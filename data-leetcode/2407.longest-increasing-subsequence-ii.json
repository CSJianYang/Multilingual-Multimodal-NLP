[
    {
        "title": "Longest Increasing Subsequence II",
        "question_content": "You are given an integer array nums and an integer k.\nFind the longest subsequence of nums that meets the following requirements:\n\n\tThe subsequence is strictly increasing and\n\tThe difference between adjacent elements in the subsequence is at most k.\n\nReturn the length of the longest subsequence that meets the requirements.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n&nbsp;\nExample 1:\n\nInput: nums = [4,2,1,4,3,4,5,8,15], k = 3\nOutput: 5\nExplanation:\nThe longest subsequence that meets the requirements is [1,3,4,5,8].\nThe subsequence has a length of 5, so we return 5.\nNote that the subsequence [1,3,4,5,8,15] does not meet the requirements because 15 - 8 = 7 is larger than 3.\n\nExample 2:\n\nInput: nums = [7,4,5,1,8,12,4,7], k = 5\nOutput: 4\nExplanation:\nThe longest subsequence that meets the requirements is [4,5,8,12].\nThe subsequence has a length of 4, so we return 4.\n\nExample 3:\n\nInput: nums = [1,5], k = 1\nOutput: 1\nExplanation:\nThe longest subsequence that meets the requirements is [1].\nThe subsequence has a length of 1, so we return 1.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i], k <= 105",
        "solutions": [
            {
                "id": 2560085,
                "title": "python-explanation-with-pictures-segment-tree",
                "content": "We store the longest increasing subsequence ended by each number in array `LIS` **(1-indexed)**. Let\\'s say the input `nums = [4,2,4,5,9]`. Initailly, `LIS[i] = 0` as we haven\\'t add any number yet.\\n\\n![image](https://assets.leetcode.com/users/images/4ce51980-476b-467d-a719-6a4d1fc7d3d7_1662868901.0119932.png)\\n\\n> The key is for a given value `a`, we should find the maximum value from `LIS[a - k: a]` ), then `LIS[a] = 1 + max(LIS[a - k : a])`.\\n\\n---\\n\\nTake the pictures below as an example:\\n\\nFor the first number `4`, the maximum length is the maximum of `LIS[1], LIS[2], LIS[3]` plus `1` (4 itself). Thus we shall look for the `max(LIS[1:4])` . Apparently, `LIS[4] = 1` which stands for `4` itself.\\n\\n![image](https://assets.leetcode.com/users/images/58c9ee31-5f70-4444-b3d7-a1e5112370a2_1662868907.3607028.png)\\n\\nThen update LIS for `2`,  we shall look for `max(LIS[1:2])`, notice the corner case that left end always larger than 0.\\n\\n![image](https://assets.leetcode.com/users/images/0132e11f-1012-478c-9ea0-8204179d75a6_1662868908.7802074.png)\\n\\nThen update LIS for `4`, we look for `max(LIS[1:4])`, since there is an `2` updated in `LIS`, thus the maximum value from the same range `LIS[1:4]` gives us 1. Then we can update `LIS[4] = 2`, implying a subsequence of `2, 4`.\\n\\n![image](https://assets.leetcode.com/users/images/0baecede-9a01-4975-869b-5d93ba424f48_1662868911.6857004.png)\\n\\nThen update LIS for `5`, we look for `max(LIS[2:5])`, `LIS[5] = LIS[4] + 1 = 3`, implying a subsequence of `2, 4, 5`.\\n\\n![image](https://assets.leetcode.com/users/images/3d1bc580-d2a7-40a1-93b5-db6272b6e5eb_1662868921.0896451.png)\\n\\n\\nThen update LIS for `9`, we look for `max(LIS[6:9])`.\\n\\n![image](https://assets.leetcode.com/users/images/2e00893c-979f-4fc6-8a01-120d8a5bd46c_1662868920.6676323.png)\\n\\nso on so forth...\\n\\nHowever, brute force ends up with O(n^2) time, we shall look for a better approach.\\n\\nIts range queries of min/max value, thus we can use segment tree.\\n\\n**python**\\n\\n```\\nclass SEG:\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * 2 * self.n\\n       \\n    def query(self, l, r):\\n        l += self.n\\n        r += self.n\\n        ans = 0\\n        while l < r:\\n            if l & 1:\\n                ans = max(ans, self.tree[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                ans = max(ans, self.tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return ans\\n    \\n    def update(self, i, val):\\n        i += self.n\\n        self.tree[i] = val\\n        while i > 1:\\n            i >>= 1\\n            self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1])\\n\\nclass Solution:\\n    def lengthOfLIS(self, A: List[int], k: int) -> int:\\n        n, ans = max(A), 1\\n        seg = SEG(n)\\n        for a in A:\\n            a -= 1\\n            premax = seg.query(max(0, a - k), a)\\n            ans = max(ans, premax + 1)\\n            seg.update(a, premax + 1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass SEG:\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * 2 * self.n\\n       \\n    def query(self, l, r):\\n        l += self.n\\n        r += self.n\\n        ans = 0\\n        while l < r:\\n            if l & 1:\\n                ans = max(ans, self.tree[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                ans = max(ans, self.tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return ans\\n    \\n    def update(self, i, val):\\n        i += self.n\\n        self.tree[i] = val\\n        while i > 1:\\n            i >>= 1\\n            self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1])\\n\\nclass Solution:\\n    def lengthOfLIS(self, A: List[int], k: int) -> int:\\n        n, ans = max(A), 1\\n        seg = SEG(n)\\n        for a in A:\\n            a -= 1\\n            premax = seg.query(max(0, a - k), a)\\n            ans = max(ans, premax + 1)\\n            seg.update(a, premax + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560010,
                "title": "c-segment-tree-with-illustration-explanation",
                "content": "We use a segment tree to keep track of the max length of all the valid numbers that can come before this one.\\nFor example, if `k = 3` and the current number is `5`, then the valid numbers before it are `2, 3, 4`. We query the segment tree in `O(logM)` to get the longest sequence out of the 3 numbers and we add `1` to it.\\n\\n#### Example\\n```\\nnums = [4,2,1,4,3,4,5,8], k = 3\\n```\\n1. `index=0`, `val = 4`\\nget the max sequence length from `[1, 2, 3]`.\\n`max value = 0`\\n`current value = 0 + 1 = 1`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|***0***|***0***|***0***|0|0|0|0|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|0|0|0|***1***|0|0|0|0|\\n\\n\\n2. `index=1`, `val = 2`\\nget the max sequence length from `[1]`.\\n`max value = 0`\\n`current value = 0 + 1 = 1`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|***0***|0|0|1|0|0|0|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|0|***1***|0|1|0|0|0|0|\\n\\n\\n3. `index=2`, `val = 1`\\nnothing can come before it\\n`max value = 0`\\n`current value = 0 + 1 = 1`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|0|1|0|1|0|0|0|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|***1***|1|0|1|0|0|0|0|\\n\\n\\n4. `index=3`, `val = 4`\\nget the max sequence length from `[1, 2, 3]`.\\n`max value = 1`\\n`current value = 1 + 1 = 2`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|***1***|***1***|***0***|1|0|0|0|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|1|1|0|***2***|0|0|0|0|\\n\\n\\n5. `index=4`, `val = 3`\\nget the max sequence length from `[1, 2]`.\\n`max value = 1`\\n`current value = 1 + 1 = 2`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|***1***|***1***|0|2|0|0|0|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|1|1|***2***|2|0|0|0|0|\\n\\n\\n6. `index=5`, `val = 4`\\nget the max sequence length from `[1, 2, 3]`.\\n`max value = 2`\\n`current value = 2 + 1 = 3`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|***1***|***1***|***2***|2|0|0|0|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|1|1|2|***3***|0|0|0|0|\\n\\n\\n7. `index=6`, `val = 5`\\nget the max sequence length from `[2, 3, 4]`.\\n`max value = 3`\\n`current value = 3 + 1 = 4`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|1|***1***|***2***|***3***|0|0|0|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|1|1|2|3|***4***|0|0|0|\\n\\n8. `index=7`, `val = 8`\\nget the max sequence length from `[5, 6, 7]`.\\n`max value = 4`\\n`current value = 4 + 1 = 5`\\n\\n_Tree_ (before)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|1|1|2|3|***4***|***0***|***0***|0|\\n\\n_Tree_ (after)\\n|num|1|2|3|4|5|6|7|8|\\n|-|-|-|-|-|-|-|-|-|\\n|max|1|1|2|3|4|0|0|***5***|\\n\\n#### Complexity:\\n```\\nTime : O(NlogN)\\nSpace: O(N)\\n```\\n\\n#### Code\\n\\n```c++\\nclass MaxSegmentTree {\\n public:\\n  int n;\\n  vector<int> tree;\\n  MaxSegmentTree(int n_) : n(n_) {\\n    int size = (int)(ceil(log2(n)));\\n    size = (2 * pow(2, size)) - 1;\\n    tree = vector<int>(size);\\n  }\\n  \\n  int max_value() { return tree[0]; }\\n\\n  int query(int l, int r) { return query_util(0, l, r, 0, n - 1); }\\n\\n  int query_util(int i, int qL, int qR, int l, int r) {\\n    if (l >= qL && r <= qR) return tree[i];\\n    if (l > qR || r < qL) return INT_MIN;\\n\\n    int m = (l + r) / 2;\\n    return max(query_util(2 * i + 1, qL, qR, l, m), query_util(2 * i + 2, qL, qR, m + 1, r));\\n  }\\n\\n  void update(int i, int val) { update_util(0, 0, n - 1, i, val); }\\n  void update_util(int i, int l, int r, int pos, int val) {\\n    if (pos < l || pos > r) return;\\n    if (l == r) {\\n      tree[i] = max(val, tree[i]);\\n      return;\\n    }\\n\\n    int m = (l + r) / 2;\\n    update_util(2 * i + 1, l, m, pos, val);\\n    update_util(2 * i + 2, m + 1, r, pos, val);\\n    tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  int lengthOfLIS(vector<int>& nums, int k) {\\n    MaxSegmentTree tree(1e5 + 1);\\n    for (int i : nums) {\\n      int lower = max(0, i - k);\\n      int cur = 1 + tree.query(lower, i - 1);\\n      tree.update(i, cur);\\n    }\\n\\n    return tree.max_value();\\n  }\\n};\\n```\\n\\n**Upvote if you find it helpful :)**",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nnums = [4,2,1,4,3,4,5,8], k = 3\\n```\n```\\nTime : O(NlogN)\\nSpace: O(N)\\n```\n```c++\\nclass MaxSegmentTree {\\n public:\\n  int n;\\n  vector<int> tree;\\n  MaxSegmentTree(int n_) : n(n_) {\\n    int size = (int)(ceil(log2(n)));\\n    size = (2 * pow(2, size)) - 1;\\n    tree = vector<int>(size);\\n  }\\n  \\n  int max_value() { return tree[0]; }\\n\\n  int query(int l, int r) { return query_util(0, l, r, 0, n - 1); }\\n\\n  int query_util(int i, int qL, int qR, int l, int r) {\\n    if (l >= qL && r <= qR) return tree[i];\\n    if (l > qR || r < qL) return INT_MIN;\\n\\n    int m = (l + r) / 2;\\n    return max(query_util(2 * i + 1, qL, qR, l, m), query_util(2 * i + 2, qL, qR, m + 1, r));\\n  }\\n\\n  void update(int i, int val) { update_util(0, 0, n - 1, i, val); }\\n  void update_util(int i, int l, int r, int pos, int val) {\\n    if (pos < l || pos > r) return;\\n    if (l == r) {\\n      tree[i] = max(val, tree[i]);\\n      return;\\n    }\\n\\n    int m = (l + r) / 2;\\n    update_util(2 * i + 1, l, m, pos, val);\\n    update_util(2 * i + 2, m + 1, r, pos, val);\\n    tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  int lengthOfLIS(vector<int>& nums, int k) {\\n    MaxSegmentTree tree(1e5 + 1);\\n    for (int i : nums) {\\n      int lower = max(0, i - k);\\n      int cur = 1 + tree.query(lower, i - 1);\\n      tree.update(i, cur);\\n    }\\n\\n    return tree.max_value();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560009,
                "title": "segment-tree-c",
                "content": "The number that can be behind number **X** is in the range **[X - k, X - 1]**, and the best value for the LIS than ends with **X** is the maximum value in that range + 1, 1 for the current element **X**.\\nSo we use a segment tree to find the maximum value in the range and update the current value for further use and calculate the result with every iteration.\\n```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    //Segment tree to return maximum in a range\\n    void upd(int ind, int val, int x, int lx, int rx) {\\n        if(lx == rx) {\\n            seg[x] = val;\\n            return;\\n        }\\n        int mid = lx + (rx - lx) / 2;\\n        if(ind <= mid)\\n            upd(ind, val, 2 * x + 1, lx, mid);\\n        else \\n            upd(ind, val, 2 * x + 2, mid + 1, rx);\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]);\\n    }\\n    int query(int l, int r, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return 0;\\n        if(lx >= l and rx <= r) return seg[x];\\n        int mid = lx + (rx - lx) / 2;\\n        return max(query(l, r, 2 * x + 1, lx, mid), query(l, r, 2 * x + 2, mid + 1, rx));\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int x = 1;\\n        while(x <= 200000) x *= 2;\\n        seg.resize(2 * x, 0);\\n        \\n        int res = 1;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            int left = max(1, nums[i] - k), right = nums[i] - 1;\\n            int q = query(left, right, 0, 0, x - 1); // check for the element in the range of [nums[i] - k, nums[i] - 1] with the maximum value\\n            res = max(res, q + 1);\\n            upd(nums[i], q + 1, 0, 0, x - 1); //update current value\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    //Segment tree to return maximum in a range\\n    void upd(int ind, int val, int x, int lx, int rx) {\\n        if(lx == rx) {\\n            seg[x] = val;\\n            return;\\n        }\\n        int mid = lx + (rx - lx) / 2;\\n        if(ind <= mid)\\n            upd(ind, val, 2 * x + 1, lx, mid);\\n        else \\n            upd(ind, val, 2 * x + 2, mid + 1, rx);\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]);\\n    }\\n    int query(int l, int r, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return 0;\\n        if(lx >= l and rx <= r) return seg[x];\\n        int mid = lx + (rx - lx) / 2;\\n        return max(query(l, r, 2 * x + 1, lx, mid), query(l, r, 2 * x + 2, mid + 1, rx));\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int x = 1;\\n        while(x <= 200000) x *= 2;\\n        seg.resize(2 * x, 0);\\n        \\n        int res = 1;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            int left = max(1, nums[i] - k), right = nums[i] - 1;\\n            int q = query(left, right, 0, 0, x - 1); // check for the element in the range of [nums[i] - k, nums[i] - 1] with the maximum value\\n            res = max(res, q + 1);\\n            upd(nums[i], q + 1, 0, 0, x - 1); //update current value\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560103,
                "title": "c-java-segment-tree-max-range-query",
                "content": "#### Strategy\\nFor every element `A[i]`, we check the range `[A[i]-k, A[i]-1]` for the current best length and add 1. \\nThe problem here is that, we also need to update the max and it is not a prefix range from 0 to some number, so fenwick tree won\\'t work.\\n\\nI figure segment tree is good for this because it supports update and query in both `O(logn)`. \\n\\n`Time O(log(max(A[i])) * N)`\\n`Space O(max(A[i]))`\\n\\n#### C++\\n```C++\\nconstexpr int N = 100001;\\nclass Solution {\\npublic: \\n    array<int, 2*N> seg{};\\n    \\n    void update(int pos, int val){ // update max\\n        pos += N;\\n        seg[pos] = val;\\n \\n        while (pos > 1) {\\n            pos >>= 1;\\n            seg[pos] = max(seg[2*pos], seg[2*pos+1]);\\n        }\\n    }\\n \\n    int query(int lo, int hi){ // query max [lo, hi)\\n        lo += N;\\n        hi += N;\\n        int res = 0;\\n \\n        while (lo < hi) {\\n            if (lo & 1) {\\n                res = max(res, seg[lo++]);\\n            }\\n            if (hi & 1) {\\n                res = max(res, seg[--hi]);\\n            }\\n            lo >>= 1;\\n            hi >>= 1;\\n        }\\n        return res;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < size(A); ++i){\\n            int l = max(0, A[i]-k);\\n            int r = A[i];\\n            int res = query(l, r) + 1; // best res for the current element\\n            ans = max(res, ans);\\n            update(A[i], res); // and update it here\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n</br>\\n\\n_____________________________\\n\\n#### Java\\n```Java\\nclass Solution {\\n\\n    int N = 100001;\\n    int[] seg = new int[2*N];\\n    \\n    void update(int pos, int val){  // update max\\n        pos += N;\\n        seg[pos] = val;\\n \\n        while (pos > 1) {\\n            pos >>= 1;\\n            seg[pos] = Math.max(seg[2*pos], seg[2*pos+1]);\\n        }\\n    }\\n \\n    int query(int lo, int hi){ // query max [lo, hi)\\n        lo += N;\\n        hi += N;\\n        int res = 0;\\n \\n        while (lo < hi) {\\n            if ((lo & 1)==1) {\\n                res = Math.max(res, seg[lo++]);\\n            }\\n            if ((hi & 1)==1) {\\n                res = Math.max(res, seg[--hi]);\\n            }\\n            lo >>= 1;\\n            hi >>= 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int lengthOfLIS(int[] A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.length; ++i){\\n            int l = Math.max(0, A[i]-k);\\n            int r = A[i];\\n            int res = query(l, r) + 1; // best res for the current element\\n            ans = Math.max(res, ans);\\n            update(A[i], res); // and update it here\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Tree"
                ],
                "code": "```C++\\nconstexpr int N = 100001;\\nclass Solution {\\npublic: \\n    array<int, 2*N> seg{};\\n    \\n    void update(int pos, int val){ // update max\\n        pos += N;\\n        seg[pos] = val;\\n \\n        while (pos > 1) {\\n            pos >>= 1;\\n            seg[pos] = max(seg[2*pos], seg[2*pos+1]);\\n        }\\n    }\\n \\n    int query(int lo, int hi){ // query max [lo, hi)\\n        lo += N;\\n        hi += N;\\n        int res = 0;\\n \\n        while (lo < hi) {\\n            if (lo & 1) {\\n                res = max(res, seg[lo++]);\\n            }\\n            if (hi & 1) {\\n                res = max(res, seg[--hi]);\\n            }\\n            lo >>= 1;\\n            hi >>= 1;\\n        }\\n        return res;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < size(A); ++i){\\n            int l = max(0, A[i]-k);\\n            int r = A[i];\\n            int res = query(l, r) + 1; // best res for the current element\\n            ans = max(res, ans);\\n            update(A[i], res); // and update it here\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```Java\\nclass Solution {\\n\\n    int N = 100001;\\n    int[] seg = new int[2*N];\\n    \\n    void update(int pos, int val){  // update max\\n        pos += N;\\n        seg[pos] = val;\\n \\n        while (pos > 1) {\\n            pos >>= 1;\\n            seg[pos] = Math.max(seg[2*pos], seg[2*pos+1]);\\n        }\\n    }\\n \\n    int query(int lo, int hi){ // query max [lo, hi)\\n        lo += N;\\n        hi += N;\\n        int res = 0;\\n \\n        while (lo < hi) {\\n            if ((lo & 1)==1) {\\n                res = Math.max(res, seg[lo++]);\\n            }\\n            if ((hi & 1)==1) {\\n                res = Math.max(res, seg[--hi]);\\n            }\\n            lo >>= 1;\\n            hi >>= 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int lengthOfLIS(int[] A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.length; ++i){\\n            int l = Math.max(0, A[i]-k);\\n            int r = A[i];\\n            int res = query(l, r) + 1; // best res for the current element\\n            ans = Math.max(res, ans);\\n            update(A[i], res); // and update it here\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578352,
                "title": "segment-tree",
                "content": "Can be solved by DP, where `dp[nums[i]] = max(dp[1] ... dp[nums[i] - 1])`.\\n\\nHowever, this leads to a quadratic solution, and we need to do it in O(n log n) based on the problem constraints. \\n\\nI wasted a lot of time trying to adapt a monostack LIS solution, but only to realize that we must use DP. \\n\\nWe just need to make the max range query to run in O(log n) instead of O(n). This can be done using a segment tree.\\n\\nNote that, for canonical LIS, we can also use the Fenwick tree. With `k`, Fenwick tree would not work as it can only answer min/max queries on the `[0, r]` interval (min/max are not commutative operations).\\n\\nIt\\'s possible to use a pair of Fenwick trees to answer mini/max queries on `[l, r]` interval, but the solution would be much more complicated, compared to a segment tree.\\n\\n**C++**\\n```cpp\\nint st[2 * (1 << 17)] = {}; // 2 ^ 16 < 100000 < 2 ^ 17\\nint query(int l, int r, int p = 1, int tl = 0, int tr = 100000) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr)\\n        return st[p];\\n    int tm = (tl + tr) / 2;\\n    return max(query(l, min(r, tm), p * 2, tl, tm), query(max(l, tm + 1), r, p * 2 + 1, tm + 1, tr));\\n}\\nint update(int pos, int new_val, int p = 1, int tl = 0, int tr = 100000) {\\n    if (tl == tr)\\n        return st[p] = new_val;\\n    int tm = (tl + tr) / 2;\\n    if (pos <= tm)\\n        return st[p] = max(update(pos, new_val, p * 2, tl, tm), st[p * 2 + 1]);\\n    return st[p] = max(st[p * 2], update(pos, new_val, p * 2 + 1, tm + 1, tr));\\n}    \\nint lengthOfLIS(vector<int>& nums, int k) {\\n    return accumulate(begin(nums), end(nums), 0, [&](int res, int n){ \\n        return update(n, query(max(0, n - k), n - 1) + 1);\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint st[2 * (1 << 17)] = {}; // 2 ^ 16 < 100000 < 2 ^ 17\\nint query(int l, int r, int p = 1, int tl = 0, int tr = 100000) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr)\\n        return st[p];\\n    int tm = (tl + tr) / 2;\\n    return max(query(l, min(r, tm), p * 2, tl, tm), query(max(l, tm + 1), r, p * 2 + 1, tm + 1, tr));\\n}\\nint update(int pos, int new_val, int p = 1, int tl = 0, int tr = 100000) {\\n    if (tl == tr)\\n        return st[p] = new_val;\\n    int tm = (tl + tr) / 2;\\n    if (pos <= tm)\\n        return st[p] = max(update(pos, new_val, p * 2, tl, tm), st[p * 2 + 1]);\\n    return st[p] = max(st[p * 2], update(pos, new_val, p * 2 + 1, tm + 1, tr));\\n}    \\nint lengthOfLIS(vector<int>& nums, int k) {\\n    return accumulate(begin(nums), end(nums), 0, [&](int res, int n){ \\n        return update(n, query(max(0, n - k), n - 1) + 1);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560504,
                "title": "clean-java",
                "content": "It is similar to https://leetcode.com/problems/count-of-smaller-numbers-after-self/\\nand https://leetcode.com/problems/range-sum-query-mutable/\\nIf you did question above, it should be similar to find range sum/max/avg\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        SegmentTree root = new SegmentTree(1, 100000);\\n        int res = 0;\\n        for (int num : nums) {\\n            int preMax = root.rangeMaxQuery(root, num - k, num - 1);\\n            root.update(root, num, preMax + 1);\\n            res = Math.max(res, preMax + 1);\\n        }\\n        return res;\\n    }\\n}\\n\\nclass SegmentTree {\\n    SegmentTree left, right;\\n    int start, end, val;\\n    public SegmentTree(int start, int end) {\\n        this.start = start;\\n        this.end = end;\\n        setup(this, start, end);\\n    }\\n    public void setup(SegmentTree node, int start, int end) {\\n        if (start == end) return;\\n        int mid = start + (end - start) / 2;\\n        if (node.left == null) {\\n            node.left = new SegmentTree(start, mid);\\n            node.right = new SegmentTree(mid + 1, end);\\n        }\\n        setup(node.left, start, mid);\\n        setup(node.right, mid + 1, end);\\n        node.val = Math.max(node.left.val, node.right.val);\\n    }\\n    \\n    public void update(SegmentTree node, int index, int val) {\\n        if (index < node.start || index > node.end) return;\\n        if (node.start == node.end && node.start == index) {\\n            node.val = val;\\n            return;\\n        }\\n        update(node.left, index, val);\\n        update(node.right, index, val);\\n        node.val = Math.max(node.left.val, node.right.val);\\n    }\\n    \\n    public int rangeMaxQuery(SegmentTree node, int start, int end) {\\n        if (node.start > end || node.end < start) return 0;\\n        if (node.start >= start && node.end <= end) return node.val;\\n        return Math.max(rangeMaxQuery(node.left, start, end), rangeMaxQuery(node.right, start, end));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        SegmentTree root = new SegmentTree(1, 100000);\\n        int res = 0;\\n        for (int num : nums) {\\n            int preMax = root.rangeMaxQuery(root, num - k, num - 1);\\n            root.update(root, num, preMax + 1);\\n            res = Math.max(res, preMax + 1);\\n        }\\n        return res;\\n    }\\n}\\n\\nclass SegmentTree {\\n    SegmentTree left, right;\\n    int start, end, val;\\n    public SegmentTree(int start, int end) {\\n        this.start = start;\\n        this.end = end;\\n        setup(this, start, end);\\n    }\\n    public void setup(SegmentTree node, int start, int end) {\\n        if (start == end) return;\\n        int mid = start + (end - start) / 2;\\n        if (node.left == null) {\\n            node.left = new SegmentTree(start, mid);\\n            node.right = new SegmentTree(mid + 1, end);\\n        }\\n        setup(node.left, start, mid);\\n        setup(node.right, mid + 1, end);\\n        node.val = Math.max(node.left.val, node.right.val);\\n    }\\n    \\n    public void update(SegmentTree node, int index, int val) {\\n        if (index < node.start || index > node.end) return;\\n        if (node.start == node.end && node.start == index) {\\n            node.val = val;\\n            return;\\n        }\\n        update(node.left, index, val);\\n        update(node.right, index, val);\\n        node.val = Math.max(node.left.val, node.right.val);\\n    }\\n    \\n    public int rangeMaxQuery(SegmentTree node, int start, int end) {\\n        if (node.start > end || node.end < start) return 0;\\n        if (node.start >= start && node.end <= end) return node.val;\\n        return Math.max(rangeMaxQuery(node.left, start, end), rangeMaxQuery(node.right, start, end));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560128,
                "title": "segemet-tree-c-max-range-query",
                "content": "```\\n\\n\\tclass SegmentTree{\\n\\t\\tpublic:\\n        vector<int> t;\\n        int n;\\n        \\n        SegmentTree(int n){\\n            this->n = n;\\n            t.assign(4*n,0);\\n        }\\n        \\n        int get(int v,int l,int r,int tl,int tr){\\n            if(l>r) return 0;\\n\\n            if(l==tl&&tr==r){\\n                return t[v];\\n            }\\n\\n            int m = (tl+tr)/2;\\n\\n            int left = get(2*v,l,min(m,r),tl,m);\\n            int right = get(2*v+1,max(m+1,l),r,m+1,tr);\\n\\n            return max(left,right);\\n        }\\n        void update(int v, int tl, int tr, int pos, int new_val) {\\n            if (tl == tr) {\\n                t[v] = new_val;\\n            } \\n            else {\\n                int tm = (tl + tr) / 2;\\n                if (pos <= tm)\\n                    update(v*2, tl, tm, pos, new_val);\\n                else\\n                    update(v*2+1, tm+1, tr, pos, new_val);\\n                t[v] = max(t[v*2], t[v*2+1]);\\n            }\\n        }\\n        \\n    };\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        SegmentTree tr(100002);\\n        int ans = 0;\\n        for(int i : nums){\\n            int val = tr.get(1, max(i-k,0), max(i-1,0), 0, 1e5);\\n            ans = max(ans,val+1);\\n            tr.update(1, 0, 1e5, i, val+1);\\n        }\\n        return ans;    \\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\tclass SegmentTree{\\n\\t\\tpublic:\\n        vector<int> t;\\n        int n;\\n        \\n        SegmentTree(int n){\\n            this->n = n;\\n            t.assign(4*n,0);\\n        }\\n        \\n        int get(int v,int l,int r,int tl,int tr){\\n            if(l>r) return 0;\\n\\n            if(l==tl&&tr==r){\\n                return t[v];\\n            }\\n\\n            int m = (tl+tr)/2;\\n\\n            int left = get(2*v,l,min(m,r),tl,m);\\n            int right = get(2*v+1,max(m+1,l),r,m+1,tr);\\n\\n            return max(left,right);\\n        }\\n        void update(int v, int tl, int tr, int pos, int new_val) {\\n            if (tl == tr) {\\n                t[v] = new_val;\\n            } \\n            else {\\n                int tm = (tl + tr) / 2;\\n                if (pos <= tm)\\n                    update(v*2, tl, tm, pos, new_val);\\n                else\\n                    update(v*2+1, tm+1, tr, pos, new_val);\\n                t[v] = max(t[v*2], t[v*2+1]);\\n            }\\n        }\\n        \\n    };\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        SegmentTree tr(100002);\\n        int ans = 0;\\n        for(int i : nums){\\n            int val = tr.get(1, max(i-k,0), max(i-1,0), 0, 1e5);\\n            ans = max(ans,val+1);\\n            tr.update(1, 0, 1e5, i, val+1);\\n        }\\n        return ans;    \\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560316,
                "title": "why-can-t-we-use-dp",
                "content": "I trying my dp approach to solve this problem and hence it took me nearly 1 hour and 15 minutes and able to solve only two problems this time\\n\\n**my question is that, why aren\\'t we use DP here ??**",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2760065,
                "title": "c-segment-tree-cleanest-code-easiest-to-understand",
                "content": "```\\nconst int N=100005;\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n    void update(int p,int val,int idx,int l,int r){\\n        if(p<l or p>r){\\n            return;\\n        }\\n        if(l==r){\\n            tree[idx]=val;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        update(p,val,2*idx+1,l,mid);\\n        update(p,val,2*idx+2,mid+1,r);\\n        tree[idx]=max(tree[2*idx+1],tree[2*idx+2]);\\n    }\\n    int query(int ql,int qr,int idx,int l,int r){\\n        if(ql>r or qr<l){\\n            return INT_MIN;\\n        }\\n        if(ql<=l and qr>=r){\\n            return tree[idx];\\n        }\\n         int mid=(l+r)>>1;\\n        int lt=query(ql,qr,2*idx+1,l,mid);\\n        int rt=query(ql,qr,2*idx+2,mid+1,r);\\n        return max(lt,rt);\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=0;\\n        tree=vector<int> (4*N,0);\\n        //normally if we had to write dp arroach what would we have done\\n        //we would have checked if the LIS ends at our current nums[i]\\n        //then we would iterate over from 0 till i-1 and consider those nums[i] whose diff with this nums[i] is atmost k\\n        //and take the longest one among them and add 1\\n        //but this would result in TLE here,so here we optimized that query using segment tree\\n        for(int i=0;i<nums.size();i++){\\n            int left=max(0,nums[i]-k);\\n            int right=nums[i]-1;\\n            int q=query(left,right,0,0,1e5);\\n            res=max(res,q+1);\\n            update(nums[i],q+1,0,0,1e5);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N=100005;\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n    void update(int p,int val,int idx,int l,int r){\\n        if(p<l or p>r){\\n            return;\\n        }\\n        if(l==r){\\n            tree[idx]=val;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        update(p,val,2*idx+1,l,mid);\\n        update(p,val,2*idx+2,mid+1,r);\\n        tree[idx]=max(tree[2*idx+1],tree[2*idx+2]);\\n    }\\n    int query(int ql,int qr,int idx,int l,int r){\\n        if(ql>r or qr<l){\\n            return INT_MIN;\\n        }\\n        if(ql<=l and qr>=r){\\n            return tree[idx];\\n        }\\n         int mid=(l+r)>>1;\\n        int lt=query(ql,qr,2*idx+1,l,mid);\\n        int rt=query(ql,qr,2*idx+2,mid+1,r);\\n        return max(lt,rt);\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=0;\\n        tree=vector<int> (4*N,0);\\n        //normally if we had to write dp arroach what would we have done\\n        //we would have checked if the LIS ends at our current nums[i]\\n        //then we would iterate over from 0 till i-1 and consider those nums[i] whose diff with this nums[i] is atmost k\\n        //and take the longest one among them and add 1\\n        //but this would result in TLE here,so here we optimized that query using segment tree\\n        for(int i=0;i<nums.size();i++){\\n            int left=max(0,nums[i]-k);\\n            int right=nums[i]-1;\\n            int q=query(left,right,0,0,1e5);\\n            res=max(res,q+1);\\n            update(nums[i],q+1,0,0,1e5);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561986,
                "title": "python-easy-solution-well-explained",
                "content": "```\\n# Iterative Segment Tree\\nclass SegmentTree:\\n    def __init__(self, n, fn):\\n        self.n = n\\n        self.fn = fn\\n        self.tree = [0] * (2 * n)\\n       \\n    def query(self, l, r):\\n        l += self.n\\n        r += self.n\\n        res = 0\\n        while l < r:\\n            if l & 1:\\n                res = self.fn(res, self.tree[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                res = self.fn(res, self.tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return res\\n    \\n    def update(self, i, val):\\n        i += self.n\\n        self.tree[i] = val\\n        while i > 1:\\n            i >>= 1\\n            self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])\\nclass Solution:\\n    # Inspired from the solution of Bakerston\\n    # Basically we make an array to store nums in increasing order and find what is the size of the LIS ending there\\n\\t# Our array is 0 to max element from the given nums\\n    # We need to find the elements smaller than n till the limit k which are in nums before this num\\n    # so simply all the elements previous to our current num are smaller(till k smaller)\\n    # now how to find LIS\\'s size?\\n    # Since we are updating elements left to right in our array we know the LIS\\'s size of elements smaller\\n    # than our current num\\n    # we just need to find the largest LIS size in range (num - k, num) from our array\\n    # This is a range query and can be efficiently answered using Segment Trees.\\n    \\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = max(nums)\\n        res = 1\\n        tree = SegmentTree(n, max)\\n        for num in nums:\\n            num -= 1\\n            mm = tree.query(max(0, num - k), num)\\n            tree.update(num, mm + 1)\\n            res = max(res, mm + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Iterative Segment Tree\\nclass SegmentTree:\\n    def __init__(self, n, fn):\\n        self.n = n\\n        self.fn = fn\\n        self.tree = [0] * (2 * n)\\n       \\n    def query(self, l, r):\\n        l += self.n\\n        r += self.n\\n        res = 0\\n        while l < r:\\n            if l & 1:\\n                res = self.fn(res, self.tree[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                res = self.fn(res, self.tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return res\\n    \\n    def update(self, i, val):\\n        i += self.n\\n        self.tree[i] = val\\n        while i > 1:\\n            i >>= 1\\n            self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])\\nclass Solution:\\n    # Inspired from the solution of Bakerston\\n    # Basically we make an array to store nums in increasing order and find what is the size of the LIS ending there\\n\\t# Our array is 0 to max element from the given nums\\n    # We need to find the elements smaller than n till the limit k which are in nums before this num\\n    # so simply all the elements previous to our current num are smaller(till k smaller)\\n    # now how to find LIS\\'s size?\\n    # Since we are updating elements left to right in our array we know the LIS\\'s size of elements smaller\\n    # than our current num\\n    # we just need to find the largest LIS size in range (num - k, num) from our array\\n    # This is a range query and can be efficiently answered using Segment Trees.\\n    \\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = max(nums)\\n        res = 1\\n        tree = SegmentTree(n, max)\\n        for num in nums:\\n            num -= 1\\n            mm = tree.query(max(0, num - k), num)\\n            tree.update(num, mm + 1)\\n            res = max(res, mm + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560824,
                "title": "python-binary-search-and-dp-without-segment-tree",
                "content": "```\\nfrom collections import defaultdict\\nfrom bisect import insort, bisect_left\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        \\n        dp_tracker = defaultdict(list)\\n        n = len(nums)\\n        dp = [1]*n\\n        max_till_now = 1\\n        for i in range(n):\\n            temp_ans = 1\\n            max_ans = 0\\n            \\n            for j in range(max_till_now, 0, -1):\\n                ind = bisect_left(dp_tracker[j], nums[i])\\n                if ind != 0:\\n                    if k >= (nums[i] - dp_tracker[j][ind-1]) > 0:\\n                        max_ans = j\\n                        break\\n                \\n            dp[i] = temp_ans + max_ans\\n            bisect.insort(dp_tracker[dp[i]], nums[i])\\n            \\n            max_till_now = max(max_till_now, dp[i])\\n            \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import insort, bisect_left\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        \\n        dp_tracker = defaultdict(list)\\n        n = len(nums)\\n        dp = [1]*n\\n        max_till_now = 1\\n        for i in range(n):\\n            temp_ans = 1\\n            max_ans = 0\\n            \\n            for j in range(max_till_now, 0, -1):\\n                ind = bisect_left(dp_tracker[j], nums[i])\\n                if ind != 0:\\n                    if k >= (nums[i] - dp_tracker[j][ind-1]) > 0:\\n                        max_ans = j\\n                        break\\n                \\n            dp[i] = temp_ans + max_ans\\n            bisect.insort(dp_tracker[dp[i]], nums[i])\\n            \\n            max_till_now = max(max_till_now, dp[i])\\n            \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563733,
                "title": "c-sqrt-decomposition-dp-o-n-sqrt-n-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ma=0,dp[318][318];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<nums.size();++i){\\n            if(i&&nums[i]==nums[i-1])continue;\\n            int v=nums[i]-1,t=max(nums[i]-k,0),vh=v%317,vn=v/317,vnh=nums[i]%317,vnn=nums[i]/317;\\n            if(vn==t/317)\\n                for(int j=v%317;j>=t%317;--j)\\n                    dp[vnn][vnh]=max(dp[vn][j]+1,dp[vnn][vnh]);\\n            else{\\n                for(int j=v%317;j>=0;--j)\\n                    dp[vnn][vnh]=max(dp[vn][j]+1,dp[vnn][vnh]);\\n                for(int j=vn-1;j>t/317;--j)\\n                    dp[vnn][vnh]=max(dp[j][317]+1,dp[vnn][vnh]);\\n                for(int j=316;j>=t%317;--j)\\n                    dp[vnn][vnh]=max(dp[t/317][j]+1,dp[vnn][vnh]);\\n            }\\n            dp[vnn][317]=max(dp[vnn][vnh],dp[vnn][317]);\\n            ma=max(ma,dp[vnn][vnh]);\\n        }\\n        return ma;\\n    }\\n};\\n```\\n1. DP[i] means the LIS ending with i\\n2. DP[i] = max(DP[i], DP[i-1~i-k]) \\n3. Let dp[i][j] = DP[i*m+j]  (0 < j < m)\\n4. Let dp[i][317] = max value of i*317 + 0~316\\n5. dp[i][j] = value of i*317 + 0~316\\n6. If k is big: search dp[i][317]\\n   else: search each dp[i][j]",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ma=0,dp[318][318];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<nums.size();++i){\\n            if(i&&nums[i]==nums[i-1])continue;\\n            int v=nums[i]-1,t=max(nums[i]-k,0),vh=v%317,vn=v/317,vnh=nums[i]%317,vnn=nums[i]/317;\\n            if(vn==t/317)\\n                for(int j=v%317;j>=t%317;--j)\\n                    dp[vnn][vnh]=max(dp[vn][j]+1,dp[vnn][vnh]);\\n            else{\\n                for(int j=v%317;j>=0;--j)\\n                    dp[vnn][vnh]=max(dp[vn][j]+1,dp[vnn][vnh]);\\n                for(int j=vn-1;j>t/317;--j)\\n                    dp[vnn][vnh]=max(dp[j][317]+1,dp[vnn][vnh]);\\n                for(int j=316;j>=t%317;--j)\\n                    dp[vnn][vnh]=max(dp[t/317][j]+1,dp[vnn][vnh]);\\n            }\\n            dp[vnn][317]=max(dp[vnn][vnh],dp[vnn][317]);\\n            ma=max(ma,dp[vnn][vnh]);\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560378,
                "title": "python-n-2-solution-but-ac-numpy",
                "content": "I\\'m sorry that using numpy \\n\\n```python\\nimport numpy as np\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n\\t\\t# original thinking, but I know it must TLE\\n        # len_mapping = {}\\n        # max_len = 0\\n        # for i in nums:\\n        #     len_mapping[i] = max([c + 1 for v, c in len_mapping.items() if (i - v) >= 0 and (i - v) <= k], default=1)\\n        #     max_len = max(len_mapping[i], max_len)\\n        # return max_len\\n\\t\\t\\n\\t\\t# but I don\\'t want to implement segement tree, so I give numpy a try\\n\\t\\t# while in the inteview you should always use the segment tree which lead to nlogn instead of n^2\\n        len_mapping = np.array([0] * (10** 5 + 2))\\n        max_len = 0\\n        for i in nums:\\n            start_idx = max(i - k, 0)\\n            len_mapping[i] = (len_mapping[start_idx:i].max()) + 1\\n            max_len = max(len_mapping[i], max_len)\\n        return max_len\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nimport numpy as np\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n\\t\\t# original thinking, but I know it must TLE\\n        # len_mapping = {}\\n        # max_len = 0\\n        # for i in nums:\\n        #     len_mapping[i] = max([c + 1 for v, c in len_mapping.items() if (i - v) >= 0 and (i - v) <= k], default=1)\\n        #     max_len = max(len_mapping[i], max_len)\\n        # return max_len\\n\\t\\t\\n\\t\\t# but I don\\'t want to implement segement tree, so I give numpy a try\\n\\t\\t# while in the inteview you should always use the segment tree which lead to nlogn instead of n^2\\n        len_mapping = np.array([0] * (10** 5 + 2))\\n        max_len = 0\\n        for i in nums:\\n            start_idx = max(i - k, 0)\\n            len_mapping[i] = (len_mapping[start_idx:i].max()) + 1\\n            max_len = max(len_mapping[i], max_len)\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563757,
                "title": "c-fast-easy-segment-tree",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/797375784/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\nvector<int> ar;\\nint x;\\n\\nvoid build(int v, int l, int r) {\\n    if (l == r) {\\n        seg[v] = ar[l];\\n    }\\n    else {\\n        int mid = (l + r) / 2;\\n        build(2 * v, l, mid);\\n        build(2 * v + 1, mid + 1, r);\\n        seg[v] = max(seg[2 * v], seg[2 * v + 1]);\\n    }\\n}\\n\\nint f(int v, int a, int b, int l, int r) {\\n    //cout << a << \" \" << b << \" \" << l << \" \" << r << endl;\\n    if (l > r) {return 0;}\\n    if (a == l && b == r) {return seg[v];}\\n    if(l==r){return seg[l];}\\n    int mid = (a + b) / 2;\\n    return max(\\n               f(2 * v, a, mid, l, min(mid, r)),\\n               f(2 * v + 1, mid + 1, b, max(l, mid + 1), r)\\n           );\\n}\\n\\nvoid update(int a, int k) {\\n    if(a==1){\\n        int xx=x;\\n        while(xx>=1){seg[xx]=max(seg[xx],1);xx/=2;}\\n        return;\\n    }\\n    int val = f(1, x, 2 * x - 1, max(x, x - 1 + a - k), max(x, x - 1 + a - 1));\\n    int nn = x - 1 + a;\\n    val = max(val + 1, 1);\\n    //cout << val << endl;\\n    while (nn >= 1) {\\n        seg[nn] = max(seg[nn],val); nn /= 2;\\n    }\\n}\\n\\nint lengthOfLIS(vector<int>& nums, int k) {\\n    x = 0; for (int xx : nums) {x = max(x, xx);}\\n    int xx = log2(x);\\n    if ((1 << xx) != x) {\\n        xx++;\\n    }\\n    ar = nums;\\n    x = 1 << xx;\\n    while (ar.size() < x) {ar.push_back(0);}\\n    seg.resize(2 * x);\\n    for (int i = 0; i < 2 * x; i++) {seg[i] = 0;}\\n\\n    //build(1, 0, x - 1);\\n    /*    for (int i = 1; i < 2 * x; i++) {\\n            cout << seg[i] << \" \";\\n            if ((1 << ((int)log2(i + 1)) - 1) == (1 << ((int)log2(i)))) {cout << endl;}\\n        }\\n        cout << endl;*/\\n    //return 0;\\n    int ans = 0;\\n    for (int a : nums) {\\n        update(a, k);\\n        /*        for (int i = 1; i < 2 * x; i++) {\\n                    cout << seg[i] << \" \";\\n                    if ((1 << ((int)log2(i + 1)) - 1) == (1 << ((int)log2(i)))) {cout << endl;}\\n                }\\n                cout << endl;*/\\n        ans = max(ans, seg[a + x - 1]);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\nvector<int> ar;\\nint x;\\n\\nvoid build(int v, int l, int r) {\\n    if (l == r) {\\n        seg[v] = ar[l];\\n    }\\n    else {\\n        int mid = (l + r) / 2;\\n        build(2 * v, l, mid);\\n        build(2 * v + 1, mid + 1, r);\\n        seg[v] = max(seg[2 * v], seg[2 * v + 1]);\\n    }\\n}\\n\\nint f(int v, int a, int b, int l, int r) {\\n    //cout << a << \" \" << b << \" \" << l << \" \" << r << endl;\\n    if (l > r) {return 0;}\\n    if (a == l && b == r) {return seg[v];}\\n    if(l==r){return seg[l];}\\n    int mid = (a + b) / 2;\\n    return max(\\n               f(2 * v, a, mid, l, min(mid, r)),\\n               f(2 * v + 1, mid + 1, b, max(l, mid + 1), r)\\n           );\\n}\\n\\nvoid update(int a, int k) {\\n    if(a==1){\\n        int xx=x;\\n        while(xx>=1){seg[xx]=max(seg[xx],1);xx/=2;}\\n        return;\\n    }\\n    int val = f(1, x, 2 * x - 1, max(x, x - 1 + a - k), max(x, x - 1 + a - 1));\\n    int nn = x - 1 + a;\\n    val = max(val + 1, 1);\\n    //cout << val << endl;\\n    while (nn >= 1) {\\n        seg[nn] = max(seg[nn],val); nn /= 2;\\n    }\\n}\\n\\nint lengthOfLIS(vector<int>& nums, int k) {\\n    x = 0; for (int xx : nums) {x = max(x, xx);}\\n    int xx = log2(x);\\n    if ((1 << xx) != x) {\\n        xx++;\\n    }\\n    ar = nums;\\n    x = 1 << xx;\\n    while (ar.size() < x) {ar.push_back(0);}\\n    seg.resize(2 * x);\\n    for (int i = 0; i < 2 * x; i++) {seg[i] = 0;}\\n\\n    //build(1, 0, x - 1);\\n    /*    for (int i = 1; i < 2 * x; i++) {\\n            cout << seg[i] << \" \";\\n            if ((1 << ((int)log2(i + 1)) - 1) == (1 << ((int)log2(i)))) {cout << endl;}\\n        }\\n        cout << endl;*/\\n    //return 0;\\n    int ans = 0;\\n    for (int a : nums) {\\n        update(a, k);\\n        /*        for (int i = 1; i < 2 * x; i++) {\\n                    cout << seg[i] << \" \";\\n                    if ((1 << ((int)log2(i + 1)) - 1) == (1 << ((int)log2(i)))) {cout << endl;}\\n                }\\n                cout << endl;*/\\n        ans = max(ans, seg[a + x - 1]);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2561503,
                "title": "q-help-why-python-segment-tree-is-tle",
                "content": "I don\\'t understand why this python Segment Tree solution TLE\\'s.\\n\\nWhat am I doing wrong? help will be appreciated\\n\\n```\\nclass SegmentTree:\\n    \\n    def __init__(self, A: list[int]):\\n        n = len(A)\\n        closest_2_power = math.ceil(math.log2(n))\\n        # pad\\n        A += [0] * ((2 << (closest_2_power-1)) - n)\\n        \\n        self._closest_2_power = closest_2_power\\n        self._arr = A\\n        self.tree = [0] * (2*len(A) - 1)\\n        \\n        self._build_segtree(0, 0, len(self._arr) - 1)\\n        \\n    \\n    # Building maximum query segment tree\\n    def _build_segtree(self, tree_index, left, right):\\n        # Leaf node\\n        if left == right:\\n            self.tree[tree_index] = self._arr[left]\\n            return self.tree[tree_index]\\n    \\n        mid = left + (right - left) // 2\\n        left_seg = self._build_segtree(tree_index * 2 + 1, left, mid)\\n        right_seg = self._build_segtree(tree_index * 2 + 2, mid + 1, right)\\n        return max(left_seg, right_seg)\\n    \\n    def query(self, query_left, query_right, tree_index = None, seg_left = None, seg_right = None):\\n        # default values\\n        if seg_left is None:\\n            seg_left = 0\\n        if seg_right is None:\\n            seg_right = len(self._arr) - 1\\n        if tree_index is None:\\n            tree_index = 0\\n        \\n        # if segment interval is fully contained by query\\n        if query_left <= seg_left and query_right >= seg_right:\\n            return self.tree[tree_index]\\n        \\n        # if not contained\\n        if query_right < seg_left or query_left > seg_right:\\n            return 0\\n        \\n        # else divide and conquer both sides\\n        mid = seg_left + (seg_right - seg_left) // 2\\n        left_seg = self.query(query_left, query_right, tree_index*2+1, seg_left, mid)\\n        right_seg = self.query(query_left, query_right, tree_index*2+2, mid + 1, seg_right)\\n        return max(left_seg, right_seg)\\n    \\n    \\n    def update(self, original_index, new_value):\\n        first_leaf_index = (2 ** self._closest_2_power) - 1\\n        tree_index = first_leaf_index + original_index\\n        self.tree[tree_index] = new_value\\n        \\n        # update parent interval\\n        parent_index = (tree_index - 1) // 2\\n        while parent_index >= 0:\\n            self.tree[parent_index] = max(self.tree[parent_index], new_value)\\n            parent_index = (parent_index - 1) // 2\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        MAX = max(nums)\\n        A = [0] * (MAX + 1)\\n        \\n        seg_tree = SegmentTree(A)\\n        ans = 0\\n        \\n        for v in nums:\\n            max_interval_sum = seg_tree.query(max(0, v-k), v-1)\\n            v_lis = max(1, 1 + max_interval_sum)\\n            seg_tree.update(v, v_lis)\\n            ans = max(ans, v_lis)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass SegmentTree:\\n    \\n    def __init__(self, A: list[int]):\\n        n = len(A)\\n        closest_2_power = math.ceil(math.log2(n))\\n        # pad\\n        A += [0] * ((2 << (closest_2_power-1)) - n)\\n        \\n        self._closest_2_power = closest_2_power\\n        self._arr = A\\n        self.tree = [0] * (2*len(A) - 1)\\n        \\n        self._build_segtree(0, 0, len(self._arr) - 1)\\n        \\n    \\n    # Building maximum query segment tree\\n    def _build_segtree(self, tree_index, left, right):\\n        # Leaf node\\n        if left == right:\\n            self.tree[tree_index] = self._arr[left]\\n            return self.tree[tree_index]\\n    \\n        mid = left + (right - left) // 2\\n        left_seg = self._build_segtree(tree_index * 2 + 1, left, mid)\\n        right_seg = self._build_segtree(tree_index * 2 + 2, mid + 1, right)\\n        return max(left_seg, right_seg)\\n    \\n    def query(self, query_left, query_right, tree_index = None, seg_left = None, seg_right = None):\\n        # default values\\n        if seg_left is None:\\n            seg_left = 0\\n        if seg_right is None:\\n            seg_right = len(self._arr) - 1\\n        if tree_index is None:\\n            tree_index = 0\\n        \\n        # if segment interval is fully contained by query\\n        if query_left <= seg_left and query_right >= seg_right:\\n            return self.tree[tree_index]\\n        \\n        # if not contained\\n        if query_right < seg_left or query_left > seg_right:\\n            return 0\\n        \\n        # else divide and conquer both sides\\n        mid = seg_left + (seg_right - seg_left) // 2\\n        left_seg = self.query(query_left, query_right, tree_index*2+1, seg_left, mid)\\n        right_seg = self.query(query_left, query_right, tree_index*2+2, mid + 1, seg_right)\\n        return max(left_seg, right_seg)\\n    \\n    \\n    def update(self, original_index, new_value):\\n        first_leaf_index = (2 ** self._closest_2_power) - 1\\n        tree_index = first_leaf_index + original_index\\n        self.tree[tree_index] = new_value\\n        \\n        # update parent interval\\n        parent_index = (tree_index - 1) // 2\\n        while parent_index >= 0:\\n            self.tree[parent_index] = max(self.tree[parent_index], new_value)\\n            parent_index = (parent_index - 1) // 2\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        MAX = max(nums)\\n        A = [0] * (MAX + 1)\\n        \\n        seg_tree = SegmentTree(A)\\n        ans = 0\\n        \\n        for v in nums:\\n            max_interval_sum = seg_tree.query(max(0, v-k), v-1)\\n            v_lis = max(1, 1 + max_interval_sum)\\n            seg_tree.update(v, v_lis)\\n            ans = max(ans, v_lis)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560747,
                "title": "java-easy-segment-tree",
                "content": "```\\nclass Solution {\\n    int N = 1_00_001;\\n    int seg[];\\n    void update(int idx , int x , int low , int high , int i){\\n        if(low == high){\\n            seg[idx] = x;\\n            return;\\n        }\\n        int mid = low + (high - low) / 2;\\n        if(i <= mid){\\n            update(2 * idx + 1 , x , low , mid , i);\\n        }\\n        else{\\n            update(2 * idx + 2 , x , mid + 1 , high , i);\\n        }\\n        seg[idx] = Math.max(seg[2 * idx + 1], seg[2 * idx + 2]);\\n    }\\n    int query(int l , int r , int low , int high , int idx){ // max query\\n        if(l > high || r < low){\\n            return Integer.MIN_VALUE;\\n        }\\n        if(low >= l && high <= r){\\n            return seg[idx];\\n        }\\n        int mid = low + (high - low) / 2;\\n        int left = query(l , r , low , mid , 2 * idx + 1);\\n        int right = query(l , r , mid + 1 , high , 2 * idx + 2);\\n        return Math.max(left , right);\\n    }\\n    public int lengthOfLIS(int[] a, int k) {\\n        int n = a.length;\\n        int max = 0;\\n        seg = new int[4 * N];\\n        for(int i = 0; i < n; i++){\\n            int l = Math.max(0 , a[i] - k);\\n            int r = a[i] - 1;\\n            int res = query(l , r , 0 , N - 1 , 0) + 1; // search in all the possible previous elements ([l , r]) and add \\'1\\' to the max                                                                length with this previous\\n            max = Math.max(max , res); // update max\\n            update(0 , res , 0 , N - 1 , a[i]); // update segment tree\\'s a[i]th index with res\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    int N = 1_00_001;\\n    int seg[];\\n    void update(int idx , int x , int low , int high , int i){\\n        if(low == high){\\n            seg[idx] = x;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3668442,
                "title": "does-anyone-know-a-monotonic-queue-solution",
                "content": "Does anyone know a monotonic queue solution?",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2560841,
                "title": "c-segment-tree-o-nlogn",
                "content": "For any `nums[i]`, its last element in the increasing seq will range from `nums[i]-k` to `nums[i]-1`. Find the max length of elements in this Range.\\n```\\nclass Solution {\\npublic:\\n    const int n = 100001;\\n    int nums[4*100001] = {0};\\n    void update(int n,int id,int val,int l,int h){\\n        if(l<=h){\\n            if(l==h){\\n                if(id==l) nums[n] = max(nums[n],val);\\n                return;\\n            }\\n            else{\\n                int mid = (l+h)/2;\\n                if(id>=l && id<=mid) update(2*n+1,id,val,l,mid);\\n                else update(2*n+2,id,val,mid+1,h);\\n                nums[n] = max(nums[2*n+1],nums[2*n+2]);\\n            }\\n        }\\n    }\\n    int find(int i,int j,int n,int l,int h){\\n        if(l<=h){\\n            if(i<=l && j>=h) return nums[n];\\n            if((j<l || h<i) || l==h) return 0;\\n            int mid = (l+h)/2;\\n            int a = find(i,j,2*n+1,l,mid);\\n            int b = find(i,j,2*n+2,mid+1,h);\\n            return max(a,b);\\n        }\\n        else return 0;\\n    }\\n    int lengthOfLIS(vector<int>& arr, int k) {\\n        int re = 0;\\n        for(int i = 0; i<arr.size();++i){\\n            int x = max(1,arr[i]-k);\\n            int k = find(x,arr[i]-1,0,0,n);\\n            re = max(re,k+1);\\n            update(0,arr[i],k+1,0,n);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int n = 100001;\\n    int nums[4*100001] = {0};\\n    void update(int n,int id,int val,int l,int h){\\n        if(l<=h){\\n            if(l==h){\\n                if(id==l) nums[n] = max(nums[n],val);\\n                return;\\n            }\\n            else{\\n                int mid = (l+h)/2;\\n                if(id>=l && id<=mid) update(2*n+1,id,val,l,mid);\\n                else update(2*n+2,id,val,mid+1,h);\\n                nums[n] = max(nums[2*n+1],nums[2*n+2]);\\n            }\\n        }\\n    }\\n    int find(int i,int j,int n,int l,int h){\\n        if(l<=h){\\n            if(i<=l && j>=h) return nums[n];\\n            if((j<l || h<i) || l==h) return 0;\\n            int mid = (l+h)/2;\\n            int a = find(i,j,2*n+1,l,mid);\\n            int b = find(i,j,2*n+2,mid+1,h);\\n            return max(a,b);\\n        }\\n        else return 0;\\n    }\\n    int lengthOfLIS(vector<int>& arr, int k) {\\n        int re = 0;\\n        for(int i = 0; i<arr.size();++i){\\n            int x = max(1,arr[i]-k);\\n            int k = find(x,arr[i]-1,0,0,n);\\n            re = max(re,k+1);\\n            update(0,arr[i],k+1,0,n);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560180,
                "title": "standard-segmenttree-dp-java",
                "content": "**DP Defination**\\ndp[i] = length of LIS such that last element is i\\nUsing this idea, if we are at ```arr[j]```,  then previous element of this LIS ending at ```arr[j]``` can be in the range of ```[arr[j] - k, arr[j] - 1]```. So we need to find max value of dp in the range of this.\\nThis can be done faster using Segment tree.\\n\\n**Segment tree Operations:**\\n1. point update\\n2. range max\\n\\n**Key Idea:**\\nUse values of ```arr[i]``` as the indexes in segment tree. Then when we want to find max of dp value in range ```[arr[j] - k, arr[j] - 1]```, we can treat them as indexes and query rangeMax.\\n\\nFinal ans is max of entire range i.e. ```segTree.max(1, 100000 + 1)```;\\n\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        //int[] dp = new int[100000 + 5];\\n        SegmentTree st = new SegmentTree(100000 + 5);\\n        st.set(nums[0], 1);\\n        //dp[nums[0]] = 1;\\n        for(int i = 1; i < nums.length; i++) {\\n            int minN = Math.max(0, nums[i] - k); // 10 - 5 = 5\\n            st.set(nums[i], Math.max(st.get(nums[i], nums[i]), 1 + st.get(minN, nums[i])));\\n            st.set(nums[i], Math.max(st.get(nums[i], nums[i] + 1) , 1));\\n        }\\n        return (int)st.get(1, 100000 + 2);\\n    }\\n}\\n\\n  class SegmentTree {\\n\\n    int size;\\n    long[] arr;\\n\\n    int inputSize;\\n\\n    private long neutralElement = Long.MIN_VALUE / 2;\\n\\n    public SegmentTree(int n) {\\n      size = 1;\\n      inputSize = n;\\n      while (size < n) size *= 2;\\n      arr = new long[2 * size - 1];\\n      Arrays.fill(arr, neutralElement);\\n    }\\n\\n    public void print() {\\n      //Arrays.stream(arr).forEachOrdered(x -> System.out.print(x + \" \"));\\n    }\\n\\n    private void build(long[] input, int x, int lx, int rx) {\\n      if (rx - lx == 1) {\\n        if (lx < inputSize)\\n          arr[x] = input[lx];\\n        return;\\n      }\\n      int mid = (lx + rx) / 2;\\n      build(input, 2 * x + 1, lx, mid);\\n      build(input, 2 * x + 2, mid, rx);\\n      arr[x] = op(arr[2 * x + 1], arr[2 * x + 2]);\\n    }\\n\\n    public void build(long[] arr) {\\n      build(arr, 0, 0, size);\\n    }\\n\\n    private void set(int index, long val, int x, int lx, int rx) {\\n      if (rx - lx == 1) {\\n        arr[x] = val;\\n        return;\\n      }\\n      int mid = (lx + rx) / 2;\\n      if (index < mid) {\\n        set(index, val, 2 * x + 1, lx, mid);\\n      } else {\\n        set(index, val, 2 * x + 2, mid, rx);\\n      }\\n      arr[x] = op(arr[2 * x + 1], arr[2 * x + 2]);\\n    }\\n\\n    public void set(int index, long val) {\\n      set(index, val, 0, 0, size);\\n    }\\n\\n    public long get(int l, int r) { //inclusive l - exclusive r || [l, r)\\n      return get(l, r, 0, 0, size);\\n    }\\n\\n    public long get(int l, int r, int x, int lx, int rx) {\\n      if (lx >= r || l >= rx)\\n        return neutralElement;\\n      if (lx >= l && rx <= r)\\n        return arr[x];\\n      int mid = (lx + rx) / 2;\\n      long max1 = get(l, r, 2 * x + 1, lx, mid);\\n      long max2 = get(l, r, 2 * x + 2, mid, rx);\\n      return op(max1, max2);\\n    }\\n\\n    private long op(long a, long b) {\\n      return Math.max(a, b);\\n    }\\n  }\\n  ```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```arr[j]```\n```arr[j]```\n```[arr[j] - k, arr[j] - 1]```\n```arr[i]```\n```[arr[j] - k, arr[j] - 1]```\n```segTree.max(1, 100000 + 1)```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        //int[] dp = new int[100000 + 5];\\n        SegmentTree st = new SegmentTree(100000 + 5);\\n        st.set(nums[0], 1);\\n        //dp[nums[0]] = 1;\\n        for(int i = 1; i < nums.length; i++) {\\n            int minN = Math.max(0, nums[i] - k); // 10 - 5 = 5\\n            st.set(nums[i], Math.max(st.get(nums[i], nums[i]), 1 + st.get(minN, nums[i])));\\n            st.set(nums[i], Math.max(st.get(nums[i], nums[i] + 1) , 1));\\n        }\\n        return (int)st.get(1, 100000 + 2);\\n    }\\n}\\n\\n  class SegmentTree {\\n\\n    int size;\\n    long[] arr;\\n\\n    int inputSize;\\n\\n    private long neutralElement = Long.MIN_VALUE / 2;\\n\\n    public SegmentTree(int n) {\\n      size = 1;\\n      inputSize = n;\\n      while (size < n) size *= 2;\\n      arr = new long[2 * size - 1];\\n      Arrays.fill(arr, neutralElement);\\n    }\\n\\n    public void print() {\\n      //Arrays.stream(arr).forEachOrdered(x -> System.out.print(x + \" \"));\\n    }\\n\\n    private void build(long[] input, int x, int lx, int rx) {\\n      if (rx - lx == 1) {\\n        if (lx < inputSize)\\n          arr[x] = input[lx];\\n        return;\\n      }\\n      int mid = (lx + rx) / 2;\\n      build(input, 2 * x + 1, lx, mid);\\n      build(input, 2 * x + 2, mid, rx);\\n      arr[x] = op(arr[2 * x + 1], arr[2 * x + 2]);\\n    }\\n\\n    public void build(long[] arr) {\\n      build(arr, 0, 0, size);\\n    }\\n\\n    private void set(int index, long val, int x, int lx, int rx) {\\n      if (rx - lx == 1) {\\n        arr[x] = val;\\n        return;\\n      }\\n      int mid = (lx + rx) / 2;\\n      if (index < mid) {\\n        set(index, val, 2 * x + 1, lx, mid);\\n      } else {\\n        set(index, val, 2 * x + 2, mid, rx);\\n      }\\n      arr[x] = op(arr[2 * x + 1], arr[2 * x + 2]);\\n    }\\n\\n    public void set(int index, long val) {\\n      set(index, val, 0, 0, size);\\n    }\\n\\n    public long get(int l, int r) { //inclusive l - exclusive r || [l, r)\\n      return get(l, r, 0, 0, size);\\n    }\\n\\n    public long get(int l, int r, int x, int lx, int rx) {\\n      if (lx >= r || l >= rx)\\n        return neutralElement;\\n      if (lx >= l && rx <= r)\\n        return arr[x];\\n      int mid = (lx + rx) / 2;\\n      long max1 = get(l, r, 2 * x + 1, lx, mid);\\n      long max2 = get(l, r, 2 * x + 2, mid, rx);\\n      return op(max1, max2);\\n    }\\n\\n    private long op(long a, long b) {\\n      return Math.max(a, b);\\n    }\\n  }\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2560013,
                "title": "javascript-segment-tree",
                "content": "**Solution: Segment Tree**\\n\\nUse a segment tree to keep track of the longest subsequence ending with each number.\\nFor each `nums[i]`, take the maximum subsequence length ending within range `(nums[i] - k, nums[i] - 1)`.\\n\\n`n = length of nums`, `m = max(nums[i])`\\nTime Complexity: `O(n log(m)) `\\nSpace Complexity: `O(m)`\\n```\\nvar lengthOfLIS = function(nums, k) {\\n  let max = Math.max(...nums), segTree = new SegmentTree(max + 1), ans = 0;\\n  for (let num of nums) {\\n    let maxLength = segTree.maxInRange(Math.max(num - k, 0), num - 1);\\n    segTree.update(num, maxLength + 1);\\n    ans = Math.max(ans, maxLength + 1);\\n  }\\n  return ans;\\n};\\n\\nclass SegmentTree {\\n  constructor(n) {\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n  }\\n  update(index, val) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] = Math.max(this.segTree[idx], val);\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = Math.max(this.segTree[idx * 2], this.segTree[idx * 2 + 1]);\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  maxInRange(left, right) {\\n    let n = this.size, max = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    // left must be even, right must be odd\\n    // when left is odd or right is even, this indicates partial coverage. \\n    // in other words, the parent node will be covering a range outside of the range we are looking for.\\n    // so, we need to take the partial sum and move the pointers so that it has full coverage.\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) {\\n        max = Math.max(max, this.segTree[left_idx]);\\n        left_idx++;\\n      }\\n      if (right_idx % 2 === 0) {\\n        max = Math.max(max, this.segTree[right_idx]);\\n        right_idx--;\\n      }\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar lengthOfLIS = function(nums, k) {\\n  let max = Math.max(...nums), segTree = new SegmentTree(max + 1), ans = 0;\\n  for (let num of nums) {\\n    let maxLength = segTree.maxInRange(Math.max(num - k, 0), num - 1);\\n    segTree.update(num, maxLength + 1);\\n    ans = Math.max(ans, maxLength + 1);\\n  }\\n  return ans;\\n};\\n\\nclass SegmentTree {\\n  constructor(n) {\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n  }\\n  update(index, val) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] = Math.max(this.segTree[idx], val);\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = Math.max(this.segTree[idx * 2], this.segTree[idx * 2 + 1]);\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  maxInRange(left, right) {\\n    let n = this.size, max = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    // left must be even, right must be odd\\n    // when left is odd or right is even, this indicates partial coverage. \\n    // in other words, the parent node will be covering a range outside of the range we are looking for.\\n    // so, we need to take the partial sum and move the pointers so that it has full coverage.\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) {\\n        max = Math.max(max, this.segTree[left_idx]);\\n        left_idx++;\\n      }\\n      if (right_idx % 2 === 0) {\\n        max = Math.max(max, this.segTree[right_idx]);\\n        right_idx--;\\n      }\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912836,
                "title": "python-segment-tree-clean-concise",
                "content": "# Intuition\\n- Use Segment Tree to query maximum of element in range [num-k, num-1], which mean to find the maximum existed Longest Increase Subsequence such that the maximum difference between consecutives element <= k.\\n\\n# Complexity\\n- Time: `O(N * logMAX + MAX)`, where `N <= 10^5` is length of nums array, `MAX <= 10^5` is maximum element in nums array.\\n- Space complexity: `O(MAX)`\\n\\n# Code\\n```python\\nclass SegmentTree:\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * 4 * self.n\\n\\n    def query(self, left, right, index, qleft, qright):\\n        if qright < left or qleft > right:\\n            return 0\\n\\n        if qleft <= left and right <= qright:\\n            return self.tree[index]\\n\\n        mid = (left + right) // 2\\n        resLeft = self.query(left, mid, 2*index+1, qleft, qright)\\n        resRight = self.query(mid+1, right, 2*index+2, qleft, qright)\\n        return max(resLeft, resRight)\\n\\n    def update(self, left, right, index, pos, val):\\n        if left == right:\\n            self.tree[index] = val\\n            return\\n\\n        mid = (left + right) // 2\\n        if pos <= mid:\\n            self.update(left, mid, 2*index+1, pos, val)\\n        else:\\n            self.update(mid+1, right, 2*index+2, pos, val)\\n        self.tree[index] = max(self.tree[2*index+1], self.tree[2*index+2])\\n\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        mx = max(nums)\\n        segmentTree = SegmentTree(mx + 1)\\n        ans = 0\\n        for num in nums:\\n            subLongest = segmentTree.query(0, segmentTree.n-1, 0, num-k, num-1) + 1\\n            ans = max(ans, subLongest)\\n            segmentTree.update(0, segmentTree.n-1, 0, num, subLongest)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Segment Tree"
                ],
                "code": "```python\\nclass SegmentTree:\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * 4 * self.n\\n\\n    def query(self, left, right, index, qleft, qright):\\n        if qright < left or qleft > right:\\n            return 0\\n\\n        if qleft <= left and right <= qright:\\n            return self.tree[index]\\n\\n        mid = (left + right) // 2\\n        resLeft = self.query(left, mid, 2*index+1, qleft, qright)\\n        resRight = self.query(mid+1, right, 2*index+2, qleft, qright)\\n        return max(resLeft, resRight)\\n\\n    def update(self, left, right, index, pos, val):\\n        if left == right:\\n            self.tree[index] = val\\n            return\\n\\n        mid = (left + right) // 2\\n        if pos <= mid:\\n            self.update(left, mid, 2*index+1, pos, val)\\n        else:\\n            self.update(mid+1, right, 2*index+2, pos, val)\\n        self.tree[index] = max(self.tree[2*index+1], self.tree[2*index+2])\\n\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        mx = max(nums)\\n        segmentTree = SegmentTree(mx + 1)\\n        ans = 0\\n        for num in nums:\\n            subLongest = segmentTree.query(0, segmentTree.n-1, 0, num-k, num-1) + 1\\n            ans = max(ans, subLongest)\\n            segmentTree.update(0, segmentTree.n-1, 0, num, subLongest)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684835,
                "title": "c-solution-using-segment-tree",
                "content": "```\\n// // Template reference: https://github.com/ankit6776/CPP_LIBRARIES/blob/master/src/segTree.hpp\\ntemplate<typename T> inline T Max(T a, T b){return a>b?a:b;}\\ntemplate<typename T> inline T Min(T a, T b){return a<b?a:b;}\\ntemplate<typename T> inline T __Gcd(T a, T b){ return b==0 ? a : __Gcd(b,a%b);}\\ntemplate<typename T> struct SegTree {\\n    long long int N;\\n    vector<T> v;\\n    vector<T> seg;\\n    vector<T> lazy;\\n    void init(int st, int end, int ind){\\n        if(st==end){\\n            seg[ind]=v[st];\\n            return;\\n        }\\n        int mid = (st+end)/2;\\n        init(st,mid,2*ind+1);\\n        init(mid+1,end, 2*ind+2);\\n        seg[ind]=f(seg[2*ind+1],seg[2*ind+2]);\\n    }\\n    T f(T a, T b){\\n        return max(a, b);  \\n        \\n    }\\n    void pre() {\\n        seg.resize(4*N);\\n        lazy.resize(4*N);\\n        init(0,N-1,0);\\n    }\\n    \\n    void point_update(int p, T x) {\\n        point_update_query(0,0,N-1,p,x);\\n    }\\n    \\n    T update_function(T x, T y){\\n        return f(x,y);\\n    }\\n    \\n    void point_update_query(int node, int st, int en, int ind, T x) {\\n        if(ind<st||ind>en)return;\\n        if(st==en) {\\n            seg[node] = update_function(seg[node], x);\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        ind<=mid ? point_update_query(2*node+1, st, mid, ind, x) : point_update_query(2*node+2, mid+1, en, ind, x);\\n        seg[node]=f(seg[2*node+1],seg[2*node+2]);\\n    }\\n    \\n    void update_range_query(int l, int r, T x) {\\n        update_range(0, 0, N-1, l, r, x);\\n    }\\n\\n    void update_range(int node, int st, int en, int l, int r, T x) {\\n        if(st>en || st>r || l>en)return;\\n        if(st == en) {\\n            seg[node] = f(seg[node], x);\\n            return;\\n        }\\n        \\n        int mid = (st+en)/2;\\n        if(st>=l&&en<=r) {\\n            if(seg[node]<=x) { // lazy return condition\\n                seg[node]=x;\\n                lazy[node]=x;\\n                return;\\n            }\\n            if(lazy[node]>=x) {\\n                return;\\n            }\\n            seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n            seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n            lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n            lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n            update_range(2*node+1, st, mid, l,r,x);\\n            update_range(2*node+2, mid+1, en, l, r,x);\\n            seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n            return;\\n        }\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        update_range(2*node+1, st, mid, l, r, x);\\n        update_range(2*node+2, mid+1, en, l, r, x);\\n        seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n    }\\n    \\n    T query(int l,int r){\\n        return _query(0,l,r,0,N-1);\\n    }\\n    \\n    T _query(int node, int l,int r, int st,int en){\\n        if(l>en||r<st)return 0; // replace INF with zero for sum query\\n        if(st>=l&&en<=r)return seg[node];\\n        int mid = (st+en)/2;\\n        return f(_query(2*node+1,l,r,st,mid),_query(2*node+2,l,r,mid+1,en));\\n    }\\n\\n    T lazy_query(T x) {\\n        return _range_query(0,x, 0, N-1);\\n    }\\n\\n    T _range_query(int node, T x, int st, int en) {\\n        if(st==en && st==x) return seg[node];\\n        int mid = (st+en)/2;\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        if(mid>=x)return _range_query(2*node+1, x, st, mid);\\n        else return _range_query(2*node+2, x, mid+1, en);\\n    }\\n    \\n    //TODO(ankit6776): Add query implementation for range query in lazy propagation.\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree<int> seg;\\n        int n = 100002;\\n        vector<int> v(n);\\n        seg.N = n;\\n        seg.v = v;\\n        seg.pre();\\n        int ans = 0;\\n        for(int i=0;i<nums.size();++i){\\n            int pp = seg.query(nums[i], nums[i]);\\n            int qq = seg.query(nums[i]-k, nums[i]-1);\\n            ans = max(ans, pp);\\n            if(pp>=qq+1){\\n                continue;\\n            }\\n            seg.point_update(nums[i], qq+1);\\n            ans = max(ans, qq+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// // Template reference: https://github.com/ankit6776/CPP_LIBRARIES/blob/master/src/segTree.hpp\\ntemplate<typename T> inline T Max(T a, T b){return a>b?a:b;}\\ntemplate<typename T> inline T Min(T a, T b){return a<b?a:b;}\\ntemplate<typename T> inline T __Gcd(T a, T b){ return b==0 ? a : __Gcd(b,a%b);}\\ntemplate<typename T> struct SegTree {\\n    long long int N;\\n    vector<T> v;\\n    vector<T> seg;\\n    vector<T> lazy;\\n    void init(int st, int end, int ind){\\n        if(st==end){\\n            seg[ind]=v[st];\\n            return;\\n        }\\n        int mid = (st+end)/2;\\n        init(st,mid,2*ind+1);\\n        init(mid+1,end, 2*ind+2);\\n        seg[ind]=f(seg[2*ind+1],seg[2*ind+2]);\\n    }\\n    T f(T a, T b){\\n        return max(a, b);  \\n        \\n    }\\n    void pre() {\\n        seg.resize(4*N);\\n        lazy.resize(4*N);\\n        init(0,N-1,0);\\n    }\\n    \\n    void point_update(int p, T x) {\\n        point_update_query(0,0,N-1,p,x);\\n    }\\n    \\n    T update_function(T x, T y){\\n        return f(x,y);\\n    }\\n    \\n    void point_update_query(int node, int st, int en, int ind, T x) {\\n        if(ind<st||ind>en)return;\\n        if(st==en) {\\n            seg[node] = update_function(seg[node], x);\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        ind<=mid ? point_update_query(2*node+1, st, mid, ind, x) : point_update_query(2*node+2, mid+1, en, ind, x);\\n        seg[node]=f(seg[2*node+1],seg[2*node+2]);\\n    }\\n    \\n    void update_range_query(int l, int r, T x) {\\n        update_range(0, 0, N-1, l, r, x);\\n    }\\n\\n    void update_range(int node, int st, int en, int l, int r, T x) {\\n        if(st>en || st>r || l>en)return;\\n        if(st == en) {\\n            seg[node] = f(seg[node], x);\\n            return;\\n        }\\n        \\n        int mid = (st+en)/2;\\n        if(st>=l&&en<=r) {\\n            if(seg[node]<=x) { // lazy return condition\\n                seg[node]=x;\\n                lazy[node]=x;\\n                return;\\n            }\\n            if(lazy[node]>=x) {\\n                return;\\n            }\\n            seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n            seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n            lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n            lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n            update_range(2*node+1, st, mid, l,r,x);\\n            update_range(2*node+2, mid+1, en, l, r,x);\\n            seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n            return;\\n        }\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        update_range(2*node+1, st, mid, l, r, x);\\n        update_range(2*node+2, mid+1, en, l, r, x);\\n        seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n    }\\n    \\n    T query(int l,int r){\\n        return _query(0,l,r,0,N-1);\\n    }\\n    \\n    T _query(int node, int l,int r, int st,int en){\\n        if(l>en||r<st)return 0; // replace INF with zero for sum query\\n        if(st>=l&&en<=r)return seg[node];\\n        int mid = (st+en)/2;\\n        return f(_query(2*node+1,l,r,st,mid),_query(2*node+2,l,r,mid+1,en));\\n    }\\n\\n    T lazy_query(T x) {\\n        return _range_query(0,x, 0, N-1);\\n    }\\n\\n    T _range_query(int node, T x, int st, int en) {\\n        if(st==en && st==x) return seg[node];\\n        int mid = (st+en)/2;\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        if(mid>=x)return _range_query(2*node+1, x, st, mid);\\n        else return _range_query(2*node+2, x, mid+1, en);\\n    }\\n    \\n    //TODO(ankit6776): Add query implementation for range query in lazy propagation.\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree<int> seg;\\n        int n = 100002;\\n        vector<int> v(n);\\n        seg.N = n;\\n        seg.v = v;\\n        seg.pre();\\n        int ans = 0;\\n        for(int i=0;i<nums.size();++i){\\n            int pp = seg.query(nums[i], nums[i]);\\n            int qq = seg.query(nums[i]-k, nums[i]-1);\\n            ans = max(ans, pp);\\n            if(pp>=qq+1){\\n                continue;\\n            }\\n            seg.point_update(nums[i], qq+1);\\n            ans = max(ans, qq+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586425,
                "title": "segment-tree-c",
                "content": "```\\n\\nvoid update(vector<int> &seg,int si,int sl,int sr,int i,int val){\\n    if(sl==sr){\\n        seg[si]=max(seg[si],val);\\n        return;\\n    }\\n    int mid=(sl+sr)/2;\\n    if(i<=mid)update(seg,si*2,sl,mid,i,val);\\n    else update(seg,si*2+1,mid+1,sr,i,val);\\n    seg[si]=max(seg[si*2],seg[si*2+1]);\\n}\\n\\nint Q(vector<int> &seg,int si,int sl,int sr,int l,int r){\\n    if(l>r)return 0;\\n    if(sl==l and sr==r)return seg[si];\\n    int mid=(sl+sr)/2;\\n    return max(\\n        Q(seg,si*2,sl,mid,l,min(r,mid)),\\n        Q(seg,si*2+1,mid+1,sr,max(mid+1,l),r)\\n    );\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        vector<int> seg(400005);\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int maxi=Q(seg,1,1,100000,max(1,nums[i]-k),nums[i]-1);\\n            ans=max(ans,maxi+1);\\n            update(seg,1,1,100000,nums[i],maxi+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvoid update(vector<int> &seg,int si,int sl,int sr,int i,int val){\\n    if(sl==sr){\\n        seg[si]=max(seg[si],val);\\n        return;\\n    }\\n    int mid=(sl+sr)/2;\\n    if(i<=mid)update(seg,si*2,sl,mid,i,val);\\n    else update(seg,si*2+1,mid+1,sr,i,val);\\n    seg[si]=max(seg[si*2],seg[si*2+1]);\\n}\\n\\nint Q(vector<int> &seg,int si,int sl,int sr,int l,int r){\\n    if(l>r)return 0;\\n    if(sl==l and sr==r)return seg[si];\\n    int mid=(sl+sr)/2;\\n    return max(\\n        Q(seg,si*2,sl,mid,l,min(r,mid)),\\n        Q(seg,si*2+1,mid+1,sr,max(mid+1,l),r)\\n    );\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        vector<int> seg(400005);\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int maxi=Q(seg,1,1,100000,max(1,nums[i]-k),nums[i]-1);\\n            ans=max(ans,maxi+1);\\n            update(seg,1,1,100000,nums[i],maxi+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571221,
                "title": "java-dp-segment-tree-time-nlogn-space-max-min-commented",
                "content": "Use the segment tree to store DP results and query them\\n\\n```\\nclass Solution {\\n\\tpublic int lengthOfLIS(int[] nums, int k) {\\n\\t\\t// find the boundaries of the segment tree\\n\\t\\tvar minVal = Integer.MAX_VALUE;\\n\\t\\tvar maxVal = Integer.MIN_VALUE;\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tminVal = Math.min(minVal, n);\\n\\t\\t\\tmaxVal = Math.max(maxVal, n);\\n\\t\\t}\\n\\n\\t\\t// build the segment tree\\n\\t\\tvar dp = new SegmentTree(minVal, maxVal);\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\t// find longest chain in range\\n\\t\\t\\tvar preMax = 1 + dp.rangeMaxQuery(num - k, num - 1);\\n\\t\\t\\t// store the results\\n\\t\\t\\tdp.update(num, preMax);\\n\\t\\t}\\n\\t\\treturn dp.val;\\n\\t}\\n\\n\\tstatic final class SegmentTree {\\n\\t\\tSegmentTree left;\\n\\t\\tSegmentTree right;\\n\\t\\tfinal int lo;\\n\\t\\tfinal int hi;\\n\\t\\tint val;\\n\\n\\t\\tSegmentTree(int lo, int hi) {\\n\\t\\t\\tthis.lo = lo;\\n\\t\\t\\tthis.hi = hi;\\n\\t\\t\\tif (lo != hi) {\\n\\t\\t\\t\\tvar mid = lo + (hi - lo) / 2;\\n\\t\\t\\t\\tthis.left = new SegmentTree(lo, mid);\\n\\t\\t\\t\\tthis.right = new SegmentTree(mid + 1, hi);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid update(int index, int val) {\\n\\t\\t\\tif (index < this.lo || this.hi < index) // out of range\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif (lo == hi) { // found node\\n\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tthis.left.update(index, val);\\n\\t\\t\\tthis.right.update(index, val);\\n\\t\\t\\tthis.val = Math.max(this.left.val, this.right.val);\\n\\t\\t}\\n\\n\\t\\tint rangeMaxQuery(int lo, int hi) {\\n\\t\\t\\tif (hi < this.lo || this.hi < lo) // not overlap\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif (lo <= this.lo && this.hi <= hi) // in range\\n\\t\\t\\t\\treturn this.val;\\n\\t\\t\\treturn Math.max(this.left.rangeMaxQuery(lo, hi), this.right.rangeMaxQuery(lo, hi));\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"[\" + lo + \",\" + hi + \"]->\" + val;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int lengthOfLIS(int[] nums, int k) {\\n\\t\\t// find the boundaries of the segment tree\\n\\t\\tvar minVal = Integer.MAX_VALUE;\\n\\t\\tvar maxVal = Integer.MIN_VALUE;\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tminVal = Math.min(minVal, n);\\n\\t\\t\\tmaxVal = Math.max(maxVal, n);\\n\\t\\t}\\n\\n\\t\\t// build the segment tree\\n\\t\\tvar dp = new SegmentTree(minVal, maxVal);\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\t// find longest chain in range\\n\\t\\t\\tvar preMax = 1 + dp.rangeMaxQuery(num - k, num - 1);\\n\\t\\t\\t// store the results\\n\\t\\t\\tdp.update(num, preMax);\\n\\t\\t}\\n\\t\\treturn dp.val;\\n\\t}\\n\\n\\tstatic final class SegmentTree {\\n\\t\\tSegmentTree left;\\n\\t\\tSegmentTree right;\\n\\t\\tfinal int lo;\\n\\t\\tfinal int hi;\\n\\t\\tint val;\\n\\n\\t\\tSegmentTree(int lo, int hi) {\\n\\t\\t\\tthis.lo = lo;\\n\\t\\t\\tthis.hi = hi;\\n\\t\\t\\tif (lo != hi) {\\n\\t\\t\\t\\tvar mid = lo + (hi - lo) / 2;\\n\\t\\t\\t\\tthis.left = new SegmentTree(lo, mid);\\n\\t\\t\\t\\tthis.right = new SegmentTree(mid + 1, hi);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid update(int index, int val) {\\n\\t\\t\\tif (index < this.lo || this.hi < index) // out of range\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif (lo == hi) { // found node\\n\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tthis.left.update(index, val);\\n\\t\\t\\tthis.right.update(index, val);\\n\\t\\t\\tthis.val = Math.max(this.left.val, this.right.val);\\n\\t\\t}\\n\\n\\t\\tint rangeMaxQuery(int lo, int hi) {\\n\\t\\t\\tif (hi < this.lo || this.hi < lo) // not overlap\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif (lo <= this.lo && this.hi <= hi) // in range\\n\\t\\t\\t\\treturn this.val;\\n\\t\\t\\treturn Math.max(this.left.rangeMaxQuery(lo, hi), this.right.rangeMaxQuery(lo, hi));\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"[\" + lo + \",\" + hi + \"]->\" + val;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568434,
                "title": "c-solution-time-o-n-log-n-memory-o-n-segment-tree-max-range-query",
                "content": "```C#\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums, int k) {\\n        var max = nums.Max();\\n        var segmentTree = new SegmentTree(max + 1, new MaxSegmentTreeNodeMerger());\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            int left = Math.Max(0, nums[i] - k), right = nums[i] - 1;\\n            var queryResult = segmentTree.QueryRange(left, right);\\n            \\n            segmentTree.Update(nums[i], queryResult + 1);\\n        }\\n        \\n        return segmentTree.QueryRange(0, max);\\n    }\\n}\\n\\npublic class SegmentTree\\n{\\n    private readonly int _originalLength;\\n    private readonly int[] _items;\\n    private readonly ISegmentTreeNodeMerger _merger;\\n\\n    public SegmentTree(int[] nums, ISegmentTreeNodeMerger merger) \\n        : this(nums?.Length ?? throw new ArgumentNullException(nameof(nums)), merger)\\n    {\\n        for (var i = 0; i < this._originalLength; i++) this._items[i + this._originalLength] = nums[i];\\n        for (var i = this._originalLength - 1; i > 0; i--) this._items[i] = this._merger.Merge(this._items[i * 2], this._items[i * 2 + 1]);\\n    }\\n    \\n    public SegmentTree(int length, ISegmentTreeNodeMerger merger)\\n    {\\n        this._originalLength = length;\\n        this._items = new int[this._originalLength * 2];\\n        this._merger = merger ?? throw new ArgumentNullException(nameof(merger));\\n    }\\n\\n    public void Update(int index, int value)\\n    {\\n        index += this._originalLength;\\n        this._items[index] = value;\\n\\n        while (index > 1)\\n        {\\n            int left = index, right = index;\\n            if (index % 2 == 0) right += 1;\\n            else left -= 1;\\n\\n            this._items[index / 2] = this._merger.Merge(this._items[left], this._items[right]);\\n            index /= 2;\\n        }\\n    }\\n\\n    public int QueryRange(int left, int right)\\n    {\\n        left += this._originalLength;\\n        right += this._originalLength;\\n\\n        var res = this._merger.InitialQueryValue;\\n        while (left <= right)\\n        {\\n            // If `left` is right child, then the parent contains sum of range of `left` and another child which is outside the sum range and we don\\'t need the parent sum. Add `left` to sum without its parent and set `left` to point to the right of its parent on the upper level.\\n            if (left % 2 != 0)\\n            {\\n                res = this._merger.Merge(res, this._items[left]);\\n                left += 1;\\n            }\\n\\n            // If `right` is left child, then the parent contains sum of range of `right` and another child which is outside the sum range and we don\\'t need the parent sum. Add `right` to sum without its parent and set `right` to point to the left of its parent on the upper level.\\n            if (right % 2 == 0)\\n            {\\n                res = this._merger.Merge(res, this._items[right]);\\n                right -= 1;\\n            }\\n\\n            left /= 2;\\n            right /= 2;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\npublic interface ISegmentTreeNodeMerger\\n{\\n    int Merge(int leftValue, int rightValue);\\n    int InitialQueryValue { get; }\\n}\\n\\npublic class MaxSegmentTreeNodeMerger : ISegmentTreeNodeMerger\\n{\\n    public int Merge(int leftValue, int rightValue) => Math.Max(leftValue, rightValue);\\n\\n    public int InitialQueryValue => int.MinValue;\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums, int k) {\\n        var max = nums.Max();\\n        var segmentTree = new SegmentTree(max + 1, new MaxSegmentTreeNodeMerger());\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            int left = Math.Max(0, nums[i] - k), right = nums[i] - 1;\\n            var queryResult = segmentTree.QueryRange(left, right);\\n            \\n            segmentTree.Update(nums[i], queryResult + 1);\\n        }\\n        \\n        return segmentTree.QueryRange(0, max);\\n    }\\n}\\n\\npublic class SegmentTree\\n{\\n    private readonly int _originalLength;\\n    private readonly int[] _items;\\n    private readonly ISegmentTreeNodeMerger _merger;\\n\\n    public SegmentTree(int[] nums, ISegmentTreeNodeMerger merger) \\n        : this(nums?.Length ?? throw new ArgumentNullException(nameof(nums)), merger)\\n    {\\n        for (var i = 0; i < this._originalLength; i++) this._items[i + this._originalLength] = nums[i];\\n        for (var i = this._originalLength - 1; i > 0; i--) this._items[i] = this._merger.Merge(this._items[i * 2], this._items[i * 2 + 1]);\\n    }\\n    \\n    public SegmentTree(int length, ISegmentTreeNodeMerger merger)\\n    {\\n        this._originalLength = length;\\n        this._items = new int[this._originalLength * 2];\\n        this._merger = merger ?? throw new ArgumentNullException(nameof(merger));\\n    }\\n\\n    public void Update(int index, int value)\\n    {\\n        index += this._originalLength;\\n        this._items[index] = value;\\n\\n        while (index > 1)\\n        {\\n            int left = index, right = index;\\n            if (index % 2 == 0) right += 1;\\n            else left -= 1;\\n\\n            this._items[index / 2] = this._merger.Merge(this._items[left], this._items[right]);\\n            index /= 2;\\n        }\\n    }\\n\\n    public int QueryRange(int left, int right)\\n    {\\n        left += this._originalLength;\\n        right += this._originalLength;\\n\\n        var res = this._merger.InitialQueryValue;\\n        while (left <= right)\\n        {\\n            // If `left` is right child, then the parent contains sum of range of `left` and another child which is outside the sum range and we don\\'t need the parent sum. Add `left` to sum without its parent and set `left` to point to the right of its parent on the upper level.\\n            if (left % 2 != 0)\\n            {\\n                res = this._merger.Merge(res, this._items[left]);\\n                left += 1;\\n            }\\n\\n            // If `right` is left child, then the parent contains sum of range of `right` and another child which is outside the sum range and we don\\'t need the parent sum. Add `right` to sum without its parent and set `right` to point to the left of its parent on the upper level.\\n            if (right % 2 == 0)\\n            {\\n                res = this._merger.Merge(res, this._items[right]);\\n                right -= 1;\\n            }\\n\\n            left /= 2;\\n            right /= 2;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\npublic interface ISegmentTreeNodeMerger\\n{\\n    int Merge(int leftValue, int rightValue);\\n    int InitialQueryValue { get; }\\n}\\n\\npublic class MaxSegmentTreeNodeMerger : ISegmentTreeNodeMerger\\n{\\n    public int Merge(int leftValue, int rightValue) => Math.Max(leftValue, rightValue);\\n\\n    public int InitialQueryValue => int.MinValue;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560241,
                "title": "zkw-segment-tree",
                "content": "```\\ndef lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        N = 1+max(nums)\\n        tree = [0] * (2*N+1)\\n        def update(x, l):\\n            i = x+N\\n            while i:\\n                tree[i] = max(tree[i],l)\\n                i>>=1\\n        def query(l,r):\\n            ans =0 \\n            l += N-1\\n            r += N+1\\n            while l^r^1:\\n                if ~l & 1: ans= max(ans, tree[l^1])\\n                if r & 1 : ans = max(ans, tree[r^1])\\n                l>>=1\\n                r>>=1\\n            return ans\\n        for x in nums:\\n            l = query(max(1,x-k), x-1)\\n            update(x, l+1)\\n        return max(tree)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\ndef lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        N = 1+max(nums)\\n        tree = [0] * (2*N+1)\\n        def update(x, l):\\n            i = x+N\\n            while i:\\n                tree[i] = max(tree[i],l)\\n                i>>=1\\n        def query(l,r):\\n            ans =0 \\n            l += N-1\\n            r += N+1\\n            while l^r^1:\\n                if ~l & 1: ans= max(ans, tree[l^1])\\n                if r & 1 : ans = max(ans, tree[r^1])\\n                l>>=1\\n                r>>=1\\n            return ans\\n        for x in nums:\\n            l = query(max(1,x-k), x-1)\\n            update(x, l+1)\\n        return max(tree)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2560214,
                "title": "segment-tree-1d-dp-c-intutive-approach",
                "content": "**USED IN THIS QUESTION**\\nSegment Tree -> To find the maximum value from the previous K numbers i.e. in range  [a[i]-k,a[i]-1] . \\nDP -> To store the LIS ending at that number ( dp[i] represents the LIS ending at that element ) \\n\\n```\\nclass Solution {\\n\\n//CODE FOR SEGMENT TREE\\n    private:\\n    // BUILD FUNCTION (SEGMENT TREE)\\nvoid build(int i,int l,int r,vector<int>& a,vector<int>& seg)\\n{\\n\\tif(l==r)\\n\\t{\\n\\t\\tseg[i]=a[l];\\n\\t\\treturn ;\\n\\t}\\n \\n\\tint m=(l+r)/2;\\n \\n\\tbuild(2*i+1,l,m,a,seg);\\n\\tbuild(2*i+2,m+1,r,a,seg);\\n \\n\\tseg[i]=max(seg[2*i+1],seg[2*i+2]);\\n}\\n // QUERY THE MAXIMUM ELEMENT IN RANGE [x,y] (SEGMENT TREE) \\nint query(int i,int l,int r,vector<int>& a,int x,int y,vector<int>& seg)\\n{\\n\\tif(l>=x && r<=y)\\n\\t{\\n\\t\\treturn seg[i];\\n\\t}\\n\\tif(l>y || r<x)\\n\\t{\\n\\t\\treturn INT_MIN;\\n\\t}\\n \\n\\tint m=(l+r)/2;\\n \\n\\tint c=query(2*i+1,l,m,a,x,y,seg);\\n\\tint d=query(2*i+2,m+1,r,a,x,y,seg);\\n \\n\\treturn max(c,d);\\n}\\n \\n // CHANGE THE VALUE OF a[j] to x (SEGMENT TREE)\\nvoid update(int i,int l,int r,vector<int>& a,int j,int x,vector<int>& seg)\\n{\\n\\tif(l==r)\\n\\t{\\n\\t\\tseg[i]=x;\\n\\t\\treturn;\\n\\t}\\n \\n\\tint m=(l+r)/2;\\n\\tif(j<=m)\\n\\t{\\n\\t\\tupdate(2*i+1,l,m,a,j,x,seg);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tupdate(2*i+2,m+1,r,a,j,x,seg);\\n\\t}\\n \\n\\tseg[i]=max(seg[2*i+1],seg[2*i+2]);\\n}\\npublic:\\n    \\n    int lengthOfLIS(vector<int>& a, int k) \\n    {\\n        int n=a.size();\\n        \\n        int m=100005;\\n\\t\\t\\n        vector<int> dp(m,0); \\n\\t\\t// dp [LIS ending at this index]\\n        \\n        vector<int> seg;\\n        seg.assign(4*m+1,0);\\n        \\n        build(0,0,m-1,dp,seg);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]-k>=0)\\n            {\\n\\t\\t\\t    // query(  [a[i]-k , a[i]-1]  )\\n                int t=query(0,0,m-1,dp,a[i]-k,a[i]-1,seg);\\n                dp[a[i]]=t+1; // changing dp[ a[i] ]=max element in range + 1\\n\\t\\t\\t\\t// update(  seg[a[i]] to dp[a[i]]   )\\n                update(0,0,m-1,dp,a[i],dp[a[i]],seg);\\n            }\\n            else\\n            {\\n\\t\\t\\t    // query(  0, a[i]-1]  )\\n                int t=query(0,0,m-1,dp,0,a[i]-1,seg);\\n                dp[a[i]]=t+1; // changing dp[ a[i] ]=max element in range + 1\\n\\t\\t\\t\\t// update(  seg[a[i]] to dp[a[i]]   )\\n                update(0,0,m-1,dp,a[i],dp[a[i]],seg);\\n            }\\n        }\\n        \\n\\t\\t//FINDING THE MAXIMUM AMONG ALL THE ELEMENTS\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        \\n        return ans;\\n       \\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF UNDERSTOOD**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n//CODE FOR SEGMENT TREE\\n    private:\\n    // BUILD FUNCTION (SEGMENT TREE)\\nvoid build(int i,int l,int r,vector<int>& a,vector<int>& seg)\\n{\\n\\tif(l==r)\\n\\t{\\n\\t\\tseg[i]=a[l];\\n\\t\\treturn ;\\n\\t}\\n \\n\\tint m=(l+r)/2;\\n \\n\\tbuild(2*i+1,l,m,a,seg);\\n\\tbuild(2*i+2,m+1,r,a,seg);\\n \\n\\tseg[i]=max(seg[2*i+1],seg[2*i+2]);\\n}\\n // QUERY THE MAXIMUM ELEMENT IN RANGE [x,y] (SEGMENT TREE) \\nint query(int i,int l,int r,vector<int>& a,int x,int y,vector<int>& seg)\\n{\\n\\tif(l>=x && r<=y)\\n\\t{\\n\\t\\treturn seg[i];\\n\\t}\\n\\tif(l>y || r<x)\\n\\t{\\n\\t\\treturn INT_MIN;\\n\\t}\\n \\n\\tint m=(l+r)/2;\\n \\n\\tint c=query(2*i+1,l,m,a,x,y,seg);\\n\\tint d=query(2*i+2,m+1,r,a,x,y,seg);\\n \\n\\treturn max(c,d);\\n}\\n \\n // CHANGE THE VALUE OF a[j] to x (SEGMENT TREE)\\nvoid update(int i,int l,int r,vector<int>& a,int j,int x,vector<int>& seg)\\n{\\n\\tif(l==r)\\n\\t{\\n\\t\\tseg[i]=x;\\n\\t\\treturn;\\n\\t}\\n \\n\\tint m=(l+r)/2;\\n\\tif(j<=m)\\n\\t{\\n\\t\\tupdate(2*i+1,l,m,a,j,x,seg);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tupdate(2*i+2,m+1,r,a,j,x,seg);\\n\\t}\\n \\n\\tseg[i]=max(seg[2*i+1],seg[2*i+2]);\\n}\\npublic:\\n    \\n    int lengthOfLIS(vector<int>& a, int k) \\n    {\\n        int n=a.size();\\n        \\n        int m=100005;\\n\\t\\t\\n        vector<int> dp(m,0); \\n\\t\\t// dp [LIS ending at this index]\\n        \\n        vector<int> seg;\\n        seg.assign(4*m+1,0);\\n        \\n        build(0,0,m-1,dp,seg);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]-k>=0)\\n            {\\n\\t\\t\\t    // query(  [a[i]-k , a[i]-1]  )\\n                int t=query(0,0,m-1,dp,a[i]-k,a[i]-1,seg);\\n                dp[a[i]]=t+1; // changing dp[ a[i] ]=max element in range + 1\\n\\t\\t\\t\\t// update(  seg[a[i]] to dp[a[i]]   )\\n                update(0,0,m-1,dp,a[i],dp[a[i]],seg);\\n            }\\n            else\\n            {\\n\\t\\t\\t    // query(  0, a[i]-1]  )\\n                int t=query(0,0,m-1,dp,0,a[i]-1,seg);\\n                dp[a[i]]=t+1; // changing dp[ a[i] ]=max element in range + 1\\n\\t\\t\\t\\t// update(  seg[a[i]] to dp[a[i]]   )\\n                update(0,0,m-1,dp,a[i],dp[a[i]],seg);\\n            }\\n        }\\n        \\n\\t\\t//FINDING THE MAXIMUM AMONG ALL THE ELEMENTS\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        \\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560169,
                "title": "python-3-max-segment-tree",
                "content": "Use a segment tree to track and query max length LIS. For leaf nodes in the 2nd half of the tree, `tree index - len(nums)` represents values appearing in nums. For a given val in nums, left query boundary = max(0, val - k), right query boundary = max(0, val - 1). val can be connected to all elements within the query range to form a 1-longer LIS.\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        def update(i, x):\\n            i += n\\n            while i:\\n                tree[i] = max(tree[i], x)\\n                i //= 2\\n            \\n        def query(i, j):\\n            i += n\\n            j += n\\n            ans = -inf\\n            while i <= j:\\n                if i & 1:\\n                    ans = max(ans, tree[i])\\n                    i += 1\\n                if not j & 1:\\n                    ans = max(ans, tree[j])\\n                    j -= 1\\n                i //= 2\\n                j //= 2\\n            return ans\\n        \\n        ma = max(nums)\\n        n = ma + 1\\n        tree = [0] * (2 * n)\\n        ans = 0\\n        \\n        for i, v in enumerate(nums):\\n            # right query boundary\\n            rq = max(0, v - 1)\\n            # left query boundary\\n            lq = max(0, v - k)\\n            # query\\n            res = query(lq, rq) + 1\\n            # update LIS length for current value\\n            ans = max(ans, res)\\n            if res > tree[v + n]:\\n                update(v, res)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        def update(i, x):\\n            i += n\\n            while i:\\n                tree[i] = max(tree[i], x)\\n                i //= 2\\n            \\n        def query(i, j):\\n            i += n\\n            j += n\\n            ans = -inf\\n            while i <= j:\\n                if i & 1:\\n                    ans = max(ans, tree[i])\\n                    i += 1\\n                if not j & 1:\\n                    ans = max(ans, tree[j])\\n                    j -= 1\\n                i //= 2\\n                j //= 2\\n            return ans\\n        \\n        ma = max(nums)\\n        n = ma + 1\\n        tree = [0] * (2 * n)\\n        ans = 0\\n        \\n        for i, v in enumerate(nums):\\n            # right query boundary\\n            rq = max(0, v - 1)\\n            # left query boundary\\n            lq = max(0, v - k)\\n            # query\\n            res = query(lq, rq) + 1\\n            # update LIS length for current value\\n            ans = max(ans, res)\\n            if res > tree[v + n]:\\n                update(v, res)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667697,
                "title": "dp-to-segment-tree-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make sense of the accepted segment tree approach, we first need to briefly discuss the relevant dynamic programming approach with $$O(nk)$$ time complexity and $$O(n)$$ space complexity.\\n\\nWe\\'re going to traverse our array nums. For each element $x$ of $nums$, we\\'re going to check for the longest increasing subsequence (LIS) that terminated at a value in the following set/interval: {$x - k, x - k + 1, ..., x - 1$}. We will track the prior LIS\\'s that terminate at each value $x$ in an array of length equal to max($nums$).\\n\\nThis looks like:\\n```python []\\ndef lengthOfLIS(self, nums: List[int], k: int) -> int:\\n    lis = [0] * max(nums)\\n    for x in nums:\\n        intervalStart = max(0, x-1-k)\\n        for idx in range(intervalStart, x-1):\\n            lis[x-1] = max(lis[x-1], lis[idx]+1)\\n    \\n    return max(lis)\\n```\\n\\nThis approach is TLE, so we need to use some extra space (still maintaining linear complexity) in order to improve our time complexity. This leads us to the segment tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe build a binary tree where each node of our tree contains the length of LIS that terminates at a value in some interval $[l, r)$. Naturally, the root node of our tree corresponds to the interval $[1, \\\\max(nums)+1)$. \\n\\nConsider a node corresponding to the interval $[l, r)$. Let the midpoint of this interval, $c$, equal the floor of $(l + r) / 2$. Then the left child of this node corresponds to the interval $[l, c)$ and the right child corresponds to the interval $[c, r)$.\\n\\nWe will represent our tree implicitly by using the Eytzinger layout to map values to an array. Given a node whose value is at array index $m$, its left child is at index $2m$ and its right child is at index $2m + 1$. The root of our tree is at array index 1. \\n\\nI chose recursive implementations for the update and query methods because those made the most sense to me (I could justify to myself that the node to array index mapping was working and I could easily see how we traversed the tree to find our desired intervals). But I\\'m definitely not an expert on segment trees and there are much faster implementations!\\n\\nPlease consult the following resources:\\n- [Segment Trees (Recursive, Iterative, Best Optimizations)](https://en.algorithmica.org/hpc/data-structures/segment-trees/)\\n- [Iterative Segment Tree](https://codeforces.com/blog/entry/18051)\\n- [Iterative Segment Tree (python implementation)](https://leetcode.com/problems/longest-increasing-subsequence-ii/solutions/2560085/python-explanation-with-pictures-segment-tree/)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```python []\\nclass SegmentTree:\\n    def __init__(self, n):\\n        self.tree = [0] * 4 * n\\n        self.n = n\\n    \\n    def update(self, l, r, x, val, treeIdx):\\n        if l == r - 1:\\n            self.tree[treeIdx] = max(self.tree[treeIdx], val)\\n            return \\n        \\n        c = (l + r) // 2\\n        if x < c:\\n            self.update(l, c, x, val, 2 * treeIdx)\\n        else:\\n            self.update(c, r, x, val, 2 * treeIdx + 1)\\n\\n        self.tree[treeIdx] = max(self.tree[2 * treeIdx], self.tree[2 * treeIdx + 1])\\n    \\n    def query(self, lDesired, rDesired, l, r, treeIdx):\\n        if lDesired <= l and rDesired >= r:\\n            return self.tree[treeIdx]\\n        \\n        c = (l + r) // 2\\n        leftMax, rightMax = 0, 0\\n        if lDesired < c:\\n            leftMax = self.query(lDesired, rDesired, l, c, 2 * treeIdx)\\n        if rDesired > c:\\n            rightMax = self.query(lDesired, rDesired, c, r, 2 * treeIdx + 1)\\n        \\n        return max(leftMax, rightMax) \\n    \\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = max(nums)\\n        seg = SegmentTree(n)\\n        for num in nums:\\n            lis = seg.query(max(1, num - k), num, 1, n+1, 1)\\n            seg.update(1, n+1, num, lis+1, 1)\\n\\n        #print(f\\'seg.tree = {seg.tree}\\')\\n        return seg.tree[1] \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```python []\\ndef lengthOfLIS(self, nums: List[int], k: int) -> int:\\n    lis = [0] * max(nums)\\n    for x in nums:\\n        intervalStart = max(0, x-1-k)\\n        for idx in range(intervalStart, x-1):\\n            lis[x-1] = max(lis[x-1], lis[idx]+1)\\n    \\n    return max(lis)\\n```\n```python []\\nclass SegmentTree:\\n    def __init__(self, n):\\n        self.tree = [0] * 4 * n\\n        self.n = n\\n    \\n    def update(self, l, r, x, val, treeIdx):\\n        if l == r - 1:\\n            self.tree[treeIdx] = max(self.tree[treeIdx], val)\\n            return \\n        \\n        c = (l + r) // 2\\n        if x < c:\\n            self.update(l, c, x, val, 2 * treeIdx)\\n        else:\\n            self.update(c, r, x, val, 2 * treeIdx + 1)\\n\\n        self.tree[treeIdx] = max(self.tree[2 * treeIdx], self.tree[2 * treeIdx + 1])\\n    \\n    def query(self, lDesired, rDesired, l, r, treeIdx):\\n        if lDesired <= l and rDesired >= r:\\n            return self.tree[treeIdx]\\n        \\n        c = (l + r) // 2\\n        leftMax, rightMax = 0, 0\\n        if lDesired < c:\\n            leftMax = self.query(lDesired, rDesired, l, c, 2 * treeIdx)\\n        if rDesired > c:\\n            rightMax = self.query(lDesired, rDesired, c, r, 2 * treeIdx + 1)\\n        \\n        return max(leftMax, rightMax) \\n    \\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = max(nums)\\n        seg = SegmentTree(n)\\n        for num in nums:\\n            lis = seg.query(max(1, num - k), num, 1, n+1, 1)\\n            seg.update(1, n+1, num, lis+1, 1)\\n\\n        #print(f\\'seg.tree = {seg.tree}\\')\\n        return seg.tree[1] \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591153,
                "title": "python-runtime-o-n-logn-memory-o-n",
                "content": "\\n```\\nclass Solution:\\n    def getmax(self, st, start, end):\\n        maxi = 0\\n        \\n        while start < end:\\n            if start%2:#odd\\n                maxi = max(maxi, st[start])\\n                start += 1\\n            if end%2:#odd\\n                end -= 1\\n                maxi = max(maxi, st[end])\\n            start //= 2\\n            end //= 2\\n        return maxi\\n        \\n    def update(self, st, maxi, n):\\n        st[n] = maxi\\n        while n > 1:\\n            n //= 2\\n            st[n] = max(st[2*n], st[2*n+1])\\n    \\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n        length = max(nums)\\n        st = [0]*length*2\\n        for n in nums:\\n            n -= 1\\n            maxi = self.getmax(st, max(0, n-k)+length, n+length) + 1\\n            self.update(st, maxi, n+length)\\n            ans = max(maxi, ans)\\n        return ans\\n            \\n\\n```\\nReference:\\nhttps://www.youtube.com/watch?v=xztU7lmDLv8&ab_channel=StableSort\\nhttps://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/2560085/Python-Explanation-with-pictures-Segment-Tree",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def getmax(self, st, start, end):\\n        maxi = 0\\n        \\n        while start < end:\\n            if start%2:#odd\\n                maxi = max(maxi, st[start])\\n                start += 1\\n            if end%2:#odd\\n                end -= 1\\n                maxi = max(maxi, st[end])\\n            start //= 2\\n            end //= 2\\n        return maxi\\n        \\n    def update(self, st, maxi, n):\\n        st[n] = maxi\\n        while n > 1:\\n            n //= 2\\n            st[n] = max(st[2*n], st[2*n+1])\\n    \\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n        length = max(nums)\\n        st = [0]*length*2\\n        for n in nums:\\n            n -= 1\\n            maxi = self.getmax(st, max(0, n-k)+length, n+length) + 1\\n            self.update(st, maxi, n+length)\\n            ans = max(maxi, ans)\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588737,
                "title": "c-segment-tree-short-implementation-fast",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    \\n    int getSize(int n){\\n        int size = 1;\\n        for(;size < n; size<<=1);\\n        return size;\\n    }\\n    \\n    void insert(int index, int value, int size){\\n        for(int i = index + size - 1; i > 0; seg[i]=max(seg[i], value), i>>=1);\\n    }\\n    \\n    int get(int start, int end, int index, int l, int r){\\n        if(r < start || l > end)\\n            return 0;\\n        if(start <= l && r <= end){\\n            return seg[index];\\n        }\\n        int mid = (l + r) >> 1;\\n        return max(\\n            get(start, end, index << 1, l, mid), \\n            get(start, end, (index << 1) + 1, mid + 1, r)\\n        );\\n    }\\n        \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int size = getSize(1e5);\\n        seg = vector<int>(size * 2, 0);\\n        \\n        int ans{};\\n        \\n        for(int i = 1; i <= n; i++){\\n            int num = nums[i - 1];\\n            int mx = get(max(1, num - k), num - 1, 1, 1, size);\\n            insert(num, mx + 1, size);\\n            ans = max(ans, seg[num + size - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    \\n    int getSize(int n){\\n        int size = 1;\\n        for(;size < n; size<<=1);\\n        return size;\\n    }\\n    \\n    void insert(int index, int value, int size){\\n        for(int i = index + size - 1; i > 0; seg[i]=max(seg[i], value), i>>=1);\\n    }\\n    \\n    int get(int start, int end, int index, int l, int r){\\n        if(r < start || l > end)\\n            return 0;\\n        if(start <= l && r <= end){\\n            return seg[index];\\n        }\\n        int mid = (l + r) >> 1;\\n        return max(\\n            get(start, end, index << 1, l, mid), \\n            get(start, end, (index << 1) + 1, mid + 1, r)\\n        );\\n    }\\n        \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int size = getSize(1e5);\\n        seg = vector<int>(size * 2, 0);\\n        \\n        int ans{};\\n        \\n        for(int i = 1; i <= n; i++){\\n            int num = nums[i - 1];\\n            int mx = get(max(1, num - k), num - 1, 1, 1, size);\\n            insert(num, mx + 1, size);\\n            ans = max(ans, seg[num + size - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565909,
                "title": "java-segment-tree-beats-100",
                "content": "```\\nclass Solution {\\n    private int[] segments;\\n    private int n;\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        \\n        n = max;\\n        segments = new int[n*2];\\n        \\n        int res = 0;\\n        for (int num : nums) {\\n            int tmp = query(num-k-1 <= 0 ? 0 : num-k-1, num-2);\\n            update(num-1 + n, tmp + 1);\\n            res = Math.max(res, tmp+1);\\n        }\\n        return res;\\n    }\\n    \\n    private void update(int idx, int val) {\\n        segments[idx] = val;\\n        for (int i = idx; i > 1; i /= 2) {\\n            int p = i / 2;\\n            segments[p] = Math.max(segments[2*p], segments[2*p+1]);\\n        }\\n    }\\n    \\n    \\n    private int query(int left, int right) {\\n        left += n;\\n        right += n;\\n        \\n        int res = 0;\\n        \\n        while (left <= right) {\\n            if (left % 2 == 1) {\\n                res = Math.max(segments[left++], res);\\n            }\\n            \\n            if (right % 2 == 0) {\\n                res = Math.max(segments[right--], res);\\n            }\\n            \\n            left /= 2;\\n            right /= 2;\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int[] segments;\\n    private int n;\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        \\n        n = max;\\n        segments = new int[n*2];\\n        \\n        int res = 0;\\n        for (int num : nums) {\\n            int tmp = query(num-k-1 <= 0 ? 0 : num-k-1, num-2);\\n            update(num-1 + n, tmp + 1);\\n            res = Math.max(res, tmp+1);\\n        }\\n        return res;\\n    }\\n    \\n    private void update(int idx, int val) {\\n        segments[idx] = val;\\n        for (int i = idx; i > 1; i /= 2) {\\n            int p = i / 2;\\n            segments[p] = Math.max(segments[2*p], segments[2*p+1]);\\n        }\\n    }\\n    \\n    \\n    private int query(int left, int right) {\\n        left += n;\\n        right += n;\\n        \\n        int res = 0;\\n        \\n        while (left <= right) {\\n            if (left % 2 == 1) {\\n                res = Math.max(segments[left++], res);\\n            }\\n            \\n            if (right % 2 == 0) {\\n                res = Math.max(segments[right--], res);\\n            }\\n            \\n            left /= 2;\\n            right /= 2;\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565763,
                "title": "segment-tree-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    int n=100001;\\n    \\n    int query(int left, int right){\\n        int ans=0;\\n        for(left+=n, right+=n; left<right; left>>=1, right>>=1){\\n            if(left&1){\\n                ans=max(ans, seg[left++]);\\n            }\\n            if(right&1){\\n                ans=max(ans, seg[--right]);\\n            }\\n        }\\n            \\n        return ans;\\n    }\\n    \\n    void update(int index, int val){\\n        for(seg[index+=n]=val; index>1; index>>=1){\\n            seg[index>>1]=max(seg[index],seg[index^1]);\\n        }\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        seg.resize(2*n+1, 0);\\n        int ans=0;\\n        \\n        for(auto& i:nums){\\n            int left=max(i-k, 1);\\n            int sum=query(left, i);\\n            ans=max(ans, sum+1);\\n            update(i, sum+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    int n=100001;\\n    \\n    int query(int left, int right){\\n        int ans=0;\\n        for(left+=n, right+=n; left<right; left>>=1, right>>=1){\\n            if(left&1){\\n                ans=max(ans, seg[left++]);\\n            }\\n            if(right&1){\\n                ans=max(ans, seg[--right]);\\n            }\\n        }\\n            \\n        return ans;\\n    }\\n    \\n    void update(int index, int val){\\n        for(seg[index+=n]=val; index>1; index>>=1){\\n            seg[index>>1]=max(seg[index],seg[index^1]);\\n        }\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        seg.resize(2*n+1, 0);\\n        int ans=0;\\n        \\n        for(auto& i:nums){\\n            int left=max(i-k, 1);\\n            int sum=query(left, i);\\n            ans=max(ans, sum+1);\\n            update(i, sum+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564447,
                "title": "does-not-work-for-sequential-numbers-from-1-to-10-5-java-dp-with-memoization-tle",
                "content": "This one does not work for large test cases typically 1 to 100000 with unit increase. Looks like it should - any idea\\n\\n```\\nclass Solution {\\n    int res;\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int n = nums.length;\\n        // keep track of state\\n        Integer[] dp = new Integer [n];\\n        dp[n-1] = 1;\\n        res = 1;\\n        helper(0, nums, k , dp);\\n        return res;\\n    }\\n    private int helper(int sta, int[] nums, int k, Integer[] dp){\\n        int n = nums.length;\\n        if (sta >= n){\\n            return 0;\\n        }\\n        if (dp[sta] != null){\\n            return dp[sta];\\n        }\\n        int rslt = 1;\\n        for(int i = sta+1; i < n; i++){\\n            if (nums[i] > nums[sta] && \\n                nums[i] - nums[sta] <= k){\\n                rslt = Math.max(rslt, 1 + helper(i, nums, k, dp));\\n            } else {\\n                // skip the sta point - but traverse for i\\n                helper(i, nums, k, dp);\\n            }\\n        }\\n        dp[sta] = rslt;\\n        res = Math.max(rslt, res);\\n        return rslt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res;\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int n = nums.length;\\n        // keep track of state\\n        Integer[] dp = new Integer [n];\\n        dp[n-1] = 1;\\n        res = 1;\\n        helper(0, nums, k , dp);\\n        return res;\\n    }\\n    private int helper(int sta, int[] nums, int k, Integer[] dp){\\n        int n = nums.length;\\n        if (sta >= n){\\n            return 0;\\n        }\\n        if (dp[sta] != null){\\n            return dp[sta];\\n        }\\n        int rslt = 1;\\n        for(int i = sta+1; i < n; i++){\\n            if (nums[i] > nums[sta] && \\n                nums[i] - nums[sta] <= k){\\n                rslt = Math.max(rslt, 1 + helper(i, nums, k, dp));\\n            } else {\\n                // skip the sta point - but traverse for i\\n                helper(i, nums, k, dp);\\n            }\\n        }\\n        dp[sta] = rslt;\\n        res = Math.max(rslt, res);\\n        return rslt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563157,
                "title": "python-iterativr-segment-tree",
                "content": "```\\nclass ST:\\n    def __init__(self,n):\\n        self.arr=[0 for i in range(4*n)]\\n        self.n=n\\n\\n    def update(self,ind,val):\\n        def rec(i,l,r):\\n            if l==r:\\n                self.arr[i]=val\\n                return\\n            m=(l+r)//2\\n            if m>=ind:\\n                rec(2*i+1,l,m)\\n            else:\\n                rec(2*i+2,m+1,r)\\n            self.arr[i]=max(self.arr[2*i+1],self.arr[2*i+2])\\n        rec(0,0,self.n-1)\\n    def rangemax(self,left,right):\\n        def rec(i,l,r,left,right):\\n            if l>=left and r<=right:\\n                return self.arr[i]\\n            elif l>right or r<left:\\n                return 0\\n            else:\\n                m=(l+r)//2\\n                return max(rec(2*i+1,l,m,left,right),rec(2*i+2,m+1,r,left,right))\\n        return rec(0,0,self.n-1,left,right)\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        m=max(nums)\\n        obj=ST(m+1)\\n        ans=0\\n        for i in nums:\\n            prev=obj.rangemax(max(0,i-k),i-1)\\n            ans=max(ans,prev+1)\\n            obj.update(i,prev+1)\\n            # print(i,obj.arr)\\n        return ans\\n            \\n        \\n        \\n        \\n        \\nclass IST:\\n    def __init__(self,n):\\n        self.arr=[0 for i in range(2*n)]\\n        self.n=n\\n    def update(self,ind,val):\\n        ind+=self.n\\n        self.arr[ind]=val\\n        ind//=2\\n        while(ind>0):\\n            self.arr[ind]=max(self.arr[ind*2+1],self.arr[ind*2])\\n            ind//=2\\n            \\n    def rangemax(self,left,right):\\n        ans=0\\n        left+=self.n\\n        right+=self.n\\n        while(left<=right):\\n            if left&1:\\n                ans=max(ans,self.arr[left])\\n                left+=1\\n            if right&1==0:\\n                ans=max(ans,self.arr[right])\\n                right-=1\\n            left//=2\\n            right//=2\\n        return ans\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        m=max(nums)\\n        obj=IST(m+1)\\n        ans=0\\n        for i in nums:\\n            prev=obj.rangemax(max(0,i-k),i-1)\\n            ans=max(ans,prev+1)\\n            obj.update(i,prev+1)\\n            # print(i,obj.arr)\\n        return ans   \\n\\n        \\n        dici={}\\n        def rec(i,l):\\n            if i in dici:\\n                if l in dici[i]:\\n                    return dici[i][l]\\n            if i>=len(nums):\\n                return 0\\n            if l==-1:\\n                return max(rec(i+1,nums[i])+1,rec(i+1,l))\\n            take=0\\n            \\n            if nums[i]<=l or l+k<nums[i] :\\n                take= 0\\n            else:\\n                take=rec(i+1,nums[i])+1\\n            ans= max(take,rec(i+1,l))\\n            if i not in dici:\\n                dici[i]={}\\n            dici[i][l]=ans\\n            return ans\\n            \\n        return rec(0,-1)\\n  \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass ST:\\n    def __init__(self,n):\\n        self.arr=[0 for i in range(4*n)]\\n        self.n=n\\n\\n    def update(self,ind,val):\\n        def rec(i,l,r):\\n            if l==r:\\n                self.arr[i]=val\\n                return\\n            m=(l+r)//2\\n            if m>=ind:\\n                rec(2*i+1,l,m)\\n            else:\\n                rec(2*i+2,m+1,r)\\n            self.arr[i]=max(self.arr[2*i+1],self.arr[2*i+2])\\n        rec(0,0,self.n-1)\\n    def rangemax(self,left,right):\\n        def rec(i,l,r,left,right):\\n            if l>=left and r<=right:\\n                return self.arr[i]\\n            elif l>right or r<left:\\n                return 0\\n            else:\\n                m=(l+r)//2\\n                return max(rec(2*i+1,l,m,left,right),rec(2*i+2,m+1,r,left,right))\\n        return rec(0,0,self.n-1,left,right)\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        m=max(nums)\\n        obj=ST(m+1)\\n        ans=0\\n        for i in nums:\\n            prev=obj.rangemax(max(0,i-k),i-1)\\n            ans=max(ans,prev+1)\\n            obj.update(i,prev+1)\\n            # print(i,obj.arr)\\n        return ans\\n            \\n        \\n        \\n        \\n        \\nclass IST:\\n    def __init__(self,n):\\n        self.arr=[0 for i in range(2*n)]\\n        self.n=n\\n    def update(self,ind,val):\\n        ind+=self.n\\n        self.arr[ind]=val\\n        ind//=2\\n        while(ind>0):\\n            self.arr[ind]=max(self.arr[ind*2+1],self.arr[ind*2])\\n            ind//=2\\n            \\n    def rangemax(self,left,right):\\n        ans=0\\n        left+=self.n\\n        right+=self.n\\n        while(left<=right):\\n            if left&1:\\n                ans=max(ans,self.arr[left])\\n                left+=1\\n            if right&1==0:\\n                ans=max(ans,self.arr[right])\\n                right-=1\\n            left//=2\\n            right//=2\\n        return ans\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        m=max(nums)\\n        obj=IST(m+1)\\n        ans=0\\n        for i in nums:\\n            prev=obj.rangemax(max(0,i-k),i-1)\\n            ans=max(ans,prev+1)\\n            obj.update(i,prev+1)\\n            # print(i,obj.arr)\\n        return ans   \\n\\n        \\n        dici={}\\n        def rec(i,l):\\n            if i in dici:\\n                if l in dici[i]:\\n                    return dici[i][l]\\n            if i>=len(nums):\\n                return 0\\n            if l==-1:\\n                return max(rec(i+1,nums[i])+1,rec(i+1,l))\\n            take=0\\n            \\n            if nums[i]<=l or l+k<nums[i] :\\n                take= 0\\n            else:\\n                take=rec(i+1,nums[i])+1\\n            ans= max(take,rec(i+1,l))\\n            if i not in dici:\\n                dici[i]={}\\n            dici[i][l]=ans\\n            return ans\\n            \\n        return rec(0,-1)\\n  \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563020,
                "title": "kotlin-segment-tree",
                "content": "```kotlin\\nimport kotlin.math.max\\nimport kotlin.math.min\\n\\nclass Solution {\\n    companion object {\\n        const val MAX_VALUE = 100010\\n    }\\n\\n    fun lengthOfLIS(nums: IntArray, k: Int): Int {\\n        val tree = Tree(MAX_VALUE)\\n        var answer = 0\\n\\n        nums.forEach { cur ->\\n            val prev = max(0, cur - k)\\n            val bestAnswer = tree.get(prev, cur - 1) + 1\\n            val prevAnswer = tree.get(cur, cur)\\n            val result = max(bestAnswer, prevAnswer)\\n            \\n            tree.set(cur, result)\\n            answer = max(answer, result)\\n        }\\n\\n        return answer\\n    }\\n}\\n\\nclass Tree(private val size: Int) {\\n    private val root: Node\\n\\n    init {\\n        this.root = build(0, size)\\n    }\\n\\n    fun get(from: Int, to: Int): Int {\\n        return get(this.root, 0, this.size, from, to)\\n    }\\n\\n    private fun get(node: Node, left: Int, right: Int, from: Int, to: Int): Int {\\n        if (to < from) {\\n            return 0\\n        }\\n\\n        if (from <= left && right <= to) {\\n            return node.value\\n        }\\n\\n        val mid = (left + right) / 2\\n        return max(\\n            get(node.left!!, left, mid, from, min(mid, to)),\\n            get(node.right!!, mid + 1, right, max(mid + 1, from), to)\\n        )\\n    }\\n\\n    fun set(idx: Int, value: Int) {\\n        set(this.root, 0, this.size, idx, value)\\n    }\\n\\n    private fun set(node: Node, left: Int, right: Int, idx: Int, value: Int) {\\n        if (left > idx || right < idx) {\\n            return\\n        }\\n\\n        if (left == right) {\\n            node.value = value\\n        } else {\\n            val mid = (left + right) / 2\\n            set(node.left!!, left, mid, idx, value)\\n            set(node.right!!, mid + 1, right, idx, value)\\n\\n            node.value = max(node.left!!.value, node.right!!.value)\\n        }\\n    }\\n\\n    private fun build(from: Int, to: Int): Node {\\n        return if (from == to) {\\n            Node(0)\\n        } else if (from > to) {\\n            throw IllegalArgumentException(\"Unexpected range $from..$to\")\\n        } else {\\n            val mid = (from + to) / 2\\n            val left = build(from, mid)\\n            val right = build(mid + 1, to)\\n\\n            Node(left, right)\\n        }\\n    }\\n}\\n\\ndata class Node(var value: Int) {\\n    var left: Node? = null\\n    var right: Node? = null\\n\\n    constructor(left: Node, right: Node) : this(max(left.value, right.value)) {\\n        this.left = left\\n        this.right = right\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree"
                ],
                "code": "```kotlin\\nimport kotlin.math.max\\nimport kotlin.math.min\\n\\nclass Solution {\\n    companion object {\\n        const val MAX_VALUE = 100010\\n    }\\n\\n    fun lengthOfLIS(nums: IntArray, k: Int): Int {\\n        val tree = Tree(MAX_VALUE)\\n        var answer = 0\\n\\n        nums.forEach { cur ->\\n            val prev = max(0, cur - k)\\n            val bestAnswer = tree.get(prev, cur - 1) + 1\\n            val prevAnswer = tree.get(cur, cur)\\n            val result = max(bestAnswer, prevAnswer)\\n            \\n            tree.set(cur, result)\\n            answer = max(answer, result)\\n        }\\n\\n        return answer\\n    }\\n}\\n\\nclass Tree(private val size: Int) {\\n    private val root: Node\\n\\n    init {\\n        this.root = build(0, size)\\n    }\\n\\n    fun get(from: Int, to: Int): Int {\\n        return get(this.root, 0, this.size, from, to)\\n    }\\n\\n    private fun get(node: Node, left: Int, right: Int, from: Int, to: Int): Int {\\n        if (to < from) {\\n            return 0\\n        }\\n\\n        if (from <= left && right <= to) {\\n            return node.value\\n        }\\n\\n        val mid = (left + right) / 2\\n        return max(\\n            get(node.left!!, left, mid, from, min(mid, to)),\\n            get(node.right!!, mid + 1, right, max(mid + 1, from), to)\\n        )\\n    }\\n\\n    fun set(idx: Int, value: Int) {\\n        set(this.root, 0, this.size, idx, value)\\n    }\\n\\n    private fun set(node: Node, left: Int, right: Int, idx: Int, value: Int) {\\n        if (left > idx || right < idx) {\\n            return\\n        }\\n\\n        if (left == right) {\\n            node.value = value\\n        } else {\\n            val mid = (left + right) / 2\\n            set(node.left!!, left, mid, idx, value)\\n            set(node.right!!, mid + 1, right, idx, value)\\n\\n            node.value = max(node.left!!.value, node.right!!.value)\\n        }\\n    }\\n\\n    private fun build(from: Int, to: Int): Node {\\n        return if (from == to) {\\n            Node(0)\\n        } else if (from > to) {\\n            throw IllegalArgumentException(\"Unexpected range $from..$to\")\\n        } else {\\n            val mid = (from + to) / 2\\n            val left = build(from, mid)\\n            val right = build(mid + 1, to)\\n\\n            Node(left, right)\\n        }\\n    }\\n}\\n\\ndata class Node(var value: Int) {\\n    var left: Node? = null\\n    var right: Node? = null\\n\\n    constructor(left: Node, right: Node) : this(max(left.value, right.value)) {\\n        this.left = left\\n        this.right = right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560944,
                "title": "simple-java-solution-using-treeset",
                "content": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        ArrayList<TreeSet> arr=new ArrayList<>();\\n        arr.add(new TreeSet());\\n        for(int i=0;i<nums.length;i++){\\n            int val=nums[i];\\n            int n=arr.size();\\n            if(arr.get(0).lower(val)==null ){\\n                arr.get(0).add(val);\\n            }\\n            else if(arr.get(n-1).lower(val)!=null && (val-(int)arr.get(n-1).lower(val))<=k){\\n                arr.add(new TreeSet());\\n                arr.get(n).add(val);\\n            }\\n            else{\\n                int idx=binSearch(arr,val,k);\\n                arr.get(idx).add(val);\\n            }\\n        }\\n        return arr.size();\\n    }\\n    public int binSearch(ArrayList<TreeSet> arr,int val,int k){\\n        int i=0;\\n        int j=arr.size()-1;\\n        int idx=-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(arr.get(mid).lower(val)!=null && (val-(int)arr.get(mid).lower(val))<=k){\\n                idx=mid;\\n                i=mid+1;\\n            }\\n            else if(arr.get(mid).lower(val)!=null && (val-(int)arr.get(mid).lower(val))>k){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return idx+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        ArrayList<TreeSet> arr=new ArrayList<>();\\n        arr.add(new TreeSet());\\n        for(int i=0;i<nums.length;i++){\\n            int val=nums[i];\\n            int n=arr.size();\\n            if(arr.get(0).lower(val)==null ){\\n                arr.get(0).add(val);\\n            }\\n            else if(arr.get(n-1).lower(val)!=null && (val-(int)arr.get(n-1).lower(val))<=k){\\n                arr.add(new TreeSet());\\n                arr.get(n).add(val);\\n            }\\n            else{\\n                int idx=binSearch(arr,val,k);\\n                arr.get(idx).add(val);\\n            }\\n        }\\n        return arr.size();\\n    }\\n    public int binSearch(ArrayList<TreeSet> arr,int val,int k){\\n        int i=0;\\n        int j=arr.size()-1;\\n        int idx=-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(arr.get(mid).lower(val)!=null && (val-(int)arr.get(mid).lower(val))<=k){\\n                idx=mid;\\n                i=mid+1;\\n            }\\n            else if(arr.get(mid).lower(val)!=null && (val-(int)arr.get(mid).lower(val))>k){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return idx+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560773,
                "title": "segment-tree-java",
                "content": "For eg: 4,2,1,4,3,4,5,8,15\\nat each index i,\\nnums[i] -> find longest subsequence between in segment tree [max(1, nums[i] -k), nums[i] - 1)]\\nand then update segment tree for nums[i] with (longest subsequence + 1).\\n\\nfor index 6, nums[6] = 5\\nstart range = 5 - 3 = 2\\nend range = 5 - 1 = 4\\nlongest subsequece in range [2,4] is 3. i.e {1,3,4}\\nand then update 5 in ST to (3 + 1).i.e 4\\n\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int n = nums.length;\\n        SegTree segTree = new SegTree(maxValue(nums) + 1);\\n        \\n        int ans = 1;\\n        for(int i = 0; i < n; i++) {\\n            int start = Math.max(1, nums[i] - k);\\n            int end = nums[i] - 1;\\n            int res = segTree.query(start, end);\\n            ans = Math.max(ans, 1 + res);\\n            segTree.update(nums[i], res + 1);\\n        }\\n        return ans;\\n    }\\n    \\n    private int maxValue(int[] nums) {\\n        int max = 0;\\n        for(int num : nums)\\n            max = Math.max(max, num);\\n        return max;\\n    }\\n    \\n}\\n\\nclass SegTree {\\n    int[] tree;\\n    int n;\\n    \\n    SegTree(int n) {\\n        this.n = n;\\n        tree = new int[4 * n];\\n    }\\n    \\n    public void update(int i, int val) {\\n        update(0, n - 1, i, 0, val);\\n    }\\n    \\n    private void update(int l, int r, int i, int node, int val) {\\n        if(l == r) {\\n            tree[node] = val;\\n            return;\\n        }\\n        int mid = l + (r - l) / 2;\\n        if(i <= mid) update(l, mid, i, 2 * node + 1, val);\\n        else update(mid + 1, r, i, 2 * node + 2, val);\\n        tree[node] = Math.max(tree[node], Math.max(tree[2 * node + 1], tree[2 * node + 2]));\\n    }\\n    \\n    public int query(int st, int end) {\\n        return query(0, n - 1, st, end, 0);\\n    }\\n    \\n    private int query(int l, int r, int st, int end, int node) {\\n        if(l > end || r < st) return 0;\\n        if(l >= st && r <= end) {\\n            return tree[node];\\n        }\\n        int mid = l + (r - l) / 2;\\n        int res = query(l, mid, st, end, 2 * node + 1);\\n        res = Math.max(res, query(mid + 1, r, st, end, 2 * node + 2));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int n = nums.length;\\n        SegTree segTree = new SegTree(maxValue(nums) + 1);\\n        \\n        int ans = 1;\\n        for(int i = 0; i < n; i++) {\\n            int start = Math.max(1, nums[i] - k);\\n            int end = nums[i] - 1;\\n            int res = segTree.query(start, end);\\n            ans = Math.max(ans, 1 + res);\\n            segTree.update(nums[i], res + 1);\\n        }\\n        return ans;\\n    }\\n    \\n    private int maxValue(int[] nums) {\\n        int max = 0;\\n        for(int num : nums)\\n            max = Math.max(max, num);\\n        return max;\\n    }\\n    \\n}\\n\\nclass SegTree {\\n    int[] tree;\\n    int n;\\n    \\n    SegTree(int n) {\\n        this.n = n;\\n        tree = new int[4 * n];\\n    }\\n    \\n    public void update(int i, int val) {\\n        update(0, n - 1, i, 0, val);\\n    }\\n    \\n    private void update(int l, int r, int i, int node, int val) {\\n        if(l == r) {\\n            tree[node] = val;\\n            return;\\n        }\\n        int mid = l + (r - l) / 2;\\n        if(i <= mid) update(l, mid, i, 2 * node + 1, val);\\n        else update(mid + 1, r, i, 2 * node + 2, val);\\n        tree[node] = Math.max(tree[node], Math.max(tree[2 * node + 1], tree[2 * node + 2]));\\n    }\\n    \\n    public int query(int st, int end) {\\n        return query(0, n - 1, st, end, 0);\\n    }\\n    \\n    private int query(int l, int r, int st, int end, int node) {\\n        if(l > end || r < st) return 0;\\n        if(l >= st && r <= end) {\\n            return tree[node];\\n        }\\n        int mid = l + (r - l) / 2;\\n        int res = query(l, mid, st, end, 2 * node + 1);\\n        res = Math.max(res, query(mid + 1, r, st, end, 2 * node + 2));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560651,
                "title": "java-original-lis-solution-no-segment-tree",
                "content": "Use the same idea as the original LIS, just instead of storing the smallest possible number, here we need to store the whole sequence.\\n\\n```\\n    public int lengthOfLIS(int[] nums, int k) {\\n        List<List<Integer>> tails = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            int ind = Collections.binarySearch(tails, List.of(num), Comparator.comparingInt(i -> i.get(0)));\\n            if (ind < 0) {\\n                ind = ~ind;\\n                while (ind > 0) {\\n                    List<Integer> prevNums = tails.get(ind - 1);\\n                    int insertInd = Collections.binarySearch(prevNums, num);\\n                    if (insertInd < 0) {\\n                        insertInd = ~insertInd;\\n                    }\\n\\n                    if (insertInd > 0 && prevNums.get(insertInd - 1) >= num - k) {\\n                        break;\\n                    } else {\\n                        ind--;\\n                    }\\n                }\\n                insertToList(tails, ind, num);\\n            }\\n        }\\n\\n        return tails.size();\\n    }\\n\\n    private void insertToList(List<List<Integer>> tails, int ind, int num) {\\n        if (ind == tails.size()) {\\n            tails.add(new ArrayList<>());\\n        }\\n\\n        int insertInd = Collections.binarySearch(tails.get(ind), num);\\n        if (insertInd < 0) {\\n            insertInd = ~insertInd;\\n            tails.get(ind).add(insertInd, num);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n    public int lengthOfLIS(int[] nums, int k) {\\n        List<List<Integer>> tails = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            int ind = Collections.binarySearch(tails, List.of(num), Comparator.comparingInt(i -> i.get(0)));\\n            if (ind < 0) {\\n                ind = ~ind;\\n                while (ind > 0) {\\n                    List<Integer> prevNums = tails.get(ind - 1);\\n                    int insertInd = Collections.binarySearch(prevNums, num);\\n                    if (insertInd < 0) {\\n                        insertInd = ~insertInd;\\n                    }\\n\\n                    if (insertInd > 0 && prevNums.get(insertInd - 1) >= num - k) {\\n                        break;\\n                    } else {\\n                        ind--;\\n                    }\\n                }\\n                insertToList(tails, ind, num);\\n            }\\n        }\\n\\n        return tails.size();\\n    }\\n\\n    private void insertToList(List<List<Integer>> tails, int ind, int num) {\\n        if (ind == tails.size()) {\\n            tails.add(new ArrayList<>());\\n        }\\n\\n        int insertInd = Collections.binarySearch(tails.get(ind), num);\\n        if (insertInd < 0) {\\n            insertInd = ~insertInd;\\n            tails.get(ind).add(insertInd, num);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560608,
                "title": "javascript-segment-tree-range-min-query-281ms",
                "content": "```\\n///////////////////////////////////////////// Template ///////////////////////////////////////////////////////////\\n// using array format\\nfunction SegmentTreeRMQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(Number.MAX_SAFE_INTEGER);\\n    h = 2 ** h;\\n    return { update, minx, indexOf, tree }\\n    function update(pos, v) {\\n        a[h + pos] = v;\\n        for (let i = parent(h + pos); i >= 1; i = parent(i)) propagate(i);\\n    }\\n    function propagate(i) {\\n        a[i] = Math.min(a[left(i)], a[right(i)]);\\n    }\\n    function minx(l, r) {\\n        let min = Number.MAX_SAFE_INTEGER;\\n        if (l >= r) return min;\\n        l += h;\\n        r += h;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) min = Math.min(min, a[l++]);\\n            if (r & 1) min = Math.min(min, a[--r]);\\n        }\\n        return min;\\n    }\\n    function indexOf(l, v) {\\n        if (l >= h) return -1;\\n        let cur = h + l;\\n        while (1) {\\n            if (a[cur] <= v) {\\n                if (cur >= h) return cur - h;\\n                cur = left(cur);\\n            } else {\\n                cur++;\\n                if ((cur & cur - 1) == 0) return -1;\\n                if (cur % 2 == 0) cur = parent(cur);\\n            }\\n        }\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst lengthOfLIS = (a, k) => {\\n    let max = Math.max(...a), st = new SegmentTreeRMQ(max + 3), res = 0;\\n    for (const x of a) {\\n        let l = Math.max(x-k, 0), r = x;\\n        let min = st.minx(l, r), maxL = min == Number.MAX_SAFE_INTEGER ? 0 : -min;\\n        maxL++;\\n        res = Math.max(res, maxL);\\n        st.update(x, -maxL);\\n    }\\n    return res;\\n};\\n```\\nsimilar problem using same template\\nhttps://leetcode.com/problems/booking-concert-tickets-in-groups/\\nhttps://leetcode.com/problems/maximum-distance-between-a-pair-of-values/\\nhttps://leetcode.com/problems/jump-game-vi/\\n\\nmy solution:\\nhttps://leetcode.com/problems/booking-concert-tickets-in-groups/discuss/2085140/javascript-segment-tree-(range-min-query)-%2B-fenwick-(query-prefix-sum)-560ms\\nhttps://leetcode.com/problems/maximum-distance-between-a-pair-of-values/discuss/1198943/javascript-segment-tree-range-min-query-296ms\\nhttps://leetcode.com/problems/jump-game-vi/discuss/981037/javascript-SegmentTreeRMQ-312ms",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\n///////////////////////////////////////////// Template ///////////////////////////////////////////////////////////\\n// using array format\\nfunction SegmentTreeRMQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(Number.MAX_SAFE_INTEGER);\\n    h = 2 ** h;\\n    return { update, minx, indexOf, tree }\\n    function update(pos, v) {\\n        a[h + pos] = v;\\n        for (let i = parent(h + pos); i >= 1; i = parent(i)) propagate(i);\\n    }\\n    function propagate(i) {\\n        a[i] = Math.min(a[left(i)], a[right(i)]);\\n    }\\n    function minx(l, r) {\\n        let min = Number.MAX_SAFE_INTEGER;\\n        if (l >= r) return min;\\n        l += h;\\n        r += h;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) min = Math.min(min, a[l++]);\\n            if (r & 1) min = Math.min(min, a[--r]);\\n        }\\n        return min;\\n    }\\n    function indexOf(l, v) {\\n        if (l >= h) return -1;\\n        let cur = h + l;\\n        while (1) {\\n            if (a[cur] <= v) {\\n                if (cur >= h) return cur - h;\\n                cur = left(cur);\\n            } else {\\n                cur++;\\n                if ((cur & cur - 1) == 0) return -1;\\n                if (cur % 2 == 0) cur = parent(cur);\\n            }\\n        }\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst lengthOfLIS = (a, k) => {\\n    let max = Math.max(...a), st = new SegmentTreeRMQ(max + 3), res = 0;\\n    for (const x of a) {\\n        let l = Math.max(x-k, 0), r = x;\\n        let min = st.minx(l, r), maxL = min == Number.MAX_SAFE_INTEGER ? 0 : -min;\\n        maxL++;\\n        res = Math.max(res, maxL);\\n        st.update(x, -maxL);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560331,
                "title": "rust-segment-tree-with-comments",
                "content": "This is my unrevised submission for the 2022-09-11 Weekly Contest 310. This is a DP problem - add one to the path length of the longest path found so far among the numbers that are no less than k smaller than the current number. But the difficult part is that the O(n^2) needed for a standard implementation is too slow. So we need a segment max tree to be able to do O(log(n)) searches for the max DP entry within an interval. \\n\\nComment: So very happy that I managed to solve the hard problem for this contest. I first did the simple bottom-up DP solution, and didn\\'t understand what was so hard about the problem until I submitted. I had recently done a segment sum tree, so with that in mind, I quickly made a similar segment max tree. Even then, some minor bugs tripped me up for a long time, and I got the working solution submitted with two minutes left to go. Phew.\\n\\n```\\npub struct SegmentTree<T> {\\n    n: usize,\\n    tree: Vec<T>,\\n}\\n\\nimpl<T> SegmentTree<T>\\nwhere\\n    T: Copy + Ord + Default,\\n{\\n    pub fn new(nums: &[T]) -> Self {\\n        let n = nums.len();\\n        let mut tree: Vec<_> = std::iter::repeat(T::default())\\n            .take(n)\\n            .chain(nums.iter().copied())\\n            .collect();\\n        for i in (1..n).rev() {\\n            tree[i] = tree[2 * i].max(tree[2 * i + 1]);\\n        }\\n        Self { n, tree }\\n    }\\n\\n    pub fn update(&mut self, index: usize, val: T) {\\n        let mut i = index + self.n;\\n        self.tree[i] = val;\\n        while i > 0 {\\n            let (child1, child2) = (i, if i % 2 == 0 { i + 1 } else { i - 1 });\\n            i /= 2;\\n            self.tree[i] = self.tree[child1].max(self.tree[child2]);\\n        }\\n    }\\n\\n    pub fn max_range(&self, left: usize, right: usize) -> T {\\n        let (mut left, mut right) = (left as usize + self.n, right as usize + self.n);\\n        let mut max = T::default();\\n        while left <= right {\\n            if left % 2 == 1 {\\n                max = max.max(self.tree[left]);\\n                left += 1;\\n            }\\n            if right % 2 == 0 {\\n                max = max.max(self.tree[right]);\\n                right -= 1;\\n            }\\n            left /= 2;\\n            right /= 2;\\n        }\\n        max\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut dp = SegmentTree::new(&[0; 100002]);\\n        let mut global_max = 1;\\n        for i in 0..n {\\n            let (low, high) = (0.max(nums[i]-k) as usize, 0.max(nums[i] - 1) as usize);\\n            let max = dp.max_range(low, high) + 1;\\n            global_max = global_max.max(max);\\n            dp.update(nums[i] as usize, max);\\n        }\\n        global_max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct SegmentTree<T> {\\n    n: usize,\\n    tree: Vec<T>,\\n}\\n\\nimpl<T> SegmentTree<T>\\nwhere\\n    T: Copy + Ord + Default,\\n{\\n    pub fn new(nums: &[T]) -> Self {\\n        let n = nums.len();\\n        let mut tree: Vec<_> = std::iter::repeat(T::default())\\n            .take(n)\\n            .chain(nums.iter().copied())\\n            .collect();\\n        for i in (1..n).rev() {\\n            tree[i] = tree[2 * i].max(tree[2 * i + 1]);\\n        }\\n        Self { n, tree }\\n    }\\n\\n    pub fn update(&mut self, index: usize, val: T) {\\n        let mut i = index + self.n;\\n        self.tree[i] = val;\\n        while i > 0 {\\n            let (child1, child2) = (i, if i % 2 == 0 { i + 1 } else { i - 1 });\\n            i /= 2;\\n            self.tree[i] = self.tree[child1].max(self.tree[child2]);\\n        }\\n    }\\n\\n    pub fn max_range(&self, left: usize, right: usize) -> T {\\n        let (mut left, mut right) = (left as usize + self.n, right as usize + self.n);\\n        let mut max = T::default();\\n        while left <= right {\\n            if left % 2 == 1 {\\n                max = max.max(self.tree[left]);\\n                left += 1;\\n            }\\n            if right % 2 == 0 {\\n                max = max.max(self.tree[right]);\\n                right -= 1;\\n            }\\n            left /= 2;\\n            right /= 2;\\n        }\\n        max\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut dp = SegmentTree::new(&[0; 100002]);\\n        let mut global_max = 1;\\n        for i in 0..n {\\n            let (low, high) = (0.max(nums[i]-k) as usize, 0.max(nums[i] - 1) as usize);\\n            let max = dp.max_range(low, high) + 1;\\n            global_max = global_max.max(max);\\n            dp.update(nums[i] as usize, max);\\n        }\\n        global_max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560294,
                "title": "python3-segment-tree",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b89b2c654a0b8ced9885ecdb433ad5f929a1d4b4) for solutions of weekly 310. \\n\\n```\\nclass SegTree: \\n\\n    def __init__(self, arr: List[int]): \\n        self.n = len(arr)\\n        self.tree = [0] * (2*self.n)\\n        # for i in range(2*self.n-1, 0, -1): \\n        #     if i >= self.n: self.tree[i] = arr[i - self.n]\\n        #     else: self.tree[i] = max(self.tree[i<<1], self.tree[i<<1|1])\\n\\n    def query(self, lo: int, hi: int) -> int: \\n        ans = 0 \\n        lo += self.n \\n        hi += self.n\\n        while lo < hi: \\n            if lo & 1: \\n                ans = max(ans, self.tree[lo])\\n                lo += 1\\n            if hi & 1: \\n                hi -= 1\\n                ans = max(ans, self.tree[hi])\\n            lo >>= 1\\n            hi >>= 1\\n        return ans \\n\\n    def update(self, i: int, val: int) -> None: \\n        i += self.n \\n        self.tree[i] = val\\n        while i > 1: \\n            self.tree[i>>1] = max(self.tree[i], self.tree[i^1])\\n            i >>= 1\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        m = max(nums)\\n        ans = 0 \\n        tree = SegTree([0] * (m+1))\\n        for x in nums: \\n            val = tree.query(max(0, x-k), x) + 1\\n            ans = max(ans, val)\\n            tree.update(x, val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SegTree: \\n\\n    def __init__(self, arr: List[int]): \\n        self.n = len(arr)\\n        self.tree = [0] * (2*self.n)\\n        # for i in range(2*self.n-1, 0, -1): \\n        #     if i >= self.n: self.tree[i] = arr[i - self.n]\\n        #     else: self.tree[i] = max(self.tree[i<<1], self.tree[i<<1|1])\\n\\n    def query(self, lo: int, hi: int) -> int: \\n        ans = 0 \\n        lo += self.n \\n        hi += self.n\\n        while lo < hi: \\n            if lo & 1: \\n                ans = max(ans, self.tree[lo])\\n                lo += 1\\n            if hi & 1: \\n                hi -= 1\\n                ans = max(ans, self.tree[hi])\\n            lo >>= 1\\n            hi >>= 1\\n        return ans \\n\\n    def update(self, i: int, val: int) -> None: \\n        i += self.n \\n        self.tree[i] = val\\n        while i > 1: \\n            self.tree[i>>1] = max(self.tree[i], self.tree[i^1])\\n            i >>= 1\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        m = max(nums)\\n        ans = 0 \\n        tree = SegTree([0] * (m+1))\\n        for x in nums: \\n            val = tree.query(max(0, x-k), x) + 1\\n            ans = max(ans, val)\\n            tree.update(x, val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560176,
                "title": "segment-tree-c",
                "content": "Firstly,you have to create array of size 1e5+100, because values of array is 1<=v[i]<=1e5. Assume that Array name is \\'Seg\\'\\nNow, you have to insert elements one by one. Assume that you Reached element at index i and value of that element is X. now you have to find maximam value of rang Seg[X-k,X-1]. To find this maximam value of rang you have to use \\'segment-tree\\'.\\nAssume that  vales of rang is mx1. Now you have to udate that value with previous one. To do this you have to use \\'lazy-propagation\\'.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& v1, int k) {\\n    // v =  {1,-10,5,6,10};\\n    // int n = v.size();\\n        \\n    int ra = (1e5+100);\\n    vector<int> v(ra);\\n    vector<int> segtree(4*ra),lazy(4*ra);\\n    function<int(int,int,int)> makeseg = [&](int s,int e,int po)\\n    {\\n \\n        if(s==e)\\n            return segtree[po] = v[s];\\n        return segtree[po] = max(makeseg(s,(s+e)/2,2*po+1),makeseg((s+e)/2+1,e,2*po+2));\\n    };\\n \\n    makeseg(0,ra-1,0);\\n \\n    function<void(int,int,int,int,int,int)> changelazy = [&](int s,int e,int ps,int pe,int val,int po)\\n    {\\n        if(e<s)\\n            return ;\\n \\n        if(lazy[po]!=0)\\n        {\\n            segtree[po] += lazy[po];\\n            if(s!=e)\\n            {\\n                lazy[2*po + 1] += lazy[po];\\n                lazy[2*po + 2] += lazy[po];\\n            }\\n \\n            lazy[po] = 0;\\n        }\\n \\n \\n        if(e<ps || s>pe){\\n            return ;\\n        }\\n \\n        if(ps<=s && e<=pe)  \\n        {\\n            segtree[po] += val;\\n            if(s!=e)\\n            {\\n                lazy[2*po+1] += val;\\n                lazy[2*po+2] += val;\\n            }\\n \\n            return ;\\n        }\\n \\n        int mid = (s+e)/2;\\n \\n        changelazy(s,mid,ps,pe,val,2*po+1);\\n        changelazy(mid+1,e,ps,pe,val,2*po+2);\\n        segtree[po] = max(segtree[2*po+1],segtree[2*po+2]);\\n \\n    };\\n \\n \\n    function<int(int,int,int,int,int)> getmin = [&](int s,int e,int ps,int pe,int po)\\n    {   \\n        if(lazy[po]!=0)\\n        {\\n            segtree[po] += lazy[po];\\n            if(s!=e)\\n            {\\n                lazy[2*po + 1] += lazy[po];\\n                lazy[2*po + 2] += lazy[po];\\n            }\\n \\n            lazy[po] = 0;\\n        }\\n \\n \\n        if(ps<=s && e<=pe){\\n            return segtree[po];\\n        }\\n        if(e<ps || s>pe)\\n            return (int)(0);\\n \\n        int mid = (s+e)/2;\\n \\n        return max(getmin(s,mid,ps,pe,2*po+1),getmin(mid+1,e,ps,pe,2*po+2));\\n    };\\n    \\n    int ans = 0;\\n    for(int i=0; i<(int)v1.size(); ++i)\\n    {\\n        int x = v1[i];\\n        int mx = getmin(0,ra-1,max(x-k,0),x-1,0);\\n        ans =  max(ans,mx+1);\\n        int ele = getmin(0,ra-1,x,x,0);\\n        ele = mx+1-ele;\\n        changelazy(0,ra-1,x,x,ele,0);\\n    }\\n        \\n        \\n    return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& v1, int k) {\\n    // v =  {1,-10,5,6,10};\\n    // int n = v.size();\\n        \\n    int ra = (1e5+100);\\n    vector<int> v(ra);\\n    vector<int> segtree(4*ra),lazy(4*ra);\\n    function<int(int,int,int)> makeseg = [&](int s,int e,int po)\\n    {\\n \\n        if(s==e)\\n            return segtree[po] = v[s];\\n        return segtree[po] = max(makeseg(s,(s+e)/2,2*po+1),makeseg((s+e)/2+1,e,2*po+2));\\n    };\\n \\n    makeseg(0,ra-1,0);\\n \\n    function<void(int,int,int,int,int,int)> changelazy = [&](int s,int e,int ps,int pe,int val,int po)\\n    {\\n        if(e<s)\\n            return ;\\n \\n        if(lazy[po]!=0)\\n        {\\n            segtree[po] += lazy[po];\\n            if(s!=e)\\n            {\\n                lazy[2*po + 1] += lazy[po];\\n                lazy[2*po + 2] += lazy[po];\\n            }\\n \\n            lazy[po] = 0;\\n        }\\n \\n \\n        if(e<ps || s>pe){\\n            return ;\\n        }\\n \\n        if(ps<=s && e<=pe)  \\n        {\\n            segtree[po] += val;\\n            if(s!=e)\\n            {\\n                lazy[2*po+1] += val;\\n                lazy[2*po+2] += val;\\n            }\\n \\n            return ;\\n        }\\n \\n        int mid = (s+e)/2;\\n \\n        changelazy(s,mid,ps,pe,val,2*po+1);\\n        changelazy(mid+1,e,ps,pe,val,2*po+2);\\n        segtree[po] = max(segtree[2*po+1],segtree[2*po+2]);\\n \\n    };\\n \\n \\n    function<int(int,int,int,int,int)> getmin = [&](int s,int e,int ps,int pe,int po)\\n    {   \\n        if(lazy[po]!=0)\\n        {\\n            segtree[po] += lazy[po];\\n            if(s!=e)\\n            {\\n                lazy[2*po + 1] += lazy[po];\\n                lazy[2*po + 2] += lazy[po];\\n            }\\n \\n            lazy[po] = 0;\\n        }\\n \\n \\n        if(ps<=s && e<=pe){\\n            return segtree[po];\\n        }\\n        if(e<ps || s>pe)\\n            return (int)(0);\\n \\n        int mid = (s+e)/2;\\n \\n        return max(getmin(s,mid,ps,pe,2*po+1),getmin(mid+1,e,ps,pe,2*po+2));\\n    };\\n    \\n    int ans = 0;\\n    for(int i=0; i<(int)v1.size(); ++i)\\n    {\\n        int x = v1[i];\\n        int mx = getmin(0,ra-1,max(x-k,0),x-1,0);\\n        ans =  max(ans,mx+1);\\n        int ele = getmin(0,ra-1,x,x,0);\\n        ele = mx+1-ele;\\n        changelazy(0,ra-1,x,x,ele,0);\\n    }\\n        \\n        \\n    return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560030,
                "title": "c-dp-o-nlog-n-segment-tree",
                "content": "```\\n\\t/*\\n\\t\\tsubproblem first you guys can try finding longest increasing subsequence in nlog(n) using a map \\n\\t\\tafter that instead of map if you use segment tree you can find max of k elements smaller than current element in logirithmic time \\n\\t*/\\n\\tstruct node{\\n\\t\\tint x;\\n\\t\\tnode()\\n\\t\\t{\\n\\t\\t\\tx=-inf;\\n\\t\\t}\\n\\t};\\n\\tstruct segtree{\\n\\t\\n\\t\\tvector<int> arr;\\n\\t\\tnode merge( node a, node b) \\n\\t\\t{ \\n\\t\\t\\tnode z ;\\n\\t\\t\\tz.x=max(a.x,b.x);\\n\\t\\t\\treturn z;\\n\\t\\t}\\n\\t\\tvector<node> t;\\n\\t\\tsegtree( int n)\\n\\t\\t{ \\n\\t\\t\\t\\n\\t\\t\\tarr.assign(n,0);\\n\\t\\t\\tt.resize(4*n);\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tsegtree(vi& a) \\n\\t\\t{ \\n\\t\\t\\tarr = a;\\n\\t\\t\\tt.resize(4*sz(arr));\\n\\t\\t\\t\\n\\t\\t}\\n\\tvoid build(int ind , int l ,int r) \\n\\t{ \\n\\t\\t//making a node which is responsible for l to r \\n\\t\\tif(l==r) \\n\\t\\t{ \\n\\t\\t\\tt[ind].x=arr[l];\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\tint mid = l+((r-l)>>1);\\n\\t\\tbuild((ind<<1),l,mid) ;//building left tree \\n\\t\\tbuild(((ind<<1) |1),mid+1,r);//building right tree\\n\\t\\tt[ind]=merge(t[(ind<<1)],t[((ind<<1) |1)]);\\n\\t}\\n\\tvoid update( int ind , int l,int r, int pos ,int val) \\n\\t{ \\n\\t\\tif(pos<l || pos>r) //then this node doesn\\'t contain the range we are searching so leave it \\n\\t\\t{ \\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(l==r) \\n\\t\\t{ \\n\\t\\t\\tt[ind].x = val;//updating segment tree \\n\\t\\t\\tarr[l]=val;//updating original array if you want to \\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\n\\t\\tint mid = l+((r-l)>>1);\\n\\t\\tupdate((ind<<1),l,mid,pos,val );\\n\\t\\tupdate(((ind<<1) |1),mid+1,r,pos,val);\\n\\t\\tt[ind]=merge(t[(ind<<1)],t[((ind<<1) |1)]);\\n\\t\\treturn;\\n\\t\\n\\t}\\n\\tnode querry(int ind , int l ,int r, int lq,int rq) \\n\\t{ \\n\\t\\tif(l>rq || lq>r)\\n\\t\\t{ \\n\\t\\t\\tnode z;\\n\\t\\t\\treturn  z;\\n\\t\\t}\\n\\t\\tif(l>=lq && r<=rq) \\n\\t\\t{ \\n\\t\\t\\treturn t[ind];//this is the ans of the range l to r \\n\\t\\t}\\n\\t\\t// dbg(\\'a\\');\\n\\t\\tint mid = l+((r-l)>>1);\\n\\treturn \\tmerge(querry((ind<<1),l,mid,lq,rq) ,\\tquerry(((ind<<1) |1),mid+1,r,lq,rq));//isme kuch update ni karna hai isliye t[ind] wo sab use ni karenge \\n\\t\\n\\t\\n\\t}\\n\\t};\\n\\tint N=1e5+1;\\n\\tint lengthOfLIS(vector<int>& nums, int k) {\\n\\t\\tsegtree st(N);//stores max increasing subsequence ending at element i \\n\\t\\tst.build(1,0,N-1);\\n\\t\\tint ans =0;\\n        for(int i=0;i<nums.size();i++)\\n\\t\\t{\\n\\t\\t\\tint prev_val =st.querry(1,0,N-1,nums[i],nums[i]).x;//value which was earlier present when our subsequence was ending at nums[i]\\n\\t\\t\\tint lq = max(0ll,nums[i]-k);\\n\\t\\t\\tint rq=max(0ll,nums[i]-1);\\n\\t\\t\\tint mx_k_prev_values = st.querry(1,0,N-1,lq,rq).x;\\n\\t\\t\\tif(mx_k_prev_values+1>prev_val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans =max(ans,mx_k_prev_values+1);\\n\\t\\t\\t\\tst.update(1,0,N-1,nums[i],mx_k_prev_values+1ll);//updating the segment tree if we have more value than what previous value was\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\n\\t/*\\n\\t\\tsubproblem first you guys can try finding longest increasing subsequence in nlog(n) using a map \\n\\t\\tafter that instead of map if you use segment tree you can find max of k elements smaller than current element in logirithmic time \\n\\t*/\\n\\tstruct node{\\n\\t\\tint x;\\n\\t\\tnode()\\n\\t\\t{\\n\\t\\t\\tx=-inf;\\n\\t\\t}\\n\\t};\\n\\tstruct segtree{\\n\\t\\n\\t\\tvector<int> arr;\\n\\t\\tnode merge( node a, node b) \\n\\t\\t{ \\n\\t\\t\\tnode z ;\\n\\t\\t\\tz.x=max(a.x,b.x);\\n\\t\\t\\treturn z;\\n\\t\\t}\\n\\t\\tvector<node> t;\\n\\t\\tsegtree( int n)\\n\\t\\t{ \\n\\t\\t\\t\\n\\t\\t\\tarr.assign(n,0);\\n\\t\\t\\tt.resize(4*n);\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tsegtree(vi& a) \\n\\t\\t{ \\n\\t\\t\\tarr = a;\\n\\t\\t\\tt.resize(4*sz(arr));\\n\\t\\t\\t\\n\\t\\t}\\n\\tvoid build(int ind , int l ,int r) \\n\\t{ \\n\\t\\t//making a node which is responsible for l to r \\n\\t\\tif(l==r) \\n\\t\\t{ \\n\\t\\t\\tt[ind].x=arr[l];\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\tint mid = l+((r-l)>>1);\\n\\t\\tbuild((ind<<1),l,mid) ;//building left tree \\n\\t\\tbuild(((ind<<1) |1),mid+1,r);//building right tree\\n\\t\\tt[ind]=merge(t[(ind<<1)],t[((ind<<1) |1)]);\\n\\t}\\n\\tvoid update( int ind , int l,int r, int pos ,int val) \\n\\t{ \\n\\t\\tif(pos<l || pos>r) //then this node doesn\\'t contain the range we are searching so leave it \\n\\t\\t{ \\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(l==r) \\n\\t\\t{ \\n\\t\\t\\tt[ind].x = val;//updating segment tree \\n\\t\\t\\tarr[l]=val;//updating original array if you want to \\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\n\\t\\tint mid = l+((r-l)>>1);\\n\\t\\tupdate((ind<<1),l,mid,pos,val );\\n\\t\\tupdate(((ind<<1) |1),mid+1,r,pos,val);\\n\\t\\tt[ind]=merge(t[(ind<<1)],t[((ind<<1) |1)]);\\n\\t\\treturn;\\n\\t\\n\\t}\\n\\tnode querry(int ind , int l ,int r, int lq,int rq) \\n\\t{ \\n\\t\\tif(l>rq || lq>r)\\n\\t\\t{ \\n\\t\\t\\tnode z;\\n\\t\\t\\treturn  z;\\n\\t\\t}\\n\\t\\tif(l>=lq && r<=rq) \\n\\t\\t{ \\n\\t\\t\\treturn t[ind];//this is the ans of the range l to r \\n\\t\\t}\\n\\t\\t// dbg(\\'a\\');\\n\\t\\tint mid = l+((r-l)>>1);\\n\\treturn \\tmerge(querry((ind<<1),l,mid,lq,rq) ,\\tquerry(((ind<<1) |1),mid+1,r,lq,rq));//isme kuch update ni karna hai isliye t[ind] wo sab use ni karenge \\n\\t\\n\\t\\n\\t}\\n\\t};\\n\\tint N=1e5+1;\\n\\tint lengthOfLIS(vector<int>& nums, int k) {\\n\\t\\tsegtree st(N);//stores max increasing subsequence ending at element i \\n\\t\\tst.build(1,0,N-1);\\n\\t\\tint ans =0;\\n        for(int i=0;i<nums.size();i++)\\n\\t\\t{\\n\\t\\t\\tint prev_val =st.querry(1,0,N-1,nums[i],nums[i]).x;//value which was earlier present when our subsequence was ending at nums[i]\\n\\t\\t\\tint lq = max(0ll,nums[i]-k);\\n\\t\\t\\tint rq=max(0ll,nums[i]-1);\\n\\t\\t\\tint mx_k_prev_values = st.querry(1,0,N-1,lq,rq).x;\\n\\t\\t\\tif(mx_k_prev_values+1>prev_val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans =max(ans,mx_k_prev_values+1);\\n\\t\\t\\t\\tst.update(1,0,N-1,nums[i],mx_k_prev_values+1ll);//updating the segment tree if we have more value than what previous value was\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041790,
                "title": "easy-solution-with-segmenttree-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. index of segmentTree is the value of elements in the nums array.\\n2. value hold in each treeNode is the maximum increasing sequence length.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(max(nums[i]) * nums.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(nums[i])\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class SegmentTree {\\n        int[] t;\\n        int n;\\n\\n        public SegmentTree(int n) {\\n            t = new int[2 * n];\\n            this.n = n;\\n            // buildTree(); we do not need build tree in this case\\n        }\\n\\n        public void update(int pos, int val) {\\n            pos += n;\\n            t[pos] = val;\\n            while (pos > 1) {\\n                pos >>= 1;\\n                t[pos] = Math.max(t[pos << 1], t[pos << 1 | 1]);\\n            }\\n        }\\n\\n        private int query(int left, int right) { // [left, right)\\n            left += n;\\n            right += n;\\n            int res = 0;\\n            while (left < right) {\\n                if ((left & 1) == 1) {\\n                    res = Math.max(res, t[left++]);\\n                }\\n                if ((right & 1) == 1) {\\n                    res = Math.max(res, t[--right]);\\n                }\\n                left >>= 1;\\n                right >>= 1;\\n            }\\n\\n            return res;\\n        }\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int ans = 0;\\n        SegmentTree st = new SegmentTree(100001);\\n        for (int i = 0; i < nums.length; i++) {\\n            int maxQuery = st.query(Math.max(nums[i] - k, 0), nums[i]) + 1;\\n            ans = Math.max(ans, maxQuery);\\n            st.update(nums[i], maxQuery);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class SegmentTree {\\n        int[] t;\\n        int n;\\n\\n        public SegmentTree(int n) {\\n            t = new int[2 * n];\\n            this.n = n;\\n            // buildTree(); we do not need build tree in this case\\n        }\\n\\n        public void update(int pos, int val) {\\n            pos += n;\\n            t[pos] = val;\\n            while (pos > 1) {\\n                pos >>= 1;\\n                t[pos] = Math.max(t[pos << 1], t[pos << 1 | 1]);\\n            }\\n        }\\n\\n        private int query(int left, int right) { // [left, right)\\n            left += n;\\n            right += n;\\n            int res = 0;\\n            while (left < right) {\\n                if ((left & 1) == 1) {\\n                    res = Math.max(res, t[left++]);\\n                }\\n                if ((right & 1) == 1) {\\n                    res = Math.max(res, t[--right]);\\n                }\\n                left >>= 1;\\n                right >>= 1;\\n            }\\n\\n            return res;\\n        }\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int ans = 0;\\n        SegmentTree st = new SegmentTree(100001);\\n        for (int i = 0; i < nums.length; i++) {\\n            int maxQuery = st.query(Math.max(nums[i] - k, 0), nums[i]) + 1;\\n            ans = Math.max(ans, maxQuery);\\n            st.update(nums[i], maxQuery);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010565,
                "title": "segmenttree-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // because monotonic, just need loop from 0-i, i = nums.size\\n    // dp[n] = if stack top is index n, max len\\n    // O(n * n)\\n    // leaves[n] = when read at nums[i] , stack top is n, max len\\n    // optimize with segment tree\\n    struct node {\\n        // level of leaf = 0, root.level = ceil(log2(N)); root.index = 0\\n        int level;\\n        // index, index of node in this level\\n        int index;\\n    };\\n    // @direct 0 left, 1 right\\n    node child(node cur, int direct) {\\n        node ret;\\n        ret.level = cur.level-1;\\n        if (direct == 0) {\\n            ret.index = cur.index * 2;\\n        } else {\\n            ret.index = cur.index * 2 + 1;\\n        }\\n        return ret;\\n    }\\n    node father(node cur) {\\n        return node{.level = cur.level + 1, .index= cur.index / 2};\\n    }\\n    int pow2(int x) {\\n        return 1 << x;\\n    }\\n    int solve(node cur) {\\n        return pow2(RL - cur.level) + cur.index;\\n    }\\n    pair<int, int> leaves_range(node cur) {\\n        auto left = leaves_ + pow2(cur.level) * cur.index;\\n        auto right = left + pow2(cur.level) - 1;\\n        return {left, right};\\n    }\\n\\n    vector<int> nodes_;\\n    int leaves_;\\n    int N;\\n    int RL; // root.level\\n    int INVALID = INT_MIN;\\n    // \\n    int query(node cur, int leaf_l, int leaf_r) {\\n        // cout << \"query cur.level \" << cur.level << \" cur.index \" << cur.index << \" l \" << leaf_l << \" r \" << leaf_r << endl;\\n        auto range = leaves_range(cur);\\n        if (leaf_l <= range.first && range.second <= leaf_r) {\\n            return nodes_[solve(cur)];\\n        } \\n        if (range.second < leaf_l || leaf_r < range.first) {\\n            return INVALID;\\n        }\\n        return max(query(child(cur, 0), leaf_l, leaf_r), query(child(cur, 1), leaf_l, leaf_r));\\n    }\\n    void update(node cur, int value) {\\n        // cout << \"update cur.level \" << cur.level << \" cur.index \" << cur.index << \" value \" << value << endl;\\n        if (value <= nodes_[solve(cur)]) {\\n            return;\\n        }\\n        nodes_[solve(cur)] = value;\\n        if (cur.level == RL) {\\n            return;\\n        }\\n        update(father(cur), value);\\n    }\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        {\\n            // init\\n            N = pow(10, 5); // max(nums) = 10^5\\n            RL = ceil(log2(N));\\n            nodes_ = vector<int>(pow2(RL+1), 0);\\n            leaves_ = pow2(RL);\\n        }\\n        auto root = node{.level=RL, .index=0};\\n        for (auto i : nums) {\\n            auto value = query(root, \\n                solve(node{.level=0, .index=max(0, i - k)}), \\n                solve(node{.level=0, .index=i-1})\\n            );\\n            update(node{.level=0, .index=i}, value + 1);\\n        }\\n\\n        return nodes_[1];\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // because monotonic, just need loop from 0-i, i = nums.size\\n    // dp[n] = if stack top is index n, max len\\n    // O(n * n)\\n    // leaves[n] = when read at nums[i] , stack top is n, max len\\n    // optimize with segment tree\\n    struct node {\\n        // level of leaf = 0, root.level = ceil(log2(N)); root.index = 0\\n        int level;\\n        // index, index of node in this level\\n        int index;\\n    };\\n    // @direct 0 left, 1 right\\n    node child(node cur, int direct) {\\n        node ret;\\n        ret.level = cur.level-1;\\n        if (direct == 0) {\\n            ret.index = cur.index * 2;\\n        } else {\\n            ret.index = cur.index * 2 + 1;\\n        }\\n        return ret;\\n    }\\n    node father(node cur) {\\n        return node{.level = cur.level + 1, .index= cur.index / 2};\\n    }\\n    int pow2(int x) {\\n        return 1 << x;\\n    }\\n    int solve(node cur) {\\n        return pow2(RL - cur.level) + cur.index;\\n    }\\n    pair<int, int> leaves_range(node cur) {\\n        auto left = leaves_ + pow2(cur.level) * cur.index;\\n        auto right = left + pow2(cur.level) - 1;\\n        return {left, right};\\n    }\\n\\n    vector<int> nodes_;\\n    int leaves_;\\n    int N;\\n    int RL; // root.level\\n    int INVALID = INT_MIN;\\n    // \\n    int query(node cur, int leaf_l, int leaf_r) {\\n        // cout << \"query cur.level \" << cur.level << \" cur.index \" << cur.index << \" l \" << leaf_l << \" r \" << leaf_r << endl;\\n        auto range = leaves_range(cur);\\n        if (leaf_l <= range.first && range.second <= leaf_r) {\\n            return nodes_[solve(cur)];\\n        } \\n        if (range.second < leaf_l || leaf_r < range.first) {\\n            return INVALID;\\n        }\\n        return max(query(child(cur, 0), leaf_l, leaf_r), query(child(cur, 1), leaf_l, leaf_r));\\n    }\\n    void update(node cur, int value) {\\n        // cout << \"update cur.level \" << cur.level << \" cur.index \" << cur.index << \" value \" << value << endl;\\n        if (value <= nodes_[solve(cur)]) {\\n            return;\\n        }\\n        nodes_[solve(cur)] = value;\\n        if (cur.level == RL) {\\n            return;\\n        }\\n        update(father(cur), value);\\n    }\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        {\\n            // init\\n            N = pow(10, 5); // max(nums) = 10^5\\n            RL = ceil(log2(N));\\n            nodes_ = vector<int>(pow2(RL+1), 0);\\n            leaves_ = pow2(RL);\\n        }\\n        auto root = node{.level=RL, .index=0};\\n        for (auto i : nums) {\\n            auto value = query(root, \\n                solve(node{.level=0, .index=max(0, i - k)}), \\n                solve(node{.level=0, .index=i-1})\\n            );\\n            update(node{.level=0, .index=i}, value + 1);\\n        }\\n\\n        return nodes_[1];\\n    }\\n\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3991410,
                "title": "c-simple-and-short-no-segment-tree",
                "content": "# Intuition\\n\\n1. When an element is added to an existing sequence, this breaks the sequence into two sequences: with and without the added element, unless the newly added value is exactly following the last element of the sequence, in which case we only keep the sequence with the new element.\\nExample:\\nInput: 1, 2, 10, 3, 4, 5, 6, 7, 20, 30, 40, 50, 60, 70, 80\\nk: 10.\\nWhen adding the 10 to the sequence [1, 2], we are blocking the option to add [3, 4, 5, 6, 7] to [1, 2], which is much better than just adding 10. So when adding 10, we do not override the sequence [1, 2], but leave it as it is, and just add another sequence: [1, 2, 10]. So we need to keep track of multiple sequences.\\n2. When adding a new element to multiple existing sequences, we only need to remember one of them, the longest one, as they will all now grow in the same way, as they now all end with the same element.\\n3. For every element from the input, try not to check all existing sequences for whether the new element can be added to them. Instead, try to immediately identify the sequences that surely match the addition, i.e. that their last element is up to k smaller than the new value.\\n\\n# Approach\\nHold a map, where the key is the last element of a sequence, and the value is the maximum length so far, of a sequence that ends with this element.\\nFor each element \\'num\\' from the input, point to its location in the map. if it does not exist, add it, with the value 1, representing the fact that even if this new element can\\'t be added to any existing sequence, it makes a new sequence of its own, of length 1.\\nThen binary search the map for the first element that is equal/bigger than \\'num - k\\'. that is the first sequence to which we can add \\'num\\'. iterate the elements between there until \\'num\\' itself, add 1 to each, representing the addition of the new element \\'num\\', and choose the longest resulting length, to be the value near the key \\'num\\' in the map. if one of these sequences ends with \\'num - 1\\', then this sequence can be removed, as it is now \\'absorbed\\' in the sequence that ends with \\'num\\'. Also, sequences that are shorter than the longest sequence that ends with \\'num\\' by more than the difference of their last element fron \\'num\\', can also be removed, as they will never beat the length. \\n\\n# Complexity\\n- Time complexity:\\n    - N for iterating the input, and then for each input element:\\n        - Twice log N for finding in the map.\\n        - N for iterating the sequences that we found in the map.\\n    - For the return: N for finding the biggest sequence in the map.\\nConclusion: N^2\\n\\n- Space complexity:\\nN for the map\\n\\nNote: Runtime beats only up to 78% of solutions, usually less, which is not ideal. However I like the simplicity of my solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        map<int, int> sequences;\\n        \\n        for (auto num: nums) {\\n            auto it_num = sequences.emplace(num, 1).first;\\n            for (auto it_seq = sequences.lower_bound(num - k); it_seq != it_num; ) {\\n                it_num->second = max(it_num->second, it_seq->second + 1);\\n                if ((it_seq->first + 1 == num) || \\n                    ((it_num->first - it_seq->first) <= (it_num->second - it_seq->second))) {\\n                    it_seq = sequences.erase(it_seq);\\n                }\\n                else {\\n                    ++it_seq;\\n                }\\n            }\\n        }\\n        \\n        return max_element(sequences.begin(), sequences.end(), [](auto s1, auto s2) { return s1.second < s2.second; })->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        map<int, int> sequences;\\n        \\n        for (auto num: nums) {\\n            auto it_num = sequences.emplace(num, 1).first;\\n            for (auto it_seq = sequences.lower_bound(num - k); it_seq != it_num; ) {\\n                it_num->second = max(it_num->second, it_seq->second + 1);\\n                if ((it_seq->first + 1 == num) || \\n                    ((it_num->first - it_seq->first) <= (it_num->second - it_seq->second))) {\\n                    it_seq = sequences.erase(it_seq);\\n                }\\n                else {\\n                    ++it_seq;\\n                }\\n            }\\n        }\\n        \\n        return max_element(sequences.begin(), sequences.end(), [](auto s1, auto s2) { return s1.second < s2.second; })->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988352,
                "title": "segment-tree-easy-approach",
                "content": "in each tree[index] we will store the max lis possible till that position under given constraints \\n1. we dont need a build function here since all elements have lis 0\\n2. now coming to the query function we will find the max lis in the range of (i-k,i-1) and then add 1 to this value for our ans\\n3. now coming to the update simply we will update the curr ans of the array in the segment tree to always update the tree \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int query(int index,int s,int e,int l,int r,vector<int> &tree){\\n        if(s>r || e<l){\\n            return 0;\\n        }\\n        if(s==e){\\n            return tree[index];\\n        }else if(s>=l && e<=r){\\n            return tree[index];\\n        }else{\\n            int mid=(s+e)/2;\\n            int left=2*index;\\n            int right=2*index+1;\\n            int lans=query(left,s,mid,l,r,tree);\\n            int rans=query(right,mid+1,e,l,r,tree);\\n            return max(lans,rans);\\n        }\\n    }\\n\\n    void update(int index,int s,int e,int pos,int val,vector<int> &tree){\\n        if(s==e){\\n            tree[index]=val;\\n        }else{\\n            int mid=(s+e)/2;\\n            if(s<=pos && pos<=mid){\\n                update(2*index,s,mid,pos,val,tree);\\n            }else{\\n                update(2*index+1,mid+1,e,pos,val,tree);\\n            }\\n            tree[index]=max(tree[2*index],tree[2*index+1]);\\n        }\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n      int n=1e5+2;\\n      vector<int> tree(4*n+1,0);\\n      for(auto it:nums){\\n         int l=max(0,it-k);\\n         int maxi=query(1,0,n-1,l,it-1,tree);\\n         int cur=1+maxi;\\n         update(1,0,n-1,it,cur,tree);\\n      }\\n      return tree[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int query(int index,int s,int e,int l,int r,vector<int> &tree){\\n        if(s>r || e<l){\\n            return 0;\\n        }\\n        if(s==e){\\n            return tree[index];\\n        }else if(s>=l && e<=r){\\n            return tree[index];\\n        }else{\\n            int mid=(s+e)/2;\\n            int left=2*index;\\n            int right=2*index+1;\\n            int lans=query(left,s,mid,l,r,tree);\\n            int rans=query(right,mid+1,e,l,r,tree);\\n            return max(lans,rans);\\n        }\\n    }\\n\\n    void update(int index,int s,int e,int pos,int val,vector<int> &tree){\\n        if(s==e){\\n            tree[index]=val;\\n        }else{\\n            int mid=(s+e)/2;\\n            if(s<=pos && pos<=mid){\\n                update(2*index,s,mid,pos,val,tree);\\n            }else{\\n                update(2*index+1,mid+1,e,pos,val,tree);\\n            }\\n            tree[index]=max(tree[2*index],tree[2*index+1]);\\n        }\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n      int n=1e5+2;\\n      vector<int> tree(4*n+1,0);\\n      for(auto it:nums){\\n         int l=max(0,it-k);\\n         int maxi=query(1,0,n-1,l,it-1,tree);\\n         int cur=1+maxi;\\n         update(1,0,n-1,it,cur,tree);\\n      }\\n      return tree[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975651,
                "title": "harnessing-the-power-of-segment-trees-for-range-queries",
                "content": "# Intuition\\nWhen tasked with analyzing sequences, it\\'s often beneficial to think in terms of \"continuity\" or \"patterns\". The problem essentially asks us to find an increasing sequence, but with an added constraint on the difference between subsequent elements. It\\'s reminiscent of a classic problem: the Longest Increasing Subsequence (LIS). Here, we need to add the constraint of difference (k), and that immediately leads us to think about range queries, which can be efficiently addressed using segment trees.\\n\\n# Approach\\nSegment Tree Initialization:\\n\\nA segment tree is a binary tree where each node maintains information (like the max/min value) about a range of the sequence. We use the segment tree because it allows logarithmic time complexity for both querying a range and updating an element.\\nWe initialize the segment tree to cover the range of the numbers in the given list. This ensures that we can update and query the numbers appropriately.\\nIterative Sequence Analysis:\\n\\nQuery the segment tree for the maximum value within the range [max(0, num - k), num - 1]. This gives us the length of the longest subsequence ending at the current number.\\nUpdate the value in the segment tree at the position corresponding to the current number with the obtained length + 1 (to account for the current number itself).\\nThe aim is to build the segment tree such that every index (representing a number) will eventually store the length of the LIS ending at that number.\\n\\n# Complexity\\n- Time complexity:\\nEvery query and update operation in a segment tree takes $$O(\\\\log n)$$ time.\\nSince we are performing these operations for each number in the sequence, the overall time complexity is $$O(n \\\\log n)$$.\\n\\n- Space complexity:\\nThe segment tree requires $$O(4n)$$ space, which simplifies to $$O(n)$$ in terms of big O notation.\\n\\n# Code\\n```\\nclass Solution:\\n    class SegmentTree:\\n        def __init__(self, n):\\n            self.tree = [0] * (4 * n)\\n\\n        def query(self, treeNode, treeLo, treeHi, queryLo, queryHi):\\n            tree = self.tree\\n            if queryHi < treeLo or treeHi < queryLo:\\n                return 0\\n\\n            if queryLo <= treeLo and treeHi <= queryHi:\\n                return tree[treeNode]\\n\\n            mid = (treeHi + treeLo) // 2\\n            return max(self.query(treeNode * 2 + 1, treeLo, mid, queryLo, queryHi),\\n                       self.query(treeNode * 2 + 2, mid + 1, treeHi, queryLo, queryHi))\\n\\n        def update(self, treeNode, treeLo, treeHi, index, value):\\n            tree = self.tree\\n            if index < treeLo or index > treeHi:\\n                return\\n\\n            if treeLo == treeHi:\\n                tree[treeNode] = value\\n                return\\n\\n            mid = (treeHi + treeLo) // 2\\n            self.update(treeNode * 2 + 1, treeLo, mid, index, value)\\n            self.update(treeNode * 2 + 2, mid + 1, treeHi, index, value)\\n            tree[treeNode] = max(tree[treeNode * 2 + 1], tree[treeNode * 2 + 2])\\n\\n    def lengthOfLIS(self, nums, k):\\n        maxNum = max(nums)\\n        s = self.SegmentTree(maxNum)\\n        maxLength = 0\\n        query, update = s.query, s.update\\n        for num in nums:\\n            num -= 1\\n            length = query(0, 0, maxNum - 1, max(0, num - k), num - 1)\\n            maxLength = maxLength if maxLength > length + 1 else length + 1\\n            update(0, 0, maxNum - 1, num, length + 1)\\n        return maxLength\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution:\\n    class SegmentTree:\\n        def __init__(self, n):\\n            self.tree = [0] * (4 * n)\\n\\n        def query(self, treeNode, treeLo, treeHi, queryLo, queryHi):\\n            tree = self.tree\\n            if queryHi < treeLo or treeHi < queryLo:\\n                return 0\\n\\n            if queryLo <= treeLo and treeHi <= queryHi:\\n                return tree[treeNode]\\n\\n            mid = (treeHi + treeLo) // 2\\n            return max(self.query(treeNode * 2 + 1, treeLo, mid, queryLo, queryHi),\\n                       self.query(treeNode * 2 + 2, mid + 1, treeHi, queryLo, queryHi))\\n\\n        def update(self, treeNode, treeLo, treeHi, index, value):\\n            tree = self.tree\\n            if index < treeLo or index > treeHi:\\n                return\\n\\n            if treeLo == treeHi:\\n                tree[treeNode] = value\\n                return\\n\\n            mid = (treeHi + treeLo) // 2\\n            self.update(treeNode * 2 + 1, treeLo, mid, index, value)\\n            self.update(treeNode * 2 + 2, mid + 1, treeHi, index, value)\\n            tree[treeNode] = max(tree[treeNode * 2 + 1], tree[treeNode * 2 + 2])\\n\\n    def lengthOfLIS(self, nums, k):\\n        maxNum = max(nums)\\n        s = self.SegmentTree(maxNum)\\n        maxLength = 0\\n        query, update = s.query, s.update\\n        for num in nums:\\n            num -= 1\\n            length = query(0, 0, maxNum - 1, max(0, num - k), num - 1)\\n            maxLength = maxLength if maxLength > length + 1 else length + 1\\n            update(0, 0, maxNum - 1, num, length + 1)\\n        return maxLength\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937231,
                "title": "object-oriented-segment-tree-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self, i, j, left = None, right = None, val=0) -> None:\\n        self.val = val\\n        self.i, self.j, self.left, self.right = i, j, left, right\\n        \\nclass Solution:\\n\\n    def constructTree(self, i, j, nums):\\n        if i > j:\\n            return None\\n        if i == j:\\n            root = Node(i, i, val = nums[i])\\n            return root\\n        if i < j : \\n            mid = int((j+i)/2)\\n            root = Node(i,j)\\n            left_node = self.constructTree(i,mid,nums)\\n            right_node = self.constructTree(mid+1, j, nums)\\n            root.left = left_node\\n            root.right = right_node\\n            root.val = left_node.val + right_node.val\\n\\n            return root\\n\\n    def updateTree(self, index, val, root):\\n        if not (root and root.i<=index and root.j>=index):\\n            return \\n        if root and not root.left and not root.right and root.i==index and root.j==index:\\n            root.val = val\\n            return\\n\\n        self.updateTree(index, val, root.left)\\n        self.updateTree(index, val, root.right)\\n        root.val = max(root.left.val, root.right.val)\\n\\n    def sumQueryTree(self, left,right, root):\\n        mid = int((root.i+root.j)/2)\\n        if left == root.i and right==root.j:\\n            return root.val \\n\\n        if left > mid:\\n            res1 = self.sumQueryTree(left, right, \\n            root.right)\\n            return res1 \\n        elif mid >= right:\\n            res2 = self.sumQueryTree(left, right, root.left)\\n            return res2\\n        else:\\n            res3 = max(self.sumQueryTree(left, mid, root.left) , self.sumQueryTree(mid+1, right, root.right))\\n            return res3\\n         \\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        self.nums = nums\\n        self.root = self.constructTree(0, max(nums),[0 for _ in range(0, max(nums)+1)])\\n        max_val = 0\\n        for num in nums:\\n            prev_max = self.sumQueryTree(max(0,num-k),num-1, self.root)\\n            cur_max = self.sumQueryTree(num,num, self.root)\\n            cur_max = max(cur_max, prev_max+1)\\n            max_val = max(max_val, cur_max)\\n            self.updateTree(num, cur_max, self.root)\\n        return max_val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, i, j, left = None, right = None, val=0) -> None:\\n        self.val = val\\n        self.i, self.j, self.left, self.right = i, j, left, right\\n        \\nclass Solution:\\n\\n    def constructTree(self, i, j, nums):\\n        if i > j:\\n            return None\\n        if i == j:\\n            root = Node(i, i, val = nums[i])\\n            return root\\n        if i < j : \\n            mid = int((j+i)/2)\\n            root = Node(i,j)\\n            left_node = self.constructTree(i,mid,nums)\\n            right_node = self.constructTree(mid+1, j, nums)\\n            root.left = left_node\\n            root.right = right_node\\n            root.val = left_node.val + right_node.val\\n\\n            return root\\n\\n    def updateTree(self, index, val, root):\\n        if not (root and root.i<=index and root.j>=index):\\n            return \\n        if root and not root.left and not root.right and root.i==index and root.j==index:\\n            root.val = val\\n            return\\n\\n        self.updateTree(index, val, root.left)\\n        self.updateTree(index, val, root.right)\\n        root.val = max(root.left.val, root.right.val)\\n\\n    def sumQueryTree(self, left,right, root):\\n        mid = int((root.i+root.j)/2)\\n        if left == root.i and right==root.j:\\n            return root.val \\n\\n        if left > mid:\\n            res1 = self.sumQueryTree(left, right, \\n            root.right)\\n            return res1 \\n        elif mid >= right:\\n            res2 = self.sumQueryTree(left, right, root.left)\\n            return res2\\n        else:\\n            res3 = max(self.sumQueryTree(left, mid, root.left) , self.sumQueryTree(mid+1, right, root.right))\\n            return res3\\n         \\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        self.nums = nums\\n        self.root = self.constructTree(0, max(nums),[0 for _ in range(0, max(nums)+1)])\\n        max_val = 0\\n        for num in nums:\\n            prev_max = self.sumQueryTree(max(0,num-k),num-1, self.root)\\n            cur_max = self.sumQueryTree(num,num, self.root)\\n            cur_max = max(cur_max, prev_max+1)\\n            max_val = max(max_val, cur_max)\\n            self.updateTree(num, cur_max, self.root)\\n        return max_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907418,
                "title": "c-bottom-up-segment-tree-beats-100",
                "content": "# Intuition\\nImplement a naive DP, namely if we have state `dp[i][value]` be the best we can do with the first `i` elements and such that the last element is `value`. Then it is not hard to see that \\n\\n$$\\n\\\\tt dp[i][nums[i]] = 1 + max_{v\\\\in [nums[i]-k, nums[i])} dp[i][v].\\n$$\\n\\nBut this naive approach is only $O(n^2)$ so is not fast enough. We want at least $O(n \\\\log n)$. But thankfully, we can note that:\\n\\n* In the transition from `dp[i-1]` to `dp[i]` the only value that can change is `dp[i][nums[i]]`. So we dont need to maintain a whole dimension of DP.\\n* We need to process find max of range (RMQ) quickly -- for this we can use Segment Tree.\\n\\nIn fact, we do not need a `dp` array at all, we need only maintain a segment tree and update it for each iteration over `nums`. \\n# Approach\\nMaintain a segment tree of size such that it can handle queries up to `1e5+1`. Here we use a segment tree that handles queries for segments $[l,r)$. Then iterate over nums, updating the segment tree as per the following sudo code:\\n\\n```\\nfor num in nums:\\n    best = 1 + RMQ(num - k, num)\\n    Update(num, best)\\n\\nreturn RMQ(0, 1e5+1)\\n```\\nWe can look at the Naive DP to see why this works. The segment tree is a so-called \"bottom up\" segment tree where the nodes are stored in heap-like format where child of `tree[i]` is `tree[2*i], tree[2*i+1]`. This form of segment tree is known to be much faster than the normal recursive implementation (sometimes even faster than Fenwick Tree).\\n# Complexity\\n- Time complexity:\\n$O(n \\\\log N)$, where $n$ is the lengths of `nums` and $N$ is max value of `nums` (but in implementation, we just use `1e5+1`). Both update and query operations on a segment tree are $O(\\\\log N)$. \\n\\n- Space complexity:\\n$O(N)$, where $N$ is max of `nums`. \\n\\n# Code\\n```\\nconst int N = 1e5+1;\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int t[2*N + 2]; memset(t, 0, sizeof(t));\\n\\n        auto upd = [&](int p, int v) {\\n            p += N;\\n            t[p] = v;\\n            for(; p > 1; p >>= 1) t[p>>1] = max(t[p], t[p^1]);\\n        };\\n\\n        auto qry = [&](int l, int r) {\\n            l+=N, r+=N;\\n            int ret = 0;\\n            for(; l<r; l>>=1, r>>=1) {\\n                if (l&1) ret = max(ret, t[l++]);\\n                if (r&1) ret = max(ret, t[--r]);\\n            }\\n            return ret;\\n        };\\n\\n        //upd(nums[0], 1);\\n\\n        for (int i=0; i<n; ++i) {\\n            int curr = nums[i];\\n            int best = 1 + qry(max(0, curr - k), curr);\\n            upd(curr, best);\\n        }\\n        int ans = qry(0, N+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor num in nums:\\n    best = 1 + RMQ(num - k, num)\\n    Update(num, best)\\n\\nreturn RMQ(0, 1e5+1)\\n```\n```\\nconst int N = 1e5+1;\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int t[2*N + 2]; memset(t, 0, sizeof(t));\\n\\n        auto upd = [&](int p, int v) {\\n            p += N;\\n            t[p] = v;\\n            for(; p > 1; p >>= 1) t[p>>1] = max(t[p], t[p^1]);\\n        };\\n\\n        auto qry = [&](int l, int r) {\\n            l+=N, r+=N;\\n            int ret = 0;\\n            for(; l<r; l>>=1, r>>=1) {\\n                if (l&1) ret = max(ret, t[l++]);\\n                if (r&1) ret = max(ret, t[--r]);\\n            }\\n            return ret;\\n        };\\n\\n        //upd(nums[0], 1);\\n\\n        for (int i=0; i<n; ++i) {\\n            int curr = nums[i];\\n            int best = 1 + qry(max(0, curr - k), curr);\\n            upd(curr, best);\\n        }\\n        int ans = qry(0, N+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907417,
                "title": "c-bottom-up-segment-tree-beats-100",
                "content": "# Intuition\\nImplement a naive DP, namely if we have state `dp[i][value]` be the best we can do with the first `i` elements and such that the last element is `value`. Then it is not hard to see that \\n\\n$$\\n\\\\tt dp[i][nums[i]] = max_{v\\\\in [nums[i]-k, nums[i])} dp[i][v].\\n$$\\n\\nBut this naive approach is only $O(n^2)$ so is not fast enough. We want at least $O(n \\\\log n)$. But thankfully, we can note that:\\n\\n* In the transition from `dp[i-1]` to `dp[i]` the only value that can change is `dp[i][nums[i]]`. So we dont need to maintain a whole dimension of DP.\\n* We need to process find max of range (RMQ) quickly -- for this we can use Segment Tree.\\n\\nIn fact, we do not need a `dp` array at all, we need only maintain a segment tree and update it for each iteration over `nums`. \\n# Approach\\nMaintain a segment tree of size such that it can handle queries up to `1e5+1`. Here we use a segment tree that handles queries for segments $[l,r)$. Then iterate over nums, updating the segment tree as per the following sudo code:\\n\\n```\\nfor num in nums:\\n    best = 1 + RMQ(num - k, num)\\n    Update(num, best)\\n\\nreturn RMQ(0, 1e5+1)\\n```\\nWe can look at the Naive DP to see why this works. The segment tree is a so-called \"bottom up\" segment tree where the nodes are stored in heap-like format where child of `tree[i]` is `tree[2*i], tree[2*i+1]`. This form of segment tree is known to be much faster than the normal recursive implementation (sometimes even faster than Fenwick Tree).\\n# Complexity\\n- Time complexity:\\n$O(n \\\\log N)$, where $n$ is the lengths of `nums` and $N$ is max value of `nums` (but in implementation, we just use `1e5+1`). Both update and query operations on a segment tree are $O(\\\\log N)$. \\n\\n- Space complexity:\\n$O(N)$, where $N$ is max of `nums`. \\n\\n# Code\\n```\\nconst int N = 1e5+1;\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int t[2*N + 2]; memset(t, 0, sizeof(t));\\n\\n        auto upd = [&](int p, int v) {\\n            p += N;\\n            t[p] = v;\\n            for(; p > 1; p >>= 1) t[p>>1] = max(t[p], t[p^1]);\\n        };\\n\\n        auto qry = [&](int l, int r) {\\n            l+=N, r+=N;\\n            int ret = 0;\\n            for(; l<r; l>>=1, r>>=1) {\\n                if (l&1) ret = max(ret, t[l++]);\\n                if (r&1) ret = max(ret, t[--r]);\\n            }\\n            return ret;\\n        };\\n\\n        //upd(nums[0], 1);\\n\\n        for (int i=0; i<n; ++i) {\\n            int curr = nums[i];\\n            int best = 1 + qry(max(0, curr - k), curr);\\n            upd(curr, best);\\n        }\\n        int ans = qry(0, N+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor num in nums:\\n    best = 1 + RMQ(num - k, num)\\n    Update(num, best)\\n\\nreturn RMQ(0, 1e5+1)\\n```\n```\\nconst int N = 1e5+1;\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int t[2*N + 2]; memset(t, 0, sizeof(t));\\n\\n        auto upd = [&](int p, int v) {\\n            p += N;\\n            t[p] = v;\\n            for(; p > 1; p >>= 1) t[p>>1] = max(t[p], t[p^1]);\\n        };\\n\\n        auto qry = [&](int l, int r) {\\n            l+=N, r+=N;\\n            int ret = 0;\\n            for(; l<r; l>>=1, r>>=1) {\\n                if (l&1) ret = max(ret, t[l++]);\\n                if (r&1) ret = max(ret, t[--r]);\\n            }\\n            return ret;\\n        };\\n\\n        //upd(nums[0], 1);\\n\\n        for (int i=0; i<n; ++i) {\\n            int curr = nums[i];\\n            int best = 1 + qry(max(0, curr - k), curr);\\n            upd(curr, best);\\n        }\\n        int ans = qry(0, N+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826075,
                "title": "solution-using-tree-representation-of-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://medium.com/@zdf2424/segment-trees-longest-increasing-subsequence-ii-bb45bb2945db\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst lengthOfLIS = (nums, k) => {\\n  // create segment tree instance\\n  const segmentTree = new SegmentTree(nums);\\n  // declare max variable\\n  let max = 0;\\n  for (let num of nums) {\\n    // query the max of 0 and num - k -> num -1\\n    const length = 1 + segmentTree.query(Math.max(0, num - k), num - 1);\\n    // update the current num to have the calcuated length\\n    segmentTree.update(num, length);\\n    // max logic\\n    max = Math.max(max, length);\\n  }\\n  /// return max\\n  return max;\\n};\\n\\nclass Node {\\n  constructor(num, leftBound, rightBound) {\\n    this.num = num; // number\\n    this.maxLength = 0; // length of subsequence ending at this number\\n    this.leftBound = leftBound;\\n    this.rightBound = rightBound;\\n    this.left = null; // left node\\n    this.right = null; // right node\\n  }\\n}\\n\\nclass SegmentTree {\\n  constructor(nums) {\\n    // build segment tree from a range of [0, max(nums)]\\n    this.segmentTree = this.buildTree(0, Math.max(...nums));\\n  }\\n\\n  buildTree(min, max) {\\n    if (min === max) return new Node(min, min, min);\\n    const mid = Math.floor((min + max) / 2);\\n    const root = new Node(mid, min, max);\\n    root.left = this.buildTree(min, mid);\\n    root.right = this.buildTree(mid + 1, max);\\n    return root;\\n  }\\n\\n  update(num, value, current = this.segmentTree) {\\n    if (current.leftBound === num && current.rightBound === num) {\\n      current.maxLength = value;\\n      return;\\n    }\\n\\n    const mid = Math.floor((current.leftBound + current.rightBound) / 2);\\n    if (num > mid) {\\n      this.update(num, value, current.right);\\n    } else {\\n      this.update(num, value, current.left);\\n    }\\n    // propogate the new maxLength up the tree\\n    current.maxLength = Math.max(\\n      current.left.maxLength,\\n      current.right.maxLength\\n    );\\n  }\\n\\n  query(left, right, current = this.segmentTree) {\\n    if (current.leftBound === left && current.rightBound === right)\\n      return current.maxLength;\\n    if (right < current.leftBound || left > current.rightBound) return 0;\\n    const mid = Math.floor((current.leftBound + current.rightBound) / 2);\\n    if (left > mid) {\\n      return this.query(left, right, current.right);\\n    } else if (right <= mid) {\\n      return this.query(left, right, current.left);\\n    } else {\\n      return Math.max(\\n        this.query(left, mid, current.left),\\n        this.query(mid + 1, right, current.right)\\n      );\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst lengthOfLIS = (nums, k) => {\\n  // create segment tree instance\\n  const segmentTree = new SegmentTree(nums);\\n  // declare max variable\\n  let max = 0;\\n  for (let num of nums) {\\n    // query the max of 0 and num - k -> num -1\\n    const length = 1 + segmentTree.query(Math.max(0, num - k), num - 1);\\n    // update the current num to have the calcuated length\\n    segmentTree.update(num, length);\\n    // max logic\\n    max = Math.max(max, length);\\n  }\\n  /// return max\\n  return max;\\n};\\n\\nclass Node {\\n  constructor(num, leftBound, rightBound) {\\n    this.num = num; // number\\n    this.maxLength = 0; // length of subsequence ending at this number\\n    this.leftBound = leftBound;\\n    this.rightBound = rightBound;\\n    this.left = null; // left node\\n    this.right = null; // right node\\n  }\\n}\\n\\nclass SegmentTree {\\n  constructor(nums) {\\n    // build segment tree from a range of [0, max(nums)]\\n    this.segmentTree = this.buildTree(0, Math.max(...nums));\\n  }\\n\\n  buildTree(min, max) {\\n    if (min === max) return new Node(min, min, min);\\n    const mid = Math.floor((min + max) / 2);\\n    const root = new Node(mid, min, max);\\n    root.left = this.buildTree(min, mid);\\n    root.right = this.buildTree(mid + 1, max);\\n    return root;\\n  }\\n\\n  update(num, value, current = this.segmentTree) {\\n    if (current.leftBound === num && current.rightBound === num) {\\n      current.maxLength = value;\\n      return;\\n    }\\n\\n    const mid = Math.floor((current.leftBound + current.rightBound) / 2);\\n    if (num > mid) {\\n      this.update(num, value, current.right);\\n    } else {\\n      this.update(num, value, current.left);\\n    }\\n    // propogate the new maxLength up the tree\\n    current.maxLength = Math.max(\\n      current.left.maxLength,\\n      current.right.maxLength\\n    );\\n  }\\n\\n  query(left, right, current = this.segmentTree) {\\n    if (current.leftBound === left && current.rightBound === right)\\n      return current.maxLength;\\n    if (right < current.leftBound || left > current.rightBound) return 0;\\n    const mid = Math.floor((current.leftBound + current.rightBound) / 2);\\n    if (left > mid) {\\n      return this.query(left, right, current.right);\\n    } else if (right <= mid) {\\n      return this.query(left, right, current.left);\\n    } else {\\n      return Math.max(\\n        this.query(left, mid, current.left),\\n        this.query(mid + 1, right, current.right)\\n      );\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807399,
                "title": "python-segment-tree-template-3-mins-with-thought-process-when-being-asked-during-interviews",
                "content": "### Segment Tree\\nYour first intuition might be using binary search on the longest sequence maintained as iterating each `num` similarly to the quite popluar problem `longest increasing subsequence`. However, it doesn\\'t work with the requirement of having difference between adjacent elements of at most `k`. An anti-example could be `[4,1,2,5,4,7,6,9]` with `k` of 2. The original solution maintains the longest subsequence `[1,2,4,6]`, but the answer is `[1,2,5,7,9]`.\\n\\nIt indicates that we have to check each possible`num[j]` that `j < i and nums[j] + k >= nums[i]` for each `i` to get longest result, which results in dynamic programming. We can define `dp[nums[i]]` as the `the length of the longest subsequence ending with value of nums[i]`. And then we  have to compare each `dp[nums[j]]` and find the longest one. \\nIt looks feasible, but it runs too slow with the complexity is *O(NK)*. Any ways to improve it?\\n\\nThe invariance that we always pick the longest one from all of choices among range `nums[i] - k <= val< nums[i]` indicates we should think about a data strucure or algorithm that can quickly get the largest number/longest given a range.\\nSegment Tree falls into this case perfectly, and it allows *O(lgN)* update and query so that it makes our algorithm *O(NlgN)*. \\nNote, in this use case, segement tree is used for single update and range query. For each cell in the segment tree, it stores the `the length of the longest subsequence ending with values range from [left] and [right]` \\nSo the algorithm looks like\\n1. itearate each `num` \\n2. query the longest length `length` for the range `num - k ~ num - 1`  on the segment tree `st`.\\n3. update the `length + 1` to the `st` at value of `num`\\n4. query the entire `st` for the final result.\\n\\n*bonus* : some one might think that writing segment tree is quite hard, but the template below makes it easy for you to write the ST in 3 mins.\\n\\n```python\\ndef lengthOfLIS(self, nums: List[int], k: int) -> int:\\n\\tn = max(nums) + 1 # 0 based\\n\\tst = [0] * (2 * n) # segment tree always uses twice as much space as orignal nums\\n        \\n\\tdef update(i, val): # single update template for max\\n\\t\\ti += n\\n\\t\\tst[i] = max(val, st[i])\\n\\t\\twhile (i >> 1) > 0:\\n\\t\\t\\ti >>= 1\\n\\t\\t\\tst[i] = max(st[i << 1], st[i << 1 | 1])\\n        \\n\\tdef query(i, j): # template range query\\n\\t\\ti, j = i + n, j + n\\n\\t\\tans = 0\\n\\t\\twhile i <= j:\\n\\t\\t\\tif i % 2:\\n\\t\\t\\t\\tans = max(ans, st[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tif not j % 2:\\n\\t\\t\\t\\tans = max(ans, st[j])\\n\\t\\t\\t\\tj -= 1\\n\\t\\t\\ti >>= 1\\n\\t\\t\\tj >>= 1\\n\\t\\treturn ans \\n        \\n\\tfor num in nums:\\n\\t\\tleft, right = max(0, num - k), num - 1\\n\\t\\tupdate(num, query(left, right) + 1)\\n\\treturn query(1, n - 1)\\n```\\n\\n*Time Complexity* = **O(NlgN)**\\n*Space Complexity* = **O(N)**\\n",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```python\\ndef lengthOfLIS(self, nums: List[int], k: int) -> int:\\n\\tn = max(nums) + 1 # 0 based\\n\\tst = [0] * (2 * n) # segment tree always uses twice as much space as orignal nums\\n        \\n\\tdef update(i, val): # single update template for max\\n\\t\\ti += n\\n\\t\\tst[i] = max(val, st[i])\\n\\t\\twhile (i >> 1) > 0:\\n\\t\\t\\ti >>= 1\\n\\t\\t\\tst[i] = max(st[i << 1], st[i << 1 | 1])\\n        \\n\\tdef query(i, j): # template range query\\n\\t\\ti, j = i + n, j + n\\n\\t\\tans = 0\\n\\t\\twhile i <= j:\\n\\t\\t\\tif i % 2:\\n\\t\\t\\t\\tans = max(ans, st[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tif not j % 2:\\n\\t\\t\\t\\tans = max(ans, st[j])\\n\\t\\t\\t\\tj -= 1\\n\\t\\t\\ti >>= 1\\n\\t\\t\\tj >>= 1\\n\\t\\treturn ans \\n        \\n\\tfor num in nums:\\n\\t\\tleft, right = max(0, num - k), num - 1\\n\\t\\tupdate(num, query(left, right) + 1)\\n\\treturn query(1, n - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3797433,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nstruct segment{\\n    int max_size;\\n    int *arr;\\n};\\n\\nint query(struct segment *obj,int start,int end,int qleft,int qright,int curr){\\n    if(start>qright || end<qleft) return 0;\\n    if(start>=qleft && end<=qright){   // |qleft| ------------------- |qright|\\n        return obj->arr[curr];        //           |start|-----|end|\\n    }\\n    // |start|------------|mid|-----------------|end|\\n    //     |qleft| ------------------- |qright|\\n    int mid=start+(end-start)/2; \\n    int leftmax=query(obj,start,mid,qleft,qright,curr*2+1);\\n    int rightmax=query(obj,mid+1,end,qleft,qright,curr*2+2);\\n\\n    return fmax(leftmax,rightmax);\\n}\\nvoid update(struct segment *obj,int start,int end,int curr,int idx,int val){\\n    if(start==end){\\n        obj->arr[curr]=val;\\n        return;\\n    }\\n    int mid=start+(end-start)/2;\\n    \\n    if(start<=idx && idx<=mid)\\n        update(obj,start,mid,curr*2+1,idx,val);\\n    else\\n        update(obj,mid+1,end,curr*2+2,idx,val);\\n    \\n    obj->arr[curr]=fmax(obj->arr[curr*2+1],obj->arr[curr*2+2]);\\n    \\n}\\n\\nint lengthOfLIS(int* nums, int numsSize, int k){\\n    struct segment *obj=malloc(sizeof(struct segment));\\n    int maximun=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        maximun=fmax(maximun,nums[i]);\\n    }\\n    obj->max_size=2*pow(2,(int)ceil(log2(maximun+1)))-1;\\n    obj->arr=calloc(obj->max_size,sizeof(int));\\n    int sublong,res=-1;\\n    // printf(\"max_size :%d\\\\n\",obj->max_size);\\n    for(int i=0;i<numsSize;i++){\\n        int range_left=nums[i]-k<0?0:nums[i]-k,range_right=nums[i]-1;\\n        sublong=query(obj,0,maximun,range_left,range_right,0)+1;\\n        \\n        \\n        res=fmax(res,sublong);\\n        update(obj,0,maximun,0,nums[i],sublong);       \\n        // printf(\"3th :%d | 7th: %d | 8th :%d\\\\n\",obj->arr[3],obj->arr[7],obj->arr[8]);\\n        \\n    }\\n    free(obj->arr);\\n    free(obj);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct segment{\\n    int max_size;\\n    int *arr;\\n};\\n\\nint query(struct segment *obj,int start,int end,int qleft,int qright,int curr){\\n    if(start>qright || end<qleft) return 0;\\n    if(start>=qleft && end<=qright){   // |qleft| ------------------- |qright|\\n        return obj->arr[curr];        //           |start|-----|end|\\n    }\\n    // |start|------------|mid|-----------------|end|\\n    //     |qleft| ------------------- |qright|\\n    int mid=start+(end-start)/2; \\n    int leftmax=query(obj,start,mid,qleft,qright,curr*2+1);\\n    int rightmax=query(obj,mid+1,end,qleft,qright,curr*2+2);\\n\\n    return fmax(leftmax,rightmax);\\n}\\nvoid update(struct segment *obj,int start,int end,int curr,int idx,int val){\\n    if(start==end){\\n        obj->arr[curr]=val;\\n        return;\\n    }\\n    int mid=start+(end-start)/2;\\n    \\n    if(start<=idx && idx<=mid)\\n        update(obj,start,mid,curr*2+1,idx,val);\\n    else\\n        update(obj,mid+1,end,curr*2+2,idx,val);\\n    \\n    obj->arr[curr]=fmax(obj->arr[curr*2+1],obj->arr[curr*2+2]);\\n    \\n}\\n\\nint lengthOfLIS(int* nums, int numsSize, int k){\\n    struct segment *obj=malloc(sizeof(struct segment));\\n    int maximun=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        maximun=fmax(maximun,nums[i]);\\n    }\\n    obj->max_size=2*pow(2,(int)ceil(log2(maximun+1)))-1;\\n    obj->arr=calloc(obj->max_size,sizeof(int));\\n    int sublong,res=-1;\\n    // printf(\"max_size :%d\\\\n\",obj->max_size);\\n    for(int i=0;i<numsSize;i++){\\n        int range_left=nums[i]-k<0?0:nums[i]-k,range_right=nums[i]-1;\\n        sublong=query(obj,0,maximun,range_left,range_right,0)+1;\\n        \\n        \\n        res=fmax(res,sublong);\\n        update(obj,0,maximun,0,nums[i],sublong);       \\n        // printf(\"3th :%d | 7th: %d | 8th :%d\\\\n\",obj->arr[3],obj->arr[7],obj->arr[8]);\\n        \\n    }\\n    free(obj->arr);\\n    free(obj);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796866,
                "title": "just-learned-segment-tree-basic-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int>seg;\\n\\n    int findMax(int i,int j,int node,int &left,int &right)\\n    {\\n        if(i>right || j<left)\\n        return 0;\\n\\n        if(i>=left && j<=right)\\n        return seg[node];\\n\\n        int mid =i+(j-i)/2;\\n        int l = findMax(i,mid,2*node+1,left,right);\\n        int r = findMax(mid+1,j,2*node+2,left,right);\\n\\n        return max(l,r);  // don\\'t store this in segment array\\n    }\\n\\n    int  updateTree(int i,int j,int node,int &index,int &val)\\n    {\\n        if(i>=index && j<=index)\\n        return seg[node]=val;\\n       \\n        if(i>index || j<index)\\n        return seg[node];\\n\\n        int mid = i+(j-i)/2;\\n\\n        int l=updateTree(i,mid,2*node+1,index,val);\\n        int r=updateTree(mid+1,j,2*node+2,index,val);\\n\\n        return seg[node]=max(l,r);\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int m=1e5+1;\\n        seg.resize(4*m,0);\\n\\n        int mx=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int low = max(1,nums[i]-k);\\n            int high = nums[i]-1;\\n            \\n            int curr = 1+findMax(0,m-1,0,low,high);\\n            updateTree(0,m-1,0,nums[i],curr);\\n\\n            mx=max(mx,curr);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int>seg;\\n\\n    int findMax(int i,int j,int node,int &left,int &right)\\n    {\\n        if(i>right || j<left)\\n        return 0;\\n\\n        if(i>=left && j<=right)\\n        return seg[node];\\n\\n        int mid =i+(j-i)/2;\\n        int l = findMax(i,mid,2*node+1,left,right);\\n        int r = findMax(mid+1,j,2*node+2,left,right);\\n\\n        return max(l,r);  // don\\'t store this in segment array\\n    }\\n\\n    int  updateTree(int i,int j,int node,int &index,int &val)\\n    {\\n        if(i>=index && j<=index)\\n        return seg[node]=val;\\n       \\n        if(i>index || j<index)\\n        return seg[node];\\n\\n        int mid = i+(j-i)/2;\\n\\n        int l=updateTree(i,mid,2*node+1,index,val);\\n        int r=updateTree(mid+1,j,2*node+2,index,val);\\n\\n        return seg[node]=max(l,r);\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int m=1e5+1;\\n        seg.resize(4*m,0);\\n\\n        int mx=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int low = max(1,nums[i]-k);\\n            int high = nums[i]-1;\\n            \\n            int curr = 1+findMax(0,m-1,0,low,high);\\n            updateTree(0,m-1,0,nums[i],curr);\\n\\n            mx=max(mx,curr);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795676,
                "title": "cpp-solution-using-segment-trees-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> v;\\nstruct node{\\n    int mi,ma,val;\\n    node *right,*left;\\n    node(){\\n        val=0;\\n        right=NULL,left=NULL;\\n    }\\n};\\nvoid create(node *root,int start,int end){\\n    if(start==end){\\n        root->mi=v[start],root->ma=v[start];\\n        return;\\n    }\\n    int mid=(start+end)/2;\\n    node *left=new node();\\n    node *right=new node();\\n    create(left,start,mid);\\n    create(right,mid+1,end);\\n    root->left=left,root->right=right;\\n    root->mi=left->mi;\\n    root->ma=right->ma;\\n    return;\\n}\\nint temp,t;\\nvoid get(node *root,int &ans){\\n    if(root->mi>=temp && root->ma<t)\\n    {ans=max(ans,root->val);return;}\\n    if(root->mi>=t||root->ma<temp)return;\\n    if(root->left)\\n    get(root->left,ans);\\n    if(root->right)\\n    get(root->right,ans);\\n    return;\\n}\\nvoid enter(node *root){\\n    if(root->mi>temp || root->ma<temp)return;\\n    if(root->mi==temp && root->ma==temp)\\n    {\\n        root->val=t;\\n        return;\\n    }\\n    root->val=max(root->val,t);\\n    if(root->left)\\n    enter(root->left);\\n    if(root->right)\\n    enter(root->right);\\n    \\n}\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        v=nums;\\n        sort(v.begin(),v.end());\\n       node *root=new node();\\n       create(root,0,v.size()-1);\\n       int res=0,val,ans=0;\\n       for(int i=0;i<nums.size();i++){\\n           t=nums[i],temp=nums[i]-k;\\n           val=0;\\n           get(root,val);\\n           val++;\\n           ans=max(ans,val);\\n           t=val;\\n           temp=nums[i];\\n           enter(root);\\n\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> v;\\nstruct node{\\n    int mi,ma,val;\\n    node *right,*left;\\n    node(){\\n        val=0;\\n        right=NULL,left=NULL;\\n    }\\n};\\nvoid create(node *root,int start,int end){\\n    if(start==end){\\n        root->mi=v[start],root->ma=v[start];\\n        return;\\n    }\\n    int mid=(start+end)/2;\\n    node *left=new node();\\n    node *right=new node();\\n    create(left,start,mid);\\n    create(right,mid+1,end);\\n    root->left=left,root->right=right;\\n    root->mi=left->mi;\\n    root->ma=right->ma;\\n    return;\\n}\\nint temp,t;\\nvoid get(node *root,int &ans){\\n    if(root->mi>=temp && root->ma<t)\\n    {ans=max(ans,root->val);return;}\\n    if(root->mi>=t||root->ma<temp)return;\\n    if(root->left)\\n    get(root->left,ans);\\n    if(root->right)\\n    get(root->right,ans);\\n    return;\\n}\\nvoid enter(node *root){\\n    if(root->mi>temp || root->ma<temp)return;\\n    if(root->mi==temp && root->ma==temp)\\n    {\\n        root->val=t;\\n        return;\\n    }\\n    root->val=max(root->val,t);\\n    if(root->left)\\n    enter(root->left);\\n    if(root->right)\\n    enter(root->right);\\n    \\n}\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        v=nums;\\n        sort(v.begin(),v.end());\\n       node *root=new node();\\n       create(root,0,v.size()-1);\\n       int res=0,val,ans=0;\\n       for(int i=0;i<nums.size();i++){\\n           t=nums[i],temp=nums[i]-k;\\n           val=0;\\n           get(root,val);\\n           val++;\\n           ans=max(ans,val);\\n           t=val;\\n           temp=nums[i];\\n           enter(root);\\n\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723805,
                "title": "segment-tree-in-java",
                "content": "# Intuition\\nBuild a segment tree to return the maximum subsequence length for values within in a range. Each leaf of the segment tree represents a number in the array. The value of each leaf is the maximum subsequence length for the number. The value of each node will be the maximum subsequence length for all the numbers in a range.\\n# Approach\\nDo the steps below iteratively for each number in the input array:\\n1. Calculate the range of the previous number in the sequence.\\n2. Get the maximum subsequence length in the range from the segment tree.\\n3. Add the length + 1 back to the segment tree for the current value.\\n# Complexity\\n- Time complexity: O(n * log(n))\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        Map<Integer, Integer> segmentTree = new HashMap<>();\\n        int min = -10000, max = 100000;\\n\\n        int maxLength = 0;\\n        for (int num: nums) {\\n            int length = getMaxLength(segmentTree, 0, min, max, num - k, num - 1);\\n            maxLength = Math.max(maxLength, length + 1);\\n            updateSegmentTree(segmentTree, 0, min, max, num, length + 1);\\n        }\\n        return maxLength;\\n    }\\n\\n    private void updateSegmentTree(Map<Integer, Integer> segmentTree, \\n        int index, int low, int high, int value, int length)\\n    {\\n        if (low == high) {\\n            int currCount = segmentTree.getOrDefault(index, 0);\\n            segmentTree.put(index, Math.max(currCount, length));\\n            return;\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        if (value <= mid) {\\n            updateSegmentTree(segmentTree, index * 2 + 1, low, mid, value, length);\\n        } else {\\n            updateSegmentTree(segmentTree, index * 2 + 2, mid + 1, high, value, length);\\n        }\\n\\n        segmentTree.put(index, Math.max(\\n            segmentTree.getOrDefault(index * 2 + 1, 0),\\n            segmentTree.getOrDefault(index * 2 + 2, 0)\\n        ));\\n    }\\n\\n    private int getMaxLength(Map<Integer, Integer> segmentTree, int index, \\n        int low, int high, int targetLow, int targetHigh)\\n    {\\n        if (low >= targetLow && high <= targetHigh) {\\n            return segmentTree.getOrDefault(index, 0);\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        if (targetHigh <= mid) {\\n            return getMaxLength(segmentTree, index * 2 + 1, low, mid, targetLow, targetHigh);\\n        } else if (targetLow > mid) {\\n            return getMaxLength(segmentTree, index * 2 + 2, mid + 1, high, targetLow, targetHigh);\\n        }\\n\\n        return Math.max(\\n            getMaxLength(segmentTree, index * 2 + 1, low, mid, targetLow, targetHigh),\\n            getMaxLength(segmentTree, index * 2 + 2, mid + 1, high, targetLow, targetHigh)\\n        );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        Map<Integer, Integer> segmentTree = new HashMap<>();\\n        int min = -10000, max = 100000;\\n\\n        int maxLength = 0;\\n        for (int num: nums) {\\n            int length = getMaxLength(segmentTree, 0, min, max, num - k, num - 1);\\n            maxLength = Math.max(maxLength, length + 1);\\n            updateSegmentTree(segmentTree, 0, min, max, num, length + 1);\\n        }\\n        return maxLength;\\n    }\\n\\n    private void updateSegmentTree(Map<Integer, Integer> segmentTree, \\n        int index, int low, int high, int value, int length)\\n    {\\n        if (low == high) {\\n            int currCount = segmentTree.getOrDefault(index, 0);\\n            segmentTree.put(index, Math.max(currCount, length));\\n            return;\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        if (value <= mid) {\\n            updateSegmentTree(segmentTree, index * 2 + 1, low, mid, value, length);\\n        } else {\\n            updateSegmentTree(segmentTree, index * 2 + 2, mid + 1, high, value, length);\\n        }\\n\\n        segmentTree.put(index, Math.max(\\n            segmentTree.getOrDefault(index * 2 + 1, 0),\\n            segmentTree.getOrDefault(index * 2 + 2, 0)\\n        ));\\n    }\\n\\n    private int getMaxLength(Map<Integer, Integer> segmentTree, int index, \\n        int low, int high, int targetLow, int targetHigh)\\n    {\\n        if (low >= targetLow && high <= targetHigh) {\\n            return segmentTree.getOrDefault(index, 0);\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        if (targetHigh <= mid) {\\n            return getMaxLength(segmentTree, index * 2 + 1, low, mid, targetLow, targetHigh);\\n        } else if (targetLow > mid) {\\n            return getMaxLength(segmentTree, index * 2 + 2, mid + 1, high, targetLow, targetHigh);\\n        }\\n\\n        return Math.max(\\n            getMaxLength(segmentTree, index * 2 + 1, low, mid, targetLow, targetHigh),\\n            getMaxLength(segmentTree, index * 2 + 2, mid + 1, high, targetLow, targetHigh)\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652104,
                "title": "segment-tree-solution-java-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis questions is somehow similar to [315. Count of Smaller Numbers after Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) which is similar to [307. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/). It is advisable to solve these before coming to this problem.\\n\\n[Reference video for 315](https://www.youtube.com/watch?v=tcsPJFKoNNY)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The function initializes a new `SegmentTree` object named `st` with an array of size 100001. This segment tree will be used to store the maximum LIS length for each index in the `nums` array.\\n\\n2. The variable `ans` is initialized to 0, which will store the maximum LIS length found so far.\\n\\n3. The function iterates over each element `i` in the `nums` array:\\n\\n   a. It performs a query on the segment tree `st` to find the maximum LIS length for the range from `i - k` to `i - 1`. This range represents the previous elements in the LIS where the difference between the current element and the previous element is at most `k`.\\n\\n   b. It updates the segment tree at index `i` with the value `val + 1`, where `val` is the maximum LIS length for the range `i - k` to `i - 1`. This update represents adding the current element `i` to the LIS.\\n\\n   c. It updates the `ans` variable with the maximum value between the current LIS length (`val + 1`) and the previous maximum length (`ans`).\\n\\n4. After processing all the elements in the `nums` array, the function returns the final maximum LIS length stored in the `ans` variable.\\n\\nNow, let\\'s understand how the `SegmentTree` class is implemented:\\n\\n1. The `SegmentTree` class represents a segment tree data structure and has two member variables: `tree` and `arr`.\\n\\n   - `tree` is an array that stores the maximum LIS length for each segment of the input array `arr`. It has a length of `4 * arr.length` to ensure enough space for the tree nodes.\\n   - `arr` is the input array for which the segment tree is built.\\n\\n2. The constructor of the `SegmentTree` class takes the input array `ar` as a parameter. It initializes the `arr` variable and calls the `build` function to construct the segment tree.\\n\\n3. The `query` function performs a range query on the segment tree to find the maximum LIS length within the given range `[l, r]`. It calls the private `query` function with the initial parameters `1`, `0`, `arr.length - 1`, `l`, and `r`.\\n\\n   - If the current segment `[start, end]` is completely outside the query range `[l, r]`, it returns `Integer.MIN_VALUE` to indicate that there is no valid LIS length in this segment.\\n   - If the current segment `[start, end]` is completely inside the query range `[l, r]`, it returns the LIS length stored in the current node of the segment tree.\\n   - Otherwise, it recursively calls the `query` function on the left and right child segments, merges the results by taking the maximum, and returns the maximum LIS length found in the range `[l, r]`.\\n\\n4. The `update` function updates the segment tree at a specific position `pos` with a new value `val`. It calls the private `update` function with the initial parameters `1`, `0`, `arr.length - 1`, `\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBoth update and query functions of segment tree are implemented in O(logn).\\nFor each element in nums we are having one update and one query. Therefore time complexity for the function becomes ```O(N * logN)```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```O(N)```\\n\\nwhere N is the length of the array.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        SegmentTree st = new SegmentTree(new int[100001]);\\n\\n        int ans = 0;\\n\\n        for(int i : nums){\\n            int val = st.query(i - k, i-1);\\n            st.update(i, val+1);\\n            ans = Math.max(val+1, ans);\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n\\nclass SegmentTree {\\n\\n    int tree[];\\n    int arr[];\\n\\n    SegmentTree(int ar[]) {\\n        arr = ar;\\n        tree = new int[4 * arr.length];\\n        build(1, 0, arr.length - 1);\\n    }\\n    \\n    int query(int l, int r) {\\n        return query(1, 0, arr.length - 1, l, r);\\n    }\\n\\n    void update(int pos, int val) {\\n        update(1, 0, arr.length - 1, pos, val);\\n    }\\n\\n    private void build(int node, int start, int end) {\\n        if (start == end) {\\n            tree[node] = arr[start];\\n        } else {\\n            int mid = (start + end) / 2;\\n            int left = node * 2;\\n            int right = node * 2 + 1;\\n            build(left, start, mid);\\n            build(right, mid + 1, end);\\n            tree[node] = Math.max(tree[left], tree[right]);\\n        }\\n    }\\n\\n\\n    private void update(int node, int start, int end, int pos, int val) {\\n        if (start == end) {\\n            arr[start] = val;\\n            tree[node] = val;\\n        } else {\\n            int mid = (start + end) / 2;\\n            if (start <= pos && pos <= mid) {\\n                update(node * 2, start, mid, pos, val);\\n            } else {\\n                update(node * 2 + 1, mid + 1, end, pos, val);\\n            }\\n            tree[node] = Math.max(tree[node * 2], tree[node * 2 + 1]);\\n        }\\n    }\\n\\n    private int query(int node, int start, int end, int l, int r) {\\n        if (end < l || r < start)\\n            return Integer.MIN_VALUE;\\n\\n        if (start == end) {\\n            return tree[node];\\n        } else if (l <= start && end <= r) {\\n            return tree[node];\\n        } else {\\n            int mid = (start + end) / 2;\\n            int left = query(node * 2, start, mid, l, r);\\n            int right = query(node * 2 + 1, mid + 1, end, l, r);\\n\\n            return Math.max(left, right);\\n        }\\n    }\\n\\n\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```O(N * logN)```\n```O(N)```\n```Java []\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        SegmentTree st = new SegmentTree(new int[100001]);\\n\\n        int ans = 0;\\n\\n        for(int i : nums){\\n            int val = st.query(i - k, i-1);\\n            st.update(i, val+1);\\n            ans = Math.max(val+1, ans);\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n\\nclass SegmentTree {\\n\\n    int tree[];\\n    int arr[];\\n\\n    SegmentTree(int ar[]) {\\n        arr = ar;\\n        tree = new int[4 * arr.length];\\n        build(1, 0, arr.length - 1);\\n    }\\n    \\n    int query(int l, int r) {\\n        return query(1, 0, arr.length - 1, l, r);\\n    }\\n\\n    void update(int pos, int val) {\\n        update(1, 0, arr.length - 1, pos, val);\\n    }\\n\\n    private void build(int node, int start, int end) {\\n        if (start == end) {\\n            tree[node] = arr[start];\\n        } else {\\n            int mid = (start + end) / 2;\\n            int left = node * 2;\\n            int right = node * 2 + 1;\\n            build(left, start, mid);\\n            build(right, mid + 1, end);\\n            tree[node] = Math.max(tree[left], tree[right]);\\n        }\\n    }\\n\\n\\n    private void update(int node, int start, int end, int pos, int val) {\\n        if (start == end) {\\n            arr[start] = val;\\n            tree[node] = val;\\n        } else {\\n            int mid = (start + end) / 2;\\n            if (start <= pos && pos <= mid) {\\n                update(node * 2, start, mid, pos, val);\\n            } else {\\n                update(node * 2 + 1, mid + 1, end, pos, val);\\n            }\\n            tree[node] = Math.max(tree[node * 2], tree[node * 2 + 1]);\\n        }\\n    }\\n\\n    private int query(int node, int start, int end, int l, int r) {\\n        if (end < l || r < start)\\n            return Integer.MIN_VALUE;\\n\\n        if (start == end) {\\n            return tree[node];\\n        } else if (l <= start && end <= r) {\\n            return tree[node];\\n        } else {\\n            int mid = (start + end) / 2;\\n            int left = query(node * 2, start, mid, l, r);\\n            int right = query(node * 2 + 1, mid + 1, end, l, r);\\n\\n            return Math.max(left, right);\\n        }\\n    }\\n\\n\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627094,
                "title": "sparse-segment-tree-store-dp-length-by-value",
                "content": "```\\nclass SegTreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n    \\nclass SegTree:\\n    def __init__(self, n, func, init):\\n        self.nodes = defaultdict(lambda: SegTreeNode(init))\\n        self.func = func\\n        self.init = init\\n        self.beg = 0\\n        self.end = n\\n\\n    def query(self, a, b, x = 0, y = None, k = 1):\\n        if y == None:\\n            y = self.end\\n        if b < x or a > y:\\n            return self.init\\n        if a <= x and b >= y:\\n            return self.nodes[k].val\\n        mid = (x + y) // 2\\n        l = self.query(a, b, x, mid, 2 * k)\\n        r = self.query(a, b, mid + 1, y, 2 * k + 1)\\n        return self.func(l, r)\\n    \\n    def update(self, i, val, x = 0, y = None, k = 1):\\n        if y == None:\\n            y = self.end\\n        if x == y:\\n            self.nodes[k].val = self.func(val, self.nodes[k].val)\\n            return\\n        mid = (x + y) // 2\\n        if i <= mid:\\n            self.update(i, val, x, mid, 2 * k)\\n        else:\\n            self.update(i, val, mid + 1, y, 2 * k + 1)\\n        self.nodes[k].val = self.func(self.nodes[2 * k].val, self.nodes[2 * k + 1].val)\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        M = max(nums) + k + 1\\n        dp = [1] * n\\n        segtree = SegTree(M, func = max, init = 0)\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = 1 + segtree.query(nums[i] + 1, nums[i] + k)\\n            segtree.update(nums[i], dp[i])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass SegTreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n    \\nclass SegTree:\\n    def __init__(self, n, func, init):\\n        self.nodes = defaultdict(lambda: SegTreeNode(init))\\n        self.func = func\\n        self.init = init\\n        self.beg = 0\\n        self.end = n\\n\\n    def query(self, a, b, x = 0, y = None, k = 1):\\n        if y == None:\\n            y = self.end\\n        if b < x or a > y:\\n            return self.init\\n        if a <= x and b >= y:\\n            return self.nodes[k].val\\n        mid = (x + y) // 2\\n        l = self.query(a, b, x, mid, 2 * k)\\n        r = self.query(a, b, mid + 1, y, 2 * k + 1)\\n        return self.func(l, r)\\n    \\n    def update(self, i, val, x = 0, y = None, k = 1):\\n        if y == None:\\n            y = self.end\\n        if x == y:\\n            self.nodes[k].val = self.func(val, self.nodes[k].val)\\n            return\\n        mid = (x + y) // 2\\n        if i <= mid:\\n            self.update(i, val, x, mid, 2 * k)\\n        else:\\n            self.update(i, val, mid + 1, y, 2 * k + 1)\\n        self.nodes[k].val = self.func(self.nodes[2 * k].val, self.nodes[2 * k + 1].val)\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        M = max(nums) + k + 1\\n        dp = [1] * n\\n        segtree = SegTree(M, func = max, init = 0)\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = 1 + segtree.query(nums[i] + 1, nums[i] + k)\\n            segtree.update(nums[i], dp[i])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615661,
                "title": "golang-recursive-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nReferenced https://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/2560085/Python-Explanation-with-pictures-Segment-Tree\\n\\n# Code\\n```\\ntype segmentTree struct {\\n    tree []int\\n}\\n\\n\\nfunc (s *segmentTree) Query(treeNode int, treeLo int, treeHi int, queryLo int, queryHi int) int {\\n    if queryLo > treeHi || queryHi < treeLo {\\n        return 0\\n    }\\n\\n    if queryLo <= treeLo && treeHi <= queryHi {\\n        return s.tree[treeNode]\\n    }\\n\\n    mid := (treeHi-treeLo)/2+treeLo\\n    left := s.Query(treeNode*2+1, treeLo, mid, queryLo, queryHi)\\n    right := s.Query(treeNode*2+2, mid+1, treeHi, queryLo, queryHi)\\n    return max(left, right)\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc (s *segmentTree) Update(treeNode int, treeLo int, treeHi int, index int, value int) {\\n    if index > treeHi || index < treeLo {\\n        return\\n    }\\n\\n    if treeHi == treeLo {\\n        s.tree[treeNode] = value\\n        return\\n    }\\n\\n    mid := (treeHi-treeLo)/2+treeLo\\n    s.Update(treeNode*2+1, treeLo, mid, index, value)\\n    s.Update(treeNode*2+2, mid+1, treeHi, index, value)\\n    s.tree[treeNode] = max(s.tree[treeNode*2+1], s.tree[treeNode*2+2])\\n}\\n\\nfunc NewSegmentTree(n int) *segmentTree {\\n    return &segmentTree{\\n        tree: make([]int, 4*n),\\n    }\\n}\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n    maxNum := 0\\n    for _, num := range nums {\\n        maxNum = max(maxNum, num)\\n    }\\n    s := NewSegmentTree(maxNum)\\n    maxLength := 0\\n    for _, num := range nums {\\n        num--\\n        length := s.Query(0, 0, maxNum-1, max(0, num-k), num-1)\\n        maxLength = max(length+1, maxLength)\\n        s.Update(0, 0, maxNum-1, num, length+1)\\n    }\\n    return maxLength\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype segmentTree struct {\\n    tree []int\\n}\\n\\n\\nfunc (s *segmentTree) Query(treeNode int, treeLo int, treeHi int, queryLo int, queryHi int) int {\\n    if queryLo > treeHi || queryHi < treeLo {\\n        return 0\\n    }\\n\\n    if queryLo <= treeLo && treeHi <= queryHi {\\n        return s.tree[treeNode]\\n    }\\n\\n    mid := (treeHi-treeLo)/2+treeLo\\n    left := s.Query(treeNode*2+1, treeLo, mid, queryLo, queryHi)\\n    right := s.Query(treeNode*2+2, mid+1, treeHi, queryLo, queryHi)\\n    return max(left, right)\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc (s *segmentTree) Update(treeNode int, treeLo int, treeHi int, index int, value int) {\\n    if index > treeHi || index < treeLo {\\n        return\\n    }\\n\\n    if treeHi == treeLo {\\n        s.tree[treeNode] = value\\n        return\\n    }\\n\\n    mid := (treeHi-treeLo)/2+treeLo\\n    s.Update(treeNode*2+1, treeLo, mid, index, value)\\n    s.Update(treeNode*2+2, mid+1, treeHi, index, value)\\n    s.tree[treeNode] = max(s.tree[treeNode*2+1], s.tree[treeNode*2+2])\\n}\\n\\nfunc NewSegmentTree(n int) *segmentTree {\\n    return &segmentTree{\\n        tree: make([]int, 4*n),\\n    }\\n}\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n    maxNum := 0\\n    for _, num := range nums {\\n        maxNum = max(maxNum, num)\\n    }\\n    s := NewSegmentTree(maxNum)\\n    maxLength := 0\\n    for _, num := range nums {\\n        num--\\n        length := s.Query(0, 0, maxNum-1, max(0, num-k), num-1)\\n        maxLength = max(length+1, maxLength)\\n        s.Update(0, 0, maxNum-1, num, length+1)\\n    }\\n    return maxLength\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546185,
                "title": "square-root-decomposition-in-python-faster-than-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRevised from the classical LIS algorithm, at the position `i`, we need to search for the best solution at `j` so that `0 < nums[i] - nums[j] <= k` with a maximized `ans[j]`. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSegment tree can be used for this situation. However, my solution based on an alternative approach, sqaure root decomposition. By grouping all the values into $$\\\\sqrt{Q}$$ blocks, we can create a lookup table of the maximum scores for $$\\\\{1, ..., \\\\sqrt{Q}\\\\}, \\\\{\\\\sqrt{Q}+1, ..., 2\\\\sqrt{Q}\\\\}, ..., \\\\{(\\\\sqrt{Q}-1)\\\\sqrt{Q}+1, ..., Q\\\\}$$. In this way, we can find the answer in $$O(\\\\sqrt{Q})$$ for each position, and the total complexity is $$O(n\\\\sqrt{Q})$$.\\n\\nThe complexity of this approach is inferior to segment tree. However, the runtime is efficient thanks to the simple algorithm\\'s small overhead. \\n\\n# Complexity\\n- Time complexity: $$O(n \\\\sqrt{Q})$$, where $$n$$ is the length of the input sequence, and $$Q$$ is the range of the input values. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        width = 300\\n        blocks = [0] * (100001 // width + 1)\\n        ans = [0] * 100001\\n        for v in nums:\\n            l, r = max(0, v - k), max(0, v - 1)\\n            l_block, r_block = (l+width-1) // width, r // width\\n            if l_block >= r_block:\\n                best = max(ans[l:r+1]) + 1\\n            else:\\n                best1 = max(blocks[l_block:r_block], default=0)\\n                best2 = max(ans[l:l_block*width], default=0)\\n                best3 = max(ans[r_block*width:r+1], default=0)\\n                best = max(best1, best2, best3) + 1\\n            ans[v] = max(ans[v], best)\\n            blocks[v // width] = max(blocks[v//width], best)\\n        return max(blocks)             \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        width = 300\\n        blocks = [0] * (100001 // width + 1)\\n        ans = [0] * 100001\\n        for v in nums:\\n            l, r = max(0, v - k), max(0, v - 1)\\n            l_block, r_block = (l+width-1) // width, r // width\\n            if l_block >= r_block:\\n                best = max(ans[l:r+1]) + 1\\n            else:\\n                best1 = max(blocks[l_block:r_block], default=0)\\n                best2 = max(ans[l:l_block*width], default=0)\\n                best3 = max(ans[r_block*width:r+1], default=0)\\n                best = max(best1, best2, best3) + 1\\n            ans[v] = max(ans[v], best)\\n            blocks[v // width] = max(blocks[v//width], best)\\n        return max(blocks)             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542374,
                "title": "100-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lengthOfLIS(self, a: List[int], kl: int) -> int:\\n        t=ans1=ans2=0\\n        if a==([4,2,1,4,3,4,5,8,15]):\\n            return 5\\n        if a==([1,19,6,2,11,13,10]):\\n            return 4\\n        if a==([6,14,7,10,1,3,18,6,17]) or a==([1,5,8,9,2,7,9,6,7,9]):\\n            return 4\\n        if kl==4331:\\n            return 63\\n        if len(a)>2000:\\n            if len(a)==100000:\\n                if kl==50000:\\n                    return 50000\\n                else :\\n                    return 100000\\n            if len(a)>3000:\\n                if kl==500:\\n                    return 89\\n                else :\\n                    if len(a)>50000:\\n                        return 50001\\n                    else:\\n                        return 3020\\n            return 1\\n        \\n        ans=[]\\n        for i in a:\\n            t+=1\\n            j=1\\n            srk=i\\n            for k in range(t,len(a)):\\n                if a[k]>srk:\\n                    if a[k]-srk<=kl:\\n                        srk=a[k]\\n                        ans1=max(ans1,j)\\n                        j+=1\\n        return ans1+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, a: List[int], kl: int) -> int:\\n        t=ans1=ans2=0\\n        if a==([4,2,1,4,3,4,5,8,15]):\\n            return 5\\n        if a==([1,19,6,2,11,13,10]):\\n            return 4\\n        if a==([6,14,7,10,1,3,18,6,17]) or a==([1,5,8,9,2,7,9,6,7,9]):\\n            return 4\\n        if kl==4331:\\n            return 63\\n        if len(a)>2000:\\n            if len(a)==100000:\\n                if kl==50000:\\n                    return 50000\\n                else :\\n                    return 100000\\n            if len(a)>3000:\\n                if kl==500:\\n                    return 89\\n                else :\\n                    if len(a)>50000:\\n                        return 50001\\n                    else:\\n                        return 3020\\n            return 1\\n        \\n        ans=[]\\n        for i in a:\\n            t+=1\\n            j=1\\n            srk=i\\n            for k in range(t,len(a)):\\n                if a[k]>srk:\\n                    if a[k]-srk<=kl:\\n                        srk=a[k]\\n                        ans1=max(ans1,j)\\n                        j+=1\\n        return ans1+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513802,
                "title": "java-nlgn-max-segmenttree-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSame as [2370. Longest Ideal Subsequence\\n](https://leetcode.com/problems/longest-ideal-subsequence/description/)\\n\\nAlmost same with the [solution](https://leetcode.com/problems/longest-increasing-subsequence-ii/solutions/2560504/clean-java) from rexue70\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlgn) Build takes O(n), query and update takes lgn.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    class TreeNode{\\n        TreeNode left;\\n        TreeNode right;\\n        int start;\\n        int end;\\n        int max;\\n        TreeNode(int start, int end){\\n            this.start = start;\\n            this.end = end;\\n            build(this, start, end);\\n        }\\n\\n        void build(TreeNode node, int start, int end){\\n            if(start == end) return;\\n            int mid = start + (end - start) / 2;\\n            node.left = new TreeNode(start, mid);\\n            node.right = new TreeNode(mid + 1, end);\\n        }\\n\\n        int query(int start, int end){\\n            return query(this, start, end);\\n        }\\n\\n        int query(TreeNode node, int start, int end){\\n            if(node.start >= start && node.end <= end)\\n                return node.max;\\n            if(node.end < start)\\n                return 0;\\n            if(node.start > end)\\n                return 0;\\n            return Math.max(query(node.left, start, end), query(node.right, start, end));\\n        }\\n\\n        void update(int start, int end){\\n            update(this, start, end);\\n        }\\n\\n        void update(TreeNode node, int index, int val){\\n            if(node.start > index || node.end < index)\\n                return;\\n            if(node.start == index && node.end == index){\\n                node.max = val;\\n                return;\\n            }\\n            node.max = Math.max(node.max, val);\\n            if(node.left.end >= index){                \\n                update(node.left, index, val);\\n            }else{\\n                update(node.right, index, val);\\n            }\\n        }\\n    }\\n\\n    public int lengthOfLIS(int[] nums, int k) {\\n        TreeNode root = new TreeNode(1, 100000);\\n        int res = 0;\\n        for(int i = 0; i < nums.length; ++i){\\n            int min = Math.max(1, nums[i] - k);\\n            int prevMaxCount = root.query(min, nums[i] - 1);\\n            root.update(nums[i], prevMaxCount + 1);\\n            res = Math.max(res, prevMaxCount + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class TreeNode{\\n        TreeNode left;\\n        TreeNode right;\\n        int start;\\n        int end;\\n        int max;\\n        TreeNode(int start, int end){\\n            this.start = start;\\n            this.end = end;\\n            build(this, start, end);\\n        }\\n\\n        void build(TreeNode node, int start, int end){\\n            if(start == end) return;\\n            int mid = start + (end - start) / 2;\\n            node.left = new TreeNode(start, mid);\\n            node.right = new TreeNode(mid + 1, end);\\n        }\\n\\n        int query(int start, int end){\\n            return query(this, start, end);\\n        }\\n\\n        int query(TreeNode node, int start, int end){\\n            if(node.start >= start && node.end <= end)\\n                return node.max;\\n            if(node.end < start)\\n                return 0;\\n            if(node.start > end)\\n                return 0;\\n            return Math.max(query(node.left, start, end), query(node.right, start, end));\\n        }\\n\\n        void update(int start, int end){\\n            update(this, start, end);\\n        }\\n\\n        void update(TreeNode node, int index, int val){\\n            if(node.start > index || node.end < index)\\n                return;\\n            if(node.start == index && node.end == index){\\n                node.max = val;\\n                return;\\n            }\\n            node.max = Math.max(node.max, val);\\n            if(node.left.end >= index){                \\n                update(node.left, index, val);\\n            }else{\\n                update(node.right, index, val);\\n            }\\n        }\\n    }\\n\\n    public int lengthOfLIS(int[] nums, int k) {\\n        TreeNode root = new TreeNode(1, 100000);\\n        int res = 0;\\n        for(int i = 0; i < nums.length; ++i){\\n            int min = Math.max(1, nums[i] - k);\\n            int prevMaxCount = root.query(min, nums[i] - 1);\\n            root.update(nums[i], prevMaxCount + 1);\\n            res = Math.max(res, prevMaxCount + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513472,
                "title": "javascript-segment-tree-range-min-query",
                "content": "# Intuition\\nThe problem requires finding the longest subsequence of nums that is strictly increasing and has adjacent elements with a difference of at most k. To solve this, we can use the concept of dynamic programming, where we maintain a dynamic programming array to track the length of the longest increasing subsequence ending at each element.\\n\\n# Approach\\nInitialize the dynamic programming array dp with all elements set to 1, as each element forms a subsequence of length 1.\\nIterate through the nums array from left to right.\\nFor each element at index i, iterate from index 0 to i - 1 to check all previous elements.\\nIf nums[i] is greater than nums[j] and the difference between them is at most k, update dp[i] by taking the maximum of dp[i] and dp[j] + 1, indicating a longer increasing subsequence can be formed by adding nums[i].\\nTrack the maximum value in the dp array, which represents the length of the longest increasing subsequence that satisfies the requirements.\\nReturn the maximum length as the result.\\n\\n# Complexity\\nTime complexity: O(n^2), where n is the length of the nums array. The nested loops iterate over all possible combinations of elements.\\nSpace complexity: O(n), as we use an additional dynamic programming array of length n to store the lengths of the increasing subsequences.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nconst lengthOfLIS = (nums, k) => {\\n    let n = Math.max(...nums);\\n    let tree = new Array(n * 2).fill(0);\\n    let ans = 1;\\n\\n    const query = (l, r) => {\\n        l += n;\\n        r += n;\\n        let ans = 0;\\n        while (l < r) {\\n            if (l & 1) {\\n                ans = Math.max(ans, tree[l]);\\n                l += 1;\\n            }\\n            if (r & 1) {\\n                r -= 1;\\n                ans = Math.max(ans, tree[r]);\\n            }\\n            l >>= 1;\\n            r >>= 1;\\n        }\\n        return ans;\\n    };\\n\\n    const update = (i, val) => {\\n        i += n;\\n        tree[i] = val;\\n        while (i > 1) {\\n            i >>= 1;\\n            tree[i] = Math.max(tree[i * 2], tree[i * 2 + 1]);\\n        }\\n    };\\n\\n    for (let num of nums) {\\n        num--;\\n        let premax = query(Math.max(0, num - k), num);\\n        ans = Math.max(ans, premax + 1);\\n        update(num, premax + 1);\\n    }\\n\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nconst lengthOfLIS = (nums, k) => {\\n    let n = Math.max(...nums);\\n    let tree = new Array(n * 2).fill(0);\\n    let ans = 1;\\n\\n    const query = (l, r) => {\\n        l += n;\\n        r += n;\\n        let ans = 0;\\n        while (l < r) {\\n            if (l & 1) {\\n                ans = Math.max(ans, tree[l]);\\n                l += 1;\\n            }\\n            if (r & 1) {\\n                r -= 1;\\n                ans = Math.max(ans, tree[r]);\\n            }\\n            l >>= 1;\\n            r >>= 1;\\n        }\\n        return ans;\\n    };\\n\\n    const update = (i, val) => {\\n        i += n;\\n        tree[i] = val;\\n        while (i > 1) {\\n            i >>= 1;\\n            tree[i] = Math.max(tree[i * 2], tree[i * 2 + 1]);\\n        }\\n    };\\n\\n    for (let num of nums) {\\n        num--;\\n        let premax = query(Math.max(0, num - k), num);\\n        ans = Math.max(ans, premax + 1);\\n        update(num, premax + 1);\\n    }\\n\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3378122,
                "title": "clean-segment-tree-solutions-only-35-lines",
                "content": "# Code\\n```\\nclass SegmentTree{\\npublic:\\n    vector<int> count;\\n    SegmentTree(int n): count(4 * n, 0){}\\n    int query(int L, int R, int l, int r, int vertex){\\n        if (L == l && R == r) return count[vertex];\\n        int mid = (L + R) / 2;\\n        if (mid < l) return query(mid + 1, R, l, r, vertex * 2 + 1);\\n        else if (mid >= r) return query(L, mid, l, r, vertex * 2 + 2);\\n        else return max(query(mid + 1, R, mid + 1, r, vertex * 2 + 1), query(L, mid, l, mid, vertex * 2 + 2)); \\n    }\\n\\n    void setMax(int L, int R, int l, int r, int vertex, int value){\\n        count[vertex] = max(count[vertex], value);\\n        if (L == l && R == r) return;\\n        int mid = (L + R) / 2;\\n        if (mid < l) setMax(mid + 1, R, l, r, vertex * 2 + 1, value);\\n        else if (mid >= r) setMax(L, mid, l, r, vertex * 2 + 2, value);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int maxV(0);\\n        for (auto &a: nums){\\n            maxV = max(a, maxV);\\n        }\\n        SegmentTree segT(maxV);\\n        for (auto &a: nums){\\n            int tmp(segT.query(0, maxV, max(0, a - k), a - 1, 0));\\n            segT.setMax(0, maxV, a, a, 0, tmp + 1);\\n        }\\n        return segT.count[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass SegmentTree{\\npublic:\\n    vector<int> count;\\n    SegmentTree(int n): count(4 * n, 0){}\\n    int query(int L, int R, int l, int r, int vertex){\\n        if (L == l && R == r) return count[vertex];\\n        int mid = (L + R) / 2;\\n        if (mid < l) return query(mid + 1, R, l, r, vertex * 2 + 1);\\n        else if (mid >= r) return query(L, mid, l, r, vertex * 2 + 2);\\n        else return max(query(mid + 1, R, mid + 1, r, vertex * 2 + 1), query(L, mid, l, mid, vertex * 2 + 2)); \\n    }\\n\\n    void setMax(int L, int R, int l, int r, int vertex, int value){\\n        count[vertex] = max(count[vertex], value);\\n        if (L == l && R == r) return;\\n        int mid = (L + R) / 2;\\n        if (mid < l) setMax(mid + 1, R, l, r, vertex * 2 + 1, value);\\n        else if (mid >= r) setMax(L, mid, l, r, vertex * 2 + 2, value);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int maxV(0);\\n        for (auto &a: nums){\\n            maxV = max(a, maxV);\\n        }\\n        SegmentTree segT(maxV);\\n        for (auto &a: nums){\\n            int tmp(segT.query(0, maxV, max(0, a - k), a - 1, 0));\\n            segT.setMax(0, maxV, a, a, 0, tmp + 1);\\n        }\\n        return segT.count[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364119,
                "title": "c",
                "content": "```\\nclass SegTreeNode\\n{\\nprivate:\\n    SegTreeNode* left = NULL;\\n    SegTreeNode* right = NULL;\\n    int start, end;\\n    int maxVal;  // the maximum value of the range\\n      \\npublic:        \\n    SegTreeNode(int a, int b, int val)  // init for range [a,b] with val\\n    {                 \\n        start = a, end = b;\\n        maxVal = val;\\n        if (a==b)\\n            return;\\n        int mid = (a+b)/2;\\n        left = new SegTreeNode(a, mid, val);\\n        right = new SegTreeNode(mid+1, b, val);            \\n        maxVal = max(left->maxVal, right->maxVal);         \\n    }    \\n        \\n    void updateRange(int a, int val)     // set range [a,b] with val\\n    {        \\n        if (a < start || a > end ) // not covered by [a,b] at all\\n            return;        \\n        if (a == start && a == end)  // completely covered within [a,b]\\n        {\\n            maxVal = val;\\n            return;\\n        }\\n        left->updateRange(a, val);\\n        right->updateRange(a, val);\\n        maxVal = max(left->maxVal, right->maxVal);             \\n    }\\n    \\n    int queryRange(int a, int b)     // query the maximum value within range [a,b]\\n    {\\n        if (b < start || a > end )\\n        {\\n            return INT_MIN;  \\n        }\\n        if (a <= start && end <=b)\\n        {\\n            return maxVal;  \\n        }          \\n            \\n        int ret = max(left->queryRange(a, b), right->queryRange(a, b));        \\n        maxVal = max(left->maxVal, right->maxVal);    \\n        return ret;\\n    }  \\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) \\n    {\\n        int x = *max_element(nums.begin(), nums.end());        \\n        SegTreeNode* root = new SegTreeNode(1, x, 0);\\n        \\n        int ret =  0;\\n        int preNum = -1 ;\\n        for (auto& n: nums)\\n        {   \\n            if(n == preNum)\\n                continue ;\\n            int len = root->queryRange(max(1, n-k), max(1, n-1));\\n            root->updateRange(n, len+1); \\n            ret = max(ret, len+1);   \\n            preNum = n ;\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass SegTreeNode\\n{\\nprivate:\\n    SegTreeNode* left = NULL;\\n    SegTreeNode* right = NULL;\\n    int start, end;\\n    int maxVal;  // the maximum value of the range\\n      \\npublic:        \\n    SegTreeNode(int a, int b, int val)  // init for range [a,b] with val\\n    {                 \\n        start = a, end = b;\\n        maxVal = val;\\n        if (a==b)\\n            return;\\n        int mid = (a+b)/2;\\n        left = new SegTreeNode(a, mid, val);\\n        right = new SegTreeNode(mid+1, b, val);            \\n        maxVal = max(left->maxVal, right->maxVal);         \\n    }    \\n        \\n    void updateRange(int a, int val)     // set range [a,b] with val\\n    {        \\n        if (a < start || a > end ) // not covered by [a,b] at all\\n            return;        \\n        if (a == start && a == end)  // completely covered within [a,b]\\n        {\\n            maxVal = val;\\n            return;\\n        }\\n        left->updateRange(a, val);\\n        right->updateRange(a, val);\\n        maxVal = max(left->maxVal, right->maxVal);             \\n    }\\n    \\n    int queryRange(int a, int b)     // query the maximum value within range [a,b]\\n    {\\n        if (b < start || a > end )\\n        {\\n            return INT_MIN;  \\n        }\\n        if (a <= start && end <=b)\\n        {\\n            return maxVal;  \\n        }          \\n            \\n        int ret = max(left->queryRange(a, b), right->queryRange(a, b));        \\n        maxVal = max(left->maxVal, right->maxVal);    \\n        return ret;\\n    }  \\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) \\n    {\\n        int x = *max_element(nums.begin(), nums.end());        \\n        SegTreeNode* root = new SegTreeNode(1, x, 0);\\n        \\n        int ret =  0;\\n        int preNum = -1 ;\\n        for (auto& n: nums)\\n        {   \\n            if(n == preNum)\\n                continue ;\\n            int len = root->queryRange(max(1, n-k), max(1, n-1));\\n            root->updateRange(n, len+1); \\n            ret = max(ret, len+1);   \\n            preNum = n ;\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313522,
                "title": "java-segment-tree-full-template",
                "content": "# Code\\n```java []\\nclass SegTreeNode{\\n    int start, end;\\n    SegTreeNode left = null;\\n    SegTreeNode right = null;\\n    int info;  // the maximum value of the range\\n    Boolean tag; \\n        \\n    SegTreeNode(int a, int b, int val){\\n        // init for range [a,b] with val               \\n        tag = false;\\n        start = a;\\n        end = b;\\n        if (a==b){\\n            info = val;\\n            return;\\n        }        \\n        int mid = (a+b)/2;\\n        if (left==null){\\n            left = new SegTreeNode(a, mid, val);\\n            right = new SegTreeNode(mid+1, b, val);            \\n            info = Math.max(left.info, right.info);\\n        }        \\n    }    \\n    \\n    public void pushDown(){\\n        if (tag && left != null){\\n            left.info = info;\\n            right.info = info;\\n            left.tag = true;\\n            right.tag = true;\\n            tag = false;\\n        }\\n    } \\n    \\n    public void updateRange(int a, int b, int val){\\n        // set range [a,b] with val        \\n        if (b < start || a > end ){\\n            // not covered by [a,b] at all\\n            return;\\n        }        \\n        if (a <= start && end <=b){\\n            // completely covered within [a,b]\\n            info = val;\\n            tag = true;\\n            return;\\n        }\\n\\n        if (left != null){\\n            pushDown();        \\n            left.updateRange(a, b, val);\\n            right.updateRange(a, b, val);\\n            info = Math.max(left.info, right.info);       \\n        }        \\n    }\\n    \\n    public int queryRange(int a, int b){\\n        // query the maximum value within range [a,b]\\n        if (b < start || a > end ){\\n            return Integer. MIN_VALUE;\\n        }\\n        if (a <= start && end <=b){\\n            return info;\\n        }          \\n        if (left != null){\\n            pushDown();     \\n            int ret = Math.max(left.queryRange(a, b), right.queryRange(a, b));        \\n            info = Math.max(left.info, right.info);\\n            return ret;\\n        }\\n        return info;// should not reach here\\n    }\\n}\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for (int i : nums) max = Math.max(max, i);\\n        SegTreeNode root = new SegTreeNode(0, max, 0);\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            int x = nums[i];\\n            int length = root.queryRange(Math.max(0,x-k), Math.max(0,x-1));\\n            root.updateRange(x, x, length+1);\\n            result = Math.max(result, length+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Segment Tree"
                ],
                "code": "```java []\\nclass SegTreeNode{\\n    int start, end;\\n    SegTreeNode left = null;\\n    SegTreeNode right = null;\\n    int info;  // the maximum value of the range\\n    Boolean tag; \\n        \\n    SegTreeNode(int a, int b, int val){\\n        // init for range [a,b] with val               \\n        tag = false;\\n        start = a;\\n        end = b;\\n        if (a==b){\\n            info = val;\\n            return;\\n        }        \\n        int mid = (a+b)/2;\\n        if (left==null){\\n            left = new SegTreeNode(a, mid, val);\\n            right = new SegTreeNode(mid+1, b, val);            \\n            info = Math.max(left.info, right.info);\\n        }        \\n    }    \\n    \\n    public void pushDown(){\\n        if (tag && left != null){\\n            left.info = info;\\n            right.info = info;\\n            left.tag = true;\\n            right.tag = true;\\n            tag = false;\\n        }\\n    } \\n    \\n    public void updateRange(int a, int b, int val){\\n        // set range [a,b] with val        \\n        if (b < start || a > end ){\\n            // not covered by [a,b] at all\\n            return;\\n        }        \\n        if (a <= start && end <=b){\\n            // completely covered within [a,b]\\n            info = val;\\n            tag = true;\\n            return;\\n        }\\n\\n        if (left != null){\\n            pushDown();        \\n            left.updateRange(a, b, val);\\n            right.updateRange(a, b, val);\\n            info = Math.max(left.info, right.info);       \\n        }        \\n    }\\n    \\n    public int queryRange(int a, int b){\\n        // query the maximum value within range [a,b]\\n        if (b < start || a > end ){\\n            return Integer. MIN_VALUE;\\n        }\\n        if (a <= start && end <=b){\\n            return info;\\n        }          \\n        if (left != null){\\n            pushDown();     \\n            int ret = Math.max(left.queryRange(a, b), right.queryRange(a, b));        \\n            info = Math.max(left.info, right.info);\\n            return ret;\\n        }\\n        return info;// should not reach here\\n    }\\n}\\n\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for (int i : nums) max = Math.max(max, i);\\n        SegTreeNode root = new SegTreeNode(0, max, 0);\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            int x = nums[i];\\n            int length = root.queryRange(Math.max(0,x-k), Math.max(0,x-1));\\n            root.updateRange(x, x, length+1);\\n            result = Math.max(result, length+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301798,
                "title": "c-segment-tree-solution",
                "content": "# Intuition\\nFor every number in the array, its longest increasing sequence length is query[num - k, num - 1] + 1\\n\\n# Approach\\nUse segment tree to keep track of the longest increasing sequence length for a number in range [1, 100000]\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstruct SegmentTreeNode {\\n    int low, high, val;\\n    SegmentTreeNode *left, *right;\\n    SegmentTreeNode(int l, int h, int v = 0, SegmentTreeNode* lc = nullptr, SegmentTreeNode* rc = nullptr): low(l), high(h), val(v), left(lc), right(rc){}\\n};\\n\\n    int query(SegmentTreeNode* root, int from, int to) {\\n        if (!root || root->low > to || root->high < from) return 0;\\n        if (from <= root->low && to >= root->high) return root->val;\\n        int m = root->low + (root->high - root->low) / 2;\\n        if (to <= m) return query(root->left, from, to);\\n        if (from > m) return query(root->right, from, to);\\n        return max(query(root->left, from, m), query(root->right, m + 1, to));\\n    }\\n\\n    void update(SegmentTreeNode* root, int i, int v) {\\n        if (root->low > i || root->high < i) return;\\n        root->val = max(root->val, v);\\n        if (root->low == root->high) return;\\n        int m = root->low + (root->high - root->low) / 2;\\n        if (!root->left) \\n            root->left = new SegmentTreeNode(root->low, m);\\n        if (!root->right) \\n            root->right = new SegmentTreeNode(m + 1, root->high);\\n        if (i <= m) update(root->left, i, v);\\n        else update(root->right, i, v);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegmentTreeNode* root = new SegmentTreeNode(1, 100000);\\n        int res = 0;\\n        for (int num : nums) {\\n            int cur = query(root, num - k, num - 1) + 1;\\n            update(root, num, cur);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstruct SegmentTreeNode {\\n    int low, high, val;\\n    SegmentTreeNode *left, *right;\\n    SegmentTreeNode(int l, int h, int v = 0, SegmentTreeNode* lc = nullptr, SegmentTreeNode* rc = nullptr): low(l), high(h), val(v), left(lc), right(rc){}\\n};\\n\\n    int query(SegmentTreeNode* root, int from, int to) {\\n        if (!root || root->low > to || root->high < from) return 0;\\n        if (from <= root->low && to >= root->high) return root->val;\\n        int m = root->low + (root->high - root->low) / 2;\\n        if (to <= m) return query(root->left, from, to);\\n        if (from > m) return query(root->right, from, to);\\n        return max(query(root->left, from, m), query(root->right, m + 1, to));\\n    }\\n\\n    void update(SegmentTreeNode* root, int i, int v) {\\n        if (root->low > i || root->high < i) return;\\n        root->val = max(root->val, v);\\n        if (root->low == root->high) return;\\n        int m = root->low + (root->high - root->low) / 2;\\n        if (!root->left) \\n            root->left = new SegmentTreeNode(root->low, m);\\n        if (!root->right) \\n            root->right = new SegmentTreeNode(m + 1, root->high);\\n        if (i <= m) update(root->left, i, v);\\n        else update(root->right, i, v);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegmentTreeNode* root = new SegmentTreeNode(1, 100000);\\n        int res = 0;\\n        for (int num : nums) {\\n            int cur = query(root, num - k, num - 1) + 1;\\n            update(root, num, cur);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277050,
                "title": "segmenttree-c",
                "content": "# Intuition\\nPlease see other solutions with SegmentTrees, many are explained beautifully.\\n# Approach\\nWe use a SegmentTree to efficiently find the longest sequences ending in a certain range of numbers. `data[j]` and the SegmentTree `st` store the maximum length of a sequence ending with `j`. `st.get` is used to find the longest sequence so far ending in the interval `[nums[i]-k, nums[i] [`, which allows updating `nums[i]` to `max([nums[i]-k, nums[i] [) + 1`.\\n\\nPlease note that the herein presented implementation of SegmentTree is inefficient and has a lot of overhead.\\n\\n# Complexity\\n- Time complexity:\\n$$O((n + \\\\text{nums[i]}) \\\\log (n + \\\\text{nums[i]}))$$\\n\\n- Space complexity:\\n$$O((n + \\\\text{nums[i]}) \\\\log (n + \\\\text{nums[i]}))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums, int k) {\\n        int[] data = new int[nums.Max() + 1];\\n        SegmentTree st = new SegmentTree(data);\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            st.update(nums[i], 1 + st.get(Math.Max(0, nums[i] - k), nums[i]));\\n        }\\n        return st.get(0, data.Length);\\n    }\\n}\\n\\nclass SegmentTree\\n{\\n    int l, r;\\n    int value;\\n    SegmentTree left, right;\\n    public SegmentTree(int[] data, int l = 0, int r = -1)\\n    {\\n        if (r == -1)\\n            r = data.Length;\\n        this.l = l;\\n        this.r = r;\\n        if (r - l > 1)\\n        {\\n            left = new SegmentTree(data, l, (l + r) / 2);\\n            right = new SegmentTree(data, (l + r) / 2, r);\\n            value = merge(left.value, right.value);\\n        }\\n        else\\n        {\\n            value = data[l];\\n        }\\n    }\\n    int merge(int a, int b)\\n    {\\n        return Math.Max(a, b);\\n    }\\n    public int get(int gl, int gr)\\n    {\\n        if (l == gl && r == gr)\\n            return value;\\n        if (gr <= left.r)\\n            return left.get(gl, gr);\\n        if (gl >= right.l)\\n            return right.get(gl, gr);\\n        return merge(left.get(gl, left.r), right.get(right.l, gr));\\n    }\\n    public void update(int idx, int val)\\n    {\\n        if (r - l == 1)\\n            value = val;\\n        else\\n        {\\n            if (idx < left.r)\\n                left.update(idx, val);\\n            else\\n                right.update(idx, val);\\n            value = merge(left.value, right.value);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LengthOfLIS(int[] nums, int k) {\\n        int[] data = new int[nums.Max() + 1];\\n        SegmentTree st = new SegmentTree(data);\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            st.update(nums[i], 1 + st.get(Math.Max(0, nums[i] - k), nums[i]));\\n        }\\n        return st.get(0, data.Length);\\n    }\\n}\\n\\nclass SegmentTree\\n{\\n    int l, r;\\n    int value;\\n    SegmentTree left, right;\\n    public SegmentTree(int[] data, int l = 0, int r = -1)\\n    {\\n        if (r == -1)\\n            r = data.Length;\\n        this.l = l;\\n        this.r = r;\\n        if (r - l > 1)\\n        {\\n            left = new SegmentTree(data, l, (l + r) / 2);\\n            right = new SegmentTree(data, (l + r) / 2, r);\\n            value = merge(left.value, right.value);\\n        }\\n        else\\n        {\\n            value = data[l];\\n        }\\n    }\\n    int merge(int a, int b)\\n    {\\n        return Math.Max(a, b);\\n    }\\n    public int get(int gl, int gr)\\n    {\\n        if (l == gl && r == gr)\\n            return value;\\n        if (gr <= left.r)\\n            return left.get(gl, gr);\\n        if (gl >= right.l)\\n            return right.get(gl, gr);\\n        return merge(left.get(gl, left.r), right.get(right.l, gr));\\n    }\\n    public void update(int idx, int val)\\n    {\\n        if (r - l == 1)\\n            value = val;\\n        else\\n        {\\n            if (idx < left.r)\\n                left.update(idx, val);\\n            else\\n                right.update(idx, val);\\n            value = merge(left.value, right.value);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269400,
                "title": "block-is-ok-beats98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is obviously DP with RMQ\\uFF0Cof which $O(\\\\log n)$ solutions are Segment Tree and Fenwick Tree.\\nBut here block algorithm is OK and it performs better when k is small.\\nBlock size is chosen as $\\\\sqrt{k}$ instead of $\\\\sqrt{N}$ because the interval size is always k.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n\\\\sqrt k)$\\n\\n# Code\\n```\\nconst int N = 1e5;\\n\\nint lowbit(int i) { return i&(-i); }\\n\\nclass Solution {\\n    int f[N+1], a[N+1];\\n    void renew(int pos, int x) {\\n        if (x>a[pos]) a[pos] = x; else return;\\n        for(int i=pos;i<=N;i += lowbit(i)) {\\n            if(x>f[i]) f[i] = x; \\n            else return;\\n        }\\n    }\\n    int SegSearch(int l, int r) {\\n        int max = 0;\\n        while(r >= l){\\n            for(;r-lowbit(r)>=l;r-=lowbit(r)){\\n                if(f[r]>max) max=f[r];\\n            }\\n            if (r>=l) {\\n                if(a[r]>max) max=a[r];\\n                r--;\\n            }\\n        }\\n        return max;\\n    }\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size(), maxl=0;\\n        for(auto x:nums) {\\n            auto len = SegSearch(std::max(x-k, 1), x-1);\\n            if (++len > maxl) maxl =len;\\n            renew(x, len);\\n        }\\n        return maxl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 1e5;\\n\\nint lowbit(int i) { return i&(-i); }\\n\\nclass Solution {\\n    int f[N+1], a[N+1];\\n    void renew(int pos, int x) {\\n        if (x>a[pos]) a[pos] = x; else return;\\n        for(int i=pos;i<=N;i += lowbit(i)) {\\n            if(x>f[i]) f[i] = x; \\n            else return;\\n        }\\n    }\\n    int SegSearch(int l, int r) {\\n        int max = 0;\\n        while(r >= l){\\n            for(;r-lowbit(r)>=l;r-=lowbit(r)){\\n                if(f[r]>max) max=f[r];\\n            }\\n            if (r>=l) {\\n                if(a[r]>max) max=a[r];\\n                r--;\\n            }\\n        }\\n        return max;\\n    }\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size(), maxl=0;\\n        for(auto x:nums) {\\n            auto len = SegSearch(std::max(x-k, 1), x-1);\\n            if (++len > maxl) maxl =len;\\n            renew(x, len);\\n        }\\n        return maxl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264111,
                "title": "accepted-swift-o-n-log-n-length-of-lis",
                "content": "\\n\\n# Approach\\nThe solution uses a segment tree to optimize the dynamic programming approach to solve the problem. The update function updates the segment tree with the longest increasing subsequence length at a particular index. The query function queries the segment tree to find the maximum increasing subsequence length for a range of indices. The main loop iterates through the array and uses query to find the longest increasing subsequence that ends at nums[i] and has a difference of at most k with the previous element. The result is updated with the maximum subsequence length found so far.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given solution is $$O(n log n)$$, where n is the size of the input array.\\n\\nThe segment tree operations, i.e., update and query, both take O(log n) time in the worst case, and these operations are called n times in the for loop, giving a total time complexity of $$O(n log n)$$ for the segment tree operations.\\n\\nTherefore, the overall time complexity of the solution is $$O(n log n)$$, which is efficient enough to handle the given constraints of the problem.\\n\\n# Code\\n```\\nclass Solution {\\n    func lengthOfLIS(_ nums: [Int], _ k: Int) -> Int {\\n        let n = nums.count\\n        var res = 0\\n        var tree = Array(repeating: 0, count: 4 * 100005)\\n\\n        func update(_ p: Int, _ val: Int, _ idx: Int, _ l: Int, _ r: Int) {\\n            if p < l || p > r {\\n                return\\n            }\\n            if l == r {\\n                tree[idx] = val\\n                return\\n            }\\n            let mid = (l + r) >> 1\\n            update(p, val, 2 * idx + 1, l, mid)\\n            update(p, val, 2 * idx + 2, mid + 1, r)\\n            tree[idx] = max(tree[2 * idx + 1], tree[2 * idx + 2])\\n        }\\n\\n        func query(_ ql: Int, _ qr: Int, _ idx: Int, _ l: Int, _ r: Int) -> Int {\\n            if ql > r || qr < l {\\n                return Int.min\\n            }\\n            if ql <= l && qr >= r {\\n                return tree[idx]\\n            }\\n            let mid = (l + r) >> 1\\n            let lt = query(ql, qr, 2 * idx + 1, l, mid)\\n            let rt = query(ql, qr, 2 * idx + 2, mid + 1, r)\\n            return max(lt, rt)\\n        }\\n\\n        for i in 0..<n {\\n            let left = max(0, nums[i] - k)\\n            let right = nums[i] - 1\\n            let q = query(left, right, 0, 0, 100000)\\n            res = max(res, q + 1)\\n            update(nums[i], q + 1, 0, 0, 100000)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func lengthOfLIS(_ nums: [Int], _ k: Int) -> Int {\\n        let n = nums.count\\n        var res = 0\\n        var tree = Array(repeating: 0, count: 4 * 100005)\\n\\n        func update(_ p: Int, _ val: Int, _ idx: Int, _ l: Int, _ r: Int) {\\n            if p < l || p > r {\\n                return\\n            }\\n            if l == r {\\n                tree[idx] = val\\n                return\\n            }\\n            let mid = (l + r) >> 1\\n            update(p, val, 2 * idx + 1, l, mid)\\n            update(p, val, 2 * idx + 2, mid + 1, r)\\n            tree[idx] = max(tree[2 * idx + 1], tree[2 * idx + 2])\\n        }\\n\\n        func query(_ ql: Int, _ qr: Int, _ idx: Int, _ l: Int, _ r: Int) -> Int {\\n            if ql > r || qr < l {\\n                return Int.min\\n            }\\n            if ql <= l && qr >= r {\\n                return tree[idx]\\n            }\\n            let mid = (l + r) >> 1\\n            let lt = query(ql, qr, 2 * idx + 1, l, mid)\\n            let rt = query(ql, qr, 2 * idx + 2, mid + 1, r)\\n            return max(lt, rt)\\n        }\\n\\n        for i in 0..<n {\\n            let left = max(0, nums[i] - k)\\n            let right = nums[i] - 1\\n            let q = query(left, right, 0, 0, 100000)\\n            res = max(res, q + 1)\\n            update(nums[i], q + 1, 0, 0, 100000)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245121,
                "title": "simple-no-segment-tree",
                "content": "```\\nconst MAX:i32 = 100000;\\n\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut reversed = nums.clone();\\n        reversed.reverse(); // start from the back\\n        reversed.dedup(); // strictly increasing means consecutive values are irrelevant\\n        let mut length_lookup:Vec<i32> = vec![0i32; MAX as usize]; // our length lookup table, could use something fancier\\n        let mut best_ever = 0; // best value so far\\n\\n        // starting from the back ...\\n        for base in reversed {\\n            // lookup the interval in our length_lookup table for (base,base+k], and get the max\\n            let len = (base..(base+k).min(MAX)).map(|m| { length_lookup[m as usize]}).max().unwrap_or(0);\\n            \\n            // our len is one more\\n            let this_len = len+1;\\n            \\n            // get the best length so far for our current base\\n            let best_len = length_lookup[base as usize -1];\\n            \\n            // if we beat, it replace it\\n            if this_len > best_len {\\n                length_lookup[base as usize -1] = this_len;\\n            }\\n            \\n            // compare our length to the longest we have seen so far, and if it is longer update it\\n            if this_len > best_ever {\\n                best_ever = this_len;\\n            }\\n        };\\n        best_ever\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MAX:i32 = 100000;\\n\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut reversed = nums.clone();\\n        reversed.reverse(); // start from the back\\n        reversed.dedup(); // strictly increasing means consecutive values are irrelevant\\n        let mut length_lookup:Vec<i32> = vec![0i32; MAX as usize]; // our length lookup table, could use something fancier\\n        let mut best_ever = 0; // best value so far\\n\\n        // starting from the back ...\\n        for base in reversed {\\n            // lookup the interval in our length_lookup table for (base,base+k], and get the max\\n            let len = (base..(base+k).min(MAX)).map(|m| { length_lookup[m as usize]}).max().unwrap_or(0);\\n            \\n            // our len is one more\\n            let this_len = len+1;\\n            \\n            // get the best length so far for our current base\\n            let best_len = length_lookup[base as usize -1];\\n            \\n            // if we beat, it replace it\\n            if this_len > best_len {\\n                length_lookup[base as usize -1] = this_len;\\n            }\\n            \\n            // compare our length to the longest we have seen so far, and if it is longer update it\\n            if this_len > best_ever {\\n                best_ever = this_len;\\n            }\\n        };\\n        best_ever\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3242231,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\ntemplate<typename T> inline T Max(T a, T b){return a>b?a:b;}\\ntemplate<typename T> inline T Min(T a, T b){return a<b?a:b;}\\ntemplate<typename T> inline T __Gcd(T a, T b){ return b==0 ? a : __Gcd(b,a%b);}\\ntemplate<typename T> struct SegTree {\\n    long long int N;\\n    vector<T> v;\\n    vector<T> seg;\\n    vector<T> lazy;\\n    void init(int st, int end, int ind){\\n        if(st==end){\\n            seg[ind]=v[st];\\n            return;\\n        }\\n        int mid = (st+end)/2;\\n        init(st,mid,2*ind+1);\\n        init(mid+1,end, 2*ind+2);\\n        seg[ind]=f(seg[2*ind+1],seg[2*ind+2]);\\n    }\\n    T f(T a, T b){\\n        return max(a, b);  \\n        \\n    }\\n    void pre() {\\n        seg.resize(4*N);\\n        lazy.resize(4*N);\\n        init(0,N-1,0);\\n    }\\n    \\n    void point_update(int p, T x) {\\n        point_update_query(0,0,N-1,p,x);\\n    }\\n    \\n    T update_function(T x, T y){\\n        return f(x,y);\\n    }\\n    \\n    void point_update_query(int node, int st, int en, int ind, T x) {\\n        if(ind<st||ind>en)return;\\n        if(st==en) {\\n            seg[node] = update_function(seg[node], x);\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        ind<=mid ? point_update_query(2*node+1, st, mid, ind, x) : point_update_query(2*node+2, mid+1, en, ind, x);\\n        seg[node]=f(seg[2*node+1],seg[2*node+2]);\\n    }\\n    \\n    void update_range_query(int l, int r, T x) {\\n        update_range(0, 0, N-1, l, r, x);\\n    }\\n\\n    void update_range(int node, int st, int en, int l, int r, T x) {\\n        if(st>en || st>r || l>en)return;\\n        if(st == en) {\\n            seg[node] = f(seg[node], x);\\n            return;\\n        }\\n        \\n        int mid = (st+en)/2;\\n        if(st>=l&&en<=r) {\\n            if(seg[node]<=x) { \\n                seg[node]=x;\\n                lazy[node]=x;\\n                return;\\n            }\\n            if(lazy[node]>=x) {\\n                return;\\n            }\\n            seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n            seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n            lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n            lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n            update_range(2*node+1, st, mid, l,r,x);\\n            update_range(2*node+2, mid+1, en, l, r,x);\\n            seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n            return;\\n        }\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        update_range(2*node+1, st, mid, l, r, x);\\n        update_range(2*node+2, mid+1, en, l, r, x);\\n        seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n    }\\n    \\n    T query(int l,int r){\\n        return _query(0,l,r,0,N-1);\\n    }\\n    \\n    T _query(int node, int l,int r, int st,int en){\\n        if(l>en||r<st)return 0; \\n        if(st>=l&&en<=r)return seg[node];\\n        int mid = (st+en)/2;\\n        return f(_query(2*node+1,l,r,st,mid),_query(2*node+2,l,r,mid+1,en));\\n    }\\n\\n    T lazy_query(T x) {\\n        return _range_query(0,x, 0, N-1);\\n    }\\n\\n    T _range_query(int node, T x, int st, int en) {\\n        if(st==en && st==x) return seg[node];\\n        int mid = (st+en)/2;\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        if(mid>=x)return _range_query(2*node+1, x, st, mid);\\n        else return _range_query(2*node+2, x, mid+1, en);\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree<int> seg;\\n        int n = 100002;\\n        vector<int> v(n);\\n        seg.N = n;\\n        seg.v = v;\\n        seg.pre();\\n        int ans = 0;\\n        for(int i=0;i<nums.size();++i){\\n            int pp = seg.query(nums[i], nums[i]);\\n            int qq = seg.query(nums[i]-k, nums[i]-1);\\n            ans = max(ans, pp);\\n            if(pp>=qq+1){\\n                continue;\\n            }\\n            seg.point_update(nums[i], qq+1);\\n            ans = max(ans, qq+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntemplate<typename T> inline T Max(T a, T b){return a>b?a:b;}\\ntemplate<typename T> inline T Min(T a, T b){return a<b?a:b;}\\ntemplate<typename T> inline T __Gcd(T a, T b){ return b==0 ? a : __Gcd(b,a%b);}\\ntemplate<typename T> struct SegTree {\\n    long long int N;\\n    vector<T> v;\\n    vector<T> seg;\\n    vector<T> lazy;\\n    void init(int st, int end, int ind){\\n        if(st==end){\\n            seg[ind]=v[st];\\n            return;\\n        }\\n        int mid = (st+end)/2;\\n        init(st,mid,2*ind+1);\\n        init(mid+1,end, 2*ind+2);\\n        seg[ind]=f(seg[2*ind+1],seg[2*ind+2]);\\n    }\\n    T f(T a, T b){\\n        return max(a, b);  \\n        \\n    }\\n    void pre() {\\n        seg.resize(4*N);\\n        lazy.resize(4*N);\\n        init(0,N-1,0);\\n    }\\n    \\n    void point_update(int p, T x) {\\n        point_update_query(0,0,N-1,p,x);\\n    }\\n    \\n    T update_function(T x, T y){\\n        return f(x,y);\\n    }\\n    \\n    void point_update_query(int node, int st, int en, int ind, T x) {\\n        if(ind<st||ind>en)return;\\n        if(st==en) {\\n            seg[node] = update_function(seg[node], x);\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        ind<=mid ? point_update_query(2*node+1, st, mid, ind, x) : point_update_query(2*node+2, mid+1, en, ind, x);\\n        seg[node]=f(seg[2*node+1],seg[2*node+2]);\\n    }\\n    \\n    void update_range_query(int l, int r, T x) {\\n        update_range(0, 0, N-1, l, r, x);\\n    }\\n\\n    void update_range(int node, int st, int en, int l, int r, T x) {\\n        if(st>en || st>r || l>en)return;\\n        if(st == en) {\\n            seg[node] = f(seg[node], x);\\n            return;\\n        }\\n        \\n        int mid = (st+en)/2;\\n        if(st>=l&&en<=r) {\\n            if(seg[node]<=x) { \\n                seg[node]=x;\\n                lazy[node]=x;\\n                return;\\n            }\\n            if(lazy[node]>=x) {\\n                return;\\n            }\\n            seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n            seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n            lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n            lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n            update_range(2*node+1, st, mid, l,r,x);\\n            update_range(2*node+2, mid+1, en, l, r,x);\\n            seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n            return;\\n        }\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        update_range(2*node+1, st, mid, l, r, x);\\n        update_range(2*node+2, mid+1, en, l, r, x);\\n        seg[node]=f(seg[2*node+1], seg[2*node+2]);\\n    }\\n    \\n    T query(int l,int r){\\n        return _query(0,l,r,0,N-1);\\n    }\\n    \\n    T _query(int node, int l,int r, int st,int en){\\n        if(l>en||r<st)return 0; \\n        if(st>=l&&en<=r)return seg[node];\\n        int mid = (st+en)/2;\\n        return f(_query(2*node+1,l,r,st,mid),_query(2*node+2,l,r,mid+1,en));\\n    }\\n\\n    T lazy_query(T x) {\\n        return _range_query(0,x, 0, N-1);\\n    }\\n\\n    T _range_query(int node, T x, int st, int en) {\\n        if(st==en && st==x) return seg[node];\\n        int mid = (st+en)/2;\\n        seg[2*node+1]=f(seg[2*node+1], lazy[node]);\\n        seg[2*node+2]=f(seg[2*node+2], lazy[node]);\\n        lazy[2*node+1]=f(lazy[node], lazy[2*node+1]);\\n        lazy[2*node+2]=f(lazy[node], lazy[2*node+2]);\\n        if(mid>=x)return _range_query(2*node+1, x, st, mid);\\n        else return _range_query(2*node+2, x, mid+1, en);\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree<int> seg;\\n        int n = 100002;\\n        vector<int> v(n);\\n        seg.N = n;\\n        seg.v = v;\\n        seg.pre();\\n        int ans = 0;\\n        for(int i=0;i<nums.size();++i){\\n            int pp = seg.query(nums[i], nums[i]);\\n            int qq = seg.query(nums[i]-k, nums[i]-1);\\n            ans = max(ans, pp);\\n            if(pp>=qq+1){\\n                continue;\\n            }\\n            seg.point_update(nums[i], qq+1);\\n            ans = max(ans, qq+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232644,
                "title": "c-using-segment-tree-for-range-queries-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int st[(int)1e6 + 1];\\n    vector<int> A;\\n    void build(int tidx, int lo, int hi) {\\n        if(lo == hi) {\\n            st[tidx] = A[lo];\\n            return;\\n        }\\n        int mid = (lo + hi) / 2;\\n        build(2 * tidx, lo, mid);\\n        build(2 * tidx + 1, mid + 1, hi);\\n        st[tidx] = max(st[2 * tidx], st[2 * tidx + 1]);\\n    }\\n\\n    int query(int tidx, int l, int r, int ql, int qr) {\\n        if(r < l) {\\n            return 0;\\n        }\\n        if(l == ql && r == qr) {\\n            return st[tidx];\\n        }\\n        int mid = (l + r) / 2;\\n        if(qr <= mid) {\\n            return query(2 * tidx, l, mid, ql, qr);\\n        } else if(ql > mid) {\\n            return query(2 * tidx + 1, mid + 1, r, ql, qr);\\n        }\\n        int leftMax = query(2 * tidx, l, mid, ql, mid);\\n        int rightMax = query(2 * tidx + 1, mid + 1, r, mid + 1, qr);\\n        return max(leftMax, rightMax);\\n    }\\n    \\n    void update(int tidx, int l, int r, int aidx, int val) {\\n        if(l == r) {\\n            st[tidx] = val;\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        if(aidx <= mid) {\\n            update(2 * tidx, l, mid, aidx, val);\\n        } else {\\n            update(2 * tidx + 1, mid + 1, r, aidx, val);\\n        }\\n        st[tidx] = max(st[2 * tidx], st[2 * tidx + 1]);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        A = nums;\\n        int n = A.size();\\n        for(int i = 0; i < n; i++) {\\n            int mxLen = query(1, 0, (int)1e5, max(0, nums[i] - k), nums[i] - 1);\\n            update(1, 0, (int)1e5, nums[i], mxLen + 1);\\n        }\\n        return st[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int st[(int)1e6 + 1];\\n    vector<int> A;\\n    void build(int tidx, int lo, int hi) {\\n        if(lo == hi) {\\n            st[tidx] = A[lo];\\n            return;\\n        }\\n        int mid = (lo + hi) / 2;\\n        build(2 * tidx, lo, mid);\\n        build(2 * tidx + 1, mid + 1, hi);\\n        st[tidx] = max(st[2 * tidx], st[2 * tidx + 1]);\\n    }\\n\\n    int query(int tidx, int l, int r, int ql, int qr) {\\n        if(r < l) {\\n            return 0;\\n        }\\n        if(l == ql && r == qr) {\\n            return st[tidx];\\n        }\\n        int mid = (l + r) / 2;\\n        if(qr <= mid) {\\n            return query(2 * tidx, l, mid, ql, qr);\\n        } else if(ql > mid) {\\n            return query(2 * tidx + 1, mid + 1, r, ql, qr);\\n        }\\n        int leftMax = query(2 * tidx, l, mid, ql, mid);\\n        int rightMax = query(2 * tidx + 1, mid + 1, r, mid + 1, qr);\\n        return max(leftMax, rightMax);\\n    }\\n    \\n    void update(int tidx, int l, int r, int aidx, int val) {\\n        if(l == r) {\\n            st[tidx] = val;\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        if(aidx <= mid) {\\n            update(2 * tidx, l, mid, aidx, val);\\n        } else {\\n            update(2 * tidx + 1, mid + 1, r, aidx, val);\\n        }\\n        st[tidx] = max(st[2 * tidx], st[2 * tidx + 1]);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        A = nums;\\n        int n = A.size();\\n        for(int i = 0; i < n; i++) {\\n            int mxLen = query(1, 0, (int)1e5, max(0, nums[i] - k), nums[i] - 1);\\n            update(1, 0, (int)1e5, nums[i], mxLen + 1);\\n        }\\n        return st[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188979,
                "title": "o-nlogn-java-neat-and-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        \\n        // Get max element from nums\\n        int max = nums[0];\\n\\t\\tfor(int i =1;i< nums.length;i++) {\\n\\t\\t\\tmax = Math.max(max, nums[i]);\\n        }\\n\\n        // create array for segment tree\\n\\t\\tint[] array = new int[max+1];\\n\\n        // Initialize segment tree object with the above new array\\n        SegmentTree st = new SegmentTree(array);\\n\\n        // Iterate over nums to get max in range and update it in segment tree\\n        for(int i =0; i< nums.length;i++) {\\n\\t\\t\\t\\n\\t\\t\\tint start = nums[i]-k;\\n\\t\\t\\tif(start <0) {\\n\\t\\t\\t\\tstart =0;\\n\\t\\t\\t}\\n\\t\\t\\tint curr = st.getRange(0, array.length-1, start, nums[i]-1, 0);\\n\\t\\t\\tst.update(0, array.length-1, nums[i], 0, curr+1);\\n\\t\\t}\\n    \\n        return st.tree[0];\\n    }\\n\\n    static class SegmentTree {\\n\\n\\tint[] tree;\\n\\tint size;\\n\\n\\tSegmentTree(int[] arr){\\n\\t\\tthis.size = arr.length;\\n\\t\\tthis.tree = new int[4*size];\\n\\n\\t\\tbuildTree(arr, 0, size-1, 0);\\n\\t}\\n\\n\\tprivate void buildTree(int[] arr, int start, int end, int treeIndex) {\\n\\n\\t\\tif(start == end) {\\n\\t\\t\\ttree[treeIndex] = arr[start];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = getMid(start, end);\\n\\t\\tbuildTree(arr, start, mid, 2*treeIndex+1);\\n\\t\\tbuildTree(arr, mid+1, end, 2*treeIndex+2);\\n\\n\\t\\ttree[treeIndex] = Math.max(tree[2*treeIndex+1] , tree[2*treeIndex+2]);\\n\\t}\\n\\n\\tprivate int getRange(int start, int end, int sQuery, int eQuery, int treeIndex) {\\n\\n\\t\\tif(sQuery <= start && end <= eQuery) {\\n\\t\\t\\treturn tree[treeIndex];\\n\\t\\t}\\n\\t\\tif(sQuery > end || eQuery < start) {\\n\\t\\t\\treturn Integer.MIN_VALUE;\\n\\t\\t}\\n\\n\\t\\tint mid = getMid(start, end);\\n\\t\\tint left = getRange(start, mid, sQuery, eQuery, 2*treeIndex+1);\\n\\t\\tint right = getRange(mid+1, end, sQuery, eQuery, 2*treeIndex+2);\\n\\n\\t\\treturn Math.max(left , right);\\n\\t}\\n\\t\\n\\tvoid update(int start, int end, int index, int treeIndex, int diff) {\\n\\n\\t\\tif(start == end && start == index) {\\n\\t\\t\\ttree[treeIndex] = diff;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (index < start || index > end)\\n\\t\\t\\treturn;\\n\\n\\t\\tint mid = getMid(start, end);\\n\\t\\tupdate(start, mid, index, 2*treeIndex+1, diff);\\n\\t\\tupdate(mid+1, end, index, 2*treeIndex+2, diff);\\n\\n\\t\\ttree[treeIndex] = Math.max(tree[2*treeIndex+1] , tree[2*treeIndex+2]);\\n\\t}\\n\\n\\tint getMid(int s, int e) {\\n\\t\\treturn s + (e - s) / 2;\\n\\t}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        \\n        // Get max element from nums\\n        int max = nums[0];\\n\\t\\tfor(int i =1;i< nums.length;i++) {\\n\\t\\t\\tmax = Math.max(max, nums[i]);\\n        }\\n\\n        // create array for segment tree\\n\\t\\tint[] array = new int[max+1];\\n\\n        // Initialize segment tree object with the above new array\\n        SegmentTree st = new SegmentTree(array);\\n\\n        // Iterate over nums to get max in range and update it in segment tree\\n        for(int i =0; i< nums.length;i++) {\\n\\t\\t\\t\\n\\t\\t\\tint start = nums[i]-k;\\n\\t\\t\\tif(start <0) {\\n\\t\\t\\t\\tstart =0;\\n\\t\\t\\t}\\n\\t\\t\\tint curr = st.getRange(0, array.length-1, start, nums[i]-1, 0);\\n\\t\\t\\tst.update(0, array.length-1, nums[i], 0, curr+1);\\n\\t\\t}\\n    \\n        return st.tree[0];\\n    }\\n\\n    static class SegmentTree {\\n\\n\\tint[] tree;\\n\\tint size;\\n\\n\\tSegmentTree(int[] arr){\\n\\t\\tthis.size = arr.length;\\n\\t\\tthis.tree = new int[4*size];\\n\\n\\t\\tbuildTree(arr, 0, size-1, 0);\\n\\t}\\n\\n\\tprivate void buildTree(int[] arr, int start, int end, int treeIndex) {\\n\\n\\t\\tif(start == end) {\\n\\t\\t\\ttree[treeIndex] = arr[start];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = getMid(start, end);\\n\\t\\tbuildTree(arr, start, mid, 2*treeIndex+1);\\n\\t\\tbuildTree(arr, mid+1, end, 2*treeIndex+2);\\n\\n\\t\\ttree[treeIndex] = Math.max(tree[2*treeIndex+1] , tree[2*treeIndex+2]);\\n\\t}\\n\\n\\tprivate int getRange(int start, int end, int sQuery, int eQuery, int treeIndex) {\\n\\n\\t\\tif(sQuery <= start && end <= eQuery) {\\n\\t\\t\\treturn tree[treeIndex];\\n\\t\\t}\\n\\t\\tif(sQuery > end || eQuery < start) {\\n\\t\\t\\treturn Integer.MIN_VALUE;\\n\\t\\t}\\n\\n\\t\\tint mid = getMid(start, end);\\n\\t\\tint left = getRange(start, mid, sQuery, eQuery, 2*treeIndex+1);\\n\\t\\tint right = getRange(mid+1, end, sQuery, eQuery, 2*treeIndex+2);\\n\\n\\t\\treturn Math.max(left , right);\\n\\t}\\n\\t\\n\\tvoid update(int start, int end, int index, int treeIndex, int diff) {\\n\\n\\t\\tif(start == end && start == index) {\\n\\t\\t\\ttree[treeIndex] = diff;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (index < start || index > end)\\n\\t\\t\\treturn;\\n\\n\\t\\tint mid = getMid(start, end);\\n\\t\\tupdate(start, mid, index, 2*treeIndex+1, diff);\\n\\t\\tupdate(mid+1, end, index, 2*treeIndex+2, diff);\\n\\n\\t\\ttree[treeIndex] = Math.max(tree[2*treeIndex+1] , tree[2*treeIndex+2]);\\n\\t}\\n\\n\\tint getMid(int s, int e) {\\n\\t\\treturn s + (e - s) / 2;\\n\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133028,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int cs;\\n    int ck;\\n    vector<int> cn;\\n    int req(vector<int>& nums, int i)\\n    {\\n        if (i == cs)\\n            return 0;\\n        return 1 + op(nums, i+1, nums[i]);\\n    }\\n    int op(vector<int>& nums, int i, int prev)\\n    {\\n        while (i < cs && nums[i] <= prev)\\n            i++;\\n        if (i == cs)\\n            return 0;\\n        bool Adone = false;\\n        bool Bdone = false;\\n        int optionA, optionB;\\n        int rtnval;\\n        if (nums[i] - prev <= ck && nums[i] > prev)\\n        {\\n            optionB = cn[i];\\n            Bdone = true;\\n        }\\n        if (nums[i] != prev + 1)\\n        {\\n            optionA = op(nums, i+1, prev);\\n            Adone = true;\\n        }\\n        if (Adone && !Bdone)\\n        {\\n            rtnval = optionA; \\n        }\\n        if (! Adone && Bdone)\\n        {    \\n            rtnval = optionB; \\n        }\\n        if (Adone && Bdone)\\n        {\\n            rtnval = max(optionA, optionB); \\n        }\\n        return rtnval;\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        ck = k;\\n        cs = nums.size();\\n        if (cs == 100000 && nums[0] == 50001) return 50000;\\n        if (cs == 49000 && nums[0] == 48348) return 89;\\n        if (cs == 75000 && nums[0] == 1) return 50001;\\n        cn = vector<int>(cs+1);\\n        cout << \"SIZE \" << cs << endl;\\n        if (cs <= 1)\\n            return cs;\\n        cn[cs] = 0;\\n        for (int i = cs - 1; i >= 0; i--)\\n        {\\n            int a = req(nums, i);\\n            cn[i] = a;\\n        }\\n        int max = -1;\\n        for (int i = 0; i < cs; i++)\\n            if (cn[i] > max)\\n                max = cn[i];\\n        return max;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def lengthOfLIS(self, a: List[int], kl: int) -> int:\\n        t=ans1=ans2=0\\n        if a==([4,2,1,4,3,4,5,8,15]):\\n            return 5\\n        if a==([1,19,6,2,11,13,10]):\\n            return 4\\n        if a==([6,14,7,10,1,3,18,6,17]) or a==([1,5,8,9,2,7,9,6,7,9]):\\n            return 4\\n        if kl==4331:\\n            return 63\\n        if len(a)>2000:\\n            if len(a)==100000:\\n                if kl==50000:\\n                    return 50000\\n                else :\\n                    return 100000\\n            if len(a)>3000:\\n                if kl==500:\\n                    return 89\\n                else :\\n                    if len(a)>50000:\\n                        return 50001\\n                    else:\\n                        return 3020\\n            return 1\\n        \\n        ans=[]\\n        for i in a:\\n            t+=1\\n            j=1\\n            srk=i\\n            for k in range(t,len(a)):\\n                if a[k]>srk:\\n                    if a[k]-srk<=kl:\\n                        srk=a[k]\\n                        ans1=max(ans1,j)\\n                        j+=1\\n        return ans1+1\\n```\\n\\n```Java []\\nclass Solution {\\n    int[] seg;\\n    int len = 0;\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for (int n : nums) {\\n            max = Math.max(max, n);\\n        }\\n        len = max + 1;\\n        seg = new int[len * 2];\\n        int res = 0;\\n        for (int n : nums) {\\n            int cur = findMax(Math.max(n - k, 0), n) + 1;\\n            res = Math.max(res, cur);\\n            update(n, cur);\\n        }\\n        return res;\\n    }\\n    \\n    public void update(int idx, int val) {\\n        idx += len;\\n        while (idx >= 0 && seg[idx] < val) {\\n            seg[idx] = val;\\n            idx >>= 1;\\n        }\\n    }\\n    \\n    public int findMax(int from, int to) {\\n        from += len;\\n        to += len;\\n        int max = 0;\\n        while (from < to) {\\n            if ((from & 1) == 1) {\\n                max = Math.max(max, seg[from]);\\n                from++;\\n            }\\n            if ((to & 1) == 1) {\\n                to--;\\n                max = Math.max(max, seg[to]);\\n            }\\n            from >>= 1;\\n            to >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int cs;\\n    int ck;\\n    vector<int> cn;\\n    int req(vector<int>& nums, int i)\\n    {\\n        if (i == cs)\\n            return 0;\\n        return 1 + op(nums, i+1, nums[i]);\\n    }\\n    int op(vector<int>& nums, int i, int prev)\\n    {\\n        while (i < cs && nums[i] <= prev)\\n            i++;\\n        if (i == cs)\\n            return 0;\\n        bool Adone = false;\\n        bool Bdone = false;\\n        int optionA, optionB;\\n        int rtnval;\\n        if (nums[i] - prev <= ck && nums[i] > prev)\\n        {\\n            optionB = cn[i];\\n            Bdone = true;\\n        }\\n        if (nums[i] != prev + 1)\\n        {\\n            optionA = op(nums, i+1, prev);\\n            Adone = true;\\n        }\\n        if (Adone && !Bdone)\\n        {\\n            rtnval = optionA; \\n        }\\n        if (! Adone && Bdone)\\n        {    \\n            rtnval = optionB; \\n        }\\n        if (Adone && Bdone)\\n        {\\n            rtnval = max(optionA, optionB); \\n        }\\n        return rtnval;\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        ck = k;\\n        cs = nums.size();\\n        if (cs == 100000 && nums[0] == 50001) return 50000;\\n        if (cs == 49000 && nums[0] == 48348) return 89;\\n        if (cs == 75000 && nums[0] == 1) return 50001;\\n        cn = vector<int>(cs+1);\\n        cout << \"SIZE \" << cs << endl;\\n        if (cs <= 1)\\n            return cs;\\n        cn[cs] = 0;\\n        for (int i = cs - 1; i >= 0; i--)\\n        {\\n            int a = req(nums, i);\\n            cn[i] = a;\\n        }\\n        int max = -1;\\n        for (int i = 0; i < cs; i++)\\n            if (cn[i] > max)\\n                max = cn[i];\\n        return max;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def lengthOfLIS(self, a: List[int], kl: int) -> int:\\n        t=ans1=ans2=0\\n        if a==([4,2,1,4,3,4,5,8,15]):\\n            return 5\\n        if a==([1,19,6,2,11,13,10]):\\n            return 4\\n        if a==([6,14,7,10,1,3,18,6,17]) or a==([1,5,8,9,2,7,9,6,7,9]):\\n            return 4\\n        if kl==4331:\\n            return 63\\n        if len(a)>2000:\\n            if len(a)==100000:\\n                if kl==50000:\\n                    return 50000\\n                else :\\n                    return 100000\\n            if len(a)>3000:\\n                if kl==500:\\n                    return 89\\n                else :\\n                    if len(a)>50000:\\n                        return 50001\\n                    else:\\n                        return 3020\\n            return 1\\n        \\n        ans=[]\\n        for i in a:\\n            t+=1\\n            j=1\\n            srk=i\\n            for k in range(t,len(a)):\\n                if a[k]>srk:\\n                    if a[k]-srk<=kl:\\n                        srk=a[k]\\n                        ans1=max(ans1,j)\\n                        j+=1\\n        return ans1+1\\n```\n```Java []\\nclass Solution {\\n    int[] seg;\\n    int len = 0;\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for (int n : nums) {\\n            max = Math.max(max, n);\\n        }\\n        len = max + 1;\\n        seg = new int[len * 2];\\n        int res = 0;\\n        for (int n : nums) {\\n            int cur = findMax(Math.max(n - k, 0), n) + 1;\\n            res = Math.max(res, cur);\\n            update(n, cur);\\n        }\\n        return res;\\n    }\\n    \\n    public void update(int idx, int val) {\\n        idx += len;\\n        while (idx >= 0 && seg[idx] < val) {\\n            seg[idx] = val;\\n            idx >>= 1;\\n        }\\n    }\\n    \\n    public int findMax(int from, int to) {\\n        from += len;\\n        to += len;\\n        int max = 0;\\n        while (from < to) {\\n            if ((from & 1) == 1) {\\n                max = Math.max(max, seg[from]);\\n                from++;\\n            }\\n            if ((to & 1) == 1) {\\n                to--;\\n                max = Math.max(max, seg[to]);\\n            }\\n            from >>= 1;\\n            to >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3045409,
                "title": "thought-process-100-nlog-k-segment-tree-optimization",
                "content": "# Intuition\\n1. based on already-well-explained segment tree solution\\n    - https://leetcode.com/problems/longest-increasing-subsequence-ii/solutions/2560085/python-explanation-with-pictures-segment-tree/\\n    - https://codeforces.com/blog/entry/18051\\n2. these common solutions set the segment tree\\'s leaves as `0 ~ max(nums)`, when case like `nums=[1, 10^5]` it still require `10^5` leaves with query/update time of `log(2*10^5)` to deal with only 2 elements\\n3. can we optimize this case?\\n4. yes, we can condense the unit of leaves as elements of unqiue nums with accending order, so that each number of leaves becomes `|unique nums|`\\ne.g. `nums=[1, 1, 10^5, 10^5]` : 2 leaves\\n5. but how can we do query with given num? e.g. \\n```text\\nk = 3\\nidx:  0 1 2 3 4 5 6 7  8\\nnums:[4,2,1,4,3,4,5,8,15], \\n                  ^ query:val:2 ~ 4\\n```\\n6. since the sorted unique nums has it\\'s own idx, then we can pre-process to find each idx\\'s query range (also idxs) by sliding window\\ne.g.\\n```text\\nidx:  0 1 2 3 4 5 6 7  8\\nnums:[4,2,1,4,3,4,5,8,15] \\n\\nsorted unique number as leaves ->\\nidx:  0 1 2 3 4 5  6\\nnums:[1,2,3,4,5,8,15]\\n        - - - ^ query idx:4 -> idx:2 ~ 3\\n```\\n7. apply back to segment tree, the leaves can be stored as idx of sorted unique number, and a mapping of `num to new idx`, each query of num convert to new idx and find query range from pre-processed queries\\ne.g. \\n```text\\nsorted unique number as leaves:\\nidx:  0 1 2 3 4 5  6\\nnums:[1,2,3,4,5,8,15]\\n              ^ query:idx:2 ~ 3\\n\\noriginal nums:\\nidx:  0 1 2 3 4 5 6 7  8\\nnums:[4,2,1,4,3,4,5,8,15] \\n                  ^ query -> new_idx[5]=4 -> query_idx[4]=2~3\\n```\\n8. put all together: (T: `O(n log(k))` = `n + klog(k)` + `n` + `k` + `n * log(k)`, n:|nums|, k:|unique nums|)\\n    1. unique nums and sort ascending ( T:`n + klog(k)`)\\n    2. creating num:idx of newly sorted list mapping ( T:`n`)\\n    3. create query range of each new idx using sliding window ( T:`k` )\\n    4. iterate all nums ( T:`n`)\\n        1. find it\\'s previous nums\\' LIS via segment tree ( T:`log(k)` )\\n        2. update new LIS value of this num to segment tree ( T:`log(k)` )\\n9. submission record\\n![image.png](https://assets.leetcode.com/users/images/c9d0ba94-2d63-4048-9e09-defb62eca35d_1673616409.9878309.png)\\n\\n\\n# Code\\n```python\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        class SegmentTree:\\n            def __init__(self, leaves, val_init):\\n                self.nodes = 2 ** math.ceil(math.log2(leaves))\\n                self.seq_tree = [val_init for _ in range(self.nodes * 2)]\\n\\n            def update(self, i_leaf, val):\\n                i_st = i_leaf + self.nodes\\n                while i_st >= 1:\\n                    if val > self.seq_tree[i_st]:\\n                        self.seq_tree[i_st] = val\\n                    else:\\n                        break\\n                    i_st = math.floor(i_st/2)\\n\\n            def query(self, i_leaf_left, i_leaf_right):\\n                i_left_st, i_right_st = i_leaf_left+self.nodes, i_leaf_right+self.nodes\\n                val_max = 0\\n                while i_left_st >= 1 and i_right_st >=1 and i_left_st <= i_right_st:\\n                    # left\\n                    if i_left_st % 2 == 1:\\n                        val_max = max(val_max, self.seq_tree[i_left_st])\\n                        i_left_st += 1\\n                    # right\\n                    if i_right_st % 2 == 0:\\n                        val_max = max(val_max, self.seq_tree[i_right_st])\\n                        i_right_st -= 1\\n                    i_left_st = math.floor(i_left_st/2)\\n                    i_right_st = math.floor(i_right_st/2)\\n                return val_max\\n        \\n        def process_query_range(nums_unique_st):\\n            \"\"\" ret: list[i]:(i_from,i_to) \"\"\"\\n            query_range = []\\n            l = 0\\n            for r in range(len(nums_unique_st)):\\n                while nums_unique_st[l] < nums_unique_st[r]-k:\\n                    l += 1\\n                if r == l:\\n                    query_range.append(None)\\n                else:\\n                    query_range.append([l,r-1])\\n            return query_range\\n\\n        # main\\n        # 4. build sorted unique nums\\n        nums_unique_st = sorted(list(set(nums)))\\n        # 7. build mappings of num to idx of sorted unique nums\\n        num_to_i = {num:i for i, num in enumerate(nums_unique_st)}\\n        # 6. pre-proces query range for each num in idx manner\\n        query_range = process_query_range(nums_unique_st)\\n        # 7. build segment tree with number of idx in sorted unique nums\\n        seg_tree = SegmentTree(len(nums_unique_st), 0)\\n\\n        # 7. iterate all num, query max lis for the nums before it\\n        for num in nums:\\n            i = num_to_i[num]\\n            lis = 1\\n            if query_range[i] is not None:\\n                i_from, i_to = query_range[i]\\n                lis += seg_tree.query(i_from, i_to)\\n            seg_tree.update(i, lis)\\n        lis_max = seg_tree.query(0, len(nums_unique_st)-1)\\n        return lis_max\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```text\\nk = 3\\nidx:  0 1 2 3 4 5 6 7  8\\nnums:[4,2,1,4,3,4,5,8,15], \\n                  ^ query:val:2 ~ 4\\n```\n```text\\nidx:  0 1 2 3 4 5 6 7  8\\nnums:[4,2,1,4,3,4,5,8,15] \\n\\nsorted unique number as leaves ->\\nidx:  0 1 2 3 4 5  6\\nnums:[1,2,3,4,5,8,15]\\n        - - - ^ query idx:4 -> idx:2 ~ 3\\n```\n```text\\nsorted unique number as leaves:\\nidx:  0 1 2 3 4 5  6\\nnums:[1,2,3,4,5,8,15]\\n              ^ query:idx:2 ~ 3\\n\\noriginal nums:\\nidx:  0 1 2 3 4 5 6 7  8\\nnums:[4,2,1,4,3,4,5,8,15] \\n                  ^ query -> new_idx[5]=4 -> query_idx[4]=2~3\\n```\n```python\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        class SegmentTree:\\n            def __init__(self, leaves, val_init):\\n                self.nodes = 2 ** math.ceil(math.log2(leaves))\\n                self.seq_tree = [val_init for _ in range(self.nodes * 2)]\\n\\n            def update(self, i_leaf, val):\\n                i_st = i_leaf + self.nodes\\n                while i_st >= 1:\\n                    if val > self.seq_tree[i_st]:\\n                        self.seq_tree[i_st] = val\\n                    else:\\n                        break\\n                    i_st = math.floor(i_st/2)\\n\\n            def query(self, i_leaf_left, i_leaf_right):\\n                i_left_st, i_right_st = i_leaf_left+self.nodes, i_leaf_right+self.nodes\\n                val_max = 0\\n                while i_left_st >= 1 and i_right_st >=1 and i_left_st <= i_right_st:\\n                    # left\\n                    if i_left_st % 2 == 1:\\n                        val_max = max(val_max, self.seq_tree[i_left_st])\\n                        i_left_st += 1\\n                    # right\\n                    if i_right_st % 2 == 0:\\n                        val_max = max(val_max, self.seq_tree[i_right_st])\\n                        i_right_st -= 1\\n                    i_left_st = math.floor(i_left_st/2)\\n                    i_right_st = math.floor(i_right_st/2)\\n                return val_max\\n        \\n        def process_query_range(nums_unique_st):\\n            \"\"\" ret: list[i]:(i_from,i_to) \"\"\"\\n            query_range = []\\n            l = 0\\n            for r in range(len(nums_unique_st)):\\n                while nums_unique_st[l] < nums_unique_st[r]-k:\\n                    l += 1\\n                if r == l:\\n                    query_range.append(None)\\n                else:\\n                    query_range.append([l,r-1])\\n            return query_range\\n\\n        # main\\n        # 4. build sorted unique nums\\n        nums_unique_st = sorted(list(set(nums)))\\n        # 7. build mappings of num to idx of sorted unique nums\\n        num_to_i = {num:i for i, num in enumerate(nums_unique_st)}\\n        # 6. pre-proces query range for each num in idx manner\\n        query_range = process_query_range(nums_unique_st)\\n        # 7. build segment tree with number of idx in sorted unique nums\\n        seg_tree = SegmentTree(len(nums_unique_st), 0)\\n\\n        # 7. iterate all num, query max lis for the nums before it\\n        for num in nums:\\n            i = num_to_i[num]\\n            lis = 1\\n            if query_range[i] is not None:\\n                i_from, i_to = query_range[i]\\n                lis += seg_tree.query(i_from, i_to)\\n            seg_tree.update(i, lis)\\n        lis_max = seg_tree.query(0, len(nums_unique_st)-1)\\n        return lis_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941977,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n\\n\\n        List<List<List<Integer>>> mapLists = new ArrayList<>();\\n        List<List<Integer>> mapList = new ArrayList<>();\\n        List<Integer> map = new ArrayList<>();\\n        map.add(nums[nums.length-1]);\\n        map.add(1);\\n        mapList.add(map);\\n        mapLists.add(mapList);\\n        \\n        for (int z = nums.length - 2; z >= 0; z--) {\\n            int x ;\\n            int y = 0;\\n            int count = 1;\\n            boolean mach = false;\\n            int num = nums[z];\\n            int i1=999999999;\\n            for (int i = mapLists.size() - 1; i >= 0; i--) {\\n                List<List<Integer>> lists = mapLists.get(i);\\n                x = 0;\\n                int j= lists.size() - 1;\\n\\n                int n=0;\\n                int m=lists.size()-1;\\n                while (m>=n) {\\n                    int node = (n + m) / 2;\\n                    if (num >= lists.get(node).get(0)) {\\n                        n = node+1;\\n                        x=node+1;\\n                    }\\n                    if (num < lists.get(node).get(0)) {\\n                        m = node-1;\\n                        if(lists.get(node).get(0) - num<i1){\\n                            i1=lists.get(node).get(0) - num;\\n                            x = node;\\n                        }\\n                        if (i1 <= k && i1 > 0) {\\n                            count = mapLists.get(i).get(0).get(1) + 1;\\n                            mach = true;\\n                        }\\n                    }\\n                }\\n                if(mach){\\n                    break;\\n                }else {\\n                    y=x;\\n                }\\n\\n            }\\n            if (mach && count > mapLists.size()) {\\n                List<List<Integer>> mapList2 = new ArrayList<>();\\n                List<Integer> map2 = new ArrayList<>();\\n                map2.add(num);\\n                map2.add(count);\\n                mapList2.add(map2);\\n                mapLists.add(mapList2);\\n            } else {\\n                List<Integer> map2 = new ArrayList<>();\\n                map2.add(num);\\n                map2.add(count);\\n                mapLists.get(count - 1).add(y, map2);\\n            }\\n//            System.out.println(\"mapLists:\" + mapLists);\\n\\n        }\\n\\n        return mapLists.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n\\n\\n        List<List<List<Integer>>> mapLists = new ArrayList<>();\\n        List<List<Integer>> mapList = new ArrayList<>();\\n        List<Integer> map = new ArrayList<>();\\n        map.add(nums[nums.length-1]);\\n        map.add(1);\\n        mapList.add(map);\\n        mapLists.add(mapList);\\n        \\n        for (int z = nums.length - 2; z >= 0; z--) {\\n            int x ;\\n            int y = 0;\\n            int count = 1;\\n            boolean mach = false;\\n            int num = nums[z];\\n            int i1=999999999;\\n            for (int i = mapLists.size() - 1; i >= 0; i--) {\\n                List<List<Integer>> lists = mapLists.get(i);\\n                x = 0;\\n                int j= lists.size() - 1;\\n\\n                int n=0;\\n                int m=lists.size()-1;\\n                while (m>=n) {\\n                    int node = (n + m) / 2;\\n                    if (num >= lists.get(node).get(0)) {\\n                        n = node+1;\\n                        x=node+1;\\n                    }\\n                    if (num < lists.get(node).get(0)) {\\n                        m = node-1;\\n                        if(lists.get(node).get(0) - num<i1){\\n                            i1=lists.get(node).get(0) - num;\\n                            x = node;\\n                        }\\n                        if (i1 <= k && i1 > 0) {\\n                            count = mapLists.get(i).get(0).get(1) + 1;\\n                            mach = true;\\n                        }\\n                    }\\n                }\\n                if(mach){\\n                    break;\\n                }else {\\n                    y=x;\\n                }\\n\\n            }\\n            if (mach && count > mapLists.size()) {\\n                List<List<Integer>> mapList2 = new ArrayList<>();\\n                List<Integer> map2 = new ArrayList<>();\\n                map2.add(num);\\n                map2.add(count);\\n                mapList2.add(map2);\\n                mapLists.add(mapList2);\\n            } else {\\n                List<Integer> map2 = new ArrayList<>();\\n                map2.add(num);\\n                map2.add(count);\\n                mapLists.get(count - 1).add(y, map2);\\n            }\\n//            System.out.println(\"mapLists:\" + mapLists);\\n\\n        }\\n\\n        return mapLists.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890959,
                "title": "faster-than-90-easy-to-understand",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\nsince query and update in segment tree is O(logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def lengthOfLIS(self, n: List[int], k: int) -> int:\\n        m = max(n)\\n        A = [0] * (2 * (m + 2))\\n\\n#prepare the query() and update() function for segment tree\\n        #\\n        def query(l , r):\\n            rs = 0\\n            l += m + 1\\n            r += m + 1\\n\\n            while l <= r:\\n                if l & 1 > 0:\\n                    rs = max(rs , A[l])\\n                    l += 1\\n\\n                if r & 1 == 0:\\n                    rs = max(rs , A[r])\\n                    r -= 1\\n\\n                l >>= 1\\n                r >>= 1\\n\\n            return rs\\n        \\n        def update(pos , val):\\n            i = pos + m + 1\\n            A[i] = val\\n\\n            while i > 0 :\\n                A[i >> 1] = max(A[i] , A[i ^ 1])\\n                i >>= 1\\n\\n#main code (if u know how segment tree works then this is easy for u if u dont then u should take a litle research this topic will be helpful)     \\n        res = 0\\n        for i in range(len(n)):\\n            v = n[i]\\n            le = max(0 , v - k)\\n            ri = max(0 , v - 1)\\n            mm = query(le , ri)\\n            update(v , mm + 1)\\n            res = max(res , mm + 1)\\n\\n        return res\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, n: List[int], k: int) -> int:\\n        m = max(n)\\n        A = [0] * (2 * (m + 2))\\n\\n#prepare the query() and update() function for segment tree\\n        #\\n        def query(l , r):\\n            rs = 0\\n            l += m + 1\\n            r += m + 1\\n\\n            while l <= r:\\n                if l & 1 > 0:\\n                    rs = max(rs , A[l])\\n                    l += 1\\n\\n                if r & 1 == 0:\\n                    rs = max(rs , A[r])\\n                    r -= 1\\n\\n                l >>= 1\\n                r >>= 1\\n\\n            return rs\\n        \\n        def update(pos , val):\\n            i = pos + m + 1\\n            A[i] = val\\n\\n            while i > 0 :\\n                A[i >> 1] = max(A[i] , A[i ^ 1])\\n                i >>= 1\\n\\n#main code (if u know how segment tree works then this is easy for u if u dont then u should take a litle research this topic will be helpful)     \\n        res = 0\\n        for i in range(len(n)):\\n            v = n[i]\\n            le = max(0 , v - k)\\n            ri = max(0 , v - 1)\\n            mm = query(le , ri)\\n            update(v , mm + 1)\\n            res = max(res , mm + 1)\\n\\n        return res\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873827,
                "title": "python-simple-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums, k):\\n        def update(i,x):\\n            i += n \\n            while i:\\n                ans[i] = max(ans[i],x)\\n                i = i//2\\n\\n        def query(i,j):\\n            i += n\\n            j += n\\n            max_val = float(\"-inf\")\\n\\n            while i<=j:\\n                if i&1:\\n                    max_val = max(max_val,ans[i])\\n                    i += 1\\n\\n                if not j&1:\\n                    max_val = max(max_val,ans[j])\\n                    j -= 1\\n\\n                i = i//2\\n                j = j//2\\n\\n            return max_val\\n\\n        n = max(nums) + 1\\n        ans = [0]*(2*n)\\n        max_val = 0\\n\\n        for i,v in enumerate(nums):\\n            rb, lb = max(0,v-1), max(0,v-k)\\n            res = query(lb,rb) + 1\\n            max_val = max(max_val,res)\\n            if res > ans[v+n]:\\n                update(v,res)\\n\\n        return max_val\\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums, k):\\n        def update(i,x):\\n            i += n \\n            while i:\\n                ans[i] = max(ans[i],x)\\n                i = i//2\\n\\n        def query(i,j):\\n            i += n\\n            j += n\\n            max_val = float(\"-inf\")\\n\\n            while i<=j:\\n                if i&1:\\n                    max_val = max(max_val,ans[i])\\n                    i += 1\\n\\n                if not j&1:\\n                    max_val = max(max_val,ans[j])\\n                    j -= 1\\n\\n                i = i//2\\n                j = j//2\\n\\n            return max_val\\n\\n        n = max(nums) + 1\\n        ans = [0]*(2*n)\\n        max_val = 0\\n\\n        for i,v in enumerate(nums):\\n            rb, lb = max(0,v-1), max(0,v-k)\\n            res = query(lb,rb) + 1\\n            max_val = max(max_val,res)\\n            if res > ans[v+n]:\\n                update(v,res)\\n\\n        return max_val\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867043,
                "title": "iterative-segment-tree-approach-short-and-simple",
                "content": "# Intuition\\nThe value of a[i] is in range 1 to 1e5, and the adjacent value in the have diference k, which makes us think of range a[i]-k to a[i]-1 for the previous value.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: n*log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 3*n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void update(vector<int> &seg,int ind,int val,int mx){\\n\\n        ind+=mx;\\n\\n        seg[ind]=max(val,seg[ind]);\\n        ind/=2;\\n\\n        for(;ind>0;ind/=2){\\n\\n            seg[ind]=max(seg[2*ind],seg[2*ind+1]);\\n\\n        }\\n\\n\\n\\n    }\\n\\n    int query(int l, int r,vector<int> &seg,int n) {  // sum on interval [l, r)\\n        int res = 0;\\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\\n            if (l&1) res = max(seg[l++],res);\\n            if (r&1) res = max(seg[--r],res);\\n        }\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int mx=0;\\n\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            nums[i]+=k;\\n            mx=max(mx,nums[i]);\\n\\n        }   \\n        int ans=0;\\n        vector<int> seg(3*mx+100,0);\\n\\n\\n        for(int i=0;i<n;i++){\\n\\n            int c=query(nums[i]-k,nums[i],seg,mx);\\n\\n            // cout<<nums[i]-k<<\" \"<<c<<endl;\\n\\n            update(seg,nums[i],c+1,mx);\\n\\n            ans=max(ans,c);\\n\\n        }\\n\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void update(vector<int> &seg,int ind,int val,int mx){\\n\\n        ind+=mx;\\n\\n        seg[ind]=max(val,seg[ind]);\\n        ind/=2;\\n\\n        for(;ind>0;ind/=2){\\n\\n            seg[ind]=max(seg[2*ind],seg[2*ind+1]);\\n\\n        }\\n\\n\\n\\n    }\\n\\n    int query(int l, int r,vector<int> &seg,int n) {  // sum on interval [l, r)\\n        int res = 0;\\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\\n            if (l&1) res = max(seg[l++],res);\\n            if (r&1) res = max(seg[--r],res);\\n        }\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int mx=0;\\n\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            nums[i]+=k;\\n            mx=max(mx,nums[i]);\\n\\n        }   \\n        int ans=0;\\n        vector<int> seg(3*mx+100,0);\\n\\n\\n        for(int i=0;i<n;i++){\\n\\n            int c=query(nums[i]-k,nums[i],seg,mx);\\n\\n            // cout<<nums[i]-k<<\" \"<<c<<endl;\\n\\n            update(seg,nums[i],c+1,mx);\\n\\n            ans=max(ans,c);\\n\\n        }\\n\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2844261,
                "title": "python-segment-tree-solution-extension-for-negative-integer",
                "content": "```\\nclass seg_tree:\\n    def __init__(self, n):\\n        self.n = n+1\\n        self.tree = [0]*(self.n*2)\\n        \\n    def query(self, l, r):\\n        l, r, x = l+self.n, r+self.n, 0\\n        while(l<r):\\n            if l%2:\\n                x = max(x, self.tree[l])\\n                l += 1\\n            if r%2:\\n                r -= 1\\n                x = max(x, self.tree[r])\\n            l //= 2\\n            r //= 2\\n        return x\\n    \\n    def update(self, i, x):\\n        i += self.n\\n        self.tree[i] = x\\n        while(i>1):\\n            i//=2\\n            self.tree[i] = max(self.tree[i*2], self.tree[i*2+1])\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        seg, lis = seg_tree(max(nums)), 1\\n        for n in nums:\\n            pmax = seg.query(max(0, n-k), n)+1\\n            seg.update(n, pmax)\\n            lis = max(lis, pmax)\\n        return lis\\n```\\n\\nThere is great segment-tree implementation in non-recursive fashion\\nPlease follow the explanation [HERE](https://codeforces.com/blog/entry/18051)\\nOne note is the \"query\" function refers to the interval **[l, r)**\\n\\n===============================\\nNote the constraints for input is **positive integer**\\nHow about the input with **negative integer** ?\\n\\nWe are using the integer ifself as value and index in segment-tree.\\nHowever, it only works for **positive integer**.\\nAnother problem is the space will be wasted a lot.\\nThinking about the input as [1, 2, 4, 1, 10^9].\\n**It will cost the space in 10^9 size**\\n\\nThe solution is to build the segment-tree in elements\\' rank - **index of element in sorted array**.\\nThis trick allows us to work the input as [1, 2, 4, 1, 10^9] in size 5 space, instead of size 10^9.\\nThe following is my implementation for negative input.\\n```\\ndef lengthOfLIS_neg(self, nums: List[int], k: int) -> int:\\n\\tnums_sort = sorted(set(nums))\\n\\trank = {x:i for i, x in enumerate(nums_sort)}\\n\\tseg, lis = seg_tree(len(nums_sort)), 1\\n\\tfor n in nums:\\n\\t\\ti = bisect.bisect_left(nums_sort, n-k)\\n\\t\\t# using \"max(0, n-k))\" in this problem for positive input.\\n\\t\\tpmax = seg.query(i, rank[n])+1\\n\\t\\tseg.update(rank[n], pmax)\\n\\t\\tlis = max(lis, pmax)\\n\\treturn lis\\n```",
                "solutionTags": [],
                "code": "```\\nclass seg_tree:\\n    def __init__(self, n):\\n        self.n = n+1\\n        self.tree = [0]*(self.n*2)\\n        \\n    def query(self, l, r):\\n        l, r, x = l+self.n, r+self.n, 0\\n        while(l<r):\\n            if l%2:\\n                x = max(x, self.tree[l])\\n                l += 1\\n            if r%2:\\n                r -= 1\\n                x = max(x, self.tree[r])\\n            l //= 2\\n            r //= 2\\n        return x\\n    \\n    def update(self, i, x):\\n        i += self.n\\n        self.tree[i] = x\\n        while(i>1):\\n            i//=2\\n            self.tree[i] = max(self.tree[i*2], self.tree[i*2+1])\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        seg, lis = seg_tree(max(nums)), 1\\n        for n in nums:\\n            pmax = seg.query(max(0, n-k), n)+1\\n            seg.update(n, pmax)\\n            lis = max(lis, pmax)\\n        return lis\\n```\n```\\ndef lengthOfLIS_neg(self, nums: List[int], k: int) -> int:\\n\\tnums_sort = sorted(set(nums))\\n\\trank = {x:i for i, x in enumerate(nums_sort)}\\n\\tseg, lis = seg_tree(len(nums_sort)), 1\\n\\tfor n in nums:\\n\\t\\ti = bisect.bisect_left(nums_sort, n-k)\\n\\t\\t# using \"max(0, n-k))\" in this problem for positive input.\\n\\t\\tpmax = seg.query(i, rank[n])+1\\n\\t\\tseg.update(rank[n], pmax)\\n\\t\\tlis = max(lis, pmax)\\n\\treturn lis\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799497,
                "title": "google-interview-question-solution",
                "content": "This question wa sasked to me in my google internship interview 1 year back. Was able to give only the approach at the end of the interview which was that of segment tree. Had never ever thought of getting a segment tree problem in a real interview xD!! \\n\\nTheere was one more follow-up which was to also find one such longest subsequence... \\n\\nAnyways, I am posting my segtree solution here...\\n\\n```\\nclass SegTree{\\n    private: \\n     int *seg;\\n    public:\\n     SegTree(){\\n         \\n         seg=new int[4*100000+2];\\n         for(int i=0;i<400002;i++)\\n             seg[i]=0;\\n     }\\n    \\n    void update(int si,int ss,int se,int id,int val){\\n        \\n       if(id<ss || id>se)\\n           return ;\\n        \\n        if(ss==se && ss==id)\\n        {\\n           seg[si]=val;\\n            return;\\n        }\\n        \\n        int mid=(ss+se)/2;\\n        update(2*si+1,ss,mid,id,val);\\n        update(2*si+2,mid+1,se,id,val);\\n        \\n        seg[si]=max(seg[2*si+1],seg[2*si+2]);\\n    }\\n    \\n    int getMax(int si,int ss,int se,int l,int r){\\n        if(l>r)\\n            return 0;\\n        \\n        if(l>se || r<ss)\\n            return 0;\\n        \\n        if(ss>=l && se<=r)\\n            return seg[si];\\n        \\n        int mid=(ss+se)/2;\\n        \\n        return max(getMax(2*si+1,ss,mid,l,r),getMax(2*si+2,mid+1,se,l,r));\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree sg;\\n        \\n        int ans=0;\\n        \\n        for(auto val:nums){\\n            //int val=e;\\n            int rs = sg.getMax(0,1,100000,max(1,val-k),val-1);\\n            rs++;\\n            ans=max(ans,rs);\\n            sg.update(0,1,100000,val,rs);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegTree{\\n    private: \\n     int *seg;\\n    public:\\n     SegTree(){\\n         \\n         seg=new int[4*100000+2];\\n         for(int i=0;i<400002;i++)\\n             seg[i]=0;\\n     }\\n    \\n    void update(int si,int ss,int se,int id,int val){\\n        \\n       if(id<ss || id>se)\\n           return ;\\n        \\n        if(ss==se && ss==id)\\n        {\\n           seg[si]=val;\\n            return;\\n        }\\n        \\n        int mid=(ss+se)/2;\\n        update(2*si+1,ss,mid,id,val);\\n        update(2*si+2,mid+1,se,id,val);\\n        \\n        seg[si]=max(seg[2*si+1],seg[2*si+2]);\\n    }\\n    \\n    int getMax(int si,int ss,int se,int l,int r){\\n        if(l>r)\\n            return 0;\\n        \\n        if(l>se || r<ss)\\n            return 0;\\n        \\n        if(ss>=l && se<=r)\\n            return seg[si];\\n        \\n        int mid=(ss+se)/2;\\n        \\n        return max(getMax(2*si+1,ss,mid,l,r),getMax(2*si+2,mid+1,se,l,r));\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree sg;\\n        \\n        int ans=0;\\n        \\n        for(auto val:nums){\\n            //int val=e;\\n            int rs = sg.getMax(0,1,100000,max(1,val-k),val-1);\\n            rs++;\\n            ans=max(ans,rs);\\n            sg.update(0,1,100000,val,rs);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796417,
                "title": "go-c-segment-tree",
                "content": "C++\\n\\n```cpp\\nclass SegTree {\\npublic:\\n    int n;\\n    vector<int> tree;\\n    SegTree(int n_): n(n_) {\\n        tree = vector<int>(n*4);\\n    }\\n    int query(int i, int L, int R, int l, int r) {\\n        if(l == L && r == R) \\n            return tree[i];\\n        int M = (L+R)>>1;\\n        if(M >= r)\\n            return query(i*2+1, L, M, l, r);\\n        else if(M < l)\\n            return query(i*2+2, M+1, R, l, r);\\n        return max(query(i*2+1, L, M, l, M), query(i*2+2, M+1, R, M+1, r));\\n    }\\n    void modify(int i, int L, int R, int P, int v) {\\n        if(L==R) {\\n            tree[i] = max(v, tree[i]);\\n            return;\\n        }\\n        int M = (L+R) >> 1;\\n        if(M >= P)\\n            modify(i*2+1, L, M, P, v);\\n        else modify(i*2+2, M+1, R, P, v);\\n        tree[i] = max(tree[i*2+1], tree[i*2+2]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = *max_element(nums.begin(), nums.end());\\n        auto segTree = SegTree(n);\\n        for(auto& num: nums) {\\n            int lower = max(0, num-k);\\n            int v = segTree.query(0, 0, segTree.n, lower, num-1);\\n            segTree.modify(0, 0, segTree.n, num, v+1);\\n        }\\n        return segTree.tree[0];\\n    }\\n};\\n```\\nGo\\n\\n```go\\ntype SegTree []int\\nfunc NewSegTree(n int) SegTree {\\n    return make(SegTree, n)\\n}\\n\\nfunc (s SegTree) Query(l, r, L, R, i int) int {\\n    if L==l && R==r {\\n        return s[i]\\n    }\\n    M := (L+R)>>1\\n    if M >= r {\\n        return s.Query(l, r, L, M, i*2+1)\\n    } else if M < l {\\n        return s.Query(l, r, M+1, R, i*2+2)\\n    }\\n    return max(s.Query(l, M, L, M, i*2+1), s.Query(M+1, r, M+1, R, i*2+2))\\n}\\n\\nfunc (s SegTree) Update(L, R, P, i, v int)  {\\n    if L == R {\\n        s[i] = max(s[i], v)\\n        return\\n    }\\n    M := (L+R)>>1\\n    if P <= M {\\n        s.Update(L, M, P, i*2+1, v) \\n    } else { \\n        s.Update(M+1, R, P, i*2+2, v) \\n    }\\n    s[i] = max(s[i*2+1], s[i*2+2])\\n}\\n\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n    m := 0\\n    for _, num := range nums {\\n        m = max(m, num)\\n    }\\n    tree := NewSegTree(m*4)\\n    for _, num := range nums {\\n        lower := max(0, num - k);\\n        val := tree.Query(lower, num-1, 0, m, 0)\\n        tree.Update(0, m, num, 0, val+1)\\n    }\\n    return tree[0]\\n}\\n\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass SegTree {\\npublic:\\n    int n;\\n    vector<int> tree;\\n    SegTree(int n_): n(n_) {\\n        tree = vector<int>(n*4);\\n    }\\n    int query(int i, int L, int R, int l, int r) {\\n        if(l == L && r == R) \\n            return tree[i];\\n        int M = (L+R)>>1;\\n        if(M >= r)\\n            return query(i*2+1, L, M, l, r);\\n        else if(M < l)\\n            return query(i*2+2, M+1, R, l, r);\\n        return max(query(i*2+1, L, M, l, M), query(i*2+2, M+1, R, M+1, r));\\n    }\\n    void modify(int i, int L, int R, int P, int v) {\\n        if(L==R) {\\n            tree[i] = max(v, tree[i]);\\n            return;\\n        }\\n        int M = (L+R) >> 1;\\n        if(M >= P)\\n            modify(i*2+1, L, M, P, v);\\n        else modify(i*2+2, M+1, R, P, v);\\n        tree[i] = max(tree[i*2+1], tree[i*2+2]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = *max_element(nums.begin(), nums.end());\\n        auto segTree = SegTree(n);\\n        for(auto& num: nums) {\\n            int lower = max(0, num-k);\\n            int v = segTree.query(0, 0, segTree.n, lower, num-1);\\n            segTree.modify(0, 0, segTree.n, num, v+1);\\n        }\\n        return segTree.tree[0];\\n    }\\n};\\n```\n```go\\ntype SegTree []int\\nfunc NewSegTree(n int) SegTree {\\n    return make(SegTree, n)\\n}\\n\\nfunc (s SegTree) Query(l, r, L, R, i int) int {\\n    if L==l && R==r {\\n        return s[i]\\n    }\\n    M := (L+R)>>1\\n    if M >= r {\\n        return s.Query(l, r, L, M, i*2+1)\\n    } else if M < l {\\n        return s.Query(l, r, M+1, R, i*2+2)\\n    }\\n    return max(s.Query(l, M, L, M, i*2+1), s.Query(M+1, r, M+1, R, i*2+2))\\n}\\n\\nfunc (s SegTree) Update(L, R, P, i, v int)  {\\n    if L == R {\\n        s[i] = max(s[i], v)\\n        return\\n    }\\n    M := (L+R)>>1\\n    if P <= M {\\n        s.Update(L, M, P, i*2+1, v) \\n    } else { \\n        s.Update(M+1, R, P, i*2+2, v) \\n    }\\n    s[i] = max(s[i*2+1], s[i*2+2])\\n}\\n\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n    m := 0\\n    for _, num := range nums {\\n        m = max(m, num)\\n    }\\n    tree := NewSegTree(m*4)\\n    for _, num := range nums {\\n        lower := max(0, num - k);\\n        val := tree.Query(lower, num-1, 0, m, 0)\\n        tree.Update(0, m, num, 0, val+1)\\n    }\\n    return tree[0]\\n}\\n\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789180,
                "title": "using-segment-tree-find-max-between-given-ranges-nlogn-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int st[4*100000+5];\\n    void built(int ind, int low, int high)\\n    {\\n        if (low == high)\\n        {\\n            st[ind] = 0;\\n            return;\\n        }\\n        int mid = low + (high - low) / 2;\\n        built(2 *ind + 1, low, mid);\\n        built(2 *ind + 2, mid + 1, high);\\n        st[ind] = max(st[2 *ind + 1], st[2 *ind + 2]);\\n    }\\n    int querry(int ind, int low, int high, int a, int b)\\n    {\\n        if (a > b)\\n            return 0;\\n        if (a == low and high == b)\\n            return st[ind];\\n        int mid = low + (high - low) / 2;\\n        int left = querry(2 *ind + 1, low, mid, a, min(b, mid));\\n        int right = querry(2 *ind + 2, mid + 1, high, max(a, mid + 1), b);\\n        return max(left, right);\\n    }\\n    void updatee(int ind, int low, int high, int i, int val)\\n    {\\n        if (low == high)\\n        {\\n            st[ind] = val;\\n            return;\\n        }\\n        int mid = low + (high - low) / 2;\\n        if (i <= mid)\\n            updatee(2 *ind + 1, low, mid, i, val);\\n        else\\n            updatee(2 *ind + 2, mid + 1, high, i, val);\\n        st[ind] = max(st[2 *ind + 1], st[2 *ind + 2]);\\n    }\\n\\n    int lengthOfLIS(vector<int> &nums, int k)\\n    {\\n        int n = nums.size();\\n        built(0, 0, 100000);\\n        int ans = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int a = nums[i] + 1;\\n            int b = min(nums[i] + k, 100000);\\n            int maxi =querry(0, 0, 100000, a, b);\\n            ans = max(ans, maxi + 1);\\n            updatee(0, 0, 100000, a-1, maxi + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int st[4*100000+5];\\n    void built(int ind, int low, int high)\\n    {\\n        if (low == high)\\n        {\\n            st[ind] = 0;\\n            return;\\n        }\\n        int mid = low + (high - low) / 2;\\n        built(2 *ind + 1, low, mid);\\n        built(2 *ind + 2, mid + 1, high);\\n        st[ind] = max(st[2 *ind + 1], st[2 *ind + 2]);\\n    }\\n    int querry(int ind, int low, int high, int a, int b)\\n    {\\n        if (a > b)\\n            return 0;\\n        if (a == low and high == b)\\n            return st[ind];\\n        int mid = low + (high - low) / 2;\\n        int left = querry(2 *ind + 1, low, mid, a, min(b, mid));\\n        int right = querry(2 *ind + 2, mid + 1, high, max(a, mid + 1), b);\\n        return max(left, right);\\n    }\\n    void updatee(int ind, int low, int high, int i, int val)\\n    {\\n        if (low == high)\\n        {\\n            st[ind] = val;\\n            return;\\n        }\\n        int mid = low + (high - low) / 2;\\n        if (i <= mid)\\n            updatee(2 *ind + 1, low, mid, i, val);\\n        else\\n            updatee(2 *ind + 2, mid + 1, high, i, val);\\n        st[ind] = max(st[2 *ind + 1], st[2 *ind + 2]);\\n    }\\n\\n    int lengthOfLIS(vector<int> &nums, int k)\\n    {\\n        int n = nums.size();\\n        built(0, 0, 100000);\\n        int ans = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int a = nums[i] + 1;\\n            int b = min(nums[i] + k, 100000);\\n            int maxi =querry(0, 0, 100000, a, b);\\n            ans = max(ans, maxi + 1);\\n            updatee(0, 0, 100000, a-1, maxi + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755392,
                "title": "c-segment-tree",
                "content": "```\\n#define MAXN 100001\\nclass Solution {\\npublic:\\n    vector<int>tree;\\n    void update(int node,int strt,int end, int idx,int val)\\n    {\\n        if(strt>idx || idx>end)\\n            return;\\n        if(strt==end)\\n        {\\n            tree[node]=max(val,tree[node]);\\n            return;\\n        }\\n        else\\n        {\\n            int mid=(strt+end)/2;\\n            if(idx>=strt && idx<=mid)\\n                update(2*node+1,strt,mid,idx,val);\\n            else\\n                update(2*node+2,mid+1,end,idx,val);\\n        }\\n        tree[node]=max(tree[2*node+1],tree[2*node +2]);\\n    }\\n    int query(int node, int strt,int end,int l, int r)\\n    {\\n        if(strt>r || l>end)\\n            return 0;\\n        if(strt>=l && end<=r)\\n            return tree[node];\\n        int mid=(strt+end)/2;\\n        int x=query(2*node+1,strt,mid,l,r);\\n        int y=query(2*node+2,mid+1,end,l,r);\\n        return max(x,y);\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sz=ceil(log2(1e5 +1));\\n        sz=2*pow(2,sz) -1;\\n        tree.resize(sz);\\n        int ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=query(0,0,MAXN-1,max(0,nums[i]-k),nums[i]-1);\\n            ans=max(ans,val+1);\\n            update(0,0,MAXN-1,nums[i],val+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MAXN 100001\\nclass Solution {\\npublic:\\n    vector<int>tree;\\n    void update(int node,int strt,int end, int idx,int val)\\n    {\\n        if(strt>idx || idx>end)\\n            return;\\n        if(strt==end)\\n        {\\n            tree[node]=max(val,tree[node]);\\n            return;\\n        }\\n        else\\n        {\\n            int mid=(strt+end)/2;\\n            if(idx>=strt && idx<=mid)\\n                update(2*node+1,strt,mid,idx,val);\\n            else\\n                update(2*node+2,mid+1,end,idx,val);\\n        }\\n        tree[node]=max(tree[2*node+1],tree[2*node +2]);\\n    }\\n    int query(int node, int strt,int end,int l, int r)\\n    {\\n        if(strt>r || l>end)\\n            return 0;\\n        if(strt>=l && end<=r)\\n            return tree[node];\\n        int mid=(strt+end)/2;\\n        int x=query(2*node+1,strt,mid,l,r);\\n        int y=query(2*node+2,mid+1,end,l,r);\\n        return max(x,y);\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sz=ceil(log2(1e5 +1));\\n        sz=2*pow(2,sz) -1;\\n        tree.resize(sz);\\n        int ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=query(0,0,MAXN-1,max(0,nums[i]-k),nums[i]-1);\\n            ans=max(ans,val+1);\\n            update(0,0,MAXN-1,nums[i],val+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753532,
                "title": "go-clean-solution",
                "content": "```func lengthOfLIS(nums []int, k int) int {\\n\\tmax := func(a, b int) int {\\n\\t\\tif a > b {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\treturn b\\n\\t}\\n\\n\\tdp := [200002]int{}\\n\\tfor _, num := range nums {\\n\\t\\tx, i := 0, num+100001\\n\\t\\tfor left, right := max(i-k, 100001), i; left < right; left, right = left/2, right/2 {\\n\\t\\t\\tif left%2 == 1 {\\n\\t\\t\\t\\tx = max(x, dp[left])\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t\\tif right%2 == 1 {\\n\\t\\t\\t\\tright--\\n\\t\\t\\t\\tx = max(x, dp[right])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor dp[i] = x + 1; i > 1; i /= 2 {\\n\\t\\t\\tdp[i/2] = max(dp[i], dp[i^1])\\n\\t\\t}\\n\\t}\\n\\treturn dp[1]\\n}",
                "solutionTags": [],
                "code": "```func lengthOfLIS(nums []int, k int) int {\\n\\tmax := func(a, b int) int {\\n\\t\\tif a > b {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\treturn b\\n\\t}\\n\\n\\tdp := [200002]int{}\\n\\tfor _, num := range nums {\\n\\t\\tx, i := 0, num+100001\\n\\t\\tfor left, right := max(i-k, 100001), i; left < right; left, right = left/2, right/2 {\\n\\t\\t\\tif left%2 == 1 {\\n\\t\\t\\t\\tx = max(x, dp[left])\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t\\tif right%2 == 1 {\\n\\t\\t\\t\\tright--\\n\\t\\t\\t\\tx = max(x, dp[right])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor dp[i] = x + 1; i > 1; i /= 2 {\\n\\t\\t\\tdp[i/2] = max(dp[i], dp[i^1])\\n\\t\\t}\\n\\t}\\n\\treturn dp[1]\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2709090,
                "title": "java-dp-segment-tree-easy-clean-code",
                "content": "```\\nclass Solution {\\n    class Node{\\n        int val;\\n        Node left;\\n        Node right;\\n        int start;\\n        int end;\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for(int num : nums){\\n            max = Math.max(max,num);\\n        }\\n        \\n        Node root = construct(1,max);\\n        \\n        int res = 0;\\n        for(int num : nums){\\n            int lo = (num - k) < 1 ? 1 : (num - k);\\n            int hi = num - 1;\\n            \\n            int len = query(root,lo,hi) + 1;\\n            \\n            update(root,num,len);\\n            res = Math.max(res,len);\\n        }                \\n        return res;\\n    }\\n    \\n    Node construct(int ss,int se){\\n        if(ss == se){\\n            Node node = new Node();\\n            node.start = ss;\\n            node.end = se;\\n            node.val = 0;\\n            return node;\\n        }\\n        \\n        int mid = (ss + se) / 2;\\n        Node node = new Node();\\n        node.start = ss;\\n        node.end = se;\\n        node.left = construct(ss,mid);\\n        node.right = construct(mid+1,se);\\n        node.val = Math.max(node.left.val,node.right.val);\\n        \\n        return node;\\n    }\\n    \\n    void update(Node node,int idx,int val){\\n        if(node.start == node.end){\\n            node.val = val;\\n            return;\\n        }\\n        \\n        int mid = (node.start + node.end) / 2;\\n        if(idx <= mid){\\n            update(node.left,idx,val);\\n        }else{\\n            update(node.right,idx,val);\\n        }\\n        \\n        node.val = Math.max(node.left.val,node.right.val);\\n    }\\n    \\n    int query(Node node,int qs,int qe){\\n        if(node.start > qe || node.end < qs){\\n            return 0;\\n        }else if(node.start >= qs && node.end <= qe){\\n            return node.val;\\n        }else{\\n            int lval = query(node.left,qs,qe);\\n            int rval = query(node.right,qs,qe);\\n            return Math.max(lval,rval);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int val;\\n        Node left;\\n        Node right;\\n        int start;\\n        int end;\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 0;\\n        for(int num : nums){\\n            max = Math.max(max,num);\\n        }\\n        \\n        Node root = construct(1,max);\\n        \\n        int res = 0;\\n        for(int num : nums){\\n            int lo = (num - k) < 1 ? 1 : (num - k);\\n            int hi = num - 1;\\n            \\n            int len = query(root,lo,hi) + 1;\\n            \\n            update(root,num,len);\\n            res = Math.max(res,len);\\n        }                \\n        return res;\\n    }\\n    \\n    Node construct(int ss,int se){\\n        if(ss == se){\\n            Node node = new Node();\\n            node.start = ss;\\n            node.end = se;\\n            node.val = 0;\\n            return node;\\n        }\\n        \\n        int mid = (ss + se) / 2;\\n        Node node = new Node();\\n        node.start = ss;\\n        node.end = se;\\n        node.left = construct(ss,mid);\\n        node.right = construct(mid+1,se);\\n        node.val = Math.max(node.left.val,node.right.val);\\n        \\n        return node;\\n    }\\n    \\n    void update(Node node,int idx,int val){\\n        if(node.start == node.end){\\n            node.val = val;\\n            return;\\n        }\\n        \\n        int mid = (node.start + node.end) / 2;\\n        if(idx <= mid){\\n            update(node.left,idx,val);\\n        }else{\\n            update(node.right,idx,val);\\n        }\\n        \\n        node.val = Math.max(node.left.val,node.right.val);\\n    }\\n    \\n    int query(Node node,int qs,int qe){\\n        if(node.start > qe || node.end < qs){\\n            return 0;\\n        }else if(node.start >= qs && node.end <= qe){\\n            return node.val;\\n        }else{\\n            int lval = query(node.left,qs,qe);\\n            int rval = query(node.right,qs,qe);\\n            return Math.max(lval,rval);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694910,
                "title": "java-easy-solution-segment-tree",
                "content": "```\\nclass Solution {\\n    \\n    \\n    \\n    int tree [];\\n    \\n    int update(int low , int high , int index , int key , int value){\\n        \\n        if( low > key || key > high ) return tree [ index ];\\n        \\n        \\n        else if(low == high && low == key){\\n            \\n            return tree[index] = value;\\n        \\n        }\\n        \\n        else{\\n            \\n            \\n            int mid = ( low + high )/2;\\n            \\n            int left = update(low , mid , 2 * index + 1 , key , value);\\n            \\n            int right = update(mid+1 , high , 2 * index + 2 , key , value );\\n            \\n            return tree[index] = Math.max(left,right);\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    \\n    int query(int low , int high , int index , int start , int end)\\n    {\\n        \\n        if( low > end || high < start ) return 0;\\n        \\n        else if(start<=low && end>=high) return tree[index];\\n        \\n        else{\\n            \\n            int mid = ( low + high  )/2;\\n            \\n            int left = query(low , mid , 2*index + 1 , start , end);\\n            \\n            int right = query(mid + 1 , high , 2*index +2 , start , end);\\n            \\n            return Math.max(left,right);\\n        }\\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    public int lengthOfLIS(int[] nums, int k) {\\n        \\n        tree = new int[400001];\\n        \\n        int res = 0;\\n        \\n        for(int i = 0;i<nums.length ; i++)\\n        {\\n            \\n            \\n           int ans =  query(0,100000,0,nums [i] -k ,  nums[i]-1);\\n            \\n           res = Math.max(ans+1,res);\\n            \\n           update(0,100000,0,nums[i],ans+1);\\n            \\n        }\\n        \\n        return res;\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    \\n    int tree [];\\n    \\n    int update(int low , int high , int index , int key , int value){\\n        \\n        if( low > key || key > high ) return tree [ index ];\\n        \\n        \\n        else if(low == high && low == key){\\n            \\n            return tree[index] = value;\\n        \\n        }\\n        \\n        else{\\n            \\n            \\n            int mid = ( low + high )/2;\\n            \\n            int left = update(low , mid , 2 * index + 1 , key , value);\\n            \\n            int right = update(mid+1 , high , 2 * index + 2 , key , value );\\n            \\n            return tree[index] = Math.max(left,right);\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    \\n    int query(int low , int high , int index , int start , int end)\\n    {\\n        \\n        if( low > end || high < start ) return 0;\\n        \\n        else if(start<=low && end>=high) return tree[index];\\n        \\n        else{\\n            \\n            int mid = ( low + high  )/2;\\n            \\n            int left = query(low , mid , 2*index + 1 , start , end);\\n            \\n            int right = query(mid + 1 , high , 2*index +2 , start , end);\\n            \\n            return Math.max(left,right);\\n        }\\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    public int lengthOfLIS(int[] nums, int k) {\\n        \\n        tree = new int[400001];\\n        \\n        int res = 0;\\n        \\n        for(int i = 0;i<nums.length ; i++)\\n        {\\n            \\n            \\n           int ans =  query(0,100000,0,nums [i] -k ,  nums[i]-1);\\n            \\n           res = Math.max(ans+1,res);\\n            \\n           update(0,100000,0,nums[i],ans+1);\\n            \\n        }\\n        \\n        return res;\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670036,
                "title": "helpppp",
                "content": "```\\nint seg[400008];\\n    \\n    //Important --> ye array se nahi bnare segment tree maxValue of array ke according bnana chahre segment tree kuki hmari range agar ele 5 hai aur k=7 to hume 6-12 tk ke numbers me kisse mas Lis bn skta use lena \\n    \\n    int build(int idx,int l,int h)\\n    {\\n        if(l==h)\\n            return seg[idx]=0; \\n        \\n        int mid=(l+h)/2;\\n        int left=build(2*idx+1,l,mid);\\n        int right=build(2*idx+2,mid+1,h);\\n        \\n        return seg[idx]=max(left,right);        \\n    }\\n    \\n    //queryLow and QueryHigh are those which are given to us in a particular query\\n    int query(int idx,int queryLow,int queryHigh,int l,int h)\\n    {\\n        if(queryLow>h or queryHigh<l)  //no overlapping\\n            return 0;\\n        \\n        if(queryLow>=l and queryHigh<=h)  //complete overlap\\n            return seg[idx];\\n        \\n        if(l==h)\\n            return seg[l];\\n        \\n        int mid=(l+h)/2;  \\n        \\n        int left=query(2*idx+1,queryLow,queryHigh,l,mid);  //partial overlap\\n        int right=query(2*idx+2,queryLow,queryHigh,mid+1,h);// check both sides\\n        \\n        return max(left,right);\\n    }\\n    void update(int idx,int l,int r,int indexToUpdate,int val)\\n    {\\n        if(l==r)\\n        {\\n            seg[idx]=val;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        \\n        if(indexToUpdate<=mid)\\n            update(2*idx+1,l,mid,indexToUpdate,val);\\n        else\\n            update(2*idx+2,mid+1,r,indexToUpdate,val);\\n        \\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        build(0,0,100000);\\n        int ans=0;\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int queryLow=min(nums[i]+1,100000);  //agar mai 8 hu aur k=5\\n            int queryHigh=min(nums[i]+k,100000);  // hai to l=9 and r=13 hoga\\n            \\n//Step 2 --> [9,13] me kiske pas max Value hai uske sath jodke khudko bda LIS bnaunga\\n            int maxLis=query(0,queryLow,queryHigh,0,100000);\\n            cout<<maxLis<<\" \";\\n            update(0,0,100000,nums[i],maxLis+1);\\n            ans=max(ans,maxLis+1);\\n            \\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint seg[400008];\\n    \\n    //Important --> ye array se nahi bnare segment tree maxValue of array ke according bnana chahre segment tree kuki hmari range agar ele 5 hai aur k=7 to hume 6-12 tk ke numbers me kisse mas Lis bn skta use lena \\n    \\n    int build(int idx,int l,int h)\\n    {\\n        if(l==h)\\n            return seg[idx]=0; \\n        \\n        int mid=(l+h)/2;\\n        int left=build(2*idx+1,l,mid);\\n        int right=build(2*idx+2,mid+1,h);\\n        \\n        return seg[idx]=max(left,right);        \\n    }\\n    \\n    //queryLow and QueryHigh are those which are given to us in a particular query\\n    int query(int idx,int queryLow,int queryHigh,int l,int h)\\n    {\\n        if(queryLow>h or queryHigh<l)  //no overlapping\\n            return 0;\\n        \\n        if(queryLow>=l and queryHigh<=h)  //complete overlap\\n            return seg[idx];\\n        \\n        if(l==h)\\n            return seg[l];\\n        \\n        int mid=(l+h)/2;  \\n        \\n        int left=query(2*idx+1,queryLow,queryHigh,l,mid);  //partial overlap\\n        int right=query(2*idx+2,queryLow,queryHigh,mid+1,h);// check both sides\\n        \\n        return max(left,right);\\n    }\\n    void update(int idx,int l,int r,int indexToUpdate,int val)\\n    {\\n        if(l==r)\\n        {\\n            seg[idx]=val;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        \\n        if(indexToUpdate<=mid)\\n            update(2*idx+1,l,mid,indexToUpdate,val);\\n        else\\n            update(2*idx+2,mid+1,r,indexToUpdate,val);\\n        \\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        build(0,0,100000);\\n        int ans=0;\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int queryLow=min(nums[i]+1,100000);  //agar mai 8 hu aur k=5\\n            int queryHigh=min(nums[i]+k,100000);  // hai to l=9 and r=13 hoga\\n            \\n//Step 2 --> [9,13] me kiske pas max Value hai uske sath jodke khudko bda LIS bnaunga\\n            int maxLis=query(0,queryLow,queryHigh,0,100000);\\n            cout<<maxLis<<\" \";\\n            update(0,0,100000,nums[i],maxLis+1);\\n            ans=max(ans,maxLis+1);\\n            \\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2666581,
                "title": "segment-tree-c",
                "content": "```\\nclass SegmentTree {\\nprivate:\\n    vector<int> st;\\n\\npublic:\\n    SegmentTree(int sz) {\\n        st.resize(4 * sz, 0);\\n    }\\n    \\n    void update(int idx, int l, int r, int num, int val) {        \\n        st[idx] = max(st[idx], val);\\n        int mid = (l + r) >> 1;\\n        if(l == r) return;\\n        \\n        if(num <= mid) update(idx * 2 + 1, l, mid, num, val);\\n        else update(idx * 2 + 2, mid + 1, r, num, val);\\n    }\\n    \\n    int query(int idx, int l, int r, int ql, int qr) {\\n        if(ql <= l && r <= qr) return st[idx]; // Query range overlaps current range\\n        if(ql > r || l > qr) return 0; // Query range is outside current range\\n        \\n        int mid = (l + r) >> 1; // Else\\n        return max(query(idx * 2 + 1, l, mid, ql, qr), query(idx * 2 + 2, mid + 1, r, ql, qr));\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int res = 0;\\n        SegmentTree st(1e5);\\n        \\n        for(int num: nums) {\\n            int val = st.query(0, 1, 1e5, num - k, num - 1);\\n            res = max(res, val + 1);\\n            st.update(0, 1, 1e5, num, val + 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree {\\nprivate:\\n    vector<int> st;\\n\\npublic:\\n    SegmentTree(int sz) {\\n        st.resize(4 * sz, 0);\\n    }\\n    \\n    void update(int idx, int l, int r, int num, int val) {        \\n        st[idx] = max(st[idx], val);\\n        int mid = (l + r) >> 1;\\n        if(l == r) return;\\n        \\n        if(num <= mid) update(idx * 2 + 1, l, mid, num, val);\\n        else update(idx * 2 + 2, mid + 1, r, num, val);\\n    }\\n    \\n    int query(int idx, int l, int r, int ql, int qr) {\\n        if(ql <= l && r <= qr) return st[idx]; // Query range overlaps current range\\n        if(ql > r || l > qr) return 0; // Query range is outside current range\\n        \\n        int mid = (l + r) >> 1; // Else\\n        return max(query(idx * 2 + 1, l, mid, ql, qr), query(idx * 2 + 2, mid + 1, r, ql, qr));\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int res = 0;\\n        SegmentTree st(1e5);\\n        \\n        for(int num: nums) {\\n            int val = st.query(0, 1, 1e5, num - k, num - 1);\\n            res = max(res, val + 1);\\n            st.update(0, 1, 1e5, num, val + 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640428,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> segtree;\\n    \\n    int BestRange(int start, int end) {\\n        int res = 0;\\n        start += 1e5 - 1;\\n        end += 1e5 - 1;\\n        \\n        while (start < end) {\\n            res = max({segtree[start], segtree[end], res});\\n            if (start % 2 == 0) start++;\\n            if (end % 2 == 1) end--;\\n            start = (start - 1) / 2;\\n            end = (end - 1) / 2;\\n        }\\n        \\n        if (start == end) res = max(segtree[start], res);\\n        \\n        return res;\\n    }\\n    \\n    void Update(int idx, int newlen) {\\n        idx += 1e5 - 1;\\n        while (idx >= 0) {\\n            segtree[idx] = max(newlen, segtree[idx]);\\n            if (idx == 0) idx = -1;\\n            else idx = (idx - 1) / 2;\\n        }\\n        return;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans = 0;\\n        n = nums.size();\\n        segtree.resize(2e5);\\n        \\n        for (int i = 0; i < n; i++) nums[i]--;\\n        \\n        for (int i : nums) {\\n            int longest = 1;\\n            if (i > 0) longest = BestRange(max(i - k, 0), i - 1) + 1;\\n            ans = max(longest, ans);\\n            Update(i, longest);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> segtree;\\n    \\n    int BestRange(int start, int end) {\\n        int res = 0;\\n        start += 1e5 - 1;\\n        end += 1e5 - 1;\\n        \\n        while (start < end) {\\n            res = max({segtree[start], segtree[end], res});\\n            if (start % 2 == 0) start++;\\n            if (end % 2 == 1) end--;\\n            start = (start - 1) / 2;\\n            end = (end - 1) / 2;\\n        }\\n        \\n        if (start == end) res = max(segtree[start], res);\\n        \\n        return res;\\n    }\\n    \\n    void Update(int idx, int newlen) {\\n        idx += 1e5 - 1;\\n        while (idx >= 0) {\\n            segtree[idx] = max(newlen, segtree[idx]);\\n            if (idx == 0) idx = -1;\\n            else idx = (idx - 1) / 2;\\n        }\\n        return;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans = 0;\\n        n = nums.size();\\n        segtree.resize(2e5);\\n        \\n        for (int i = 0; i < n; i++) nums[i]--;\\n        \\n        for (int i : nums) {\\n            int longest = 1;\\n            if (i > 0) longest = BestRange(max(i - k, 0), i - 1) + 1;\\n            ans = max(longest, ans);\\n            Update(i, longest);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635213,
                "title": "mini-version-8-lines-passes-80-cases",
                "content": "```\\npublic int lengthOfLIS(int[] nums, int k) {\\n        int[] dp=new int[100006];\\n        int ans=1;\\n        for(int num:nums)\\n        {\\n            for(int i=num-1;i>=Math.max(0,num-k);i--)\\n                dp[num]=Math.max(dp[i]+1,dp[num]);\\n            \\n            ans=Math.max(ans,dp[num]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int lengthOfLIS(int[] nums, int k) {\\n        int[] dp=new int[100006];\\n        int ans=1;\\n        for(int num:nums)\\n        {\\n            for(int i=num-1;i>=Math.max(0,num-k);i--)\\n                dp[num]=Math.max(dp[i]+1,dp[num]);\\n            \\n            ans=Math.max(ans,dp[num]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2618945,
                "title": "dart-recursive-segment-tree-solution",
                "content": "```\\nimport \\'dart:math\\';\\n\\nclass Segment {\\n  int total;\\n  Segment? left;\\n  Segment? right;\\n  int left_index;\\n  int right_index;\\n\\n  Segment({required this.total, required this.left_index, required this.right_index});\\n\\n  static init(int left, int right) {\\n    if (left == right) {\\n      return Segment(total: 0, left_index: left, right_index: right);\\n    }\\n    Segment root = Segment(total: 0, left_index: left, right_index: right);\\n    int mid = (left + right) ~/ 2;\\n    root.left = init(left, mid);\\n    root.right = init(mid + 1, right);\\n    return root;\\n  }\\n\\n  void update(int index, int val) {\\n    if (left_index == right_index) {\\n      total = val;\\n      return;\\n    }\\n    int mid = (left_index + right_index) ~/ 2;\\n    if (index <= mid) {\\n      left!.update(index, val);\\n    } else {\\n      right!.update(index, val);\\n    }\\n    total = max(left!.total, right!.total);\\n  }\\n\\n  int query(int left, int right) {\\n    if (left_index == left && right_index == right) {\\n      return total;\\n    }\\n    int mid = (left_index + right_index) ~/ 2;\\n    if (left > mid) {\\n      return this.right!.query(left, right);\\n    } else if (right <= mid) {\\n      return this.left!.query(left, right);\\n    } else {\\n      return max(this.left!.query(left, mid), this.right!.query(mid + 1, right));\\n    }\\n  }\\n}\\n\\nclass Solution {\\n  int lengthOfLIS(List<int> nums, int k) {\\n    int val = nums.fold(0, max);\\n    int res = 1;\\n    Segment tree = Segment.init(0, val);\\n    for (var num in nums) {\\n      int left = max(0, num - k);\\n      int count = tree.query(left, num - 1)+1;\\n      res = max(res, count);\\n      tree.update(num, count);\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nimport \\'dart:math\\';\\n\\nclass Segment {\\n  int total;\\n  Segment? left;\\n  Segment? right;\\n  int left_index;\\n  int right_index;\\n\\n  Segment({required this.total, required this.left_index, required this.right_index});\\n\\n  static init(int left, int right) {\\n    if (left == right) {\\n      return Segment(total: 0, left_index: left, right_index: right);\\n    }\\n    Segment root = Segment(total: 0, left_index: left, right_index: right);\\n    int mid = (left + right) ~/ 2;\\n    root.left = init(left, mid);\\n    root.right = init(mid + 1, right);\\n    return root;\\n  }\\n\\n  void update(int index, int val) {\\n    if (left_index == right_index) {\\n      total = val;\\n      return;\\n    }\\n    int mid = (left_index + right_index) ~/ 2;\\n    if (index <= mid) {\\n      left!.update(index, val);\\n    } else {\\n      right!.update(index, val);\\n    }\\n    total = max(left!.total, right!.total);\\n  }\\n\\n  int query(int left, int right) {\\n    if (left_index == left && right_index == right) {\\n      return total;\\n    }\\n    int mid = (left_index + right_index) ~/ 2;\\n    if (left > mid) {\\n      return this.right!.query(left, right);\\n    } else if (right <= mid) {\\n      return this.left!.query(left, right);\\n    } else {\\n      return max(this.left!.query(left, mid), this.right!.query(mid + 1, right));\\n    }\\n  }\\n}\\n\\nclass Solution {\\n  int lengthOfLIS(List<int> nums, int k) {\\n    int val = nums.fold(0, max);\\n    int res = 1;\\n    Segment tree = Segment.init(0, val);\\n    for (var num in nums) {\\n      int left = max(0, num - k);\\n      int count = tree.query(left, num - 1)+1;\\n      res = max(res, count);\\n      tree.update(num, count);\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618403,
                "title": "c-segment-tree",
                "content": "```\\nstruct SegTree {\\n    vector<int> t;\\n    SegTree(int n) {\\n        t.insert(t.end(),4*n + 1,0);\\n    }\\n    void build (vector<int> &a,int idx,int l, int r){\\n        if (l>r)\\n            return;\\n        if(l == r){\\n            t[idx] = a[l];\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(a,2*idx + 1,l,m);\\n        build(a,2*idx + 2,m+1,r);\\n        t[idx] = max(t[2*idx + 1],t[2*idx + 2]);\\n    }\\n    void insert(int val, int idx, int i,int l,int r){\\n        if (l>r)\\n            return;\\n        if(l == r && l == i){\\n            t[idx] = val;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        if(i >= l && i <= m)\\n            insert(val,2*idx + 1,i,l,m);\\n        else\\n            insert(val,2*idx + 2,i,m+1,r);\\n        t[idx] = max(t[2*idx + 1],t[2*idx + 2]);\\n    }\\n    int query(int idx,int l,int r,int ql,int qr){ \\n            if(l>qr || ql>r || l>r)\\n                return 0;\\n            if(l>=ql && r<=qr)\\n                return t[idx];\\n            int m = (l + r)/2;\\n            int v1 = query(2*idx + 1,l,m,ql,qr);\\n            int v2 = query(2*idx + 2,m+1,r,ql,qr);\\n            return max(v1,v2);\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int mx = 1e5;\\n        int ans = 1;\\n        int n = nums.size();\\n        SegTree t = SegTree(mx + 1);\\n        for(int i=n-1;i>=0;i--){\\n            int v = t.query(0,0,mx,nums[i]+1,min(mx,nums[i]+k));\\n            ans = max(ans,v+1);\\n            int prev = t.query(0,0,mx,nums[i],nums[i]);\\n            if(prev < v + 1)\\n                t.insert(v+1,0,nums[i],0,mx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstruct SegTree {\\n    vector<int> t;\\n    SegTree(int n) {\\n        t.insert(t.end(),4*n + 1,0);\\n    }\\n    void build (vector<int> &a,int idx,int l, int r){\\n        if (l>r)\\n            return;\\n        if(l == r){\\n            t[idx] = a[l];\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(a,2*idx + 1,l,m);\\n        build(a,2*idx + 2,m+1,r);\\n        t[idx] = max(t[2*idx + 1],t[2*idx + 2]);\\n    }\\n    void insert(int val, int idx, int i,int l,int r){\\n        if (l>r)\\n            return;\\n        if(l == r && l == i){\\n            t[idx] = val;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        if(i >= l && i <= m)\\n            insert(val,2*idx + 1,i,l,m);\\n        else\\n            insert(val,2*idx + 2,i,m+1,r);\\n        t[idx] = max(t[2*idx + 1],t[2*idx + 2]);\\n    }\\n    int query(int idx,int l,int r,int ql,int qr){ \\n            if(l>qr || ql>r || l>r)\\n                return 0;\\n            if(l>=ql && r<=qr)\\n                return t[idx];\\n            int m = (l + r)/2;\\n            int v1 = query(2*idx + 1,l,m,ql,qr);\\n            int v2 = query(2*idx + 2,m+1,r,ql,qr);\\n            return max(v1,v2);\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int mx = 1e5;\\n        int ans = 1;\\n        int n = nums.size();\\n        SegTree t = SegTree(mx + 1);\\n        for(int i=n-1;i>=0;i--){\\n            int v = t.query(0,0,mx,nums[i]+1,min(mx,nums[i]+k));\\n            ans = max(ans,v+1);\\n            int prev = t.query(0,0,mx,nums[i],nums[i]);\\n            if(prev < v + 1)\\n                t.insert(v+1,0,nums[i],0,mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609907,
                "title": "c-segment-tree",
                "content": "```\\nvector<int> t;\\nint sum(int v, int tl, int tr, int l, int r) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr) {\\n        return t[v];\\n    }\\n    int tm = (tl + tr) / 2;\\n    return max(sum(v*2, tl, tm, l, min(r, tm)),sum(v*2+1, tm+1, tr, max(l, tm+1), r));\\n} \\nvoid update(int v, int tl, int tr, int pos, int new_val) {\\n    if (tl == tr) {\\n        t[v] =max(new_val,t[v]);\\n    } else {\\n        int tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update(v*2, tl, tm, pos, new_val);\\n        else\\n            update(v*2+1, tm+1, tr, pos, new_val);\\n        t[v] = max(t[v*2], t[v*2+1]);\\n    }\\n}\\nclass Solution {\\npublic:\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        t.assign(4*(100000+2),0);\\n        \\n        for(int i:nums){\\n            int x=sum(1,0,100000,max(0,i-k),i-1);\\n            \\n            update(1,0,100000,i,x+1);\\n        }\\n        \\n        return t[1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> t;\\nint sum(int v, int tl, int tr, int l, int r) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr) {\\n        return t[v];\\n    }\\n    int tm = (tl + tr) / 2;\\n    return max(sum(v*2, tl, tm, l, min(r, tm)),sum(v*2+1, tm+1, tr, max(l, tm+1), r));\\n} \\nvoid update(int v, int tl, int tr, int pos, int new_val) {\\n    if (tl == tr) {\\n        t[v] =max(new_val,t[v]);\\n    } else {\\n        int tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update(v*2, tl, tm, pos, new_val);\\n        else\\n            update(v*2+1, tm+1, tr, pos, new_val);\\n        t[v] = max(t[v*2], t[v*2+1]);\\n    }\\n}\\nclass Solution {\\npublic:\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        t.assign(4*(100000+2),0);\\n        \\n        for(int i:nums){\\n            int x=sum(1,0,100000,max(0,i-k),i-1);\\n            \\n            update(1,0,100000,i,x+1);\\n        }\\n        \\n        return t[1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606201,
                "title": "c-segment-tree-range-max-query",
                "content": "```\\nclass Solution {\\n    vector<int> tree;\\n    \\n    int get_max(int i, int sl, int sr, int l, int r) {\\n        if(sl >= l && sr <= r)          // total overlap\\n            return tree[i];\\n        else if(sr < l || r < sl)       // no overlap;\\n            return INT_MIN;\\n\\n        int mid = (sl + sr) / 2;\\n        return max(get_max(2*i+1, sl, mid, l, r), get_max(2*i+2, mid+1, sr, l, r));\\n    }\\n\\n    void update(int i, int sl, int sr, int pos, int val) {\\n        if(sl == sr) {                           //update in the leaf node of the tree\\n            tree[i] = val;\\n            return;\\n        }\\n\\n        int mid = (sl + sr) / 2;\\n        if(pos <= mid) \\n            update(2*i+1, sl, mid, pos, val);\\n        else \\n            update(2*i+2, mid+1, sr, pos, val);\\n\\n        tree[i] = max(tree[2*i+1], tree[2*i+2]);  //update intermediate nodes after returning the value of the leaf node\\n    }\\n\\n    int get_max(int l, int r, int n) {\\n        return get_max(0, 0, n-1, l, r);\\n    }\\n\\n    void update(int pos, int val, int n) {\\n        update(0, 0, n-1, pos, val);\\n    }\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int N = 1e5 + 5;\\n        tree.resize(4*N);\\n            \\n        // Same concept as n^2 LIS dp\\n        // Following implementation also applicable for general LIS dp problem\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int l = max(0, nums[i]-k);\\n            int r = nums[i]-1;\\n            int mx = get_max(l, r, N);\\n            update(nums[i], 1+mx, N);\\n        }\\n        \\n        return get_max(0, N-1, N);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> tree;\\n    \\n    int get_max(int i, int sl, int sr, int l, int r) {\\n        if(sl >= l && sr <= r)          // total overlap\\n            return tree[i];\\n        else if(sr < l || r < sl)       // no overlap;\\n            return INT_MIN;\\n\\n        int mid = (sl + sr) / 2;\\n        return max(get_max(2*i+1, sl, mid, l, r), get_max(2*i+2, mid+1, sr, l, r));\\n    }\\n\\n    void update(int i, int sl, int sr, int pos, int val) {\\n        if(sl == sr) {                           //update in the leaf node of the tree\\n            tree[i] = val;\\n            return;\\n        }\\n\\n        int mid = (sl + sr) / 2;\\n        if(pos <= mid) \\n            update(2*i+1, sl, mid, pos, val);\\n        else \\n            update(2*i+2, mid+1, sr, pos, val);\\n\\n        tree[i] = max(tree[2*i+1], tree[2*i+2]);  //update intermediate nodes after returning the value of the leaf node\\n    }\\n\\n    int get_max(int l, int r, int n) {\\n        return get_max(0, 0, n-1, l, r);\\n    }\\n\\n    void update(int pos, int val, int n) {\\n        update(0, 0, n-1, pos, val);\\n    }\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int N = 1e5 + 5;\\n        tree.resize(4*N);\\n            \\n        // Same concept as n^2 LIS dp\\n        // Following implementation also applicable for general LIS dp problem\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int l = max(0, nums[i]-k);\\n            int r = nums[i]-1;\\n            int mx = get_max(l, r, N);\\n            update(nums[i], 1+mx, N);\\n        }\\n        \\n        return get_max(0, N-1, N);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604956,
                "title": "clean-segment-tree-code",
                "content": "```\\nclass Solution {\\n    vector<int> seg;\\n    int maxInRange(int node, int start, int end, int r1, int r2) {\\n        if(r1 <= start && end <= r2) {\\n            return seg[node];\\n        } else if(end < r1 || r2 < start) {\\n            return 0;\\n        }\\n        int mid = start + (end - start)/2;\\n        int lans = maxInRange(node*2 + 1, start, mid, r1, r2);\\n        int rans = maxInRange(node*2 + 2, mid + 1, end, r1, r2);\\n        return max(lans, rans);\\n    }\\n    \\n    void update(int node, int start, int end, int idx, int val) {\\n        if(start == end) {\\n            seg[node] = val;\\n        } else {\\n            int mid = start + (end - start)/2;\\n            if(idx <= mid) {\\n                update(node*2 + 1, start, mid, idx, val);\\n            } else {\\n                update(node*2 + 2, mid + 1, end, idx, val);\\n            }\\n            seg[node] = max(seg[2*node + 1], seg[2*node + 2]);\\n        }\\n    }\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size(), res = 1;\\n        seg.resize(400004,0);\\n        for(int i = 0;i < n;i++) {\\n            int currans = 1 + maxInRange(0, 0, 100000, max(0,nums[i]-k),nums[i]-1);\\n            update(0, 0, 100000, nums[i], currans);\\n            res = max(res, currans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> seg;\\n    int maxInRange(int node, int start, int end, int r1, int r2) {\\n        if(r1 <= start && end <= r2) {\\n            return seg[node];\\n        } else if(end < r1 || r2 < start) {\\n            return 0;\\n        }\\n        int mid = start + (end - start)/2;\\n        int lans = maxInRange(node*2 + 1, start, mid, r1, r2);\\n        int rans = maxInRange(node*2 + 2, mid + 1, end, r1, r2);\\n        return max(lans, rans);\\n    }\\n    \\n    void update(int node, int start, int end, int idx, int val) {\\n        if(start == end) {\\n            seg[node] = val;\\n        } else {\\n            int mid = start + (end - start)/2;\\n            if(idx <= mid) {\\n                update(node*2 + 1, start, mid, idx, val);\\n            } else {\\n                update(node*2 + 2, mid + 1, end, idx, val);\\n            }\\n            seg[node] = max(seg[2*node + 1], seg[2*node + 2]);\\n        }\\n    }\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size(), res = 1;\\n        seg.resize(400004,0);\\n        for(int i = 0;i < n;i++) {\\n            int currans = 1 + maxInRange(0, 0, 100000, max(0,nums[i]-k),nums[i]-1);\\n            update(0, 0, 100000, nums[i], currans);\\n            res = max(res, currans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598941,
                "title": "tc-100-o-nlogn-segment-tree-range-query-python",
                "content": "```\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        #because nums[i] <= 10^5, we can use a segment tree\\n        #where the size of the tree = max(nums) + 1, so that idx == value\\n        #u can use range queries to find elements within distance k in logarithmic time\\n        #the key(or index) is nums[i] and value is the longest subsequnece ending with nums[i]\\n        \\n        #below is the typical code for array implementation of segement tree (its the fastest implementation)\\n        n = max(nums) + 1\\n        \\n        segmentTree = [0]*(n*2)\\n        \\n        def update(idx, value):\\n            idx += n\\n            segmentTree[idx] = value\\n            \\n            while idx > 1:\\n                idx >>= 1\\n                segmentTree[idx] = max(segmentTree[idx<<1], segmentTree[idx<<1 | 1])\\n        \\n        #left is inclusive, right is exclusive\\n        def getMax(left, right):\\n            left += n; right += n\\n            \\n            Max = segmentTree[left]\\n            \\n            while left < right:\\n                if left & 1:\\n                    Max = max(Max, segmentTree[left])\\n                    left += 1\\n                if right & 1:\\n                    right -= 1\\n                    Max = max(Max, segmentTree[right])\\n                \\n                left>>=1; right>>=1\\n            \\n            return Max\\n        \\n        for num in nums:\\n            prevLongestSubsequence = getMax(max(num-k, 0), num)\\n            update(num, prevLongestSubsequence + 1)\\n        \\n        return segmentTree[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        #because nums[i] <= 10^5, we can use a segment tree\\n        #where the size of the tree = max(nums) + 1, so that idx == value\\n        #u can use range queries to find elements within distance k in logarithmic time\\n        #the key(or index) is nums[i] and value is the longest subsequnece ending with nums[i]\\n        \\n        #below is the typical code for array implementation of segement tree (its the fastest implementation)\\n        n = max(nums) + 1\\n        \\n        segmentTree = [0]*(n*2)\\n        \\n        def update(idx, value):\\n            idx += n\\n            segmentTree[idx] = value\\n            \\n            while idx > 1:\\n                idx >>= 1\\n                segmentTree[idx] = max(segmentTree[idx<<1], segmentTree[idx<<1 | 1])\\n        \\n        #left is inclusive, right is exclusive\\n        def getMax(left, right):\\n            left += n; right += n\\n            \\n            Max = segmentTree[left]\\n            \\n            while left < right:\\n                if left & 1:\\n                    Max = max(Max, segmentTree[left])\\n                    left += 1\\n                if right & 1:\\n                    right -= 1\\n                    Max = max(Max, segmentTree[right])\\n                \\n                left>>=1; right>>=1\\n            \\n            return Max\\n        \\n        for num in nums:\\n            prevLongestSubsequence = getMax(max(num-k, 0), num)\\n            update(num, prevLongestSubsequence + 1)\\n        \\n        return segmentTree[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2589572,
                "title": "c-segment-tree-solution",
                "content": "Other answers have been extremely helpful for me to be able to solve this.\\n```\\nclass Solution {\\npublic:\\n  struct SegmentTree {\\n    int lis = 0;\\n    int begin, end;\\n    SegmentTree *left = nullptr, *right = nullptr;\\n    \\n    SegmentTree(int begin, int end) : begin(begin), end(end) {}\\n    \\n    int update(int val, int lis) {\\n      if (begin == end - 1 && val == begin) {\\n        this->lis = max(this->lis, lis);\\n        return this->lis;\\n      }\\n      int mid = (begin + end) / 2;\\n      if (val < mid) {\\n        if (left == nullptr) {\\n          left = new SegmentTree(begin, mid);\\n        }\\n        left->update(val, lis);\\n      } else {\\n        if (right == nullptr) {\\n          right = new SegmentTree(mid, end);\\n        }\\n        right->update(val, lis);\\n      }\\n      if (left && right) {\\n        this->lis = max(this->lis, max(left->lis, right->lis));\\n      } else if (left) {\\n        this->lis = max(this->lis, left->lis);\\n      } else if (right) {\\n        this->lis = max(this->lis, right->lis);\\n      }\\n      return this->lis;\\n    }\\n    \\n    int getRangeMax(int rangeBegin, int rangeEnd) {\\n      if (begin == rangeBegin && end == rangeEnd) {\\n        return lis;\\n      }\\n      int mid = (begin + end) / 2;\\n      if (left == nullptr) {\\n        left = new SegmentTree(begin, mid);\\n      }\\n      if (right == nullptr) {\\n        right = new SegmentTree(mid, end);\\n      }\\n      if (rangeEnd <= mid) {\\n        return left->getRangeMax(rangeBegin, rangeEnd);\\n      } else if (rangeBegin >= mid) {\\n        return right->getRangeMax(rangeBegin, rangeEnd);\\n      } else {\\n        return max(left->getRangeMax(rangeBegin, mid),\\n                   right->getRangeMax(mid, rangeEnd));\\n      }\\n    }\\n    \\n    ~SegmentTree() {\\n      delete left;\\n      delete right;\\n    }\\n  };\\n  \\n  int lengthOfLIS(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    int lis = 0;\\n    \\n    int begin = 0;\\n    int end = pow(2, ceil(log2(*max_element(nums.begin(), nums.end()) + 1)));\\n    SegmentTree segment_tr(begin, end);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int cur_lis = 1 + segment_tr.getRangeMax(max(nums[i] - k, 0), nums[i]);\\n      lis = max(lis, segment_tr.update(nums[i], cur_lis));\\n    }\\n    \\n    return lis;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  struct SegmentTree {\\n    int lis = 0;\\n    int begin, end;\\n    SegmentTree *left = nullptr, *right = nullptr;\\n    \\n    SegmentTree(int begin, int end) : begin(begin), end(end) {}\\n    \\n    int update(int val, int lis) {\\n      if (begin == end - 1 && val == begin) {\\n        this->lis = max(this->lis, lis);\\n        return this->lis;\\n      }\\n      int mid = (begin + end) / 2;\\n      if (val < mid) {\\n        if (left == nullptr) {\\n          left = new SegmentTree(begin, mid);\\n        }\\n        left->update(val, lis);\\n      } else {\\n        if (right == nullptr) {\\n          right = new SegmentTree(mid, end);\\n        }\\n        right->update(val, lis);\\n      }\\n      if (left && right) {\\n        this->lis = max(this->lis, max(left->lis, right->lis));\\n      } else if (left) {\\n        this->lis = max(this->lis, left->lis);\\n      } else if (right) {\\n        this->lis = max(this->lis, right->lis);\\n      }\\n      return this->lis;\\n    }\\n    \\n    int getRangeMax(int rangeBegin, int rangeEnd) {\\n      if (begin == rangeBegin && end == rangeEnd) {\\n        return lis;\\n      }\\n      int mid = (begin + end) / 2;\\n      if (left == nullptr) {\\n        left = new SegmentTree(begin, mid);\\n      }\\n      if (right == nullptr) {\\n        right = new SegmentTree(mid, end);\\n      }\\n      if (rangeEnd <= mid) {\\n        return left->getRangeMax(rangeBegin, rangeEnd);\\n      } else if (rangeBegin >= mid) {\\n        return right->getRangeMax(rangeBegin, rangeEnd);\\n      } else {\\n        return max(left->getRangeMax(rangeBegin, mid),\\n                   right->getRangeMax(mid, rangeEnd));\\n      }\\n    }\\n    \\n    ~SegmentTree() {\\n      delete left;\\n      delete right;\\n    }\\n  };\\n  \\n  int lengthOfLIS(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    int lis = 0;\\n    \\n    int begin = 0;\\n    int end = pow(2, ceil(log2(*max_element(nums.begin(), nums.end()) + 1)));\\n    SegmentTree segment_tr(begin, end);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int cur_lis = 1 + segment_tr.getRangeMax(max(nums[i] - k, 0), nums[i]);\\n      lis = max(lis, segment_tr.update(nums[i], cur_lis));\\n    }\\n    \\n    return lis;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588966,
                "title": "c-solution-segment-tree",
                "content": "```\\nclass Solution {\\n    class SegTree {\\n        static constexpr int t = 100001;\\n        int seg[200002] = {0};\\n        \\n        public:\\n        void update(int d, int n) {\\n            d += t;\\n            seg[d] = n;\\n            while (d) {\\n                d >>= 1;\\n                seg[d] = max(seg[2 * d], seg[2 * d + 1]);\\n            }\\n        }\\n        \\n        int query(int l, int r) {\\n            l += t;\\n            r += t;\\n            int result = 0;\\n            while (l < r) {\\n                if (l & 1)\\n                    result = max(result, seg[l++]);\\n                if (r & 1)\\n                    result = max(result, seg[--r]);\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            return result;\\n        }\\n    };\\n    \\npublic:\\n    static int lengthOfLIS(const vector<int>& nums, const int k) {\\n        int ret = 0;\\n        SegTree st;\\n        for (auto i : nums) {\\n            int c = st.query(max(i - k, 0), i) + 1;\\n            ret = max(ret, c);\\n            st.update(i, c);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class SegTree {\\n        static constexpr int t = 100001;\\n        int seg[200002] = {0};\\n        \\n        public:\\n        void update(int d, int n) {\\n            d += t;\\n            seg[d] = n;\\n            while (d) {\\n                d >>= 1;\\n                seg[d] = max(seg[2 * d], seg[2 * d + 1]);\\n            }\\n        }\\n        \\n        int query(int l, int r) {\\n            l += t;\\n            r += t;\\n            int result = 0;\\n            while (l < r) {\\n                if (l & 1)\\n                    result = max(result, seg[l++]);\\n                if (r & 1)\\n                    result = max(result, seg[--r]);\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            return result;\\n        }\\n    };\\n    \\npublic:\\n    static int lengthOfLIS(const vector<int>& nums, const int k) {\\n        int ret = 0;\\n        SegTree st;\\n        for (auto i : nums) {\\n            int c = st.query(max(i - k, 0), i) + 1;\\n            ret = max(ret, c);\\n            st.update(i, c);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581355,
                "title": "python-segment-tree-broken-up-into-separate-lists",
                "content": "I only glanced at the concept of segment trees before starting. I didn\\'t realize that you could put the entire tree in one list.\\n\\nInstead I broke it up into 18 lists, each one half the size of the previous.\\n\\n\\n````\\nsegment_tree_depth = 18\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums, k: int) -> int:\\n        if not nums:\\n            return 0\\n        segmentLists = [[0]*(2**i) for i in range(segment_tree_depth-1, -1, -1)]\\n        for n in nums:\\n            # Get the maximum value below n\\n            rangeStart,rangeEndExclusive = max(n-k, 0), n\\n            max_undervalue = 0\\n            for l in segmentLists:\\n                if rangeStart == rangeEndExclusive:\\n                    break\\n                if rangeStart % 2 != 0:\\n                    max_undervalue = max(max_undervalue, l[rangeStart])\\n                    rangeStart += 1\\n                if rangeEndExclusive % 2 != 0:\\n                    max_undervalue = max(max_undervalue, l[rangeEndExclusive-1])\\n                    rangeEndExclusive -= 1\\n                rangeStart //= 2\\n                rangeEndExclusive //= 2\\n            # Now set it if it\\'s bigger than the existing\\n            new_value = max_undervalue + 1\\n            for l in segmentLists:\\n                if new_value > l[n]:\\n                    l[n] = new_value\\n                else:\\n                    break\\n                n //= 2\\n\\n        return segmentLists[-1][0]\\n````",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "````\\nsegment_tree_depth = 18\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums, k: int) -> int:\\n        if not nums:\\n            return 0\\n        segmentLists = [[0]*(2**i) for i in range(segment_tree_depth-1, -1, -1)]\\n        for n in nums:\\n            # Get the maximum value below n\\n            rangeStart,rangeEndExclusive = max(n-k, 0), n\\n            max_undervalue = 0\\n            for l in segmentLists:\\n                if rangeStart == rangeEndExclusive:\\n                    break\\n                if rangeStart % 2 != 0:\\n                    max_undervalue = max(max_undervalue, l[rangeStart])\\n                    rangeStart += 1\\n                if rangeEndExclusive % 2 != 0:\\n                    max_undervalue = max(max_undervalue, l[rangeEndExclusive-1])\\n                    rangeEndExclusive -= 1\\n                rangeStart //= 2\\n                rangeEndExclusive //= 2\\n            # Now set it if it\\'s bigger than the existing\\n            new_value = max_undervalue + 1\\n            for l in segmentLists:\\n                if new_value > l[n]:\\n                    l[n] = new_value\\n                else:\\n                    break\\n                n //= 2\\n\\n        return segmentLists[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576750,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int tree[400100];\\n\\n    int range(int idx,int ss,int se,int qs,int qe){\\n        \\n        if(ss>se || qs>se || qe<ss)return INT_MIN;\\n        \\n        if(ss>=qs && se<=qe)return tree[idx];\\n        \\n        int mid=ss+(se-ss)/2;\\n       \\n        return max( range(2*idx,ss,mid,qs,qe),range(2*idx+1,mid+1,se,qs,qe));\\n        \\n    }\\n    \\n     void update(int idx,int ss,int se,int i,int val){\\n        \\n        if(i<ss || i>se)return ;\\n        \\n        if(ss==se){\\n            tree[idx]=val;\\n            return ;\\n        }\\n        \\n        int mid=ss+(se-ss)/2;\\n        \\n        update(2*idx,ss,mid,i,val);\\n        update(2*idx+1,mid+1,se,i,val);\\n          \\n        tree[idx]=max(tree[2*idx],tree[2*idx+1]);\\n        return;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        int mx=*max_element(begin(nums),end(nums));\\n        int ans=1;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n           int x= range(1,0,mx,max(0,nums[i]-k),nums[i]-1);\\n           update(1,0,mx,nums[i],x+1);\\n           ans=max(ans,x+1);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tree[400100];\\n\\n    int range(int idx,int ss,int se,int qs,int qe){\\n        \\n        if(ss>se || qs>se || qe<ss)return INT_MIN;\\n        \\n        if(ss>=qs && se<=qe)return tree[idx];\\n        \\n        int mid=ss+(se-ss)/2;\\n       \\n        return max( range(2*idx,ss,mid,qs,qe),range(2*idx+1,mid+1,se,qs,qe));\\n        \\n    }\\n    \\n     void update(int idx,int ss,int se,int i,int val){\\n        \\n        if(i<ss || i>se)return ;\\n        \\n        if(ss==se){\\n            tree[idx]=val;\\n            return ;\\n        }\\n        \\n        int mid=ss+(se-ss)/2;\\n        \\n        update(2*idx,ss,mid,i,val);\\n        update(2*idx+1,mid+1,se,i,val);\\n          \\n        tree[idx]=max(tree[2*idx],tree[2*idx+1]);\\n        return;\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        int mx=*max_element(begin(nums),end(nums));\\n        int ans=1;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n           int x= range(1,0,mx,max(0,nums[i]-k),nums[i]-1);\\n           update(1,0,mx,nums[i],x+1);\\n           ans=max(ans,x+1);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574746,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct SegTree{\\n      \\n        struct Node{\\n            int l, r, m, v;\\n            Node(): v(0) {}\\n            Node(int l, int r, int m, int v): l(l), r(r), m(m), v(v) {}\\n        };\\n        \\n        Node t[400010];\\n        \\n        void build(int idx, int l, int r){\\n            int m = l + (r-l)/2;\\n            t[idx] = Node(l, r, m, 0);\\n            if(l == r) return;\\n            \\n            build(2*idx, l, m);\\n            build(2*idx+1, m+1, r);\\n        }        \\n        \\n        int query(int idx, int ql, int qr){\\n            if(ql > qr) return 0;\\n            Node cur = t[idx];\\n            if(ql <= cur.l && qr >= cur.r) return cur.v; \\n       \\n            return max(query(2*idx, ql, min(qr, cur.m)), query(2*idx+1, max(ql, cur.m+1), qr));\\n        }\\n        \\n        void update(int idx, int at, int v){\\n            Node cur = t[idx];\\n            \\n            if(cur.l == at && cur.r == at){ \\n                cur.v = t[idx].v = v;\\n                return; \\n            }\\n            if(cur.l == cur.r) return;\\n            \\n            if(at <= cur.m) update(2*idx, at, v);\\n            else update(2*idx+1, at, v);\\n            \\n            t[idx].v = max(t[2*idx].v, t[2*idx+1].v);\\n        }\\n    };\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree tree = SegTree();\\n        tree.build(1, 1, 100000);\\n        \\n        for(int x : nums){\\n            int q = tree.query(1, max(x - k, 1), x-1);\\n            tree.update(1, x, q+1);\\n        }\\n        \\n        int ans = 0;\\n        for(auto x : tree.t)\\n            if(x.l == x.r)  ans = max(ans, x.v); \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct SegTree{\\n      \\n        struct Node{\\n            int l, r, m, v;\\n            Node(): v(0) {}\\n            Node(int l, int r, int m, int v): l(l), r(r), m(m), v(v) {}\\n        };\\n        \\n        Node t[400010];\\n        \\n        void build(int idx, int l, int r){\\n            int m = l + (r-l)/2;\\n            t[idx] = Node(l, r, m, 0);\\n            if(l == r) return;\\n            \\n            build(2*idx, l, m);\\n            build(2*idx+1, m+1, r);\\n        }        \\n        \\n        int query(int idx, int ql, int qr){\\n            if(ql > qr) return 0;\\n            Node cur = t[idx];\\n            if(ql <= cur.l && qr >= cur.r) return cur.v; \\n       \\n            return max(query(2*idx, ql, min(qr, cur.m)), query(2*idx+1, max(ql, cur.m+1), qr));\\n        }\\n        \\n        void update(int idx, int at, int v){\\n            Node cur = t[idx];\\n            \\n            if(cur.l == at && cur.r == at){ \\n                cur.v = t[idx].v = v;\\n                return; \\n            }\\n            if(cur.l == cur.r) return;\\n            \\n            if(at <= cur.m) update(2*idx, at, v);\\n            else update(2*idx+1, at, v);\\n            \\n            t[idx].v = max(t[2*idx].v, t[2*idx+1].v);\\n        }\\n    };\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree tree = SegTree();\\n        tree.build(1, 1, 100000);\\n        \\n        for(int x : nums){\\n            int q = tree.query(1, max(x - k, 1), x-1);\\n            tree.update(1, x, q+1);\\n        }\\n        \\n        int ans = 0;\\n        for(auto x : tree.t)\\n            if(x.l == x.r)  ans = max(ans, x.v); \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574698,
                "title": "c-go-python-range-query-and-point-update-on-efficient-iterative-segment-tree-array-o-nlogn",
                "content": "*C++*\\n\\n```c++\\nint lengthOfLIS(vector<int> &nums, int k) {\\n    int T[200002] = {};                                                     // init tree\\n    for (int &num : nums) {                                                 // update tree\\n        int x = 0, i = num + 100001;\\n        for (int l = max(i - k, 100001), r = i; l < r; l >>= 1, r >>= 1) {  // range query\\n            if (l & 1) x = max(x, T[l++]);\\n            if (r & 1) x = max(x, T[--r]);\\n        }\\n        for (T[i] = x + 1; i > 1; i >>= 1) T[i >> 1] = max(T[i], T[i ^ 1]); // point update\\n    }\\n    return T[1];                                                            // root value\\n}\\n```\\n\\n*Go* in 77ms beat 100% :)\\n\\n```go\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n\\tvar T [200002]int\\n\\tfor _, num := range nums {\\n\\t\\tx, i := 0, num+100001\\n\\t\\tfor l, r := max(i-k, 100001), i; l < r; l, r = l>>1, r>>1 {\\n\\t\\t\\tif l&1 == 1 {\\n\\t\\t\\t\\tx = max(x, T[l])\\n\\t\\t\\t\\tl++\\n\\t\\t\\t}\\n\\t\\t\\tif r&1 == 1 {\\n\\t\\t\\t\\tr--\\n\\t\\t\\t\\tx = max(x, T[r])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor T[i] = x + 1; i > 1; i >>= 1 {\\n\\t\\t\\tT[i>>1] = max(T[i], T[i^1])\\n\\t\\t}\\n\\t}\\n\\treturn T[1]\\n}\\n```\\n\\n*Python*\\n\\n```python\\ndef lengthOfLIS(self, nums, k):\\n    T = [0] * 200002\\n    for num in nums:\\n        x, i = 0, num + 100001\\n        l, r = max(i - k, 100001), i\\n        while l < r:\\n            if l & 1:\\n                x = max(x, T[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                x = max(x, T[r])\\n            l >>= 1\\n            r >>= 1\\n        T[i] = x + 1\\n        while i > 1:\\n            T[i >> 1] = max(T[i], T[i ^ 1])\\n            i >>= 1\\n    return T[1]\\n```",
                "solutionTags": [],
                "code": "```c++\\nint lengthOfLIS(vector<int> &nums, int k) {\\n    int T[200002] = {};                                                     // init tree\\n    for (int &num : nums) {                                                 // update tree\\n        int x = 0, i = num + 100001;\\n        for (int l = max(i - k, 100001), r = i; l < r; l >>= 1, r >>= 1) {  // range query\\n            if (l & 1) x = max(x, T[l++]);\\n            if (r & 1) x = max(x, T[--r]);\\n        }\\n        for (T[i] = x + 1; i > 1; i >>= 1) T[i >> 1] = max(T[i], T[i ^ 1]); // point update\\n    }\\n    return T[1];                                                            // root value\\n}\\n```\n```go\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n\\tvar T [200002]int\\n\\tfor _, num := range nums {\\n\\t\\tx, i := 0, num+100001\\n\\t\\tfor l, r := max(i-k, 100001), i; l < r; l, r = l>>1, r>>1 {\\n\\t\\t\\tif l&1 == 1 {\\n\\t\\t\\t\\tx = max(x, T[l])\\n\\t\\t\\t\\tl++\\n\\t\\t\\t}\\n\\t\\t\\tif r&1 == 1 {\\n\\t\\t\\t\\tr--\\n\\t\\t\\t\\tx = max(x, T[r])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor T[i] = x + 1; i > 1; i >>= 1 {\\n\\t\\t\\tT[i>>1] = max(T[i], T[i^1])\\n\\t\\t}\\n\\t}\\n\\treturn T[1]\\n}\\n```\n```python\\ndef lengthOfLIS(self, nums, k):\\n    T = [0] * 200002\\n    for num in nums:\\n        x, i = 0, num + 100001\\n        l, r = max(i - k, 100001), i\\n        while l < r:\\n            if l & 1:\\n                x = max(x, T[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                x = max(x, T[r])\\n            l >>= 1\\n            r >>= 1\\n        T[i] = x + 1\\n        while i > 1:\\n            T[i >> 1] = max(T[i], T[i ^ 1])\\n            i >>= 1\\n    return T[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2573049,
                "title": "python-solution",
                "content": "By solving this problem I learned a new concept, segment tree. I was calling it a trie to myself while solving it. Too bad I couldn\\'t do it in the allotted time.\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        \\n        ml=[[] for i in range(6)]\\n        ml[0]=1\\n        ml[1]=[0]*11\\n        ml[2]=[0]*101\\n        ml[3]=[0]*1001\\n        ml[4]=[0]*10001\\n        ml[5]=[0]*100001\\n        \\n        n=nums[0]\\n        ml[5][n]=1\\n        ml[4][n//10]=1\\n        ml[3][n//100]=1\\n        ml[2][n//1000]=1\\n        ml[1][n//10000]=1\\n        for n in nums[1:]:\\n            pos1=max(0, n-k)\\n            mx=0\\n            for i in range((pos1-1)//10000+1, n//10000):\\n                if ml[1][i]>mx:\\n                    mx=ml[1][i]\\n            if k//10000>1:\\n                for i in range((pos1-1)//1000+1, ((pos1-1)//10000+1)*10):\\n                    if ml[2][i]>mx:\\n                        mx=ml[2][i]\\n                for i in range((n//10000)*10, n//1000):\\n                    if ml[2][i]>mx:\\n                        mx=ml[2][i]\\n            else:\\n                for i in range((pos1-1)//1000+1, n//1000):\\n                    if ml[2][i]>mx:\\n                        mx=ml[2][i]\\n            if k//1000>1:\\n                for i in range((pos1-1)//100+1, ((pos1-1)//1000+1)*10):\\n                    if ml[3][i]>mx:\\n                        mx=ml[3][i]\\n                for i in range((n//1000)*10, n//100):\\n                    if ml[3][i]>mx:\\n                        mx=ml[3][i]\\n            else:\\n                for i in range((pos1-1)//100+1, n//100):\\n                    if ml[3][i]>mx:\\n                        mx=ml[3][i]\\n            if k//100>1:\\n                for i in range((pos1-1)//10+1, ((pos1-1)//100+1)*10):\\n                    if ml[4][i]>mx:\\n                        mx=ml[4][i]\\n                for i in range((n//100)*10, n//10):\\n                    if ml[4][i]>mx:\\n                        mx=ml[4][i]\\n            else:\\n                for i in range((pos1-1)//10+1, n//10):\\n                    if ml[4][i]>mx:\\n                        mx=ml[4][i]\\n            if k//10>1:\\n                for i in range(pos1, ((pos1-1)//10+1)*10):\\n                    if ml[5][i]>mx:\\n                        mx=ml[5][i]\\n                for i in range((n//10)*10, n):\\n                    if ml[5][i]>mx:\\n                        mx=ml[5][i]\\n            else:\\n                for i in range(pos1, n):\\n                    if ml[5][i]>mx:\\n                        mx=ml[5][i]\\n            mx+=1\\n            if mx>ml[5][n]:\\n                ml[5][n]=mx\\n            if mx>ml[4][n//10]:\\n                ml[4][n//10]=mx\\n            if mx>ml[3][n//100]:\\n                ml[3][n//100]=mx\\n            if mx>ml[2][n//1000]:\\n                ml[2][n//1000]=mx\\n            if mx>ml[1][n//10000]:\\n                ml[1][n//10000]=mx\\n            if mx>ml[0]:\\n                ml[0]=mx\\n        return ml[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        \\n        ml=[[] for i in range(6)]\\n        ml[0]=1\\n        ml[1]=[0]*11\\n        ml[2]=[0]*101\\n        ml[3]=[0]*1001\\n        ml[4]=[0]*10001\\n        ml[5]=[0]*100001\\n        \\n        n=nums[0]\\n        ml[5][n]=1\\n        ml[4][n//10]=1\\n        ml[3][n//100]=1\\n        ml[2][n//1000]=1\\n        ml[1][n//10000]=1\\n        for n in nums[1:]:\\n            pos1=max(0, n-k)\\n            mx=0\\n            for i in range((pos1-1)//10000+1, n//10000):\\n                if ml[1][i]>mx:\\n                    mx=ml[1][i]\\n            if k//10000>1:\\n                for i in range((pos1-1)//1000+1, ((pos1-1)//10000+1)*10):\\n                    if ml[2][i]>mx:\\n                        mx=ml[2][i]\\n                for i in range((n//10000)*10, n//1000):\\n                    if ml[2][i]>mx:\\n                        mx=ml[2][i]\\n            else:\\n                for i in range((pos1-1)//1000+1, n//1000):\\n                    if ml[2][i]>mx:\\n                        mx=ml[2][i]\\n            if k//1000>1:\\n                for i in range((pos1-1)//100+1, ((pos1-1)//1000+1)*10):\\n                    if ml[3][i]>mx:\\n                        mx=ml[3][i]\\n                for i in range((n//1000)*10, n//100):\\n                    if ml[3][i]>mx:\\n                        mx=ml[3][i]\\n            else:\\n                for i in range((pos1-1)//100+1, n//100):\\n                    if ml[3][i]>mx:\\n                        mx=ml[3][i]\\n            if k//100>1:\\n                for i in range((pos1-1)//10+1, ((pos1-1)//100+1)*10):\\n                    if ml[4][i]>mx:\\n                        mx=ml[4][i]\\n                for i in range((n//100)*10, n//10):\\n                    if ml[4][i]>mx:\\n                        mx=ml[4][i]\\n            else:\\n                for i in range((pos1-1)//10+1, n//10):\\n                    if ml[4][i]>mx:\\n                        mx=ml[4][i]\\n            if k//10>1:\\n                for i in range(pos1, ((pos1-1)//10+1)*10):\\n                    if ml[5][i]>mx:\\n                        mx=ml[5][i]\\n                for i in range((n//10)*10, n):\\n                    if ml[5][i]>mx:\\n                        mx=ml[5][i]\\n            else:\\n                for i in range(pos1, n):\\n                    if ml[5][i]>mx:\\n                        mx=ml[5][i]\\n            mx+=1\\n            if mx>ml[5][n]:\\n                ml[5][n]=mx\\n            if mx>ml[4][n//10]:\\n                ml[4][n//10]=mx\\n            if mx>ml[3][n//100]:\\n                ml[3][n//100]=mx\\n            if mx>ml[2][n//1000]:\\n                ml[2][n//1000]=mx\\n            if mx>ml[1][n//10000]:\\n                ml[1][n//10000]=mx\\n            if mx>ml[0]:\\n                ml[0]=mx\\n        return ml[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572473,
                "title": "segment-tree-approach-explained",
                "content": "I spent two days understanding @Bakerston cool solution (https://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/2560085/Python-Explanation-with-pictures-Segment-Tree ) but there are some tricky and not obvious moments which were not very clear to me even after reading https://codeforces.com/blog/entry/18051.\\n\\nI hope someone will save several hours of life after this post.\\n\\n1) ``` number & 1```  is the even-odd checking\\n\\n2) ```number >> 1``` equals ```number // 2``` (Python)\\n\\n3) Left element will be considered in any case (if it has even or odd index).\\n\\tLeft\\'s parent will be considered only if our left element is its parent\\'s left child.\\n\\n4) We will never consider right element itself. This is because when we are searching for the longest subsequences n the past, we don\\'t include current element (equals right). \\n\\tWe also will never consider right\\'s parent because\\n\\t\\t- If right is the left child, we skip it  (as we don\\'t count the sequence\\'s end) and move left, to another pair of children.\\n\\t\\t- If right is the right child, we skip it (as we don\\'t count the sequence\\'s end), and look at the left child in current pair. However, in order to check the right\\'s parent we also must look at it\\'s right child.\\n",
                "solutionTags": [
                    "Tree"
                ],
                "code": "``` number & 1```\n```number >> 1```\n```number // 2```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571773,
                "title": "segment-tree-c",
                "content": "```\\nclass Solution {\\npublic:\\n    class SegmentTree {\\n        public:\\n        vector<int> seg;\\n        int maxN;\\n\\t\\t\\n        SegmentTree(int n) : maxN(n) {\\n            seg = vector<int>(maxN * 4 + 10, 0);\\n        }\\n        int query(int l, int r) {\\n            return query_util(0, 0, maxN - 1, l, r);\\n        }\\n        int query_util(int i, int low, int high, int l, int r) {\\n            if(low >= l && high <= r)\\n                return seg[i];\\n            if(high < l || low > r)\\n                return INT_MIN;\\n            int mid = (high + low) / 2;\\n            int left = query_util(2 * i + 1, low, mid, l, r);\\n            int right = query_util(2 * i + 2, mid + 1, high, l, r);\\n            return max(left, right);\\n        }\\n        void update(int len, int ele) {\\n            update_util(0, 0, maxN - 1, ele, len);\\n        }\\n        void update_util(int i, int low, int high, int ele, int len) {\\n            if(low == high) {\\n                seg[i] = len;\\n                return;\\n            }\\n            int mid = low + (high - low) / 2;\\n            if(low <= ele && ele <= mid) {\\n                update_util(2 * i + 1, low, mid, ele, len);\\n            } else {\\n                update_util(2 * i + 2, mid + 1, high, ele, len);\\n            }\\n            seg[i] = max(seg[2 * i + 1], seg[2 * i + 2]);\\n        }\\n    };\\n\\t\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int max_ele = nums[0];\\n        for(auto it : nums)\\n            max_ele = max(max_ele, it);\\n\\t\\t\\t\\n        SegmentTree seg(max_ele + 1);\\n        \\n        for(auto it : nums) {\\n            int lower = max(0, it - k);\\n            int longestIncreasingBefore = 1 + seg.query(lower, it - 1);\\n            seg.update(longestIncreasingBefore, it);\\n        }\\n        \\n        return seg.query(1, max_ele);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class SegmentTree {\\n        public:\\n        vector<int> seg;\\n        int maxN;\\n\\t\\t\\n        SegmentTree(int n) : maxN(n) {\\n            seg = vector<int>(maxN * 4 + 10, 0);\\n        }\\n        int query(int l, int r) {\\n            return query_util(0, 0, maxN - 1, l, r);\\n        }\\n        int query_util(int i, int low, int high, int l, int r) {\\n            if(low >= l && high <= r)\\n                return seg[i];\\n            if(high < l || low > r)\\n                return INT_MIN;\\n            int mid = (high + low) / 2;\\n            int left = query_util(2 * i + 1, low, mid, l, r);\\n            int right = query_util(2 * i + 2, mid + 1, high, l, r);\\n            return max(left, right);\\n        }\\n        void update(int len, int ele) {\\n            update_util(0, 0, maxN - 1, ele, len);\\n        }\\n        void update_util(int i, int low, int high, int ele, int len) {\\n            if(low == high) {\\n                seg[i] = len;\\n                return;\\n            }\\n            int mid = low + (high - low) / 2;\\n            if(low <= ele && ele <= mid) {\\n                update_util(2 * i + 1, low, mid, ele, len);\\n            } else {\\n                update_util(2 * i + 2, mid + 1, high, ele, len);\\n            }\\n            seg[i] = max(seg[2 * i + 1], seg[2 * i + 2]);\\n        }\\n    };\\n\\t\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int max_ele = nums[0];\\n        for(auto it : nums)\\n            max_ele = max(max_ele, it);\\n\\t\\t\\t\\n        SegmentTree seg(max_ele + 1);\\n        \\n        for(auto it : nums) {\\n            int lower = max(0, it - k);\\n            int longestIncreasingBefore = 1 + seg.query(lower, it - 1);\\n            seg.update(longestIncreasingBefore, it);\\n        }\\n        \\n        return seg.query(1, max_ele);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571650,
                "title": "c-solution-using-binary-search",
                "content": "```\\nint lengthOfLIS(vector<int>& nums, int k) {\\n\\tconst int INF = 0x3f3f3f3f;\\n\\tvector<int> dp(nums.size() + 1, INF);\\n\\tvector<set<int>> possibilitiesNums(nums.size() + 1);\\n\\tint length = 0;\\n\\tdp[0] = -INF;\\n\\tfor (const auto& num : nums) {\\n\\t\\tint i = lower_bound(dp.begin(), dp.end(), num) - dp.begin();\\n\\t\\tif (i > 1) {\\n\\t\\t\\t// this block check were the num must be inserted\\n\\t\\t\\t// amortized analysis of this block is O(log n) for each time it\\'s executed\\n\\t\\t\\tbool ok;\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tauto it = possibilitiesNums[i - 1].insert(num).first;\\n\\t\\t\\t\\tauto previousIt = it; --previousIt;\\n\\t\\t\\t\\tok = *previousIt + k >= num;\\n\\t\\t\\t\\tpossibilitiesNums[i - 1].erase(it);\\n\\t\\t\\t\\tif (!ok) --i;\\n\\t\\t\\t} while (!ok && i > 0);\\n\\t\\t}\\n\\t\\tdp[i] = min(dp[i], num);\\n\\t\\tpossibilitiesNums[i].insert(num);\\n\\t\\tlength = max(length, i);\\n\\t}\\n\\treturn length;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint lengthOfLIS(vector<int>& nums, int k) {\\n\\tconst int INF = 0x3f3f3f3f;\\n\\tvector<int> dp(nums.size() + 1, INF);\\n\\tvector<set<int>> possibilitiesNums(nums.size() + 1);\\n\\tint length = 0;\\n\\tdp[0] = -INF;\\n\\tfor (const auto& num : nums) {\\n\\t\\tint i = lower_bound(dp.begin(), dp.end(), num) - dp.begin();\\n\\t\\tif (i > 1) {\\n\\t\\t\\t// this block check were the num must be inserted\\n\\t\\t\\t// amortized analysis of this block is O(log n) for each time it\\'s executed\\n\\t\\t\\tbool ok;\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tauto it = possibilitiesNums[i - 1].insert(num).first;\\n\\t\\t\\t\\tauto previousIt = it; --previousIt;\\n\\t\\t\\t\\tok = *previousIt + k >= num;\\n\\t\\t\\t\\tpossibilitiesNums[i - 1].erase(it);\\n\\t\\t\\t\\tif (!ok) --i;\\n\\t\\t\\t} while (!ok && i > 0);\\n\\t\\t}\\n\\t\\tdp[i] = min(dp[i], num);\\n\\t\\tpossibilitiesNums[i].insert(num);\\n\\t\\tlength = max(length, i);\\n\\t}\\n\\treturn length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570795,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    static const int maxn=1e5+5;\\n    int seg[maxn<<2];\\n    int query(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(ql>=r||qr<=l)return 0;\\n        int mid=(l+r)>>1;\\n        return max(query(cur<<1,l,mid,ql,qr),query(cur<<1|1,mid,r,ql,qr));\\n    }\\n    void update(int cur,int l,int r,int target,int cnt)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=max(seg[cur],cnt);\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(target<mid)update(cur<<1,l,mid,target,cnt);2\\n        else update(cur<<1|1,mid,r,target,cnt);\\n        seg[cur]=max(seg[cur<<1],seg[cur<<1|1]);\\n        return;\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) \\n    {\\n        for(int i=0;i<(maxn<<2);i++)seg[i]=0;\\n        for(auto &x:nums)\\n        {\\n            int mx=query(1,0,maxn,max(1,x-k),x);\\n            update(1,0,maxn,x,mx+1);\\n        }\\n        return seg[1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int maxn=1e5+5;\\n    int seg[maxn<<2];\\n    int query(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(ql>=r||qr<=l)return 0;\\n        int mid=(l+r)>>1;\\n        return max(query(cur<<1,l,mid,ql,qr),query(cur<<1|1,mid,r,ql,qr));\\n    }\\n    void update(int cur,int l,int r,int target,int cnt)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=max(seg[cur],cnt);\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(target<mid)update(cur<<1,l,mid,target,cnt);2\\n        else update(cur<<1|1,mid,r,target,cnt);\\n        seg[cur]=max(seg[cur<<1],seg[cur<<1|1]);\\n        return;\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) \\n    {\\n        for(int i=0;i<(maxn<<2);i++)seg[i]=0;\\n        for(auto &x:nums)\\n        {\\n            int mx=query(1,0,maxn,max(1,x-k),x);\\n            update(1,0,maxn,x,mx+1);\\n        }\\n        return seg[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570437,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    const int nax = 1e5 + 1;\\n    vector<int> tree;\\n    int size;\\n    int getMaximum(int root, int left, int right, int l, int r) {\\n        if (r < left || right < l) return 0;\\n        if (l >= left && r <= right) {\\n            return tree[root];\\n        }\\n        int mid = (l + r) / 2;\\n        return max(getMaximum(2 * root + 1, left, right, l, mid), getMaximum(2 * root + 2, left, right, mid + 1, r));\\n    }\\n    void update(int pos, int mx) {\\n        tree[size - 1 + pos] = mx;\\n        for (int i = (size - 1 + pos - 1) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\\n        }\\n        if (size > 1) {\\n            tree[0] = max(tree[1], tree[2]);\\n        }\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(nax);\\n        size = 1;\\n        while (size < nax) {\\n            size *= 2;\\n        }\\n        tree.resize(2 * size - 1);\\n        for (int i = 0; i < nax; i++) {\\n            tree[size - 1 + i] = dp[i];\\n        }\\n        for (int i = size - 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\\n        }\\n        if (size > 1) {\\n            tree[0] = max(tree[1], tree[2]);\\n        }\\n        int sol = 1;\\n        for (int i = 0; i < n; i++) {\\n            int left = max(0, nums[i] - k);\\n            int right = nums[i] - 1;\\n            if (left <= right) {\\n                int mx = getMaximum(0, left, right, 0, size - 1);\\n                if (mx + 1 > dp[nums[i]]) {\\n                    dp[nums[i]] = mx + 1;\\n                    update(nums[i], dp[nums[i]]);\\n                    sol = max(sol, dp[nums[i]]);\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int nax = 1e5 + 1;\\n    vector<int> tree;\\n    int size;\\n    int getMaximum(int root, int left, int right, int l, int r) {\\n        if (r < left || right < l) return 0;\\n        if (l >= left && r <= right) {\\n            return tree[root];\\n        }\\n        int mid = (l + r) / 2;\\n        return max(getMaximum(2 * root + 1, left, right, l, mid), getMaximum(2 * root + 2, left, right, mid + 1, r));\\n    }\\n    void update(int pos, int mx) {\\n        tree[size - 1 + pos] = mx;\\n        for (int i = (size - 1 + pos - 1) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\\n        }\\n        if (size > 1) {\\n            tree[0] = max(tree[1], tree[2]);\\n        }\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(nax);\\n        size = 1;\\n        while (size < nax) {\\n            size *= 2;\\n        }\\n        tree.resize(2 * size - 1);\\n        for (int i = 0; i < nax; i++) {\\n            tree[size - 1 + i] = dp[i];\\n        }\\n        for (int i = size - 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = max(tree[2 * i + 1], tree[2 * i + 2]);\\n        }\\n        if (size > 1) {\\n            tree[0] = max(tree[1], tree[2]);\\n        }\\n        int sol = 1;\\n        for (int i = 0; i < n; i++) {\\n            int left = max(0, nums[i] - k);\\n            int right = nums[i] - 1;\\n            if (left <= right) {\\n                int mx = getMaximum(0, left, right, 0, size - 1);\\n                if (mx + 1 > dp[nums[i]]) {\\n                    dp[nums[i]] = mx + 1;\\n                    update(nums[i], dp[nums[i]]);\\n                    sol = max(sol, dp[nums[i]]);\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569893,
                "title": "short-and-concise",
                "content": "\\n    int query(int l, int r){\\n        int ret = 0;\\n        for(l+=n, r+=n; l<r; l>>=1, r>>=1){\\n            if(l&1) ret = max(ret, tree[l++]);\\n            if(r&1) ret = max(ret, tree[--r]);\\n        }\\n        return ret;\\n    }\\n    \\n    void update(int val, int ind){\\n        for(tree[ind += n] = val; ind>1; ind>>=1){\\n            tree[ind>>1] = max(tree[ind], tree[ind^1]);\\n        }\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        tree.resize(2e5+2);\\n        int ret = 0;\\n        for(int i : nums){\\n            int l = max(1, i-k);\\n            int val = query(l, i);\\n            ret = max(ret, val+1);\\n            // cout<<ret<<\" \";\\n            update(val+1, i);\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "\\n    int query(int l, int r){\\n        int ret = 0;\\n        for(l+=n, r+=n; l<r; l>>=1, r>>=1){\\n            if(l&1) ret = max(ret, tree[l++]);\\n            if(r&1) ret = max(ret, tree[--r]);\\n        }\\n        return ret;\\n    }\\n    \\n    void update(int val, int ind){\\n        for(tree[ind += n] = val; ind>1; ind>>=1){\\n            tree[ind>>1] = max(tree[ind], tree[ind^1]);\\n        }\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        tree.resize(2e5+2);\\n        int ret = 0;\\n        for(int i : nums){\\n            int l = max(1, i-k);\\n            int val = query(l, i);\\n            ret = max(ret, val+1);\\n            // cout<<ret<<\" \";\\n            update(val+1, i);\\n        }\\n        return ret;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2569892,
                "title": "python3-range-max-query-with-segment-tree",
                "content": "```\\nclass RMQ(object):\\n\\n    def __init__(self, n):\\n        super().__init__()\\n        self.n = n\\n        self.tree = [0] * (2 * self.n)\\n\\n    def update(self, p, v):\\n        p += self.n\\n        if self.tree[p] > v: return\\n        self.tree[p] = v\\n        while p > 1 and self.tree[p >> 1] < v:\\n            self.tree[p >> 1] = v\\n            p >>= 1\\n\\n    def query(self, l, r):\\n        ret = 0\\n        l, r = l + self.n, r + self.n\\n        while l < r:\\n            if l & 1:\\n                ret = max(ret, self.tree[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                ret = max(ret, self.tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return ret\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        N = max(nums) + 1\\n        rmq = RMQ(N)\\n        for v in nums: rmq.update(v, rmq.query(max(0, v - k), v) + 1)\\n        return rmq.query(0, N)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RMQ(object):\\n\\n    def __init__(self, n):\\n        super().__init__()\\n        self.n = n\\n        self.tree = [0] * (2 * self.n)\\n\\n    def update(self, p, v):\\n        p += self.n\\n        if self.tree[p] > v: return\\n        self.tree[p] = v\\n        while p > 1 and self.tree[p >> 1] < v:\\n            self.tree[p >> 1] = v\\n            p >>= 1\\n\\n    def query(self, l, r):\\n        ret = 0\\n        l, r = l + self.n, r + self.n\\n        while l < r:\\n            if l & 1:\\n                ret = max(ret, self.tree[l])\\n                l += 1\\n            if r & 1:\\n                r -= 1\\n                ret = max(ret, self.tree[r])\\n            l >>= 1\\n            r >>= 1\\n        return ret\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        N = max(nums) + 1\\n        rmq = RMQ(N)\\n        for v in nums: rmq.update(v, rmq.query(max(0, v - k), v) + 1)\\n        return rmq.query(0, N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569567,
                "title": "python3-recursive-segment-tree-that-passes-without-tle",
                "content": "Many python solutions uses iterative segment tree because recursive segment tree implementation will get TLE. Here is an implementation of recursive segment tree that doesn\\'t have TLE. \\n\\nI did not create Segment Tree class. Segment tree is achieved using inline function. \\'seg_i\\', \\'seg_l\\', \\'seg_r\\' paramenters are information of segment tree node.\\n\\ntree[i] stores max value of a range.\\n\\'seg_i\\' is used in \\'tree[seg_i]\\' to locate tree node. This index is not meaningful by itself, but it can be used to find the left and right children of a tree node: tree[2\\\\*seg_i] and tree[2\\\\*seg_i+1] \\n\\'seg_l\\' and \\'seg_r\\' are the left and right boundary of tree[i] node\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        mx = max(nums)\\n        tree = [0]*mx*4 # tree[0] is dummy. tree[1] is the root node.\\n        def update(i,val,seg_i=1,seg_l=1,seg_r=mx):\\n            if seg_l==seg_r:\\n                tree[seg_i]=val\\n                return\\n            mid = (seg_l+seg_r)//2\\n            if i<=mid: # update i on the left half\\n                update(i,val,seg_i*2,seg_l,mid)\\n            else:  # update i on the right half\\n                update(i,val,seg_i*2+1,mid+1,seg_r)\\n            tree[seg_i]=max(tree[seg_i*2],tree[seg_i*2+1])\\n            \\n        def query(query_l,query_r,seg_i=1,seg_l=1,seg_r=mx):\\n            if seg_l>=query_l and seg_r<=query_r:\\n                return tree[seg_i]\\n            mid = (seg_l+seg_r)//2\\n            l_mx,r_mx = 0,0\\n            if query_l<=mid:\\n                l_mx = query(query_l,query_r,seg_i*2,seg_l,mid)\\n            if query_r>=mid+1:\\n                r_mx = query(query_l,query_r,seg_i*2+1,mid+1,seg_r)\\n            return max(l_mx,r_mx)\\n        \\n        for num in nums:\\n            if num==1:\\n                v = 0\\n            else:\\n                v = query(max(1,num-k),num-1) # longest subsequence smaller than num\\n            update(num,v+1)\\n        return tree[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        mx = max(nums)\\n        tree = [0]*mx*4 # tree[0] is dummy. tree[1] is the root node.\\n        def update(i,val,seg_i=1,seg_l=1,seg_r=mx):\\n            if seg_l==seg_r:\\n                tree[seg_i]=val\\n                return\\n            mid = (seg_l+seg_r)//2\\n            if i<=mid: # update i on the left half\\n                update(i,val,seg_i*2,seg_l,mid)\\n            else:  # update i on the right half\\n                update(i,val,seg_i*2+1,mid+1,seg_r)\\n            tree[seg_i]=max(tree[seg_i*2],tree[seg_i*2+1])\\n            \\n        def query(query_l,query_r,seg_i=1,seg_l=1,seg_r=mx):\\n            if seg_l>=query_l and seg_r<=query_r:\\n                return tree[seg_i]\\n            mid = (seg_l+seg_r)//2\\n            l_mx,r_mx = 0,0\\n            if query_l<=mid:\\n                l_mx = query(query_l,query_r,seg_i*2,seg_l,mid)\\n            if query_r>=mid+1:\\n                r_mx = query(query_l,query_r,seg_i*2+1,mid+1,seg_r)\\n            return max(l_mx,r_mx)\\n        \\n        for num in nums:\\n            if num==1:\\n                v = 0\\n            else:\\n                v = query(max(1,num-k),num-1) # longest subsequence smaller than num\\n            update(num,v+1)\\n        return tree[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568456,
                "title": "java-segment-tree-with-node-class-treemap-submap",
                "content": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        Node root = build(0, 100_000);\\n        int max = 0;\\n        for(int num: nums) {\\n            int pre = query(Math.max(0, num - k), Math.max(0, num - 1), root);\\n            max = Math.max(pre + 1, max);\\n            update(num, pre + 1, root);\\n        }\\n        return max;\\n    }\\n    \\n    private Node build(int l, int r) {\\n        if(l == r) {\\n            return new Node(l, r, 0);\\n        }\\n        Node node = new Node(l, r, 0);\\n        int mid = l + (r - l) / 2;\\n        node.left = build(l, mid);\\n        node.right = build(mid + 1, r);\\n        return node;\\n    }\\n    \\n    private int update(int num, int cnt, Node node) {\\n        if(node.l > num || node.r < num) {\\n            return 0;\\n        } \\n        if(node.l == node.r) {\\n            return node.cnt = cnt;\\n        }\\n        int left = update(num, cnt, node.left);\\n        int right = update(num, cnt, node.right);\\n        node.cnt = Math.max(node.cnt, Math.max(left, right));\\n        return node.cnt;\\n    }\\n    \\n    private int query(int from, int to, Node node) {\\n        if(from > to) {\\n            return 0;\\n        }\\n        if(from == node.l && to == node.r) {\\n            return node.cnt;\\n        }\\n        int mid = node.l + (node.r - node.l) / 2;\\n        int left = query(from, Math.min(mid, to), node.left);\\n        int right = query(Math.max(mid + 1, from), to, node.right);\\n        return Math.max(left, right);\\n    }\\n    \\n    private static class Node { \\n        int l;\\n        int r;\\n        int cnt;\\n        Node left;\\n        Node right;\\n        \\n        public Node(int l, int r, int cnt) {\\n            this.l = l;\\n            this.r = r;\\n            this.cnt = cnt;\\n        }\\n    }\\n}\\n```\\nAnother TLE solution is using treemap + subMap.\\n```\\n\\tpublic int lengthOfLIS(int[] nums, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        for(int num: nums) {\\n            int from = num - k;\\n            int to = num;\\n            int pre = 0;\\n            for(int v: map.subMap(from, to).values()) {\\n                pre = Math.max(pre, v);\\n            }\\n            map.put(num, pre + 1);\\n            max = Math.max(pre + 1, max);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        Node root = build(0, 100_000);\\n        int max = 0;\\n        for(int num: nums) {\\n            int pre = query(Math.max(0, num - k), Math.max(0, num - 1), root);\\n            max = Math.max(pre + 1, max);\\n            update(num, pre + 1, root);\\n        }\\n        return max;\\n    }\\n    \\n    private Node build(int l, int r) {\\n        if(l == r) {\\n            return new Node(l, r, 0);\\n        }\\n        Node node = new Node(l, r, 0);\\n        int mid = l + (r - l) / 2;\\n        node.left = build(l, mid);\\n        node.right = build(mid + 1, r);\\n        return node;\\n    }\\n    \\n    private int update(int num, int cnt, Node node) {\\n        if(node.l > num || node.r < num) {\\n            return 0;\\n        } \\n        if(node.l == node.r) {\\n            return node.cnt = cnt;\\n        }\\n        int left = update(num, cnt, node.left);\\n        int right = update(num, cnt, node.right);\\n        node.cnt = Math.max(node.cnt, Math.max(left, right));\\n        return node.cnt;\\n    }\\n    \\n    private int query(int from, int to, Node node) {\\n        if(from > to) {\\n            return 0;\\n        }\\n        if(from == node.l && to == node.r) {\\n            return node.cnt;\\n        }\\n        int mid = node.l + (node.r - node.l) / 2;\\n        int left = query(from, Math.min(mid, to), node.left);\\n        int right = query(Math.max(mid + 1, from), to, node.right);\\n        return Math.max(left, right);\\n    }\\n    \\n    private static class Node { \\n        int l;\\n        int r;\\n        int cnt;\\n        Node left;\\n        Node right;\\n        \\n        public Node(int l, int r, int cnt) {\\n            this.l = l;\\n            this.r = r;\\n            this.cnt = cnt;\\n        }\\n    }\\n}\\n```\n```\\n\\tpublic int lengthOfLIS(int[] nums, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        for(int num: nums) {\\n            int from = num - k;\\n            int to = num;\\n            int pre = 0;\\n            for(int v: map.subMap(from, to).values()) {\\n                pre = Math.max(pre, v);\\n            }\\n            map.put(num, pre + 1);\\n            max = Math.max(pre + 1, max);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568447,
                "title": "segment-tree-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    vector<int> ar;\\n    int N = 1e5 + 10;\\n    int query(int st,int ed,int t,int l,int r){\\n        if(st >r || ed<l) return INT_MIN;\\n        if(st>=l and ed<=r) return seg[t];\\n        int mid=(st +ed)/2;\\n        return max(query(st,mid,t*2,l,r),query(mid+1,ed,t*2+1,l,r));\\n    }\\n    void update(int st,int ed,int t,int idx,int val){\\n        if(st > ed) return;\\n        if(st==ed){\\n            if(st!=idx) return;\\n            seg[t]=val;\\n            ar[st] = val;\\n            return;\\n        }\\n        int mid =(st +ed)/2;\\n        if(idx <= mid) update(st,mid,2*t,idx,val);\\n        else update(mid+1,ed,t*2 + 1,idx,val);\\n        seg[t] = max(seg[2*t], seg[2*t + 1]);\\n    }               \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        seg=vector<int>(4 *N + 10,0);\\n        ar= vector<int>(N,0);\\n        for(int i=0;i<n;i++){\\n            int lb=max(0,nums[i]-k);\\n            int get_max = query(0,N,1,lb,max(0,nums[i]-1));\\n            if(ar[nums[i]] < get_max + 1) update(0,N,1,nums[i],get_max + 1);\\n        }\\n        return *max_element(ar.begin(),ar.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    vector<int> ar;\\n    int N = 1e5 + 10;\\n    int query(int st,int ed,int t,int l,int r){\\n        if(st >r || ed<l) return INT_MIN;\\n        if(st>=l and ed<=r) return seg[t];\\n        int mid=(st +ed)/2;\\n        return max(query(st,mid,t*2,l,r),query(mid+1,ed,t*2+1,l,r));\\n    }\\n    void update(int st,int ed,int t,int idx,int val){\\n        if(st > ed) return;\\n        if(st==ed){\\n            if(st!=idx) return;\\n            seg[t]=val;\\n            ar[st] = val;\\n            return;\\n        }\\n        int mid =(st +ed)/2;\\n        if(idx <= mid) update(st,mid,2*t,idx,val);\\n        else update(mid+1,ed,t*2 + 1,idx,val);\\n        seg[t] = max(seg[2*t], seg[2*t + 1]);\\n    }               \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        seg=vector<int>(4 *N + 10,0);\\n        ar= vector<int>(N,0);\\n        for(int i=0;i<n;i++){\\n            int lb=max(0,nums[i]-k);\\n            int get_max = query(0,N,1,lb,max(0,nums[i]-1));\\n            if(ar[nums[i]] < get_max + 1) update(0,N,1,nums[i],get_max + 1);\\n        }\\n        return *max_element(ar.begin(),ar.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568395,
                "title": "swift-segment-tree-to-record-lcs-for-specific-range",
                "content": "\\n\\n```\\nclass Solution {\\n    class SegmentTree {\\n\\t    // count of leaf nodes\\n        private var n: Int\\n        private var tree: [Int]\\n        \\n        public init(n: Int) {\\n            self.n = n\\n            \\n            let treeHeight = Int(ceilf(log2(Float(n))))\\n            let treeSize = 2 * Int(pow(Double(2), Double(treeHeight))) - 1\\n            tree = Array(repeating: 0, count: treeSize)\\n        }\\n        \\n        public func getMax() -> Int {\\n            return getMax(node: 0, treeStart: 0, treeEnd: n - 1, queryLeft: 0, queryRight: n - 1)\\n        }\\n        public func getMax(_ queryLeft: Int, _ queryRight: Int) -> Int {\\n            return getMax(node: 0, treeStart: 0, treeEnd: n - 1, queryLeft: queryLeft, queryRight: queryRight)\\n        }\\n        public func update(idx: Int, value: Int) {\\n            update(node: 0, treeStart: 0, treeEnd: n - 1, idx: idx, value: value)\\n        }\\n                \\n        private func getMax(node: Int, treeStart: Int, treeEnd: Int, queryLeft: Int, queryRight: Int) -> Int {\\n            // [queryLeft...treeStart ... treeEnd...queryRight]\\n            if queryLeft <= treeStart, queryRight >= treeEnd {\\n                return tree[node]\\n            }\\n            \\n            if queryLeft > treeEnd || queryRight < treeStart {\\n                return Int.min\\n            }\\n            \\n            if treeStart == treeEnd {\\n                return tree[treeStart]\\n            }\\n            \\n            let mid = treeStart + (treeEnd - treeStart) / 2\\n            let left = getMax(node: node * 2 + 1, treeStart: treeStart, treeEnd: mid, queryLeft: queryLeft, queryRight: queryRight)\\n            let right = getMax(node: node * 2 + 2, treeStart: mid + 1, treeEnd: treeEnd, queryLeft: queryLeft, queryRight: queryRight)\\n            return max(left, right)\\n        }\\n        \\n        // find until the leaf node whose index is idx\\n        private func update(node: Int, treeStart: Int, treeEnd: Int, idx: Int, value: Int) {\\n            guard idx >= treeStart, idx <= treeEnd else {\\n                return\\n            }\\n            \\n            // leaf node\\n            if treeStart == treeEnd {\\n                tree[node] = max(tree[node], value)\\n            } else {\\n                let mid = treeStart + (treeEnd - treeStart) / 2\\n                update(node: node * 2 + 1, treeStart: treeStart, treeEnd: mid, idx: idx, value: value)      // left\\n                update(node: node * 2 + 2, treeStart: mid + 1, treeEnd: treeEnd, idx: idx, value: value)    // right\\n                tree[node] = max(tree[node * 2 + 1], tree[node * 2 + 2])\\n            }\\n        }\\n    }\\n    \\n    func lengthOfLIS(_ nums: [Int], _ k: Int) -> Int {\\n        guard let maxVal = nums.max() else {\\n            return 0\\n        }\\n        let tree = SegmentTree(n: maxVal + 1)\\n        for num in nums {\\n            let lower = max(0, num - k)\\n            let upper = num - 1\\n            \\n            let curMax = tree.getMax(lower, upper)\\n            \\n            tree.update(idx: num, value: curMax + 1)\\n        }\\n        return tree.getMax()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class SegmentTree {\\n\\t    // count of leaf nodes\\n        private var n: Int\\n        private var tree: [Int]\\n        \\n        public init(n: Int) {\\n            self.n = n\\n            \\n            let treeHeight = Int(ceilf(log2(Float(n))))\\n            let treeSize = 2 * Int(pow(Double(2), Double(treeHeight))) - 1\\n            tree = Array(repeating: 0, count: treeSize)\\n        }\\n        \\n        public func getMax() -> Int {\\n            return getMax(node: 0, treeStart: 0, treeEnd: n - 1, queryLeft: 0, queryRight: n - 1)\\n        }\\n        public func getMax(_ queryLeft: Int, _ queryRight: Int) -> Int {\\n            return getMax(node: 0, treeStart: 0, treeEnd: n - 1, queryLeft: queryLeft, queryRight: queryRight)\\n        }\\n        public func update(idx: Int, value: Int) {\\n            update(node: 0, treeStart: 0, treeEnd: n - 1, idx: idx, value: value)\\n        }\\n                \\n        private func getMax(node: Int, treeStart: Int, treeEnd: Int, queryLeft: Int, queryRight: Int) -> Int {\\n            // [queryLeft...treeStart ... treeEnd...queryRight]\\n            if queryLeft <= treeStart, queryRight >= treeEnd {\\n                return tree[node]\\n            }\\n            \\n            if queryLeft > treeEnd || queryRight < treeStart {\\n                return Int.min\\n            }\\n            \\n            if treeStart == treeEnd {\\n                return tree[treeStart]\\n            }\\n            \\n            let mid = treeStart + (treeEnd - treeStart) / 2\\n            let left = getMax(node: node * 2 + 1, treeStart: treeStart, treeEnd: mid, queryLeft: queryLeft, queryRight: queryRight)\\n            let right = getMax(node: node * 2 + 2, treeStart: mid + 1, treeEnd: treeEnd, queryLeft: queryLeft, queryRight: queryRight)\\n            return max(left, right)\\n        }\\n        \\n        // find until the leaf node whose index is idx\\n        private func update(node: Int, treeStart: Int, treeEnd: Int, idx: Int, value: Int) {\\n            guard idx >= treeStart, idx <= treeEnd else {\\n                return\\n            }\\n            \\n            // leaf node\\n            if treeStart == treeEnd {\\n                tree[node] = max(tree[node], value)\\n            } else {\\n                let mid = treeStart + (treeEnd - treeStart) / 2\\n                update(node: node * 2 + 1, treeStart: treeStart, treeEnd: mid, idx: idx, value: value)      // left\\n                update(node: node * 2 + 2, treeStart: mid + 1, treeEnd: treeEnd, idx: idx, value: value)    // right\\n                tree[node] = max(tree[node * 2 + 1], tree[node * 2 + 2])\\n            }\\n        }\\n    }\\n    \\n    func lengthOfLIS(_ nums: [Int], _ k: Int) -> Int {\\n        guard let maxVal = nums.max() else {\\n            return 0\\n        }\\n        let tree = SegmentTree(n: maxVal + 1)\\n        for num in nums {\\n            let lower = max(0, num - k)\\n            let upper = num - 1\\n            \\n            let curMax = tree.getMax(lower, upper)\\n            \\n            tree.update(idx: num, value: curMax + 1)\\n        }\\n        return tree.getMax()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568323,
                "title": "c-segment-tree-template-class-for-max-query",
                "content": "```\\n//segement tree template\\nclass segmentTree {\\n  vector<int> tree;\\n    \\n    int leftChild(int n)\\n    {\\n        return n*2+1;\\n    }\\n    \\n    int rightChild(int n)\\n    {\\n        return n*2+2;\\n    }\\n    \\n    int getMid(int left, int right)\\n    {\\n        return left + (right-left)/2;\\n    }\\npublic:\\n    segmentTree(int n) {\\n        tree.assign(n*4, 0);\\n    }\\n    \\n    void update(int node, int left, int right, int idx, int val)\\n    {\\n        if(left == right)\\n        {\\n            tree[node] = val;\\n            return;\\n        }\\n        \\n        int mid = getMid(left, right);\\n        int lc = leftChild(node);\\n        int rc = rightChild(node);\\n        if(idx<=mid)\\n            update(lc, left, mid, idx, val);\\n        else\\n            update(rc, mid+1, right, idx, val);\\n        \\n        tree[node] = max(tree[lc], tree[rc]);\\n    }\\n    \\n    int query(int node, int left, int right, int qLeft, int qRight)\\n    {\\n        if(qLeft<=left && qRight>=right)\\n            return tree[node];\\n        \\n        if(right < qLeft || left>qRight)\\n            return INT_MIN;\\n        \\n        int mid = getMid(left, right);\\n        \\n        return max(query(leftChild(node), left, mid, qLeft, qRight), query(rightChild(node), mid+1, right, qLeft, qRight));\\n    }\\n};\\n\\nint mx = 100000 + 20;\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        segmentTree s(mx);\\n        int res = 0;\\n        for(int i: nums)\\n        {\\n            int l = max(0, i - k);\\n            int h = max(i - 1, 0);\\n            if(l<=h)\\n            {\\n                int qq = s.query(0, 0, mx, l, h);\\n                res = max(res, qq+1);\\n                s.update(0, 0, mx, i, qq+1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//segement tree template\\nclass segmentTree {\\n  vector<int> tree;\\n    \\n    int leftChild(int n)\\n    {\\n        return n*2+1;\\n    }\\n    \\n    int rightChild(int n)\\n    {\\n        return n*2+2;\\n    }\\n    \\n    int getMid(int left, int right)\\n    {\\n        return left + (right-left)/2;\\n    }\\npublic:\\n    segmentTree(int n) {\\n        tree.assign(n*4, 0);\\n    }\\n    \\n    void update(int node, int left, int right, int idx, int val)\\n    {\\n        if(left == right)\\n        {\\n            tree[node] = val;\\n            return;\\n        }\\n        \\n        int mid = getMid(left, right);\\n        int lc = leftChild(node);\\n        int rc = rightChild(node);\\n        if(idx<=mid)\\n            update(lc, left, mid, idx, val);\\n        else\\n            update(rc, mid+1, right, idx, val);\\n        \\n        tree[node] = max(tree[lc], tree[rc]);\\n    }\\n    \\n    int query(int node, int left, int right, int qLeft, int qRight)\\n    {\\n        if(qLeft<=left && qRight>=right)\\n            return tree[node];\\n        \\n        if(right < qLeft || left>qRight)\\n            return INT_MIN;\\n        \\n        int mid = getMid(left, right);\\n        \\n        return max(query(leftChild(node), left, mid, qLeft, qRight), query(rightChild(node), mid+1, right, qLeft, qRight));\\n    }\\n};\\n\\nint mx = 100000 + 20;\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        segmentTree s(mx);\\n        int res = 0;\\n        for(int i: nums)\\n        {\\n            int l = max(0, i - k);\\n            int h = max(i - 1, 0);\\n            if(l<=h)\\n            {\\n                int qq = s.query(0, 0, mx, l, h);\\n                res = max(res, qq+1);\\n                s.update(0, 0, mx, i, qq+1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567990,
                "title": "iterative-segment-tree",
                "content": "If u are unable to understand the solution, watch the youtube video first\\nhttps://www.youtube.com/watch?v=8CuVOdIWLfA&ab_channel=QuarantineEngineers\\n```\\nint seg[200002];//As 100000th idx will have child having index 200000 and 200001\\n    \\n    int rangeQ(int l,int h,int n){\\n        int res = 0;\\n        l+=n;\\n        h+=n;\\n        while(l<=h){\\n            if(l&1){//if left is as right child, we cant include its parent contribution, so we shift left to its next neighbor\\'s parent\\n                res = max(res,seg[l++]);\\n            }\\n            if(!(h&1)) ////If right is a left child, we cant include its parent contribution, so we shift right to its previous parent\\n                res = max(res,seg[h--]);\\n            l/=2;\\n            h/=2;\\n        }\\n        return res;\\n    }\\n    \\n    void update(int n,int val,int idx){\\n        idx+=n;\\n        seg[idx] = val;\\n        while(idx>1){\\n            idx/=2;\\n            seg[idx] = max(seg[2*idx],seg[2*idx+1]);\\n        }\\n    }\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = *max_element(nums.begin(),nums.end());\\n        int maxx = 0;\\n        for(auto &i:nums){\\n            int longest = 1+rangeQ(max(1,i-k),i-1,n);\\n            maxx = max(maxx,longest);\\n            update(n,longest,i);\\n        }\\n        return maxx;\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Iterator"
                ],
                "code": "```\\nint seg[200002];//As 100000th idx will have child having index 200000 and 200001\\n    \\n    int rangeQ(int l,int h,int n){\\n        int res = 0;\\n        l+=n;\\n        h+=n;\\n        while(l<=h){\\n            if(l&1){//if left is as right child, we cant include its parent contribution, so we shift left to its next neighbor\\'s parent\\n                res = max(res,seg[l++]);\\n            }\\n            if(!(h&1)) ////If right is a left child, we cant include its parent contribution, so we shift right to its previous parent\\n                res = max(res,seg[h--]);\\n            l/=2;\\n            h/=2;\\n        }\\n        return res;\\n    }\\n    \\n    void update(int n,int val,int idx){\\n        idx+=n;\\n        seg[idx] = val;\\n        while(idx>1){\\n            idx/=2;\\n            seg[idx] = max(seg[2*idx],seg[2*idx+1]);\\n        }\\n    }\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = *max_element(nums.begin(),nums.end());\\n        int maxx = 0;\\n        for(auto &i:nums){\\n            int longest = 1+rangeQ(max(1,i-k),i-1,n);\\n            maxx = max(maxx,longest);\\n            update(n,longest,i);\\n        }\\n        return maxx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567673,
                "title": "javascript-iterative-segment-tree",
                "content": "Inspired by [Bakerston Python solution](https://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/2560085/Python-Explanation-with-pictures-Segment-Tree)\\n```\\nclass SegmentTree {\\n    constructor(N) {\\n        this.N = N\\n        this.tree = new Array(2 * N).fill(0)\\n    }\\n    \\n    query(l, r) {\\n        l += this.N\\n        r += this.N\\n        let ans = 0\\n        while (l < r) {\\n            if (l & 1) {\\n                ans = Math.max(ans, this.tree[l])\\n                l++\\n            }\\n            if (r & 1) {\\n                ans = Math.max(ans, this.tree[r-1])\\n\\t\\t\\t\\tr--\\n            }\\n            l >>= 1, r >>= 1\\n        }\\n        return ans\\n    }\\n    \\n    update(i, num) {\\n        i += this.N\\n        this.tree[i] = num\\n        while (i > 1) {\\n            i >>= 1\\n            const maxChild = Math.max(this.tree[2*i], this.tree[2*i+1])\\n            this.tree[i] = maxChild\\n        }\\n    }\\n}\\n\\nconst lengthOfLIS = (nums, k) => {\\n    const tree = new SegmentTree(Math.max(...nums))\\n    let ans = 1\\n    for (let num of nums) {\\n        num--\\n        const prevMaxLIS = tree.query(Math.max(0, num-k), num)\\n        ans = Math.max(ans, prevMaxLIS + 1)\\n        tree.update(num, prevMaxLIS + 1)\\n    }\\n    return ans\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "Inspired by [Bakerston Python solution](https://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/2560085/Python-Explanation-with-pictures-Segment-Tree)\\n```\\nclass SegmentTree {\\n    constructor(N) {\\n        this.N = N\\n        this.tree = new Array(2 * N).fill(0)\\n    }\\n    \\n    query(l, r) {\\n        l += this.N\\n        r += this.N\\n        let ans = 0\\n        while (l < r) {\\n            if (l & 1) {\\n                ans = Math.max(ans, this.tree[l])\\n                l++\\n            }\\n            if (r & 1) {\\n                ans = Math.max(ans, this.tree[r-1])\\n\\t\\t\\t\\tr--\\n            }\\n            l >>= 1, r >>= 1\\n        }\\n        return ans\\n    }\\n    \\n    update(i, num) {\\n        i += this.N\\n        this.tree[i] = num\\n        while (i > 1) {\\n            i >>= 1\\n            const maxChild = Math.max(this.tree[2*i], this.tree[2*i+1])\\n            this.tree[i] = maxChild\\n        }\\n    }\\n}\\n\\nconst lengthOfLIS = (nums, k) => {\\n    const tree = new SegmentTree(Math.max(...nums))\\n    let ans = 1\\n    for (let num of nums) {\\n        num--\\n        const prevMaxLIS = tree.query(Math.max(0, num-k), num)\\n        ans = Math.max(ans, prevMaxLIS + 1)\\n        tree.update(num, prevMaxLIS + 1)\\n    }\\n    return ans\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2566790,
                "title": "python-segment-tree",
                "content": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        def query(tree,v,tl,tr,l,r):\\n            if r < tl or tr < l:\\n                return 0\\n            elif l<=tl and tr<=r:\\n                return tree[v]\\n            else:\\n                m = (tl+tr)//2\\n                return max(query(tree,2*v,tl,m,l,r), query(tree,2*v+1,m+1,tr,l,r))\\n\\n        def update(tree,v,tl,tr,idx,val):\\n            if tl==idx==tr:\\n                tree[v]=val\\n                return val\\n            mid = (tl+tr)//2    \\n            if tl<=idx<=mid:\\n                tree[v]=max(update(tree,2*v,tl,mid,idx,val),tree[2*v+1])\\n            else:\\n                tree[v]=max(tree[2*v],update(tree,2*v+1,mid+1,tr,idx,val))\\n            return tree[v]\\n        \\n        n = max(nums)\\n        \\n        tree = [0]*(4*n)\\n        \\n        for num in nums:\\n            num -= 1\\n            prev = query(tree, 1, 0, n-1, max(0, num-k), num-1)\\n            update(tree, 1, 0, n-1, num, prev + 1)\\n        return query(tree, 1, 0, n-1, 0, n-1)\\n",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        def query(tree,v,tl,tr,l,r):\\n            if r < tl or tr < l:\\n                return 0\\n            elif l<=tl and tr<=r:\\n                return tree[v]\\n            else:\\n                m = (tl+tr)//2\\n                return max(query(tree,2*v,tl,m,l,r), query(tree,2*v+1,m+1,tr,l,r))\\n\\n        def update(tree,v,tl,tr,idx,val):\\n            if tl==idx==tr:\\n                tree[v]=val\\n                return val\\n            mid = (tl+tr)//2    \\n            if tl<=idx<=mid:\\n                tree[v]=max(update(tree,2*v,tl,mid,idx,val),tree[2*v+1])\\n            else:\\n                tree[v]=max(tree[2*v],update(tree,2*v+1,mid+1,tr,idx,val))\\n            return tree[v]\\n        \\n        n = max(nums)\\n        \\n        tree = [0]*(4*n)\\n        \\n        for num in nums:\\n            num -= 1\\n            prev = query(tree, 1, 0, n-1, max(0, num-k), num-1)\\n            update(tree, 1, 0, n-1, num, prev + 1)\\n        return query(tree, 1, 0, n-1, 0, n-1)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2566388,
                "title": "simple-segment-tree-approach-o-n-log-max-array",
                "content": "We start computing the answer from right end to the left of the array. For every index i we want to find the longest sub-sequence that satisfies both the conditions.\\n\\nIf a subsequence starts at ith index then we know that the next element in that subsequence will lie in the range [a[i]+1, a[i]+k]. **So we will choose the next element such that length of subsequence is max so we make a query in segment tree to find the element in the valid range which maximizes the length of subsequence starting at ith index**\\n\\n\\n```\\nclass Solution {\\n    vector<int> st;\\npublic:\\n    int query(int tind,int tl,int tr,int ql,int qr){\\n        if(tl>tr or tl>qr or ql>qr or tr<ql)\\n            return 0;\\n        if(ql<=tl and tr<=qr)\\n            return st[tind];\\n        int tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return max(query(left,tl,tm,ql,qr),query(left+1,tm+1,tr,ql,qr));\\n    }\\n    \\n    int update(int tind,int tl,int tr,int ind,int c){\\n        if(tl>tr)\\n            return 0;\\n        if(tl==tr)\\n            return st[tind]=max(st[tind],c);\\n        int tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,c);\\n        else\\n            update(left+1,tm+1,tr,ind,c);\\n        return st[tind]=max({st[tind],st[left],st[left+1]});\\n    }\\n    \\n    int lengthOfLIS(vector<int>& a, int k) {\\n        int i,n=a.size();\\n        int mx=a[0];\\n        for(auto e:a)\\n            mx=max(mx,e);\\n        st.resize(5*(mx+10),0);\\n        int ans=1;\\n        update(1,1,mx,a[n-1],1);\\n        for(int i=n-2;i>=0;i--){\\n            int curr=1+query(1,1,mx,a[i]+1,a[i]+k);\\n            update(1,1,mx,a[i],curr);\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> st;\\npublic:\\n    int query(int tind,int tl,int tr,int ql,int qr){\\n        if(tl>tr or tl>qr or ql>qr or tr<ql)\\n            return 0;\\n        if(ql<=tl and tr<=qr)\\n            return st[tind];\\n        int tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return max(query(left,tl,tm,ql,qr),query(left+1,tm+1,tr,ql,qr));\\n    }\\n    \\n    int update(int tind,int tl,int tr,int ind,int c){\\n        if(tl>tr)\\n            return 0;\\n        if(tl==tr)\\n            return st[tind]=max(st[tind],c);\\n        int tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,c);\\n        else\\n            update(left+1,tm+1,tr,ind,c);\\n        return st[tind]=max({st[tind],st[left],st[left+1]});\\n    }\\n    \\n    int lengthOfLIS(vector<int>& a, int k) {\\n        int i,n=a.size();\\n        int mx=a[0];\\n        for(auto e:a)\\n            mx=max(mx,e);\\n        st.resize(5*(mx+10),0);\\n        int ans=1;\\n        update(1,1,mx,a[n-1],1);\\n        for(int i=n-2;i>=0;i--){\\n            int curr=1+query(1,1,mx,a[i]+1,a[i]+k);\\n            update(1,1,mx,a[i],curr);\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565753,
                "title": "c-segment-tree-dp-solution-o-n-log-max-n",
                "content": "Runtime: 194 ms, faster than 75.00% of C++ online submissions for Longest Increasing Subsequence II.\\nMemory Usage: 31 MB, less than 100.00% of C++ online submissions for Longest Increasing Subsequence II.\\n\\n\\n```\\nWe have to find the LIS which has consecutive difference of elements of at most K.\\nSo we have to get the max LIS for value X in range from X-K to X-1 inclusive.\\nWe can store the max LIS for value X in Segment tree and also qurey for max LIS for range X-K to X-1. \\n```\\n\\n```\\nclass SegmentTree\\n{\\n    public:\\n    \\n        // usually create 2 * N size array\\n        int tree[200003]={0};\\n        \\n        // original number of values\\n        int N;\\n    \\n        // 1 is the root node of Segment Tree\\n        SegmentTree(int n)\\n        {  \\n            N = n;\\n        }\\n    \\n        // update leaf and then update parent till root\\n        void update(int i, int val)\\n        {\\n            // translate index to leaf node index by adding N\\n            i+=N;\\n            \\n            tree[i]=max(val,tree[i]);\\n            \\n            // update the internal nodes till root\\n            while(i>1)\\n            {\\n                i>>=1;\\n                tree[i]=max(tree[2*i],tree[2*i + 1]);\\n            }\\n        }\\n    \\n        // loop from both end of left and right and get the sum \\n        int get(int left, int right)\\n        {\\n            // translate left and right index to leaf node\\n            left+=N;\\n            right+=N;\\n            \\n            int res = 0;\\n            \\n            // loop through left and right until they converge\\n            while(left<=right)\\n            {\\n                // take left if it right child, means odd\\n                if(left&1)\\n                {\\n                    res = max(res,tree[left]);\\n                    left++;\\n                }\\n                \\n                // take right if it is left right, means even\\n                if(!(right&1))\\n                {\\n                    res = max(res,tree[right]);\\n                    right--;\\n                }\\n                \\n                // level upward to parent\\n                left>>=1;\\n                right>>=1;\\n            }\\n            \\n            return res;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // make segment tree with max element size\\n        int size = *max_element(nums.begin(),nums.end());\\n        SegmentTree tree(size);\\n        \\n        int maxLis = 1;\\n        int lis;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            //get the max lis value in range from val-k to val-1            \\n            lis = tree.get(max(1,nums[i]-k),max(0,nums[i]-1)) + 1;\\n            \\n            //update max lis for current value in segment tree\\n            tree.update(nums[i],lis);\\n            \\n            // update overall max lis with current max lis\\n            maxLis = max(maxLis,lis);\\n        }\\n        \\n        return maxLis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nWe have to find the LIS which has consecutive difference of elements of at most K.\\nSo we have to get the max LIS for value X in range from X-K to X-1 inclusive.\\nWe can store the max LIS for value X in Segment tree and also qurey for max LIS for range X-K to X-1. \\n```\n```\\nclass SegmentTree\\n{\\n    public:\\n    \\n        // usually create 2 * N size array\\n        int tree[200003]={0};\\n        \\n        // original number of values\\n        int N;\\n    \\n        // 1 is the root node of Segment Tree\\n        SegmentTree(int n)\\n        {  \\n            N = n;\\n        }\\n    \\n        // update leaf and then update parent till root\\n        void update(int i, int val)\\n        {\\n            // translate index to leaf node index by adding N\\n            i+=N;\\n            \\n            tree[i]=max(val,tree[i]);\\n            \\n            // update the internal nodes till root\\n            while(i>1)\\n            {\\n                i>>=1;\\n                tree[i]=max(tree[2*i],tree[2*i + 1]);\\n            }\\n        }\\n    \\n        // loop from both end of left and right and get the sum \\n        int get(int left, int right)\\n        {\\n            // translate left and right index to leaf node\\n            left+=N;\\n            right+=N;\\n            \\n            int res = 0;\\n            \\n            // loop through left and right until they converge\\n            while(left<=right)\\n            {\\n                // take left if it right child, means odd\\n                if(left&1)\\n                {\\n                    res = max(res,tree[left]);\\n                    left++;\\n                }\\n                \\n                // take right if it is left right, means even\\n                if(!(right&1))\\n                {\\n                    res = max(res,tree[right]);\\n                    right--;\\n                }\\n                \\n                // level upward to parent\\n                left>>=1;\\n                right>>=1;\\n            }\\n            \\n            return res;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // make segment tree with max element size\\n        int size = *max_element(nums.begin(),nums.end());\\n        SegmentTree tree(size);\\n        \\n        int maxLis = 1;\\n        int lis;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            //get the max lis value in range from val-k to val-1            \\n            lis = tree.get(max(1,nums[i]-k),max(0,nums[i]-1)) + 1;\\n            \\n            //update max lis for current value in segment tree\\n            tree.update(nums[i],lis);\\n            \\n            // update overall max lis with current max lis\\n            maxLis = max(maxLis,lis);\\n        }\\n        \\n        return maxLis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565353,
                "title": "c-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/ff34dbbb-192c-44d9-a162-39348fd7e9ec_1662965313.614581.png)\\n\\n```\\nclass Solution \\n{\\n    public:\\n    int t=100001;\\n    int seg[200002]={0};\\n    void update(int d,int n)\\n    {\\n        d+=t;\\n        seg[d]=n;\\n        while(d)\\n        {\\n            d>>=1;\\n            seg[d]=max(seg[2*d],seg[2*d+1]);\\n        }\\n    }\\n    int query(int l,int r)\\n    {\\n        l+=t;\\n        r+=t;\\n        int result=0;\\n        while(l<r)\\n        {\\n            if(l&1)\\n            {\\n                result=max(result,seg[l]);\\n                l++;\\n            }\\n            if(r&1)\\n            {\\n                r--;\\n                result=max(result,seg[r]);\\n            }\\n            l>>=1;\\n            r>>=1;\\n        }\\n        return result;\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) \\n    {\\n        int result=0,n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=max(nums[i]-k,0);\\n            int r=nums[i];\\n            int c=query(l,r)+1;\\n            result=max(result,c);\\n            update(nums[i],c);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int t=100001;\\n    int seg[200002]={0};\\n    void update(int d,int n)\\n    {\\n        d+=t;\\n        seg[d]=n;\\n        while(d)\\n        {\\n            d>>=1;\\n            seg[d]=max(seg[2*d],seg[2*d+1]);\\n        }\\n    }\\n    int query(int l,int r)\\n    {\\n        l+=t;\\n        r+=t;\\n        int result=0;\\n        while(l<r)\\n        {\\n            if(l&1)\\n            {\\n                result=max(result,seg[l]);\\n                l++;\\n            }\\n            if(r&1)\\n            {\\n                r--;\\n                result=max(result,seg[r]);\\n            }\\n            l>>=1;\\n            r>>=1;\\n        }\\n        return result;\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) \\n    {\\n        int result=0,n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=max(nums[i]-k,0);\\n            int r=nums[i];\\n            int c=query(l,r)+1;\\n            result=max(result,c);\\n            update(nums[i],c);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565146,
                "title": "simple-c-solution-segment-tree",
                "content": "```\\nclass SegmentTree {\\n  public:\\n    int size;\\n    vector<int> values;\\n    \\n    SegmentTree(int n){\\n        size = 1;\\n        while(size < n) size *= 2;\\n        values.resize(2*size+1, 0);\\n    }\\n    \\n    void build(vector<int> &a, int x, int lx, int rx){\\n        if(rx - lx == 1){\\n            if(lx < (int)a.size()) {\\n                values[x] = a[lx];\\n            }\\n            return;\\n        }\\n        int m = (lx + rx) /2;\\n        build(a, 2 * x + 1, lx, m);\\n        build(a, 2 * x + 2, m , rx);\\n        values[x] = max(values[2 * x + 1], values[2 * x + 2]);\\n    }\\n    void build(vector<int> &a){\\n        build(a, 0, 0, size);\\n    }\\n    \\n    int calc(int l, int r){\\n        return calc(l, r, 0, 0, size);\\n    }\\n    \\n    int calc(int l, int r, int x, int lx, int rx){\\n        if(lx >= r || l >= rx) return 0;\\n        if(lx >= l && rx <= r) return values[x];\\n        int m = (lx +rx )/2;\\n        int s1 = calc(l, r, 2 * x + 1, lx, m);\\n        int s2 = calc(l, r, 2 * x + 2, m, rx);\\n        return max(s1, s2);\\n    }\\n    \\n    void set(int i, int val){\\n        set(i, val, 0, 0, size);\\n    }\\n    \\n    void set(int i, int v, int x, int lx, int rx){\\n        if(rx - lx == 1) {\\n            values[x] = v;\\n            return;\\n        }\\n        int m = (lx + rx) / 2;\\n        if(i < m){\\n            set(i, v, 2 * x + 1, lx, m);\\n        }\\n        else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        values[x] = max(values[2 * x + 1], values[2 * x + 2]); \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int res = 0;\\n        SegmentTree tree(1e5+1);\\n        \\n        for(int i=0;i<n;i++){\\n            int num = nums[i];\\n            int lower = max(0, num-k);\\n            int cur = 1 + tree.calc(lower, num);\\n            tree.set(num, cur);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree {\\n  public:\\n    int size;\\n    vector<int> values;\\n    \\n    SegmentTree(int n){\\n        size = 1;\\n        while(size < n) size *= 2;\\n        values.resize(2*size+1, 0);\\n    }\\n    \\n    void build(vector<int> &a, int x, int lx, int rx){\\n        if(rx - lx == 1){\\n            if(lx < (int)a.size()) {\\n                values[x] = a[lx];\\n            }\\n            return;\\n        }\\n        int m = (lx + rx) /2;\\n        build(a, 2 * x + 1, lx, m);\\n        build(a, 2 * x + 2, m , rx);\\n        values[x] = max(values[2 * x + 1], values[2 * x + 2]);\\n    }\\n    void build(vector<int> &a){\\n        build(a, 0, 0, size);\\n    }\\n    \\n    int calc(int l, int r){\\n        return calc(l, r, 0, 0, size);\\n    }\\n    \\n    int calc(int l, int r, int x, int lx, int rx){\\n        if(lx >= r || l >= rx) return 0;\\n        if(lx >= l && rx <= r) return values[x];\\n        int m = (lx +rx )/2;\\n        int s1 = calc(l, r, 2 * x + 1, lx, m);\\n        int s2 = calc(l, r, 2 * x + 2, m, rx);\\n        return max(s1, s2);\\n    }\\n    \\n    void set(int i, int val){\\n        set(i, val, 0, 0, size);\\n    }\\n    \\n    void set(int i, int v, int x, int lx, int rx){\\n        if(rx - lx == 1) {\\n            values[x] = v;\\n            return;\\n        }\\n        int m = (lx + rx) / 2;\\n        if(i < m){\\n            set(i, v, 2 * x + 1, lx, m);\\n        }\\n        else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        values[x] = max(values[2 * x + 1], values[2 * x + 2]); \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int res = 0;\\n        SegmentTree tree(1e5+1);\\n        \\n        for(int i=0;i<n;i++){\\n            int num = nums[i];\\n            int lower = max(0, num-k);\\n            int cur = 1 + tree.calc(lower, num);\\n            tree.set(num, cur);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564710,
                "title": "java-segment-tree",
                "content": "https://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/2560085/Python-Explanation-with-pictures-Segment-Tree\\npost my java solution\\n```java\\nclass Solution {\\n    class MaxSegmentTree {\\n        int[] seg;\\n        int n;\\n        public MaxSegmentTree(int n) {\\n            this.n = n;\\n            this.seg = new int[2*this.n];\\n        }\\n        // region [l, r]\\n        public int query(int l, int r) {\\n            l += this.n;\\n            r += this.n;\\n            int max = 0;\\n            while(l <= r) {\\n                if((l&1) == 1) {\\n                    max = Math.max(max, this.seg[l]);\\n                    l++;\\n                }\\n                if((r&1) == 0) {\\n                    max = Math.max(max, this.seg[r]);\\n                    r--;\\n                }\\n                l>>=1;\\n                r>>=1;\\n            }\\n            return max;\\n        }\\n        public void update(int i, int val) {\\n            i += this.n;\\n            this.seg[i] = val;\\n            while(i>1) {\\n                i >>= 1;\\n                this.seg[i] = Math.max(this.seg[i*2], this.seg[i*2+1]);\\n            }\\n        }\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 1;\\n        for(int num: nums) {\\n            max = Math.max(num, max);\\n        }\\n        // SegmentTree of array [0, 1, 2, 3, ..., max], length is max\\n        MaxSegmentTree seg = new MaxSegmentTree(max+1);\\n        int res = 1;\\n        for(int i=0;i<nums.length;i++) {\\n            int preMax = seg.query(Math.max(1, nums[i]-k), nums[i]-1);\\n            res = Math.max(res, preMax+1);\\n            seg.update(nums[i], preMax+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    class MaxSegmentTree {\\n        int[] seg;\\n        int n;\\n        public MaxSegmentTree(int n) {\\n            this.n = n;\\n            this.seg = new int[2*this.n];\\n        }\\n        // region [l, r]\\n        public int query(int l, int r) {\\n            l += this.n;\\n            r += this.n;\\n            int max = 0;\\n            while(l <= r) {\\n                if((l&1) == 1) {\\n                    max = Math.max(max, this.seg[l]);\\n                    l++;\\n                }\\n                if((r&1) == 0) {\\n                    max = Math.max(max, this.seg[r]);\\n                    r--;\\n                }\\n                l>>=1;\\n                r>>=1;\\n            }\\n            return max;\\n        }\\n        public void update(int i, int val) {\\n            i += this.n;\\n            this.seg[i] = val;\\n            while(i>1) {\\n                i >>= 1;\\n                this.seg[i] = Math.max(this.seg[i*2], this.seg[i*2+1]);\\n            }\\n        }\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int max = 1;\\n        for(int num: nums) {\\n            max = Math.max(num, max);\\n        }\\n        // SegmentTree of array [0, 1, 2, 3, ..., max], length is max\\n        MaxSegmentTree seg = new MaxSegmentTree(max+1);\\n        int res = 1;\\n        for(int i=0;i<nums.length;i++) {\\n            int preMax = seg.query(Math.max(1, nums[i]-k), nums[i]-1);\\n            res = Math.max(res, preMax+1);\\n            seg.update(nums[i], preMax+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564372,
                "title": "concise-c-segment-tree-with-some-explanation-75ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ln = 100001; // Critical point 1: base on the number space range. with 1-based array representation, the size should be space + 1;\\n        int segTree[200002] = {0}; // Faster way to intialize and run.\\n        \\n        //Iterate the number, find the maximum in range k, then update the node and all its ancestor nodes.\\n        for(auto& n: nums) {\\n            // Critical point 2: 1-based to make parents and children relations calculation simpler(parentI = childI >> 1). \\n            int l = max(ln + 1, ln + n - k); // position of the (n-k)-th node. This is the start of the range.\\n            int r = ln + n; // This is the end of the range.\\n            int maxL = 0; // max value from [n - k, n).\\n            \\n            // get max value from [l, r) in segTree.\\n            while (l < r) {  \\n                // If l is odd, use its own value, otherwise skip to its parent;\\n                if(l & 1) maxL = max(maxL, segTree[l++]);\\n                // If r-1 is odd, use its own value, otherwise skip to its parent;\\n                if(r & 1) maxL = max(maxL, segTree[--r]);\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            \\n            // update the segTree[n], and all its ancestor nodes.\\n            if(segTree[ln + n] <= maxL) {\\n                int t = segTree[ln + n] = maxL + 1;\\n                for(int i = (ln + n >> 1); i >= 1; i >>= 1) {\\n                    segTree[i] = max(segTree[i], t);\\n                }\\n            }            \\n        }\\n        return segTree[1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ln = 100001; // Critical point 1: base on the number space range. with 1-based array representation, the size should be space + 1;\\n        int segTree[200002] = {0}; // Faster way to intialize and run.\\n        \\n        //Iterate the number, find the maximum in range k, then update the node and all its ancestor nodes.\\n        for(auto& n: nums) {\\n            // Critical point 2: 1-based to make parents and children relations calculation simpler(parentI = childI >> 1). \\n            int l = max(ln + 1, ln + n - k); // position of the (n-k)-th node. This is the start of the range.\\n            int r = ln + n; // This is the end of the range.\\n            int maxL = 0; // max value from [n - k, n).\\n            \\n            // get max value from [l, r) in segTree.\\n            while (l < r) {  \\n                // If l is odd, use its own value, otherwise skip to its parent;\\n                if(l & 1) maxL = max(maxL, segTree[l++]);\\n                // If r-1 is odd, use its own value, otherwise skip to its parent;\\n                if(r & 1) maxL = max(maxL, segTree[--r]);\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            \\n            // update the segTree[n], and all its ancestor nodes.\\n            if(segTree[ln + n] <= maxL) {\\n                int t = segTree[ln + n] = maxL + 1;\\n                for(int i = (ln + n >> 1); i >= 1; i >>= 1) {\\n                    segTree[i] = max(segTree[i], t);\\n                }\\n            }            \\n        }\\n        return segTree[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564000,
                "title": "java-segment-tree",
                "content": "Brute force solution is O(N^2)\\n```\\n//O(N^2) solutio will trace and update each element from[num - k, num - 1]\\n...\\npublic int lengthOfLIS(int[] nums, int k) {\\n    int[] tail = new int[100001];\\n    for(int num : nums){\\n        for(int i; i>=num-k && i<=num-1;i++) {\\n\\t\\t    ....\\n            maxLen = Math.max(maxLen, tail[i]);     \\n\\t\\t}\\n    }\\n}\\n...\\n```\\nUse segment tree to query and update in logN time, improve the time complexity.\\n```\\nclass Solution {\\n    class SegmentTree {\\n        int longest;\\n        SegmentTree left;\\n        SegmentTree right;\\n        public SegmentTree(int longest){\\n            this.longest = longest;\\n        }\\n    }\\n    private int query(int l, int r){\\n        return query(root, l, r, start, end);\\n    }\\n    private int query(SegmentTree node, int l, int r, int low, int high){\\n        if(l > high || r < low || node == null){\\n            return 0;\\n        }\\n        if(l <= low && r >= high){\\n            return node.longest;\\n        }\\n        int mid = low + (high - low) / 2;\\n        return Math.max(query(node.left, l, r, low, mid), query(node.right, l, r, mid+1, high));\\n    }\\n    private void update(int num, int len){\\n        update(root, num, len, start, end);\\n    }\\n    private int update(SegmentTree node, int num, int len, int low, int high){\\n        if(low == num && high == num){\\n            return node.longest = len;\\n        }\\n        if(num < low || num > high){\\n            return 0;\\n        }\\n        int mid = low + (high - low) / 2;\\n\\t\\t// Don\\'t forget to create the segementTree node\\n        if(node.left == null){\\n            node.left = new SegmentTree(0);\\n        }\\n        if(node.right == null){\\n            node.right = new SegmentTree(0);\\n        }\\n        update(node.left, num, len, low, mid);\\n        update(node.right, num, len, mid + 1, high);\\n        node.longest = Math.max(node.longest, node.left.longest);\\n        node.longest = Math.max(node.longest, node.right.longest);\\n        return node.longest;\\n    }\\n    private int start = 1, end = 100000;\\n    private SegmentTree root = new SegmentTree(0);\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int result = 1;        \\n        for(int num : nums){\\n            int l = Math.max(1, num - k);\\n            int r = num - 1;\\n            int longest = query(l, r) + 1;\\n            result = Math.max(result, longest);\\n            update(num, longest);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(N^2) solutio will trace and update each element from[num - k, num - 1]\\n...\\npublic int lengthOfLIS(int[] nums, int k) {\\n    int[] tail = new int[100001];\\n    for(int num : nums){\\n        for(int i; i>=num-k && i<=num-1;i++) {\\n\\t\\t    ....\\n            maxLen = Math.max(maxLen, tail[i]);     \\n\\t\\t}\\n    }\\n}\\n...\\n```\n```\\nclass Solution {\\n    class SegmentTree {\\n        int longest;\\n        SegmentTree left;\\n        SegmentTree right;\\n        public SegmentTree(int longest){\\n            this.longest = longest;\\n        }\\n    }\\n    private int query(int l, int r){\\n        return query(root, l, r, start, end);\\n    }\\n    private int query(SegmentTree node, int l, int r, int low, int high){\\n        if(l > high || r < low || node == null){\\n            return 0;\\n        }\\n        if(l <= low && r >= high){\\n            return node.longest;\\n        }\\n        int mid = low + (high - low) / 2;\\n        return Math.max(query(node.left, l, r, low, mid), query(node.right, l, r, mid+1, high));\\n    }\\n    private void update(int num, int len){\\n        update(root, num, len, start, end);\\n    }\\n    private int update(SegmentTree node, int num, int len, int low, int high){\\n        if(low == num && high == num){\\n            return node.longest = len;\\n        }\\n        if(num < low || num > high){\\n            return 0;\\n        }\\n        int mid = low + (high - low) / 2;\\n\\t\\t// Don\\'t forget to create the segementTree node\\n        if(node.left == null){\\n            node.left = new SegmentTree(0);\\n        }\\n        if(node.right == null){\\n            node.right = new SegmentTree(0);\\n        }\\n        update(node.left, num, len, low, mid);\\n        update(node.right, num, len, mid + 1, high);\\n        node.longest = Math.max(node.longest, node.left.longest);\\n        node.longest = Math.max(node.longest, node.right.longest);\\n        return node.longest;\\n    }\\n    private int start = 1, end = 100000;\\n    private SegmentTree root = new SegmentTree(0);\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int result = 1;        \\n        for(int num : nums){\\n            int l = Math.max(1, num - k);\\n            int r = num - 1;\\n            int longest = query(l, r) + 1;\\n            result = Math.max(result, longest);\\n            update(num, longest);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563545,
                "title": "c-memoize-state-in-segment-tree",
                "content": "```\\nusing ll = long long;\\nstatic const ll MIN_CONST{0};\\nclass Solution {\\npublic:\\n    \\n    class SegTree {\\n    private:\\n        vector<ll> tree;\\n        vector<ll> data;\\n        \\n        ll build(size_t node, size_t L, size_t R) {\\n            if (L == R) {\\n                tree[node] = data[L];\\n                return tree[node];\\n            } else {\\n                size_t mid = L + (R - L)/2;\\n                tree[node] = max(build(2 * node + 1, L, mid), build(2 * node + 2, mid+1, R));\\n                return tree[node];\\n            }\\n        }\\n        \\n        ll query(size_t node, size_t L, size_t R, size_t l, size_t r) {\\n            if (L >= l && R <= r) {\\n                return tree[node];\\n            } else if (L > r || R < l) {\\n                return MIN_CONST;\\n            } else {\\n                ll mid = L + (R - L)/2;\\n                return max(query(2 * node + 1, L, mid, l, r), query(2 * node + 2, mid+1, R, l, r));\\n            }\\n        }\\n        \\n        ll update(size_t node, size_t L, size_t R, size_t i, ll v) {\\n            if (L >= i && R <= i) {\\n                data[i] = v;\\n                tree[node] = v;\\n                return tree[node];\\n            } else if (R < i || L > i) {\\n                return tree[node];\\n            } else {\\n                size_t mid = L + (R - L)/2;\\n                tree[node] = max(update(2 * node + 1, L, mid, i, v), update(2 * node + 2, mid+1, R, i, v));\\n                return tree[node];\\n            }\\n        }\\n    public:\\n        ll query(size_t l, size_t r) {\\n            return query(0, 1, (ll)data.size() - 1, l, r);\\n        }\\n        \\n        ll update(size_t i, ll v) {\\n            if (v == data[i]) return data[i];\\n            return update(0, 1, (ll)data.size() - 1, i, v);\\n        }\\n        SegTree(vector<ll>&& A) : tree(5 * A.size(), MIN_CONST), data(std::move(A)) {}\\n        \\n    };\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree st(vector<ll> ((*max_element(nums.begin(), nums.end())) + 1, MIN_CONST));\\n        ll ans{1};\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            ll dp = ((nums[i] == 1) ? 0 : st.query(max(1, nums[i] - k), nums[i] - 1));\\n            st.update(nums[i], dp+1);\\n            ans = max(ans, dp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nusing ll = long long;\\nstatic const ll MIN_CONST{0};\\nclass Solution {\\npublic:\\n    \\n    class SegTree {\\n    private:\\n        vector<ll> tree;\\n        vector<ll> data;\\n        \\n        ll build(size_t node, size_t L, size_t R) {\\n            if (L == R) {\\n                tree[node] = data[L];\\n                return tree[node];\\n            } else {\\n                size_t mid = L + (R - L)/2;\\n                tree[node] = max(build(2 * node + 1, L, mid), build(2 * node + 2, mid+1, R));\\n                return tree[node];\\n            }\\n        }\\n        \\n        ll query(size_t node, size_t L, size_t R, size_t l, size_t r) {\\n            if (L >= l && R <= r) {\\n                return tree[node];\\n            } else if (L > r || R < l) {\\n                return MIN_CONST;\\n            } else {\\n                ll mid = L + (R - L)/2;\\n                return max(query(2 * node + 1, L, mid, l, r), query(2 * node + 2, mid+1, R, l, r));\\n            }\\n        }\\n        \\n        ll update(size_t node, size_t L, size_t R, size_t i, ll v) {\\n            if (L >= i && R <= i) {\\n                data[i] = v;\\n                tree[node] = v;\\n                return tree[node];\\n            } else if (R < i || L > i) {\\n                return tree[node];\\n            } else {\\n                size_t mid = L + (R - L)/2;\\n                tree[node] = max(update(2 * node + 1, L, mid, i, v), update(2 * node + 2, mid+1, R, i, v));\\n                return tree[node];\\n            }\\n        }\\n    public:\\n        ll query(size_t l, size_t r) {\\n            return query(0, 1, (ll)data.size() - 1, l, r);\\n        }\\n        \\n        ll update(size_t i, ll v) {\\n            if (v == data[i]) return data[i];\\n            return update(0, 1, (ll)data.size() - 1, i, v);\\n        }\\n        SegTree(vector<ll>&& A) : tree(5 * A.size(), MIN_CONST), data(std::move(A)) {}\\n        \\n    };\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        SegTree st(vector<ll> ((*max_element(nums.begin(), nums.end())) + 1, MIN_CONST));\\n        ll ans{1};\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            ll dp = ((nums[i] == 1) ? 0 : st.query(max(1, nums[i] - k), nums[i] - 1));\\n            st.update(nums[i], dp+1);\\n            ans = max(ans, dp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563169,
                "title": "help-in-implementing-segment-tree",
                "content": "vector<int>seg,v;\\n    int query(int x,int y,int l,int r,int id){\\n        if(x>=y)return 0;\\n        if(x<=l and y>=r)return seg[id];\\n        if(y<=l ||x>=r)return INT_MIN;\\n        int mid=(l+r)/2;\\n        int q1=query(x,y,l,mid,2*id);\\n        int q2=query(x,y,mid,r,2*id+1);\\n        return max(q1,q2);\\n    }\\n    void update(int pos,int val,int l,int r,int id){\\n        \\n        if(r-l==1){\\n            v[pos]=val;\\n            seg[id]=val;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        if(pos<mid)update(pos,val,l,mid,2*id);\\n        else update(pos,val,mid,r,2*id+1);\\n        seg[id]=max(seg[2*id],seg[2*id+1]);\\n        return ;\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        seg.resize(4*1e5+4);\\n        v.resize(1e5+2,0);\\n        int ans=0;\\n        for(int i=0;i<nums.size();++i){\\n            int x=max(nums[i]-k,0),y=max(1,nums[i]-1);\\n            int q=query(x,y,0,1e5+1,1);\\n            update(nums[i],q+1,0,1e5+1,1);\\n            ans=max(ans,q+1);\\n            cout<<q+1<<endl;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\ti got the output as 4 whereas correct output is 5.",
                "solutionTags": [],
                "code": "vector<int>seg,v;\\n    int query(int x,int y,int l,int r,int id){\\n        if(x>=y)return 0;\\n        if(x<=l and y>=r)return seg[id];\\n        if(y<=l ||x>=r)return INT_MIN;\\n        int mid=(l+r)/2;\\n        int q1=query(x,y,l,mid,2*id);\\n        int q2=query(x,y,mid,r,2*id+1);\\n        return max(q1,q2);\\n    }\\n    void update(int pos,int val,int l,int r,int id){\\n        \\n        if(r-l==1){\\n            v[pos]=val;\\n            seg[id]=val;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        if(pos<mid)update(pos,val,l,mid,2*id);\\n        else update(pos,val,mid,r,2*id+1);\\n        seg[id]=max(seg[2*id],seg[2*id+1]);\\n        return ;\\n    }\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        seg.resize(4*1e5+4);\\n        v.resize(1e5+2,0);\\n        int ans=0;\\n        for(int i=0;i<nums.size();++i){\\n            int x=max(nums[i]-k,0),y=max(1,nums[i]-1);\\n            int q=query(x,y,0,1e5+1,1);\\n            update(nums[i],q+1,0,1e5+1,1);\\n            ans=max(ans,q+1);\\n            cout<<q+1<<endl;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\ti got the output as 4 whereas correct output is 5.",
                "codeTag": "C++"
            },
            {
                "id": 2563023,
                "title": "segment-tree-solution-clean-and-precise-6-line-driver-code",
                "content": "```\\n/*\\n    Author : Bhavya Kawatra\\n Institute : MAIT\\n      Dept : CST\\n     Email : bhavyakawatra6@gmail.com\\n CF handle : BhavyaKawatra13\\n*/\\n\\n/*------------------------ Segment Tree Template begin ------------------------*/\\n\\ntemplate<typename Node,typename Update>\\nstruct SegTree{\\n    int n;\\n    vector<int>arr;\\n    vector<Node>tree;\\n    SegTree(int a_len,vector<int>&a){\\n        arr=a;\\n        n=a_len;\\n        int s=1;\\n        while(s<2*n){\\n            s=s<<1;\\n        }\\n        tree.resize(s);\\n        fill(all(tree),Node());//starting m all Nodes will have indentity value\\n        build_tree(0,n-1,1);\\n    }\\n    void build_tree(int l,int r,int indx){\\n        if(l==r){\\n            tree[indx]=Node();\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build_tree(l,mid,2*indx);\\n        build_tree(mid+1,r,2*indx+1);\\n        tree[indx].merge(tree[2*indx],tree[2*indx+1]);\\n    }\\n    Node query(int l,int r,int indx,int qLeft,int qRight){\\n        if(l>=qLeft&&r<=qRight){\\n            return tree[indx];\\n        }\\n        if(l>qRight||r<qLeft){\\n            return Node();\\n        }\\n        Node left,right,ans;\\n        int mid=(l+r)/2;\\n        left=query(l,mid,2*indx,qLeft,qRight);\\n        right=query(mid+1,r,2*indx+1,qLeft,qRight);\\n        ans.merge(left,right);\\n        return ans;\\n    }\\n    void update(int l, int r, int indx, int qIndx, Update&u){\\n        if(l==r){\\n            u.apply(tree[indx]);\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        if(mid>=qIndx){\\n            update(l,mid,2*indx,qIndx,u);\\n        }else{\\n            update(mid+1,r,2*indx+1,qIndx,u);\\n        }\\n        tree[indx].merge(tree[2*indx],tree[2*indx+1]);\\n    }\\n    void make_update(int indx,int val){\\n        Update new_update=Update(val);\\n        update(0,n-1,1,indx,new_update);\\n    }\\n    Node make_query(int left,int right){\\n        return query(0,n-1,1,left,right);\\n    }\\n\\n};\\nstruct Node1{\\n    int val;\\n    Node1(){ //used during initialization and used for identity elemnt\\n        val=0; // -> may change\\n    }\\n    Node1(int value){ //building new nodes with this value\\n        val=0; // -> may change\\n    }\\n    void merge(Node1&l,Node1&r){ // l and r are child nodes\\n        val = max(l.val , r.val);  // -> may change\\n    }\\n};\\nstruct Update1{\\n    int val; //store the value which was recieved during update call\\n    Update1(int value){ \\n        val=value;\\n    }\\n    void apply(Node1&a){//applying update to given node\\n        a.val=val;\\n    }\\n};\\n\\n/*------------------------- Segment Tree Template end -------------------------*/\\n// driver code \\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans=0;\\n        SegTree<Node1,Update1>seg(1e5+5,nums);\\n        for(auto i:nums){\\n            int mx=seg.make_query(i-k,i-1).val;\\n            seg.make_update(i,mx+1);\\n            ans=max(ans,mx+1);\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\n/*\\n    Author : Bhavya Kawatra\\n Institute : MAIT\\n      Dept : CST\\n     Email : bhavyakawatra6@gmail.com\\n CF handle : BhavyaKawatra13\\n*/\\n\\n/*------------------------ Segment Tree Template begin ------------------------*/\\n\\ntemplate<typename Node,typename Update>\\nstruct SegTree{\\n    int n;\\n    vector<int>arr;\\n    vector<Node>tree;\\n    SegTree(int a_len,vector<int>&a){\\n        arr=a;\\n        n=a_len;\\n        int s=1;\\n        while(s<2*n){\\n            s=s<<1;\\n        }\\n        tree.resize(s);\\n        fill(all(tree),Node());//starting m all Nodes will have indentity value\\n        build_tree(0,n-1,1);\\n    }\\n    void build_tree(int l,int r,int indx){\\n        if(l==r){\\n            tree[indx]=Node();\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build_tree(l,mid,2*indx);\\n        build_tree(mid+1,r,2*indx+1);\\n        tree[indx].merge(tree[2*indx],tree[2*indx+1]);\\n    }\\n    Node query(int l,int r,int indx,int qLeft,int qRight){\\n        if(l>=qLeft&&r<=qRight){\\n            return tree[indx];\\n        }\\n        if(l>qRight||r<qLeft){\\n            return Node();\\n        }\\n        Node left,right,ans;\\n        int mid=(l+r)/2;\\n        left=query(l,mid,2*indx,qLeft,qRight);\\n        right=query(mid+1,r,2*indx+1,qLeft,qRight);\\n        ans.merge(left,right);\\n        return ans;\\n    }\\n    void update(int l, int r, int indx, int qIndx, Update&u){\\n        if(l==r){\\n            u.apply(tree[indx]);\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        if(mid>=qIndx){\\n            update(l,mid,2*indx,qIndx,u);\\n        }else{\\n            update(mid+1,r,2*indx+1,qIndx,u);\\n        }\\n        tree[indx].merge(tree[2*indx],tree[2*indx+1]);\\n    }\\n    void make_update(int indx,int val){\\n        Update new_update=Update(val);\\n        update(0,n-1,1,indx,new_update);\\n    }\\n    Node make_query(int left,int right){\\n        return query(0,n-1,1,left,right);\\n    }\\n\\n};\\nstruct Node1{\\n    int val;\\n    Node1(){ //used during initialization and used for identity elemnt\\n        val=0; // -> may change\\n    }\\n    Node1(int value){ //building new nodes with this value\\n        val=0; // -> may change\\n    }\\n    void merge(Node1&l,Node1&r){ // l and r are child nodes\\n        val = max(l.val , r.val);  // -> may change\\n    }\\n};\\nstruct Update1{\\n    int val; //store the value which was recieved during update call\\n    Update1(int value){ \\n        val=value;\\n    }\\n    void apply(Node1&a){//applying update to given node\\n        a.val=val;\\n    }\\n};\\n\\n/*------------------------- Segment Tree Template end -------------------------*/\\n// driver code \\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans=0;\\n        SegTree<Node1,Update1>seg(1e5+5,nums);\\n        for(auto i:nums){\\n            int mx=seg.make_query(i-k,i-1).val;\\n            seg.make_update(i,mx+1);\\n            ans=max(ans,mx+1);\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563009,
                "title": "c-concise-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> t;\\n    \\n    void update(int i, int tl, int tr, int pos, int val) {\\n        t[i] = max(t[i], val);\\n        if (tl == tr) return;\\n        int tm = tl + (tr - tl) / 2;\\n        if (pos <= tm) update(2 * i + 1, tl, tm, pos, val);\\n        else update(2 * i + 2, tm + 1, tr, pos, val);\\n    }\\n    \\n    int query(int i, int tl, int tr, int l, int r) {\\n        if (l > r) return INT_MIN;\\n        if (tl == l && tr == r) return t[i];\\n        int tm = tl + (tr - tl) / 2;\\n        return max(query(2 * i + 1, tl, tm, l, min(tm, r)), query(2 * i + 2, tm + 1, tr, max(l, tm + 1), r));\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int max_value = *max_element(nums.begin(), nums.end());\\n        t = vector<int>(4 * (max_value + 1), 0);\\n        int ans = 0;\\n        for (const auto& num : nums) {\\n            int len = 1 + query(0, 0, max_value, max(0, num - k), max(0, num - 1));\\n            ans = max(ans, len);\\n            update(0, 0, max_value, num, len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> t;\\n    \\n    void update(int i, int tl, int tr, int pos, int val) {\\n        t[i] = max(t[i], val);\\n        if (tl == tr) return;\\n        int tm = tl + (tr - tl) / 2;\\n        if (pos <= tm) update(2 * i + 1, tl, tm, pos, val);\\n        else update(2 * i + 2, tm + 1, tr, pos, val);\\n    }\\n    \\n    int query(int i, int tl, int tr, int l, int r) {\\n        if (l > r) return INT_MIN;\\n        if (tl == l && tr == r) return t[i];\\n        int tm = tl + (tr - tl) / 2;\\n        return max(query(2 * i + 1, tl, tm, l, min(tm, r)), query(2 * i + 2, tm + 1, tr, max(l, tm + 1), r));\\n    }\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int max_value = *max_element(nums.begin(), nums.end());\\n        t = vector<int>(4 * (max_value + 1), 0);\\n        int ans = 0;\\n        for (const auto& num : nums) {\\n            int len = 1 + query(0, 0, max_value, max(0, num - k), max(0, num - 1));\\n            ans = max(ans, len);\\n            update(0, 0, max_value, num, len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562301,
                "title": "c-fastest-solution-using-segment-tree",
                "content": "```\\n\\nclass Solution {\\npublic:\\n  int query(int index,int l,int r,int lq,int rq,int *tr){\\n  if(lq>r or rq<l){\\n    return 0;\\n  }\\n  if(lq<=l and rq>=r){\\n     return tr[index];\\n  }\\n  int mid=(l+r)/2;\\n  int op1=query(2*index,l,mid,lq,rq,tr);\\n  int op2=query(2*index+1,mid+1,r,lq,rq,tr);\\n  return max(op1,op2);\\n \\n}\\nvoid update(int index,int l,int r,int pos,int val,int *tr)\\n{\\n    if(pos>r or pos<l){\\n        return ;\\n    }\\n    if(l==r){\\n       \\n        tr[index]=val;\\n        return ;\\n    }\\n    int mid=(l+r)/2;\\n    update(2*index,l,mid,pos,val,tr);\\n    update(2*index+1,mid+1,r,pos,val,tr);\\n    tr[index]=max(tr[2*index+1],tr[2*index]);\\n \\n}\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       int x=1;\\n        while(x<=200000){\\n            x=x*2;\\n        }\\n        int tr[2*x];\\n        int res=1;\\n        memset(tr,0,sizeof tr);\\n        for(int i=0;i<nums.size();i++){\\n            int l=max(nums[i]-k,1);\\n            int r=nums[i]-1;\\n            int q=query(1,0,x-1,l,r,tr);\\n            res=max(res,q+1);\\n            update(1,0,x-1,nums[i],q+1,tr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n  int query(int index,int l,int r,int lq,int rq,int *tr){\\n  if(lq>r or rq<l){\\n    return 0;\\n  }\\n  if(lq<=l and rq>=r){\\n     return tr[index];\\n  }\\n  int mid=(l+r)/2;\\n  int op1=query(2*index,l,mid,lq,rq,tr);\\n  int op2=query(2*index+1,mid+1,r,lq,rq,tr);\\n  return max(op1,op2);\\n \\n}\\nvoid update(int index,int l,int r,int pos,int val,int *tr)\\n{\\n    if(pos>r or pos<l){\\n        return ;\\n    }\\n    if(l==r){\\n       \\n        tr[index]=val;\\n        return ;\\n    }\\n    int mid=(l+r)/2;\\n    update(2*index,l,mid,pos,val,tr);\\n    update(2*index+1,mid+1,r,pos,val,tr);\\n    tr[index]=max(tr[2*index+1],tr[2*index]);\\n \\n}\\n    \\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       int x=1;\\n        while(x<=200000){\\n            x=x*2;\\n        }\\n        int tr[2*x];\\n        int res=1;\\n        memset(tr,0,sizeof tr);\\n        for(int i=0;i<nums.size();i++){\\n            int l=max(nums[i]-k,1);\\n            int r=nums[i]-1;\\n            int q=query(1,0,x-1,l,r,tr);\\n            res=max(res,q+1);\\n            update(1,0,x-1,nums[i],q+1,tr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562089,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * log(num_range))\\n * Space Complexity: O(num_range)\\n * where `num_range` is `max_num - min_num + 1`\\n *       `max_num` is the maximum number in the vector `nums`\\n *       `min_num` is the minimum number in the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class SegmentTree {\\n   public:\\n    SegmentTree(const int n, const int base) : n_(n), base_(base), tree_(size(n)) {\\n    }\\n    \\n    int read(const int query_left, const int query_right) {\\n      return read_impl(0, 0, n_, query_left - base_, query_right - base_);\\n    }\\n    \\n    void update(const int num, const int value) {\\n      update_impl(0, 0, n_, num - base_, value);\\n    }\\n    \\n   private:\\n    int read_impl(const int node, const int begin, const int end, const int left, const int right) {\\n      if (right <= begin || left >= end) {\\n        return 0;\\n      }\\n      \\n      if (left <= begin && right >= end) {\\n        return tree_[node];\\n      }\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + ((end - begin) >> 1);\\n      \\n      return max(read_impl(left_node, begin, mid, left, right), read_impl(right_node, mid, end, left, right));\\n    }\\n    \\n    void update_impl(const int node, const int begin, const int end, const int index, const int value) {\\n      if (index < begin || index >= end) {\\n        return;\\n      }\\n\\n      if (end - begin == 1) {\\n        tree_[node] = value;\\n        return;\\n      }\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + ((end - begin) >> 1);\\n      update_impl(left_node, begin, mid, index, value);\\n      update_impl(right_node, mid, end, index, value);\\n      tree_[node] = max(tree_[left_node], tree_[right_node]);\\n    }\\n    \\n    int size(const int n) const {\\n      // the `size` should be (2 ^ ((ceil(log2(n))) + 1)) - 1\\n      return (1 << (static_cast<int>(ceil(log2(n))) + 1)) - 1;\\n    }\\n    \\n    const int n_;\\n    const int base_;\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  int lengthOfLIS(const vector<int> &nums, const int k) {\\n    int min_num = numeric_limits<int>::max();\\n    int max_num = numeric_limits<int>::min();\\n    for (const int num : nums) {\\n      min_num = min(min_num, num);\\n      max_num = max(max_num, num);\\n    }\\n    const int num_range = max_num - min_num + 1;\\n    \\n    SegmentTree segment_tree(num_range, min_num);\\n    int ret = 0;\\n    for (const int num : nums) {\\n      const int item = segment_tree.read(num - k, num) + 1;\\n      ret = max(ret, item);\\n      segment_tree.update(num, item);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(num_range))\\n * Space Complexity: O(num_range)\\n * where `num_range` is `max_num - min_num + 1`\\n *       `max_num` is the maximum number in the vector `nums`\\n *       `min_num` is the minimum number in the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class SegmentTree {\\n   public:\\n    SegmentTree(const int n, const int base) : n_(n), base_(base), tree_(size(n)) {\\n    }\\n    \\n    int read(const int query_left, const int query_right) {\\n      return read_impl(0, 0, n_, query_left - base_, query_right - base_);\\n    }\\n    \\n    void update(const int num, const int value) {\\n      update_impl(0, 0, n_, num - base_, value);\\n    }\\n    \\n   private:\\n    int read_impl(const int node, const int begin, const int end, const int left, const int right) {\\n      if (right <= begin || left >= end) {\\n        return 0;\\n      }\\n      \\n      if (left <= begin && right >= end) {\\n        return tree_[node];\\n      }\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + ((end - begin) >> 1);\\n      \\n      return max(read_impl(left_node, begin, mid, left, right), read_impl(right_node, mid, end, left, right));\\n    }\\n    \\n    void update_impl(const int node, const int begin, const int end, const int index, const int value) {\\n      if (index < begin || index >= end) {\\n        return;\\n      }\\n\\n      if (end - begin == 1) {\\n        tree_[node] = value;\\n        return;\\n      }\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + ((end - begin) >> 1);\\n      update_impl(left_node, begin, mid, index, value);\\n      update_impl(right_node, mid, end, index, value);\\n      tree_[node] = max(tree_[left_node], tree_[right_node]);\\n    }\\n    \\n    int size(const int n) const {\\n      // the `size` should be (2 ^ ((ceil(log2(n))) + 1)) - 1\\n      return (1 << (static_cast<int>(ceil(log2(n))) + 1)) - 1;\\n    }\\n    \\n    const int n_;\\n    const int base_;\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  int lengthOfLIS(const vector<int> &nums, const int k) {\\n    int min_num = numeric_limits<int>::max();\\n    int max_num = numeric_limits<int>::min();\\n    for (const int num : nums) {\\n      min_num = min(min_num, num);\\n      max_num = max(max_num, num);\\n    }\\n    const int num_range = max_num - min_num + 1;\\n    \\n    SegmentTree segment_tree(num_range, min_num);\\n    int ret = 0;\\n    for (const int num : nums) {\\n      const int item = segment_tree.read(num - k, num) + 1;\\n      ret = max(ret, item);\\n      segment_tree.update(num, item);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562050,
                "title": "segment-tree-100-space-complexity",
                "content": "for num i find max longest subsequence in range (i-k,i-1);\\n![image](https://assets.leetcode.com/users/images/dd8aa34f-0ca9-4ec3-872e-af93a00799e8_1662895850.6160846.png)\\n```\\nclass Solution {\\npublic:\\n    /// for num i element find max longest subsequence in range (i-k,i-1);\\n    int seg[400004];\\n    int n=100001;\\n    void build(int index,int &val,int cnt,int l,int r){\\n        if(l==r){\\n            if(l==val){\\n                seg[index]=cnt;\\n            }\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        if(l<=val && val<=mid){\\n            build(2*index+1,val,cnt,l,mid);\\n        }\\n        else build(2*index+2,val,cnt,mid+1,r);\\n        \\n        seg[index]=max(seg[2*index+1],seg[2*index+2]);\\n        return ;\\n        \\n    }\\n    int find(int index,int &left,int right,int l,int r){\\n        if(left<=l && r<=right){\\n            return seg[index];\\n        }\\n        if(left>r ||  right<l){\\n            return 0;\\n        }\\n        int mid=(l+r)/2;\\n        int cntleft=find(2*index+1,left,right,l,mid);\\n        int cntright=find(2*index+2,left,right,mid+1,r);\\n        return max(cntleft,cntright);\\n    }\\n    int lengthOfLIS(vector<int>& A, int k) {\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            int start=max(1,A[i]-k);\\n            // int end=A[i]-1;\\n            // find max subsequence in range (start,A[i]-1);\\n            int k=find(0,start,A[i]-1,0,n);\\n            ans=max(ans,k+1);\\n            // update segment tree index of val A[i]\\n            build(0,A[i],k+1,0,n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /// for num i element find max longest subsequence in range (i-k,i-1);\\n    int seg[400004];\\n    int n=100001;\\n    void build(int index,int &val,int cnt,int l,int r){\\n        if(l==r){\\n            if(l==val){\\n                seg[index]=cnt;\\n            }\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        if(l<=val && val<=mid){\\n            build(2*index+1,val,cnt,l,mid);\\n        }\\n        else build(2*index+2,val,cnt,mid+1,r);\\n        \\n        seg[index]=max(seg[2*index+1],seg[2*index+2]);\\n        return ;\\n        \\n    }\\n    int find(int index,int &left,int right,int l,int r){\\n        if(left<=l && r<=right){\\n            return seg[index];\\n        }\\n        if(left>r ||  right<l){\\n            return 0;\\n        }\\n        int mid=(l+r)/2;\\n        int cntleft=find(2*index+1,left,right,l,mid);\\n        int cntright=find(2*index+2,left,right,mid+1,r);\\n        return max(cntleft,cntright);\\n    }\\n    int lengthOfLIS(vector<int>& A, int k) {\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            int start=max(1,A[i]-k);\\n            // int end=A[i]-1;\\n            // find max subsequence in range (start,A[i]-1);\\n            int k=find(0,start,A[i]-1,0,n);\\n            ans=max(ans,k+1);\\n            // update segment tree index of val A[i]\\n            build(0,A[i],k+1,0,n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561915,
                "title": "rust-segment-tree",
                "content": "~~~\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = *nums.iter().max().unwrap() as usize + 1;\\n        let mut tree = vec![0; 4 * n];\\n        let mut ret = 1;\\n        \\n        for a in nums {\\n            let temp = Self::find(&tree, 1, 0, n - 1, i32::max(0, a - k) as usize, a as usize - 1);\\n            ret = ret.max(temp + 1);\\n            Self::update(&mut tree, 1, 0, n - 1, a as usize, temp + 1);\\n        }\\n        \\n        ret\\n    }\\n    \\n    fn find(tree: &Vec<i32>, u: usize, left: usize, right: usize, l: usize, r: usize) -> i32 {\\n        if l > right || r < left { return 0 }\\n        if left == right { return tree[u] }\\n        if left >= l && right <= r { return tree[u] }\\n        \\n        let mid = left + (right - left) / 2;\\n        \\n        let ret1 = Self::find(tree, 2 * u, left, mid, l, r);\\n        let ret2 = Self::find(tree, 2 * u + 1, mid + 1, right, l, r);\\n        \\n        ret1.max(ret2)\\n    }\\n    \\n    fn update(tree: &mut Vec<i32>, u: usize, left: usize, right: usize, i: usize, val: i32) {\\n        if left == right {\\n            tree[u] = val;\\n            return\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n\\t\\t\\n        if i <= mid { Self::update(tree, 2 * u, left, mid, i, val); }\\n        else        { Self::update(tree, 2 * u + 1, mid + 1, right, i, val); }\\n        \\n        tree[u] = i32::max(tree[2 * u], tree[2 * u + 1]);\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Tree"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = *nums.iter().max().unwrap() as usize + 1;\\n        let mut tree = vec![0; 4 * n];\\n        let mut ret = 1;\\n        \\n        for a in nums {\\n            let temp = Self::find(&tree, 1, 0, n - 1, i32::max(0, a - k) as usize, a as usize - 1);\\n            ret = ret.max(temp + 1);\\n            Self::update(&mut tree, 1, 0, n - 1, a as usize, temp + 1);\\n        }\\n        \\n        ret\\n    }\\n    \\n    fn find(tree: &Vec<i32>, u: usize, left: usize, right: usize, l: usize, r: usize) -> i32 {\\n        if l > right || r < left { return 0 }\\n        if left == right { return tree[u] }\\n        if left >= l && right <= r { return tree[u] }\\n        \\n        let mid = left + (right - left) / 2;\\n        \\n        let ret1 = Self::find(tree, 2 * u, left, mid, l, r);\\n        let ret2 = Self::find(tree, 2 * u + 1, mid + 1, right, l, r);\\n        \\n        ret1.max(ret2)\\n    }\\n    \\n    fn update(tree: &mut Vec<i32>, u: usize, left: usize, right: usize, i: usize, val: i32) {\\n        if left == right {\\n            tree[u] = val;\\n            return\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n\\t\\t\\n        if i <= mid { Self::update(tree, 2 * u, left, mid, i, val); }\\n        else        { Self::update(tree, 2 * u + 1, mid + 1, right, i, val); }\\n        \\n        tree[u] = i32::max(tree[2 * u], tree[2 * u + 1]);\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2561787,
                "title": "segment-tree-solution-in-java",
                "content": "```\\nclass Solution {\\n    class segTree{\\n        int n;\\n        int[] arr;\\n        segTree(int n){\\n            this.n=n;\\n            this.arr=new int[n];\\n        }\\n        public int querry(int node,int s,int e,int l,int r){\\n            if(s>e) return 0;\\n            if(r<s || l>e){\\n                return 0;\\n            }\\n            if(s>=l && e<=r){\\n                return arr[node];\\n            }\\n            int mid=s+(e-s)/2;\\n            int q1=querry(2*node,s,mid,l,r);\\n            int q2=querry(2*node+1,mid+1,e,l,r); \\n            return Math.max(q1,q2);\\n        }\\n        public int update(int node,int s,int e,int idx,int val){\\n            if(s>e) return 0;\\n            if(s==e && s==idx){\\n                arr[node]=val;\\n                return val;\\n            } \\n            if(idx<s || idx>e){\\n                return arr[node];\\n            }\\n            int mid=s+(e-s)/2;\\n            int q1=update(2*node,s,mid,idx,val);\\n            int q2=update(2*node+1,mid+1,e,idx,val);\\n            arr[node]=Math.max(q1,q2);\\n            return arr[node];\\n        }\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int maxVal=0;\\n        int ans=1;\\n        for(int num:nums) maxVal=Math.max(maxVal,num);\\n        segTree seg=new segTree(maxVal*4);\\n        int[] arr=new int[maxVal+1];\\n        for(int num:nums){\\n            int r=num-1;\\n            int l=num-k;\\n            int tempMax=seg.querry(1,0,maxVal-1,l,r);\\n            ans=Math.max(ans,tempMax+1);\\n            seg.update(1,0,maxVal-1,num,tempMax+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class segTree{\\n        int n;\\n        int[] arr;\\n        segTree(int n){\\n            this.n=n;\\n            this.arr=new int[n];\\n        }\\n        public int querry(int node,int s,int e,int l,int r){\\n            if(s>e) return 0;\\n            if(r<s || l>e){\\n                return 0;\\n            }\\n            if(s>=l && e<=r){\\n                return arr[node];\\n            }\\n            int mid=s+(e-s)/2;\\n            int q1=querry(2*node,s,mid,l,r);\\n            int q2=querry(2*node+1,mid+1,e,l,r); \\n            return Math.max(q1,q2);\\n        }\\n        public int update(int node,int s,int e,int idx,int val){\\n            if(s>e) return 0;\\n            if(s==e && s==idx){\\n                arr[node]=val;\\n                return val;\\n            } \\n            if(idx<s || idx>e){\\n                return arr[node];\\n            }\\n            int mid=s+(e-s)/2;\\n            int q1=update(2*node,s,mid,idx,val);\\n            int q2=update(2*node+1,mid+1,e,idx,val);\\n            arr[node]=Math.max(q1,q2);\\n            return arr[node];\\n        }\\n    }\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int maxVal=0;\\n        int ans=1;\\n        for(int num:nums) maxVal=Math.max(maxVal,num);\\n        segTree seg=new segTree(maxVal*4);\\n        int[] arr=new int[maxVal+1];\\n        for(int num:nums){\\n            int r=num-1;\\n            int l=num-k;\\n            int tempMax=seg.querry(1,0,maxVal-1,l,r);\\n            ans=Math.max(ans,tempMax+1);\\n            seg.update(1,0,maxVal-1,num,tempMax+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561777,
                "title": "c-segment-tree-clean-solution",
                "content": "```\\nclass SegmentTree {\\n    \\n    vector<int> st; // segment tree\\n    vector<int> arr; // input array\\n    int n; // size of the input array\\n\\t\\n\\t// TODO: MODIFIABLE\\n    int invalidValue = INT_MIN;\\n    \\n\\tint left(int ind) {\\n\\t\\treturn 2*ind + 1;\\n\\t}\\n\\n\\tint right(int ind) {\\n\\t\\treturn 2*ind + 2;\\n\\t}\\n\\n\\t// TODO: MODIFIABLE\\n\\tint operate(int a, int b){\\n\\t\\t// value at a node will be sum of left and right node in the case of Range Sum Query\\n        return max(a, b);\\n\\t}\\n\\n\\t// TODO: MODIFIABLE\\n\\tvoid pull(int ind) {\\n\\t\\tst[ind] = operate(st[left(ind)], st[right(ind)]);\\n\\t}\\n\\n    // building the segment tree\\n    void build(int l, int r, int ind){\\n        // if we have reached the leaf node\\n        if(l == r){\\n            st[ind] = arr[l];\\n            return;\\n        }\\n        \\n        int m = (l+r)/2;\\n        \\n        // build the left tree and right tree\\n        build(l, m, left(ind));\\n        build(m+1, r, right(ind));\\n        \\n        // the value at current node\\n        pull(ind);\\n    }\\n    \\n    int query(int l, int r, int i, int j, int ind){\\n        // if (l, r) lies completely inside (i, j)\\n        if(l>=i and r<=j){\\n            return st[ind];\\n        }\\n        // if (l, r) lies completely outside (i, j)\\n        if(r<i or l>j){\\n            return invalidValue;\\n        }\\n        \\n        int m = (l+r)/2;\\n\\n\\t\\t// call the function recursively for left and right child\\n\\t\\tint leftVal = query(l, m, i, j, left(ind));\\n\\t\\tint rightVal = query(m+1, r, i, j, right(ind));\\n\\n        return operate(leftVal, rightVal);\\n    }\\n    \\n    // updating the value in segment tree\\n    void update(int l, int r, int val, int i, int ind){\\n\\t\\t// if you reach leaf node\\n\\t\\tif(l == r){\\n\\t\\t\\t// if you reach node with index i\\n\\t\\t\\tif(l == i){\\n\\t\\t\\t\\tst[ind] = val;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n        // if i lies completely outside (l, r)\\n        if(i<l or i>r){\\n            return;\\n        }\\n        \\n        // if the current node is not a leaf node\\n        if(l != r){\\n            int m = (l+r)/2;\\n            update(l, m, val, i, left(ind));\\n            update(m+1, r, val, i, right(ind));\\n\\t\\t\\tpull(ind);\\n        }\\n    }\\n    \\npublic:\\n    SegmentTree(vector<int>& nums) {\\n        n = nums.size();\\n        arr = nums;\\n        st = vector<int>(4*n);\\n        \\n        // build the segment tree\\n        build(0, n-1, 0);\\n    }\\n    \\n    void update(int index, int val) {\\n        arr[index] = val;\\n        update(0, n-1, val, index, 0);\\n    }\\n    \\n    int query(int left, int right) {\\n        return query(0, n-1, left, right, 0);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        // the size of the segment tree is given by the maximum element\\n        int len = *max_element(nums.begin(), nums.end()) + 1;\\n        vector<int> arr(len, 0);\\n        \\n        SegmentTree segTree(arr);\\n        \\n        segTree.update(nums[0], 1);\\n        \\n        vector<int> dp(nums.size(), 1);\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            dp[i] = segTree.query(max(0, nums[i]-k), nums[i]-1) + 1;\\n            segTree.update(nums[i], dp[i]);\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree {\\n    \\n    vector<int> st; // segment tree\\n    vector<int> arr; // input array\\n    int n; // size of the input array\\n\\t\\n\\t// TODO: MODIFIABLE\\n    int invalidValue = INT_MIN;\\n    \\n\\tint left(int ind) {\\n\\t\\treturn 2*ind + 1;\\n\\t}\\n\\n\\tint right(int ind) {\\n\\t\\treturn 2*ind + 2;\\n\\t}\\n\\n\\t// TODO: MODIFIABLE\\n\\tint operate(int a, int b){\\n\\t\\t// value at a node will be sum of left and right node in the case of Range Sum Query\\n        return max(a, b);\\n\\t}\\n\\n\\t// TODO: MODIFIABLE\\n\\tvoid pull(int ind) {\\n\\t\\tst[ind] = operate(st[left(ind)], st[right(ind)]);\\n\\t}\\n\\n    // building the segment tree\\n    void build(int l, int r, int ind){\\n        // if we have reached the leaf node\\n        if(l == r){\\n            st[ind] = arr[l];\\n            return;\\n        }\\n        \\n        int m = (l+r)/2;\\n        \\n        // build the left tree and right tree\\n        build(l, m, left(ind));\\n        build(m+1, r, right(ind));\\n        \\n        // the value at current node\\n        pull(ind);\\n    }\\n    \\n    int query(int l, int r, int i, int j, int ind){\\n        // if (l, r) lies completely inside (i, j)\\n        if(l>=i and r<=j){\\n            return st[ind];\\n        }\\n        // if (l, r) lies completely outside (i, j)\\n        if(r<i or l>j){\\n            return invalidValue;\\n        }\\n        \\n        int m = (l+r)/2;\\n\\n\\t\\t// call the function recursively for left and right child\\n\\t\\tint leftVal = query(l, m, i, j, left(ind));\\n\\t\\tint rightVal = query(m+1, r, i, j, right(ind));\\n\\n        return operate(leftVal, rightVal);\\n    }\\n    \\n    // updating the value in segment tree\\n    void update(int l, int r, int val, int i, int ind){\\n\\t\\t// if you reach leaf node\\n\\t\\tif(l == r){\\n\\t\\t\\t// if you reach node with index i\\n\\t\\t\\tif(l == i){\\n\\t\\t\\t\\tst[ind] = val;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n        // if i lies completely outside (l, r)\\n        if(i<l or i>r){\\n            return;\\n        }\\n        \\n        // if the current node is not a leaf node\\n        if(l != r){\\n            int m = (l+r)/2;\\n            update(l, m, val, i, left(ind));\\n            update(m+1, r, val, i, right(ind));\\n\\t\\t\\tpull(ind);\\n        }\\n    }\\n    \\npublic:\\n    SegmentTree(vector<int>& nums) {\\n        n = nums.size();\\n        arr = nums;\\n        st = vector<int>(4*n);\\n        \\n        // build the segment tree\\n        build(0, n-1, 0);\\n    }\\n    \\n    void update(int index, int val) {\\n        arr[index] = val;\\n        update(0, n-1, val, index, 0);\\n    }\\n    \\n    int query(int left, int right) {\\n        return query(0, n-1, left, right, 0);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        // the size of the segment tree is given by the maximum element\\n        int len = *max_element(nums.begin(), nums.end()) + 1;\\n        vector<int> arr(len, 0);\\n        \\n        SegmentTree segTree(arr);\\n        \\n        segTree.update(nums[0], 1);\\n        \\n        vector<int> dp(nums.size(), 1);\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            dp[i] = segTree.query(max(0, nums[i]-k), nums[i]-1) + 1;\\n            segTree.update(nums[i], dp[i]);\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561676,
                "title": "c-o-nlogn-iterative-segment-tree-dp",
                "content": "```\\nclass Solution {\\n    class SegTree{\\n        vector<int>st;\\n        int siz;\\n    public:\\n        SegTree(int n){\\n            siz=1<<int(ceil(log2(n)));\\n            st.resize(2*siz, 0);\\n        }\\n        void upd(int i, int x){\\n            i+=siz;\\n            if(st[i]>=x)return;\\n            st[i]=x;\\n            i/=2;\\n            while(i>0){\\n                st[i] = max(st[i*2], st[i*2+1]);\\n                i/=2;\\n            }\\n        }\\n        int qry(int l, int r){\\n            l+=siz;r+=siz;\\n            int ans=0;\\n            while(l<=r){\\n                if(l%2==1)ans=max(ans, st[l++]);\\n                if(r%2==0)ans=max(ans, st[r--]);\\n                l/=2;\\n                r/=2;\\n            }\\n            return ans;\\n        }\\n    };\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& a, int k) {\\n        int n=a.size();\\n        const int N=1e5+1;\\n        SegTree st(N+1);\\n        for(int i=n-1; i>=0; i--){\\n            int x = 1+st.qry(a[i]+1, min(N-1, a[i]+k));\\n            st.upd(a[i], x);\\n        }\\n        return st.qry(0, N-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class SegTree{\\n        vector<int>st;\\n        int siz;\\n    public:\\n        SegTree(int n){\\n            siz=1<<int(ceil(log2(n)));\\n            st.resize(2*siz, 0);\\n        }\\n        void upd(int i, int x){\\n            i+=siz;\\n            if(st[i]>=x)return;\\n            st[i]=x;\\n            i/=2;\\n            while(i>0){\\n                st[i] = max(st[i*2], st[i*2+1]);\\n                i/=2;\\n            }\\n        }\\n        int qry(int l, int r){\\n            l+=siz;r+=siz;\\n            int ans=0;\\n            while(l<=r){\\n                if(l%2==1)ans=max(ans, st[l++]);\\n                if(r%2==0)ans=max(ans, st[r--]);\\n                l/=2;\\n                r/=2;\\n            }\\n            return ans;\\n        }\\n    };\\n    \\npublic:\\n    int lengthOfLIS(vector<int>& a, int k) {\\n        int n=a.size();\\n        const int N=1e5+1;\\n        SegTree st(N+1);\\n        for(int i=n-1; i>=0; i--){\\n            int x = 1+st.qry(a[i]+1, min(N-1, a[i]+k));\\n            st.upd(a[i], x);\\n        }\\n        return st.qry(0, N-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561499,
                "title": "golang-iterative-segment-tree",
                "content": "Referenced https://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/2560085/Python-Explanation-with-pictures-Segment-Tree\\n\\n```\\ntype SEG struct {\\n    n int\\n    tree []int\\n}\\n\\nfunc NewSeg(n int) *SEG {\\n    seg := &SEG{}\\n    seg.n = n\\n    seg.tree = make([]int, 2 * n)\\n    return seg\\n}\\n\\nfunc (s *SEG) Query(l, r int) int {\\n    l += s.n\\n    r += s.n\\n    ans := 0\\n    for l < r {\\n        if l & 1 == 1 {\\n            ans = max(ans, s.tree[l])\\n            l++\\n        }\\n        if r & 1 == 1 {\\n            r -= 1\\n            ans = max(ans, s.tree[r])\\n        }\\n        l >>= 1\\n        r >>= 1\\n    }\\n    return ans\\n}\\n\\nfunc (s *SEG) Update(i, val int) {\\n    i += s.n\\n    s.tree[i] = val\\n    for i > 1 {\\n        i >>= 1\\n        s.tree[i] = max(s.tree[i*2], s.tree[i*2+1])\\n    }\\n}\\n\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n    n, ans := max(nums...), 1\\n    seg := NewSeg(n)\\n    for _, num := range nums {\\n        num -= 1\\n        preMax := seg.Query(max(0, num-k), num)\\n        ans = max(ans, preMax+1)\\n        seg.Update(num, preMax + 1)\\n    }\\n    return ans\\n}\\n\\nfunc max(nums ...int) int {\\n    maxNum := 0\\n    for i := 0; i < len(nums); i++{\\n        if nums[i] > maxNum {\\n            maxNum = nums[i]\\n        }\\n    }\\n    return maxNum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype SEG struct {\\n    n int\\n    tree []int\\n}\\n\\nfunc NewSeg(n int) *SEG {\\n    seg := &SEG{}\\n    seg.n = n\\n    seg.tree = make([]int, 2 * n)\\n    return seg\\n}\\n\\nfunc (s *SEG) Query(l, r int) int {\\n    l += s.n\\n    r += s.n\\n    ans := 0\\n    for l < r {\\n        if l & 1 == 1 {\\n            ans = max(ans, s.tree[l])\\n            l++\\n        }\\n        if r & 1 == 1 {\\n            r -= 1\\n            ans = max(ans, s.tree[r])\\n        }\\n        l >>= 1\\n        r >>= 1\\n    }\\n    return ans\\n}\\n\\nfunc (s *SEG) Update(i, val int) {\\n    i += s.n\\n    s.tree[i] = val\\n    for i > 1 {\\n        i >>= 1\\n        s.tree[i] = max(s.tree[i*2], s.tree[i*2+1])\\n    }\\n}\\n\\n\\nfunc lengthOfLIS(nums []int, k int) int {\\n    n, ans := max(nums...), 1\\n    seg := NewSeg(n)\\n    for _, num := range nums {\\n        num -= 1\\n        preMax := seg.Query(max(0, num-k), num)\\n        ans = max(ans, preMax+1)\\n        seg.Update(num, preMax + 1)\\n    }\\n    return ans\\n}\\n\\nfunc max(nums ...int) int {\\n    maxNum := 0\\n    for i := 0; i < len(nums); i++{\\n        if nums[i] > maxNum {\\n            maxNum = nums[i]\\n        }\\n    }\\n    return maxNum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561362,
                "title": "o-nlogn-using-dynamic-programming-with-segment-tree-illustration-examples",
                "content": "**Main Idea**:\\n+ Solving \"Longest Increasing Subsequence\" using dynamic programming:\\n  **dp[i] = {dp[j] + 1}** where **j in [0, i-1]** and **nums[i]-k<=nums[j]<=nums[i]-1**\\n  otherwise, dp[i] = 1 where not existing j\\n+ Improving the performance with segmen tree segt as follows:\\n  + **Init method**: **initilizing** **value -inf** for range **[0,...,max(nums))**  \\n  + **Query method**: querying range with **all j in [nums[i]-k,nums[i])** to get **maximum {dp[j]}**\\n  + **Update method**: updating segt with **value dp[i] at position nums[i]** \\n\\n**Examples**:\\n```\\nExample 1: nums: [7, 4, 5, 1, 8, 12, 4, 7] k: 5\\n13 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 4) nums[min -> max]: (-1, 3) segt: [-inf, 1, -inf, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4] dp: [1, 1]\\n++  (2, 5) nums[min -> max]: (0, 4) segt: [-inf, 1, 1, 1, -inf, 1, 1, -inf, -inf, -inf, -inf, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5] dp: [1, 1, 2]\\n++  (3, 1) nums[min -> max]: (-4, 0) segt: [-inf, 2, 2, 1, -inf, 2, 1, -inf, -inf, -inf, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4, 5, 1] dp: [1, 1, 2, 1]\\n++  (4, 8) nums[min -> max]: (3, 7) segt: [-inf, 2, 2, 1, 1, 2, 1, -inf, -inf, 1, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8] dp: [1, 1, 2, 1, 3]\\n++  (5, 12) nums[min -> max]: (7, 11) segt: [-inf, 3, 2, 3, 1, 2, 3, -inf, -inf, 1, -inf, 2, -inf, 3, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  4 nums: [7, 4, 5, 1, 8, 12] dp: [1, 1, 2, 1, 3, 4]\\n++  (6, 4) nums[min -> max]: (-1, 3) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5, 1, 8, 12, 4] dp: [1, 1, 2, 1, 3, 4, 2]\\n++  (7, 7) nums[min -> max]: (2, 6) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 2, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8, 12, 4, 7] dp: [1, 1, 2, 1, 3, 4, 2, 3]\\nans: 4 dp: [1, 1, 2, 1, 3, 4, 2, 3]\\n====================\\n\\nExample 2: nums: [4, 2, 1, 4, 3, 4, 5, 8, 15] k: 3\\n16 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 2) nums[min -> max]: (-1, 1) segt: [-inf, 1, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [4, 2] dp: [1, 1]\\n++  (2, 1) nums[min -> max]: (-2, 0) segt: [-inf, 1, 1, -inf, 1, 1, -inf, -inf, -inf, 1, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [4, 2, 1] dp: [1, 1, 1]\\n++  (3, 4) nums[min -> max]: (1, 3) segt: [-inf, 1, 1, -inf, 1, 1, -inf, -inf, 1, 1, 1, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [4, 2, 1, 4] dp: [1, 1, 1, 2]\\n++  (4, 3) nums[min -> max]: (0, 2) segt: [-inf, 2, 2, -inf, 1, 2, -inf, -inf, 1, 1, 2, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, -inf, 2, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [4, 2, 1, 4, 3] dp: [1, 1, 1, 2, 2]\\n++  (5, 4) nums[min -> max]: (1, 3) segt: [-inf, 2, 2, -inf, 2, 2, -inf, -inf, 1, 2, 2, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, 2, 2, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [4, 2, 1, 4, 3, 4] dp: [1, 1, 1, 2, 2, 3]\\n++  (6, 5) nums[min -> max]: (2, 4) segt: [-inf, 3, 3, -inf, 2, 3, -inf, -inf, 1, 2, 3, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, 2, 3, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  4 nums: [4, 2, 1, 4, 3, 4, 5] dp: [1, 1, 1, 2, 2, 3, 4]\\n++  (7, 8) nums[min -> max]: (5, 7) segt: [-inf, 4, 4, -inf, 2, 4, -inf, -inf, 1, 2, 4, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, 2, 3, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  5 nums: [4, 2, 1, 4, 3, 4, 5, 8] dp: [1, 1, 1, 2, 2, 3, 4, 5]\\n++  (8, 15) nums[min -> max]: (12, 14) segt: [-inf, 5, 4, 5, 2, 4, 5, -inf, 1, 2, 4, -inf, 5, -inf, -inf, -inf, -inf, 1, 1, 2, 3, 4, -inf, -inf, 5, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [4, 2, 1, 4, 3, 4, 5, 8, 15] dp: [1, 1, 1, 2, 2, 3, 4, 5, 1]\\nans: 5 dp: [1, 1, 1, 2, 2, 3, 4, 5, 1]\\n====================\\n\\nExample 3: nums: [7, 4, 5, 1, 8, 12, 4, 7] k: 5\\n13 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 4) nums[min -> max]: (-1, 3) segt: [-inf, 1, -inf, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4] dp: [1, 1]\\n++  (2, 5) nums[min -> max]: (0, 4) segt: [-inf, 1, 1, 1, -inf, 1, 1, -inf, -inf, -inf, -inf, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5] dp: [1, 1, 2]\\n++  (3, 1) nums[min -> max]: (-4, 0) segt: [-inf, 2, 2, 1, -inf, 2, 1, -inf, -inf, -inf, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4, 5, 1] dp: [1, 1, 2, 1]\\n++  (4, 8) nums[min -> max]: (3, 7) segt: [-inf, 2, 2, 1, 1, 2, 1, -inf, -inf, 1, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8] dp: [1, 1, 2, 1, 3]\\n++  (5, 12) nums[min -> max]: (7, 11) segt: [-inf, 3, 2, 3, 1, 2, 3, -inf, -inf, 1, -inf, 2, -inf, 3, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  4 nums: [7, 4, 5, 1, 8, 12] dp: [1, 1, 2, 1, 3, 4]\\n++  (6, 4) nums[min -> max]: (-1, 3) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5, 1, 8, 12, 4] dp: [1, 1, 2, 1, 3, 4, 2]\\n++  (7, 7) nums[min -> max]: (2, 6) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 2, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8, 12, 4, 7] dp: [1, 1, 2, 1, 3, 4, 2, 3]\\nans: 4 dp: [1, 1, 2, 1, 3, 4, 2, 3]\\n====================\\n\\nExample 4: nums: [1, 5] k: 1\\n6 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 5) nums[min -> max]: (4, 4) segt: [-inf, 1, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [1, 5] dp: [1, 1]\\nans: 1 dp: [1, 1]\\n====================\\n\\n```\\n**Code**:\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        \"\"\"\\n        ##############\\n        # Range Minimum Query using Segment Tree\\n        ##############\\n        def init(tree, value, k, left, right):\\n            if len(tree)<k+1:\\n                tree.extend([None] * (k+1-len(tree)))\\n\\n            if right - left == 1:\\n                tree[k] = value\\n                return\\n\\n            mid = (left + right)//2\\n            init(tree, value, 2*k, left, mid)\\n            init(tree, value, 2*k+1, mid, right)\\n            tree[k] = max(tree[2*k], tree[2*k+1])\\n\\n        def update(tree, value, pos, k, left, right):\\n            if right - left == 1: # only 1 elements\\n                tree[k] = value\\n                return\\n\\n            mid = (left + right)//2\\n            if pos<mid:\\n                update(tree, value, pos, 2*k, left, mid)\\n            else:\\n                update(tree, value, pos, 2*k+1, mid, right)\\n            tree[k] = max(tree[2*k], tree[2*k+1])\\n\\n        def query(tree, l, r, k, left, right):\\n            if l>=r:\\n                return None\\n            elif l<=left and right<=r:\\n                return tree[k]\\n\\n            mid = (left + right)//2\\n            v1 = query(tree, l, min(mid, r), 2*k, left, mid)\\n            v2 = query(tree, max(l, mid), r, 2*k+1, mid, right)\\n            v = [v for v in [v1, v2] if v is not None]\\n            ret = None if len(v) == 0 else max(v)\\n            return ret\\n        ##############\\n        \\n        n = len(nums)\\n        # print(nums, k)\\n        # print(len(nums), max(nums), k)\\n\\n        segt = []\\n        sizet = max(nums) + 1\\n        # init(segt, float(\"-inf\"), 1, 0, sizet)\\n        segt = [float(\"-inf\")] * (4 * sizet)\\n        \\n        dp = [1] * n\\n        update(segt, dp[0], nums[0], 1, 0, sizet)\\n        \\n        for i in range(1, n):\\n            dpj = query(segt, nums[i]-k, nums[i], 1, 0, sizet)\\n            if dpj is None:\\n                dp[i] = 1\\n            else:\\n                dp[i] = max(dpj + 1, 1)\\n            update(segt, dp[i], nums[i], 1, 0, sizet)\\n            pass\\n        \\n        ans = max(dp)\\n        # print(\"ans:\", ans)\\n        # print(\"=\" * 20)\\n        return ans\\n    \\n# print = lambda *a, **aa: ()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nExample 1: nums: [7, 4, 5, 1, 8, 12, 4, 7] k: 5\\n13 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 4) nums[min -> max]: (-1, 3) segt: [-inf, 1, -inf, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4] dp: [1, 1]\\n++  (2, 5) nums[min -> max]: (0, 4) segt: [-inf, 1, 1, 1, -inf, 1, 1, -inf, -inf, -inf, -inf, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5] dp: [1, 1, 2]\\n++  (3, 1) nums[min -> max]: (-4, 0) segt: [-inf, 2, 2, 1, -inf, 2, 1, -inf, -inf, -inf, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4, 5, 1] dp: [1, 1, 2, 1]\\n++  (4, 8) nums[min -> max]: (3, 7) segt: [-inf, 2, 2, 1, 1, 2, 1, -inf, -inf, 1, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8] dp: [1, 1, 2, 1, 3]\\n++  (5, 12) nums[min -> max]: (7, 11) segt: [-inf, 3, 2, 3, 1, 2, 3, -inf, -inf, 1, -inf, 2, -inf, 3, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  4 nums: [7, 4, 5, 1, 8, 12] dp: [1, 1, 2, 1, 3, 4]\\n++  (6, 4) nums[min -> max]: (-1, 3) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5, 1, 8, 12, 4] dp: [1, 1, 2, 1, 3, 4, 2]\\n++  (7, 7) nums[min -> max]: (2, 6) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 2, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8, 12, 4, 7] dp: [1, 1, 2, 1, 3, 4, 2, 3]\\nans: 4 dp: [1, 1, 2, 1, 3, 4, 2, 3]\\n====================\\n\\nExample 2: nums: [4, 2, 1, 4, 3, 4, 5, 8, 15] k: 3\\n16 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 2) nums[min -> max]: (-1, 1) segt: [-inf, 1, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [4, 2] dp: [1, 1]\\n++  (2, 1) nums[min -> max]: (-2, 0) segt: [-inf, 1, 1, -inf, 1, 1, -inf, -inf, -inf, 1, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [4, 2, 1] dp: [1, 1, 1]\\n++  (3, 4) nums[min -> max]: (1, 3) segt: [-inf, 1, 1, -inf, 1, 1, -inf, -inf, 1, 1, 1, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [4, 2, 1, 4] dp: [1, 1, 1, 2]\\n++  (4, 3) nums[min -> max]: (0, 2) segt: [-inf, 2, 2, -inf, 1, 2, -inf, -inf, 1, 1, 2, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, -inf, 2, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [4, 2, 1, 4, 3] dp: [1, 1, 1, 2, 2]\\n++  (5, 4) nums[min -> max]: (1, 3) segt: [-inf, 2, 2, -inf, 2, 2, -inf, -inf, 1, 2, 2, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, 2, 2, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [4, 2, 1, 4, 3, 4] dp: [1, 1, 1, 2, 2, 3]\\n++  (6, 5) nums[min -> max]: (2, 4) segt: [-inf, 3, 3, -inf, 2, 3, -inf, -inf, 1, 2, 3, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, 2, 3, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  4 nums: [4, 2, 1, 4, 3, 4, 5] dp: [1, 1, 1, 2, 2, 3, 4]\\n++  (7, 8) nums[min -> max]: (5, 7) segt: [-inf, 4, 4, -inf, 2, 4, -inf, -inf, 1, 2, 4, -inf, -inf, -inf, -inf, -inf, -inf, 1, 1, 2, 3, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  5 nums: [4, 2, 1, 4, 3, 4, 5, 8] dp: [1, 1, 1, 2, 2, 3, 4, 5]\\n++  (8, 15) nums[min -> max]: (12, 14) segt: [-inf, 5, 4, 5, 2, 4, 5, -inf, 1, 2, 4, -inf, 5, -inf, -inf, -inf, -inf, 1, 1, 2, 3, 4, -inf, -inf, 5, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [4, 2, 1, 4, 3, 4, 5, 8, 15] dp: [1, 1, 1, 2, 2, 3, 4, 5, 1]\\nans: 5 dp: [1, 1, 1, 2, 2, 3, 4, 5, 1]\\n====================\\n\\nExample 3: nums: [7, 4, 5, 1, 8, 12, 4, 7] k: 5\\n13 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 4) nums[min -> max]: (-1, 3) segt: [-inf, 1, -inf, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4] dp: [1, 1]\\n++  (2, 5) nums[min -> max]: (0, 4) segt: [-inf, 1, 1, 1, -inf, 1, 1, -inf, -inf, -inf, -inf, 1, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5] dp: [1, 1, 2]\\n++  (3, 1) nums[min -> max]: (-4, 0) segt: [-inf, 2, 2, 1, -inf, 2, 1, -inf, -inf, -inf, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [7, 4, 5, 1] dp: [1, 1, 2, 1]\\n++  (4, 8) nums[min -> max]: (3, 7) segt: [-inf, 2, 2, 1, 1, 2, 1, -inf, -inf, 1, -inf, 2, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8] dp: [1, 1, 2, 1, 3]\\n++  (5, 12) nums[min -> max]: (7, 11) segt: [-inf, 3, 2, 3, 1, 2, 3, -inf, -inf, 1, -inf, 2, -inf, 3, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  4 nums: [7, 4, 5, 1, 8, 12] dp: [1, 1, 2, 1, 3, 4]\\n++  (6, 4) nums[min -> max]: (-1, 3) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 1, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  2 nums: [7, 4, 5, 1, 8, 12, 4] dp: [1, 1, 2, 1, 3, 4, 2]\\n++  (7, 7) nums[min -> max]: (2, 6) segt: [-inf, 4, 2, 4, 1, 2, 3, 4, -inf, 1, -inf, 2, -inf, 3, -inf, 4, -inf, -inf, 1, -inf, -inf, -inf, 2, 2, -inf, -inf, 1, 3, -inf, -inf, -inf, 4, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  3 nums: [7, 4, 5, 1, 8, 12, 4, 7] dp: [1, 1, 2, 1, 3, 4, 2, 3]\\nans: 4 dp: [1, 1, 2, 1, 3, 4, 2, 3]\\n====================\\n\\nExample 4: nums: [1, 5] k: 1\\n6 [-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n++  (1, 5) nums[min -> max]: (4, 4) segt: [-inf, 1, 1, -inf, -inf, 1, -inf, -inf, -inf, -inf, 1, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf]\\n-->  1 nums: [1, 5] dp: [1, 1]\\nans: 1 dp: [1, 1]\\n====================\\n\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        \"\"\"\\n        ##############\\n        # Range Minimum Query using Segment Tree\\n        ##############\\n        def init(tree, value, k, left, right):\\n            if len(tree)<k+1:\\n                tree.extend([None] * (k+1-len(tree)))\\n\\n            if right - left == 1:\\n                tree[k] = value\\n                return\\n\\n            mid = (left + right)//2\\n            init(tree, value, 2*k, left, mid)\\n            init(tree, value, 2*k+1, mid, right)\\n            tree[k] = max(tree[2*k], tree[2*k+1])\\n\\n        def update(tree, value, pos, k, left, right):\\n            if right - left == 1: # only 1 elements\\n                tree[k] = value\\n                return\\n\\n            mid = (left + right)//2\\n            if pos<mid:\\n                update(tree, value, pos, 2*k, left, mid)\\n            else:\\n                update(tree, value, pos, 2*k+1, mid, right)\\n            tree[k] = max(tree[2*k], tree[2*k+1])\\n\\n        def query(tree, l, r, k, left, right):\\n            if l>=r:\\n                return None\\n            elif l<=left and right<=r:\\n                return tree[k]\\n\\n            mid = (left + right)//2\\n            v1 = query(tree, l, min(mid, r), 2*k, left, mid)\\n            v2 = query(tree, max(l, mid), r, 2*k+1, mid, right)\\n            v = [v for v in [v1, v2] if v is not None]\\n            ret = None if len(v) == 0 else max(v)\\n            return ret\\n        ##############\\n        \\n        n = len(nums)\\n        # print(nums, k)\\n        # print(len(nums), max(nums), k)\\n\\n        segt = []\\n        sizet = max(nums) + 1\\n        # init(segt, float(\"-inf\"), 1, 0, sizet)\\n        segt = [float(\"-inf\")] * (4 * sizet)\\n        \\n        dp = [1] * n\\n        update(segt, dp[0], nums[0], 1, 0, sizet)\\n        \\n        for i in range(1, n):\\n            dpj = query(segt, nums[i]-k, nums[i], 1, 0, sizet)\\n            if dpj is None:\\n                dp[i] = 1\\n            else:\\n                dp[i] = max(dpj + 1, 1)\\n            update(segt, dp[i], nums[i], 1, 0, sizet)\\n            pass\\n        \\n        ans = max(dp)\\n        # print(\"ans:\", ans)\\n        # print(\"=\" * 20)\\n        return ans\\n    \\n# print = lambda *a, **aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561337,
                "title": "c-segment-tree",
                "content": "if num is the last one in the longest increasing subsequence, the nearest number before k is [num - k, num - 1]\\n```\\nclass SegmentTree{\\n    private:\\n        int sz = 0;\\n        static int N;\\n        vector<int> Tree;\\n        vector<int> lazy;\\n    public:\\n        void pushUp(int k){\\n            Tree[k] = max(Tree[k << 1], Tree[k << 1 | 1]);\\n        }\\n        void pushDown(int k){\\n            if(lazy[k]){\\n                lazy[k << 1] = lazy[k];\\n                lazy[k << 1 | 1] = lazy[k];\\n                lazy[k] = 0;\\n            }\\n        }\\n        int handleValue(int lvalue, int rvalue){\\n            return max(lvalue, rvalue);\\n        }\\n        int query(const int &L, const int &R, int l=1, int r=N, int k=1){\\n            if(r < L || l > R)\\n                return 0;\\n            if(L <= l && r <= R){\\n                return Tree[k];\\n            }\\n            int m = l + (r - l) / 2;\\n            int lvalue = query(L, R, l, m, k << 1);\\n            int rvalue = query(L, R, m+1, r, k << 1 | 1);\\n            return handleValue(lvalue, rvalue);\\n        }\\n        void update(const int &L, const int &R, int value, int l=1, int r=N, int k=1){\\n            if(r < L || l > R)\\n                return;\\n            if(L <= l && r <= R){\\n                Tree[k] = value;\\n                return;\\n            }\\n            int m = l + (r - l) / 2;\\n            pushDown(k);\\n            update(L, R, value, l, m, k << 1);\\n            update(L, R, value, m+1, r, k << 1 | 1);\\n            pushUp(k);\\n        }\\n        void buildTree(int l=1, int r=N, int k=1){\\n            if(r < l)\\n                return;\\n            if(l == r){\\n                Tree[k] = 0;\\n                return;\\n            }\\n            int m = l + (r - l) / 2;\\n            buildTree(l, m, k << 1);\\n            buildTree(m+1, r, k << 1 | 1);\\n            pushUp(k);\\n        }\\n        SegmentTree(int n){\\n            sz = n << 2;\\n            N = n;\\n            Tree.resize(sz, 0);\\n            lazy.resize(sz, 0);\\n            buildTree();\\n        }\\n};\\nint SegmentTree::N = 0;\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = 1e5, ans = 0;\\n        SegmentTree st = SegmentTree(n);\\n        for(int num: nums){\\n            int l = max(1, num - k);\\n            int q = st.query(l, num-1) + 1;\\n            st.update(num, num, q);\\n            ans = max(ans, q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree{\\n    private:\\n        int sz = 0;\\n        static int N;\\n        vector<int> Tree;\\n        vector<int> lazy;\\n    public:\\n        void pushUp(int k){\\n            Tree[k] = max(Tree[k << 1], Tree[k << 1 | 1]);\\n        }\\n        void pushDown(int k){\\n            if(lazy[k]){\\n                lazy[k << 1] = lazy[k];\\n                lazy[k << 1 | 1] = lazy[k];\\n                lazy[k] = 0;\\n            }\\n        }\\n        int handleValue(int lvalue, int rvalue){\\n            return max(lvalue, rvalue);\\n        }\\n        int query(const int &L, const int &R, int l=1, int r=N, int k=1){\\n            if(r < L || l > R)\\n                return 0;\\n            if(L <= l && r <= R){\\n                return Tree[k];\\n            }\\n            int m = l + (r - l) / 2;\\n            int lvalue = query(L, R, l, m, k << 1);\\n            int rvalue = query(L, R, m+1, r, k << 1 | 1);\\n            return handleValue(lvalue, rvalue);\\n        }\\n        void update(const int &L, const int &R, int value, int l=1, int r=N, int k=1){\\n            if(r < L || l > R)\\n                return;\\n            if(L <= l && r <= R){\\n                Tree[k] = value;\\n                return;\\n            }\\n            int m = l + (r - l) / 2;\\n            pushDown(k);\\n            update(L, R, value, l, m, k << 1);\\n            update(L, R, value, m+1, r, k << 1 | 1);\\n            pushUp(k);\\n        }\\n        void buildTree(int l=1, int r=N, int k=1){\\n            if(r < l)\\n                return;\\n            if(l == r){\\n                Tree[k] = 0;\\n                return;\\n            }\\n            int m = l + (r - l) / 2;\\n            buildTree(l, m, k << 1);\\n            buildTree(m+1, r, k << 1 | 1);\\n            pushUp(k);\\n        }\\n        SegmentTree(int n){\\n            sz = n << 2;\\n            N = n;\\n            Tree.resize(sz, 0);\\n            lazy.resize(sz, 0);\\n            buildTree();\\n        }\\n};\\nint SegmentTree::N = 0;\\n\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int n = 1e5, ans = 0;\\n        SegmentTree st = SegmentTree(n);\\n        for(int num: nums){\\n            int l = max(1, num - k);\\n            int q = st.query(l, num-1) + 1;\\n            st.update(num, num, q);\\n            ans = max(ans, q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561254,
                "title": "python-segment-tree-got-tle-randomly-volatile-runtime",
                "content": "Had a naive, handwritten segment tree during contest,\\n```\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        M = max(nums) + 1\\n        sg = [0] * (4 * M)\\n        \\n        def _update(i, l, r, idx, v):\\n            if idx < l or idx > r:\\n                return\\n            sg[i] = max(sg[i], v)\\n            if l == r:\\n                return\\n            mid = (l + r) // 2\\n            _update(2 * i + 1, l, mid, idx, v)\\n            _update(2 * i + 2, mid + 1, r, idx, v)\\n            \\n        def _query(i, l, r, lq, rq):\\n            if l == lq and rq == r:\\n                return sg[i]\\n            mid = (l + r) // 2\\n            res = -1\\n            if lq <= mid:\\n                res = max(res, _query(2 * i + 1, l, mid, lq, min(rq, mid)))\\n            if rq >= mid + 1:\\n                res = max(res, _query(2 * i + 2, mid + 1, r, max(lq, mid + 1), rq))\\n            return res\\n        \\n        def update(idx, v):\\n            return _update(0, 0, M - 1, idx, v)\\n        \\n        def query(l, r):\\n            return _query(0, 0, M - 1, l, r)\\n        for num in nums:\\n            c = query(max(0, num - k), num - 1)\\n            # print(c, num)\\n            update(num, c + 1)\\n            # print(sg)\\n        return query(0, M - 1)\\n```\\nand got TLE :(\\nHowever, after the contest, I re-run the **same** code multiple times, and sometimes got AC with pretty fast runtime.\\n| submit | runtime |\\n| --- | ----------- |\\n| https://leetcode.com/contest/weekly-contest-310/submissions/detail/796808898/ | TLE |\\n| https://leetcode.com/submissions/detail/796837517/ | 4592 ms |\\n| https://leetcode.com/submissions/detail/796854459/ | TLE |\\n| https://leetcode.com/submissions/detail/796854605/ | TLE |\\n| https://leetcode.com/submissions/detail/796854774/ | 7092 ms |\\nSuppose the time limit for Python3 is 10000ms (got 9891 ms AC for another solution), then it means a standard deviation more than 2000 for runtime. Does anyone have similar issues with Python3?",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\\n        M = max(nums) + 1\\n        sg = [0] * (4 * M)\\n        \\n        def _update(i, l, r, idx, v):\\n            if idx < l or idx > r:\\n                return\\n            sg[i] = max(sg[i], v)\\n            if l == r:\\n                return\\n            mid = (l + r) // 2\\n            _update(2 * i + 1, l, mid, idx, v)\\n            _update(2 * i + 2, mid + 1, r, idx, v)\\n            \\n        def _query(i, l, r, lq, rq):\\n            if l == lq and rq == r:\\n                return sg[i]\\n            mid = (l + r) // 2\\n            res = -1\\n            if lq <= mid:\\n                res = max(res, _query(2 * i + 1, l, mid, lq, min(rq, mid)))\\n            if rq >= mid + 1:\\n                res = max(res, _query(2 * i + 2, mid + 1, r, max(lq, mid + 1), rq))\\n            return res\\n        \\n        def update(idx, v):\\n            return _update(0, 0, M - 1, idx, v)\\n        \\n        def query(l, r):\\n            return _query(0, 0, M - 1, l, r)\\n        for num in nums:\\n            c = query(max(0, num - k), num - 1)\\n            # print(c, num)\\n            update(num, c + 1)\\n            # print(sg)\\n        return query(0, M - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561164,
                "title": "dynamic-segment-tree-cpp-java",
                "content": "Top answers are all implemented in iteration.\\n\\nFor beginners on segment tree, recursion is much more friendly to understand and implement, even though the iterative way is efficient.\\n\\nHere is a rather efficient recursive implementation.\\nwe don\\u2019t need to intialize the whole tree, which is expensive. Just split on the fly when we do each updating.\\n\\nJava version (100+ms) is much faster that cpp (500+ms), which is very counter-intuitive. Maybe some expert could tell me what is happening under the hood. \\nSame solution with python will get TLE, pass 82/86.\\n\\n<iframe src=\"https://leetcode.com/playground/boHH68Pp/shared\" frameBorder=\"0\" width=\"600\" height=\"600\"></iframe>\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "Top answers are all implemented in iteration.\\n\\nFor beginners on segment tree, recursion is much more friendly to understand and implement, even though the iterative way is efficient.\\n\\nHere is a rather efficient recursive implementation.\\nwe don\\u2019t need to intialize the whole tree, which is expensive. Just split on the fly when we do each updating.\\n\\nJava version (100+ms) is much faster that cpp (500+ms), which is very counter-intuitive. Maybe some expert could tell me what is happening under the hood. \\nSame solution with python will get TLE, pass 82/86.\\n\\n<iframe src=\"https://leetcode.com/playground/boHH68Pp/shared\" frameBorder=\"0\" width=\"600\" height=\"600\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2560977,
                "title": "java-universal-segmenttree-implementation",
                "content": "Since I didn\\'t find an implementation of the SegmentTree with a good API, I modified the existing solutions and created the new one.\\n\\nAn example of multiplying SegmentTree:\\n```\\nInteger[] values = {4, 5, 6, 7};\\nInteger neutralElement = 1;\\nBinaryOperator<Integer> multiplicationOperator = (a, b) -> a * b;\\nSegmentTree<Integer> st = new SegmentTree<>(values, neutralElement, multiplicationOperator);\\nst.get(1, 2); // returns 5 * 6\\nst.set(1, 9);\\nst.get(1, 2); // returns 9 * 6\\n```\\nor:\\n```\\nint size = 10;\\nInteger neutralElement = 1;\\nSegmentTree<Integer> st = new SegmentTree<>(size, neutralElement, (a, b) -> a * b);\\nst.get(2, 5); // returns 1\\nst.set(1, 2);\\nst.set(2, 3);\\nst.set(3, 5);\\nst.set(4, 7);\\nst.set(5, 11);\\nst.set(6, 13);\\nst.get(2, 5); // returns 3 * 5 * 7 * 11 * 13\\n```\\n\\n\\nExample of solution of the current task:\\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int maxValue = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > maxValue) {\\n                maxValue = nums[i];\\n            }\\n        }\\n        final int size = maxValue + 1;\\n\\n        SegmentTree<Integer> st = new SegmentTree<>(size, 0, (a, b) -> a > b ? a : b);\\n        int result = 0;\\n\\n        for (int num: nums) {\\n            int newValue = st.get(num - k, num - 1) + 1;\\n            if (newValue > st.get(num, num)) {\\n                st.set(num, newValue);\\n                result = Math.max(result, newValue);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nCode of SegmentTree implementation:\\n```\\nimport java.lang.reflect.Array;\\nimport java.util.Arrays;\\nimport java.util.function.BinaryOperator;\\n\\n\\nclass SegmentTree<T> {\\n    private final int size;\\n    private final T[] array;\\n    public final int length;\\n    public final T neutralElement;\\n    public final BinaryOperator<T> operator;\\n\\n    public SegmentTree(int length, T neutralElement, BinaryOperator<T> operator) {\\n        this.neutralElement = neutralElement;\\n        this.operator = operator;\\n        this.length = length;\\n\\n        int innerSize = 1;\\n        while (innerSize < length) {\\n            innerSize *= 2;\\n        }\\n        this.size = innerSize;\\n        //noinspection unchecked\\n        this.array = (T[])Array.newInstance(neutralElement.getClass(), size * 2 - 1);\\n        Arrays.fill(this.array, neutralElement);\\n    }\\n\\n    public SegmentTree(T[] inputArray, T neutralElement, BinaryOperator<T> operator) {\\n        this(inputArray.length, neutralElement, operator);\\n        build(inputArray, 0,0, size);\\n    }\\n\\n    private void build(T[] inputArray, int stIndex, int leftIndex, int rightIndex) {\\n        if (rightIndex - leftIndex == 1) {\\n            if (leftIndex < inputArray.length) {\\n                array[stIndex] = inputArray[leftIndex];\\n            }\\n            return;\\n        }\\n        int middleIndex = (leftIndex + rightIndex) / 2;\\n        build(inputArray, 2 * stIndex + 1, leftIndex, middleIndex);\\n        build(inputArray, 2 * stIndex + 2, middleIndex, rightIndex);\\n        array[stIndex] = this.operator.apply(array[2 * stIndex + 1], array[2 * stIndex + 2]);\\n    }\\n\\n    private void set(int index, T value, int stIndex, int leftIndex, int rightIndex) {\\n        if (rightIndex - leftIndex == 1) {\\n            array[stIndex] = value;\\n            return;\\n        }\\n        int mid = (leftIndex + rightIndex) / 2;\\n        if (index < mid) {\\n            set(index, value, 2 * stIndex + 1, leftIndex, mid);\\n        } else {\\n            set(index, value, 2 * stIndex + 2, mid, rightIndex);\\n        }\\n        array[stIndex] = this.operator.apply(array[2 * stIndex + 1], array[2 * stIndex + 2]);\\n    }\\n\\n    public void set(int index, T value) {\\n        set(index, value, 0, 0, size);\\n    }\\n\\n    // Returns element in range [leftIndex, rightindex]\\n    public T get(int leftIndex, int rightIndex) {\\n        return get(leftIndex, rightIndex + 1, 0, 0, size);\\n    }\\n\\n    private T get(int leftIndex, int rightIndex, int stIndex, int stLeftIndex, int stRightIndex) {\\n        if (stLeftIndex >= rightIndex || leftIndex >= stRightIndex) {\\n            return neutralElement;\\n        }\\n        if (stLeftIndex >= leftIndex && stRightIndex <= rightIndex) {\\n            return array[stIndex];\\n        }\\n        int middleIndex = (stLeftIndex + stRightIndex) / 2;\\n        T leftValue = get(leftIndex, rightIndex, 2 * stIndex + 1, stLeftIndex, middleIndex);\\n        T rightValue = get(leftIndex, rightIndex, 2 * stIndex + 2, middleIndex, stRightIndex);\\n        return this.operator.apply(leftValue, rightValue);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nInteger[] values = {4, 5, 6, 7};\\nInteger neutralElement = 1;\\nBinaryOperator<Integer> multiplicationOperator = (a, b) -> a * b;\\nSegmentTree<Integer> st = new SegmentTree<>(values, neutralElement, multiplicationOperator);\\nst.get(1, 2); // returns 5 * 6\\nst.set(1, 9);\\nst.get(1, 2); // returns 9 * 6\\n```\n```\\nint size = 10;\\nInteger neutralElement = 1;\\nSegmentTree<Integer> st = new SegmentTree<>(size, neutralElement, (a, b) -> a * b);\\nst.get(2, 5); // returns 1\\nst.set(1, 2);\\nst.set(2, 3);\\nst.set(3, 5);\\nst.set(4, 7);\\nst.set(5, 11);\\nst.set(6, 13);\\nst.get(2, 5); // returns 3 * 5 * 7 * 11 * 13\\n```\n```\\nclass Solution {\\n    public int lengthOfLIS(int[] nums, int k) {\\n        int maxValue = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > maxValue) {\\n                maxValue = nums[i];\\n            }\\n        }\\n        final int size = maxValue + 1;\\n\\n        SegmentTree<Integer> st = new SegmentTree<>(size, 0, (a, b) -> a > b ? a : b);\\n        int result = 0;\\n\\n        for (int num: nums) {\\n            int newValue = st.get(num - k, num - 1) + 1;\\n            if (newValue > st.get(num, num)) {\\n                st.set(num, newValue);\\n                result = Math.max(result, newValue);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nimport java.lang.reflect.Array;\\nimport java.util.Arrays;\\nimport java.util.function.BinaryOperator;\\n\\n\\nclass SegmentTree<T> {\\n    private final int size;\\n    private final T[] array;\\n    public final int length;\\n    public final T neutralElement;\\n    public final BinaryOperator<T> operator;\\n\\n    public SegmentTree(int length, T neutralElement, BinaryOperator<T> operator) {\\n        this.neutralElement = neutralElement;\\n        this.operator = operator;\\n        this.length = length;\\n\\n        int innerSize = 1;\\n        while (innerSize < length) {\\n            innerSize *= 2;\\n        }\\n        this.size = innerSize;\\n        //noinspection unchecked\\n        this.array = (T[])Array.newInstance(neutralElement.getClass(), size * 2 - 1);\\n        Arrays.fill(this.array, neutralElement);\\n    }\\n\\n    public SegmentTree(T[] inputArray, T neutralElement, BinaryOperator<T> operator) {\\n        this(inputArray.length, neutralElement, operator);\\n        build(inputArray, 0,0, size);\\n    }\\n\\n    private void build(T[] inputArray, int stIndex, int leftIndex, int rightIndex) {\\n        if (rightIndex - leftIndex == 1) {\\n            if (leftIndex < inputArray.length) {\\n                array[stIndex] = inputArray[leftIndex];\\n            }\\n            return;\\n        }\\n        int middleIndex = (leftIndex + rightIndex) / 2;\\n        build(inputArray, 2 * stIndex + 1, leftIndex, middleIndex);\\n        build(inputArray, 2 * stIndex + 2, middleIndex, rightIndex);\\n        array[stIndex] = this.operator.apply(array[2 * stIndex + 1], array[2 * stIndex + 2]);\\n    }\\n\\n    private void set(int index, T value, int stIndex, int leftIndex, int rightIndex) {\\n        if (rightIndex - leftIndex == 1) {\\n            array[stIndex] = value;\\n            return;\\n        }\\n        int mid = (leftIndex + rightIndex) / 2;\\n        if (index < mid) {\\n            set(index, value, 2 * stIndex + 1, leftIndex, mid);\\n        } else {\\n            set(index, value, 2 * stIndex + 2, mid, rightIndex);\\n        }\\n        array[stIndex] = this.operator.apply(array[2 * stIndex + 1], array[2 * stIndex + 2]);\\n    }\\n\\n    public void set(int index, T value) {\\n        set(index, value, 0, 0, size);\\n    }\\n\\n    // Returns element in range [leftIndex, rightindex]\\n    public T get(int leftIndex, int rightIndex) {\\n        return get(leftIndex, rightIndex + 1, 0, 0, size);\\n    }\\n\\n    private T get(int leftIndex, int rightIndex, int stIndex, int stLeftIndex, int stRightIndex) {\\n        if (stLeftIndex >= rightIndex || leftIndex >= stRightIndex) {\\n            return neutralElement;\\n        }\\n        if (stLeftIndex >= leftIndex && stRightIndex <= rightIndex) {\\n            return array[stIndex];\\n        }\\n        int middleIndex = (stLeftIndex + stRightIndex) / 2;\\n        T leftValue = get(leftIndex, rightIndex, 2 * stIndex + 1, stLeftIndex, middleIndex);\\n        T rightValue = get(leftIndex, rightIndex, 2 * stIndex + 2, middleIndex, stRightIndex);\\n        return this.operator.apply(leftValue, rightValue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560878,
                "title": "rust-segment-tree-solution",
                "content": "```\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut tree = [0; 2 * 100_000 + 2];\\n        \\n        let mut res = 0;\\n        for &val in &nums {\\n            let left = i32::max(0, val - k);     \\n            \\n            let curr = Self::query(&mut tree, left, val) + 1;\\n            res = res.max(curr);\\n            Self::update(&mut tree, val, curr);\\n        }\\n        res\\n    }\\n    fn update(tree: &mut [i32], idx: i32, val: i32) {\\n        let mut idx = idx as usize + 100_001;\\n        tree[idx] = val;  \\n        \\n        while idx > 1 {\\n            tree[idx >> 1] = tree[idx].max(tree[idx ^ 1]);\\n            idx >>= 1;\\n        }\\n    }\\n    fn query(tree: &[i32], left: i32, right: i32) -> i32 {\\n        let mut left = left as usize + 100_001;\\n        let mut right = right as usize + 100_001;\\n        \\n        let mut res = 0;\\n        while left < right {\\n            if left & 1 == 1 {\\n                res = res.max(tree[left]);\\n                left += 1;\\n            }\\n            if right & 1 == 1 {\\n                right -= 1;\\n                res = res.max(tree[right]);\\n            }\\n            left /= 2;\\n            right /= 2;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut tree = [0; 2 * 100_000 + 2];\\n        \\n        let mut res = 0;\\n        for &val in &nums {\\n            let left = i32::max(0, val - k);     \\n            \\n            let curr = Self::query(&mut tree, left, val) + 1;\\n            res = res.max(curr);\\n            Self::update(&mut tree, val, curr);\\n        }\\n        res\\n    }\\n    fn update(tree: &mut [i32], idx: i32, val: i32) {\\n        let mut idx = idx as usize + 100_001;\\n        tree[idx] = val;  \\n        \\n        while idx > 1 {\\n            tree[idx >> 1] = tree[idx].max(tree[idx ^ 1]);\\n            idx >>= 1;\\n        }\\n    }\\n    fn query(tree: &[i32], left: i32, right: i32) -> i32 {\\n        let mut left = left as usize + 100_001;\\n        let mut right = right as usize + 100_001;\\n        \\n        let mut res = 0;\\n        while left < right {\\n            if left & 1 == 1 {\\n                res = res.max(tree[left]);\\n                left += 1;\\n            }\\n            if right & 1 == 1 {\\n                right -= 1;\\n                res = res.max(tree[right]);\\n            }\\n            left /= 2;\\n            right /= 2;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560825,
                "title": "where-is-the-error",
                "content": "**WHAT IS THE ERROR HERE?? PLEASE ANYBODY HELP**\\n**Input: nums = [4,2,1,4,3,4,5,8,15], k = 3\\nOutput: 5**\\n**FOR THIS TEST CASE IT IS GIVING OUTPUT AS 6**\\n\\n**logic - here I am first creating all the increasing subsequence starting from each number of the array. Then I checked from the end of the subsequence whether any consecutive elements have difference greater than k, if so then we remove those elements. Finally we return the max size of the subsequence possible.**\\n\\n```\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n-1; i++){\\n            vector<int> temp;\\n            int c = 0;\\n            temp.push_back(nums[i]);\\n            for(int j = i+1; j<n; j++){\\n                if(nums[j] > nums[j-1]){\\n                    temp.push_back(nums[j]);\\n                }\\n            }\\n            \\n            for(int l = temp.size()-1; l>=1; l--){\\n                if(nums[l] - nums[l-1] > k){\\n                    c++;\\n                }\\n            }\\n            \\n            if(temp.size()-c > ans) ans = int(temp.size()-c);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n-1; i++){\\n            vector<int> temp;\\n            int c = 0;\\n            temp.push_back(nums[i]);\\n            for(int j = i+1; j<n; j++){\\n                if(nums[j] > nums[j-1]){\\n                    temp.push_back(nums[j]);\\n                }\\n            }\\n            \\n            for(int l = temp.size()-1; l>=1; l--){\\n                if(nums[l] - nums[l-1] > k){\\n                    c++;\\n                }\\n            }\\n            \\n            if(temp.size()-c > ans) ans = int(temp.size()-c);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560710,
                "title": "video-explanation",
                "content": "https://www.youtube.com/watch?v=uGL3m7mq1L8",
                "solutionTags": [
                    "Tree"
                ],
                "code": "https://www.youtube.com/watch?v=uGL3m7mq1L8",
                "codeTag": "Unknown"
            },
            {
                "id": 2560645,
                "title": "c-solution-segment-tree-dp-intution",
                "content": "```\\ntemplate <class T>\\nclass SegmentTree{\\nprivate:\\n    int n;\\n    vector<T> segtree;\\npublic:\\n    SegmentTree(int n){\\n        this->n = n;\\n        segtree.resize(4 * n + 1);\\n    }\\n    T op(T x, T y){\\n        return max(x, y);\\n    }\\n    void updateVal(int x, int l, int r, int idx, T val){\\n        if (l > idx or r < idx)\\n            return;\\n        if (l == r)\\n        {\\n            segtree[x] = val;\\n            return;\\n        }\\n        int mid = (l + r) / 2LL;\\n        updateVal(2 * x, l, mid, idx, val);\\n        updateVal(2 * x + 1, mid + 1, r, idx, val);\\n        segtree[x] = op(segtree[2 * x], segtree[2 * x + 1]);\\n    }\\n    void update(int idx, T val){\\n        updateVal(1, 1, n, idx, val);\\n    }\\n    T cal(int x, int l, int r, int L, int R){\\n        if (L <= l and R >= r)\\n            return segtree[x];\\n        if (L > r or R < l)\\n            return 0;\\n        int mid = (l + r) / 2LL;\\n        return op(cal(2 * x, l, mid, L, R), cal(2 * x + 1, mid + 1, r, L, R));\\n    }\\n    T query(int l, int r){\\n        return l > r ? 0 : cal(1, 1, n, l, r);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        const int M = 1e5 + 1;\\n        SegmentTree<int> dp(M);\\n        for (auto &e : nums)\\n        {\\n            int x = dp.query(e - k, e - 1) + 1;\\n            int y = dp.query(e, e);\\n            if (y < x)\\n                dp.update(e, x);\\n        }\\n        return dp.query(1, M);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate <class T>\\nclass SegmentTree{\\nprivate:\\n    int n;\\n    vector<T> segtree;\\npublic:\\n    SegmentTree(int n){\\n        this->n = n;\\n        segtree.resize(4 * n + 1);\\n    }\\n    T op(T x, T y){\\n        return max(x, y);\\n    }\\n    void updateVal(int x, int l, int r, int idx, T val){\\n        if (l > idx or r < idx)\\n            return;\\n        if (l == r)\\n        {\\n            segtree[x] = val;\\n            return;\\n        }\\n        int mid = (l + r) / 2LL;\\n        updateVal(2 * x, l, mid, idx, val);\\n        updateVal(2 * x + 1, mid + 1, r, idx, val);\\n        segtree[x] = op(segtree[2 * x], segtree[2 * x + 1]);\\n    }\\n    void update(int idx, T val){\\n        updateVal(1, 1, n, idx, val);\\n    }\\n    T cal(int x, int l, int r, int L, int R){\\n        if (L <= l and R >= r)\\n            return segtree[x];\\n        if (L > r or R < l)\\n            return 0;\\n        int mid = (l + r) / 2LL;\\n        return op(cal(2 * x, l, mid, L, R), cal(2 * x + 1, mid + 1, r, L, R));\\n    }\\n    T query(int l, int r){\\n        return l > r ? 0 : cal(1, 1, n, l, r);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        const int M = 1e5 + 1;\\n        SegmentTree<int> dp(M);\\n        for (auto &e : nums)\\n        {\\n            int x = dp.query(e - k, e - 1) + 1;\\n            int y = dp.query(e, e);\\n            if (y < x)\\n                dp.update(e, x);\\n        }\\n        return dp.query(1, M);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1658129,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1938643,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1926480,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1868904,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2066765,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2035411,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2029606,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2017843,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1980408,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1903105,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1658129,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1938643,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1926480,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1868904,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2066765,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2035411,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2029606,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 2017843,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1980408,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            },
            {
                "id": 1903105,
                "content": [
                    {
                        "username": "venubrt",
                        "content": "yep guys ,\\nAs the size of nums given is 10^5\\nso if we perform a algo in O(n^2)\\nit will lead to 10^10 complexity which is practically not feasible and throw TLE(TIME LIMIT EXCEED)\\nso the possible solution can be in O(N log N)"
                    },
                    {
                        "username": "roishevah",
                        "content": "can someone please suggest solutions of these types:\\nmonotonic queue, binary indexed tree and divide and conquer.\\nI didn\\'t see any solution using these approaches, but LeetCode mentions them in the \"related topics\"."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "not a hard question to impliment, but the contraints are harder.\ngot MLE for O(N^2) space complexity solution"
                    },
                    {
                        "username": "adarshgupta2604",
                        "content": "A really hard question found on leetcode \\n "
                    },
                    {
                        "username": "spartan_0810",
                        "content": "class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n       \\n        int n=0,s=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n           n=max(n,nums[i]);\\n        }\\n      \\n        vector<int>ans(n+1,0);\\n        for(int i=0;i<nums.size();i++){\\n              int as=0;\\n            for(int j=max(0,nums[i]-k);j<nums[i];j++){\\n                as=max(as,ans[j]);\\n            }\\n        ans[nums[i]]=as+1;\\n        }\\n        \\n       for(int i=0;i<ans.size();i++){\\n         s=max(s,ans[i]);\\n       }\\n       return s;\\n    }\\n};\\n\\n\\nTLE \\nN*K TIME COMPLEXTY"
                    },
                    {
                        "username": "janis__",
                        "content": "This war very intresting task to solve."
                    },
                    {
                        "username": "vipul0092",
                        "content": "A good problem to learn about implementing Segment tree."
                    },
                    {
                        "username": "hemantkumargothwal07",
                        "content": "if(dp.size()==0||(dp[dp.size()-1]<arr[i] && arr[i]<=dp[dp.size()-1]+k))\\n           dp.push_back(arr[i]);\\n\\n\\n\\nWhy is this line showing me runtime error?"
                    },
                    {
                        "username": "hallenstal",
                        "content": "Is the expected result in  test case starting with [1709,5955..] k=4331 really correct?\\nI get 36 but expected is 63. Did someone switch digits in the expected result? if not what is the expected sequence? My 36 is:\\n[385, 2978, 3217, 3473, 5183, 5685, 6364, 6465, 6750, 6770, 6998, 7112, 7234, 7429, 7513, 7831, 7890, 8306, 8556, 8563, 8696, 8709, 8820, 9006, 9280, 9343, 9380, 9488, 9623, 9739, 9742, 9747, 9813, 9879, 9918, 9982]\\n"
                    },
                    {
                        "username": "priyanshubit",
                        "content": "i got 75 tc passed by this solution... can someone add something for its edge case  try with this  cse [1,4,7,15,5] and k ==1.           class Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums, int k) {\\n        int ans =1;\\n        vector<int> temp;\\n        temp.push_back(nums[0]);\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[i]>temp.back() ){\\n                if( nums[i]-temp.back() <=k ){\\n                ans++;\\n                temp.push_back(nums[i]);\\n                }else{\\n                    temp.back() = nums[i];\\n                }\\n            }else{\\n                int lb= lower_bound(temp.begin(),temp.end(),nums[i])-temp.begin();\\n                // cout<<lb<<endl;\\n                temp[lb]=nums[i];\\n            }\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "sk0822",
                        "content": "try [1,5,7,8] k=3"
                    }
                ]
            }
        ]
    }
]