[
    {
        "title": "Partition Array for Maximum Sum",
        "question_content": "Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\nReturn the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.\n&nbsp;\nExample 1:\n\nInput: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n\nExample 2:\n\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nExample 3:\n\nInput: arr = [1], k = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 500\n\t0 <= arr[i] <= 109\n\t1 <= k <= arr.length",
        "solutions": [
            {
                "id": 290863,
                "title": "java-c-python-dp-o-k-space",
                "content": "# **Explanation**\\n\\n`dp[i]` record the maximum sum we can get considering `A[0] ~ A[i-1]`\\nTo get `dp[i]`, we will try to change `k` last numbers separately to the maximum of them,\\nwhere `k = 1` to `k = K`.\\n\\n# **Solution 1, O(N) space**\\nTime `O(NK)`\\nSpace `O(N)`\\n\\n**Java:**\\n```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N + 1];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best;\\n        }\\n        return dp[N];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best; \\n        }\\n        return dp[N];\\n    }\\n```\\n**Python:**\\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * (N + 1)\\n        for i in xrange(1, N + 1):\\n            curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                dp[i] = max(dp[i], dp[i - k] + curMax * k)\\n        return dp[N]\\n```\\n\\n# **Solution 2, O(K) space**\\nTime `O(NK)`\\nSpace `O(K)`\\n\\n**Java:**\\n```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[K];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best;\\n        }\\n        return dp[N % K];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(K);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best; \\n        }\\n        return dp[N % K];\\n    }\\n```\\n**Python:**\\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * K\\n        for i in xrange(1, N + 1):\\n            best = curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                best = max(best, dp[(i - k) % K] + curMax * k)\\n            dp[i % K] = best\\n        return dp[N % K]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N + 1];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best;\\n        }\\n        return dp[N];\\n    }\\n```\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[i - k] + curMax * k);\\n            }\\n            dp[i] = best; \\n        }\\n        return dp[N];\\n    }\\n```\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * (N + 1)\\n        for i in xrange(1, N + 1):\\n            curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                dp[i] = max(dp[i], dp[i - k] + curMax * k)\\n        return dp[N]\\n```\n```java\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[K];\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k]);\\n                best = Math.max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best;\\n        }\\n        return dp[N % K];\\n    }\\n```\n```cpp\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int N = A.size();\\n        vector<int> dp(K);\\n        for (int i = 1; i <= N; ++i) {\\n            int curMax = 0, best = 0;\\n            for (int k = 1; k <= K && i - k >= 0; ++k) {\\n                curMax = max(curMax, A[i - k]);\\n                best = max(best, dp[(i - k) % K] + curMax * k);\\n            }\\n            dp[i % K] = best; \\n        }\\n        return dp[N % K];\\n    }\\n```\n```py\\n    def maxSumAfterPartitioning(self, A, K):\\n        N = len(A)\\n        dp = [0] * K\\n        for i in xrange(1, N + 1):\\n            best = curMax = 0\\n            for k in xrange(1, min(K, i) + 1):\\n                curMax = max(curMax, A[i - k])\\n                best = max(best, dp[(i - k) % K] + curMax * k)\\n            dp[i % K] = best\\n        return dp[N % K]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 291057,
                "title": "java-visualize-the-pattern",
                "content": "Code is same as others, but I found a way to visualize the pattern. Alfter all, the goal is to derive the rule.\\n\\n```java\\nclass Solution {\\n    // Let k be 2\\n    // Focus on \"growth\" of the pattern\\n    // Define A\\' to be a partition over A that gives max sum\\n    \\n    // #0\\n    // A = {1}\\n    // A\\'= {1} => 1\\n    \\n    // #1\\n    // A = {1, 2}\\n    // A\\'= {1}{2} => 1 + 2 => 3 X\\n    // A\\'= {1, 2} => {2, 2} => 4 AC\\n        \\n    // #2\\n    // A = {1, 2, 9}\\n    // A\\'= {1, 2}{9} => {2, 2}{9} => 4 + 9 => 13 X\\n    // A\\'= {1}{2, 9} => {1}{9, 9} => 1 + 18 => 19 AC\\n    \\n    // #3\\n    // A = {1, 2, 9, 30}\\n    // A\\'= {1}{2, 9}{30} => {1}{9, 9}{30} => 19 + 30 => 49 X\\n    // A\\'= {1, 2}{9, 30} => {2, 2}{30, 30} => 4 + 60 => 64 AC\\n    \\n    // Now, label each instance. Use F1() to represent how A is partitioned and use F2() to represent\\n    // the AC value of that partition. F2() is the dp relation we are looking for.\\n    \\n    // #4\\n    // A = {1, 2, 9, 30, 5}\\n    // A\\'= F1(#3){5} => F2(#3) + 5 => 69 X\\n    // A\\'= F1(#2){30, 5} => F2(#2) + 30 + 30 => 79 AC\\n    // => F2(#4) = 79\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N];\\n        for (int i = 0; i < N; ++i) {\\n            int curMax = 0;\\n            for (int k = 1; k <= K && i - k + 1 >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k + 1]);\\n                dp[i] = Math.max(dp[i], (i >= k ? dp[i - k] : 0) + curMax * k);\\n            }\\n        }\\n        return dp[N - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // Let k be 2\\n    // Focus on \"growth\" of the pattern\\n    // Define A\\' to be a partition over A that gives max sum\\n    \\n    // #0\\n    // A = {1}\\n    // A\\'= {1} => 1\\n    \\n    // #1\\n    // A = {1, 2}\\n    // A\\'= {1}{2} => 1 + 2 => 3 X\\n    // A\\'= {1, 2} => {2, 2} => 4 AC\\n        \\n    // #2\\n    // A = {1, 2, 9}\\n    // A\\'= {1, 2}{9} => {2, 2}{9} => 4 + 9 => 13 X\\n    // A\\'= {1}{2, 9} => {1}{9, 9} => 1 + 18 => 19 AC\\n    \\n    // #3\\n    // A = {1, 2, 9, 30}\\n    // A\\'= {1}{2, 9}{30} => {1}{9, 9}{30} => 19 + 30 => 49 X\\n    // A\\'= {1, 2}{9, 30} => {2, 2}{30, 30} => 4 + 60 => 64 AC\\n    \\n    // Now, label each instance. Use F1() to represent how A is partitioned and use F2() to represent\\n    // the AC value of that partition. F2() is the dp relation we are looking for.\\n    \\n    // #4\\n    // A = {1, 2, 9, 30, 5}\\n    // A\\'= F1(#3){5} => F2(#3) + 5 => 69 X\\n    // A\\'= F1(#2){30, 5} => F2(#2) + 30 + 30 => 79 AC\\n    // => F2(#4) = 79\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int N = A.length, dp[] = new int[N];\\n        for (int i = 0; i < N; ++i) {\\n            int curMax = 0;\\n            for (int k = 1; k <= K && i - k + 1 >= 0; ++k) {\\n                curMax = Math.max(curMax, A[i - k + 1]);\\n                dp[i] = Math.max(dp[i], (i >= k ? dp[i - k] : 0) + curMax * k);\\n            }\\n        }\\n        return dp[N - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299443,
                "title": "java-o-nk-faster-than-99-82-less-memory-than-100-with-explanation",
                "content": "The dynamic programming solution works here because the problem has an optimal substructure and overlapping subproblems as in the following example:\\n\\nLet `A = [9, 10, 2, 5]` and `K = 3`\\n\\nLet `S[n1, n2, ..., ni]` be the solution to subarray `[n1, n2, ..., ni]`.\\nThe following are base cases to initialize the memo array:\\n```\\nS[9] = 9 (i.e., memo[0] = 9)\\nS[9, 10] = 20 (i.e., memo[1] = 20)\\nS[9, 10, 2] = 30 (i.e., memo[2] = 30)\\n```\\n\\nHere we do the real work, where you need to \"loop\" through a K-sized window before the new value to be considered, including the new value, which in this case the new value is 5:\\n```\\nS[9, 10, 2, 5] = max(S[9] + S[10, 2, 5], S[9, 10] + S[2, 5], S[9, 10, 2] + S[5]) = 39\\n```\\nThe window we \"looped\" through above is [10, 2, 5].\\n\\nFrom the formula above, we see that the overlapping subproblem is in using the solutions from previous solutions stored in the memo, e.g., `S[9]`, `S[9, 10]`, and `S[9, 10, 2]`. The optimal substructure comes from the fact that the solution to `S[9, 10, 2, 5]` is solved by using solutions to previously calculated solutions.\\n\\n```\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] memo = new int[A.length];\\n        memo[0] = A[0];\\n        int initMax = A[0];\\n\\n        for(int i = 1; i < K; ++i) {\\n            if (A[i] > initMax) {\\n                initMax = A[i];\\n            }\\n            memo[i] = (i+1) * initMax;\\n        }\\n\\n        for (int i = K; i < A.length; ++i) {\\n            int cur = 0;\\n            int kIntervalMax = A[i];\\n\\t\\t\\t// Backtrack up to K-1 indices to calculate current maximum for memo[i].\\n            for (int j = 1; j <= K; ++j) {\\n\\t\\t\\t    // Keep track of the current maximum in the window [i-j+1, i].\\n                if (A[i-j+1] > kIntervalMax) {\\n                    kIntervalMax = A[i-j+1];\\n                }\\n\\t\\t\\t\\t// cur is the candidate for the solution to memo[i] as we backtrack the K-1 window.\\n                cur = memo[i-j] + j * kIntervalMax;\\n\\n                if (cur > memo[i]) {\\n                    memo[i] = cur;\\n                }\\n            }\\n        }\\n        return memo[A.length-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nS[9] = 9 (i.e., memo[0] = 9)\\nS[9, 10] = 20 (i.e., memo[1] = 20)\\nS[9, 10, 2] = 30 (i.e., memo[2] = 30)\\n```\n```\\nS[9, 10, 2, 5] = max(S[9] + S[10, 2, 5], S[9, 10] + S[2, 5], S[9, 10, 2] + S[5]) = 39\\n```\n```\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] memo = new int[A.length];\\n        memo[0] = A[0];\\n        int initMax = A[0];\\n\\n        for(int i = 1; i < K; ++i) {\\n            if (A[i] > initMax) {\\n                initMax = A[i];\\n            }\\n            memo[i] = (i+1) * initMax;\\n        }\\n\\n        for (int i = K; i < A.length; ++i) {\\n            int cur = 0;\\n            int kIntervalMax = A[i];\\n\\t\\t\\t// Backtrack up to K-1 indices to calculate current maximum for memo[i].\\n            for (int j = 1; j <= K; ++j) {\\n\\t\\t\\t    // Keep track of the current maximum in the window [i-j+1, i].\\n                if (A[i-j+1] > kIntervalMax) {\\n                    kIntervalMax = A[i-j+1];\\n                }\\n\\t\\t\\t\\t// cur is the candidate for the solution to memo[i] as we backtrack the K-1 window.\\n                cur = memo[i-j] + j * kIntervalMax;\\n\\n                if (cur > memo[i]) {\\n                    memo[i] = cur;\\n                }\\n            }\\n        }\\n        return memo[A.length-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370807,
                "title": "dfs-solution-using-memoization-super-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private int dfs(int[] A, int K, int start, int[] dp) {\\n        int n = A.length;\\n        if (start >= n) return 0;\\n        if (dp[start] != 0) {\\n            return dp[start];\\n        }\\n        int maxSum = 0, maxEle = 0;\\n        for (int i = start; i < Math.min(n, start + K); i++) {\\n            maxEle = Math.max(maxEle, A[i]);\\n            maxSum = Math.max(maxSum, maxEle * (i - start + 1) + dfs(A, K, i + 1, dp));\\n        }\\n        dp[start] = maxSum;\\n        return maxSum;\\n    }\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length;\\n        int[] dp = new int[n];\\n        return dfs(A, K, 0, dp);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int dfs(int[] A, int K, int start, int[] dp) {\\n        int n = A.length;\\n        if (start >= n) return 0;\\n        if (dp[start] != 0) {\\n            return dp[start];\\n        }\\n        int maxSum = 0, maxEle = 0;\\n        for (int i = start; i < Math.min(n, start + K); i++) {\\n            maxEle = Math.max(maxEle, A[i]);\\n            maxSum = Math.max(maxSum, maxEle * (i - start + 1) + dfs(A, K, i + 1, dp));\\n        }\\n        dp[start] = maxSum;\\n        return maxSum;\\n    }\\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length;\\n        int[] dp = new int[n];\\n        return dfs(A, K, 0, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621079,
                "title": "python-easy-dp-with-visualization-and-examples",
                "content": "\\nHow to approach:\\n\\nAssume we only look ***back*** for dividing groups\\n\\nTake an example to see how to calculate and roll over:\\n![image](https://assets.leetcode.com/users/images/2fe51237-f8ad-4224-b8d6-d9a23c04187b_1639118918.889263.png)\\n\\nThen the states and transition function is as below:\\n-\\tFirst is to calculate a result for all cases:\\n```\\ncurr = []  # current sub-list\\nfor m in range(k):  # in total m cases\\n\\tcurr += dp[i][j-m-1] + max(arr[(j-m):(j+i)]) * (m+1)\\n```\\ndp[i][j-m-1] : is to use the previous dp result for the previous sum\\narr[(j-m):(j+i)] : by looking back m+1 numbers to find the max and repeat m+1 times\\n\\n-\\tThen is to choose the max result\\n```\\ndp[i][j] = max(curr)\\n```\\n\\n- Since index i in not necessary, we only need j (index of arr), and m (index of k), the script is as below:\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*n\\n        \\n        # handle the first k indexes differently\\n        for j in range(k): dp[j]=max(arr[:j+1])*(j+1)\\n        \\n        # we can get rid of index i by running i times\\n        for j in range(k,n):\\n            curr = []\\n            for m in range(k):\\n                curr.append(dp[j-m-1] + max(arr[(j-m):(j+1)]) * (m+1))\\n            dp[j] = max(curr)\\n\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ncurr = []  # current sub-list\\nfor m in range(k):  # in total m cases\\n\\tcurr += dp[i][j-m-1] + max(arr[(j-m):(j+i)]) * (m+1)\\n```\n```\\ndp[i][j] = max(curr)\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*n\\n        \\n        # handle the first k indexes differently\\n        for j in range(k): dp[j]=max(arr[:j+1])*(j+1)\\n        \\n        # we can get rid of index i by running i times\\n        for j in range(k,n):\\n            curr = []\\n            for m in range(k):\\n                curr.append(dp[j-m-1] + max(arr[(j-m):(j+1)]) * (m+1))\\n            dp[j] = max(curr)\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028098,
                "title": "java-recursive-to-memoization-to-dp",
                "content": "**Recursive**\\n\\n>you should partition the array into (contiguous) subarrays of length at most k\\n\\nAt each index **i** of the array, we have **k** decision to make on how to partition the array as follows,\\n0 - Partition at index **i** so we will have array of size 1.\\n1 - Partition at index **i + 1** so we will have array of size 2.\\n.\\n.\\nk-1 - Partition at index **i + k - 1** so we will have array of size k.\\n\\n>After partitioning, each subarray has their values changed to become the maximum value of that subarray\\n\\nSince the problem says all the elements in the partition become the maximum value. We maintain the partition array running max and multiply the max with number of elements in the partition.\\n\\nAfter each partition the array we get on the right side of the partition is a sub problem (**optimal substructure**) so we call the recursion on it (with starting index of right partion) and add the result with previously computed current left array partition max sum.\\nSince the problem asks to find the largest, we take the maximum on the **k** decisions we made early.\\n\\n\\n\\nTree diagram for input [1, 15, 7, 9] with k = 2.\\nIt is possible to see the **overlapping subproblems** marked with star symbol.\\n\\n![image](https://assets.leetcode.com/users/images/81394224-f839-4cf0-b7ca-7cf667988d7a_1611250596.0235531.png)\\n\\n\\n```\\n\\tpublic int maxSumAfterPartitioning_r(int[] arr, int k) {\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) { // k decision to partition the array\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) { // stop partition when we we reach end of the array\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]); // Running maximum of left partition array\\n\\t\\t\\tint leftPartionSum = currMax * (j + 1); // sum of left partition\\n\\t\\t\\tint rightPartionMaxSum = maxSumAfterPartitioning(arr, k, to + 1); // Max Sum of right partition - Sub problem\\n\\t\\t\\tsumMax = Math.max(sumMax, leftPartionSum + rightPartionMaxSum); // Since problem asks for largest sum, we track the largest sum of k decisions we are making in this loop.\\n\\t\\t}\\n\\t\\treturn sumMax;\\n\\t}\\n```\\n\\n**Memoization**\\nAs previously pointed, we have repeating subproblems for same index of **i**, to avoid recomputation we want to store the result and use it when needed. What is the state based on which we can store the result? If we see the recursive method signature the only variable (state) that is changing is **i**. So we create a array of same size that of the input and use it for memoization.\\n```\\n\\tpublic int maxSumAfterPartitioning_memo(int[] arr, int k) {\\n\\t\\tInteger[] memo = new Integer[arr.length];\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0, memo);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i, Integer[] memo) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (memo[i] != null) {\\n\\t\\t\\treturn memo[i];\\n\\t\\t}\\n\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]);\\n\\t\\t\\tsumMax = Math.max(sumMax, (currMax * (j + 1)) + maxSumAfterPartitioning(arr, k, to + 1, memo));\\n\\t\\t}\\n\\t\\treturn memo[i] = sumMax;\\n\\t}\\n```\\n\\n**DP**\\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\tint[] dp = new int[arr.length];\\n\\t\\tfor (int to = 0; to < arr.length; to++) {\\n\\t\\t\\tint currMax = 0;\\n\\t\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\t\\tint from = to - j;\\n\\t\\t\\t\\tif (from < 0) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrMax = Math.max(currMax, arr[from]);\\n\\t\\t\\t\\tint newSplitVal = (currMax * (j + 1)) + getVal(dp, from - 1);\\n\\t\\t\\t\\tdp[to] = Math.max(dp[to], newSplitVal);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[arr.length - 1];\\n\\t}\\n\\n\\tprivate int getVal(int[] dp, int i) {\\n\\t\\tif (i < 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn dp[i];\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tpublic int maxSumAfterPartitioning_r(int[] arr, int k) {\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) { // k decision to partition the array\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) { // stop partition when we we reach end of the array\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]); // Running maximum of left partition array\\n\\t\\t\\tint leftPartionSum = currMax * (j + 1); // sum of left partition\\n\\t\\t\\tint rightPartionMaxSum = maxSumAfterPartitioning(arr, k, to + 1); // Max Sum of right partition - Sub problem\\n\\t\\t\\tsumMax = Math.max(sumMax, leftPartionSum + rightPartionMaxSum); // Since problem asks for largest sum, we track the largest sum of k decisions we are making in this loop.\\n\\t\\t}\\n\\t\\treturn sumMax;\\n\\t}\\n```\n```\\n\\tpublic int maxSumAfterPartitioning_memo(int[] arr, int k) {\\n\\t\\tInteger[] memo = new Integer[arr.length];\\n\\t\\treturn maxSumAfterPartitioning(arr, k, 0, memo);\\n\\t}\\n\\n\\tprivate int maxSumAfterPartitioning(int[] arr, int k, int i, Integer[] memo) {\\n\\t\\tif (i == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (memo[i] != null) {\\n\\t\\t\\treturn memo[i];\\n\\t\\t}\\n\\n\\t\\tint currMax = 0;\\n\\t\\tint sumMax = 0;\\n\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\tint to = i + j;\\n\\t\\t\\tif (to >= arr.length) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrMax = Math.max(currMax, arr[to]);\\n\\t\\t\\tsumMax = Math.max(sumMax, (currMax * (j + 1)) + maxSumAfterPartitioning(arr, k, to + 1, memo));\\n\\t\\t}\\n\\t\\treturn memo[i] = sumMax;\\n\\t}\\n```\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\tint[] dp = new int[arr.length];\\n\\t\\tfor (int to = 0; to < arr.length; to++) {\\n\\t\\t\\tint currMax = 0;\\n\\t\\t\\tfor (int j = 0; j < k; j++) {\\n\\t\\t\\t\\tint from = to - j;\\n\\t\\t\\t\\tif (from < 0) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrMax = Math.max(currMax, arr[from]);\\n\\t\\t\\t\\tint newSplitVal = (currMax * (j + 1)) + getVal(dp, from - 1);\\n\\t\\t\\t\\tdp[to] = Math.max(dp[to], newSplitVal);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[arr.length - 1];\\n\\t}\\n\\n\\tprivate int getVal(int[] dp, int i) {\\n\\t\\tif (i < 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn dp[i];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299049,
                "title": "dp-python-commented-code",
                "content": "So essentially, the subproblem is\\n\\nSuppose you are at position X of the array\\nWhat is the maximum possible sum to this point?\\nso you go back K-1 step\\n\\nyou choose the maximum from the following combinations:\\n\\ndp_sum[X - 1] +  max(A[X])*1\\ndp_sum[X - 2] +  max(A[X-1], A[X])*2\\ndp_sum[X - 3] + max(A[X-2], A[X-1], A[X])*3\\n.....\\ndp_sum[X - (k-1)] + max(A[X-(k-2)] ..... A[X])*(k-1)\\n\\n\\n```\\n\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        # initialization\\n        dp_sum = [0 for x in range(len(A))]\\n        dp_sum[0] = A[0]\\n        max_so_far = A[0]\\n        for x in range(1,K):\\n            max_so_far = max(max_so_far, A[x])\\n            dp_sum[x] = (x+1)*max_so_far\\n\\n        \\n        # find the maximum sum so far as if this is the end of a partition\\n        for ind in range(K, len(dp_sum)):\\n            \\n            # go back K-1 steps to find the maximum so far\\n            \\n            partition_max = 0\\n            for back in range(K):\\n                partition_max = max(partition_max, A[ind - back])\\n                prev_sum = dp_sum[ind - back - 1]\\n                \\n                dp_sum[ind] = max(dp_sum[ind], prev_sum + (back+1)*partition_max)\\n        \\n        \\n        return dp_sum[-1]\\n\\t\\t\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        # initialization\\n        dp_sum = [0 for x in range(len(A))]\\n        dp_sum[0] = A[0]\\n        max_so_far = A[0]\\n        for x in range(1,K):\\n            max_so_far = max(max_so_far, A[x])\\n            dp_sum[x] = (x+1)*max_so_far\\n\\n        \\n        # find the maximum sum so far as if this is the end of a partition\\n        for ind in range(K, len(dp_sum)):\\n            \\n            # go back K-1 steps to find the maximum so far\\n            \\n            partition_max = 0\\n            for back in range(K):\\n                partition_max = max(partition_max, A[ind - back])\\n                prev_sum = dp_sum[ind - back - 1]\\n                \\n                dp_sum[ind] = max(dp_sum[ind], prev_sum + (back+1)*partition_max)\\n        \\n        \\n        return dp_sum[-1]\\n\\t\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859099,
                "title": "recursive-memoization-dp-building-dp-solutions-from-recursion-c",
                "content": "**Recursion** \\nFirst think a simple recursion solution on seeing the problem. In this question we have to consider subarrays of at most k length. Start thinking like if you do the work considering 0,1,2..k elements in every next step, the recursion brings you the answer for the rest part.\\n\\nRelation :  Loop i from 0 to k: R(0,n) = Work(0,i) + R(i+1,n)\\n\\n```\\nint helper(vector<int>& arr, int s,int k){\\n\\n        if(s >= arr.size())\\n            return 0;\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(s+k,arr.size());i++){    /// Work You Do\\n           \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));    /// Work you pass to recursion\\n            \\n        }\\n        return sum;\\n        \\n    }\\n```\\n\\n**Memoization**\\nStart thinking of the overlapping subproblems. Try to make the recursion tree and identify overlapping subproblems. Now use memoization to reduce the recursive function calls.\\n\\n```\\n int helper(vector<int>& arr, int s,int k,int* memo){\\n        \\n        if(s >= arr.size())\\n            return 0;\\n        if(memo[s] != -1)    /// Memoization\\n            return memo[s];\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(arr.size(),s+k);i++){\\n      \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));\\n            \\n        }\\n        memo[s] = sum;   /// Saving the answer for future use.\\n        return sum;\\n        \\n    }\\n```\\n\\n\\n**DP**\\nNow, Try to build your solution from Bottom-Up. (It\\'ll be way easier now.)\\n\\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n      \\n        int n = arr.size();\\n        int* dp = new int[n];\\n        for(int i=0;i<n;i++){\\n            dp[i] = -1;\\n         }\\n        for(int i = n-1;i>=0;i--){\\n            int sum = INT_MIN;\\n            int max_ele = INT_MIN;\\n            for(int j = i;j<n && j<i+k;j++){\\n                max_ele = max(max_ele,arr[j]);\\n                int cand = j+1 < n ? dp[j+1] + max_ele*(j-i+1) : max_ele*(j-i+1); \\n                sum = max(sum , cand);\\n            }\\n            dp[i] = sum;\\n        }\\n        return dp[0];\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint helper(vector<int>& arr, int s,int k){\\n\\n        if(s >= arr.size())\\n            return 0;\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(s+k,arr.size());i++){    /// Work You Do\\n           \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));    /// Work you pass to recursion\\n            \\n        }\\n        return sum;\\n        \\n    }\\n```\n```\\n int helper(vector<int>& arr, int s,int k,int* memo){\\n        \\n        if(s >= arr.size())\\n            return 0;\\n        if(memo[s] != -1)    /// Memoization\\n            return memo[s];\\n        \\n        int sum = INT_MIN;\\n        int max_ele = INT_MIN;\\n        \\n        for(int i=s;i<min(arr.size(),s+k);i++){\\n      \\n                max_ele = max(max_ele,arr[i]);\\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));\\n            \\n        }\\n        memo[s] = sum;   /// Saving the answer for future use.\\n        return sum;\\n        \\n    }\\n```\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n      \\n        int n = arr.size();\\n        int* dp = new int[n];\\n        for(int i=0;i<n;i++){\\n            dp[i] = -1;\\n         }\\n        for(int i = n-1;i>=0;i--){\\n            int sum = INT_MIN;\\n            int max_ele = INT_MIN;\\n            for(int j = i;j<n && j<i+k;j++){\\n                max_ele = max(max_ele,arr[j]);\\n                int cand = j+1 < n ? dp[j+1] + max_ele*(j-i+1) : max_ele*(j-i+1); \\n                sum = max(sum , cand);\\n            }\\n            dp[i] = sum;\\n        }\\n        return dp[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1281273,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        //dp[i] stores the sum at index i\\n        int n=arr.size();\\n        vector<int> dp(n);\\n        int maxi=arr[0];\\n        for(int i=0;i<k;i++)\\n        {\\n            maxi=max(arr[i],maxi);\\n            dp[i]=(maxi*(i+1));\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            dp[i]=arr[i]+dp[i-1];\\n            maxi=arr[i];\\n            //check if a partition can result into the maximum sum\\n            for(int j=i-1;j>i-k;j--)\\n            {\\n                //get the maximum element\\n                maxi=max(maxi,arr[j]);\\n                dp[i]=max(dp[i],dp[j-1]+ (i-j+1)*maxi);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Please upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        //dp[i] stores the sum at index i\\n        int n=arr.size();\\n        vector<int> dp(n);\\n        int maxi=arr[0];\\n        for(int i=0;i<k;i++)\\n        {\\n            maxi=max(arr[i],maxi);\\n            dp[i]=(maxi*(i+1));\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            dp[i]=arr[i]+dp[i-1];\\n            maxi=arr[i];\\n            //check if a partition can result into the maximum sum\\n            for(int j=i-1;j>i-k;j--)\\n            {\\n                //get the maximum element\\n                maxi=max(maxi,arr[j]);\\n                dp[i]=max(dp[i],dp[j-1]+ (i-j+1)*maxi);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290850,
                "title": "c-rolling-max-dp",
                "content": "# Top-Down Solution\\nFor each position ```pos```, increase your subarray size ```i``` from ```1``` to ```k```, tracking the maximum value ```mv``` so far. The sum of the subarray is ```mv * i```.\\n\\nThen, call our function recursively for position ```pos + i```.\\n\\nTo avoid re-calculating the same input, use memoisation to track the maximum sum for the position (```dp```).\\n```\\nint dp[501] = {};\\nint maxSumAfterPartitioning(vector<int>& A, int K, int pos = 0, int res = 0) {\\n  if (pos < A.size() && dp[pos] != 0) return dp[pos];\\n  for (int i = 1, mv = 0; i <= K && pos + i <= A.size(); ++i) {\\n    mv = max(mv, A[pos + i - 1]);\\n    res = max(res, mv * i + maxSumAfterPartitioning(A, K, pos + i));\\n  }\\n  return dp[pos] = res;\\n}\\n```",
                "solutionTags": [],
                "code": "```pos```\n```i```\n```1```\n```k```\n```mv```\n```mv * i```\n```pos + i```\n```dp```\n```\\nint dp[501] = {};\\nint maxSumAfterPartitioning(vector<int>& A, int K, int pos = 0, int res = 0) {\\n  if (pos < A.size() && dp[pos] != 0) return dp[pos];\\n  for (int i = 1, mv = 0; i <= K && pos + i <= A.size(); ++i) {\\n    mv = max(mv, A[pos + i - 1]);\\n    res = max(res, mv * i + maxSumAfterPartitioning(A, K, pos + i));\\n  }\\n  return dp[pos] = res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306945,
                "title": "o-nk-dp-with-explanation",
                "content": "Problem asks for to partition array in some parts (each partition of length at most K) such that replace each element in partition by max element in that partition then total sum should be maximised.\\n\\nFor K  = 1, trivial solution to consider each element as one partition then max sum = Sum of all elements\\nFor K  = 2,  check for previous k - 1 elements i.e. previous 1 element.\\nThen decide between whether or not increase size of partition\\ne.g.  For each two elements,  Max of  (2 * max element,  sum of each element with k - 1)\\nFor K = 3, check for previous k - 1 elements i.e. previous 2 elements.\\n e.g.  For each three elements,  Max of  (3 * max element,  earlier result of partition of size 2 of first two or last two elements  + remaining element)\\n \\nFrom pattern we have overlapping subproblem of computation of parition of size of k - 1 and optimal substructure (finding max sum), this calls for dynamic programming. \\n\\n\\n``` csharp\\npublic int MaxSumAfterPartitioning(int[] A, int K)\\n{\\n\\tint[] d = new int[A.Length];\\n\\n\\tfor (int i = 0; i < A.Length; i++)\\n\\t{\\n\\t\\tint partitionMax = 0;\\n\\t\\tfor (int k = 1; k <= K && (k - 1) <= i; k++)\\n\\t\\t{\\n\\t\\t\\tpartitionMax = Math.Max(partitionMax, A[i - (k - 1)]);\\n\\t\\t\\td[i] = Math.Max(d[i], (i >= k ? d[i - k] : 0) + k * partitionMax);\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[A.Length - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic int MaxSumAfterPartitioning(int[] A, int K)\\n{\\n\\tint[] d = new int[A.Length];\\n\\n\\tfor (int i = 0; i < A.Length; i++)\\n\\t{\\n\\t\\tint partitionMax = 0;\\n\\t\\tfor (int k = 1; k <= K && (k - 1) <= i; k++)\\n\\t\\t{\\n\\t\\t\\tpartitionMax = Math.Max(partitionMax, A[i - (k - 1)]);\\n\\t\\t\\td[i] = Math.Max(d[i], (i >= k ? d[i - k] : 0) + k * partitionMax);\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[A.Length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387825,
                "title": "easy-to-understand-c-memoization",
                "content": "Basically, we have to calculate all possibilites of partition i.e for a given K, the subarray could be of length 1,2,3.....K. That\\'s where Dynamic Programming comes into picture.\\n\\nFor that we need some variables to store necessary information i.e length of the current subarray(len),maximum in the current subarray(maxm), and ofcourse the index of the element being visited.\\n\\nAt every index we have to check 2 major possibilites:\\n* **Make a partition**( current subarray sum= maxm* length of subarray)\\n*  **Don\\'t make a partition**(only possible if current subarray length <K)\\n\\nWe can call the function again by incrementing or resetting values of the variables and continue visiting every index further till end of the array. \\nWe can cache the sums of corresponding index and array length as shown.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int find(int index,int maxm,int len,vector<int>& arr, int k)\\n    {\\n        if(index==arr.size())\\n        {\\n            return len*maxm;       \\n        }\\n        \\n        int part=0,noPart=0;\\n        maxm=max(maxm,arr[index]);\\n        len++;\\n        \\n        if(dp[index][len]!=-1)\\n            return dp[index][len];\\n        \\n        if(len<k)\\n        {\\n            noPart=find(index+1,maxm,len,arr,k);    \\n        }\\n        part=len*maxm+find(index+1,INT_MIN,0,arr,k);\\n        \\n        return dp[index][len]=max(part,noPart);\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        dp.resize(n+1,vector<int>(k+1,-1));\\n        \\n        return find(0,INT_MIN,0,arr,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int find(int index,int maxm,int len,vector<int>& arr, int k)\\n    {\\n        if(index==arr.size())\\n        {\\n            return len*maxm;       \\n        }\\n        \\n        int part=0,noPart=0;\\n        maxm=max(maxm,arr[index]);\\n        len++;\\n        \\n        if(dp[index][len]!=-1)\\n            return dp[index][len];\\n        \\n        if(len<k)\\n        {\\n            noPart=find(index+1,maxm,len,arr,k);    \\n        }\\n        part=len*maxm+find(index+1,INT_MIN,0,arr,k);\\n        \\n        return dp[index][len]=max(part,noPart);\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        dp.resize(n+1,vector<int>(k+1,-1));\\n        \\n        return find(0,INT_MIN,0,arr,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168667,
                "title": "c-recursion-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size(), -1);\\n        return dfs(arr, k, 0, dp);\\n    }\\n    \\n    int dfs(vector<int>&arr, int k, int start, vector<int>& dp){\\n        int n = arr.size();\\n        if(start>=n)\\n            return 0;\\n        if(dp[start]!=-1) return dp[start];\\n        int maxsum = arr[start];\\n        int maxno = arr[start];\\n        for(int end = start;end<start+k && end<n;end++)\\n        {\\n            maxno = max(maxno,arr[end]);\\n            maxsum = max(maxsum,(maxno*(end-start+1)+dfs(arr,k,end+1,dp)));\\n        }\\n        return dp[start] = maxsum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size(), -1);\\n        return dfs(arr, k, 0, dp);\\n    }\\n    \\n    int dfs(vector<int>&arr, int k, int start, vector<int>& dp){\\n        int n = arr.size();\\n        if(start>=n)\\n            return 0;\\n        if(dp[start]!=-1) return dp[start];\\n        int maxsum = arr[start];\\n        int maxno = arr[start];\\n        for(int end = start;end<start+k && end<n;end++)\\n        {\\n            maxno = max(maxno,arr[end]);\\n            maxsum = max(maxsum,(maxno*(end-start+1)+dfs(arr,k,end+1,dp)));\\n        }\\n        return dp[start] = maxsum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150881,
                "title": "c-easy-bottom-up-solution-with-intution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k) {\\n        int n=a.size();\\n        int dp[n];//to store maximum sum ending at particular index\\n        memset(dp,0,sizeof(dp));\\n        int m=a[0];\\n        //Base Case\\n        for(int i=0;i<k;i++){//storing the result for upto first k numbers by finding the maximum among them\\n            m=max(m,a[i]);\\n            dp[i]=m*(i+1);\\n        }\\n        //Now Calculating the solution\\n        for(int i=k;i<n;i++){\\n            m=a[i];//initialising as the current max\\n            for(int j = 1;j <= k;j++){\\n                m=max(m,a[i-j+1]);//finding the maximum till here\\n                //recurrence relation here is found by dp[i] \\n                // means maximum sum ended at i\\n                //dp[i-1]+A[i]\\n                //dp[i-2]+max(A[i-1],A[i])*2\\n                // and so on till the window of size k\\n                dp[i]=max(dp[i],dp[i-j]+(m*j));\\n            }\\n        }\\n        return dp[n-1];//finally returning the answer\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k) {\\n        int n=a.size();\\n        int dp[n];//to store maximum sum ending at particular index\\n        memset(dp,0,sizeof(dp));\\n        int m=a[0];\\n        //Base Case\\n        for(int i=0;i<k;i++){//storing the result for upto first k numbers by finding the maximum among them\\n            m=max(m,a[i]);\\n            dp[i]=m*(i+1);\\n        }\\n        //Now Calculating the solution\\n        for(int i=k;i<n;i++){\\n            m=a[i];//initialising as the current max\\n            for(int j = 1;j <= k;j++){\\n                m=max(m,a[i-j+1]);//finding the maximum till here\\n                //recurrence relation here is found by dp[i] \\n                // means maximum sum ended at i\\n                //dp[i-1]+A[i]\\n                //dp[i-2]+max(A[i-1],A[i])*2\\n                // and so on till the window of size k\\n                dp[i]=max(dp[i],dp[i-j]+(m*j));\\n            }\\n        }\\n        return dp[n-1];//finally returning the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881385,
                "title": "dp-python-bottom-up-top-down",
                "content": "This problem is extremely hard to grasp. It\\'s a variation on dynamic programming, but the subproblems are hard to see when you first look at it. I\\'d say this is a \\'Hard\\' difficulty, not a \\'Medium.\\'\\n\\nBeginning with the original array [1, 15, 7, 9, 2, 5, 10], the answer to this problem is:\\nmax(1x1 + f([15, 7, 9, 2, 5, 10]), 2x15 + f([7, 9, 2, 5, 10]), + 3x15 + f([9, 2, 5, 10]).\\nThe product at the front is the current \\'K\\' value we are on, multiplied by the maximum value of the first K elements in the array. We have to update the maximum seen so far to multiply it by up to K values of it. \\n\\nThe subproblems themselves just repeat until we reach the empty list, whose answer is 0. After seeing the subproblem, the hard part is getting the indexing correct. Memoization doesn\\'t require this since we can just use a hashtable and store whatever index we are on, but the bottom-up approach does require precise indexing.\\n\\nWe initialize an array of length len(A) + 1. The last element is 0 to represent the base case of the empty list. The element before that is set as A[len(A)-1]. This is because the list with one element\\'s answer is just the one element itself. Each dp[i] represents the answer to the subproblem for the subarray starting at index i. We go in reverse, and using the current max product, we add it to dp[i+k] where k is our offset between 1 and K. We keep taking the max of each iteration.\\n\\nWe check K values per element in our array, so O(NK) runtime. O(N) space.\\n\\nTOP-DOWN\\n```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            # base case\\n            if start == len(arr):\\n                return 0\\n            \\n            cur_max = float(\\'-inf\\')\\n            res = 0\\n            \\n            # we want to loop over k elements, take the maximum and multiply\\n            # then add it to the corresponding subproblem with the reduced\\n            # array\\n            for i in range(K):\\n                if start+i == len(arr):\\n                    break\\n                cur_max = max(cur_max, arr[start+i])\\n                # take the max of all possibilities\\n                if start+i+1 in memo:\\n                    res = max(res, (i+1)*cur_max + memo[start+i+1])\\n                else:\\n                    res = max(res, (i+1)*cur_max + recur(arr, start+i+1, memo))\\n                    \\n            # return the final result\\n            memo[start] = res\\n            return res\\n        \\n        memo = {}\\n        recur(A, 0, memo)\\n        return memo[0]\\n```\\n\\nBOTTOM-UP\\n```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        dp = [float(\\'-inf\\') for i in range(len(A)+1)]\\n        dp[-1] = 0\\n        dp[-2] = A[-1]\\n        \\n        for j in reversed(range(len(A)-1)):\\n            cur_max = float(\\'-inf\\')\\n            for k in range(K):\\n                if j+k == len(A):\\n                    break\\n                cur_max = max(cur_max, A[j+k])\\n                dp[j] = max(dp[j], (k+1)*cur_max + dp[j+k+1])\\n        \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        \\n        def recur(arr, start, memo):\\n            # base case\\n            if start == len(arr):\\n                return 0\\n            \\n            cur_max = float(\\'-inf\\')\\n            res = 0\\n            \\n            # we want to loop over k elements, take the maximum and multiply\\n            # then add it to the corresponding subproblem with the reduced\\n            # array\\n            for i in range(K):\\n                if start+i == len(arr):\\n                    break\\n                cur_max = max(cur_max, arr[start+i])\\n                # take the max of all possibilities\\n                if start+i+1 in memo:\\n                    res = max(res, (i+1)*cur_max + memo[start+i+1])\\n                else:\\n                    res = max(res, (i+1)*cur_max + recur(arr, start+i+1, memo))\\n                    \\n            # return the final result\\n            memo[start] = res\\n            return res\\n        \\n        memo = {}\\n        recur(A, 0, memo)\\n        return memo[0]\\n```\n```\\ndef maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        dp = [float(\\'-inf\\') for i in range(len(A)+1)]\\n        dp[-1] = 0\\n        dp[-2] = A[-1]\\n        \\n        for j in reversed(range(len(A)-1)):\\n            cur_max = float(\\'-inf\\')\\n            for k in range(K):\\n                if j+k == len(A):\\n                    break\\n                cur_max = max(cur_max, A[j+k])\\n                dp[j] = max(dp[j], (k+1)*cur_max + dp[j+k+1])\\n        \\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2278681,
                "title": "c-recursion-memoization-basic-dp-mcm-pattern",
                "content": "```\\n// The Solution is Totally Based on MCM Technique i.e. Partioning Technique.\\n// What I did is Totally Based on that First I wrote Recursive Code and then memoize it to remove any TLE.\\n// So Its Simple and Intutive I need to get the ans for any values and rest the recursion will do its work.\\n// So lets Take the example\\n// [1,15,7,9,2,5,10] , k = 3\\n// So here I will first choose 1 and for rest of the Array that is for 15,7,9,2,5,10 recursion will give me its ans now loop will progress i will now take 1,15 and for that my maximum value is 15 which into length will give me its answer and for rest of the array i will get the soltuion this is my another valid solution and similarly I did that again and finally when i will choose 1,15,7 then further Breakdown is not possible becuase at most k elements are allowed.And then I memoize the code.\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>&arr , int i , int j, int k)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(j-i==k)\\n        {\\n            int max1 = 0;\\n            if(j+1 > arr.size())\\n            {\\n                max1= *max_element(arr.begin() + i , arr.end());\\n                return (max1*k);\\n            }\\n           max1 = *max_element(arr.begin() + i , arr.begin() + j + 1);\\n           return (max1*k);\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans = 0;\\n        for(int p = i ; p < j ; p++)\\n        {\\n            if(p-i < k)\\n            {   \\n                int max2 = *max_element(arr.begin() + i , arr.begin() + p + 1);\\n                max2 = max2*(p-i+1);\\n                ans = max(ans , max2 + solve(arr , p+1 , j , k));\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(arr , 0 , arr.size() , k);\\n    }\\n};\\n```\\n**Please Upvote the Solution if you like it.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// The Solution is Totally Based on MCM Technique i.e. Partioning Technique.\\n// What I did is Totally Based on that First I wrote Recursive Code and then memoize it to remove any TLE.\\n// So Its Simple and Intutive I need to get the ans for any values and rest the recursion will do its work.\\n// So lets Take the example\\n// [1,15,7,9,2,5,10] , k = 3\\n// So here I will first choose 1 and for rest of the Array that is for 15,7,9,2,5,10 recursion will give me its ans now loop will progress i will now take 1,15 and for that my maximum value is 15 which into length will give me its answer and for rest of the array i will get the soltuion this is my another valid solution and similarly I did that again and finally when i will choose 1,15,7 then further Breakdown is not possible becuase at most k elements are allowed.And then I memoize the code.\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>&arr , int i , int j, int k)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(j-i==k)\\n        {\\n            int max1 = 0;\\n            if(j+1 > arr.size())\\n            {\\n                max1= *max_element(arr.begin() + i , arr.end());\\n                return (max1*k);\\n            }\\n           max1 = *max_element(arr.begin() + i , arr.begin() + j + 1);\\n           return (max1*k);\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans = 0;\\n        for(int p = i ; p < j ; p++)\\n        {\\n            if(p-i < k)\\n            {   \\n                int max2 = *max_element(arr.begin() + i , arr.begin() + p + 1);\\n                max2 = max2*(p-i+1);\\n                ans = max(ans , max2 + solve(arr , p+1 , j , k));\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(arr , 0 , arr.size() , k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522001,
                "title": "python3-with-explanation",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, K):\\n        # 0) Initialization\\n        #    best_a is used to keep past computation result\\n        #    best_a[i] is to keep local optimal result of A[0:i-1]\\n        best_a = [0] * len(A)\\n        best_a[0] = A[0]\\n\\n        # 1) Iteratively fill the best_a with local optimal result\\n        #    best_a[0] = A[0]\\n        #    best_a[1] = max(best_a[0] + A[1], max(A[0:2]) * 2)\\n        #    best_a[2] = max(best_a[1] + A[2], best_a[0] + max(A[1:3]) * 2, max(A[0:3]) * 3)\\n        #    ...\\n        #    best_a[n] = max(best_a[n-1] + A[n], best_a[n-2] + max(A[n-1:n+1]) * 2, ..., max(A[n-K+1:n+1]) * K)\\n        for i in range(1, len(A)):\\n            max_v = 0\\n            for j in range(i, max(-1, i-K), -1):\\n                sa = A[j:i+1]\\n                v = best_a[j-1] + max(sa) * len(sa)\\n                if v > max_v:\\n                    max_v = v\\n\\n            best_a[i] = max_v\\n\\n        # 3) The global optimal result is kept in last element\\n        return best_a[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, K):\\n        # 0) Initialization\\n        #    best_a is used to keep past computation result\\n        #    best_a[i] is to keep local optimal result of A[0:i-1]\\n        best_a = [0] * len(A)\\n        best_a[0] = A[0]\\n\\n        # 1) Iteratively fill the best_a with local optimal result\\n        #    best_a[0] = A[0]\\n        #    best_a[1] = max(best_a[0] + A[1], max(A[0:2]) * 2)\\n        #    best_a[2] = max(best_a[1] + A[2], best_a[0] + max(A[1:3]) * 2, max(A[0:3]) * 3)\\n        #    ...\\n        #    best_a[n] = max(best_a[n-1] + A[n], best_a[n-2] + max(A[n-1:n+1]) * 2, ..., max(A[n-K+1:n+1]) * K)\\n        for i in range(1, len(A)):\\n            max_v = 0\\n            for j in range(i, max(-1, i-K), -1):\\n                sa = A[j:i+1]\\n                v = best_a[j-1] + max(sa) * len(sa)\\n                if v > max_v:\\n                    max_v = v\\n\\n            best_a[i] = max_v\\n\\n        # 3) The global optimal result is kept in last element\\n        return best_a[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744173,
                "title": "easy-to-understand-memo-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& A, int dp[], int k, int i){\\n        if(i>=A.size()) return 0;\\n        int & ans  = dp[i];\\n        if(ans!=-1) return ans;\\n        int maxx  = A[i];\\n        \\n        for(int j = 0; j<k&& (i+j)<A.size() ; j++){\\n            maxx = max(A[i+j], maxx);\\n            ans = max(ans, maxx*(j+1) + find(A, dp, k, i+j+1) );\\n            \\n        }\\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int n = A.size();\\n        int dp[n+1];\\n        memset(dp,-1,sizeof(dp));\\n        return find(A,dp, K, 0);\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find(vector<int>& A, int dp[], int k, int i){\\n        if(i>=A.size()) return 0;\\n        int & ans  = dp[i];\\n        if(ans!=-1) return ans;\\n        int maxx  = A[i];\\n        \\n        for(int j = 0; j<k&& (i+j)<A.size() ; j++){\\n            maxx = max(A[i+j], maxx);\\n            ans = max(ans, maxx*(j+1) + find(A, dp, k, i+j+1) );\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1519101,
                "title": "dp-matrix-chain-multiplication-format-c-pseudo-code-of-mcm",
                "content": "This is the pseudo code used to solve any MCM problem..just find the pattern of MCM and apply this logic\\nExplanation:-\\n![image](https://assets.leetcode.com/users/images/fe6ffbf3-245c-43df-85e0-00191d8d9068_1634111288.2755802.png)\\n\\nThe code :-\\n```\\nint dp[501][501];\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, int k, vector<int>& arr){\\n        //  base case\\n        if(j < i) // size of array = 0\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int currmax=0;\\n        int len=1;\\n        int ans=0;\\n        for(int t=i ; t<=j && len<=k; t++, len++){\\n            \\n            // calculate maximum till you reach k elements\\n            currmax = max(currmax, arr[t]);\\n            // solve thr answer for right subarray\\n            int r = solve(t+1, j, k, arr);\\n            // solve the answer fot current partition\\n            ans = max(ans, currmax*len + r);\\n        \\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    \\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k){\\n        \\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        // using Dynamic programming\\n        // similar to matrix chain multiplication format :)\\n        // break at every k from i to j\\n        return solve(0, n-1, k, arr);\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint dp[501][501];\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, int k, vector<int>& arr){\\n        //  base case\\n        if(j < i) // size of array = 0\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int currmax=0;\\n        int len=1;\\n        int ans=0;\\n        for(int t=i ; t<=j && len<=k; t++, len++){\\n            \\n            // calculate maximum till you reach k elements\\n            currmax = max(currmax, arr[t]);\\n            // solve thr answer for right subarray\\n            int r = solve(t+1, j, k, arr);\\n            // solve the answer fot current partition\\n            ans = max(ans, currmax*len + r);\\n        \\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    \\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k){\\n        \\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        // using Dynamic programming\\n        // similar to matrix chain multiplication format :)\\n        // break at every k from i to j\\n        return solve(0, n-1, k, arr);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249327,
                "title": "java-solution-o-nk-time-o-n-space-dp-approach",
                "content": "```\\n public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N=arr.length;\\n        if(N==1) return arr[0];\\n        int[] dp = new int[N+1];\\n        \\n        for(int i=1;i<=N;i++){\\n            int currMax=0; int maxSumK=0;\\n            for(int sub=1;sub<=k && i-sub>=0;sub++){\\n                currMax=Math.max(currMax,arr[i-sub]);\\n                maxSumK=Math.max(maxSumK,dp[i-sub]+(currMax*sub));\\n            }\\n            dp[i]=maxSumK;\\n        }\\n        return dp[N];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N=arr.length;\\n        if(N==1) return arr[0];\\n        int[] dp = new int[N+1];\\n        \\n        for(int i=1;i<=N;i++){\\n            int currMax=0; int maxSumK=0;\\n            for(int sub=1;sub<=k && i-sub>=0;sub++){\\n                currMax=Math.max(currMax,arr[i-sub]);\\n                maxSumK=Math.max(maxSumK,dp[i-sub]+(currMax*sub));\\n            }\\n            dp[i]=maxSumK;\\n        }\\n        return dp[N];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151452,
                "title": "rust-0-ms-dp-with-explanation-on-example",
                "content": "As in most dynamic programming questions we will start from solving base case.\\nOur example input will be ```arr=[1,15,7,9,2,5,10] k=3``` and our max possible sums will be at ```dp = [0,0,0,0,0,0,0]```\\nOur base case is solved from 3 first values of array.\\nFor first 3 arr values our max sum is as follows [1,30,45,0,0,0,0] since 15 is bigger than 1 and 7 and we calculate it like that:\\n```\\nfor i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n```\\nNow that we have base case solved, we can continue by walking arr from k to n. \\n[1, 15, 7,   9, 2, 5, 10] arr\\n[1, 30, 45, 0, 0, 0,   0] dp\\nSo now to get max sum for 9 we should check  in loop which is bigger: ```9*1+45``` or ```9*2+30```(since 9 is bigger than 7) or ```15*3+1```(since 15 is bigger than 7 and 9) the answer is 54 so we choose 54 and now we have\\n[1, 15,  7,   9, 2, 5, 10] arr\\n[1, 30, 45, 54, 0, 0,   0] dp\\nNow let\\'s do same for 2.  We need to choose biggest from these```2*1+54``` or ```9*2+45``` or ```9*3+30``` the answer is 63 so now we have\\n[1, 15,  7,   9, 2, 5, 10] arr\\n[1, 30, 45, 54, 63, 0,   0] dp\\nContinuing these steps we will have\\n[1, 15, 7, 9, 2, 5, 10] arr\\n[1, 30, 45, 54, 63, 72, 84] dp\\nAnd the answer is dp[last_index]\\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_sum_after_partitioning(arr: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let n = arr.len();\\n        let mut dp = vec![0;n];\\n        dp[0] = arr[0];\\n        let mut local_max = arr[0];\\n        for i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n        for i in k..n{\\n            local_max = 0;\\n            for j in 1..k+1{\\n                local_max = max(local_max,arr[i+1-j]);\\n                dp[i] = max(dp[i], dp[i-j]+local_max*(j as i32));// for 9 in our example this means choose biggest of  45+9*1 or 30+9*2 or 1+15*3\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```arr=[1,15,7,9,2,5,10] k=3```\n```dp = [0,0,0,0,0,0,0]```\n```\\nfor i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n```\n```9*1+45```\n```9*2+30```\n```15*3+1```\n```2*1+54```\n```9*2+45```\n```9*3+30```\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_sum_after_partitioning(arr: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let n = arr.len();\\n        let mut dp = vec![0;n];\\n        dp[0] = arr[0];\\n        let mut local_max = arr[0];\\n        for i in 0..k{\\n            local_max = max(local_max,arr[i]);\\n            dp[i] = local_max*(i as i32 +1);\\n        }\\n        for i in k..n{\\n            local_max = 0;\\n            for j in 1..k+1{\\n                local_max = max(local_max,arr[i+1-j]);\\n                dp[i] = max(dp[i], dp[i-j]+local_max*(j as i32));// for 9 in our example this means choose biggest of  45+9*1 or 30+9*2 or 1+15*3\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924268,
                "title": "c-dynamic-programming-98-98-fast",
                "content": "```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int dp[n];\\n       \\n        memset(dp,0,sizeof(dp));\\n        \\n        dp[0] = arr[0];\\n        int maxi = arr[0];\\n        //filling 1-(k-1) of dp array\\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);  \\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxi = arr[i];//MINIMIUM VALUE\\n            for(int j=1;j<=k;j++)\\n            {\\n               maxi = max(maxi,arr[i-j+1]);\\n                dp[i] = max(dp[i],dp[i-j] + maxi*j);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n        \\n    }\\n\\t\\n```\\n\\nit took me many readings of the statement only actually understanding the problem though!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int dp[n];\\n       \\n        memset(dp,0,sizeof(dp));\\n        \\n        dp[0] = arr[0];\\n        int maxi = arr[0];\\n        //filling 1-(k-1) of dp array\\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);  \\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxi = arr[i];//MINIMIUM VALUE\\n            for(int j=1;j<=k;j++)\\n            {\\n               maxi = max(maxi,arr[i-j+1]);\\n                dp[i] = max(dp[i],dp[i-j] + maxi*j);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n        \\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851374,
                "title": "javascript-dynamic-programming-memoization-with-explanation",
                "content": "```\\n/**\\n * DYNAMIC PROGRAMMING + MEMOIZATION\\n * \\n * Creates a memo[] that holds all the max results for each index from 0....end of arr.length-1.\\n * For each number in the arr[i] it \"tries on\" different partition sizes from 1 to k, all the while\\n * holding the biggest number within that partition.\\n * Then sees if it will produce the max sum by multiplying that max num by the partition size, \\n * and adding that to the max sum that\\'s alrady been calculated until that partition (in memo[i - partition size]).\\n * \\n * For example: arr=[8, 4, 7], k=2\\n * memo[0] = can only have partition size of 1 so it will be the value 8\\n * memo[1] = which is bigger? partition size 1 (max num is 4) or 2 (max num between {8,4} is 8? =>\\n *          memo[1-1]+4*1 or memo[1-2]+8*2 =>\\n *          memo[0]+4 or memo[-1]+16 (memo[-1] doesn\\'t exist so take 0 instead) =>\\n *          8+4 or 0+16 => \\n *          12 or 16 => 16\\n * memo[2] = which is bigger? partition size 1 (max num 7) or 2 (max num between {7, 4} is 7)? =>\\n *          memo[2-1]+7*1 or memo[2-2]+7*2 =>\\n *          memo[1]+7 or memo[0]+14 => 16+7 or 8+14 => 24 or 22 => 24\\n * so the answer is the memo[] of the last index: 24.\\n * \\n * Runtime complexity - say N=arr.length then complexity is O(N*k). Each number in array tries different partition sizes.\\n * Space complexityy - O(N) for memo[] for every value in arr[].\\n * \\n * \\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumAfterPartitioning = function (arr, k) {\\n    let result = 0;\\n\\n    if (arr && (arr.length >= 1) && (arr.length <= 500) && (k >= 1) && (k <= arr.length)) {\\n        let currMaxForPartition;\\n        let memo = [];\\n        // the only partition size to use for the first number can only be 1, so the max sum is that number\\n        memo[0] = arr[0]; \\n\\n        // for every number in the array fill the memo[]\\n        for (let i = 1; i < arr.length; i++) {\\n            // init the max num for the partition as the lowest possible number that could be in arr[]\\n            currMaxForPartition = 0;\\n            // init memo[] as a placeholder value as minimal sum possible\\n            memo[i] = 0;\\n\\n            // for each partition size from 1 until k, keeping in mind that \\n            // the partition size can\\'t be bigger than the current index\\n            for (let a = 1; (a <= k) && ((i - a + 1) >= 0); a++) {\\n                // find the biggest number in that partition in arr[]\\n                currMaxForPartition = Math.max(currMaxForPartition, arr[i - a + 1]);\\n\\n                // multiply the currMaxForPartition by partition size and add that the max sum before that\\n                // partition. if it\\'s bigger than the last max sum, override it.\\n                // if i is smaller than the partition size, use 0 as previous max sum\\n                memo[i] = Math.max(memo[i], ((i >= k) ? memo[i - a] : 0) + (a * currMaxForPartition));\\n            }\\n        }\\n\\n        // last value in memo\\n        result = memo[arr.length - 1];\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * DYNAMIC PROGRAMMING + MEMOIZATION\\n * \\n * Creates a memo[] that holds all the max results for each index from 0....end of arr.length-1.\\n * For each number in the arr[i] it \"tries on\" different partition sizes from 1 to k, all the while\\n * holding the biggest number within that partition.\\n * Then sees if it will produce the max sum by multiplying that max num by the partition size, \\n * and adding that to the max sum that\\'s alrady been calculated until that partition (in memo[i - partition size]).\\n * \\n * For example: arr=[8, 4, 7], k=2\\n * memo[0] = can only have partition size of 1 so it will be the value 8\\n * memo[1] = which is bigger? partition size 1 (max num is 4) or 2 (max num between {8,4} is 8? =>\\n *          memo[1-1]+4*1 or memo[1-2]+8*2 =>\\n *          memo[0]+4 or memo[-1]+16 (memo[-1] doesn\\'t exist so take 0 instead) =>\\n *          8+4 or 0+16 => \\n *          12 or 16 => 16\\n * memo[2] = which is bigger? partition size 1 (max num 7) or 2 (max num between {7, 4} is 7)? =>\\n *          memo[2-1]+7*1 or memo[2-2]+7*2 =>\\n *          memo[1]+7 or memo[0]+14 => 16+7 or 8+14 => 24 or 22 => 24\\n * so the answer is the memo[] of the last index: 24.\\n * \\n * Runtime complexity - say N=arr.length then complexity is O(N*k). Each number in array tries different partition sizes.\\n * Space complexityy - O(N) for memo[] for every value in arr[].\\n * \\n * \\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumAfterPartitioning = function (arr, k) {\\n    let result = 0;\\n\\n    if (arr && (arr.length >= 1) && (arr.length <= 500) && (k >= 1) && (k <= arr.length)) {\\n        let currMaxForPartition;\\n        let memo = [];\\n        // the only partition size to use for the first number can only be 1, so the max sum is that number\\n        memo[0] = arr[0]; \\n\\n        // for every number in the array fill the memo[]\\n        for (let i = 1; i < arr.length; i++) {\\n            // init the max num for the partition as the lowest possible number that could be in arr[]\\n            currMaxForPartition = 0;\\n            // init memo[] as a placeholder value as minimal sum possible\\n            memo[i] = 0;\\n\\n            // for each partition size from 1 until k, keeping in mind that \\n            // the partition size can\\'t be bigger than the current index\\n            for (let a = 1; (a <= k) && ((i - a + 1) >= 0); a++) {\\n                // find the biggest number in that partition in arr[]\\n                currMaxForPartition = Math.max(currMaxForPartition, arr[i - a + 1]);\\n\\n                // multiply the currMaxForPartition by partition size and add that the max sum before that\\n                // partition. if it\\'s bigger than the last max sum, override it.\\n                // if i is smaller than the partition size, use 0 as previous max sum\\n                memo[i] = Math.max(memo[i], ((i >= k) ? memo[i - a] : 0) + (a * currMaxForPartition));\\n            }\\n        }\\n\\n        // last value in memo\\n        result = memo[arr.length - 1];\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774195,
                "title": "java-recursive-memoization-bottom-up",
                "content": "```\\n- For each of the starting point \\'i\\', we are able to choose the values from \\'i -> i + k - 1\\'\\n\\t- Then convert all of the values to the largest element within the range\\n\\t\\t- We will easily calculate the total sum within the current range by using this equation \\'# of elements in range x largest number\\'\\n\\t- Then our next range will start right after our current range\\n- We will want to pick the choice which will give us the highest sum\\n```\\n```\\npublic class PartitionArrayForMaximumSumRecursiveApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K) {\\n        if (start >= A.length) return 0;\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K) + (i - start + 1) * max);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\\n```\\npublic class PartitionArrayForMaximumSumMemoizationApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K, new int[A.length]);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K, int[] memo) {\\n        if (start >= A.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K, memo) + (i - start + 1) * max);\\n        }\\n\\n        memo[start] = maxSum;\\n        return maxSum;\\n    }\\n}\\n```\\n```\\npublic class PartitionArrayForMaximumSumBottomUp {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] sum = new int[A.length + 1];\\n\\n        for (int start = A.length - 1; start >= 0; start--) {\\n            int max = 0;\\n\\n            for (int i = start; i < Math.min(A.length, start + K); i++) {\\n                max = Math.max(max, A[i]);\\n                sum[start] = Math.max(sum[start], sum[i + 1] + (i - start + 1) * max);\\n            }\\n        }\\n\\n        return sum[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- For each of the starting point \\'i\\', we are able to choose the values from \\'i -> i + k - 1\\'\\n\\t- Then convert all of the values to the largest element within the range\\n\\t\\t- We will easily calculate the total sum within the current range by using this equation \\'# of elements in range x largest number\\'\\n\\t- Then our next range will start right after our current range\\n- We will want to pick the choice which will give us the highest sum\\n```\n```\\npublic class PartitionArrayForMaximumSumRecursiveApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K) {\\n        if (start >= A.length) return 0;\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K) + (i - start + 1) * max);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class PartitionArrayForMaximumSumMemoizationApproach {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        return maxSumAfterPartitioning(0, A, K, new int[A.length]);\\n    }\\n\\n    private int maxSumAfterPartitioning(int start, int[] A, int K, int[] memo) {\\n        if (start >= A.length) return 0;\\n        if (memo[start] != 0) return memo[start];\\n\\n        int max = 0;\\n        int maxSum = 0;\\n\\n        for (int i = start; i < Math.min(A.length, start + K); i++) {\\n            max = Math.max(max, A[i]);\\n            maxSum = Math.max(maxSum, maxSumAfterPartitioning(i + 1, A, K, memo) + (i - start + 1) * max);\\n        }\\n\\n        memo[start] = maxSum;\\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class PartitionArrayForMaximumSumBottomUp {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] sum = new int[A.length + 1];\\n\\n        for (int start = A.length - 1; start >= 0; start--) {\\n            int max = 0;\\n\\n            for (int i = start; i < Math.min(A.length, start + K); i++) {\\n                max = Math.max(max, A[i]);\\n                sum[start] = Math.max(sum[start], sum[i + 1] + (i - start + 1) * max);\\n            }\\n        }\\n\\n        return sum[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672793,
                "title": "java-simple-dp",
                "content": "```\\npublic int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length, dp[] = new int[n + 1];  //dp[i] max sum of first i ele, 0 ... A[i -1];\\n        for (int i = 1; i < dp.length; i++) {  // dp[0] = 0;\\n            for (int j = 0, max = 0; i - j - 1 >= 0 && j < K; j++) {\\n                max = Math.max(max, A[i - j - 1]);  // subarray from i - j - 1, i - 1;\\n                dp[i] = Math.max(dp[i], max * (j + 1) + dp[i - j - 2 + 1]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSumAfterPartitioning(int[] A, int K) {\\n        int n = A.length, dp[] = new int[n + 1];  //dp[i] max sum of first i ele, 0 ... A[i -1];\\n        for (int i = 1; i < dp.length; i++) {  // dp[0] = 0;\\n            for (int j = 0, max = 0; i - j - 1 >= 0 && j < K; j++) {\\n                max = Math.max(max, A[i - j - 1]);  // subarray from i - j - 1, i - 1;\\n                dp[i] = Math.max(dp[i], max * (j + 1) + dp[i - j - 2 + 1]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435555,
                "title": "c-dp-with-explanation",
                "content": "Phew! This one was tough for me. I spent a couple days tearing apart other solutions on here, trying to understand how they worked. After much calcuation, and thinking, I came up with a solution slightly different from the others, but I feel it\\'s far more readable than many of the others.\\n\\n```\\n        public int MaxSumAfterPartitioning(int[] A, int K)\\n        {\\n            var previousMaxSums = new int[A.Length];\\n\\n            // Iterating through the value array\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // Setup the current maximum for this partition.\\n                int maxInPartition = 0;\\n\\n                // J represents a distance from i.\\n                for (int j = 0; j < K; j++)\\n                {\\n                    // If we are out of bounds, break the loop\\n                    // This could have been a loop condition too, but it seems\\n                    // more readable here.\\n                    if (i - j < 0)\\n                        break;\\n\\n                    // We are currently looking at previousSums[i - j], if there are\\n                    // elements in the array before that range, add them here, other wise, 0\\n                    var possibleSum = i - (j + 1) >= 0 ? previousMaxSums[i - (j + 1)] : 0;\\n\\n                    // If we\\'ve discovered a better max, use it.\\n                    maxInPartition = Math.Max(maxInPartition, A[i - j]);\\n\\n                    // Add the max, spread across however big our partition is to the\\n                    // previous elements. We had + 1 to account for previousSum[i],\\n                    // as J represents the distance FROM i, but not including it.\\n                    possibleSum += maxInPartition * (j + 1);\\n\\n                    // Which is more, the current value, or the new one?\\n                    previousMaxSums[i] = Math.Max(previousMaxSums[i], possibleSum);\\n                }\\n            }\\n\\n            return previousMaxSums[previousMaxSums.Length - 1];\\n        }\\n```\\n\\nHere are some extra tips that helped me solve this:\\n\\n- The \\'DP\\' array is a historical list of the maximum sum, with the index corresponding to the number of available elements in the A collection. It\\'s a record of \\'We made the best with X amount of elements\\'. We will never \\'go back\\' (i - 1) and change this once its calculated. I realize some DP problems update elements of an array, then when finished, search for a solution... not the case so much here.\\n- At each index we start a partition going backward. If you want to visualize what that might look like, its something like this:\\n\\t```\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x, x] + parition[x] | j = 1\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x] + parition[x, x] | j = 2\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x] + parition[x, x, x] | j = 3\\n\\t```\\n- The example problem has an array like `[1, 15, 7, 9... 10]`, I had a hard time working out the logic of how we would know to replace `[15, 15, 15]` over indices `0, 1, 2` rather than indices `1, 2, 3` or something. Here\\'s how that logic worked out. When `i = 3`, and `j = 2`, the `maxInPartition`  was 15. Why did we not then use 15 instead of 9? Well, if our parition was currently 3 in size, using 15, meant we had a partition value of 45. However since the partition was 3 elements big, that means thats 2 elements we couldn\\'t use from the historical, `previousMaxSums` array. At this point our `previousMaxSums` array looked something like this: [1, 30, 45...] - we would have had to use the value at index 0 (since we were looking at using 3 elements from our partition) + the partition value, which would have equaled `46`. Simply adding the `A[3] = 9` to the previous 45, using a partition size of 1 was a much better idea, giving us a sum of `54`.",
                "solutionTags": [],
                "code": "```\\n        public int MaxSumAfterPartitioning(int[] A, int K)\\n        {\\n            var previousMaxSums = new int[A.Length];\\n\\n            // Iterating through the value array\\n            for (int i = 0; i < A.Length; i++)\\n            {\\n                // Setup the current maximum for this partition.\\n                int maxInPartition = 0;\\n\\n                // J represents a distance from i.\\n                for (int j = 0; j < K; j++)\\n                {\\n                    // If we are out of bounds, break the loop\\n                    // This could have been a loop condition too, but it seems\\n                    // more readable here.\\n                    if (i - j < 0)\\n                        break;\\n\\n                    // We are currently looking at previousSums[i - j], if there are\\n                    // elements in the array before that range, add them here, other wise, 0\\n                    var possibleSum = i - (j + 1) >= 0 ? previousMaxSums[i - (j + 1)] : 0;\\n\\n                    // If we\\'ve discovered a better max, use it.\\n                    maxInPartition = Math.Max(maxInPartition, A[i - j]);\\n\\n                    // Add the max, spread across however big our partition is to the\\n                    // previous elements. We had + 1 to account for previousSum[i],\\n                    // as J represents the distance FROM i, but not including it.\\n                    possibleSum += maxInPartition * (j + 1);\\n\\n                    // Which is more, the current value, or the new one?\\n                    previousMaxSums[i] = Math.Max(previousMaxSums[i], possibleSum);\\n                }\\n            }\\n\\n            return previousMaxSums[previousMaxSums.Length - 1];\\n        }\\n```\n```\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x, x] + parition[x] | j = 1\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x, x] + parition[x, x] | j = 2\\n\\t\\tpossibleSum = previousMaxSums[x, x, x, x] + parition[x, x, x] | j = 3\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 290853,
                "title": "java-dp-solution-o-n-k",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n        \\n        for(int i=1;i<A.length;i++) {\\n            int maxSum = A[i]+dp[i-1], maxVal = A[i];\\n            for(int j=i-1;j>=0 && j>i-K;j--) {\\n                maxVal = Math.max(maxVal, A[j]);\\n                if(j==0) {\\n                    maxSum = Math.max(maxSum, maxVal*(i-j+1));\\n                } else {\\n                    maxSum = Math.max(maxVal*(i-j+1)+dp[j-1], maxSum);\\n                }\\n                \\n            }\\n            dp[i] = maxSum;\\n        }\\n        \\n        return dp[A.length-1];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n        \\n        for(int i=1;i<A.length;i++) {\\n            int maxSum = A[i]+dp[i-1], maxVal = A[i];\\n            for(int j=i-1;j>=0 && j>i-K;j--) {\\n                maxVal = Math.max(maxVal, A[j]);\\n                if(j==0) {\\n                    maxSum = Math.max(maxSum, maxVal*(i-j+1));\\n                } else {\\n                    maxSum = Math.max(maxVal*(i-j+1)+dp[j-1], maxSum);\\n                }\\n                \\n            }\\n            dp[i] = maxSum;\\n        }\\n        \\n        return dp[A.length-1];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929046,
                "title": "c-solution-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&arr,int k,vector<int>&dp){\\n        int n = arr.size();\\n        if(i==n)\\n            return 0;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int maxSum = INT_MIN;\\n        int len = 0,maxi=INT_MIN;\\n        for(int z=i;z<min(n,i+k);z++){\\n            len++;\\n            maxi= max(maxi,arr[z]);\\n            int sum = len*maxi + solve(z+1,arr,k,dp);\\n            maxSum = max(sum,maxSum);\\n        }\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,arr,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&arr,int k,vector<int>&dp){\\n        int n = arr.size();\\n        if(i==n)\\n            return 0;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int maxSum = INT_MIN;\\n        int len = 0,maxi=INT_MIN;\\n        for(int z=i;z<min(n,i+k);z++){\\n            len++;\\n            maxi= max(maxi,arr[z]);\\n            int sum = len*maxi + solve(z+1,arr,k,dp);\\n            maxSum = max(sum,maxSum);\\n        }\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,arr,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539902,
                "title": "python-concise-code-dp",
                "content": "DP[i] denotes: the max value it can get to index i -1 in arr . (inlcuding i-1)\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0] * (n+1)\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, k+1):\\n                if i - j >= 0:\\n                    dp[i] = max(\\n                        dp[i-j] + max(arr[i-j: i]) * j ,\\n                        dp[i]\\n                    )\\n        return dp[-1]\\n",
                "solutionTags": [],
                "code": "DP[i] denotes: the max value it can get to index i -1 in arr . (inlcuding i-1)\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0] * (n+1)\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, k+1):\\n                if i - j >= 0:\\n                    dp[i] = max(\\n                        dp[i-j] + max(arr[i-j: i]) * j ,\\n                        dp[i]\\n                    )\\n        return dp[-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2239967,
                "title": "c-easy-front-partition-recursion-memo-to-tabulation-dp",
                "content": "**\\u2705Please upvote if you find the post useful\\u2705**\\n\\nIt is pretty easy to understand that greedy will not work here and we have to find all possible partitions and take the maximum amongst them.\\n\\nNow, to find all possible partitions, we have to write a recursive function.\\n\\n**Let\\'s define our recursive function as F where F(i) denotes the maximum sum we can get from index i till last index.**\\n\\nAt any index i, we can make partitions of length 1, 2, 3....k. Hence we will loop at every index and try all k partitions. Refer to the pseudo code below.\\n\\n***Base Condition** : When i == n we have exhausted the array hence we will return 0.*\\n\\nLet\\'s try to write the pseudo code.\\n```\\nF(i) {\\n\\tsum = INT_MIN\\n\\tfor(j = i to i + k)\\n\\t\\tcurrent sum = max element in current partition * length of current partition\\n\\t\\t\\t\\t\\t\\t\\t\\t+ F(j + 1)\\n\\t\\tsum = max(sum, current sum)\\n\\treturn sum\\n}\\n```\\n\\n***Here F(0) will give us the answer***\\n\\nNow (i + k) can go out of bound that is when i + k >= n, (n = length of arr). So we have to handle that case as well.\\n`Hence j can go from i to min(n, i + k)`\\n\\n---\\n\\n### Recursion + Memo\\nNow, as we understand the pseudo code, we can write the recursive one as well.\\n```\\nclass Solution {\\n    int partition(int i, int k, vector<int>&arr, vector<int>&dp) {\\n        int n = arr.size();\\n        if(i == n) return 0; //base case\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        int max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n        for(int j = i; j < min(n, i + k); j++) {\\n            length++; //increase length in each partition\\n            max_num = max(max_num, arr[j]); //update maximum number in each partition\\n            int curr_sum = length * max_num + partition(j + 1, k, arr, dp);\\n            max_sum = max(max_sum, curr_sum);\\n        }\\n        \\n        return dp[i] = max_sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int>dp(n + 1, -1);\\n        int ans = partition(0, k, arr, dp);\\n        return ans;\\n    }\\n};\\n```\\n**TC : O(N^2)\\nSC : O(N)**\\n\\n---\\n\\n### Tabulation\\nNow, as we have written the recursive code, writing the tabulation is pretty easy. \\nIn recursion our i varied from 0 to n - 1. Hence, in tabulation, we will just go the other way around.\\nAs per our base condition, dp[n] = 0;\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size(), max_sum, max_num, length;\\n        \\n        int dp[n + 1];\\n        dp[n] = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n            for(int j = i; j < min(n, i + k); j++) {\\n                length++;\\n                max_num = max(max_num, arr[j]);\\n                int curr_sum = length * max_num + dp[j + 1];\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n\\n            dp[i] = max_sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n**TC : O(N^2)\\nSC : O(N)**\\n\\n**\\u2705Please upvote if you find the post useful\\u2705**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nF(i) {\\n\\tsum = INT_MIN\\n\\tfor(j = i to i + k)\\n\\t\\tcurrent sum = max element in current partition * length of current partition\\n\\t\\t\\t\\t\\t\\t\\t\\t+ F(j + 1)\\n\\t\\tsum = max(sum, current sum)\\n\\treturn sum\\n}\\n```\n```\\nclass Solution {\\n    int partition(int i, int k, vector<int>&arr, vector<int>&dp) {\\n        int n = arr.size();\\n        if(i == n) return 0; //base case\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        int max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n        for(int j = i; j < min(n, i + k); j++) {\\n            length++; //increase length in each partition\\n            max_num = max(max_num, arr[j]); //update maximum number in each partition\\n            int curr_sum = length * max_num + partition(j + 1, k, arr, dp);\\n            max_sum = max(max_sum, curr_sum);\\n        }\\n        \\n        return dp[i] = max_sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int>dp(n + 1, -1);\\n        int ans = partition(0, k, arr, dp);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size(), max_sum, max_num, length;\\n        \\n        int dp[n + 1];\\n        dp[n] = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            max_sum = INT_MIN, max_num = INT_MIN, length = 0;\\n        \\n            for(int j = i; j < min(n, i + k); j++) {\\n                length++;\\n                max_num = max(max_num, arr[j]);\\n                int curr_sum = length * max_num + dp[j + 1];\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n\\n            dp[i] = max_sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078593,
                "title": "recursive-memoization-solution-with-clean-code",
                "content": "class Solution {\\npublic:\\n\\n    int m;\\n    vector<int> v;\\n    int t[502];//memoization array...\\n    int rec(int i,int n){\\n        if(i>=n) return 0;//base function....\\n        if(t[i]) return t[i];\\n        int mx=0,cur=0;\\n        for(int p=0;p<m;p++){\\n            if(i+p>=n) break;//if limit exceeds..\\n            mx=max(mx,v[i+p]);\\n            cur=max(cur,mx*(p+1)+rec(i+p+1,n));//condition to be satisfied....\\n        }\\n        return t[i]=cur;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        v=arr;//assign to global vector....\\n        m=k;//assign to global variable....\\n        return rec(0,v.size());\\n    }\\n};\\nIf you like the solution please upvote \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09.....",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int m;\\n    vector<int> v;\\n    int t[502];//memoization array...\\n    int rec(int i,int n){\\n        if(i>=n) return 0;//base function....\\n        if(t[i]) return t[i];\\n        int mx=0,cur=0;\\n        for(int p=0;p<m;p++){\\n            if(i+p>=n) break;//if limit exceeds..\\n            mx=max(mx,v[i+p]);\\n            cur=max(cur,mx*(p+1)+rec(i+p+1,n));//condition to be satisfied....\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838637,
                "title": "java-solution-dp-bottom-up-approach",
                "content": "\\'\\'\\'\\n\\n\\n\\n\\n     class Solution {\\n      public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n       \\n        int[] dp=new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            int max=0;\\n            int val=0;\\n            for(int j=1;j<=Math.min(i,k);j++){\\n                max=Math.max(max,arr[i-j]);\\n                \\n                val=Math.max(dp[i-j]+max*j,val);\\n                \\n            }\\n            dp[i]=val;\\n        }\\n        return dp[n];\\n    }\\n}   \\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n      public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n       \\n        int[] dp=new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            int max=0;\\n            int val=0;\\n            for(int j=1;j<=Math.min(i,k);j++){\\n                max=Math.max(max,arr[i-j]);\\n                \\n                val=Math.max(dp[i-j]+max*j,val);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1539213,
                "title": "simple-python-solution-with-explanation",
                "content": "Explanation : https://github.com/midnightbot/leetcode_solutions/blob/main/1043.%20Partition%20Array%20for%20Maximum%20Sum(DP).pdf\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        #opt[i] be optimal ans for 0..i\\n        \\n        memo = [-1] * len(arr)\\n        memo[0] = arr[0]\\n        #memo[1] = max(arr[0],arr[1])*2\\n        #memo[2] = max(arr[0],arr[1],arr[2])*3\\n        \\n        for y in range(1,k): ##initialization\\n            \\n            memo[y] = max(arr[0:y+1]) * (y+1)\\n        \\n        for x in range(k,len(arr)):\\n            #print(memo)\\n            maxs = max(arr[x-k+1:x+1])\\n            for z in range(1,k+1):\\n                maxs = max(arr[x-z+1:x+1])\\n                memo[x] = max(memo[x],memo[x-1] + arr[x], maxs*z + memo[x-z])\\n        #print(memo)    \\n        return memo[len(arr)-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        #opt[i] be optimal ans for 0..i\\n        \\n        memo = [-1] * len(arr)\\n        memo[0] = arr[0]\\n        #memo[1] = max(arr[0],arr[1])*2\\n        #memo[2] = max(arr[0],arr[1],arr[2])*3\\n        \\n        for y in range(1,k): ##initialization\\n            \\n            memo[y] = max(arr[0:y+1]) * (y+1)\\n        \\n        for x in range(k,len(arr)):\\n            #print(memo)\\n            maxs = max(arr[x-k+1:x+1])\\n            for z in range(1,k+1):\\n                maxs = max(arr[x-z+1:x+1])\\n                memo[x] = max(memo[x],memo[x-1] + arr[x], maxs*z + memo[x-z])\\n        #print(memo)    \\n        return memo[len(arr)-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474132,
                "title": "python-recursion-intuitive-code",
                "content": "Note that we can have a sub-array of at most k elements.\\n\\nFor example: [1,15,7] and k = 2\\n\\n```\\nidx: 0  1 2\\nval: 1 15 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      .\\n\\t\\t       max([1])*1+R([15,7])               max[1,15]*2+R([7]\\nmax([15])*1 + R([7])      max([15,7]*2 + R([])              max([7]*1) + R([])\\nmax([7]*1 + R([]))\\n```\\n\\nMemoization can be added later using lru_cache or a dictionary.\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\n        @lru_cache(maxsize = None)\\n        def recurse(i):\\n            #base case\\n            if i >= len(arr):\\n                return 0\\n            \\n            ret = 0\\n            for j in range(i+1,min(i+1+k, len(arr)+1)):\\n                temp = max(arr[i:j])*(j-i)\\n                ret = max(ret, temp+recurse(j))\\n            \\n            return ret\\n        \\n        return recurse(0)\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nidx: 0  1 2\\nval: 1 15 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      .\\n\\t\\t       max([1])*1+R([15,7])               max[1,15]*2+R([7]\\nmax([15])*1 + R([7])      max([15,7]*2 + R([])              max([7]*1) + R([])\\nmax([7]*1 + R([]))\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\n        @lru_cache(maxsize = None)\\n        def recurse(i):\\n            #base case\\n            if i >= len(arr):\\n                return 0\\n            \\n            ret = 0\\n            for j in range(i+1,min(i+1+k, len(arr)+1)):\\n                temp = max(arr[i:j])*(j-i)\\n                ret = max(ret, temp+recurse(j))\\n            \\n            return ret\\n        \\n        return recurse(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211040,
                "title": "java-progressive-solution",
                "content": "**Method 1:** Brute force\\n* At each level of recursion, index will advance by 1 and the logic will branch into k branches.\\n* What the recursion tree looks like for arr = [1, 15, 7, 9], k = 2\\n![image](https://assets.leetcode.com/users/images/9d28806a-26be-497b-98a1-dedc1db437fb_1621139418.690102.jpeg)\\n\\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k);\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k) {\\n\\tif (start >= arr.length)\\n\\t\\treturn 0;\\n\\tvar localMax = 0;\\n\\tvar globalMax = 0;\\n\\t// the loop condition here means, I want the loop to run through the subArray, from start to start + k (end),\\n\\t// but not go out of bounds in the process.\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\t// (i - start + 1) is the paritioned subArray size, all the elements of which have to \"flipped\" \\n\\t\\t// (count in total as that max value) to the max element of that subarray\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k));\\n\\t}\\n\\treturn globalMax;\\n}\\n```\\n\\n**Method 2:** Inject Memoization into method 1, i.e. right before you return a result, hash it.\\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k, new HashMap<>());\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k, Map<Integer, Integer> map) {\\n\\tif (start == arr.length)\\n\\t\\treturn 0;\\n\\tif (map.containsKey(start))\\n\\t\\treturn map.get(start);\\n\\tvar globalMax = 0;\\n\\tvar localMax = 0;\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k, map));\\n\\t}\\n\\tmap.put(start, globalMax);\\n\\treturn globalMax;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k);\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k) {\\n\\tif (start >= arr.length)\\n\\t\\treturn 0;\\n\\tvar localMax = 0;\\n\\tvar globalMax = 0;\\n\\t// the loop condition here means, I want the loop to run through the subArray, from start to start + k (end),\\n\\t// but not go out of bounds in the process.\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\t// (i - start + 1) is the paritioned subArray size, all the elements of which have to \"flipped\" \\n\\t\\t// (count in total as that max value) to the max element of that subarray\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k));\\n\\t}\\n\\treturn globalMax;\\n}\\n```\n```\\npublic int maxSumAfterPartitioning(int[] arr, int k) {\\n\\treturn maxSumAfterPartitioning(arr, 0, k, new HashMap<>());\\n}\\n\\nprivate int maxSumAfterPartitioning(int[] arr, int start, int k, Map<Integer, Integer> map) {\\n\\tif (start == arr.length)\\n\\t\\treturn 0;\\n\\tif (map.containsKey(start))\\n\\t\\treturn map.get(start);\\n\\tvar globalMax = 0;\\n\\tvar localMax = 0;\\n\\tfor (var i = start; i < start + k && i < arr.length; i++) {\\n\\t\\tlocalMax = Math.max(localMax, arr[i]);\\n\\t\\tglobalMax = Math.max(globalMax, (localMax * (i - start + 1)) + maxSumAfterPartitioning(arr, i + 1, k, map));\\n\\t}\\n\\tmap.put(start, globalMax);\\n\\treturn globalMax;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192230,
                "title": "java-bottom-up-dp-solution",
                "content": "Suppose  we know answers ans[] i.e max sum for  arr[0], arr[0..1], arr[0..2] .... arr[0....n-1] , \\nlet ans[i] = max sum for arr[0....i]\\nthen when n th element is added, the max sum for new array i.e arr[0....n] would be max of { ans[n-j] + j * max element in arr[n-j ... n] ) } for j belongs to (0 .. k).\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length + 1];\\n        for(int i = 1; i <= arr.length; i++){\\n            int dpMax = Integer.MIN_VALUE;\\n            int max= Integer.MIN_VALUE;\\n            for(int j = 0; j < k; j++){\\n                \\n                if(i - j - 1 >= 0){\\n                    max = Math.max(max, arr[i-j-1]);\\n                    dpMax = Math.max(dpMax, dp[i-j-1] + (j + 1)*max );\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            dp[i] = dpMax;\\n        }\\n        return dp[arr.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length + 1];\\n        for(int i = 1; i <= arr.length; i++){\\n            int dpMax = Integer.MIN_VALUE;\\n            int max= Integer.MIN_VALUE;\\n            for(int j = 0; j < k; j++){\\n                \\n                if(i - j - 1 >= 0){\\n                    max = Math.max(max, arr[i-j-1]);\\n                    dpMax = Math.max(dpMax, dp[i-j-1] + (j + 1)*max );\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            dp[i] = dpMax;\\n        }\\n        return dp[arr.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012677,
                "title": "python-top-down-dp",
                "content": "Let dp[n] = the largest sum of the array arr[:n] after partitioning.\\nBase case: (i) n == 0, dp[0] = 0\\n                    (ii) n <= k, just one partition, n * max(arr[:n])\\nRecurrence:\\nn > k, the last partition has k choices: 1 number, 2 numbers, ..., k numbers,\\nthus, dp[n] = max([dp[n-i] + i * max(arr[n-i:n]) for i in range(1, k + 1)])\\n```\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def recursive(n):\\n            if n == 0:\\n                return 0\\n            if n <= k:\\n                return max(arr[:n]) * n\\n            if n in dp:\\n                return dp[n]\\n            curr_max = arr[n-1]\\n            dp[n] = recursive(n - 1) + curr_max\\n            for i in range(2, k + 1):\\n                curr_max = max(curr_max, arr[n - i])\\n                dp[n] = max(dp[n], recursive(n - i) + curr_max * i)\\n            return dp[n]\\n        \\n        dp = dict()\\n        return recursive(len(arr))\\n```\\nTime complexity: O(n * k)",
                "solutionTags": [],
                "code": "```\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def recursive(n):\\n            if n == 0:\\n                return 0\\n            if n <= k:\\n                return max(arr[:n]) * n\\n            if n in dp:\\n                return dp[n]\\n            curr_max = arr[n-1]\\n            dp[n] = recursive(n - 1) + curr_max\\n            for i in range(2, k + 1):\\n                curr_max = max(curr_max, arr[n - i])\\n                dp[n] = max(dp[n], recursive(n - i) + curr_max * i)\\n            return dp[n]\\n        \\n        dp = dict()\\n        return recursive(len(arr))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 778772,
                "title": "java-dp-with-comments",
                "content": "class Solution {\\n    \\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n    \\n        int[] dp = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            \\n            /**\\n                We want to partition the array\\n                in such a way that we expand \\n                the current window to size K\\n                backwards and use the dp value\\n                at i - K if it exists in our solution\\n            \\n            **/\\n            \\n            int windowMax = 0;\\n            \\n            // k is my window size\\n            // k can be almost of size K - max window size available\\n            // current position - window size should be greater than equal to 0\\n            // we don\\'t want the window to skid through the first position\\n            \\n            for (int k = 1; k <= K && (i - (k -1) >= 0); k++) {\\n                \\n                windowMax = Math.max(windowMax, A[i - (k -1)]);\\n                \\n                dp[i] = Math.max(dp[i], (i-k >= 0 ? dp[i-k] : 0) + windowMax * k);\\n                \\n            }\\n\\n        }\\n         \\n        return dp[A.length - 1];\\n    }\\n   \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    \\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n    \\n        int[] dp = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            \\n            /**\\n                We want to partition the array\\n                in such a way that we expand \\n                the current window to size K\\n                backwards and use the dp value\\n                at i - K if it exists in our solution\\n            \\n            **/\\n            \\n            int windowMax = 0;\\n            \\n            // k is my window size\\n            // k can be almost of size K - max window size available\\n            // current position - window size should be greater than equal to 0\\n            // we don\\'t want the window to skid through the first position\\n            \\n            for (int k = 1; k <= K && (i - (k -1) >= 0); k++) {\\n                \\n                windowMax = Math.max(windowMax, A[i - (k -1)]);\\n                \\n                dp[i] = Math.max(dp[i], (i-k >= 0 ? dp[i-k] : 0) + windowMax * k);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 391648,
                "title": "java-solution-with-dynamic-programming",
                "content": "if `i` less than `K`, dp[i] = max(A[0], ..., A[i]) * i, else dp[i] = max(dp[i - j] + max(A[i - j + 1]) * j) while `j` from 1 to K.\\n\\n```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int len = A.length;\\n        int[] dp = new int[len];\\n        \\n        int max = A[0];\\n        for(int i = 0; i < K; i++){\\n            max = Math.max(max, A[i]);\\n            dp[i] = max * (i+1);\\n        }\\n        \\n        for(int i = K;i < len; i++){\\n            max = A[i];\\n            for(int j = 1; j <= K; j++){\\n                max = Math.max(max, A[i - j + 1]);\\n                dp[i] = Math.max(dp[i], dp[i - j] + max * j);\\n            }\\n        }\\n        \\n        return dp[len - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int len = A.length;\\n        int[] dp = new int[len];\\n        \\n        int max = A[0];\\n        for(int i = 0; i < K; i++){\\n            max = Math.max(max, A[i]);\\n            dp[i] = max * (i+1);\\n        }\\n        \\n        for(int i = K;i < len; i++){\\n            max = A[i];\\n            for(int j = 1; j <= K; j++){\\n                max = Math.max(max, A[i - j + 1]);\\n                dp[i] = Math.max(dp[i], dp[i - j] + max * j);\\n            }\\n        }\\n        \\n        return dp[len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291575,
                "title": "python-o-nk-time-o-n-space-solution",
                "content": "dp[i] means the maximum result we can get in A[ : i]\\n```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        curMax = 0\\n        for i in range(n):\\n            if i < K: \\n                curMax = max(curMax, A[i])\\n                dp[i] = curMax * (i + 1)\\n            else:\\n                curMax = 0\\n                for j in range(1, K + 1):\\n                    curMax = max(A[i - j + 1], curMax)\\n                    dp[i] = max(dp[i], dp[i - j] + curMax * j)\\n        return dp[n - 1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        curMax = 0\\n        for i in range(n):\\n            if i < K: \\n                curMax = max(curMax, A[i])\\n                dp[i] = curMax * (i + 1)\\n            else:\\n                curMax = 0\\n                for j in range(1, K + 1):\\n                    curMax = max(A[i - j + 1], curMax)\\n                    dp[i] = max(dp[i], dp[i - j] + curMax * j)\\n        return dp[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290939,
                "title": "c-short-solution",
                "content": "```\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size() + 1, 0);\\n        \\n        for(int i = 1; i <= A.size(); i++) {\\n            int max = A[i-1];\\n            for(int j = i; j > i-K && j > 0; j--) {\\n                max = std::max(max, A[j-1]);\\n                dp[i] = std::max(dp[i], max*(i-j+1) + dp[j-1]);\\n            }\\n        }\\n        \\n        return dp[A.size()];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size() + 1, 0);\\n        \\n        for(int i = 1; i <= A.size(); i++) {\\n            int max = A[i-1];\\n            for(int j = i; j > i-K && j > 0; j--) {\\n                max = std::max(max, A[j-1]);\\n                dp[i] = std::max(dp[i], max*(i-j+1) + dp[j-1]);\\n            }\\n        }\\n        \\n        return dp[A.size()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640812,
                "title": "recursive-memoization-cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Iterate over each index in the array and consider it as the starting point of a partition. Within each partition, find the maximum element and calculate the sum by multiplying the maximum element with the size of the partition. Update the maximum sum found so far.\\n\\n- Use dynamic programming to store and reuse the results of subproblems. Before calculating the sum for a particular index, check if it has already been computed and stored in the dynamic programming array. If so, retrieve the result directly instead of recomputing it. This optimization helps avoid redundant calculations and improves efficiency.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The solve function is a recursive helper function that calculates the maximum possible sum after partitioning the array arr. It takes the following parameters:\\n\\n- arr: A reference to the input vector of integers.\\n- ind: The current index in the array.\\n- k: The maximum size of each partition.\\n- n: The total number of elements in the array.\\n- dp: A reference to a vector that stores previously calculated results for dynamic programming.\\n\\n- The first condition if(ind>=n) return 0; checks if the current index ind is beyond the last index of the array. If so, it means we have reached the end of the array, and there are no more elements to process. In this case, the function returns 0, indicating that there are no elements to add to the sum.\\n\\n- The second condition if(dp[ind]!=-1) return dp[ind]; checks if the result for the current index ind has already been calculated and stored in the dynamic programming vector dp. If the value is not equal to -1, it means the result is already known and can be directly returned without further computation.\\n\\n- The variables max_ele and sum are initialized. max_ele is set to the minimum possible value (INT_MIN) to keep track of the maximum element within the current partition. sum is initially set to 0 and will store the maximum sum found so far.\\n\\n- The for loop iterates over the elements from the current index ind up to the minimum of ind+k and n (to ensure we don\\'t go beyond the array boundaries or the maximum partition size).\\n\\n- Inside the loop, max_ele is updated by comparing its current value with the element at the current index arr[i]. If arr[i] is greater than max_ele, max_ele is updated to arr[i].\\n\\n- The variable sum is updated by recursively calling the solve function with the next index i+1. The result of the recursive call is added to (i-ind+1)*max_ele, which represents the sum of the current partition multiplied by the maximum element within that partition. The max function is used to keep track of the maximum value of sum obtained during the iterations of the loop.\\n\\n- Finally, the value of sum is stored in the dp vector at the current index ind before returning it.\\n\\n- The maxSumAfterPartitioning function is the entry point for the problem. It takes the input array arr and the maximum partition size k. It initializes a dynamic programming vector dp with size n+1 and fills it with -1 to indicate that no results have been computed yet.\\n\\n- The function calls the solve function with the initial index 0 and returns the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`The time complexity of the solution is O(n * k), where n is the number of elements in the array and k is the maximum partition size. This is because for each index, we iterate up to k elements to find the maximum element within the partition.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`The space complexity is O(n), as we use a dynamic programming array of size n+1 to store the results of subproblems.`\\n\\n# Recursive Code\\n```\\nint solve(vector<int>& arr, int ind, int k, int n)\\n    {\\n        if(ind>=n) return 0;\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n)+(i-ind+1)*max_ele);\\n        }\\n        return sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        return solve(arr,0,k,n);\\n    }\\n```\\n\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int ind, int k, int n,vector<int>& dp)\\n    {\\n        if(ind>=n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n,dp)+(i-ind+1)*max_ele);\\n        }\\n        return dp[ind] = sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(arr,0,k,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(vector<int>& arr, int ind, int k, int n)\\n    {\\n        if(ind>=n) return 0;\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n)+(i-ind+1)*max_ele);\\n        }\\n        return sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        return solve(arr,0,k,n);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int ind, int k, int n,vector<int>& dp)\\n    {\\n        if(ind>=n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n\\n        int max_ele = INT_MIN;\\n        int sum = 0;\\n        for(int i=ind; i<min(ind+k,n); i++)\\n        {\\n            max_ele = max(max_ele,arr[i]);\\n            sum = max(sum , solve(arr,i+1,k,n,dp)+(i-ind+1)*max_ele);\\n        }\\n        return dp[ind] = sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(arr,0,k,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681126,
                "title": "c-recursion-memoization-tabulation",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/8ed9036b-20bd-4ba5-8a9c-ed5bca2fc081_1665314833.9614336.png)\\n\\n**T->O(n^k) && S->O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& arr,int k,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\tint op=(j+1)*maxi+f(i+j+1,arr,k,n);\\n\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\treturn f(0,arr,k,n);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n# Method -2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/99955af2-3dfa-4b3b-9667-2760066c6453_1665314840.2871518.png)\\n\\n**T->O(nk) && S->O(nk) + O(n) [Recursion stackspace]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& arr,int k,int n,vector<int>& dp){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\tint op=(j+1)*maxi+f(i+j+1,arr,k,n,dp);\\n\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i]=ans;\\n\\t\\t}\\n\\n\\t\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp(n,-1);\\n\\t\\t\\treturn f(0,arr,k,n,dp);\\n\\t\\t}\\n\\t};\\n\\n# Method -3 [Tabulation]\\n![image](https://assets.leetcode.com/users/images/0bad273e-2223-424f-8846-7bbb62dd63f0_1665315382.794784.png)\\n\\n**T->O(nk) && S->O(nk)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp(n+k,0);\\n\\t\\t\\tfor(int i=n+k-1;i>=0;i--){\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\t\\tint op=(j+1)*maxi+dp[i+j+1];\\n\\t\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i]=ans;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0];\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& arr,int k,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int j=0;j<k && i+j<n;j++){\\n\\t\\t\\t\\tint maxi=*max_element(arr.begin()+i,arr.begin()+i+j+1);\\n\\t\\t\\t\\tint op=(j+1)*maxi+f(i+j+1,arr,k,n);\\n\\t\\t\\t\\tans=max(ans,op);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2290264,
                "title": "c-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> arr;\\n    int k;\\n    int n;\\n    \\n    // state - index\\n    int dp[505];\\n    \\n    int rec(int level){\\n        // base case\\n        if(level == n){\\n            return 0;\\n        }\\n        if(dp[level] != -1) return dp[level];\\n        int ans = 0;\\n        \\n        // to maintain max of subarray\\n        int mx = 0;\\n        for(int i=0;i<k;i++){\\n            // if index goes out of bound\\n            if(level+i>=n) break;\\n            \\n            // maintaining max\\n            mx = max(mx,arr[level+i]);\\n            \\n            // transition -> parition from level to level+i, so now start subarray from level+i+1\\n            // we add mx*(i+1) as max of subarray from level to level+i is mx and its length is i+1\\n            ans = max(ans,mx*(i+1) +rec(level+i+1));\\n        }\\n        return dp[level] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& _arr, int _k) {\\n        arr = _arr;\\n        k = _k;\\n        n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> arr;\\n    int k;\\n    int n;\\n    \\n    // state - index\\n    int dp[505];\\n    \\n    int rec(int level){\\n        // base case\\n        if(level == n){\\n            return 0;\\n        }\\n        if(dp[level] != -1) return dp[level];\\n        int ans = 0;\\n        \\n        // to maintain max of subarray\\n        int mx = 0;\\n        for(int i=0;i<k;i++){\\n            // if index goes out of bound\\n            if(level+i>=n) break;\\n            \\n            // maintaining max\\n            mx = max(mx,arr[level+i]);\\n            \\n            // transition -> parition from level to level+i, so now start subarray from level+i+1\\n            // we add mx*(i+1) as max of subarray from level to level+i is mx and its length is i+1\\n            ans = max(ans,mx*(i+1) +rec(level+i+1));\\n        }\\n        return dp[level] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& _arr, int _k) {\\n        arr = _arr;\\n        k = _k;\\n        n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889336,
                "title": "recursion-linear-dp-solution-with-explanation",
                "content": "# 1. Recursion approach:\\n\\n=> Suppose that we have to conisder a subarray starting from ith index. \\n=> Lets consider ith element only (single element subarray) for the current subarray. Now, our problem gets reduced finding maximum sum from i + 1 to n - 1 (after partition).\\n\\nHence, the recurrence relation comes out to be equal to:\\nsubproblem1 = maximumOfOne + findSum(i + 1)\\nWhere maximumOfOne is the maximum element in the range i to i.\\n\\n=> Lets consider ith element and i + 1 element for the current subarray. Now, our problem gets reduced finding maximum sum from i + 2 to n - 1 (after partition).\\n\\nHence, the recurrence relation comes out to be equal to:\\nsubproblem2 = maximumOfTwo + findSum(i + 2)\\n\\nWhere maximumOfTwo is the maximum element in the range i to i + 1.\\n\\n................................................................................................................................................\\n\\n................................................................................................................................................\\n\\n................................................................................................................................................\\n\\n=> Lets consider ith element, i + 1, .. , i + k - 1 element for the current subarray. Now, our problem gets reduced finding maximum sum from i+ k to n - 1 (after partition).\\n\\nHence, the recurrence relation comes out to be equal to:\\nsubproblem= maximumOfCurrentSize + findSum(i + k)\\n\\nThus, we need to find and return maximum of (subproblem1, subproblem2, ...., subproblemk)\\n\\nTime Complexity: Exponential\\nSpace: Exponential\\n\\n**Source Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n```\\n\\n# 2. Dynamic Programming approach:\\n\\nThe program will produce TLE. Thus, we need to optimize our code. Note that we can solve this problem using dynamic programming. To solve a problem using dynamic programming it must fulfill two basic requirements:\\n\\n* Optimal Substructure\\n* Overlapping Subproblem\\n\\nIf you look closely you may notice that finding the maximum sum for elements from i = 0 to n - 1 has the same structure as finding the maximum sum for elements from i = 1 to i = n - 1, i = 2 to i = n - 1, and so on. Thus, Optimal Substructure exists in the problem.\\n\\n\\nAlso, suppose that we want to consider one element in the current subarray lets say arr[i] element. Now lets say again we want to consider only one element for the next subbary that is arr[i + 1]. Now we will call  findSum(i + 2) {That, is maximum sum after partition when elements from i + 2 to n - 1 are considered}.\\n\\nTaking another example, lets say we want to consider first two elements in the current subarray let say arr[i] and arr[i + 1].  So we will call  findSum(i + 2) {That, is maximum sum after partition when elements from i + 2 to n - 1 are considered}.\\n\\nAs you can see for the above two examples, we are calling findSum() function for the same parameter (i + 2). Hence, Overlapping Subproblem exists in the problem.\\n\\nThus, we can now think about a dynamic problem approach.\\n\\nThe simple way is to memoize the recursion approach as discussed above. We can create a 1D dp vector in which dp[i] stores the maximum sum after splitting when element from arr[i] to arr[n - 1] are considered.\\n\\n**Source Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n\\n```\\n\\nTime Complexity: O(N) as we are iterating over a 1D vector only.\\nSpace: O(N) as call stack is used\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(vector<int> &arr,  long long int n, long long int k, long long int i)\\n    {\\n        if(i == n)\\n            return 0;\\n        \\n        long long int mx = 0;\\n        long long int ans = 0;\\n        \\n        for(int j = i ; j < i + k && j < n ; j++)\\n        {\\n            mx = max(mx, (long long)arr[j]);\\n            ans = max(ans, (j - i + 1) * mx + solve(arr, n, k, j + 1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        long long int n = arr.size();\\n        vector<int> dp(n, -1);\\n        return solve(arr, n, k, 0);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428374,
                "title": "c-dp-7-lines",
                "content": "```\\n\\n```public:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            int m=0;\\n            int ans=0;\\n            for(int j=i-1;j>=0&&j>=i-k;j--)\\n            {\\n                m=max(m,arr[j]);\\n                ans=max(ans,m*(i-j)+dp[j]);\\n            }\\n            dp[i]=ans;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1327920,
                "title": "nice-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int dp[500];\\n    int maxsum(vector<int>& arr,int  start, int k){\\n    \\n        if(start>=n) return 0;\\n        \\n        if(dp[start]!=-1) return dp[start];\\n        int temp=0;\\n        int ans=0;\\n        for(int i=start;i<n&&i<=start+k-1;i++){\\n            \\n            temp=max(temp,arr[i]);\\n            ans =max(ans, temp* (i-start+1)+ maxsum(arr,i+1,k) );\\n        }\\n        \\n        return  dp[start]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        \\n        for(int i=0;i<500;i++) dp[i]=-1;\\n        return maxsum(arr,0,k);\\n    }\\n};\\n```\\n\\n////writing iteratively \\n\\n\\n \\n```\\n \\n class Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[501]={};\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int temp=0;\\n            int ans=0;\\n            \\n            for(int j=i;j<min(n,i+k);j++){\\n               temp=max(temp,arr[j]);\\n                 \\n                ans=max(ans,temp*(j-i+1)+dp[j+1]);\\n            }\\n            dp[i]=ans;\\n        }\\n        \\n       return dp[0]; \\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int dp[500];\\n    int maxsum(vector<int>& arr,int  start, int k){\\n    \\n        if(start>=n) return 0;\\n        \\n        if(dp[start]!=-1) return dp[start];\\n        int temp=0;\\n        int ans=0;\\n        for(int i=start;i<n&&i<=start+k-1;i++){\\n            \\n            temp=max(temp,arr[i]);\\n            ans =max(ans, temp* (i-start+1)+ maxsum(arr,i+1,k) );\\n        }\\n        \\n        return  dp[start]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        \\n        for(int i=0;i<500;i++) dp[i]=-1;\\n        return maxsum(arr,0,k);\\n    }\\n};\\n```\n```\\n \\n class Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[501]={};\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int temp=0;\\n            int ans=0;\\n            \\n            for(int j=i;j<min(n,i+k);j++){\\n               temp=max(temp,arr[j]);\\n                 \\n                ans=max(ans,temp*(j-i+1)+dp[j+1]);\\n            }\\n            dp[i]=ans;\\n        }\\n        \\n       return dp[0]; \\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243253,
                "title": "c-dp-solution-tabulation-approach-by-kushalatolia",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0]=arr[0];\\n        int max1=arr[0];\\n        for(int i=1;i<k;i++)\\n        {\\n             max1=max(max1,arr[i]);\\n            dp[i]=max1*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            int subarraymax=arr[i];\\n            for(int subarraysize=1;subarraysize<=k;subarraysize++)\\n            {\\n                subarraymax=max(subarraymax,arr[i-subarraysize+1]);\\n                dp[i]=max(dp[i],dp[i-subarraysize]+(subarraymax*subarraysize));\\n            }\\n        }\\n                    return dp[n-1];\\n\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6af5e6b8-5e92-4659-bed8-cb26eaee1fc0_1622832389.5839505.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0]=arr[0];\\n        int max1=arr[0];\\n        for(int i=1;i<k;i++)\\n        {\\n             max1=max(max1,arr[i]);\\n            dp[i]=max1*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            int subarraymax=arr[i];\\n            for(int subarraysize=1;subarraysize<=k;subarraysize++)\\n            {\\n                subarraymax=max(subarraymax,arr[i-subarraysize+1]);\\n                dp[i]=max(dp[i],dp[i-subarraysize]+(subarraymax*subarraysize));\\n            }\\n        }\\n                    return dp[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106205,
                "title": "c-simple-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int K;\\n    int dp[501][501];\\n    int util(vector<int>& arr,int s,int e){\\n        if(s>e) return 0;\\n        if(s==e) return dp[s][e]=arr[s];\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        int ans=INT_MIN;\\n        int max_till_here=INT_MIN;\\n        for(int i=s;i<=min(s+K-1,e);i++){\\n            max_till_here=max(arr[i],max_till_here);\\n            ans=max((i-s+1)*max_till_here+util(arr,i+1,e),ans);\\n        }\\n        return dp[s][e]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        K=k;\\n        int n=arr.size();\\n        return util(arr,0,n-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int K;\\n    int dp[501][501];\\n    int util(vector<int>& arr,int s,int e){\\n        if(s>e) return 0;\\n        if(s==e) return dp[s][e]=arr[s];\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        int ans=INT_MIN;\\n        int max_till_here=INT_MIN;\\n        for(int i=s;i<=min(s+K-1,e);i++){\\n            max_till_here=max(arr[i],max_till_here);\\n            ans=max((i-s+1)*max_till_here+util(arr,i+1,e),ans);\\n        }\\n        return dp[s][e]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        K=k;\\n        int n=arr.size();\\n        return util(arr,0,n-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060832,
                "title": "c-recursion-with-memorization-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo(vector<int>& a,int i,int k,int K,int n,int maxi,int dp[][505])\\n    {\\n        if(i>=n)\\n            return 0;\\n        maxi=max(maxi,a[i]);\\n        if(k==K)\\n            return memo(a,i+1,1,K,n,0,dp)+(maxi*k);\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        return dp[i][k]=max(memo(a,i+1,k+1,K,n,maxi,dp),memo(a,i+1,1,K,n,0,dp)+(maxi*k));\\n    }\\n    int maxSumAfterPartitioning(vector<int>& a, int K) {\\n        int n=a.size();\\n        int dp[n+1][505];\\n        memset(dp,-1,sizeof(dp));\\n        return memo(a,0,1,K,n,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo(vector<int>& a,int i,int k,int K,int n,int maxi,int dp[][505])\\n    {\\n        if(i>=n)\\n            return 0;\\n        maxi=max(maxi,a[i]);\\n        if(k==K)\\n            return memo(a,i+1,1,K,n,0,dp)+(maxi*k);\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        return dp[i][k]=max(memo(a,i+1,k+1,K,n,maxi,dp),memo(a,i+1,1,K,n,0,dp)+(maxi*k));\\n    }\\n    int maxSumAfterPartitioning(vector<int>& a, int K) {\\n        int n=a.size();\\n        int dp[n+1][505];\\n        memset(dp,-1,sizeof(dp));\\n        return memo(a,0,1,K,n,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037520,
                "title": "easy-python-high-speed-3-approaches-o-k-space-complexity",
                "content": "**Easy Python | High Speed | 3 Approaches | O(k) space complexity**\\n\\n\\n**A) Pure Recursion + Memoization**\\n\\nSpace complexity: O(A)\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  {}\\n        \\n        def dp(i):\\n            \\n            if i==L:\\n                return 0\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                m     =  max(A[j],m)\\n                \\n                s     =  (j-i+1)*m + dp(j+1)\\n                \\n                best  =  max(best,s)\\n            \\n            memo[i] = best\\n            return best\\n        \\n        return dp(0)\\n```\\n\\n**B) Clean Array Building  (bottom-up Dynamic Programming)**\\n\\nSpace complexity: O(A)\\n\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(L+1) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                m    = max(m,A[j])\\n                s    = (j-i+1)*m + memo[j+1]\\n                best = max(best,s)\\n            \\n            memo[i] = best\\n        \\n        return memo[0]\\n```\\n\\n**C) High Speed, Reduced Memory Usage, Dynamic Programming (bottom-up)**\\n\\nSpace complexity: O(k)\\nTime complexity: O( A * k )\\n\\nLeetcode speed ratings of 90%+ are easily achievable.\\n\\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(k) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                if A[j] > m:\\n                    m  = A[j]\\n                \\n                s  =  (j-i+1)*m + memo[(j+1)%k]\\n                \\n                if s > best:\\n                    best  =  s\\n            \\n            memo[i%k] = best\\n        \\n        return memo[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  {}\\n        \\n        def dp(i):\\n            \\n            if i==L:\\n                return 0\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                m     =  max(A[j],m)\\n                \\n                s     =  (j-i+1)*m + dp(j+1)\\n                \\n                best  =  max(best,s)\\n            \\n            memo[i] = best\\n            return best\\n        \\n        return dp(0)\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(L+1) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                m    = max(m,A[j])\\n                s    = (j-i+1)*m + memo[j+1]\\n                best = max(best,s)\\n            \\n            memo[i] = best\\n        \\n        return memo[0]\\n```\n```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A, k):\\n        \\n        L     =  len(A)\\n        memo  =  [ 0 for _ in range(k) ]\\n        \\n        for i in range(L-1,-1,-1):\\n            \\n            m, best  =  0, 0\\n            \\n            for j in range(i,min(L,i+k)):\\n                \\n                if A[j] > m:\\n                    m  = A[j]\\n                \\n                s  =  (j-i+1)*m + memo[(j+1)%k]\\n                \\n                if s > best:\\n                    best  =  s\\n            \\n            memo[i%k] = best\\n        \\n        return memo[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941440,
                "title": "cpp-recursion-memoisation-very-easy-to-understand-with-explanation",
                "content": "In this question we have two choices.\\n\\n1. For each index, start a new subarray and add the value we have\\n2. For each index, extend the same subarray but this subarray length must not be greater than k\\n\\n**The first Choice is **\\n\\tExtend the same subarray and keep a track of the maximum element in that subarray and previous start point of the same subarray.\\n\\t\\n\\t max(element, arr[current] ) this part will keep track of the the maximum element in a particular of window\\n\\tint option_a = solve(A, current + 1, prev,  max(element, arr[current] ) ); \\n\\n**The second choice**\\n\\nStart a new subarray and make sure to add the result of previous subarray window.\\n    **int option_a = element * (current -  prev) +  solve(A, current + 1, current,  arr[curent] )**\\t\\n\\t\\n\\tNow we are starting a new subarray at this point , so the only element we have is arr[current] and our starting window of this subarray is index current.\\n\\t\\n\\tNow we have two choices we have to find the maximum of them.\\n```\\nclass Solution {\\npublic:\\n  \\n    int dp[501][501];\\n  \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n      memset(dp, -1, sizeof dp);\\n      \\n      return solve(arr, 0, 0, k, arr[0]);\\n    }\\n  \\n    int solve(vector<int> &A, int i, int j, int k, int ele) {\\n      \\n      if(i - j > k)\\n        return INT_MIN;\\n      \\n      if(i == A.size())\\n        return ele*(i - j);\\n      \\n      if(dp[i][j] != -1)\\n        return dp[i][j];\\n      \\n      int opt_1 = solve(A, i + 1, j, k, max(A[i], ele));\\n      int opt_2 = ele*(i - j)  + solve(A, i + 1, i, k, A[i]);\\n      \\n      return dp[i][j] =  max(opt_1, opt_2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int dp[501][501];\\n  \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n      memset(dp, -1, sizeof dp);\\n      \\n      return solve(arr, 0, 0, k, arr[0]);\\n    }\\n  \\n    int solve(vector<int> &A, int i, int j, int k, int ele) {\\n      \\n      if(i - j > k)\\n        return INT_MIN;\\n      \\n      if(i == A.size())\\n        return ele*(i - j);\\n      \\n      if(dp[i][j] != -1)\\n        return dp[i][j];\\n      \\n      int opt_1 = solve(A, i + 1, j, k, max(A[i], ele));\\n      int opt_2 = ele*(i - j)  + solve(A, i + 1, i, k, A[i]);\\n      \\n      return dp[i][j] =  max(opt_1, opt_2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901220,
                "title": "python-short-and-simple-top-down-dp-explained",
                "content": "**Thoughts:**\\nAt each index there are at most two choices:\\n1. Continue extending the subarray if the current subarray is shorter than k.\\n2. Start a new subarray and add max(subbarray) &middot; len(subarray) to the total.\\n\\nA recursive function is used to try both options and the result of each option is added to **choices**.  \\nThen take the choice that has the highest total.  \\n\\n<br>\\n\\n**Notes:**\\nj is the end of the current subarray and i is the beginning of the current subarray\\nwe use j and i to keep track of the length of the subarray\\nmaxi is the maximum value in the current subarray\\n\\n<br>\\n\\n**Written for readability:**\\n```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\n\\tif k == 1: return sum(A)\\n\\tif k == len(A): return len(A)*max(A)\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tnonlocal k\\n\\t\\t\\n\\t\\t# reached the end of the array, we must close the current subarray\\n\\t\\tif j == len(A):\\n\\t\\t\\treturn maxi * (j - i)\\n\\n\\t\\tchoices = []\\n\\n\\t\\t# choice 1: extend subarray\\n\\t\\tif (j - i) < k:\\n\\t\\t\\tchoices.append(helper(j+1, max(A[j], maxi), i))\\n\\n\\t\\t# choice 2: start a new subarray\\n\\t\\tchoices.append(maxi * (j - i) + helper(j+1, A[j], j))\\n\\n\\t\\treturn max(choices)\\n\\n\\treturn helper(1, A[0], 0)\\n```\\n\\n<br>\\n\\n**More Concicely:**\\n```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tif j - i > k: return float(\\'-inf\\')\\n\\t\\tif j == len(A): return maxi * (j - i)\\n\\t\\treturn max(maxi * (j - i) + helper(j+1, A[j], j), helper(j+1, max(A[j], maxi), i))\\n\\treturn helper(1, A[0], 0)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\n\\tif k == 1: return sum(A)\\n\\tif k == len(A): return len(A)*max(A)\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tnonlocal k\\n\\t\\t\\n\\t\\t# reached the end of the array, we must close the current subarray\\n\\t\\tif j == len(A):\\n\\t\\t\\treturn maxi * (j - i)\\n\\n\\t\\tchoices = []\\n\\n\\t\\t# choice 1: extend subarray\\n\\t\\tif (j - i) < k:\\n\\t\\t\\tchoices.append(helper(j+1, max(A[j], maxi), i))\\n\\n\\t\\t# choice 2: start a new subarray\\n\\t\\tchoices.append(maxi * (j - i) + helper(j+1, A[j], j))\\n\\n\\t\\treturn max(choices)\\n\\n\\treturn helper(1, A[0], 0)\\n```\n```python\\ndef maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef helper(j, maxi, i):\\n\\t\\tif j - i > k: return float(\\'-inf\\')\\n\\t\\tif j == len(A): return maxi * (j - i)\\n\\t\\treturn max(maxi * (j - i) + helper(j+1, A[j], j), helper(j+1, max(A[j], maxi), i))\\n\\treturn helper(1, A[0], 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 842464,
                "title": "recursion-memoization-approach-with-full-explanation",
                "content": "**Idea:**\\n* Think this way, how much is the maximum sum obtained from index `i`? This can be calculated recursively. And we can expand the window k times before going to any recursion.\\n* Whatever is the result obtained from the recursion, add it with `current window\\'s maximum x window size`\\n* cache the computation, so that it can be used in future recursions.\\n\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        Map<Integer, Integer> cache = new HashMap<>();\\n        return helper(arr, k, 0, cache);\\n    }\\n    \\n    private int helper(int[] arr, int k, int idx, Map<Integer, Integer> cache) {\\n        if (idx == arr.length) {\\n            return 0;\\n            \\n        } else if (cache.containsKey(idx)) {\\n            return cache.get(idx);\\n            \\n        }\\n        \\n        int maxSoFar = 0,\\n            maxSumSoFar = 0;\\n        \\n        for (int i = idx; i < idx + k && i < arr.length; i++) {\\n            maxSoFar = Math.max(maxSoFar, arr[i]);\\n            maxSumSoFar = Math.max(maxSumSoFar, maxSoFar*(i - idx + 1) + helper(arr, k, i+1, cache));\\n        }\\n        \\n        cache.put(idx, maxSumSoFar);\\n        return maxSumSoFar;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        Map<Integer, Integer> cache = new HashMap<>();\\n        return helper(arr, k, 0, cache);\\n    }\\n    \\n    private int helper(int[] arr, int k, int idx, Map<Integer, Integer> cache) {\\n        if (idx == arr.length) {\\n            return 0;\\n            \\n        } else if (cache.containsKey(idx)) {\\n            return cache.get(idx);\\n            \\n        }\\n        \\n        int maxSoFar = 0,\\n            maxSumSoFar = 0;\\n        \\n        for (int i = idx; i < idx + k && i < arr.length; i++) {\\n            maxSoFar = Math.max(maxSoFar, arr[i]);\\n            maxSumSoFar = Math.max(maxSumSoFar, maxSoFar*(i - idx + 1) + helper(arr, k, i+1, cache));\\n        }\\n        \\n        cache.put(idx, maxSumSoFar);\\n        return maxSumSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797535,
                "title": "javascript-solution-top-down-approach-with-memoization-and-dynamic-programming-approach",
                "content": "**Top Down with Memoization**\\n\\n```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const memo = new Map();\\n    \\n    return findMaxSum(n - 1, 0, 0);\\n    \\n    function findMaxSum(index, maxVal, k) {\\n        const key = `${index}#${maxVal}#${k}`;\\n        \\n        // base case\\n        if (index < 0) return k * maxVal;\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let include = 0;\\n        let partition = 0;\\n        \\n        if (k < K) {\\n            include = findMaxSum(index - 1, Math.max(maxVal, A[index]), k + 1);\\n        }\\n        \\n        partition = (k * maxVal) + findMaxSum(index - 1, A[index], 1);\\n        \\n        const max = Math.max(partition, include);\\n        memo.set(key, max);\\n        \\n        return max;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n**Bottom Up (Dynamic Programming) Approach**\\n\\n```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const dp = new Array(n + 1).fill(0);\\n    dp[0] = 0;\\n    dp[1] = A[0];\\n    \\n    for (let i = 2; i <= n; i++) {\\n        let maxVal = A[i - 1];\\n        dp[i] = maxVal + dp[i - 1];\\n        \\n        for (let j = i - 1; j > 0 && i - j + 1 <= K; j--) {\\n            maxVal = Math.max(A[j - 1], maxVal);\\n            \\n            const len = i - j + 1;\\n            \\n            dp[i] = Math.max((len * maxVal) + dp[j - 1], dp[i]);\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const memo = new Map();\\n    \\n    return findMaxSum(n - 1, 0, 0);\\n    \\n    function findMaxSum(index, maxVal, k) {\\n        const key = `${index}#${maxVal}#${k}`;\\n        \\n        // base case\\n        if (index < 0) return k * maxVal;\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let include = 0;\\n        let partition = 0;\\n        \\n        if (k < K) {\\n            include = findMaxSum(index - 1, Math.max(maxVal, A[index]), k + 1);\\n        }\\n        \\n        partition = (k * maxVal) + findMaxSum(index - 1, A[index], 1);\\n        \\n        const max = Math.max(partition, include);\\n        memo.set(key, max);\\n        \\n        return max;\\n    }\\n};\\n```\n```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    const n = A.length;\\n    const dp = new Array(n + 1).fill(0);\\n    dp[0] = 0;\\n    dp[1] = A[0];\\n    \\n    for (let i = 2; i <= n; i++) {\\n        let maxVal = A[i - 1];\\n        dp[i] = maxVal + dp[i - 1];\\n        \\n        for (let j = i - 1; j > 0 && i - j + 1 <= K; j--) {\\n            maxVal = Math.max(A[j - 1], maxVal);\\n            \\n            const len = i - j + 1;\\n            \\n            dp[i] = Math.max((len * maxVal) + dp[j - 1], dp[i]);\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777041,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int k) {\\n        int n = A.size();\\n        vector<int> dp(n);\\n        dp[0] = A[0];\\n        for(int i = 1; i < n; i++) {\\n            int mx = A[i];\\n            int curr = INT_MIN;\\n            for(int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                mx = max(mx, A[i - j + 1]);\\n                if(i - j + 1 == 0)\\n                    curr = max(curr, j * mx);\\n                else\\n                    curr = max(curr, dp[i - j] + j * mx);\\n            }\\n            dp[i] = curr;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int k) {\\n        int n = A.size();\\n        vector<int> dp(n);\\n        dp[0] = A[0];\\n        for(int i = 1; i < n; i++) {\\n            int mx = A[i];\\n            int curr = INT_MIN;\\n            for(int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                mx = max(mx, A[i - j + 1]);\\n                if(i - j + 1 == 0)\\n                    curr = max(curr, j * mx);\\n                else\\n                    curr = max(curr, dp[i - j] + j * mx);\\n            }\\n            dp[i] = curr;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957717,
                "title": "python-91-42-faster-dp-memo-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            return maxAns\\n        n=len(arr)\\n        return solve(0)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n) + O(n)\\nclass Solution2:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            dp[ind]=maxAns\\n            return dp[ind]\\n        n=len(arr)\\n        dp=[-1]*n\\n        return solve(0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+dp[j+1]\\n                maxAns=max(maxAns,s)An upvotew will be encouraging\\n            dp[ind]=maxAns        \\n        return dp[0]\\n```\\n**An upvotew will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            return maxAns\\n        n=len(arr)\\n        return solve(0)\\n\\n#Memoization (Top-Down)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n) + O(n)\\nclass Solution2:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        def solve(ind):\\n            if ind==n:\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+solve(j+1)\\n                maxAns=max(maxAns,s)\\n            dp[ind]=maxAns\\n            return dp[ind]\\n        n=len(arr)\\n        dp=[-1]*n\\n        return solve(0)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n*k)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            l=0\\n            maxi=-maxsize\\n            maxAns=-maxsize\\n            for j in range(ind,min(n,ind+k)):\\n                l+=1\\n                maxi=max(maxi,arr[j])\\n                s=maxi*l+dp[j+1]\\n                maxAns=max(maxAns,s)An upvotew will be encouraging\\n            dp[ind]=maxAns        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422938,
                "title": "c-90-fast-dp-memoization-tabulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int k, int i, vector<int> &DP){\\n        if(i >= arr.size()) return 0;\\n        if(DP[i] != -1) return DP[i];\\n\\n        int maxi = -1, ans = -1;\\n        for(int j=i; j < arr.size() && j < i + k; j++){\\n            maxi = max(maxi, arr[j]);\\n            int len = j - i + 1;\\n\\n            ans = max(ans, len*maxi + solve(arr, k, j+1, DP));\\n        }\\n\\n        return DP[i] = ans;\\n    }\\n\\n    int solveTab(vector<int>& arr, int k){\\n        vector<int> DP(arr.size()+1, 0);\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int maxi = -1, ans = -1;\\n            for(int j=i; j < arr.size() && j < i + k; j++){\\n                maxi = max(maxi, arr[j]);\\n                int len = j - i + 1;\\n\\n                ans = max(ans, len*maxi + DP[j+1]);\\n            }\\n\\n            DP[i] = ans;\\n        }\\n\\n        return DP[0];\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        // vector<int> DP(arr.size(), -1);\\n        // return solve(arr, k, 0, DP);\\n\\n        return solveTab(arr, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, int k, int i, vector<int> &DP){\\n        if(i >= arr.size()) return 0;\\n        if(DP[i] != -1) return DP[i];\\n\\n        int maxi = -1, ans = -1;\\n        for(int j=i; j < arr.size() && j < i + k; j++){\\n            maxi = max(maxi, arr[j]);\\n            int len = j - i + 1;\\n\\n            ans = max(ans, len*maxi + solve(arr, k, j+1, DP));\\n        }\\n\\n        return DP[i] = ans;\\n    }\\n\\n    int solveTab(vector<int>& arr, int k){\\n        vector<int> DP(arr.size()+1, 0);\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int maxi = -1, ans = -1;\\n            for(int j=i; j < arr.size() && j < i + k; j++){\\n                maxi = max(maxi, arr[j]);\\n                int len = j - i + 1;\\n\\n                ans = max(ans, len*maxi + DP[j+1]);\\n            }\\n\\n            DP[i] = ans;\\n        }\\n\\n        return DP[0];\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        // vector<int> DP(arr.size(), -1);\\n        // return solve(arr, k, 0, DP);\\n\\n        return solveTab(arr, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419083,
                "title": "c-dp-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int dp[n];\\n        int maxOfThree = arr[0];\\n\\n        for(int i = 0; i < k; i++)\\n        {\\n            maxOfThree = max(arr[i], maxOfThree);\\n            dp[i] = (maxOfThree*(i+1));\\n        }\\n        for(int i = k; i < n; i++)\\n        {\\n            maxOfThree = arr[i];\\n            dp[i] = maxOfThree + dp[i-1];\\n\\n            for(int j = i-1; j > i-k; j--)\\n            {\\n                maxOfThree = max(maxOfThree,arr[j]); \\n                dp[i] = max(dp[i], dp[j-1] + (i-j+1)*maxOfThree);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int dp[n];\\n        int maxOfThree = arr[0];\\n\\n        for(int i = 0; i < k; i++)\\n        {\\n            maxOfThree = max(arr[i], maxOfThree);\\n            dp[i] = (maxOfThree*(i+1));\\n        }\\n        for(int i = k; i < n; i++)\\n        {\\n            maxOfThree = arr[i];\\n            dp[i] = maxOfThree + dp[i-1];\\n\\n            for(int j = i-1; j > i-k; j--)\\n            {\\n                maxOfThree = max(maxOfThree,arr[j]); \\n                dp[i] = max(dp[i], dp[j-1] + (i-j+1)*maxOfThree);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318861,
                "title": "c-dp-memoization-tabulation",
                "content": "Here is my c++ code for this problem.\\n\\n# Memoization\\n# Complexity\\n- Time complexity:$$O(n*k)$$\\n\\n- Space complexity:$$O(n)+O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, int n, vector<int>&dp, vector<int>&arr){\\n        if(i==arr.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi=INT_MIN, ans=INT_MIN, l=0;\\n        for(int j=i; j<min(n, k+i); j++){\\n            l++;\\n            maxi=max(maxi, arr[j]);\\n            int cnt=l*maxi+f(j+1, k, n, dp, arr);\\n            ans=max(ans, cnt);\\n        }\\n        return dp[i]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n, -1);\\n        return f(0, k, n, dp, arr);\\n    }\\n};\\n```\\n# Tabulation\\n# Complexity\\n- Time complexity:$$O(n*k)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            int ans=INT_MIN, maxi=INT_MIN, l=0;\\n            for(int j=i; j<min(n, i+k); j++){\\n                l++;\\n                maxi=max(maxi, arr[j]);\\n                int cnt=l*maxi+dp[j+1];\\n                ans=max(ans, cnt);\\n            }\\n            dp[i]=ans;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int k, int n, vector<int>&dp, vector<int>&arr){\\n        if(i==arr.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi=INT_MIN, ans=INT_MIN, l=0;\\n        for(int j=i; j<min(n, k+i); j++){\\n            l++;\\n            maxi=max(maxi, arr[j]);\\n            int cnt=l*maxi+f(j+1, k, n, dp, arr);\\n            ans=max(ans, cnt);\\n        }\\n        return dp[i]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n, -1);\\n        return f(0, k, n, dp, arr);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<int>dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            int ans=INT_MIN, maxi=INT_MIN, l=0;\\n            for(int j=i; j<min(n, i+k); j++){\\n                l++;\\n                maxi=max(maxi, arr[j]);\\n                int cnt=l*maxi+dp[j+1];\\n                ans=max(ans, cnt);\\n            }\\n            dp[i]=ans;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901589,
                "title": "python-easy-and-beautiful-dfs-cache",
                "content": "```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        @cache\\n        def dfs(i):\\n            if i == len(arr):\\n                return 0\\n\\n            m = 0\\n            v = arr[i]\\n\\n            for j in range(i, min(i + k, len(arr))):\\n                v = max(v, arr[j])   \\n                n = j - i + 1\\n                m = max(m, dfs(j + 1) + v*n)\\n\\n            return m\\n\\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        \\n        @cache\\n        def dfs(i):\\n            if i == len(arr):\\n                return 0\\n\\n            m = 0\\n            v = arr[i]\\n\\n            for j in range(i, min(i + k, len(arr))):\\n                v = max(v, arr[j])   \\n                n = j - i + 1\\n                m = max(m, dfs(j + 1) + v*n)\\n\\n            return m\\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642654,
                "title": "easy-cpp-solution-based-on-matrix-chain-multiplication-approach",
                "content": "**Recursive approach (gives TLE):**\\n```\\n\\tint solve(vector<int>&arr,int i,int j,int k){\\n        if(i>j)return 0;\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        return solve(arr,0,n-1,k);\\n    }\\n```\\n\\n**Memoized approach (Accepted):**\\n```\\n\\tint solve(vector<int>&arr,int i,int j,int k,vector<vector<int>>&memo){\\n        if(i>j)return 0;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k,memo);\\n            maxans=max(maxans,sum);\\n        }\\n        return memo[i][j]=maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<vector<int>>memo(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,k,memo);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint solve(vector<int>&arr,int i,int j,int k){\\n        if(i>j)return 0;\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        return solve(arr,0,n-1,k);\\n    }\\n```\n```\\n\\tint solve(vector<int>&arr,int i,int j,int k,vector<vector<int>>&memo){\\n        if(i>j)return 0;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int maxans=0;\\n        for(int p=i;p<=min(j,i+k-1);p++){\\n            int maxi=INT_MIN;\\n            for(int q=i;q<=p;q++)maxi=max(maxi,arr[q]);\\n            int sum=(maxi*(p-i+1))+solve(arr,p+1,j,k,memo);\\n            maxans=max(maxans,sum);\\n        }\\n        return memo[i][j]=maxans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<vector<int>>memo(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,k,memo);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515946,
                "title": "best-solution-easy-approch-from-scratch",
                "content": "# Memoisation :\\n```\\nclass Solution:\\n    def f(self,ind,arr,n,k,dp):\\n        if ind==n:\\n            return 0\\n        if dp[ind]!=-1:\\n            return dp[ind]\\n        maxi=float(\"-inf\")\\n        length=0\\n        maxans=float(\"-inf\")\\n        for j in range(ind,min(n,ind+k)):       #j for partition\\n            length+=1\\n            maxi=max(maxi,arr[j])\\n            summ=length*maxi + self.f(j+1,arr,n,k,dp)\\n            maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[ind]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1 for i in range(n)]\\n        return self.f(0,arr,n,k,dp)\\n```\\n\\n# Tabulation : Accepted\\n```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[0]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            maxi=float(\"-inf\")\\n            length=0\\n            maxans=float(\"-inf\")\\n            for j in range(ind,min(n,ind+k)):       #j for partition\\n                length+=1\\n                maxi=max(maxi,arr[j])\\n                summ=length*maxi + dp[j+1]\\n                maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[0]\\n```\\n\\n# Upvote if you liked",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,ind,arr,n,k,dp):\\n        if ind==n:\\n            return 0\\n        if dp[ind]!=-1:\\n            return dp[ind]\\n        maxi=float(\"-inf\")\\n        length=0\\n        maxans=float(\"-inf\")\\n        for j in range(ind,min(n,ind+k)):       #j for partition\\n            length+=1\\n            maxi=max(maxi,arr[j])\\n            summ=length*maxi + self.f(j+1,arr,n,k,dp)\\n            maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[ind]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[-1 for i in range(n)]\\n        return self.f(0,arr,n,k,dp)\\n```\n```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        dp=[0]*(n+1)\\n        dp[n]=0\\n        for ind in range(n-1,-1,-1):\\n            maxi=float(\"-inf\")\\n            length=0\\n            maxans=float(\"-inf\")\\n            for j in range(ind,min(n,ind+k)):       #j for partition\\n                length+=1\\n                maxi=max(maxi,arr[j])\\n                summ=length*maxi + dp[j+1]\\n                maxans=max(maxans,summ)\\n            dp[ind]=maxans\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423344,
                "title": "memoization-tabulation-front-partition-dp-java",
                "content": "1. Memoization\\nTn : O(n^2)\\nSn : O(n) + O(n)\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N];\\n        for(int i=0;i<N;i++){\\n            dp[i] = -1;\\n        }\\n        return partitionsum(0, N ,arr,k,dp);\\n    }\\n    int partitionsum(int ind, int N, int []arr,int k,int[]dp){\\n        if(ind == N){\\n            return 0;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int maxi = -(int)1e7;\\n        int len=0;\\n        int maxSum = -(int)1e7;\\n        for(int j=ind;j<Math.min(N, ind+k);j++){\\n            len++;\\n            maxi = Math.max(arr[j],maxi);\\n            int sum = (len*maxi) + partitionsum(j+1,N,arr,k,dp);\\n            maxSum = Math.max(sum,maxSum);\\n        }\\n        dp[ind] = maxSum;\\n        return dp[ind];\\n    }\\n}\\n```\\n2. Tabulation\\nTn : O(n^2)\\nSn:O(n)\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N+1];\\n        for(int i=0;i<N+1;i++){\\n            dp[i] = 0;\\n        }\\n        for(int ind = N-1;ind>=0;ind--){\\n            int maxi = -(int)1e7;\\n            int len=0;\\n            int maxSum = -(int)1e7;\\n            for(int j=ind;j<Math.min(N, ind+k);j++){\\n                len++;\\n                maxi = Math.max(arr[j],maxi);\\n                int sum = (len*maxi) + dp[j+1];\\n                maxSum = Math.max(sum,maxSum);\\n            }\\n            dp[ind] = maxSum;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N];\\n        for(int i=0;i<N;i++){\\n            dp[i] = -1;\\n        }\\n        return partitionsum(0, N ,arr,k,dp);\\n    }\\n    int partitionsum(int ind, int N, int []arr,int k,int[]dp){\\n        if(ind == N){\\n            return 0;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int maxi = -(int)1e7;\\n        int len=0;\\n        int maxSum = -(int)1e7;\\n        for(int j=ind;j<Math.min(N, ind+k);j++){\\n            len++;\\n            maxi = Math.max(arr[j],maxi);\\n            int sum = (len*maxi) + partitionsum(j+1,N,arr,k,dp);\\n            maxSum = Math.max(sum,maxSum);\\n        }\\n        dp[ind] = maxSum;\\n        return dp[ind];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int N = arr.length;\\n        int []dp =new int[N+1];\\n        for(int i=0;i<N+1;i++){\\n            dp[i] = 0;\\n        }\\n        for(int ind = N-1;ind>=0;ind--){\\n            int maxi = -(int)1e7;\\n            int len=0;\\n            int maxSum = -(int)1e7;\\n            for(int j=ind;j<Math.min(N, ind+k);j++){\\n                len++;\\n                maxi = Math.max(arr[j],maxi);\\n                int sum = (len*maxi) + dp[j+1];\\n                maxSum = Math.max(sum,maxSum);\\n            }\\n            dp[ind] = maxSum;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324223,
                "title": "simple-c-memoization-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> dp;\\n    int fun(int idx,vector<int>& arr,int k){\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int m = -1, sum = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            if(i+idx >= arr.size())\\n                continue;\\n            \\n            m = max(m,arr[i+idx]);\\n            sum = max(sum, (m*(i+1)) + fun(idx+i+1,arr,k));\\n        }\\n        \\n        return dp[idx] = sum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        dp = vector<int> (arr.size()+1,-1);\\n        return fun(0,arr,k);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> dp;\\n    int fun(int idx,vector<int>& arr,int k){\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int m = -1, sum = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            if(i+idx >= arr.size())\\n                continue;\\n            \\n            m = max(m,arr[i+idx]);\\n            sum = max(sum, (m*(i+1)) + fun(idx+i+1,arr,k));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2226191,
                "title": "c-well-explained-recursion-memo-mcm-variation",
                "content": "so here we want to partition array in subarrays having size not more than k , therefore as we want to check for all subarrays having size 1,2,3.......k => this means that we will have to explore all paths through recursion , and as we have to partition , then our mind should automatically think of MCM pattern .\\n\\nBASE CASE : \\nas we start from 0th index therefore when we will go out of array , then return 0;\\n ```\\n if(index>=n)\\n            return 0;\\n```\\n\\t\\t\\t\\nRECURRENCE RELATION:\\n\\nso as the subarray \\'s sum will be its ( max element * length of subarray ) , therefore we will keep a track of length , maxElement of subarray , and our ans , which will be total sum of the array after partionting .\\n\\nnow we will see from where should we start our for loop , as we can have a subarray of size 1 , therefore we will start at index . Now as we know that we cant have a subrray size of more than k , therefore the loop will run till the minimum of index+k and n (size. of arr) , so that we check if it doesnt go out of bound .\\n\\n```\\n int len=0;\\n        int maxElement=INT_MIN;\\n        int ans=INT_MIN;\\n        \\n        for(int j=index ; j<min(n,index+k)  ;j++){\\n            len++;\\n            maxElement=max(maxElement,arr[j]);\\n            \\n            int sum=len*maxElement+solve(arr,k,j+1,n);\\n            \\n            ans=max(ans,sum);\\n            \\n        }\\n        \\n        return ans;\\n```\\nand we will update the length , maxelement , and for every value of j , at last we will compare the sum of the whole array after partitioning , with our answer\\n\\n\\nTIME COMPLEXITY: exponential \\nSPACE COMPLEXITY: O(N)   =>auxillary stack space  \\n\\nafter memoization:\\nTIME COMPLEXITY:  O(N) * O(K)\\n```\\nSPACE COMPLEXITY: O(N)      +        O(N)\\n                |                         |\\n               ^                        ^\\n        1D DP ARRAY \\t  AUXILLARY STACK SPACE\\n\\t\\t\\t\\t\\t\\t\\n```\\n\\n\\nMEMOIZED CODE:\\n```\\nclass Solution {\\npublic:\\n     int t[501];\\n    int solve(vector<int>& arr, int k,int index,int n){\\n        if(index>=n)\\n            return 0;\\n        \\n        int len=0;\\n        int maxElement=INT_MIN;\\n        int ans=INT_MIN;\\n        \\n        if(t[index]!=-1)\\n            return t[index];\\n        for(int j=index ; j<min(n,index+k)  ;j++){\\n            len++;\\n            maxElement=max(maxElement,arr[j]);\\n            \\n            int sum=len*maxElement+solve(arr,k,j+1,n);\\n            \\n            ans=max(ans,sum);\\n            \\n        }\\n        \\n        return t[index]=ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        memset(t,-1,sizeof(t));\\n        return solve(arr,k,0,n);\\n    }\\n};\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n if(index>=n)\\n            return 0;\\n```\n```\\n int len=0;\\n        int maxElement=INT_MIN;\\n        int ans=INT_MIN;\\n        \\n        for(int j=index ; j<min(n,index+k)  ;j++){\\n            len++;\\n            maxElement=max(maxElement,arr[j]);\\n            \\n            int sum=len*maxElement+solve(arr,k,j+1,n);\\n            \\n            ans=max(ans,sum);\\n            \\n        }\\n        \\n        return ans;\\n```\n```\\nSPACE COMPLEXITY: O(N)      +        O(N)\\n                |                         |\\n               ^                        ^\\n        1D DP ARRAY \\t  AUXILLARY STACK SPACE\\n\\t\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2184421,
                "title": "java-recursive-memoization-tabulation",
                "content": "**Recursive Solution**\\n\\n```\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            return f(num, k, 0, n);\\n        }\\n        public int f (int[] num, int k, int i, int n) {\\n            if (i == n)\\n                return 0;\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return maxSum;\\n        }\\n    }\\n```\\n\\nTime Complexity : Exponential\\nSpace Complexity : O(N) (auxilary stack space)\\n\\n**Memoization (Top-down DP)**\\n\\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n];\\n            Arrays.fill(dp, -1);\\n            return f(num, k, 0, n, dp);\\n        }\\n        public int f (int[] num, int k, int i, int n, int[] dp) {\\n            if (i == n)\\n                return 0;\\n            if (dp[i] != -1)\\n                return dp[i];\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n, dp);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return dp[i] = maxSum;\\n        }\\n    }\\n```\\n\\nTime Complexity : O(N + k)\\nSpace Complexity : O(N) + O(N) (auxilary stack space)\\n\\n**Tabulation (Bottom-up DP)**\\n\\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n + 1];\\n            for (int i = n - 1; i >= 0; i--) {\\n                int maxSum = Integer.MIN_VALUE;\\n                int len = 0;\\n                int maxi = Integer.MIN_VALUE;\\n                for (int j = i; j < Math.min(n, i + k); j++) {\\n                    len++;\\n                    maxi = Math.max(maxi, num[j]);\\n                    int sum = (len * maxi) + dp[j + 1];\\n                    maxSum = Math.max(maxSum, sum);\\n                }\\n                dp[i] = maxSum;\\n            }\\n            return dp[0];\\n        }\\n    }\\n```\\n\\nTime Complexity : O(N + k)\\nSpace Complexity : O(N)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            return f(num, k, 0, n);\\n        }\\n        public int f (int[] num, int k, int i, int n) {\\n            if (i == n)\\n                return 0;\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return maxSum;\\n        }\\n    }\\n```\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n];\\n            Arrays.fill(dp, -1);\\n            return f(num, k, 0, n, dp);\\n        }\\n        public int f (int[] num, int k, int i, int n, int[] dp) {\\n            if (i == n)\\n                return 0;\\n            if (dp[i] != -1)\\n                return dp[i];\\n            int maxSum = Integer.MIN_VALUE;\\n            int len = 0;\\n            int maxi = Integer.MIN_VALUE;\\n            for (int j = i; j < Math.min(n, i + k); j++) {\\n                len++;\\n                maxi = Math.max(maxi, num[j]);\\n                int sum = (len * maxi) + f(num, k, j + 1, n, dp);\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n            return dp[i] = maxSum;\\n        }\\n    }\\n```\n```\\n\\n    class Solution {\\n        public int maxSumAfterPartitioning (int num[], int k) {\\n            int n = num.length;\\n            int[] dp = new int[n + 1];\\n            for (int i = n - 1; i >= 0; i--) {\\n                int maxSum = Integer.MIN_VALUE;\\n                int len = 0;\\n                int maxi = Integer.MIN_VALUE;\\n                for (int j = i; j < Math.min(n, i + k); j++) {\\n                    len++;\\n                    maxi = Math.max(maxi, num[j]);\\n                    int sum = (len * maxi) + dp[j + 1];\\n                    maxSum = Math.max(maxSum, sum);\\n                }\\n                dp[i] = maxSum;\\n            }\\n            return dp[0];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105488,
                "title": "c-o-n-k-bottom-up-top-down",
                "content": "recursion + memoization\\n```\\nclass Solution {\\nprivate:\\n    int findMaxSum(vector<int>& arr, int n, int idx, int k, vector<int>& dp){\\n        if(idx >= n)\\n            return 0;\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int sum = 0, maxTillNow = 0, len = 0;\\n        for(int i = idx; i < min(n, idx + k); ++i){\\n            ++len;\\n            maxTillNow = max(maxTillNow, arr[i]);\\n            int cost = maxTillNow * len + findMaxSum(arr, n, i + 1, k, dp);\\n            \\n            sum = max(sum, cost);\\n        }\\n        \\n        return dp[idx] = sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int > dp(n + 1, -1);\\n        int maxSum = findMaxSum(arr, n, 0, k, dp);\\n        \\n        return maxSum;\\n    }\\n};\\n```\\n\\njust a shuttle change in the recursive code and you are able to do tabulation dp\\nand it will also reduces the auxilary stack space.\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int> dp(n + 1, 0);\\n        for(int idx = n - 1; idx >= 0; --idx){\\n            int len = 0;\\n            int maxTillNow = 0;\\n            \\n            int sum = 0;\\n            for(int j = idx; j < min(n, idx + k); ++j){\\n                ++len;\\n                maxTillNow = max(maxTillNow, arr[j]);\\n                \\n                int cost = len * maxTillNow + dp[j + 1];\\n                sum = max(sum, cost);\\n            }\\n            \\n            dp[idx] = sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\nupvote if you like :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int findMaxSum(vector<int>& arr, int n, int idx, int k, vector<int>& dp){\\n        if(idx >= n)\\n            return 0;\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        int sum = 0, maxTillNow = 0, len = 0;\\n        for(int i = idx; i < min(n, idx + k); ++i){\\n            ++len;\\n            maxTillNow = max(maxTillNow, arr[i]);\\n            int cost = maxTillNow * len + findMaxSum(arr, n, i + 1, k, dp);\\n            \\n            sum = max(sum, cost);\\n        }\\n        \\n        return dp[idx] = sum;\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int > dp(n + 1, -1);\\n        int maxSum = findMaxSum(arr, n, 0, k, dp);\\n        \\n        return maxSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        vector<int> dp(n + 1, 0);\\n        for(int idx = n - 1; idx >= 0; --idx){\\n            int len = 0;\\n            int maxTillNow = 0;\\n            \\n            int sum = 0;\\n            for(int j = idx; j < min(n, idx + k); ++j){\\n                ++len;\\n                maxTillNow = max(maxTillNow, arr[j]);\\n                \\n                int cost = len * maxTillNow + dp[j + 1];\\n                sum = max(sum, cost);\\n            }\\n            \\n            dp[idx] = sum;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041761,
                "title": "python-sol-well-explained-easy-recursion-memo",
                "content": "# EXPLANATION\\n\\n\\n```\\nWe will try to make every unique pairs of subarrays possible\\n\\nWe can se we have a choice to either continue the subarray or create new , this gives the idea\\nof DP ( multiple recursions are happending)\\n\\nNow dp needs recursion and memoization\\n\\nRecursion requires recursive cases and base case\\n\\nRECURSIVE CASES\\n\\nFor every index we have two choices:\\n1. Continue the subarray \\n2. Break the subarray and start a new one\\n\\nfor 1st case we can continue if and only if size of subarray is less than k\\n\\nBASE CASE\\n\\nWhen index == len(arr) : we return max in subarray * size of subarray\\n\\nMEMOIZATION\\nNow all we need to do is to apply DP memoization\\nwe memoize the parameters which are variable (changing) \\n```\\n\\n# CODE\\n\\n```\\nclass Solution:\\n    def recursion(self,idx,arr,n,maxx,size,k):\\n        if idx == n:\\n            return maxx * size  \\n        if (idx,size,maxx) in self.dp: return self.dp[(idx,size,maxx)]\\n        ch1 = self.recursion(idx+1,arr,n,max(maxx,arr[idx]),size+1,k) if size < k else 0\\n        ch2 = self.recursion(idx+1,arr,n,arr[idx],1,k) + maxx*size\\n        best = ch1 if ch1 > ch2 else ch2\\n        self.dp[(idx,size,maxx)] = best\\n        return best\\n        \\n        \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # we will try partitioning in every way possible\\n        self.dp = {}\\n        return self.recursion(1,arr,len(arr),arr[0],1,k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nWe will try to make every unique pairs of subarrays possible\\n\\nWe can se we have a choice to either continue the subarray or create new , this gives the idea\\nof DP ( multiple recursions are happending)\\n\\nNow dp needs recursion and memoization\\n\\nRecursion requires recursive cases and base case\\n\\nRECURSIVE CASES\\n\\nFor every index we have two choices:\\n1. Continue the subarray \\n2. Break the subarray and start a new one\\n\\nfor 1st case we can continue if and only if size of subarray is less than k\\n\\nBASE CASE\\n\\nWhen index == len(arr) : we return max in subarray * size of subarray\\n\\nMEMOIZATION\\nNow all we need to do is to apply DP memoization\\nwe memoize the parameters which are variable (changing) \\n```\n```\\nclass Solution:\\n    def recursion(self,idx,arr,n,maxx,size,k):\\n        if idx == n:\\n            return maxx * size  \\n        if (idx,size,maxx) in self.dp: return self.dp[(idx,size,maxx)]\\n        ch1 = self.recursion(idx+1,arr,n,max(maxx,arr[idx]),size+1,k) if size < k else 0\\n        ch2 = self.recursion(idx+1,arr,n,arr[idx],1,k) + maxx*size\\n        best = ch1 if ch1 > ch2 else ch2\\n        self.dp[(idx,size,maxx)] = best\\n        return best\\n        \\n        \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # we will try partitioning in every way possible\\n        self.dp = {}\\n        return self.recursion(1,arr,len(arr),arr[0],1,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919540,
                "title": "c-recursive-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&arr,int idx,vector<int>&dp,int k){\\n        if(idx==arr.size())\\n            return 0;\\n        else if(dp[idx]!=0)\\n            return dp[idx];\\n        else{\\n            int res=-1;\\n            for(int i=idx;i<arr.size()&&i<idx+k;i++){\\n                res=max(res,arr[i]);\\n                if(i-idx+1<=k){\\n                    dp[idx]=max(dp[idx],res*(i-idx+1)+maxsum(arr,i+1,dp,k));\\n                }\\n            }\\n            return dp[idx];\\n        }\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n        int n=arr.size();\\n        vector<int> dp(n,0);\\n        int sum=maxsum(arr,0,dp,k);\\n        return sum;\\n\\t\\t\\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int maxsum(vector<int>&arr,int idx,vector<int>&dp,int k){\\n        if(idx==arr.size())\\n            return 0;\\n        else if(dp[idx]!=0)\\n            return dp[idx];\\n        else{\\n            int res=-1;\\n            for(int i=idx;i<arr.size()&&i<idx+k;i++){\\n                res=max(res,arr[i]);\\n                if(i-idx+1<=k){\\n                    dp[idx]=max(dp[idx],res*(i-idx+1)+maxsum(arr,i+1,dp,k));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1562342,
                "title": "c-easy-solution-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n      int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int ma  = arr[i];\\n            for(int j=i;j>(i-k) && j>=0;j--)\\n            {\\n                ma  = max(arr[j], ma);\\n                if(j-1>=0)\\n                dp[i] = max(dp[i], dp[j-1] + ma*(i-j+1));\\n                else\\n                {\\n                    dp[i] = max(dp[i], ma*(i-j+1));\\n                }\\n            } \\n        }\\n     \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n      int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int ma  = arr[i];\\n            for(int j=i;j>(i-k) && j>=0;j--)\\n            {\\n                ma  = max(arr[j], ma);\\n                if(j-1>=0)\\n                dp[i] = max(dp[i], dp[j-1] + ma*(i-j+1));\\n                else\\n                {\\n                    dp[i] = max(dp[i], ma*(i-j+1));\\n                }\\n            } \\n        }\\n     \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395821,
                "title": "c-solution-dp-approach",
                "content": "c++ solution || dp approach || \\n\\n```\\n\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n       int dp[n];\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i] = 0;\\n        }\\n        \\n        int maxi = arr[0];\\n        \\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);\\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxiSubA=arr[i];\\n            for(int j=1;j<=k;j++)\\n            {\\n                maxiSubA = max(maxiSubA,arr[i-j+1]);\\n                \\n                dp[i] = max(dp[i], dp[i-j] + maxiSubA*j);\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1];\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "c++ solution || dp approach || \\n\\n```\\n\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n       int dp[n];\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i] = 0;\\n        }\\n        \\n        int maxi = arr[0];\\n        \\n        for(int i=1;i<k;i++)\\n        {\\n            maxi = max(maxi,arr[i]);\\n            dp[i] = maxi*(i+1);\\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            int maxiSubA=arr[i];\\n            for(int j=1;j<=k;j++)\\n            {\\n                maxiSubA = max(maxiSubA,arr[i-j+1]);\\n                \\n                dp[i] = max(dp[i], dp[i-j] + maxiSubA*j);\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1];\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1395252,
                "title": "c-memoisation-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n//     DP(Tabulation)\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)        {\\n        int n=arr.size();\\n        vector<int> dp(n+1);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=arr[i-1];\\n            int val=0;\\n            for(int j=1;j<=k && i-j>=0;j++){\\n                val=max(val,arr[i-j]);\\n                dp[i]=max(dp[i],val*j+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\n//        Memoisation\\n// class Solution {\\n//     vector<int> memo;\\n//     int rec(vector<int>& arr,int k ,int i){\\n//         if(i<=0) return 0;\\n//         if(memo[i]!=-1) return memo[i];\\n//         int val=arr[i-1],ans=0;\\n//         for(int j=1;j<=k && i-j>=0;j++){\\n//             val=max(val,arr[i-j]);\\n//             ans=max(ans,val*j+rec(arr,k,i-j));\\n//         }\\n//         return memo[i]=ans;\\n//     }\\n// public:\\n//     int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n//         int n=arr.size();\\n//         memo.resize(n+1,-1);\\n//         return rec(arr,k,n);\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n//     DP(Tabulation)\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)        {\\n        int n=arr.size();\\n        vector<int> dp(n+1);\\n        for(int i=1;i<=n;i++){\\n            dp[i]=arr[i-1];\\n            int val=0;\\n            for(int j=1;j<=k && i-j>=0;j++){\\n                val=max(val,arr[i-j]);\\n                dp[i]=max(dp[i],val*j+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\n//        Memoisation\\n// class Solution {\\n//     vector<int> memo;\\n//     int rec(vector<int>& arr,int k ,int i){\\n//         if(i<=0) return 0;\\n//         if(memo[i]!=-1) return memo[i];\\n//         int val=arr[i-1],ans=0;\\n//         for(int j=1;j<=k && i-j>=0;j++){\\n//             val=max(val,arr[i-j]);\\n//             ans=max(ans,val*j+rec(arr,k,i-j));\\n//         }\\n//         return memo[i]=ans;\\n//     }\\n// public:\\n//     int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n//         int n=arr.size();\\n//         memo.resize(n+1,-1);\\n//         return rec(arr,k,n);\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266328,
                "title": "dp-mcm-pattern",
                "content": "This is just a variation of MCM problem and can be understood just by building recursion tree as we generally do for MCM type problems. \\nWe can further modify the recursive implementation as shown below...\\n\\nclass Solution {\\npublic:\\n    \\n    //mcm\\n    //Build partition tree first.\\n    //Implement using modified mcm.\\n    \\n    int getMax(vector<int> &arr,int start,int end){\\n        \\n        int mx = 0;\\n        for(int i=start;i<=end;i++){\\n            mx = max(mx,arr[i]);\\n        }\\n        \\n        return mx;\\n        \\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        int C[n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int mx = 0;\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if(i-j <= k)\\n                    mx = max(mx , C[j] + getMax(arr,j+1,i)*(i-j));\\n                \\n            }\\n            \\n            if(i+1 <= k)\\n                C[i] = max(mx , getMax(arr,0,i)*(i+1));\\n            else\\n                C[i] = mx;\\n\\n        }\\n        \\n        return C[n-1];\\n        \\n        \\n    }\\n};\\n\\n\\nYou can further optimize **getMax()** using your own methods - one can be using segment tree.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    //mcm\\n    //Build partition tree first.\\n    //Implement using modified mcm.\\n    \\n    int getMax(vector<int> &arr,int start,int end){\\n        \\n        int mx = 0;\\n        for(int i=start;i<=end;i++){\\n            mx = max(mx,arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1145019,
                "title": "java-easy-to-understand-dp-solution-beginner-concise-explanation",
                "content": "Refer to this solution for explanation (https://leetcode.com/problems/partition-array-for-maximum-sum/discuss/522001/Python3-with-explanation) and upvote the original post if you liked it\\n\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length,i,j;\\n        \\n        int dp[] = new int[n+1];\\n        \\n        for(i=1;i<=n;++i){\\n            int maxInWindow = 0, bestInWindow = 0;\\n            for(j=1;j<=k && i-j>=0;j++){\\n                maxInWindow = Math.max(maxInWindow, arr[i-j]);\\n                bestInWindow = Math.max(bestInWindow, dp[i-j]+maxInWindow*j);\\n            }\\n            dp[i] = bestInWindow;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length,i,j;\\n        \\n        int dp[] = new int[n+1];\\n        \\n        for(i=1;i<=n;++i){\\n            int maxInWindow = 0, bestInWindow = 0;\\n            for(j=1;j<=k && i-j>=0;j++){\\n                maxInWindow = Math.max(maxInWindow, arr[i-j]);\\n                bestInWindow = Math.max(bestInWindow, dp[i-j]+maxInWindow*j);\\n            }\\n            dp[i] = bestInWindow;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116387,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n + 1);\\n        for(int i = 1; i <= n; i++) {\\n            int max_value = arr[i - 1];\\n            for(int j = i; j > 0 && i - j + 1 <= k; j--) {\\n                max_value = max(max_value, arr[j - 1]);\\n                dp[i] = max(dp[i], dp[j - 1] + (i - j + 1) * max_value);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> dp(n + 1);\\n        for(int i = 1; i <= n; i++) {\\n            int max_value = arr[i - 1];\\n            for(int j = i; j > 0 && i - j + 1 <= k; j--) {\\n                max_value = max(max_value, arr[j - 1]);\\n                dp[i] = max(dp[i], dp[j - 1] + (i - j + 1) * max_value);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115228,
                "title": "2-simple-and-intuitive-java-solution-with-explanation",
                "content": "\\t/*\\n\\t   approach 1 : \\n\\t\\t --> we have 2 divide array into different subarrays.\\n\\t\\t --> we will use 2 pointer techinque : l,r. l represents index of starting element and r represents ending index for a particular subarray\\n\\t\\t --> we can make subarrays haveing elements upto k\\n\\t\\t --> so if we have less than k elements, we have 2 choices:\\n\\t\\t\\t --> either to close current subarray or to continue adding elements to it\\n\\t\\t\\t --> if we  choose to close, we will find sum for current subarry( # of elements * max value) and start a new subarray : f(r+1,r+1)\\n\\t\\t\\t --> if we want to continue adding elements we goto : f(l,r+1).\\n\\t\\t--> if we have exactly k elements, we need to create a new subarray : l=r+1,r=r+1.\\n\\t */\\n\\t class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t return helper(arr,0,0,k);\\n\\t\\t }\\n\\t\\t private int helper(int [] arr,int l,int r,int k){\\n\\t\\t\\t if(r==arr.length)return 0;\\n\\t\\t\\t if(r-l+1<=k){\\n\\t\\t\\t\\t int max = 0;\\n\\t\\t\\t\\t for(int i=l;i<=r;i++)max = Math.max(max,arr[i]);\\n\\t\\t\\t\\t return Math.max((r-l+1)*max + helper(arr,r+1,r+1,k),helper(arr,l,r+1,k));\\n\\t\\t\\t }\\n\\t\\t\\t return helper(arr,r+1,r+1,k);\\n\\t\\t }\\n\\t }\\n\\t // memoization with time and space complexity : O(n^2)\\n\\t // instead of calculating max in btw l to r, we will pre calculate it and store it in max[].\\n\\t // So finding max Value in range l to r takes O(1) time.\\n\\t class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t int n = arr.length;\\n\\t\\t\\t int[][] max = new int[n][n];\\n\\t\\t\\t for(int l=0;l<n;l++){\\n\\t\\t\\t\\t max[l][l] = arr[l];\\n\\t\\t\\t\\t for(int r=l+1;r<n;r++)\\n\\t\\t\\t\\t\\t max[l][r] = Math.max(max[l][r-1],arr[r]);\\n\\t\\t\\t }\\n\\t\\t\\t int[][] dp = new int[n][n];\\n\\t\\t\\t for(int i=0;i<n;i++)\\n\\t\\t\\t\\t Arrays.fill(dp[i],-1);\\n\\t\\t\\t return helper(arr,0,0,k,dp,max);\\n\\t\\t }\\n\\t\\t private int helper(int [] arr,int l,int r,int k,int[][] dp,int[][] max){\\n\\t\\t\\t if(r==arr.length)return 0;\\n\\t\\t\\t if(dp[l][r]!=-1)return dp[l][r];\\n\\t\\t\\t if(r-l+1<=k){\\n\\t\\t\\t\\t int maxVal = max[l][r];\\n\\t\\t\\t\\t return dp[l][r] = Math.max((r-l+1)*maxVal + helper(arr,r+1,r+1,k,dp,max),helper(arr,l,r+1,k,dp,max));\\n\\t\\t\\t }\\n\\t\\t\\t return  dp[l][r] = helper(arr,r+1,r+1,k,dp,max);\\n\\t\\t }\\n\\t }\\n\\t // another faster approach with time complexity O(nk) and space complexity : O(n)\\n\\t /*\\n\\t   approach :\\n\\t\\t   --> let say our current subarray ends at index i. How many subarrays can be created such that it will end at index i?\\n\\t\\t   --> exactly k subarray are there.\\n\\t\\t   --> so for every i in range o to n-1, we will assume that our current subarray ends at index i.\\n\\t\\t   --> we will find all such possible subarray j = [i-k+1,i], where j is starting of subarray and i in ending of subarray.\\n\\t\\t   --> let say dp[i] stores maximum sum possible ending at arr[i].\\n\\t\\t   --> so we will find all possible answers for a subarray ending at i. and we take max of all to find maxinum sum ending at i.\\n\\t\\t   --> for a particular subarray starting at j and ending at i, we find max sum ending at (j-1) + # of elements in [j,i]* max element in (j,i).\\n\\t\\t   --> for a particular [j,i]. dp[i] = dp[j-1] + (i-j+1) * max in range(j,i).\\n\\n\\t */\\n\\t class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t int n = arr.length;\\n\\t\\t\\t int[] dp = new int[n];\\n\\t\\t\\t for(int i=0;i<n;i++){\\n\\t\\t\\t\\t int max = 0;\\n\\t\\t\\t\\t for(int j=i;j>=i-k+1 && j>=0;j--){\\n\\t\\t\\t\\t\\t max = Math.max(max,arr[j]);\\n\\t\\t\\t\\t\\t dp[i] = Math.max(dp[i],(i-j+1)*max + (j==0? 0 : dp[j-1]));\\n\\t\\t\\t\\t }   \\n\\t\\t\\t }\\n\\t\\t\\t return dp[n-1];\\n\\t\\t }\\n\\n\\t }",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t public int maxSumAfterPartitioning(int[] arr, int k) {\\n\\t\\t\\t return helper(arr,0,0,k);\\n\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 1083866,
                "title": "c-dp",
                "content": "```cpp\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int> dp(arr.size() + 1);\\n\\tfor (int i=1; i<=arr.size(); i++) {\\n\\t\\tfor (int j=i-1, m = 0; j >= i-k && j>=0; j--) {\\n\\t\\t\\tm = max(m, arr[j]);    \\n\\t\\t\\tdp[i] = max(dp[j] + m * (i-j), dp[i]);    \\n\\t\\t}\\n\\t}\\n\\treturn dp[arr.size()];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int> dp(arr.size() + 1);\\n\\tfor (int i=1; i<=arr.size(); i++) {\\n\\t\\tfor (int j=i-1, m = 0; j >= i-k && j>=0; j--) {\\n\\t\\t\\tm = max(m, arr[j]);    \\n\\t\\t\\tdp[i] = max(dp[j] + m * (i-j), dp[i]);    \\n\\t\\t}\\n\\t}\\n\\treturn dp[arr.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042173,
                "title": "detailed-dp-explanation-for-newbies",
                "content": "Given that we have an array `[1,2,3,4,5]` and `k = 3` \\nTo calculate `dp[4]` or `maxSum([1,2,3,4,5])`, we need to calculate max of `a,b,c`\\n```\\na = maxSum([1,2,3,4]) + maxSum([5])\\nb = maxSum([1,2,3]) + maxSum([4,5])\\nc = maxSum([1,2]) + maxSum([3,4,5])\\n\\n// we don\\'t consider d because max sub array length is 3 and [2,3,4,5] has length 4\\nd = maxSum([1,2,3,4,5]) = maxSum([1]) + maxSum([2,3,4,5])\\n\\n// and we have\\ndp[4] = max(a,b,c)\\n```\\n\\nNow in c, we have ` maxSum([3,4,5])` = `max(3,4,5) * 3`, since the length is less than or equal to k. Now we have\\n```\\na = maxSum([1,2,3,4]) + max(5)*1 = maxSum([1,2,3,4]) + 5\\nb = max(1,2,3)*3 +  max(4,5)*2 = 19\\nc = max(1,2)*2 + max(3,4,5)*3 = 19\\n```\\n\\nSimilarly, to calculate `maxSum([1,2,3,4])`  or `dp[3]` in a\\n```\\ne = maxSum([1,2,3]) +  maxSum([4]) = 13\\nf = maxSum([1,2]) + , maxSum([3,4]) = 12\\ng = maxSum([1] +  maxSum([2,3,4]) = 13\\n\\ndp[3] = max(e,f,g) = 13\\na = maxSum([1,2,3,4]) + 5 = dp[3] + 5 = 13 + 5 = 18\\n```\\n\\nFinally, `dp[4] = max(a,b,c) = max(18, 19, 19) = 19`",
                "solutionTags": [],
                "code": "```\\na = maxSum([1,2,3,4]) + maxSum([5])\\nb = maxSum([1,2,3]) + maxSum([4,5])\\nc = maxSum([1,2]) + maxSum([3,4,5])\\n\\n// we don\\'t consider d because max sub array length is 3 and [2,3,4,5] has length 4\\nd = maxSum([1,2,3,4,5]) = maxSum([1]) + maxSum([2,3,4,5])\\n\\n// and we have\\ndp[4] = max(a,b,c)\\n```\n```\\na = maxSum([1,2,3,4]) + max(5)*1 = maxSum([1,2,3,4]) + 5\\nb = max(1,2,3)*3 +  max(4,5)*2 = 19\\nc = max(1,2)*2 + max(3,4,5)*3 = 19\\n```\n```\\ne = maxSum([1,2,3]) +  maxSum([4]) = 13\\nf = maxSum([1,2]) + , maxSum([3,4]) = 12\\ng = maxSum([1] +  maxSum([2,3,4]) = 13\\n\\ndp[3] = max(e,f,g) = 13\\na = maxSum([1,2,3,4]) + 5 = dp[3] + 5 = 13 + 5 = 18\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 985086,
                "title": "java-dfs-memoization",
                "content": "At each index try all combinations of K starting from 1.\\n\\n```\\n\\nclass Solution {\\n    int[] dp;\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        dp = new int[A.length + 1];\\n        return helper(A, 0, K);\\n    }\\n    \\n    private int helper(int[] A, int idx, int K){\\n        if(idx == A.length) return 0;\\n        if(dp[idx] != 0) return dp[idx];\\n        \\n        int maxSum = 0, maxVal = 0;\\n        for(int j = idx, i = 1 ; j < A.length && i <= K ; j++, i++){\\n            maxVal = Math.max(maxVal , A[j]);\\n            maxSum = Math.max(maxSum, i * maxVal + helper(A, j + 1, K));\\n        }\\n        return dp[idx] = maxSum;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int[] dp;\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        dp = new int[A.length + 1];\\n        return helper(A, 0, K);\\n    }\\n    \\n    private int helper(int[] A, int idx, int K){\\n        if(idx == A.length) return 0;\\n        if(dp[idx] != 0) return dp[idx];\\n        \\n        int maxSum = 0, maxVal = 0;\\n        for(int j = idx, i = 1 ; j < A.length && i <= K ; j++, i++){\\n            maxVal = Math.max(maxVal , A[j]);\\n            maxSum = Math.max(maxSum, i * maxVal + helper(A, j + 1, K));\\n        }\\n        return dp[idx] = maxSum;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948233,
                "title": "better-indexing-than-the-highest-voted-answer",
                "content": "```js\\nconst maxSumAfterPartitioning = function(nums, K) {\\n  const n = nums.length;\\n  //  dp(i) = the max sum of the first i numbers.\\n  const dp = Array(n + 1);\\n  \\n  let sum = 0;\\n  for (let i = 0; i <= n; i += 1) {\\n    dp[i] = sum;\\n    sum += nums[i];\\n  }\\n  \\n  for (let i = 1; i <= n; i += 1) {\\n    let max = 0;\\n    // k is window size\\n    for (let k = 1; k <= K && i - k >= 0; k += 1) {\\n      max = Math.max(max, nums[i - k]);\\n      const sum = dp[i - k] + k * max;\\n      dp[i] = Math.max(sum, dp[i]);\\n    }\\n  }\\n  \\n  \\n  return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst maxSumAfterPartitioning = function(nums, K) {\\n  const n = nums.length;\\n  //  dp(i) = the max sum of the first i numbers.\\n  const dp = Array(n + 1);\\n  \\n  let sum = 0;\\n  for (let i = 0; i <= n; i += 1) {\\n    dp[i] = sum;\\n    sum += nums[i];\\n  }\\n  \\n  for (let i = 1; i <= n; i += 1) {\\n    let max = 0;\\n    // k is window size\\n    for (let k = 1; k <= K && i - k >= 0; k += 1) {\\n      max = Math.max(max, nums[i - k]);\\n      const sum = dp[i - k] + k * max;\\n      dp[i] = Math.max(sum, dp[i]);\\n    }\\n  }\\n  \\n  \\n  return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908765,
                "title": "java-solution-with-explanation-3ms-faster-than-98-of-submissions",
                "content": "since its asking maximum sum, we can think of using DP.\\n\\nwhat we can do is go bottom up.  we can make a separate array callsed dp of same size of arr.\\ndp[i] represent the maximum sum up to the index i;\\nif we get the value of dp[n-1] we will get the answer.\\n\\nalso we can write in general.\\ndp[i]= max(dp[i], dp[i- possible size limit i.e from 1 to k] + maxelement * size)\\n\\ncode can we written as \\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n    int n= arr.length;\\n        int[] dp = new int[n] ;\\n        dp[0]= arr[0] ;\\n        int maxvar=arr[0] ;\\n\\n        // divide the dp[i] calculation into 2 parts\\n        //1) from 0-(k-1) \\n        // 2) from k to (n-1) ;\\n        \\n        // part 1\\n        for(int i=0;i<k;i++)\\n        {\\n            maxvar= Math.max(maxvar,arr[i]) ;\\n            dp[i] =maxvar*(i+1) ;\\n            \\n        }\\n        \\n        // part 2\\n        for(int i=k;i<n;i++)\\n        {   \\n             maxvar= arr[i] ;\\n            for(int j=1; j<=k;j++)\\n            {\\n                maxvar= Math.max(maxvar, arr[i-j+1]) ;\\n                dp[i]= Math.max(dp[i],(dp[i-j]+ maxvar*j) ) ;\\n            }\\n        }\\n        return dp[n-1] ;\\n    }\\n}\\n```\\n\\nhope it helps.\\nkeep the streak.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n    int n= arr.length;\\n        int[] dp = new int[n] ;\\n        dp[0]= arr[0] ;\\n        int maxvar=arr[0] ;\\n\\n        // divide the dp[i] calculation into 2 parts\\n        //1) from 0-(k-1) \\n        // 2) from k to (n-1) ;\\n        \\n        // part 1\\n        for(int i=0;i<k;i++)\\n        {\\n            maxvar= Math.max(maxvar,arr[i]) ;\\n            dp[i] =maxvar*(i+1) ;\\n            \\n        }\\n        \\n        // part 2\\n        for(int i=k;i<n;i++)\\n        {   \\n             maxvar= arr[i] ;\\n            for(int j=1; j<=k;j++)\\n            {\\n                maxvar= Math.max(maxvar, arr[i-j+1]) ;\\n                dp[i]= Math.max(dp[i],(dp[i-j]+ maxvar*j) ) ;\\n            }\\n        }\\n        return dp[n-1] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891490,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int w = k+1;\\n        vector<int> dp(w);\\n        for(int i = 0; i<arr.size(); i++) {\\n            int curMax = 0;\\n            for(int j =1; j <= min(k, i+1); j++) {\\n                curMax = max(curMax, arr[i - j + 1]);\\n                dp[i%w] = max(dp[i%w], ((i >= k) ? dp[(i-j)%w] : 0) + curMax * j);\\n            }\\n        }\\n        return dp[(arr.size()-1) % w];\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int w = k+1;\\n        vector<int> dp(w);\\n        for(int i = 0; i<arr.size(); i++) {\\n            int curMax = 0;\\n            for(int j =1; j <= min(k, i+1); j++) {\\n                curMax = max(curMax, arr[i - j + 1]);\\n                dp[i%w] = max(dp[i%w], ((i >= k) ? dp[(i-j)%w] : 0) + curMax * j);\\n            }\\n        }\\n        return dp[(arr.size()-1) % w];\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832917,
                "title": "java-solution-with-comments-for-understanding",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n        int dp[]=new int[n]; //dp[i] represents max sum till i-th position\\n        int max=0;\\n        int i=0;\\n        //Fill the first k positions with max element till i-th position times number of elements\\n        for(;i<k&&i<n;i++){\\n            max=Math.max(max,arr[i]);\\n            dp[i]=max*(i+1);\\n        }\\n        //Start filling the rest of dp array\\n        for(;i<n;i++){\\n            max=0;\\n            int sum=0; //sum to keep max sum possible\\n            \\n            //j will iterate till i-k-1th element \\n            //For example if k=3 and i=4 then j will be 4,3,2\\n            //Every time new element is considered, \\n            //update max and make sum = maxelement*number of elements considered\\n            for(int j=i;j>i-k;j--){\\n                max=Math.max(max,arr[j]);\\n                sum=Math.max(sum,dp[j-1]+max*(i-j+1));\\n            }\\n            //update dp[i] with the max sum possible\\n            dp[i]=sum;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n=arr.length;\\n        int dp[]=new int[n]; //dp[i] represents max sum till i-th position\\n        int max=0;\\n        int i=0;\\n        //Fill the first k positions with max element till i-th position times number of elements\\n        for(;i<k&&i<n;i++){\\n            max=Math.max(max,arr[i]);\\n            dp[i]=max*(i+1);\\n        }\\n        //Start filling the rest of dp array\\n        for(;i<n;i++){\\n            max=0;\\n            int sum=0; //sum to keep max sum possible\\n            \\n            //j will iterate till i-k-1th element \\n            //For example if k=3 and i=4 then j will be 4,3,2\\n            //Every time new element is considered, \\n            //update max and make sum = maxelement*number of elements considered\\n            for(int j=i;j>i-k;j--){\\n                max=Math.max(max,arr[j]);\\n                sum=Math.max(sum,dp[j-1]+max*(i-j+1));\\n            }\\n            //update dp[i] with the max sum possible\\n            dp[i]=sum;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686778,
                "title": "c-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<int> dp(n+1, INT_MIN);\\n        int maxA = INT_MIN;\\n        for (int i = 1; i <= K; i++) {\\n            maxA = max(maxA, A[i - 1]);\\n            dp[i] = maxA * i;\\n        }\\n        for (int i = K + 1; i < n + 1; i++) {\\n            maxA = INT_MIN;\\n            for (int len = 1; len <= K; len++) {\\n                maxA = max(maxA, A[i - len]);\\n                dp[i] = max(dp[i], maxA * len + dp[i - len]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n/* \\ndp[n]: Partition Array for Maximum Sum from A[0], A[1], ... A[n-1].\\ndp[0] = 0\\ndp[1] = A[0]\\ndp[2] = max(A[1], A[0]) * 2\\n...\\ndp[K] = max(A[k-1], ..., A[0]) * K\\ndp[i] = max(A[i-1] + dp[i-1], max(A[i-1], A[i-2])*2 + dp[i-2], ..., max(A[i-1], ..., A[i-k])*k + dp[i-k])\\ndp[A.size()]\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        int n = A.size();\\n        vector<int> dp(n+1, INT_MIN);\\n        int maxA = INT_MIN;\\n        for (int i = 1; i <= K; i++) {\\n            maxA = max(maxA, A[i - 1]);\\n            dp[i] = maxA * i;\\n        }\\n        for (int i = K + 1; i < n + 1; i++) {\\n            maxA = INT_MIN;\\n            for (int len = 1; len <= K; len++) {\\n                maxA = max(maxA, A[i - len]);\\n                dp[i] = max(dp[i], maxA * len + dp[i - len]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n/* \\ndp[n]: Partition Array for Maximum Sum from A[0], A[1], ... A[n-1].\\ndp[0] = 0\\ndp[1] = A[0]\\ndp[2] = max(A[1], A[0]) * 2\\n...\\ndp[K] = max(A[k-1], ..., A[0]) * K\\ndp[i] = max(A[i-1] + dp[i-1], max(A[i-1], A[i-2])*2 + dp[i-2], ..., max(A[i-1], ..., A[i-k])*k + dp[i-k])\\ndp[A.size()]\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521629,
                "title": "c-memoization-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> memo(A.size()+1,-1);\\n        return maxSum(memo,A,K,0);\\n    }\\n    \\n    int maxSum(vector<int>& memo, vector<int>& A, int& K, int pos){\\n        if (pos >= A.size())return 0;\\n        if (memo[pos] != -1)return memo[pos];\\n        int range_max = A[pos], rightsum = 0;\\n        \\n        //For all possible sizes of subarray extending right from this point, get sum of the array plus\\n        //cumulative sum of values to the right of the array\\'s right bound.\\n        for (int i = pos; i < A.size() && i < pos+K; i++){\\n            if (A[i] > range_max){\\n                range_max = A[i];\\n            }\\n            rightsum = max(rightsum,range_max*(i-pos+1)+maxSum(memo,A,K,i+1));     //keep track of max observed sum\\n        }\\n        return memo[pos] = rightsum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> memo(A.size()+1,-1);\\n        return maxSum(memo,A,K,0);\\n    }\\n    \\n    int maxSum(vector<int>& memo, vector<int>& A, int& K, int pos){\\n        if (pos >= A.size())return 0;\\n        if (memo[pos] != -1)return memo[pos];\\n        int range_max = A[pos], rightsum = 0;\\n        \\n        //For all possible sizes of subarray extending right from this point, get sum of the array plus\\n        //cumulative sum of values to the right of the array\\'s right bound.\\n        for (int i = pos; i < A.size() && i < pos+K; i++){\\n            if (A[i] > range_max){\\n                range_max = A[i];\\n            }\\n            rightsum = max(rightsum,range_max*(i-pos+1)+maxSum(memo,A,K,i+1));     //keep track of max observed sum\\n        }\\n        return memo[pos] = rightsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372853,
                "title": "scala-solution-with-dynamic-programming",
                "content": "```\\n  /**\\n    * Use dynamic programming and use memoization to figure out max sum at A[i] as this sub problem will occur many times.\\n    * At each step we figure out if it is best to use a partition of 1, 2, ... k\\n    */\\n  object Solution {\\n    import scala.collection.mutable\\n    def maxSumAfterPartitioning(A: Array[Int], K: Int): Int = {\\n      val solutions: mutable.Map[Int, Int] = mutable.Map.empty[Int, Int]\\n\\n      def maxSumAfterPartitioning(index: Int): Int = {\\n        if (index >= A.length) 0\\n        else {\\n          solutions.getOrElse(index, {\\n            solutions(index) = Range(K, 0, -1)\\n              .map(K => {\\n                val items: Array[Int] = A.slice(index, index + K)\\n                (items.length * items.max) + maxSumAfterPartitioning(index + items.length)\\n              })\\n              .max\\n\\n            solutions(index)\\n          })\\n        }\\n      }\\n\\n      maxSumAfterPartitioning(0)\\n    }\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\n  /**\\n    * Use dynamic programming and use memoization to figure out max sum at A[i] as this sub problem will occur many times.\\n    * At each step we figure out if it is best to use a partition of 1, 2, ... k\\n    */\\n  object Solution {\\n    import scala.collection.mutable\\n    def maxSumAfterPartitioning(A: Array[Int], K: Int): Int = {\\n      val solutions: mutable.Map[Int, Int] = mutable.Map.empty[Int, Int]\\n\\n      def maxSumAfterPartitioning(index: Int): Int = {\\n        if (index >= A.length) 0\\n        else {\\n          solutions.getOrElse(index, {\\n            solutions(index) = Range(K, 0, -1)\\n              .map(K => {\\n                val items: Array[Int] = A.slice(index, index + K)\\n                (items.length * items.max) + maxSumAfterPartitioning(index + items.length)\\n              })\\n              .max\\n\\n            solutions(index)\\n          })\\n        }\\n      }\\n\\n      maxSumAfterPartitioning(0)\\n    }\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 344900,
                "title": "java-time-beat-95",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        dp[1] = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            int curMax = A[i];\\n            // j is the length of subarray that contains A[i]\\n            for (int j = 1; j <= K; j++) {\\n                int k = i - j + 1; // start index of subarray\\n                if (k < 0) break;\\n                curMax = Math.max(curMax, A[k]);\\n                dp[i + 1] = Math.max(dp[i + 1], j * curMax + dp[k]);\\n            }\\n        }\\n        return dp[A.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        dp[1] = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            int curMax = A[i];\\n            // j is the length of subarray that contains A[i]\\n            for (int j = 1; j <= K; j++) {\\n                int k = i - j + 1; // start index of subarray\\n                if (k < 0) break;\\n                curMax = Math.max(curMax, A[k]);\\n                dp[i + 1] = Math.max(dp[i + 1], j * curMax + dp[k]);\\n            }\\n        }\\n        return dp[A.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330464,
                "title": "dp-java-o-n-k-time-and-o-n-space",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        for(int i = A.length - 1; i >= 0; i --){\\n            int maxOne = A[i];\\n            dp[i] = A[i] + dp[i+1];\\n            for(int j = 1; j < K && i+j < A.length; j++){\\n                maxOne = Math.max(A[i+j], maxOne);\\n                dp[i] = Math.max(dp[i], maxOne*(j+1) + dp[i+j+1]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length + 1];\\n        for(int i = A.length - 1; i >= 0; i --){\\n            int maxOne = A[i];\\n            dp[i] = A[i] + dp[i+1];\\n            for(int j = 1; j < K && i+j < A.length; j++){\\n                maxOne = Math.max(A[i+j], maxOne);\\n                dp[i] = Math.max(dp[i], maxOne*(j+1) + dp[i+j+1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 296668,
                "title": "javascript-dp",
                "content": "```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    let l = A.length;\\n    let dp = new Array(l + 1).fill(0);\\n    for (let i = 1 ; i < l + 1; i++) {\\n        let m = Number.MIN_VALUE;\\n        for (let j = 1; j < Math.min(i, K) + 1; j++) {\\n            m = Math.max(m, A[i - j]);\\n            dp[i] = Math.max(dp[i], dp[i - j] + m * j);\\n        }\\n    }\\n    return dp[l];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumAfterPartitioning = function(A, K) {\\n    let l = A.length;\\n    let dp = new Array(l + 1).fill(0);\\n    for (let i = 1 ; i < l + 1; i++) {\\n        let m = Number.MIN_VALUE;\\n        for (let j = 1; j < Math.min(i, K) + 1; j++) {\\n            m = Math.max(m, A[i - j]);\\n            dp[i] = Math.max(dp[i], dp[i - j] + m * j);\\n        }\\n    }\\n    return dp[l];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 292674,
                "title": "c-super-simple-and-clean-8-line-solution-beats-100",
                "content": "```\\n\\tint maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size()+1, 0);\\n        for(int i=1;i<=A.size();i++) {\\n            int m=0;\\n            for(int j=i-1;j>=0&&j>=i-K;j--) {\\n                m=max(m, A[j]);\\n                dp[i]=max(dp[i], dp[j]+m*(i-j));\\n            }\\n        }\\n        return dp.back();\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tint maxSumAfterPartitioning(vector<int>& A, int K) {\\n        vector<int> dp(A.size()+1, 0);\\n        for(int i=1;i<=A.size();i++) {\\n            int m=0;\\n            for(int j=i-1;j>=0&&j>=i-K;j--) {\\n                m=max(m, A[j]);\\n                dp[i]=max(dp[i], dp[j]+m*(i-j));\\n            }\\n        }\\n        return dp.back();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 290917,
                "title": "easy-python-o-nk-2-dp-solution",
                "content": "Idea: dp[i] means the max sum after partition in index i\\nin each loop, `dp[i] = max(dp[i-1] + max(A[i-1:i]) * 1, dp[i-2] + max(A[i-2:i]) * 2, ..., dp[i-k] + max(A[i-k:i]) * k`\\nThen we get the solution.\\n\\n```python\\nclass Solution:\\n    # dp\\n    # Onk^2 time O n space\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        if len(A) == 0:\\n            return 0\\n        dp = [0 for _ in A]\\n        dp[0] = A[0]\\n        curMax = 0\\n        for i in range(1, len(A)):\\n            if i <= K-1:\\n                dp[i]= max(A[:i+1]) * (i+1)\\n            else:\\n                dp[i] = max(A[i-K+1:i+1])\\n                for j in range(1, K+1):\\n                    dp[i] = max(dp[i], dp[i-j] + max(A[i-j+1:i+1]) * j)\\n        return dp[len(A)-1]\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    # dp\\n    # Onk^2 time O n space\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        if len(A) == 0:\\n            return 0\\n        dp = [0 for _ in A]\\n        dp[0] = A[0]\\n        curMax = 0\\n        for i in range(1, len(A)):\\n            if i <= K-1:\\n                dp[i]= max(A[:i+1]) * (i+1)\\n            else:\\n                dp[i] = max(A[i-K+1:i+1])\\n                for j in range(1, K+1):\\n                    dp[i] = max(dp[i], dp[i-j] + max(A[i-j+1:i+1]) * j)\\n        return dp[len(A)-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 290880,
                "title": "python-memoization",
                "content": "*(It looks my solution is not better than others\\'. But just want to provide another way to analyze this problem.)*\\n\\nUse memoization to implement DP. `helper(i, j)` returns and **caches** the max result of the range [i, j).\\nIf the range [i, j) is shorter than or equal to K, replace all elements with the maximum.\\nIf the range [i, j) is longer than K, try all possible `newj` such that [i, newj) is not longer than K. Then return the maximum of `helper(i, newj) + helper(newj, j)` for all possible `newj`.\\n```\\nimport functools\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(i, j):\\n            # The helper finds the max result of the range [i, j)\\n            if j - i <= K:\\n                return (j - i) * max(A[i:j])\\n            return max(helper(i, newj) + helper(newj, j) for newj in range(i + 1, i + 1 + K))\\n        \\n        return helper(0, len(A))\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(i, j):\\n            # The helper finds the max result of the range [i, j)\\n            if j - i <= K:\\n                return (j - i) * max(A[i:j])\\n            return max(helper(i, newj) + helper(newj, j) for newj in range(i + 1, i + 1 + K))\\n        \\n        return helper(0, len(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290857,
                "title": "task-teamwork-dp",
                "content": "It turns out this problem was copied directly from the USACO Gold Round this year December. I would have not noticed if it were not for the test case being exactly the same. I went back to check on my old CP notes and it was there, verbatim. Here\\'s the original problem: http://usaco.org/current/data/sol_teamwork_gold_dec18.html. Here\\'s my solution.\\n\\n```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n\\t    for(int i = 1; i < A.length; i++) {\\n\\t\\t    int curr = A[i];\\n\\t\\t    for(int j = i; j >= 0 && (i + 1 - j) <= K; j--) {\\n\\t\\t\\t    curr = Math.max(curr, A[j]);\\n\\t\\t\\t    if(j == 0) {\\n                    dp[i] = Math.max(dp[i], curr*(i + 1 - j));\\n                }\\n\\t\\t\\t    else {\\n                    dp[i] = Math.max(dp[i], dp[j - 1] + curr*(i + 1 - j));\\n                }\\n\\t\\t    }\\n    \\t}\\n        return dp[A.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] A, int K) {\\n        int[] dp = new int[A.length];\\n        dp[0] = A[0];\\n\\t    for(int i = 1; i < A.length; i++) {\\n\\t\\t    int curr = A[i];\\n\\t\\t    for(int j = i; j >= 0 && (i + 1 - j) <= K; j--) {\\n\\t\\t\\t    curr = Math.max(curr, A[j]);\\n\\t\\t\\t    if(j == 0) {\\n                    dp[i] = Math.max(dp[i], curr*(i + 1 - j));\\n                }\\n\\t\\t\\t    else {\\n                    dp[i] = Math.max(dp[i], dp[j - 1] + curr*(i + 1 - j));\\n                }\\n\\t\\t    }\\n    \\t}\\n        return dp[A.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917776,
                "title": "intuition-very-similar-to-aditya-verma-mcm-question",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& arr, int i , int j , int kk,vector<vector<int> > &dp){\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        if(i > j){\\n            return 0;\\n        }\\n        if(i == j){\\n            return arr[i];\\n        }\\n        if(j - i + 1 == kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n        if(j - i + 1 < kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int k = i ; k < i+kk && k < j; k++){\\n            ans = max(ans,solve(arr,i,k,kk,dp) + solve(arr,k+1,j,kk,dp));\\n        }   \\n\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n\\n\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<vector<int> > dp(arr.size()+1, vector<int>(arr.size()+1,-1));\\n        int i = 0, j = arr.size() - 1;\\n        return solve(arr,i,j,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& arr, int i , int j , int kk,vector<vector<int> > &dp){\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        if(i > j){\\n            return 0;\\n        }\\n        if(i == j){\\n            return arr[i];\\n        }\\n        if(j - i + 1 == kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n        if(j - i + 1 < kk){\\n            int maxi = 0;\\n            for(int x = i ; x<=j ; x++){\\n                maxi = max(maxi,arr[x]);\\n            }\\n            return (j-i+1) * maxi;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int k = i ; k < i+kk && k < j; k++){\\n            ans = max(ans,solve(arr,i,k,kk,dp) + solve(arr,k+1,j,kk,dp));\\n        }   \\n\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n\\n\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<vector<int> > dp(arr.size()+1, vector<int>(arr.size()+1,-1));\\n        int i = 0, j = arr.size() - 1;\\n        return solve(arr,i,j,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916668,
                "title": "two-ways-partition-dp-front-row-partition-dp-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[510];\\n    // time Complexity = O(n*n*n*k) - Verdict - TLE\\n    // int solve(int i, int j,  vector<int> &arr, int t){\\n    //     if(i > j) return 0;\\n    //     if(dp[i][j] != -1) return dp[i][j];\\n    //     if(i == j) return arr[i];\\n    //     if(j - i + 1 <= t){\\n    //         int mx = INT_MIN;\\n    //         for(int x = i; x<=j; x++)mx = max(mx, arr[x]);\\n    //         return (j-i+1)*mx;\\n    //     }\\n    //     int ans = 0;\\n    //     for(int k = i; k<j; k++){\\n    //         ans = max(ans,  solve(i, k, arr, t) + solve(k+1, j, arr, t));\\n    //     }\\n    //     return dp[i][j] = ans;\\n    // }\\n\\n    // using Front Row Partition Dp - Time Complexity = O(n*k)\\n    int solve(int i, int k, vector<int> &arr){\\n        if(i == arr.size()) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ans = 0;\\n        int mx = 0;\\n        for(int j = i; j < i + k && j < arr.size(); j++){\\n            mx = max(mx, arr[j]);\\n            ans = max(ans, mx*(j-i+1) + solve(j+1, k, arr));\\n        }\\n        return dp[i] = ans;\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, k, arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[510];\\n    // time Complexity = O(n*n*n*k) - Verdict - TLE\\n    // int solve(int i, int j,  vector<int> &arr, int t){\\n    //     if(i > j) return 0;\\n    //     if(dp[i][j] != -1) return dp[i][j];\\n    //     if(i == j) return arr[i];\\n    //     if(j - i + 1 <= t){\\n    //         int mx = INT_MIN;\\n    //         for(int x = i; x<=j; x++)mx = max(mx, arr[x]);\\n    //         return (j-i+1)*mx;\\n    //     }\\n    //     int ans = 0;\\n    //     for(int k = i; k<j; k++){\\n    //         ans = max(ans,  solve(i, k, arr, t) + solve(k+1, j, arr, t));\\n    //     }\\n    //     return dp[i][j] = ans;\\n    // }\\n\\n    // using Front Row Partition Dp - Time Complexity = O(n*k)\\n    int solve(int i, int k, vector<int> &arr){\\n        if(i == arr.size()) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ans = 0;\\n        int mx = 0;\\n        for(int j = i; j < i + k && j < arr.size(); j++){\\n            mx = max(mx, arr[j]);\\n            ans = max(ans, mx*(j-i+1) + solve(j+1, k, arr));\\n        }\\n        return dp[i] = ans;\\n    }\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, k, arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754823,
                "title": "java-dp-memoization",
                "content": "# Memoization\\n```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp, -1);\\n        return helper(arr, 0, k, dp);\\n    }\\n\\n    private int helper(int[] arr, int ind, int k, int[] dp) {\\n        if (ind >= arr.length) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxSum = 0, maxValue = 0;\\n        for (int i = ind; i < Math.min(ind + k, arr.length); i++) {\\n            maxValue = Math.max(maxValue, arr[i]);\\n            maxSum = Math.max((i - ind + 1) * maxValue + helper(arr, i + 1, k, dp), maxSum);\\n        }\\n\\n        return dp[ind] = maxSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp, -1);\\n        return helper(arr, 0, k, dp);\\n    }\\n\\n    private int helper(int[] arr, int ind, int k, int[] dp) {\\n        if (ind >= arr.length) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxSum = 0, maxValue = 0;\\n        for (int i = ind; i < Math.min(ind + k, arr.length); i++) {\\n            maxValue = Math.max(maxValue, arr[i]);\\n            maxSum = Math.max((i - ind + 1) * maxValue + helper(arr, i + 1, k, dp), maxSum);\\n        }\\n\\n        return dp[ind] = maxSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649204,
                "title": "easy-intuitive-dp-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int solve(vector<int> &arr, int i, int k) {\\n\\n        if(i >= arr.size()) {\\n            return 0;\\n        }\\n        if(dp[i] != -1) {\\n            return dp[i];\\n        }\\n        int ans = INT_MIN;\\n        for(int j = i; j < i + k and j < arr.size(); j++) {\\n            int maxx = INT_MIN;\\n            for(int k = i; k < j+1; k++) {\\n                maxx = max(maxx, arr[k]);\\n            }\\n            int temp = maxx * (j-i+1);\\n            int nextAns = solve(arr, j+1, k);\\n            ans = max(ans, temp + nextAns);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(arr, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int solve(vector<int> &arr, int i, int k) {\\n\\n        if(i >= arr.size()) {\\n            return 0;\\n        }\\n        if(dp[i] != -1) {\\n            return dp[i];\\n        }\\n        int ans = INT_MIN;\\n        for(int j = i; j < i + k and j < arr.size(); j++) {\\n            int maxx = INT_MIN;\\n            for(int k = i; k < j+1; k++) {\\n                maxx = max(maxx, arr[k]);\\n            }\\n            int temp = maxx * (j-i+1);\\n            int nextAns = solve(arr, j+1, k);\\n            ans = max(ans, temp + nextAns);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(arr, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559973,
                "title": "golang-solution",
                "content": "```\\nfunc maxSumAfterPartitioning(arr []int, k int) int {\\n\\tdp := make([]int, len(arr))\\n\\tdp[0] = arr[0]\\n\\tfor i := 1; i < len(arr); i++ {\\n\\t\\tmax, maxValue := 0, 0\\n\\t\\tfor j := i; j >= Max(0, i-k+1); j-- {\\n\\t\\t\\tmaxValue = Max(arr[j], maxValue)\\n\\t\\t\\tcalc := (i - j + 1) * maxValue\\n\\t\\t\\tif j > 0 {\\n\\t\\t\\t\\tmax = Max(max, calc+dp[j-1])\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tmax = Max(max, calc)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = max\\n\\t}\\n\\treturn dp[len(arr)-1]\\n}\\n\\n\\nfunc Max(a, b int) int{\\n\\tif a > b{\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxSumAfterPartitioning(arr []int, k int) int {\\n\\tdp := make([]int, len(arr))\\n\\tdp[0] = arr[0]\\n\\tfor i := 1; i < len(arr); i++ {\\n\\t\\tmax, maxValue := 0, 0\\n\\t\\tfor j := i; j >= Max(0, i-k+1); j-- {\\n\\t\\t\\tmaxValue = Max(arr[j], maxValue)\\n\\t\\t\\tcalc := (i - j + 1) * maxValue\\n\\t\\t\\tif j > 0 {\\n\\t\\t\\t\\tmax = Max(max, calc+dp[j-1])\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tmax = Max(max, calc)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = max\\n\\t}\\n\\treturn dp[len(arr)-1]\\n}\\n\\n\\nfunc Max(a, b int) int{\\n\\tif a > b{\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3308105,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp)\\n    {\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++)\\n        {\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k)\\n     {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp)\\n    {\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++)\\n        {\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k)\\n     {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040967,
                "title": "c-recursion-memoization-tabulation",
                "content": "# Recursion\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        return f(0, n, k, arr);  \\n    }\\n};\\n```\\n\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v, vector<int> &dp)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v, dp);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, -1);\\n\\n        return f(0, n, k, arr, dp); \\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, 0);\\n\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n\\n            for (int j = i; j < min(i + k, n); j++)\\n            {\\n                length++;\\n                maxi = max(maxi, arr[j]);\\n                sum = length * maxi + dp[j + 1];\\n                maxSum = max(maxSum, sum);\\n            }\\n            dp[i] = maxSum;\\n        }\\n\\n        return dp[0];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        return f(0, n, k, arr);  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i, int n, int k, vector<int> &v, vector<int> &dp)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n        for (int j = i; j < min(i + k, n); j++)\\n        {\\n            length++;\\n            maxi = max(maxi, v[j]);\\n            sum = length * maxi + f(j + 1, n, k, v, dp);\\n            maxSum = max(maxSum, sum);\\n        }\\n\\n        return dp[i] = maxSum;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, -1);\\n\\n        return f(0, n, k, arr, dp); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        vector<int> dp(n + 1, 0);\\n\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int maxi = -1e9, length = 0, sum = 0, maxSum = -1e9;\\n\\n            for (int j = i; j < min(i + k, n); j++)\\n            {\\n                length++;\\n                maxi = max(maxi, arr[j]);\\n                sum = length * maxi + dp[j + 1];\\n                maxSum = max(maxSum, sum);\\n            }\\n            dp[i] = maxSum;\\n        }\\n\\n        return dp[0];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658807,
                "title": "python-recursion-memoization-super-easy-partition-array-for-maximum-sum",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @cache\\n        def max_sum_after_partitioning(k, index):\\n            if index == len(arr):\\n                return 0\\n            current_max = float(\\'-inf\\')\\n            ans = float(\\'-inf\\')\\n            length = 0\\n            for i in range(index, min(len(arr),index+k)):\\n                length += 1\\n\\n                current_max = max(current_max, arr[i])\\n                ans = max(ans, current_max*length + max_sum_after_partitioning(k, i+1))\\n\\n\\n            return ans\\n        return max_sum_after_partitioning(k, 0)\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @cache\\n        def max_sum_after_partitioning(k, index):\\n            if index == len(arr):\\n                return 0\\n            current_max = float(\\'-inf\\')\\n            ans = float(\\'-inf\\')\\n            length = 0\\n            for i in range(index, min(len(arr),index+k)):\\n                length += 1\\n\\n                current_max = max(current_max, arr[i])\\n                ans = max(ans, current_max*length + max_sum_after_partitioning(k, i+1))\\n\\n\\n            return ans\\n        return max_sum_after_partitioning(k, 0)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586925,
                "title": "c-simple-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp){\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++){\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k) {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp){\\n        if(i==n)return 0;\\n        int mx = 0,ans = 0,len = 0;\\n        if(dp[i] != -1)return dp[i];\\n        for(int j = i; j < min(n,(i+k)); j++){\\n            len++;\\n            mx = max(mx,v[j]);\\n            int sum = mx*len + solve(j+1,v,k,n,dp);\\n            ans = max(ans,sum);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int &k) {\\n        int n = arr.size();\\n        vector<int> v(n,-1);\\n        return solve(0,arr,k,n,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461264,
                "title": "python-solution-dp-practically-brute-force",
                "content": "I spent some time to get the indicies right though\\n```\\nclass Solution:\\n    # This is a DP problem\\n    # 1 <= arr.length <= 500 -> Can look for n^2 (or nk) algorithms\\n    # dp[i] = largest sum of arr[:i+1] after partitioning\\n    # subproblem structure: in principle, for each [j:i+1] subwindow (i-j+1 <= k), we need to look for the max of dp[j] + (i-j)*max(arr[j:i+1])\\n    # To do this efficiently, we can use a variable currMax to scan for max seen from arr[i] back to arr[j:i+1]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            curr_max = 0\\n            for j in range(i-1, max(i-k-1, -1), -1):\\n                curr_max = max(curr_max, arr[j])\\n                dp[i] = max(dp[i], dp[j] + (i-j)*curr_max)\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This is a DP problem\\n    # 1 <= arr.length <= 500 -> Can look for n^2 (or nk) algorithms\\n    # dp[i] = largest sum of arr[:i+1] after partitioning\\n    # subproblem structure: in principle, for each [j:i+1] subwindow (i-j+1 <= k), we need to look for the max of dp[j] + (i-j)*max(arr[j:i+1])\\n    # To do this efficiently, we can use a variable currMax to scan for max seen from arr[i] back to arr[j:i+1]\\n    \\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            curr_max = 0\\n            for j in range(i-1, max(i-k-1, -1), -1):\\n                curr_max = max(curr_max, arr[j])\\n                dp[i] = max(dp[i], dp[j] + (i-j)*curr_max)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445808,
                "title": "partition-dp-memoization",
                "content": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int fun(int st,int n,int k,vector<int>&arr){\\n        if(dp[st]!=-1)return dp[st];\\n        if(st>=n)return dp[st]=0;\\n        int mx=arr[st];\\n        int max_ans=-1;\\n        for(int i=st;i<n and i-st<k;i++){\\n            mx=max(mx,arr[i]);\\n            int ans=(i-st+1)*mx+fun(i+1,n,k,arr);\\n            max_ans=max(max_ans,ans);\\n        }\\n        return  dp[st]=max_ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        dp.resize(arr.size()+1,-1);\\n        return fun(0,arr.size(),k,arr);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int fun(int st,int n,int k,vector<int>&arr){\\n        if(dp[st]!=-1)return dp[st];\\n        if(st>=n)return dp[st]=0;\\n        int mx=arr[st];\\n        int max_ans=-1;\\n        for(int i=st;i<n and i-st<k;i++){\\n            mx=max(mx,arr[i]);\\n            int ans=(i-st+1)*mx+fun(i+1,n,k,arr);\\n            max_ans=max(max_ans,ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2418299,
                "title": "dynamic-programming-mcm-variation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n    \\n          int start=0;\\n          dp.resize(arr.size(),-1);\\n          return fun(arr,k,start);\\n    }\\n    int fun(vector<int>&arr,int &k,int idx)\\n    {\\n        if(idx>=arr.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int max_val=INT_MIN;\\n        int ans=INT_MIN;\\n        int len=0;\\n        \\n        for(int i=idx;i<(idx+k) and i<arr.size() ;i++)\\n        {\\n            max_val=max(max_val,arr[i]);  //max till the length\\n            len++;\\n            \\n            dp[idx]=max(dp[idx],(max_val*len)+fun(arr,k,i+1));\\n        }\\n        return dp[idx];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n    \\n          int start=0;\\n          dp.resize(arr.size(),-1);\\n          return fun(arr,k,start);\\n    }\\n    int fun(vector<int>&arr,int &k,int idx)\\n    {\\n        if(idx>=arr.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int max_val=INT_MIN;\\n        int ans=INT_MIN;\\n        int len=0;\\n        \\n        for(int i=idx;i<(idx+k) and i<arr.size() ;i++)\\n        {\\n            max_val=max(max_val,arr[i]);  //max till the length\\n            len++;\\n            \\n            dp[idx]=max(dp[idx],(max_val*len)+fun(arr,k,i+1));\\n        }\\n        return dp[idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359326,
                "title": "c-recursion-memoization-tabulation-dp-similar-front-partitioning-dp",
                "content": "Recursion + memoization : \\n\\nFor every subarray of size \\'k\\' we have an option to partition it at the current index and recur for the remaining array while adding  **currPartitionLength*localMax** to the answer .\\nWe take the max of all possible combinations of such subarrays and return the max answer.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int recur(vector<int>& arr, int index, int k, vector<int> &memo)\\n    {\\n        \\n        int n=arr.size();\\n        \\n        if(index == n)\\n        {\\n            return 0;\\n        }\\n        \\n        if(memo[index] != -1)\\n        {\\n           return memo[index];\\n        }\\n        \\n        int currPartitionLength, maxCost, localMax;\\n        currPartitionLength = 0;\\n        maxCost=0;\\n        localMax = INT_MIN;\\n        \\n        for(int j=index; j < min(index+k, n); j++)\\n        {\\n            currPartitionLength++;\\n            localMax = max(localMax, arr[j]);\\n            int cost = currPartitionLength*localMax+recur(arr, j+1, k, memo);\\n            maxCost = max(maxCost, cost);\\n        }\\n        \\n        return memo[index] = maxCost;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> memo(arr.size()+1, -1);\\n        return recur(arr, 0, k, memo);\\n    }\\n};\\n```\\n\\nConverting the top down recursion to tabulation, we get : \\n\\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\n        int n = arr.size();\\n        vector<int> dp(n+1, 0);\\n        dp[n] = 0;\\n        \\n        for(int index = n-1; index>=0; index--)\\n        {\\n            int currPartitionLength, maxCost, localMax;\\n            currPartitionLength = 0;\\n            maxCost=0;\\n            localMax = INT_MIN;\\n\\n            for(int j=index; j < min(index+k, n); j++)\\n            {\\n                currPartitionLength++;\\n                localMax = max(localMax, arr[j]);\\n                int cost = currPartitionLength*localMax+dp[j+1];\\n                maxCost = max(maxCost, cost);\\n            }\\n\\n            dp[index] = maxCost;\\n        }\\n        \\n        return dp[0];\\n    }\\n```\\n\\nFor tabulation, we simply reverse the direction of traversal and replace recursion calls with dp array.\\n\\nHappy learning!\\nDo comment if you have any doubts.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int recur(vector<int>& arr, int index, int k, vector<int> &memo)\\n    {\\n        \\n        int n=arr.size();\\n        \\n        if(index == n)\\n        {\\n            return 0;\\n        }\\n        \\n        if(memo[index] != -1)\\n        {\\n           return memo[index];\\n        }\\n        \\n        int currPartitionLength, maxCost, localMax;\\n        currPartitionLength = 0;\\n        maxCost=0;\\n        localMax = INT_MIN;\\n        \\n        for(int j=index; j < min(index+k, n); j++)\\n        {\\n            currPartitionLength++;\\n            localMax = max(localMax, arr[j]);\\n            int cost = currPartitionLength*localMax+recur(arr, j+1, k, memo);\\n            maxCost = max(maxCost, cost);\\n        }\\n        \\n        return memo[index] = maxCost;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> memo(arr.size()+1, -1);\\n        return recur(arr, 0, k, memo);\\n    }\\n};\\n```\n```\\n int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\n        int n = arr.size();\\n        vector<int> dp(n+1, 0);\\n        dp[n] = 0;\\n        \\n        for(int index = n-1; index>=0; index--)\\n        {\\n            int currPartitionLength, maxCost, localMax;\\n            currPartitionLength = 0;\\n            maxCost=0;\\n            localMax = INT_MIN;\\n\\n            for(int j=index; j < min(index+k, n); j++)\\n            {\\n                currPartitionLength++;\\n                localMax = max(localMax, arr[j]);\\n                int cost = currPartitionLength*localMax+dp[j+1];\\n                maxCost = max(maxCost, cost);\\n            }\\n\\n            dp[index] = maxCost;\\n        }\\n        \\n        return dp[0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358999,
                "title": "c-solution-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int ret_sum(vector<int> &arr, int start, int end)\\n    {\\n        int maxi = 0, sum = 0;\\n        for(int i=start; i<end+1; i++) maxi = max(maxi, arr[i]);\\n        return (maxi*(end+1-start));\\n    }\\n    \\n    int func(vector<int> &dp, vector<int> &arr, int index, int k)\\n    {\\n        if(index > arr.size()-1) return 0;\\n        \\n        if(dp[index] != -1) return dp[index];\\n        \\n        int maxm = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            if(index+i > arr.size()-1) break;\\n            maxm = max(maxm, ret_sum(arr, index, index+i) + func(dp, arr, index+i+1, k));\\n        }\\n        return dp[index] = maxm;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size()+1, -1);\\n        return func(dp, arr, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ret_sum(vector<int> &arr, int start, int end)\\n    {\\n        int maxi = 0, sum = 0;\\n        for(int i=start; i<end+1; i++) maxi = max(maxi, arr[i]);\\n        return (maxi*(end+1-start));\\n    }\\n    \\n    int func(vector<int> &dp, vector<int> &arr, int index, int k)\\n    {\\n        if(index > arr.size()-1) return 0;\\n        \\n        if(dp[index] != -1) return dp[index];\\n        \\n        int maxm = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            if(index+i > arr.size()-1) break;\\n            maxm = max(maxm, ret_sum(arr, index, index+i) + func(dp, arr, index+i+1, k));\\n        }\\n        return dp[index] = maxm;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size()+1, -1);\\n        return func(dp, arr, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242821,
                "title": "c-solution-dp-tabulation-explained-via-comments",
                "content": "class Solution {\\npublic:\\n    \\n    // Tabulation Code\\n    \\n    \\n    // function to find maximum in the partition\\n    \\n    int search(int i,int j,vector<int>&nums){\\n        int maxi=-1e9;\\n        while(i<=j){\\n            maxi=max(maxi,nums[i++]);\\n        }\\n        return maxi;\\n    }\\n    \\n    \\n    \\n    \\n    int maxSumAfterPartitioning(vector<int>&nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<int>dp(n+1,0); // n+1 as j=n-1 then for j+1 to handle runtime error\\n        \\n        // base case \\n        dp[n]=0;\\n        \\n        //loops for iteration\\n        for(int i=n-1;i>=0;i--){ // changing variable\\n            int maxi=-1e9;\\n            // loop for partition\\n            // start from i+k-1 as it would be less than i+k\\n            // take minimum from n-1 and i+k-1 for array size\\n            for(int j=min(i+k-1,n-1);j>=i;j--){\\n                \\n                // finding maximum in partition \\n                int a=search(i,j,nums);\\n                //value added= length of partition j-i+1 x a\\n                // for partition of range i to j --> the length is j-i+1\\n                int val=(j-i+1)*a;\\n                \\n                // using pre computed state from next point i.e.j+1 because range from i to j is computed so precompute for state j+1;\\n                maxi=max(maxi,val+dp[j+1]);\\n            }\\n            \\n            //storing each state for each number we travel in the array\\n            dp[i]=maxi;\\n        }\\n        \\n        // maximum will be retrieved when whole array is computed i.e at index 0\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // Tabulation Code\\n    \\n    \\n    // function to find maximum in the partition\\n    \\n    int search(int i,int j,vector<int>&nums){\\n        int maxi=-1e9;\\n        while(i<=j){\\n            maxi=max(maxi,nums[i++]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2210679,
                "title": "simple-solution-for-recursion-memoization-and-topdown",
                "content": "# recursion\\n\\n\\tclass Solution {\\n    int n,k;\\n    \\n    int rec(int i,vector<int>& arr,vector<int>&dp)\\n    {\\n        if(i==n)\\n            return 0;\\n        \\n        int len =0;\\n        int mx=INT_MIN,ans=INT_MIN;\\n        \\n        for(int j=i;j<min(i+k,n);++j)\\n        {\\n            ++len;\\n            mx=max(mx,arr[j]);\\n            int sum=mx*len+rec(j+1,arr,dp);\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n\\tpublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int K) \\n    {\\n        n=arr.size();\\n        k=K;\\n        vector<int>dp(n+1,0);\\n        return rec(0,arr,dp);\\n        // return 1;\\n    }\\n\\t};\\n\\t\\n# \\tmemoization\\n\\n\\tclass Solution {\\n    int n,k;\\n    int rec(int i,vector<int>&a,vector<int>&dp)\\n    {\\n        if(i==n)\\n            return 0;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int len=0,mx=0;\\n        \\n        for(int j=i;j<min(i+k,n);++j)\\n        {\\n            ++len;\\n            mx=max(a[j],mx);\\n            int sum=mx*len+rec(j+1,a,dp);\\n            dp[i]=max(dp[i],sum);\\n        }\\n        return dp[i];\\n    }\\n\\tpublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int K) {\\n        n=arr.size(),k=K;\\n        vector<int>dp(n+1,-1);\\n        return rec(0,arr,dp);\\n    }\\n\\t};\\n\\t\\n# \\ttopdown\\n\\tclass Solution {    \\n\\tpublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n=arr.size();\\n        vector<int>dp(n+1,0);\\n        \\n        for(int i=1;i<=n;++i)\\n        {\\n            int mx=0,sum=0;\\n            for(int j=1;j<=k && i-j>=0;++j)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                sum=max(mx*j+dp[i-j],sum);\\n            }\\n            dp[i]=sum;\\n        }\\n        return dp[n];\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    int n,k;\\n    \\n    int rec(int i,vector<int>& arr,vector<int>&dp)\\n    {\\n        if(i==n)\\n            return 0;\\n        \\n        int len =0;\\n        int mx=INT_MIN,ans=INT_MIN;\\n        \\n        for(int j=i;j<min(i+k,n);++j)\\n        {\\n            ++len;\\n            mx=max(mx,arr[j]);\\n            int sum=mx*len+rec(j+1,arr,dp);\\n            ans=max(ans,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2205626,
                "title": "c-tabulation-easy-solution-dp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182884,
                "title": "using-dynamic-programming-o-n-k",
                "content": "```\\nif(ind==n) return 0;\\n\\tif(dp[ind]!=-1) return dp[ind];\\n\\tint len=0;\\n\\tint res=INT_MIN;\\n\\tint maxi=INT_MIN;\\n\\tfor(int i=ind;i<min(ind+k,n);i++){\\n\\t\\tlen++;\\n\\t\\tmaxi=max(maxi,arr[i]);\\n\\t\\tint sum=(len*maxi)+f(i+1,n,k,arr,dp);\\n\\n\\t\\tres=max(res,sum);\\n\\t}\\n\\n\\treturn dp[ind]=res;\\n}\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int>dp(arr.size(),-1);\\n\\treturn f(0,arr.size(),k,arr,dp);\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nif(ind==n) return 0;\\n\\tif(dp[ind]!=-1) return dp[ind];\\n\\tint len=0;\\n\\tint res=INT_MIN;\\n\\tint maxi=INT_MIN;\\n\\tfor(int i=ind;i<min(ind+k,n);i++){\\n\\t\\tlen++;\\n\\t\\tmaxi=max(maxi,arr[i]);\\n\\t\\tint sum=(len*maxi)+f(i+1,n,k,arr,dp);\\n\\n\\t\\tres=max(res,sum);\\n\\t}\\n\\n\\treturn dp[ind]=res;\\n}\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\tvector<int>dp(arr.size(),-1);\\n\\treturn f(0,arr.size(),k,arr,dp);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2144180,
                "title": "simple-forward-partitioning-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>&arr, int k, int i,vector<int>& dp){\\n        \\n        int n =arr.size();\\n        \\n        if(i == n) \\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int max_element=INT_MIN;\\n        int ans = INT_MIN;\\n        int len=0;\\n       \\n        // simply \\n        for(int j=i; j < min(i+k,n); j++){\\n            \\n            len++;\\n            max_element = max(arr[j], max_element);\\n            int sum = len*max_element + f(arr,k,j+1,dp);\\n            \\n            ans = max(ans,sum);\\n        }\\n        \\n        return dp[i] =ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        vector<int> dp(arr.size(),-1);\\n        \\n        return f(arr,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>&arr, int k, int i,vector<int>& dp){\\n        \\n        int n =arr.size();\\n        \\n        if(i == n) \\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int max_element=INT_MIN;\\n        int ans = INT_MIN;\\n        int len=0;\\n       \\n        // simply \\n        for(int j=i; j < min(i+k,n); j++){\\n            \\n            len++;\\n            max_element = max(arr[j], max_element);\\n            int sum = len*max_element + f(arr,k,j+1,dp);\\n            \\n            ans = max(ans,sum);\\n        }\\n        \\n        return dp[i] =ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        vector<int> dp(arr.size(),-1);\\n        \\n        return f(arr,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142656,
                "title": "java-recursive-to-memorization-to-dp",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length;\\n        int dp[] = new int[n];\\n        Arrays.fill(dp,-1);\\n        return func(0,n,arr,k,dp);\\n    }\\n    \\n    public int func(int ind,int n,int arr[],int k,int [] dp){\\n        if(ind == n) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        int maxiSum =Integer.MIN_VALUE;\\n        int len =0;\\n        int maxi = Integer.MIN_VALUE;\\n        for(int j=ind;j<Math.min(ind+k,n);j++){\\n            len++;\\n            maxi = Math.max(maxi,arr[j]);\\n            int sum = (len*maxi) + func(j+1,n,arr,k,dp);\\n            maxiSum=Math.max(sum,maxiSum);\\n            \\n        }\\n        return dp[ind] = maxiSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length;\\n        int dp[] = new int[n];\\n        Arrays.fill(dp,-1);\\n        return func(0,n,arr,k,dp);\\n    }\\n    \\n    public int func(int ind,int n,int arr[],int k,int [] dp){\\n        if(ind == n) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        int maxiSum =Integer.MIN_VALUE;\\n        int len =0;\\n        int maxi = Integer.MIN_VALUE;\\n        for(int j=ind;j<Math.min(ind+k,n);j++){\\n            len++;\\n            maxi = Math.max(maxi,arr[j]);\\n            int sum = (len*maxi) + func(j+1,n,arr,k,dp);\\n            maxiSum=Math.max(sum,maxiSum);\\n            \\n        }\\n        return dp[ind] = maxiSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060178,
                "title": "c-recursion-memoization-tabulation",
                "content": "**RECURSION (GIVES TLE)**\\n```\\nint f(int ind,vector<int>&nums,int k)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        return f(0,nums,k);\\n    }\\n};\\n```\\n**MEMOIZATION**\\n```\\nint f(int ind,vector<int>&nums,int k,vector<int>&dp)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k,dp);\\n            maxans=max(maxans,sum);\\n        }\\n        return dp[ind]=maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,nums,k,dp);\\n    }\\n};\\n```\\n**TABULATION**\\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint f(int ind,vector<int>&nums,int k)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k);\\n            maxans=max(maxans,sum);\\n        }\\n        return maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        return f(0,nums,k);\\n    }\\n};\\n```\n```\\nint f(int ind,vector<int>&nums,int k,vector<int>&dp)\\n{\\n        if(ind==nums.size())\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int len=0;\\n        int maxi=INT_MIN;\\n        int maxans=INT_MIN;\\n        int n=nums.size();\\n        for(int j=ind;j<min(n,ind+k);j++)\\n        {\\n            len++;\\n            maxi=max(maxi,nums[j]);\\n            int sum=len*maxi+f(j+1,nums,k,dp);\\n            maxans=max(maxans,sum);\\n        }\\n        return dp[ind]=maxans;\\n}\\nclass Solution {\\npublic:\\n    \\n    int maxSumAfterPartitioning(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,nums,k,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int mx=INT_MIN,best=INT_MIN;\\n            for(int j=1;j<=k && i-j>=0;j++)\\n            {\\n                mx=max(mx,arr[i-j]);\\n                best=max(best,dp[i-j]+mx*j);\\n            }\\n            dp[i]=best;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978484,
                "title": "classic-dp-problem-java-clean-code",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length; \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MIN_VALUE); \\n        return fun(dp, arr, 0, k); \\n    }\\n    public int findMax(int[] arr, int i, int j){\\n        int max =0; \\n        for (int k = i; k <= j; k++){\\n            max = Math.max(arr[k], max);\\n        }\\n        \\n        return max; \\n    }\\n    public int fun(int[] dp, int[] arr, int pos, int k){\\n        int n = dp.length; \\n        if (pos >= n) return 0;\\n        // if (k == 1) return findMax(arr, pos, n - 1)*(n - pos); \\n        if (dp[pos] != Integer.MIN_VALUE) return dp[pos]; \\n        \\n        int ans = 0;  \\n        for (int i = pos + 1; i < Math.min(n , pos + k + 1); i++){\\n         ans = Math.max(ans, findMax(arr, pos, i - 1)*(i - pos) + fun(dp, arr, i, k));    \\n        }\\n     if (n - pos <= k)   ans = Math.max(ans, findMax(arr, pos, n - 1)*(n - pos)); \\n        dp[pos] = ans; \\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int n = arr.length; \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MIN_VALUE); \\n        return fun(dp, arr, 0, k); \\n    }\\n    public int findMax(int[] arr, int i, int j){\\n        int max =0; \\n        for (int k = i; k <= j; k++){\\n            max = Math.max(arr[k], max);\\n        }\\n        \\n        return max; \\n    }\\n    public int fun(int[] dp, int[] arr, int pos, int k){\\n        int n = dp.length; \\n        if (pos >= n) return 0;\\n        // if (k == 1) return findMax(arr, pos, n - 1)*(n - pos); \\n        if (dp[pos] != Integer.MIN_VALUE) return dp[pos]; \\n        \\n        int ans = 0;  \\n        for (int i = pos + 1; i < Math.min(n , pos + k + 1); i++){\\n         ans = Math.max(ans, findMax(arr, pos, i - 1)*(i - pos) + fun(dp, arr, i, k));    \\n        }\\n     if (n - pos <= k)   ans = Math.max(ans, findMax(arr, pos, n - 1)*(n - pos)); \\n        dp[pos] = ans; \\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968983,
                "title": "c-dp-memorization-with-explanation",
                "content": "1.  The intitution by reading this problem was to traverse\\n the whole array and at each index making the decision\\n to pick 0 to k elements < ie. index ----  index+k >\\n \\n2.  it is essential to use the maximum of the index ---- index+k\\nelement to make as per the question and it trivialy calculated\\n\\n3.  memoization also revolves around the fact that at perticular\\nindex we will have max solution\\n\\n**Pseudo Code**\\n4.  for i in index--- index+k:\\n          ans =  max_value*i-index+1 + backtrack(i+1)\\n          max_val = max(ans,max_val)\\n\\n\\n     return memo[index] = max_val\\n\\t \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        vector<int>dp(n+1,-1);\\n        return backtrack(arr,0,k,dp);\\n    }\\n    int backtrack(vector<int>&arr,int index,int k,vector<int>&dp){\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int max_value=INT_MIN;\\n        int maxAtIndex=INT_MIN;\\n        for(int i=index;i<index+k and i<n;i++){\\n            if(max_value<arr[i]){\\n                max_value=arr[i];\\n            }\\n            int ans = max_value*(i-index+1)+backtrack(arr,i+1,k,dp);\\n            maxAtIndex = max(ans,maxAtIndex);\\n        }\\n        return dp[index]=maxAtIndex;\\n    }\\n};\\n```\\nPls Upvote if you found this helpful",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        n=arr.size();\\n        vector<int>dp(n+1,-1);\\n        return backtrack(arr,0,k,dp);\\n    }\\n    int backtrack(vector<int>&arr,int index,int k,vector<int>&dp){\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int max_value=INT_MIN;\\n        int maxAtIndex=INT_MIN;\\n        for(int i=index;i<index+k and i<n;i++){\\n            if(max_value<arr[i]){\\n                max_value=arr[i];\\n            }\\n            int ans = max_value*(i-index+1)+backtrack(arr,i+1,k,dp);\\n            maxAtIndex = max(ans,maxAtIndex);\\n        }\\n        return dp[index]=maxAtIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951674,
                "title": "c-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int n, int k,int idx,vector<int> &dp)\\n    {\\n        if(dp[idx]!=-1) return dp[idx];\\n        int max_num=0;\\n        int res=0;\\n        \\n        \\n        for(int i=idx; i<n && i-idx<k;i++)\\n        {\\n            max_num=max(max_num,arr[i]);\\n            res=max(res,max_num*(i-idx+1)+fun(arr,n,k,i+1,dp));            \\n        }\\n        dp[idx]=res;\\n        return res;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int> dp(n+1,-1);\\n        \\n        return fun(arr,n,k,0,dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int n, int k,int idx,vector<int> &dp)\\n    {\\n        if(dp[idx]!=-1) return dp[idx];\\n        int max_num=0;\\n        int res=0;\\n        \\n        \\n        for(int i=idx; i<n && i-idx<k;i++)\\n        {\\n            max_num=max(max_num,arr[i]);\\n            res=max(res,max_num*(i-idx+1)+fun(arr,n,k,i+1,dp));            \\n        }\\n        dp[idx]=res;\\n        return res;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int> dp(n+1,-1);\\n        \\n        return fun(arr,n,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923148,
                "title": "c-mcm-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[500+10][500+10];\\n    int mcm(vector<int>&arr,int k,int i,int j)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0;\\n        for(int f=i;f<=min(j,i+k-1);f++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int y=i;y<=f;y++)\\n            {\\n                if(arr[y]>maxi)\\n                maxi=arr[y];\\n            }\\n            int temp=(f-i+1)*maxi+mcm(arr,k,f+1,j);\\n            if(temp>ans)\\n                ans=temp;\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return mcm(arr,k,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500+10][500+10];\\n    int mcm(vector<int>&arr,int k,int i,int j)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0;\\n        for(int f=i;f<=min(j,i+k-1);f++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int y=i;y<=f;y++)\\n            {\\n                if(arr[y]>maxi)\\n                maxi=arr[y];\\n            }\\n            int temp=(f-i+1)*maxi+mcm(arr,k,f+1,j);\\n            if(temp>ans)\\n                ans=temp;\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return mcm(arr,k,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921648,
                "title": "c-easy-understanding",
                "content": "\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\t  int n = arr.size();\\n\\t\\t\\t  vector<int> dp(n+1, 0);\\n\\n\\t\\t\\t  for(int i=1; i<=n; i++){\\n\\t\\t\\t\\t  int curr_max = 0;\\n\\t\\t\\t\\t  int curr_ans = 0;\\n\\n\\t\\t\\t\\t  for(int j=1; j<=k && i-j>=0; j++){\\n\\t\\t\\t\\t\\t  curr_max = max(curr_max, arr[i-j]);\\n\\t\\t\\t\\t\\t  curr_ans = max(curr_ans, dp[i-j] + curr_max * j);\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  dp[i] = curr_ans;\\n\\t\\t\\t  }\\n\\t\\t\\t   return dp[n];\\n\\t\\t}\\n\\t\\t",
                "solutionTags": [],
                "code": "\\tint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n\\t\\t\\t  int n = arr.size();\\n\\t\\t\\t  vector<int> dp(n+1, 0);\\n\\n\\t\\t\\t  for(int i=1; i<=n; i++){\\n\\t\\t\\t\\t  int curr_max = 0;\\n\\t\\t\\t\\t  int curr_ans = 0;\\n\\n\\t\\t\\t\\t  for(int j=1; j<=k && i-j>=0; j++){\\n\\t\\t\\t\\t\\t  curr_max = max(curr_max, arr[i-j]);\\n\\t\\t\\t\\t\\t  curr_ans = max(curr_ans, dp[i-j] + curr_max * j);\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  dp[i] = curr_ans;\\n\\t\\t\\t  }\\n\\t\\t\\t   return dp[n];\\n\\t\\t}\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1906420,
                "title": "easy-recurssion-memoization-bottom-down-tabulation-bottom-up",
                "content": "RECURSSION\\n\\nTime Complexity = Exponentital\\nSpace Complexity = Exponential\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        \\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k));\\n        }\\n        \\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        return maxSum(n-1,arr,k);\\n    }\\n```\\n\\nMemoization ( Bottom Down)\\n\\nTime Complexity = O(N) // because of dp vector of n size;\\nSpace Complexity = O(N)// dp vector + stack space\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k,vector<int>&dp){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k,dp));\\n        }\\n        dp[ind] = ans;\\n        return dp[ind];\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,-1);\\n        return maxSum(n-1,arr,k,dp);\\n    }\\n};\\n```\\n\\nTabulation( Bottom Up)\\n\\nTime Complexity = O(N) // because of dp vector of n size;\\nSpace Complexity = O(N)// dp vector\\n```\\nclass Solution {\\npublic:\\n   \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        for(int i = 1 ; i < n ; i++){\\n            int ma = 0, ans = 0;\\n            for(int j = i ; j > i-k && j >= 0 ; j--){\\n                ma = max(arr[j] , ma);\\n                if(j>=1)\\n                    ans = max(dp[j-1] + ma*(i-j+1),ans);\\n                else ans = max(ans,ma*(i-j+1));\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Upvote if you like the code**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        \\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k));\\n        }\\n        \\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        return maxSum(n-1,arr,k);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSum(int ind,vector<int>&arr,int k,vector<int>&dp){\\n        // cout<<ind<<endl;\\n        if(ind == -1) \\n            return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        int ans = 0;\\n        int m = 0;\\n        for(int x = ind; x > ind-k && x>=0; x--) {\\n            m = max(arr[x],m);\\n            ans = max(ans,m*(ind-x+1) + maxSum(x-1, arr, k,dp));\\n        }\\n        dp[ind] = ans;\\n        return dp[ind];\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,-1);\\n        return maxSum(n-1,arr,k,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        vector<int>dp(n,0);\\n        dp[0] = arr[0];\\n        for(int i = 1 ; i < n ; i++){\\n            int ma = 0, ans = 0;\\n            for(int j = i ; j > i-k && j >= 0 ; j--){\\n                ma = max(arr[j] , ma);\\n                if(j>=1)\\n                    ans = max(dp[j-1] + ma*(i-j+1),ans);\\n                else ans = max(ans,ma*(i-j+1));\\n            }\\n            dp[i] = ans;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1870126,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n          int n = arr.size();\\n          int dp[n + 1];\\n          memset(dp, 0, sizeof(dp));\\n          for(int i= 1; i<=n; i++){\\n              int K = k;\\n              int cur_max = 0;\\n              int cur_ans = 0;\\n              for(int K = 1; K <= k && i - K >= 0; K++){\\n                  cur_max = max(cur_max, arr[i-K]);\\n                  cur_ans = max(cur_ans, dp[i-K] + K * cur_max);\\n              }\\n              dp[i] = cur_ans;\\n          }\\n           return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n          int n = arr.size();\\n          int dp[n + 1];\\n          memset(dp, 0, sizeof(dp));\\n          for(int i= 1; i<=n; i++){\\n              int K = k;\\n              int cur_max = 0;\\n              int cur_ans = 0;\\n              for(int K = 1; K <= k && i - K >= 0; K++){\\n                  cur_max = max(cur_max, arr[i-K]);\\n                  cur_ans = max(cur_ans, dp[i-K] + K * cur_max);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1862527,
                "title": "python-dp-explained-in-comments",
                "content": "```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\t\"\"\"\\n\\t\\tk=3\\n\\t   idx   [0]     [1]      [2]     [3]     [4] [5] [6]\\n\\t\\tarr = 1      15       7       9       2   5   10\\n\\t\\tdp    1   dp[0]+15 or \\n\\t\\t\\t\\t  15*2\\n\\t\\t\\t\\t\\t\\t   dp[1]+7 or\\n\\t\\t\\t\\t\\t\\t   dp[0]+15*2 or\\n\\t\\t\\t\\t\\t\\t   15*3\\n\\t\\t\\t... so ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i] = max(element from j to i)*(i-j)+dp[j-1] or\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i]\\n\\t\"\"\"\\n\\tdp = [0]*(len(arr))\\n\\tfor i in range(0, len(arr)):\\n\\t\\tfor j in range(i, max(i-k, -1), -1):\\n\\t\\t\\tnew_split = max(arr[j:i+1]) * (i-j+1)\\n\\t\\t\\tprev = dp[j-1] if j>0 else 0\\n\\t\\t\\tdp[i] = max(dp[i], prev +new_split)\\n\\treturn dp[-1]\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n\\t\"\"\"\\n\\t\\tk=3\\n\\t   idx   [0]     [1]      [2]     [3]     [4] [5] [6]\\n\\t\\tarr = 1      15       7       9       2   5   10\\n\\t\\tdp    1   dp[0]+15 or \\n\\t\\t\\t\\t  15*2\\n\\t\\t\\t\\t\\t\\t   dp[1]+7 or\\n\\t\\t\\t\\t\\t\\t   dp[0]+15*2 or\\n\\t\\t\\t\\t\\t\\t   15*3\\n\\t\\t\\t... so ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i] = max(element from j to i)*(i-j)+dp[j-1] or\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  dp[i]\\n\\t\"\"\"\\n\\tdp = [0]*(len(arr))\\n\\tfor i in range(0, len(arr)):\\n\\t\\tfor j in range(i, max(i-k, -1), -1):\\n\\t\\t\\tnew_split = max(arr[j:i+1]) * (i-j+1)\\n\\t\\t\\tprev = dp[j-1] if j>0 else 0\\n\\t\\t\\tdp[i] = max(dp[i], prev +new_split)\\n\\treturn dp[-1]\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1854834,
                "title": "c-memoization-solution-o-nk-time-complexity",
                "content": "```\\nclass Solution {\\nprivate:\\n    // memo[i] defines the largest sum starting from the ith index\\n    vector<int>memo;\\n    int solve(vector<int>&arr,int k,int index){\\n        if(index>=arr.size()){\\n            return 0;\\n        } else if(memo[index]!=-1){\\n            return memo[index];\\n        } else {\\n            int maxElement=arr[index];\\n            int ans=-1;\\n            //since we do not know what window size to take, we will brute force through all of them and store the maximum result\\n            for(int i=index;i<index+k and i<arr.size();i++){\\n                maxElement=max(maxElement,arr[i]);\\n                ans=max(ans,maxElement*(i-index+1)+solve(arr,k,i+1));\\n            }\\n            return memo[index]=ans;\\n        }\\n    }\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memo=vector<int>(arr.size(),-1);\\n        return solve(arr,k,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    // memo[i] defines the largest sum starting from the ith index\\n    vector<int>memo;\\n    int solve(vector<int>&arr,int k,int index){\\n        if(index>=arr.size()){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1816601,
                "title": "c-dp-bottom-up-approach-very-easy-to-understand",
                "content": "let suppose if we have one element in array than the answer will be arr[0];\\nthen we have to think if we have 2 element than what will be the answer.\\n\\nwe have to increase one by one element max maximize it.\\nfor first k element the answer will be k*max(arr[0],arr[1],,,,,arr[k[);\\n\\nthen we will start loop from k+1\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int t[n],m=arr[0];\\n        memset(t,-1,sizeof(t));\\n        for(int i=0;i<k;i++)\\n        {\\n            m= max(m,arr[i]); \\n            t[i] = m*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            m=0;\\n            for(int j = i;j>i-k;j--)\\n            {\\n                m = max(m,arr[j]);\\n                t[i] = max(t[i], m*(i-j+1)+ t[j-1]);\\n            }\\n        }\\n        return t[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int t[n],m=arr[0];\\n        memset(t,-1,sizeof(t));\\n        for(int i=0;i<k;i++)\\n        {\\n            m= max(m,arr[i]); \\n            t[i] = m*(i+1);\\n        }\\n        for(int i=k;i<n;i++)\\n        {\\n            m=0;\\n            for(int j = i;j>i-k;j--)\\n            {\\n                m = max(m,arr[j]);\\n                t[i] = max(t[i], m*(i-j+1)+ t[j-1]);\\n            }\\n        }\\n        return t[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732431,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            int currMax = 0;\\n            // the farthest position that can be impacted by index i is:   i - k + 1\\n            // therefore, we iterate dp[] from index     1 to i - k + 1  to find\\n            // the max partition method for dp[i]\\n            // if the current length of right subarray is j = 2. And, i = 5 (0-based index)\\n            // [1,2,3,4,5,6], k = 3\\n            //            i\\n            // then the farthest position can be impacted by index i is i - j + 1 = 4\\n            // rightMax is the max value of right subarray, which now is 6\\n            // then right subarray is rightMax * length of right subarray = 6 * 2 = 12\\n            // \\n            for (int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                currMax = Math.max(currMax, arr[i - j + 1]);\\n                int rightSub = currMax * j;\\n                if (i - j < 0) {\\n                    dp[i] = Math.max(dp[i], rightSub);\\n                } else {\\n                    dp[i] = Math.max(dp[i], dp[i - j] + rightSub);\\n                }\\n            }\\n        }\\n        return dp[arr.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            int currMax = 0;\\n            // the farthest position that can be impacted by index i is:   i - k + 1\\n            // therefore, we iterate dp[] from index     1 to i - k + 1  to find\\n            // the max partition method for dp[i]\\n            // if the current length of right subarray is j = 2. And, i = 5 (0-based index)\\n            // [1,2,3,4,5,6], k = 3\\n            //            i\\n            // then the farthest position can be impacted by index i is i - j + 1 = 4\\n            // rightMax is the max value of right subarray, which now is 6\\n            // then right subarray is rightMax * length of right subarray = 6 * 2 = 12\\n            // \\n            for (int j = 1; j <= k && i - j + 1 >= 0; j++) {\\n                currMax = Math.max(currMax, arr[i - j + 1]);\\n                int rightSub = currMax * j;\\n                if (i - j < 0) {\\n                    dp[i] = Math.max(dp[i], rightSub);\\n                } else {\\n                    dp[i] = Math.max(dp[i], dp[i - j] + rightSub);\\n                }\\n            }\\n        }\\n        return dp[arr.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708248,
                "title": "c-bottom-up-o-nk",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size() + 1);\\n        int n = arr.size();\\n        for (int i = n - 1; i >= 0; i--) {\\n            int mx = 0;\\n            for (int j = i; j < min(n, i + k); j++) {\\n                mx = max(mx, arr[j]);\\n                dp[i] = max(dp[i], dp[j + 1] + mx * (j - i + 1));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int> dp(arr.size() + 1);\\n        int n = arr.size();\\n        for (int i = n - 1; i >= 0; i--) {\\n            int mx = 0;\\n            for (int j = i; j < min(n, i + k); j++) {\\n                mx = max(mx, arr[j]);\\n                dp[i] = max(dp[i], dp[j + 1] + mx * (j - i + 1));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682466,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633061,
                "title": "python-simple-dp-10-lines",
                "content": "```\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(arr)\\n        dp = [0 for _ in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1, k+1):\\n                if i-j < 0:\\n                    break\\n                dp[i] = max(dp[i], dp[i-j] + max(arr[i-j:i])*j)\\n        return dp[n]",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(arr)\\n        dp = [0 for _ in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1, k+1):\\n                if i-j < 0:\\n                    break\\n                dp[i] = max(dp[i], dp[i-j] + max(arr[i-j:i])*j)\\n        return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 1533766,
                "title": "dp-python-code",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # DP dp[i] = max sum of arr[0] ~ arr[i-1]\\n        n = len(arr)\\n        dp = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            cur_max = arr[i-1]\\n            # pick the maximum for dp[i] when considering the last subarrry includes different numbers (1, 2, ... k)\\n            for j in range(1, k + 1):\\n                if i - j >= 0:\\n                    cur_max = max(cur_max, arr[i - j])\\n                    dp[i] = max(dp[i], dp[i-j] + j * cur_max)\\n        return dp[n]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # DP dp[i] = max sum of arr[0] ~ arr[i-1]\\n        n = len(arr)\\n        dp = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            cur_max = arr[i-1]\\n            # pick the maximum for dp[i] when considering the last subarrry includes different numbers (1, 2, ... k)\\n            for j in range(1, k + 1):\\n                if i - j >= 0:\\n                    cur_max = max(cur_max, arr[i - j])\\n                    dp[i] = max(dp[i], dp[i-j] + j * cur_max)\\n        return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 1530479,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(arr:tuple):\\n            if not arr:\\n                return 0\\n            \\n            ret = 0\\n            for i in range(1, min(k+1, len(arr)+1)):\\n                window = arr[:i]\\n                max_window = max(arr[:i])\\n                new_arr = tuple(arr[i:])\\n                \\n                ret = max(ret, max_window*i + helper(new_arr))\\n            \\n            return ret\\n        \\n        return helper(tuple(arr)) if k > 1 else sum(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @functools.lru_cache(None)\\n        def helper(arr:tuple):\\n            if not arr:\\n                return 0\\n            \\n            ret = 0\\n            for i in range(1, min(k+1, len(arr)+1)):\\n                window = arr[:i]\\n                max_window = max(arr[:i])\\n                new_arr = tuple(arr[i:])\\n                \\n                ret = max(ret, max_window*i + helper(new_arr))\\n            \\n            return ret\\n        \\n        return helper(tuple(arr)) if k > 1 else sum(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530159,
                "title": "java-easy-solution-bottom-up-dp-polynomial-time-complexity",
                "content": "```\\nclass Solution {\\n    \\n    \\n    \\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    \\n    \\n    int storage[];\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        storage=new int[arr.length];\\n        Arrays.fill(storage,Integer.MIN_VALUE);\\n        return solve(arr,k,0);\\n    }\\n    int solve(int data[],int k,int index){\\n        if(index>=data.length)\\n            return 0;\\n        \\n        if(storage[index]!=Integer.MIN_VALUE)\\n            return storage[index];\\n        \\n        int result=Integer.MIN_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=index;i<k+index&&i<data.length;i++){\\n            max=Math.max(max,data[i]);\\n            int right=solve(data,k,i+1);\\n            result=Math.max(result,max*(i-index+1)+right);\\n        }\\n        return storage[index]=result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482276,
                "title": "c-simple-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int > dp(arr.size(), 0);\\n        dp[0] = arr[0];\\n        for (int i = 1; i < arr.size(); ++i) {\\n            int max_v = 0;\\n            for (int j = 0; j < k && i - j >= 0; ++j) {\\n                max_v = std::max(max_v, arr[i - j]);\\n                int left_value = (i - j == 0 ? 0 : dp[i - j - 1]);\\n                dp[i] = std::max(dp[i], (left_value + max_v * (j + 1)));\\n            }\\n        }\\n        return dp[arr.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        vector<int > dp(arr.size(), 0);\\n        dp[0] = arr[0];\\n        for (int i = 1; i < arr.size(); ++i) {\\n            int max_v = 0;\\n            for (int j = 0; j < k && i - j >= 0; ++j) {\\n                max_v = std::max(max_v, arr[i - j]);\\n                int left_value = (i - j == 0 ? 0 : dp[i - j - 1]);\\n                dp[i] = std::max(dp[i], (left_value + max_v * (j + 1)));\\n            }\\n        }\\n        return dp[arr.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456159,
                "title": "simple-python-o-nk-dynamic-programming-solution",
                "content": "```Python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # let dp[i] denote the maximum sum for the \\n\\t\\t# first i elements of arr\\n\\t\\t# i.e arr[0]...arr[i-1]\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            window_max = 0\\n            for window_size in range(1, k+1):\\n                if i-window_size < 0: break\\n                window_max = max(window_max, arr[i-window_size])\\n                dp[i] = max(dp[i], dp[i-window_size]+window_max*window_size)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        # let dp[i] denote the maximum sum for the \\n\\t\\t# first i elements of arr\\n\\t\\t# i.e arr[0]...arr[i-1]\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(1, n+1):\\n            window_max = 0\\n            for window_size in range(1, k+1):\\n                if i-window_size < 0: break\\n                window_max = max(window_max, arr[i-window_size])\\n                dp[i] = max(dp[i], dp[i-window_size]+window_max*window_size)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452028,
                "title": "recursive-memo-dp-with-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/434e08db-cb69-47df-8f77-ac9583a44411_1631098683.8599129.jpeg)\\n\\n**Recursive**\\n```\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        return fun(arr,0,k);\\n    }\\n```\\n\\n**Memo**\\n```\\nvector<int>dp;\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    if(dp[i]!=-1)\\n    {\\n    return dp[i];\\n    }\\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return dp[i]=maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n         dp.resize(arr.size(),-1);\\n        return fun(arr,0,k);\\n    }\\n```\\n\\n**DP**\\n```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n    int dp[n+1];\\n        dp[n]=0;\\n    int maxoverall=0;\\n    for(int l=n;l>=0;l--)\\n    {\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=l+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=dp[tillarr+1];\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n       dp[l]=maxoverall;\\n}\\nreturn dp[0];\\n    }\\n\\n```\\n**upvote if this helps :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        return fun(arr,0,k);\\n    }\\n```\n```\\nvector<int>dp;\\nint fun(vector<int>arr,int i,int k)\\n{\\n    if(i==arr.size())\\n    return 0;\\n    \\n    if(dp[i]!=-1)\\n    {\\n    return dp[i];\\n    }\\n    int maxoverall=0;\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=i+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=fun(arr,tillarr+1,k);\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n    return dp[i]=maxoverall;\\n}\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n         dp.resize(arr.size(),-1);\\n        return fun(arr,0,k);\\n    }\\n```\n```\\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n=arr.size();\\n    int dp[n+1];\\n        dp[n]=0;\\n    int maxoverall=0;\\n    for(int l=n;l>=0;l--)\\n    {\\n    int maxtillk=0;\\n    for(int j=0;j<k;j++)\\n    {\\n        int tillarr=l+j;\\n        if(tillarr>=arr.size())\\n        break;\\n        maxtillk=max(maxtillk,arr[tillarr]);\\n        int left=maxtillk*(j+1);\\n        int right=dp[tillarr+1];\\n        maxoverall=max(maxoverall,left+right);\\n    }\\n       dp[l]=maxoverall;\\n}\\nreturn dp[0];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406284,
                "title": "python3-dynamic-programming",
                "content": "**the idea here is to form k length subarrays for each element and check for maximum sum. k length subarrays should be made using k-1 previous elements for any arr[i]. Simultaneously keep track of maximum element in that subarray.**\\n```\\n#TIME COMPLEXITY - O(N*k)\\n#SPACE COMPLEXITY - O(N)\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(len(arr)+1)]\\n        dp[0]=0\\n        for i in range(len(arr)):\\n            best,curr_max=0,0\\n            for j in range(min(k,i+1)):\\n                curr_max=max(curr_max,arr[i-j])\\n                best=max(best,dp[i-j]+curr_max*(j+1))\\n            dp[i+1]=best\\n        return dp[len(arr)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n#TIME COMPLEXITY - O(N*k)\\n#SPACE COMPLEXITY - O(N)\\nclass Solution(object):\\n    def maxSumAfterPartitioning(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(len(arr)+1)]\\n        dp[0]=0\\n        for i in range(len(arr)):\\n            best,curr_max=0,0\\n            for j in range(min(k,i+1)):\\n                curr_max=max(curr_max,arr[i-j])\\n                best=max(best,dp[i-j]+curr_max*(j+1))\\n            dp[i+1]=best\\n        return dp[len(arr)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352080,
                "title": "java-recursion-memoization-dp-3ms-beats-99-64-t-c-o-n-k-s-c-o-n",
                "content": "\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRec(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\treturn maxSumAfterPartitioningRecHelper(arr, k, 0, len);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRecHelper(int[] arr, int k, int si, int len) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningRecHelper(arr, k, si + i + 1, len);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemo(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tInteger[] memo = new Integer[len];\\n\\t\\treturn maxSumAfterPartitioningMemoHelper(arr, k, 0, len, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemoHelper(int[] arr, int k, int si, int len, Integer[] memo) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[si] != null)\\n\\t\\t\\treturn memo[si];\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningMemoHelper(arr, k, si + i + 1, len, memo);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\n\\t\\tmemo[si] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningBU(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tint[] dp = new int[len + 1];\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int j = 0; j < k && i + j < len; j++) {\\n\\t\\t\\t\\tif (arr[i + j] > max)\\n\\t\\t\\t\\t\\tmax = arr[i + j];\\n\\t\\t\\t\\tint sum = max * (j + 1) + dp[i + j + 1];\\n\\t\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\t\\tans = sum;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = ans;\\n\\t\\t}\\n\\n\\t\\treturn dp[0];\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRec(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\treturn maxSumAfterPartitioningRecHelper(arr, k, 0, len);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(k^n) O(n)\\n\\tpublic int maxSumAfterPartitioningRecHelper(int[] arr, int k, int si, int len) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningRecHelper(arr, k, si + i + 1, len);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemo(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tInteger[] memo = new Integer[len];\\n\\t\\treturn maxSumAfterPartitioningMemoHelper(arr, k, 0, len, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningMemoHelper(int[] arr, int k, int si, int len, Integer[] memo) {\\n\\n\\t\\tif (si == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[si] != null)\\n\\t\\t\\treturn memo[si];\\n\\n\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < k && si + i < len; i++) {\\n\\t\\t\\tmax = Math.max(max, arr[si + i]);\\n\\t\\t\\tint sum = max * (i + 1) + maxSumAfterPartitioningMemoHelper(arr, k, si + i + 1, len, memo);\\n\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\tans = sum;\\n\\t\\t}\\n\\n\\t\\tmemo[si] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n*k) O(n)\\n\\tpublic int maxSumAfterPartitioningBU(int[] arr, int k) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tint[] dp = new int[len + 1];\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint ans = Integer.MIN_VALUE, max = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int j = 0; j < k && i + j < len; j++) {\\n\\t\\t\\t\\tif (arr[i + j] > max)\\n\\t\\t\\t\\t\\tmax = arr[i + j];\\n\\t\\t\\t\\tint sum = max * (j + 1) + dp[i + j + 1];\\n\\t\\t\\t\\tif (sum > ans)\\n\\t\\t\\t\\t\\tans = sum;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = ans;\\n\\t\\t}\\n\\n\\t\\treturn dp[0];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1334993,
                "title": "simple-c-dp-memorization",
                "content": "class Solution {\\npublic:\\n    int dp[501];\\n    \\n    int helper(vector<int>&arr, int k , int start)\\n    {\\n        int n = arr.size(); \\n        int max_v = 0; \\n        if ( start >= n)\\n            return 0 ; \\n        int total=0;\\n        if ( dp[start]!=-1)\\n            return dp[start];\\n        for ( int i = start;  i<min(start+k, n); i++)\\n        {\\n    \\n                if (max_v < arr[i])\\n                {\\n                    max_v = arr[i];\\n                }\\n           int t ;\\n            t = max_v*(i-start+1) + helper(arr, k, i+1);\\n            if ( t > total)\\n                total = t; \\n        }\\n        \\n        return dp[start]=total; \\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(arr, k, 0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[501];\\n    \\n    int helper(vector<int>&arr, int k , int start)\\n    {\\n        int n = arr.size(); \\n        int max_v = 0; \\n        if ( start >= n)\\n            return 0 ; \\n        int total=0;\\n        if ( dp[start]!=-1)\\n            return dp[start];\\n        for ( int i = start;  i<min(start+k, n); i++)\\n        {\\n    \\n                if (max_v < arr[i])\\n                {\\n                    max_v = arr[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1300905,
                "title": "c-o-nk-time-o-n-space-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size(),maxx,j;\\n        vector<int> dp(n+1,0);\\n        \\n        for (int i=1;i<=n;i++)\\n        {\\n            maxx=arr[i-1];\\n            j=0;\\n            while(j<k && j<=i-1)\\n            {\\n                maxx=max(arr[i-j-1],maxx);\\n                dp[i]=max(dp[i],dp[i-j-1]+maxx*(j+1));\\n                j++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) \\n    {\\n        int n=arr.size(),maxx,j;\\n        vector<int> dp(n+1,0);\\n        \\n        for (int i=1;i<=n;i++)\\n        {\\n            maxx=arr[i-1];\\n            j=0;\\n            while(j<k && j<=i-1)\\n            {\\n                maxx=max(arr[i-j-1],maxx);\\n                dp[i]=max(dp[i],dp[i-j-1]+maxx*(j+1));\\n                j++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272029,
                "title": "easy-java-solution-top-down-approach",
                "content": "```\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        return solve(0, arr.length - 1,arr,k,dp);\\n\\n    }\\n    \\n    public static int solve(int start,int end,int[] arr, int k,int[] dp){\\n        if(start > end){\\n            return 0;\\n        }\\n        \\n        if(dp[start] != -1){\\n            return dp[start];\\n        }\\n        int max = arr[start];\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = start; i < start + k && i <= end; i++){\\n            max = Math.max(arr[i],max);\\n            //division\\n            int multiple = (i - start + 1);\\n            int temp = multiple * max;\\n            int x = temp + solve(i + 1, end,arr,k,dp);\\n            ans = Math.max(ans,x);\\n        }\\n        return dp[start] = ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        int[] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        return solve(0, arr.length - 1,arr,k,dp);\\n\\n    }\\n    \\n    public static int solve(int start,int end,int[] arr, int k,int[] dp){\\n        if(start > end){\\n            return 0;\\n        }\\n        \\n        if(dp[start] != -1){\\n            return dp[start];\\n        }\\n        int max = arr[start];\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = start; i < start + k && i <= end; i++){\\n            max = Math.max(arr[i],max);\\n            //division\\n            int multiple = (i - start + 1);\\n            int temp = multiple * max;\\n            int x = temp + solve(i + 1, end,arr,k,dp);\\n            ans = Math.max(ans,x);\\n        }\\n        return dp[start] = ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249233,
                "title": "c-dp-solution-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findmax(vector<int>& arr, int i, int j)\\n    {\\n        int ans = INT_MIN;\\n        for(int l=1; l<=j; l++)\\n        {\\n            ans = max(ans, arr[i-l]);\\n        }\\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i = 1, j=1; i <=k; i++,j++)\\n        {\\n            dp[i] = findmax(arr, i, j)*j;\\n        }\\n        for(int i=k+1; i<=n; i++)\\n        {\\n            dp[i] = 0;\\n            for(int j=1; j<=k; j++)\\n            {\\n                dp[i] = max(dp[i], (dp[i-j] + findmax(arr, i, j)*j));\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findmax(vector<int>& arr, int i, int j)\\n    {\\n        int ans = INT_MIN;\\n        for(int l=1; l<=j; l++)\\n        {\\n            ans = max(ans, arr[i-l]);\\n        }\\n        return ans;\\n    }\\n    int maxSumAfterPartitioning(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i = 1, j=1; i <=k; i++,j++)\\n        {\\n            dp[i] = findmax(arr, i, j)*j;\\n        }\\n        for(int i=k+1; i<=n; i++)\\n        {\\n            dp[i] = 0;\\n            for(int j=1; j<=k; j++)\\n            {\\n                dp[i] = max(dp[i], (dp[i-j] + findmax(arr, i, j)*j));\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247937,
                "title": "clarification",
                "content": "Can someone please clarify this Example 2 which is part of the description?\\n```\\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\\nOutput: 83\\n```\\nI can create sub arrays like this which satisfies the requirement.\\n`[5,7,7,7,7,9,9,9,9,9,9]`  It returns the sum of 87. Not 83.\\n\\nI am seeing I have misunderstood the problem. I do not know where!!",
                "solutionTags": [],
                "code": "```\\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\\nOutput: 83\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1243882,
                "title": "c-bottom-up",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumAfterPartitioning(const vector<int>& arr, int k)\\n    {\\n        const int N = arr.size();\\n        if (N <= k)\\n        {\\n            return *max_element(arr.begin(), arr.end())*N;\\n        }\\n        \\n        vector<int> cache(N);\\n        \\n        int curMax = 0;\\n        for (int i = 0; i < k; ++i)\\n        {\\n            curMax = max(curMax, arr[i]);\\n            cache[i] = (i+1)*curMax;\\n        }\\n        \\n        int maxSum = 0;        \\n        for (int i = k; i < N; ++i)\\n        {\\n            curMax = 0;\\n            maxSum = 0;\\n            \\n            for (int j = i; j > i-k; --j)\\n            {\\n                curMax = max(curMax, arr[j]);\\n                maxSum = max(maxSum, (i-j+1)*curMax + cache[j-1]);\\n            }\\n            cache[i] = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumAfterPartitioning(const vector<int>& arr, int k)\\n    {\\n        const int N = arr.size();\\n        if (N <= k)\\n        {\\n            return *max_element(arr.begin(), arr.end())*N;\\n        }\\n        \\n        vector<int> cache(N);\\n        \\n        int curMax = 0;\\n        for (int i = 0; i < k; ++i)\\n        {\\n            curMax = max(curMax, arr[i]);\\n            cache[i] = (i+1)*curMax;\\n        }\\n        \\n        int maxSum = 0;        \\n        for (int i = k; i < N; ++i)\\n        {\\n            curMax = 0;\\n            maxSum = 0;\\n            \\n            for (int j = i; j > i-k; --j)\\n            {\\n                curMax = max(curMax, arr[j]);\\n                maxSum = max(maxSum, (i-j+1)*curMax + cache[j-1]);\\n            }\\n            cache[i] = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237443,
                "title": "java-dp-top-down-with-memoization-and-bottom-up",
                "content": "```\\n// DP Top Down with Memoization\\n// During each recursive call, try the partition sizes from 1 to K\\n// Track the max value in the current partition\\n// Track the max result of partition sum of max values + recursive call\\n// Time: O(N*K)\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] memo = new int[n];\\n    Arrays.fill(memo, -1);\\n    return maxSumAfterPartitioning(arr, k, memo, 0);\\n  }\\n  private int maxSumAfterPartitioning(int[] arr, int k, int[] memo, int start) {\\n    int n = arr.length;\\n    if (start == n)\\n      return 0;\\n    if (memo[start] != -1)\\n      return memo[start];\\n    \\n    int maxResult = 0;\\n    int maxVal = 0;\\n    int sum = 0;\\n    for (int i = start; i < start + k && i < n; i++) {\\n      maxVal = Math.max(arr[i], maxVal);\\n      int result = maxVal * (i - start + 1) + maxSumAfterPartitioning(arr, k, memo, i + 1);\\n      maxResult = Math.max(result, maxResult);\\n    }\\n    memo[start] = maxResult;\\n    return maxResult;\\n  }\\n}\\n\\n\\n// DP - Bottom Up\\n// Time: O(N*K)\\n// 4 ms, faster than 92.98%\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] dp = new int[n+1];\\n\\n    for (int start = n - 1; start >= 0; start--) {\\n      int maxVal = 0;\\n      int maxResult = 0;\\n      for (int j = 0; j < k && start + j < n; j++) {\\n        maxVal = Math.max(arr[start+j], maxVal);\\n        int result = maxVal * (j + 1) + dp[start+j+1];\\n        maxResult = Math.max(result, maxResult);\\n      }\\n      dp[start] = maxResult;\\n    }\\n    return dp[0];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// DP Top Down with Memoization\\n// During each recursive call, try the partition sizes from 1 to K\\n// Track the max value in the current partition\\n// Track the max result of partition sum of max values + recursive call\\n// Time: O(N*K)\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] memo = new int[n];\\n    Arrays.fill(memo, -1);\\n    return maxSumAfterPartitioning(arr, k, memo, 0);\\n  }\\n  private int maxSumAfterPartitioning(int[] arr, int k, int[] memo, int start) {\\n    int n = arr.length;\\n    if (start == n)\\n      return 0;\\n    if (memo[start] != -1)\\n      return memo[start];\\n    \\n    int maxResult = 0;\\n    int maxVal = 0;\\n    int sum = 0;\\n    for (int i = start; i < start + k && i < n; i++) {\\n      maxVal = Math.max(arr[i], maxVal);\\n      int result = maxVal * (i - start + 1) + maxSumAfterPartitioning(arr, k, memo, i + 1);\\n      maxResult = Math.max(result, maxResult);\\n    }\\n    memo[start] = maxResult;\\n    return maxResult;\\n  }\\n}\\n\\n\\n// DP - Bottom Up\\n// Time: O(N*K)\\n// 4 ms, faster than 92.98%\\nclass Solution {\\n  public int maxSumAfterPartitioning(int[] arr, int k) {\\n    int n = arr.length;\\n    int[] dp = new int[n+1];\\n\\n    for (int start = n - 1; start >= 0; start--) {\\n      int maxVal = 0;\\n      int maxResult = 0;\\n      for (int j = 0; j < k && start + j < n; j++) {\\n        maxVal = Math.max(arr[start+j], maxVal);\\n        int result = maxVal * (j + 1) + dp[start+j+1];\\n        maxResult = Math.max(result, maxResult);\\n      }\\n      dp[start] = maxResult;\\n    }\\n    return dp[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226080,
                "title": "c-easy-to-understand",
                "content": "The idea is simple, check all partion cases for arr[i] and get max value\\n```\\nclass Solution {\\npublic:\\n    int dp[501];\\n    int largest(int start, int end, vector<int> arr ){\\n        int result=0;\\n        for(int i=start; i<=end; i++){\\n            result=max(result, arr[i]);\\n        }\\n        return result;\\n    }\\n \\n    int arr1[501];\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        dp[0]=arr[0];\\n        for(int i=0; i<arr.size(); i++){\\n            arr1[i]=arr[i];\\n        }\\n         \\n        for(int i=1; i<arr.size(); i++){\\n            dp[i]=arr[i]+dp[i-1];\\n        }\\n        for(int i=1; i<arr.size(); i++){\\n            for (int j=k; j>=1; j--){\\n                if(i-j>=0){\\n                    dp[i]=max(dp[i],dp[i-j]+j*(*max_element(arr1+i-j+1, arr1+i+1)));\\n                }\\n                else if(i-j==-1){\\n                    dp[i]=max(dp[i],j*(*max_element(arr1+i-j+1, arr1 + i+1)));\\n                }\\n            }\\n        }\\n        return dp[arr.size()-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[501];\\n    int largest(int start, int end, vector<int> arr ){\\n        int result=0;\\n        for(int i=start; i<=end; i++){\\n            result=max(result, arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1223864,
                "title": "cpp-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = (int)arr.size();\\n        int dp[n+1];\\n        dp[n] = 0;\\n        dp[n-1] = arr[n-1];\\n        for(int i = n-2;i >= 0;i--)\\n        {\\n            int temp = arr[i];\\n            dp[i] = INT_MIN;\\n            for(int j = 1;((i + j - 1 < n)&&(j <= k));j++)\\n            {\\n                temp = max(temp,arr[i+j-1]);\\n                dp[i] = max(dp[i],temp*j + dp[i+j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int n = (int)arr.size();\\n        int dp[n+1];\\n        dp[n] = 0;\\n        dp[n-1] = arr[n-1];\\n        for(int i = n-2;i >= 0;i--)\\n        {\\n            int temp = arr[i];\\n            dp[i] = INT_MIN;\\n            for(int j = 1;((i + j - 1 < n)&&(j <= k));j++)\\n            {\\n                temp = max(temp,arr[i+j-1]);\\n                dp[i] = max(dp[i],temp*j + dp[i+j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223707,
                "title": "recursion-with-memoisation-c-well-explained",
                "content": "Try to think of absolute bruteforce.\\nEx. [1,15,7,9,2,5,10], k = 3\\n\\nThe possible partitions to start with can be\\nCase 1: 1   |    15,7, 9, 2...\\nCase 2: 1,15 |   7,9,2,5,10\\nCase 3: 1 15 7 |  9 2 5 10\\n\\nans for Case 1: maxElement of left Partition * number of elements in left partition added to the solution of the array beggining at 15 (i.e. 15,7, 9, 2...)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& arr, int k, int ind, vector<int> &dp){\\n        \\n        int n = arr.size();\\n        // if you reached end of the array then the right side of the partition yeilds a 0 sum\\n        if(ind == n) return 0;\\n        \\n        //if the value is precalculated dont calculate again\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        // initialise variable to calculate ans\\n        int ans = INT_MIN;\\n        // end indicates till which index you can have the partition \\n        int end = min(n, ind+k);\\n        \\n        // maxElement is used to store the maxElement in the left partition\\n        int maxElement = -1;\\n        // iterate for all possible partitions\\n        for(int i = ind; i < end; i++){\\n            //update the max element\\n            maxElement = max(arr[i], maxElement);\\n            // calculate sum of elements to left of partition \\n            int sumLeft = (i - ind + 1)* (maxElement);\\n            // calculate the ans if you chose this partition\\n            int ansForPartition = sumLeft + solve(arr, k, i + 1, dp);\\n            ans = max(ans, ansForPartition);\\n        }\\n        \\n        return dp[ind] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int ind = 0;\\n        vector<int> dp(501, -1);\\n        return solve(arr, k, ind, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& arr, int k, int ind, vector<int> &dp){\\n        \\n        int n = arr.size();\\n        // if you reached end of the array then the right side of the partition yeilds a 0 sum\\n        if(ind == n) return 0;\\n        \\n        //if the value is precalculated dont calculate again\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        // initialise variable to calculate ans\\n        int ans = INT_MIN;\\n        // end indicates till which index you can have the partition \\n        int end = min(n, ind+k);\\n        \\n        // maxElement is used to store the maxElement in the left partition\\n        int maxElement = -1;\\n        // iterate for all possible partitions\\n        for(int i = ind; i < end; i++){\\n            //update the max element\\n            maxElement = max(arr[i], maxElement);\\n            // calculate sum of elements to left of partition \\n            int sumLeft = (i - ind + 1)* (maxElement);\\n            // calculate the ans if you chose this partition\\n            int ansForPartition = sumLeft + solve(arr, k, i + 1, dp);\\n            ans = max(ans, ansForPartition);\\n        }\\n        \\n        return dp[ind] = ans;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        int ind = 0;\\n        vector<int> dp(501, -1);\\n        return solve(arr, k, ind, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171472,
                "title": "easy-to-understand-solution-using-memoization-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector <int> cache;\\npublic:\\n    int partition(vector <int> &arr, int idx, int k) {\\n        if(idx >= arr.size()) return 0;\\n        if(cache[idx] != -1) return cache[idx];\\n        \\n        int s = 0, n = arr.size(), maxVal = arr[idx];\\n        for(int i = idx; i < min((idx + k), n); i++) {\\n            int l = idx, r = i, len = r - l + 1;\\n            maxVal = max(maxVal, arr[i]);\\n            \\n            s = max(s, maxVal*len + partition(arr, i + 1, k));\\n        }\\n        \\n        return cache[idx] = s;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        cache.resize(arr.size(), -1);\\n        return partition(arr, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector <int> cache;\\npublic:\\n    int partition(vector <int> &arr, int idx, int k) {\\n        if(idx >= arr.size()) return 0;\\n        if(cache[idx] != -1) return cache[idx];\\n        \\n        int s = 0, n = arr.size(), maxVal = arr[idx];\\n        for(int i = idx; i < min((idx + k), n); i++) {\\n            int l = idx, r = i, len = r - l + 1;\\n            maxVal = max(maxVal, arr[i]);\\n            \\n            s = max(s, maxVal*len + partition(arr, i + 1, k));\\n        }\\n        \\n        return cache[idx] = s;\\n    }\\n    \\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\\n        cache.resize(arr.size(), -1);\\n        return partition(arr, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168564,
                "title": "java-dp-memoization",
                "content": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        int dp[] = new int[arr.length];\\n        \\n        Arrays.fill(dp, -1);\\n        \\n        return helper(arr, k, 0, dp);\\n    }\\n    \\n    private int helper(int[] arr, int k, int curr,int[] dp){\\n        \\n        if(curr >= arr.length)\\n            return 0;\\n        \\n        if(dp[curr] != -1)\\n            return dp[curr];\\n        \\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=curr ; i<curr+k ; ++i){\\n            if(i >= arr.length)\\n                break;\\n            \\n            count++;\\n            max = Math.max(max, arr[i]);\\n            \\n            ans = Math.max(ans, max*count + helper(arr, k, i+1, dp));\\n        }\\n        \\n        dp[curr] = ans;\\n        return dp[curr];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumAfterPartitioning(int[] arr, int k) {\\n        \\n        int dp[] = new int[arr.length];\\n        \\n        Arrays.fill(dp, -1);\\n        \\n        return helper(arr, k, 0, dp);\\n    }\\n    \\n    private int helper(int[] arr, int k, int curr,int[] dp){\\n        \\n        if(curr >= arr.length)\\n            return 0;\\n        \\n        if(dp[curr] != -1)\\n            return dp[curr];\\n        \\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=curr ; i<curr+k ; ++i){\\n            if(i >= arr.length)\\n                break;\\n            \\n            count++;\\n            max = Math.max(max, arr[i]);\\n            \\n            ans = Math.max(ans, max*count + helper(arr, k, i+1, dp));\\n        }\\n        \\n        dp[curr] = ans;\\n        return dp[curr];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153946,
                "title": "dp",
                "content": "**Down to top, iterative:** time `O(N*k)` space `O(N)`\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/8e9fe6a8-08bf-4b52-b998-48683a18ddcf_1618229699.9158788.png)\\n\\n<br>\\n\\n```\\nint maxSumAfterPartitioning(vector<int>& a, int k) \\n{\\n    vector v(size(a)+1, 0);       // int v[501]={0};\\n    for(int i(size(a)-1); i>=0; --i)\\n        for(auto j(i), m(-1); j<size(a) and j-i<k; ++j)\\n            v[i] = max(v[i], (j-i+1)*(m=max(m, a[j])) + v[j+1]);\\n    return v[0];\\n}\\n```\\n**Top to down, recursive (memoization, helper):** time `O(N*k)` space `O(N)`\\n```\\nclass Solution \\n{\\n    vector<int> um;\\n\\n    int f(vector<int>& a, int k, int i) \\n    {\\n        int out{-1};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um[j+1]==-1) um[j+1] = f(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\npublic:    \\n    int maxSumAfterPartitioning(vector<int>& a, int k) \\n    {\\n        um.assign(size(a)+1, -1);\\n\\t\\tum.back()=0;\\n        return f(a, k, 0);\\n    }\\n};\\n```\\n**Top to down, recursive (memoization, no helper):** time `O(N*k)` space `O(N)`\\n```\\nclass Solution \\n{\\n    unordered_map<int, int> um;\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k, int i=0) \\n    {\\n        int out{0};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um.find(j+1)==end(um)) um[j+1] = maxSumAfterPartitioning(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSumAfterPartitioning(vector<int>& a, int k) \\n{\\n    vector v(size(a)+1, 0);       // int v[501]={0};\\n    for(int i(size(a)-1); i>=0; --i)\\n        for(auto j(i), m(-1); j<size(a) and j-i<k; ++j)\\n            v[i] = max(v[i], (j-i+1)*(m=max(m, a[j])) + v[j+1]);\\n    return v[0];\\n}\\n```\n```\\nclass Solution \\n{\\n    vector<int> um;\\n\\n    int f(vector<int>& a, int k, int i) \\n    {\\n        int out{-1};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um[j+1]==-1) um[j+1] = f(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\npublic:    \\n    int maxSumAfterPartitioning(vector<int>& a, int k) \\n    {\\n        um.assign(size(a)+1, -1);\\n\\t\\tum.back()=0;\\n        return f(a, k, 0);\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    unordered_map<int, int> um;\\npublic:\\n    int maxSumAfterPartitioning(vector<int>& a, int k, int i=0) \\n    {\\n        int out{0};\\n        for(auto j{i}, m{-1}; j<size(a) and j-i<k; ++j)\\n        {\\n            if(um.find(j+1)==end(um)) um[j+1] = maxSumAfterPartitioning(a, k, j+1);\\n\\t\\t\\tm   = max(m, a[j]);\\n            out = max(out, (j-i+1)*m + um[j+1]);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564665,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567542,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1565397,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567614,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566335,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566896,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575451,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1570889,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575356,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567385,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1564665,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567542,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1565397,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567614,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566335,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1566896,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575451,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1570889,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1575356,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1567385,
                "content": [
                    {
                        "username": "girishiitj",
                        "content": "Shouldn\\'t this problem come under DP instead of Graph?"
                    },
                    {
                        "username": "ishujain18123",
                        "content": "WHAT DOES THE QUESTION ACTUALLY WANTS US TO DO?\\nEVEN THE EXAMPLE SEEMS TO BE ODD."
                    },
                    {
                        "username": "JavaGoPython",
                        "content": "wonder why the problem was tagged as graph problem? all popular solutions are solved in DP."
                    },
                    {
                        "username": "kakkarotssj",
                        "content": "Input: arr = [1,15,7,9,2,5,10], k = 3\\nOutput: 84\\nExplanation: arr becomes [15,15,15,9,10,10,10]\\nHow this happens ?"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "[@JoshiMansi](/JoshiMansi) Thank you, your explanation made this task clear to me"
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "You can get 3 subarrays (each containing max k=3 elements) for this arr - [1,15,7] , [9] , [2,5,10] Now according to the ques all the elements of a subarray will be replaced by the max value in that subarray. So now your subarrays become - [15,15,15] , [9] , [10,10,10] which sums total to 84"
                    },
                    {
                        "username": "Balajanovski",
                        "content": "The title speaks for itself.\\nThis is a dynamic programming problem."
                    },
                    {
                        "username": "leetcoderbugbounty93",
                        "content": "Here\\'s the answer:\\n\\nInput: A = [1,15,7,9,2,5,10], K = 3\\nOutput: 84\\nExplanation: A becomes [15,15,15,9,10,10,10]\\n\\nhowever, why can\\'t it be:\\n  [15,15,15,15,15,5,10] which would give 90, which is greater than 84?\\n  \\n  thanks!\\n  \\n  nevermind. thought k meant # of partitions, not length of partitions\\n"
                    },
                    {
                        "username": "Shagun_agl",
                        "content": "is it really medium?? it should be in hard section :((\\n"
                    },
                    {
                        "username": "wisesaint",
                        "content": "Why O(n^3) solution is giving TLE?\\nLength of array is <= 500.\\nHow many operations per second does LeetCode allow?"
                    },
                    {
                        "username": "Anshul_Dishoriya",
                        "content": "1e8 iterations "
                    },
                    {
                        "username": "user1964l",
                        "content": "Can someone please explain the first testcase!"
                    },
                    {
                        "username": "asofihjqflkjlajksdflk",
                        "content": "\"you partition the array into (contiguous) subarrays of length at most K\"...\\n\\nIf K is 3, then partitioning into contiguous subarrays means also partitioning in to subarrays of length, 2, and 1, and 0.  At this point the question becomes absurd, because there is no max for a subarray of length 0.\\n\\nAfter looking at others solutions it seems that the i-th max should be calculated by taking the previous k elements of the array, unless to do so would run off the front of the array.  The description could use some tidying up."
                    }
                ]
            },
            {
                "id": 1568598,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1574753,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1573612,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 2018095,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1907058,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1835377,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1813878,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1789096,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1770356,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            },
            {
                "id": 1762133,
                "content": [
                    {
                        "username": "ashitranjan1402",
                        "content": "Is it just that you need more and more practice to come across similar questions. I just cant get along with the intuition."
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "If anyone wants question similar to this,i\\'d highly recommend to solve this question from Codechef\\nhttps://www.codechef.com/AUG20B/problems/CHEFWED \\ni am pretty sure those who struggle with this type of DP\\'s will benefit after solving this question on their own"
                    },
                    {
                        "username": "ankitpahwa111",
                        "content": "it\\'s a dp question easily visible , but couldn\\'t think of a graph solution , please help if you know one.\\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "Can someone please explain me example 2? [@ashitranjan1402](/ashitranjan1402)"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@JoshiMansi](/JoshiMansi) okayyyyy got it! Thanks a lot!!! "
                    },
                    {
                        "username": "JoshiMansi",
                        "content": "Array will be partitioned as - [[1] , [4,1,5,7] , [3,6,1,9] , [9,3]] This will then become - [[1] , [7,7,7,7] , [9,9,9,9] , [9,9]] So total sum = 83 . Or you could also partition it as - [[1,4] , [1,5,7] , [3,6,1,9] , [9,3]] this will also sum to 83"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "is anyone getting memory limit exceeded in the 43rd test case, idk why i even optimized my solution to 1-d dp aray"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": " def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        path = arr[:]\n        ans = []\n        if k == 1:\n            return sum(arr)\n        def recur(i, path):\n            nonlocal ans\n            if i >= len(arr):\n                ans.append(sum(path))\n                return\n            recur(i+1, path)\n            if (i + k) - 1 < len(arr):\n                maxi = max(arr[i: i+k])\n                for j in range(i, i+k):\n                    path[j] = maxi\n                recur((i+k) - 1, path) \n            return\n        recur(0, path)\n        return max(ans).\nCan someone tell me why this gives wrong ans and how can i makes changes in this code?"
                    },
                    {
                        "username": "shivansh961",
                        "content": "A good question of front Partition."
                    },
                    {
                        "username": "zenCoder69",
                        "content": "why medium T-T"
                    },
                    {
                        "username": "qingqianq",
                        "content": "Takes me all the afternoon to notice partition the array into (contiguous) subarrays of length at most k is not  partition the array into k parts."
                    },
                    {
                        "username": "Memberberry",
                        "content": "How is this test case 83 and not 84?\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nresulting arr should be [7,7,7,7,7,7,6,9,9,9,9] no?\n\nnevermind, k is the max length, not # of partitions. Same mistake as leetcoderbugbounty93\n"
                    },
                    {
                        "username": "tsahu9461",
                        "content": "[@rawatvishal](/rawatvishal)  howww??? k = 4 so how can there be 5 7s?? plz help\\n"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nDuplicates allow you to create your own subarrays. It's confusing. [[1][7777][9999][99]]"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "it should be [7 7 7 7 7 3 9 9 9 9 9]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Suffix Flips",
        "question_content": "<p>You are given a <strong>0-indexed</strong> binary string <code>target</code> of length <code>n</code>. You have another binary string <code>s</code> of length <code>n</code> that is initially set to all zeros. You want to make <code>s</code> equal to <code>target</code>.</p>\n\n<p>In one operation, you can pick an index <code>i</code> where <code>0 &lt;= i &lt; n</code> and flip all bits in the <strong>inclusive</strong> range <code>[i, n - 1]</code>. Flip means changing <code>&#39;0&#39;</code> to <code>&#39;1&#39;</code> and <code>&#39;1&#39;</code> to <code>&#39;0&#39;</code>.</p>\n\n<p>Return <em>the minimum number of operations needed to make </em><code>s</code><em> equal to </em><code>target</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = &quot;10111&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Initially, s = &quot;00000&quot;.\nChoose index i = 2: &quot;00<u>000</u>&quot; -&gt; &quot;00<u>111</u>&quot;\nChoose index i = 0: &quot;<u>00111</u>&quot; -&gt; &quot;<u>11000</u>&quot;\nChoose index i = 1: &quot;1<u>1000</u>&quot; -&gt; &quot;1<u>0111</u>&quot;\nWe need at least 3 flip operations to form target.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = &quot;101&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Initially, s = &quot;000&quot;.\nChoose index i = 0: &quot;<u>000</u>&quot; -&gt; &quot;<u>111</u>&quot;\nChoose index i = 1: &quot;1<u>11</u>&quot; -&gt; &quot;1<u>00</u>&quot;\nChoose index i = 2: &quot;10<u>0</u>&quot; -&gt; &quot;10<u>1</u>&quot;\nWe need at least 3 flip operations to form target.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = &quot;00000&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We do not need any operations since the initial s already equals target.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>target[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 755939,
                "title": "c-python-java-readable-easy-code-with-explanation-code-comments",
                "content": "**Key idea**\\nFlip is a must when current status of the bulbs and target status are not same.\\n\\nInitially all bulbs are at 0 and when a bulb at index i is flipped, everything that comes after that gets flipped. So it only makes sense to keep getting the status of the bulbs correct from left to right. \\n\\nWe will keep track of the status of the bulbs as we make flips.\\n\\nInitially all bulbs are 0, so say status = 0.\\nBulb 0 is 0 initially. \\n1. If we want it to be 0, we don\\'t have to make a flip.\\n2. If we want it to be 1, we must make a flip. This will change the status of remaining bulbs and they will be ON i.e. 1, so we will also make status as 1.\\nWhenever we see the status to be different from what the target is, we must make a flip and this will also change the status of remaining bulbs.\\n\\n**Thanks**\\nPlease upvote if you like it -\\n1. It encourages me to write on Leetcode and on my blog/website. \\n2. Learners get to see the post at the top.\\n2. It stays at the top so even if people downvote it, it carries little effect. Its so annoying really.\\n\\nThank you :)\\n\\n**More**\\nWell, if you find this helpful, you will likely find my blog helpful. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.size();                          // Total bulbs.\\n        int flips = 0;                                  // Final answer.\\n        char status = \\'0\\';                              // This stores the status of bulbs that are\\n                                                        // ahead of current index `i`.\\n        for (int i=0; i<n; i++) {                       // For each bulb =\\n            if (status != target[i]) {                  // If what we want is different from what\\n                                                        // it is at this moment, make a flip.\\n                flips++;                                // We made a flip.\\n                status = status == \\'0\\' ?  \\'1\\' : \\'0\\';    // Now status of remaining\\n                                                        // bulbs have changed.\\n            }\\n        }\\n        return flips; // Awesome, return the answer now.\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        flips = 0\\n        status = \\'0\\'\\n        for c in target:\\n            if c != status:\\n                flips += 1\\n                status = \\'0\\' if status == \\'1\\' else \\'1\\'\\n        return flips\\n        \\n```\\n**Java**\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int n = target.length();\\n        int flips = 0;\\n        char status = \\'0\\';\\n        for (int i = 0; i < n; i++) {\\n            if (status != target.charAt(i)) {\\n                flips++;\\n            }\\n            status = flips % 2 == 1 ? \\'1\\' : \\'0\\'; \\n        }\\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.size();                          // Total bulbs.\\n        int flips = 0;                                  // Final answer.\\n        char status = \\'0\\';                              // This stores the status of bulbs that are\\n                                                        // ahead of current index `i`.\\n        for (int i=0; i<n; i++) {                       // For each bulb =\\n            if (status != target[i]) {                  // If what we want is different from what\\n                                                        // it is at this moment, make a flip.\\n                flips++;                                // We made a flip.\\n                status = status == \\'0\\' ?  \\'1\\' : \\'0\\';    // Now status of remaining\\n                                                        // bulbs have changed.\\n            }\\n        }\\n        return flips; // Awesome, return the answer now.\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        flips = 0\\n        status = \\'0\\'\\n        for c in target:\\n            if c != status:\\n                flips += 1\\n                status = \\'0\\' if status == \\'1\\' else \\'1\\'\\n        return flips\\n        \\n```\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int n = target.length();\\n        int flips = 0;\\n        char status = \\'0\\';\\n        for (int i = 0; i < n; i++) {\\n            if (status != target.charAt(i)) {\\n                flips++;\\n            }\\n            status = flips % 2 == 1 ? \\'1\\' : \\'0\\'; \\n        }\\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755843,
                "title": "c-java-o-n",
                "content": "**Intuition**\\nThe order of bit operations does not matter. Go from left to right, switching bulbs greedily.\\n\\nSimilar question: [995. Minimum Number of K Consecutive Bit Flips](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/). I provided more detailed explanations in [my solution there](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/239284/C%2B%2B-greedy-stack-and-O(1)-memory).\\n\\n**Algorithm**\\nGo from left to right, tracking `state` of the remaining bulbs. When a bulb does not match the state, we change the state and increment the result.\\n\\nExample:\\n```\\nBulbs: [0, 1, 1, 0, 1, 1]\\nState:  0 !1  1 !0 !1  1\\nResult: 0  1  1  2  3  3\\n```\\nThis corresponds to these underlying three transitions: \\n```\\n[0, 0, 0, 0, 0, 0] => [0, 1, 1, 1, 1, 1] => [0, 1, 1, 0, 0, 0] => [0, 1, 1, 0, 1, 1]\\n```\\n\\n**C++**\\n```cpp\\nint minFlips(string target) {\\n    int cnt = 0, state = 0;\\n    for (auto b : target)\\n        if (b - \\'0\\' != state) {\\n            state = b - \\'0\\';\\n            ++cnt;\\n        }\\n    return cnt;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int minFlips(String target) {\\n    int cnt = 0, state = 0;\\n    for (var b : target.toCharArray())\\n        if (b - \\'0\\' != state) {\\n            state = b - \\'0\\';\\n            ++cnt;\\n        }\\n    return cnt;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1)",
                "solutionTags": [],
                "code": "```\\nBulbs: [0, 1, 1, 0, 1, 1]\\nState:  0 !1  1 !0 !1  1\\nResult: 0  1  1  2  3  3\\n```\n```\\n[0, 0, 0, 0, 0, 0] => [0, 1, 1, 1, 1, 1] => [0, 1, 1, 0, 0, 0] => [0, 1, 1, 0, 1, 1]\\n```\n```cpp\\nint minFlips(string target) {\\n    int cnt = 0, state = 0;\\n    for (auto b : target)\\n        if (b - \\'0\\' != state) {\\n            state = b - \\'0\\';\\n            ++cnt;\\n        }\\n    return cnt;\\n}\\n```\n```java\\npublic int minFlips(String target) {\\n    int cnt = 0, state = 0;\\n    for (var b : target.toCharArray())\\n        if (b - \\'0\\' != state) {\\n            state = b - \\'0\\';\\n            ++cnt;\\n        }\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755782,
                "title": "java-1-loop-o-n",
                "content": "switch from head of the array, every time next value is different with prev value, you need to flip again.\\ninit prev as \\u20180\\u2019.\\n```\\n    public int minFlips(String target) {\\n        char prev = \\'0\\';\\n        int res = 0;\\n        for (char c : target.toCharArray()) {\\n            if (c != prev) {\\n                prev = c;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int minFlips(String target) {\\n        char prev = \\'0\\';\\n        int res = 0;\\n        for (char c : target.toCharArray()) {\\n            if (c != prev) {\\n                prev = c;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871346,
                "title": "java-c-python-easy-and-concise",
                "content": "I was asked the question [995. Minimum Number of K Consecutive Bit Flips](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/?currentPage=1&orderBy=most_votes&query=)\\nSo I gave this problem as a good warm up.\\nNot satisfy with the current top voted discuss, \\nso I added up mine.\\n<br>\\n\\n# **Intuition**\\nGreedy solution. Need some observation.\\n<br>\\n\\n# Solution 1:\\nThe first observation is,\\nA[0] will only be flipped if i = 0.\\nSo if A[0] is 1 at first, we have to flip at i = 0.\\nres++.\\n\\nFor A[1], A[1] will be flipped if i = 0 or i = 1.\\nNow we already know the operation at i = 0,\\nA[1] will only be flipped if i = 1.\\n\\nThe rule is,\\nIf `res` is odd, the current bit is flipped.\\nIf `res` is even, the current bit stays no change.\\nif A[i] is 1, need to be flipped,\\nif A[i] is 0, not need to flip.\\nWe keep doing that, and we can know the all operations for each i.\\n\\ntime complexity `O(N)`,\\nspace complexity `O(1)`\\n\\n<br>\\n\\n**Java:**\\n```java\\n    public int minFlips(String A) {\\n        int res = 0, n = A.length();\\n        for (int i = 0; i < n; ++i)\\n            if (res % 2 != A.charAt(i) - \\'0\\')\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int minFlips(string A) {\\n        int res = 0;\\n        for (auto a: A)\\n            if (res % 2 != a - \\'0\\')\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def minFlips(self, target):\\n        res = 0\\n        for c in target:\\n            if res % 2 != int(c):\\n                res += 1\\n        return res\\n```\\n<br>\\n\\n# Solution 2\\nThe second observation is,\\nThe result of `A[i] == A[i+1]` won\\'t change,\\nunless we flip at `i + 1`.\\n\\nSo we just need to count the number of `A[i] != A[i+1]`,\\nit equals the number of flip to make all 1s or all 0s.\\n\\nNow we flip all bits to A[0].\\nIf `A[0] == \\'1\\'`, we need on more flip,\\nso I initilize `res = int(A[0])`\\n\\n**Java:**\\n```java\\n    public int minFlips(String A) {\\n        int res = A.charAt(0) - \\'0\\', n = A.length();\\n        for (int i = 1; i < n; ++i)\\n            if (A.charAt(i) != A.charAt(i - 1))\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int minFlips(string A) {\\n        int res = A[0] - \\'0\\', n = A.length();\\n        for (int i = 1; i < n; ++i)\\n            res += A[i - 1] != A[i];\\n        return res;\\n    }\\n```\\n**Python 1-line**\\nspace O(N) though\\n```py\\n    def minFlips(self, A):\\n        return len(list(itertools.groupby(A.lstrip(\\'0\\'))))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minFlips(String A) {\\n        int res = 0, n = A.length();\\n        for (int i = 0; i < n; ++i)\\n            if (res % 2 != A.charAt(i) - \\'0\\')\\n                res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int minFlips(string A) {\\n        int res = 0;\\n        for (auto a: A)\\n            if (res % 2 != a - \\'0\\')\\n                res++;\\n        return res;\\n    }\\n```\n```py\\n    def minFlips(self, target):\\n        res = 0\\n        for c in target:\\n            if res % 2 != int(c):\\n                res += 1\\n        return res\\n```\n```java\\n    public int minFlips(String A) {\\n        int res = A.charAt(0) - \\'0\\', n = A.length();\\n        for (int i = 1; i < n; ++i)\\n            if (A.charAt(i) != A.charAt(i - 1))\\n                res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int minFlips(string A) {\\n        int res = A[0] - \\'0\\', n = A.length();\\n        for (int i = 1; i < n; ++i)\\n            res += A[i - 1] != A[i];\\n        return res;\\n    }\\n```\n```py\\n    def minFlips(self, A):\\n        return len(list(itertools.groupby(A.lstrip(\\'0\\'))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 755828,
                "title": "java-detailed-explanation-greedy-o-n-one-pass",
                "content": "**Key Notes:**\\n- Choose a bulb i, then flip each bulb from index i to n-1. That means, **the 0-th bulb can only be flipped by choosing itself. And then, choosing any bulb else will not change bulb 0.**\\n- **Flip even times** -> bulb unchanged. **Flip odd times** -> bulb changed to 1.\\n- Iterate from 0 to N - 1. Greedily flip the bulb if it is unmatched with target (But, you need to check how many times it has been flipped).\\n\\n```java\\nint res = 0;\\n        \\nfor (int i = 0; i < target.length(); ++i) {\\n\\t// res == how many times it has been flipped so far for bulb i\\n\\tif (((res % 2) == 0 && target.charAt(i) == \\'1\\') || // unchanged, but need to flip to 1\\n\\t\\t((res % 2) == 1 && target.charAt(i) == \\'0\\')) { // changed, but target is 0\\n\\n\\t\\t++res;\\n\\t}\\n}\\n\\nreturn res;\\n```\\n\\n**Same idea for problem: [995. Minimum Number of K Consecutive Bit Flips](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/)**",
                "solutionTags": [],
                "code": "```java\\nint res = 0;\\n        \\nfor (int i = 0; i < target.length(); ++i) {\\n\\t// res == how many times it has been flipped so far for bulb i\\n\\tif (((res % 2) == 0 && target.charAt(i) == \\'1\\') || // unchanged, but need to flip to 1\\n\\t\\t((res % 2) == 1 && target.charAt(i) == \\'0\\')) { // changed, but target is 0\\n\\n\\t\\t++res;\\n\\t}\\n}\\n\\nreturn res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755814,
                "title": "python3-1-line",
                "content": "Algo: \\n\\nTo abstract this problem in math terms, the purpose of it is to simply convert a string composed of `0`\\'s and `1`\\'s to all `0`\\'s using a predefined flip operation that flips everything from a given position to the end. As a result, at any step, one could focus on the left-most `1`. By fliping it, a desirable byproduct is that a continous chunk of `1`\\'s connecting to the left-most `1` is set to `0`. An undesirable side effect is that the next `0` will become the left-most `1`. In the next step, you would have to flip this `1`. \\n\\nIt is not difficult to realize that this problem is to count the number of changes in the string. One caveat is the first character, for which one flip needs to be counted if it is `1`. To unify the operation, we could add a dummy `0` in front so that the string always starts with `0`. \\n\\nUsing the example given by the problem, the above argument would suggest 3 as the answer as there are in total 3 changes while scanning `010111` (a dummy `0` is added in front) from left to right. \\n`10111`\\n`01000` after 1st flip\\n`00111` after 2nd flip\\n`00000` after 3rd flip \\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return len(list(groupby(\"0\" + target)))-1\\n```\\n\\nHere, we leverage on `groupby` function of `itertools` module which groups the string for us though the only info we need is the number of groups minus one (`n` groups comes with `n-1` changes from group to group).\\n\\nFurthermore, the below elegant solution is due to @awice. \\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans = flip = 0\\n        for bulb in target: \\n            if flip ^ int(bulb): \\n                flip ^= 1\\n                ans += 1\\n        return ans\\n```\\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans, prev = 0,\"0\"\\n        for c in target: \\n            if prev != c: ans += 1\\n            prev = c\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return len(list(groupby(\"0\" + target)))-1\\n```\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans = flip = 0\\n        for bulb in target: \\n            if flip ^ int(bulb): \\n                flip ^= 1\\n                ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans, prev = 0,\"0\"\\n        for c in target: \\n            if prev != c: ans += 1\\n            prev = c\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 755833,
                "title": "java-python-3-count-flips-greedily-w-brief-explanation-and-analysis",
                "content": "Loop through `target`, find the index of first `1`, say `i`, flip all of `target[i...]` to `0`, then the index of `1`, say `j`, flip all of `target[j...]` to `1`, then find the index of next `0`, flip similarly, ..., accumulate the flipping times.\\ne.g.,\\ninitial state: target = \"10111\" , first `1` is the correspond first `1` at index `0` in the initial state `\"10111\"`, flip `target[0, ...]`=>\\nstate 1: \"01000\", now next `1` is the corresponding next `0` at index `1` in initial state `\"10111\"`, flip `target[1,...]` => \\nstate 2: \"00111\", now next `1` is the corresponding next `1` at index `2` in initial state `\"10111\"`, flip `target[2, ...]` => \\nstate 3: \"00000\"\\n\\n```java\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        for (int i = 0, b = 1; i < target.length(); ++i) {\\n            if (target.charAt(i) == \\'0\\' + b) {\\n                ++flips;\\n                b = 1 - b;\\n            }\\n        }\\n        return flips;        \\n```\\n```python\\n    def minFlips(self, target: str) -> int:\\n        flips, b = 0, 1\\n        for c in target:\\n            if int(c) == b:\\n                flips += 1\\n                b = 1 - b\\n        return flips            \\n```\\n**Analysis:**\\nTime: O(N), space: O(1).",
                "solutionTags": [],
                "code": "```java\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        for (int i = 0, b = 1; i < target.length(); ++i) {\\n            if (target.charAt(i) == \\'0\\' + b) {\\n                ++flips;\\n                b = 1 - b;\\n            }\\n        }\\n        return flips;        \\n```\n```python\\n    def minFlips(self, target: str) -> int:\\n        flips, b = 0, 1\\n        for c in target:\\n            if int(c) == b:\\n                flips += 1\\n                b = 1 - b\\n        return flips            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 755960,
                "title": "count-consecutive-1s-string",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int onesSegment = 0;\\n        for(int i = 1; i < s.length(); i++) \\n            if(s.charAt(i) == \\'0\\' && s.charAt(i - 1) == \\'1\\')\\n                onesSegment++;\\n        \\n        if(s.charAt(s.length() - 1) == \\'1\\') onesSegment++;\\n        int flip = onesSegment == 0 ?  0 : 2 * onesSegment - 1;\\n        if(s.charAt(s.length() - 1) == \\'0\\') flip++;\\n        return onesSegment == 0 ?  0: flip;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int onesSegment = 0;\\n        for(int i = 1; i < s.length(); i++) \\n            if(s.charAt(i) == \\'0\\' && s.charAt(i - 1) == \\'1\\')\\n                onesSegment++;\\n        \\n        if(s.charAt(s.length() - 1) == \\'1\\') onesSegment++;\\n        int flip = onesSegment == 0 ?  0 : 2 * onesSegment - 1;\\n        if(s.charAt(s.length() - 1) == \\'0\\') flip++;\\n        return onesSegment == 0 ?  0: flip;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963325,
                "title": "c-o-n-concise-try-not-to-flip-challange",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count = 0, size = target.size();\\n        char prev = \\'0\\';\\n        for (int i = 0; i < size; i++) {\\n            if (target[i] != prev) {\\n                count++;\\n                prev = target[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count = 0, size = target.size();\\n        char prev = \\'0\\';\\n        for (int i = 0; i < size; i++) {\\n            if (target[i] != prev) {\\n                count++;\\n                prev = target[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981667,
                "title": "java-o-n-greedy-solution-with-comments-logic-and-substructure-explained",
                "content": "**Algorithm**\\n\\nImagine your given the target string:\\n**110101**\\nand our starting string:\\n**000000**\\n\\nTo trace our algorithm let\\'s start at index 0. We can see that the first digit we encounter is a **1** with a **0** lying somewhere after it meaning that we require 2 total flips, one flip for all the **1** digits\\'s after it and one flip to reset the following **0** digit.\\n**000000** -> **<ins>11</ins>1111** -> **<ins>110</ins>000**\\n\\nAt this point we can start to see the substructure of the problem and why this approach works. After the 2 flips, we can see that the substring *[j,length of s - 1]* is now all 0s similar to our original problem and all digits from *[0, j]* match the target string. We can then repeat this process for the rest of the string to accumulate the minimum flips required and slowly construct our target string.\\n\\n**Logic, Formal**\\n\\nAll the bits in the string are originally 0. There are two cases for each character we encounter.\\n1. The bit is a 1.\\n2. The bit is a 0.\\nCase 1: When we encounter a one bit in our target string we can assume that will take one flip for that bit and all 1s that follow (before the next 0). We can also assume that the next zero bit will take one flip meaning that any 1 bit we encounter with a 0 after it would simply be adding 2 flips to our result. Any case that has more flips for that substring can be exchanged or converted into our greedy optimal case. For any *i* where *i<j* where *i* is an index after encountering a 1 and *j* is the next 0. Flipping that index *i*, would require an extra operation to flip all the 1s between *i-j* that you flipped to a 0. Therefore, in the optimal case you would use that flip on the *j* index or the next 0 you encounter. So this is in fact an optimal solution.\\nCase 2: When we encounter a 0, we can ignore it as the 1s are what determine how many flips we need, a string of 0s would take 0 operations. if we have a 0 then we can simply iterate until the next 1.\\n\\n```\\npublic int minFlips(String target) {\\n        //Find last zero in string\\n        int lastZero = -1;\\n        for(int i = target.length() - 1; i >= 0; i--){\\n            if(target.charAt(i) == \\'0\\'){\\n                lastZero = i;\\n                break;\\n            }\\n        }\\n        //If no 0 then return 1\\n        if(lastZero == -1){\\n            return 1;\\n        }\\n\\n        int result = 0;\\n        int i = 0;\\n        \\n        while(i < target.length()){\\n            \\n            //For 1\\'s after last 0 we only need one flip for the rest of the string\\n            if(i > lastZero){\\n                result++;\\n                break;\\n            }//If we encounter a 1 with a 0 somwhere after it \\n            else if(target.charAt(i) == \\'1\\'){ \\n                result += 2;\\n                //iterate until next 0\\n                while(i < target.length() && target.charAt(i) == \\'1\\'){\\n                    i++;\\n                }\\n            }\\n            \\n            //iterate until we hit next 1\\n                while(i < target.length() && target.charAt(i) == \\'0\\'){\\n                    i++;\\n                }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int minFlips(String target) {\\n        //Find last zero in string\\n        int lastZero = -1;\\n        for(int i = target.length() - 1; i >= 0; i--){\\n            if(target.charAt(i) == \\'0\\'){\\n                lastZero = i;\\n                break;\\n            }\\n        }\\n        //If no 0 then return 1\\n        if(lastZero == -1){\\n            return 1;\\n        }\\n\\n        int result = 0;\\n        int i = 0;\\n        \\n        while(i < target.length()){\\n            \\n            //For 1\\'s after last 0 we only need one flip for the rest of the string\\n            if(i > lastZero){\\n                result++;\\n                break;\\n            }//If we encounter a 1 with a 0 somwhere after it \\n            else if(target.charAt(i) == \\'1\\'){ \\n                result += 2;\\n                //iterate until next 0\\n                while(i < target.length() && target.charAt(i) == \\'1\\'){\\n                    i++;\\n                }\\n            }\\n            \\n            //iterate until we hit next 1\\n                while(i < target.length() && target.charAt(i) == \\'0\\'){\\n                    i++;\\n                }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 763667,
                "title": "python-o-1-space-o-n-time-with-1-for-loop",
                "content": "\\tclass Solution:\\n\\t\\tdef minFlips(self, target: str) -> int:\\n\\n\\t\\t\\t#Initial State = 00000\\n\\t\\t\\t#Final State   = 10111\\n\\n\\t\\t\\t# We start with  -->   00000    flag = 0  ans = 0\\n\\t\\t\\t# For i = 0   (flag == 0) != (target[i] == 1) therefore    need to change flag = 1 ans = 1   (1 1111)\\n\\t\\t\\t# For i = 1   (flag == 1) != (target[i] == 0) therefore    need to change flag = 0 ans = 2   (10 000)\\n\\t\\t\\t# For i = 2   (flag == 0) != (target[i] == 1) therefore    need to change flag = 1 ans = 3   (101 11)\\n\\t\\t\\t# For i = 3   (flag == 1) == (target[i] == 1) therefore NO need to change flag = 1 ans = 3   (1011 1)\\n\\t\\t\\t# For i = 4   (flag == 1) == (target[i] == 1) therefore NO need to change flag = 1 ans = 3   (10111 )\\n\\n\\t\\t\\t# THEREFORE we can observe that flag value tells the value of ith index, so we dnt need to change\\n\\t\\t\\t# there value if we change flag value it will do our work\\n\\n\\n\\n\\t\\t\\tflag = 0  #This will be 0 (Off) and 1 (On) tells value of ith index\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\tfor i in target:\\n\\n\\t\\t\\t\\t#If int(i) != flag change the ith index --> int(i) because i is in str and flag is in  int\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif int(i)!=flag:\\n\\n\\t\\t\\t\\t\\t#change the ith index\\n\\t\\t\\t\\t\\t#if we change ith index all the index next to i will also change\\n\\t\\t\\t\\t\\t#therefore flage also tell the value for i+1th index we can use flage for next loop\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tflag = not flag\\n\\n\\t\\t\\t\\t\\t#when flag is change increment ans\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tans+=1\\n\\n\\t\\t\\treturn ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minFlips(self, target: str) -> int:\\n\\n\\t\\t\\t#Initial State = 00000\\n\\t\\t\\t#Final State   = 10111\\n\\n\\t\\t\\t# We start with  -->   00000    flag = 0  ans = 0\\n\\t\\t\\t# For i = 0   (flag == 0) != (target[i] == 1) therefore    need to change flag = 1 ans = 1   (1 1111)\\n\\t\\t\\t# For i = 1   (flag == 1) != (target[i] == 0) therefore    need to change flag = 0 ans = 2   (10 000)\\n\\t\\t\\t# For i = 2   (flag == 0) != (target[i] == 1) therefore    need to change flag = 1 ans = 3   (101 11)\\n\\t\\t\\t# For i = 3   (flag == 1) == (target[i] == 1) therefore NO need to change flag = 1 ans = 3   (1011 1)\\n\\t\\t\\t# For i = 4   (flag == 1) == (target[i] == 1) therefore NO need to change flag = 1 ans = 3   (10111 )\\n\\n\\t\\t\\t# THEREFORE we can observe that flag value tells the value of ith index, so we dnt need to change\\n\\t\\t\\t# there value if we change flag value it will do our work\\n\\n\\n\\n\\t\\t\\tflag = 0  #This will be 0 (Off) and 1 (On) tells value of ith index\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\tfor i in target:\\n\\n\\t\\t\\t\\t#If int(i) != flag change the ith index --> int(i) because i is in str and flag is in  int\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif int(i)!=flag:\\n\\n\\t\\t\\t\\t\\t#change the ith index\\n\\t\\t\\t\\t\\t#if we change ith index all the index next to i will also change\\n\\t\\t\\t\\t\\t#therefore flage also tell the value for i+1th index we can use flage for next loop\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tflag = not flag\\n\\n\\t\\t\\t\\t\\t#when flag is change increment ans\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tans+=1\\n\\n\\t\\t\\treturn ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 755865,
                "title": "java-detailed-explanation-o-n-2-tle-and-o-n-accepted",
                "content": "### Thought process:\\n1. Started from the target array to reach all zeroes array.\\n2. Tried greedily flipping from left to right in the array whenever the value is 1 and maintain the total flip counts.\\n\\n### Brute force O(N^2) (TLE)\\n\\nThe first thing that came to me was traverse left to right, if you encounter \\'1\\', increase flipcount, and perform a flip from `i .. n-1`. This lead to O(N^2) solution and resulted in TLE.\\n\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char[] ca = target.toCharArray();\\n        int res = 0;\\n        for(int i=0; i<ca.length; i++){\\n            if(ca[i]==\\'0\\') continue;\\n            else {\\n                res++;\\n                for(int j=i; j<ca.length; j++){\\n                    if(ca[j]==\\'1\\') ca[j]=\\'0\\';\\n                    else ca[j]=\\'1\\';\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n### Optimised O(N) (Accepted)\\n\\nInstead of actually flipping, using flipcount to keep track of what the actual value should be after doing k flips. And if it comes 0, skip. else flip, and increase flipcount.\\n\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char[] ca = target.toCharArray();\\n        int flipcount = 0;\\n        for(int i=0; i<ca.length; i++){\\n            if(flipcount%2==1 && ca[i]==\\'1\\') continue;\\n            else if(flipcount%2==0 && ca[i]==\\'0\\') continue;\\n            else {\\n                flipcount++;\\n            }\\n        }\\n        return flipcount;\\n    }\\n}\\n```\\n\\nSame logic with reduced lines of code\\n\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flipcount = 0;\\n        for(char c: target.toCharArray()){\\n            if(!(flipcount%2==1 && c==\\'1\\') && !(flipcount%2==0 && c==\\'0\\')) flipcount++;\\n        }\\n        return flipcount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char[] ca = target.toCharArray();\\n        int res = 0;\\n        for(int i=0; i<ca.length; i++){\\n            if(ca[i]==\\'0\\') continue;\\n            else {\\n                res++;\\n                for(int j=i; j<ca.length; j++){\\n                    if(ca[j]==\\'1\\') ca[j]=\\'0\\';\\n                    else ca[j]=\\'1\\';\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char[] ca = target.toCharArray();\\n        int flipcount = 0;\\n        for(int i=0; i<ca.length; i++){\\n            if(flipcount%2==1 && ca[i]==\\'1\\') continue;\\n            else if(flipcount%2==0 && ca[i]==\\'0\\') continue;\\n            else {\\n                flipcount++;\\n            }\\n        }\\n        return flipcount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flipcount = 0;\\n        for(char c: target.toCharArray()){\\n            if(!(flipcount%2==1 && c==\\'1\\') && !(flipcount%2==0 && c==\\'0\\')) flipcount++;\\n        }\\n        return flipcount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756083,
                "title": "5-line-code-100-space-100-fast-o-n-java",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int max = 0;\\n        char bit = \\'0\\';\\n        for(int i = 0; i < target.length(); i++) {\\n            if(target.charAt(i) != bit) {\\n                max++;\\n                bit = target.charAt(i);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int max = 0;\\n        char bit = \\'0\\';\\n        for(int i = 0; i < target.length(); i++) {\\n            if(target.charAt(i) != bit) {\\n                max++;\\n                bit = target.charAt(i);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564562,
                "title": "java-iterative-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int count=0;\\n        char curr = \\'0\\';\\n        for(int i=0;i<target.length();i++){\\n            if(target.charAt(i)!=curr){\\n                count++;\\n                curr=target.charAt(i);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int count=0;\\n        char curr = \\'0\\';\\n        for(int i=0;i<target.length();i++){\\n            if(target.charAt(i)!=curr){\\n                count++;\\n                curr=target.charAt(i);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726593,
                "title": "simple-java-solution",
                "content": "\\nclass Solution {\\n \\n \\n\\t ***Simple solution is to count the number of flips i.e if 0 -> 1 or 1 -> 0.\\n\\t\\tEg :    11110000\\n\\t\\t\\t\\tFirst flip  : 00000000 -> 11111111\\n\\t\\t\\t\\tSecond flip : 11111111 -> 11110000\\n\\t\\t\\t\\t\\n\\t\\tEg :    00001111\\n\\t\\t\\t\\tFirst flip  : 00000000 -> 00001111\\n\\t\\t\\t\\t\\n\\t\\tTherefore the 0\\'s on the leftmost end doesnt count.\\n\\t\\tSo if string starts with zero set intial count to zero else one.*\\n\\t\\t\\n\\t\\tpublic int minFlips(String target) {\\n\\t\\t\\tint flipCount = target.charAt(0) - 48;\\n\\t\\t\\tchar prev = target.charAt(0);\\n\\n\\t\\t\\tfor(char ch : target.toCharArray()){\\n\\t\\t\\t\\tif(ch != prev){\\n\\t\\t\\t\\t\\tflipCount++;\\n\\t\\t\\t\\t\\tprev = ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn flipCount;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n \\n \\n\\t ***Simple solution is to count the number of flips i.e if 0 -> 1 or 1 -> 0.\\n\\t\\tEg :    11110000\\n\\t\\t\\t\\tFirst flip  : 00000000 -> 11111111\\n\\t\\t\\t\\tSecond flip : 11111111 -> 11110000\\n\\t\\t\\t\\t\\n\\t\\tEg :    00001111\\n\\t\\t\\t\\tFirst flip  : 00000000 -> 00001111\\n\\t\\t\\t\\t\\n\\t\\tTherefore the 0\\'s on the leftmost end doesnt count.\\n\\t\\tSo if string starts with zero set intial count to zero else one.*\\n\\t\\t\\n\\t\\tpublic int minFlips(String target) {\\n\\t\\t\\tint flipCount = target.charAt(0) - 48;\\n\\t\\t\\tchar prev = target.charAt(0);\\n\\n\\t\\t\\tfor(char ch : target.toCharArray()){\\n\\t\\t\\t\\tif(ch != prev){\\n\\t\\t\\t\\t\\tflipCount++;\\n\\t\\t\\t\\t\\tprev = ch;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 755905,
                "title": "python-3-two-solutions-1-one-liner-using-reduce-2-simple-iterative-with-thorough-explanation",
                "content": "**1) One-liner:**\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return reduce(lambda x, y: (x[0] + (x[1] != y), y), target, (0, \\'0\\'))[0]\\n```\\n\\n**2) Iterative solution:**\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans, prev = 0, \\'0\\'\\n        for curr in target:\\n            ans += curr != prev\\n            prev = curr\\n        return ans\\n```\\n\\nHere I\\'ll explain the **one-liner** (**1st** solution) using a few examples. Please jump to the example 3 if you know how ```reduce``` works:\\n\\n**1st example:**\\n```\\nd = [2, 3, 7, 15]\\nprint(reduce(lambda x, y: x + y, d)        # --->   2 + 3 + 7 + 15        --->   it prints 27\\n```\\n**Explanation:**\\nIt loops through the elements:\\n1st iteration: x = 2, y = 3. It calculates x + y = 5 and assigns it to x\\n2nd iteration: x = 5, y = 7. It calculates x + y = 12 and assigns it to x\\n3rd iteration: x = 12, y = 15. It calculates x + y = 27 and assigns it to x\\nreduce operation is done now and its result is 27.\\n\\n\\n\\n\\n**2nd example:**\\n```\\nd = [2, 3, 7, 15]\\nprint(reduce(lambda x, y: x + y, d, 100)   # --->   100 + 2 + 3 + 7 + 15  --->   it prints 127\\n```\\n**Note**: Think of 100 as the initial value for the entire reduce operations\\n\\n**Explanation**:\\nIt loops through the elements:\\n1st iteration: x = 100, y = 2. It calculates x + y = 102 and assigns it to x\\n2nd iteration: x = 102, y = 3. It calculates x + y = 105 and assigns it to x\\n3rd iteration: x  =105, y = 7. It calculates x + y = 112 and assigns it to x\\n3rd iteration: x = 112, y = 15. It calculates x + y = 127 and assigns it to x\\nreduce operation is done now and its result is 127.\\n\\n\\n\\n\\n**3rd example (Bulb Switcher):**\\n\\n**Note 1**: Generally speaking, in reduce, we have to make sure that in every iteration, **x** and **y** are of the same type as their previous-iteration counterpart accordingly (meaning **current x** type = **previous x** type; and **current y** type = **previous y** type); otherwise, the reduce operation (lambda function) would fail.\\n\\n**Note 2**: To solve the this problem, we know that we need to loop through the target and in each iteration:\\n1) Compare the **current** element of the target with its immediate **previous** element\\n2) If these two values (**current** and **previous**) differ, increment a **counter**\\n3) Assign the **current** element into an auxiliary parameter (as used above, let\\'s call it **previous**) and continue.\\n\\n**Note 3:** To use and keep track of both **counter** and **previous** in lambda function, we have to introduce and have them initialized as a tuple in the initial section of reduce function, hence ```(0, \\'0\\')```\\n\\n**Note 4:** For the lambda function, **x** is a tuple being as (**counter**, **previous**), and **y** is the **current** element of the target. Having said that, for the operation inside the lambda we can say: \\n(x[0] + (x[1] != y), y)  means (**counter** + (**previous** != **current**), **current**) which will be interpreted as:\\n1)  **current** = **counter** + (**previous** != **current**)   # ---> increment **current** if **previous** element is different than **current** element \\n2)  **previous** = **current**\\n\\nand it will be assigned to **x** for the next iteration.\\n\\n**Note 5:** When the reduce is done, we need to output only the first element (**counter**) of the result, hence using ```[0]```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return reduce(lambda x, y: (x[0] + (x[1] != y), y), target, (0, \\'0\\'))[0]\\n```\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans, prev = 0, \\'0\\'\\n        for curr in target:\\n            ans += curr != prev\\n            prev = curr\\n        return ans\\n```\n```reduce```\n```\\nd = [2, 3, 7, 15]\\nprint(reduce(lambda x, y: x + y, d)        # --->   2 + 3 + 7 + 15        --->   it prints 27\\n```\n```\\nd = [2, 3, 7, 15]\\nprint(reduce(lambda x, y: x + y, d, 100)   # --->   100 + 2 + 3 + 7 + 15  --->   it prints 127\\n```\n```(0, \\'0\\')```\n```[0]```",
                "codeTag": "Java"
            },
            {
                "id": 755791,
                "title": "c-simple-4-line",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        char prev = \\'0\\';\\n        int count=0;\\n        \\n        for(int i=0; i<target.size(); i++)\\n        {\\n            if(target[i]!=prev)\\n            {\\n                count++;\\n                prev = target[i];\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        char prev = \\'0\\';\\n        int count=0;\\n        \\n        for(int i=0; i<target.size(); i++)\\n        {\\n            if(target[i]!=prev)\\n            {\\n                count++;\\n                prev = target[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3067116,
                "title": "c-greedy-approach-easy-solution-3-lines",
                "content": "# Intuition\\n Greedy Solution\\n\\n# Approach\\nHow many times bits are flips ,i.e., the answer.\\nBut when first bit is 1 then ans=ans+1;\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int ans=0;\\n        for(int i=1;i<s.length();i++)  if(s[i]!=s[i-1])  ans++;\\n        if(s[0]==\\'0\\')   return ans;\\n        return ++ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        int ans=0;\\n        for(int i=1;i<s.length();i++)  if(s[i]!=s[i-1])  ans++;\\n        if(s[0]==\\'0\\')   return ans;\\n        return ++ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214645,
                "title": "simple-java-soln",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        \\n        int count = 0;\\n        String present = \"0\";\\n        \\n        for(int i=0;i<target.length();i++)\\n        {\\n            String index = target.charAt(i)+\"\";\\n            if(!present.equals(index))\\n            {\\n                count++;\\n                present = index;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        \\n        int count = 0;\\n        String present = \"0\";\\n        \\n        for(int i=0;i<target.length();i++)\\n        {\\n            String index = target.charAt(i)+\"\";\\n            if(!present.equals(index))\\n            {\\n                count++;\\n                present = index;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063425,
                "title": "c-tooooo-easy-solution-100-faster",
                "content": "Just count the number of times we change the 0 to 1 or vice versa in the given target string. According to our question initial check should be 0 \\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count = 0;\\n        char check = \\'0\\';\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(check!=target[i])\\n            {\\n                check = target[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count = 0;\\n        char check = \\'0\\';\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(check!=target[i])\\n            {\\n                check = target[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773735,
                "title": "java-xor",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int cur = 0, res = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            if (target.charAt(i) - \\'0\\' != cur) {\\n                cur ^= 1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int cur = 0, res = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            if (target.charAt(i) - \\'0\\' != cur) {\\n                cur ^= 1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766133,
                "title": "java-simple-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char ch=\\'0\\';\\n        int count=0;\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(ch!=target.charAt(i))\\n            {\\n                ch=(ch==\\'0\\'?\\'1\\':\\'0\\');\\n                count++;\\n            }\\n        \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char ch=\\'0\\';\\n        int count=0;\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(ch!=target.charAt(i))\\n            {\\n                ch=(ch==\\'0\\'?\\'1\\':\\'0\\');\\n                count++;\\n            }\\n        \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756591,
                "title": "java-detailed-explanation-with-picture",
                "content": "Idea is to flip at the points where there is a change in state (0->1 or 1->0).\\nIterate from the beginning do nothing until the state is same, when you encounter a change in state add flip count at that point. \\nSay when you are iterating for the target 00110100 - for the first two zeroes do nothing, when you encounter 0->1 add flip count, again for the two consecutive 1\\'s do nothing when you encounter 1->0 add flip count again, do it till end of array.\\n\\nX refers change in state from 0 ->1 or 1 -> 0.\\n\\n![image](https://assets.leetcode.com/users/images/4f101a27-7e1b-4103-a57e-c39b71652e49_1595756403.6735828.png)\\n\\n\\n```\\npublic int minFlips(String target) {\\n\\tint res = 0;\\n\\tchar prev = \\'0\\';\\n\\tfor (int i = 0; i < target.length(); i++) {\\n\\t\\tchar curr = target.charAt(i);\\n\\t\\tif (prev != curr) {\\n\\t\\t\\tres++;\\n\\t\\t\\tprev = curr;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minFlips(String target) {\\n\\tint res = 0;\\n\\tchar prev = \\'0\\';\\n\\tfor (int i = 0; i < target.length(); i++) {\\n\\t\\tchar curr = target.charAt(i);\\n\\t\\tif (prev != curr) {\\n\\t\\t\\tres++;\\n\\t\\t\\tprev = curr;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755891,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        res,i = 0,0\\n        while i < len(target):\\n            if (target[i] == \\'1\\' and res%2 == 1) or (target[i] == \\'0\\' and res%2 == 0):\\n                i += 1\\n                continue\\n            else: res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        res,i = 0,0\\n        while i < len(target):\\n            if (target[i] == \\'1\\' and res%2 == 1) or (target[i] == \\'0\\' and res%2 == 0):\\n                i += 1\\n                continue\\n            else: res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845935,
                "title": "c-one-pass-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink Greedily, in starting we have string of all zeroes. so we will start traversing from start we create a toggle val here it is c that means the value of our string char, where we occur a target diff from our toggle val, we increase the count and toggle the value of our toggle variable\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int cnt=0;\\n        int c=0;\\n        for(auto x:target)\\n        {\\n            if(x!=\\'0\\'+c)\\n            {\\n                cnt++;\\n                c=!c;\\n\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int cnt=0;\\n        int c=0;\\n        for(auto x:target)\\n        {\\n            if(x!=\\'0\\'+c)\\n            {\\n                cnt++;\\n                c=!c;\\n\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632136,
                "title": "greedy-very-simple-c-beats-98",
                "content": "# if it Helps You, Upvote Me Please...! \\u2764\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is Very Simple, we have to be count the break points after removing leading zero\\'s.\\n\\n**Break Points = t[i]!=t[i-1]**\\n\\nEx:- 0000111100011100011\\n1. firstly Remove the Leading 0 : **0000**111100011100011\\n2. after that just count the BreakPoints: 111**10**0**01**1**10**0**01**1\\n\\n# Complexity\\n- Time complexity:o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space comple\\nxity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string t) {\\n        int n = t.size();\\n        int count = 0,i = 0,fleg1 = 0;\\n\\n        while(i<n && t[i]==\\'0\\')\\n        i++;\\n\\n        i+=1;\\n        \\n        for(;i<n;i++)\\n        {\\n          if(t[i]!=t[i-1])\\n          count++; \\n\\n          if(t[i]==\\'1\\') fleg1 = 1;\\n        }\\n\\n        if(count==0 && !fleg1)\\n        return 0;\\n\\n        if(count==0 && fleg1)\\n        return 1;\\n\\n        return count+1;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/bb98892e-065c-4538-b222-41169af6eb33_1686640947.7710433.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string t) {\\n        int n = t.size();\\n        int count = 0,i = 0,fleg1 = 0;\\n\\n        while(i<n && t[i]==\\'0\\')\\n        i++;\\n\\n        i+=1;\\n        \\n        for(;i<n;i++)\\n        {\\n          if(t[i]!=t[i-1])\\n          count++; \\n\\n          if(t[i]==\\'1\\') fleg1 = 1;\\n        }\\n\\n        if(count==0 && !fleg1)\\n        return 0;\\n\\n        if(count==0 && fleg1)\\n        return 1;\\n\\n        return count+1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175651,
                "title": "python-solution-in-3-lines-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n\\t\\t# to keep counter of number of flip bits\\n        flips = 0\\n\\t\\t\\n\\t\\t# 0 will become 1 and 1 will become 0 after each move\\n\\t\\t# but the substring before current index in unchanged so traverse from left to right\\n        for letter in target:\\n\\t\\t\\t# we can find the current bit of string using flips%2 because we increment flips once a bit changes.\\n\\t\\t\\t# if the current bit not equal to the expected bit we need to flip the string\\n\\t\\t\\t\\n            if int(letter)!=flips%2:\\n                flips += 1\\n        return flips\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n\\t\\t# to keep counter of number of flip bits\\n        flips = 0\\n\\t\\t\\n\\t\\t# 0 will become 1 and 1 will become 0 after each move\\n\\t\\t# but the substring before current index in unchanged so traverse from left to right\\n        for letter in target:\\n\\t\\t\\t# we can find the current bit of string using flips%2 because we increment flips once a bit changes.\\n\\t\\t\\t# if the current bit not equal to the expected bit we need to flip the string\\n\\t\\t\\t\\n            if int(letter)!=flips%2:\\n                flips += 1\\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952370,
                "title": "java-o-n-brief-solution-explained",
                "content": "# Approach\\nCount the number of different adjacent letters. Since we are working with suffices, then you can figure out that we just need to flip starting from index (from left) where it differs from target. So, we adjust initial String with zeros only starting from left and by looking each letter one by one.\\nExample:\\n00000 -> 10101\\n1. **00000**\\n2. 1**1111**\\n3. 10**000**\\n4. 101**11**\\n5. 1010**0**\\nResult: 10101\\n\\n# Complexity\\n- Time complexity: O(N), where N - number of letters.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        char prev = target.charAt(0);\\n        if (prev == \\'1\\') flips++;\\n\\n        for (int i = 1; i < target.length(); i++) {\\n            char c = target.charAt(i);\\n            if (c != prev) {\\n                flips++;\\n                prev = c;\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        char prev = target.charAt(0);\\n        if (prev == \\'1\\') flips++;\\n\\n        for (int i = 1; i < target.length(); i++) {\\n            char c = target.charAt(i);\\n            if (c != prev) {\\n                flips++;\\n                prev = c;\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704588,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minFlips(string target) {\\n        int n = target.size();                        \\n        int flips = 0;                                 \\n        char status = \\'0\\';                              \\n                                                       \\n        for (int i=0; i<n; i++) {                      \\n            if (status != target[i]) {                 \\n                                                       \\n                flips++;                                \\n                status = status == \\'0\\' ?  \\'1\\' : \\'0\\';   \\n            }\\n        }\\n        return flips; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minFlips(string target) {\\n        int n = target.size();                        \\n        int flips = 0;                                 \\n        char status = \\'0\\';                              \\n                                                       \\n        for (int i=0; i<n; i++) {                      \\n            if (status != target[i]) {                 \\n                                                       \\n                flips++;                                \\n                status = status == \\'0\\' ?  \\'1\\' : \\'0\\';   \\n            }\\n        }\\n        return flips; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900223,
                "title": "minimum-suffix-flips-c",
                "content": "```\\n# Initially all are zeros and \\'1\\' and \\'1\\'matches means that i need one flip.\\n# Then make check as zero and check if another element is zero or not if zero increase the flip, and change the check.\\n# if not then move ahead without changing anything.\\n# You can do it in other manner as well like initialise check as zero if not equal , \\n# You need to increase the count and change the check if equal move ahead.\\n```\\n```\\nclass Solution \\n{\\n public:\\n    int minFlips(string s) \\n    {\\n        int count=0;\\n        char check=\\'1\\';\\n        for(char i:s)\\n        {\\n            if(i==check)\\n            {\\n                count++;\\n                if(check==\\'0\\')\\n                    check=\\'1\\';\\n                else\\n                    check=\\'0\\';\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n# Initially all are zeros and \\'1\\' and \\'1\\'matches means that i need one flip.\\n# Then make check as zero and check if another element is zero or not if zero increase the flip, and change the check.\\n# if not then move ahead without changing anything.\\n# You can do it in other manner as well like initialise check as zero if not equal , \\n# You need to increase the count and change the check if equal move ahead.\\n```\n```\\nclass Solution \\n{\\n public:\\n    int minFlips(string s) \\n    {\\n        int count=0;\\n        char check=\\'1\\';\\n        for(char i:s)\\n        {\\n            if(i==check)\\n            {\\n                count++;\\n                if(check==\\'0\\')\\n                    check=\\'1\\';\\n                else\\n                    check=\\'0\\';\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877414,
                "title": "minimum-suffix-flips-java-fast-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char flip = \\'0\\';\\n        int count =0;\\n        for(int i =0;i<target.length();i++){\\n          \\n            if(target.charAt(i) != flip){\\n                  flip = target.charAt(i);\\n                  count++;        \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char flip = \\'0\\';\\n        int count =0;\\n        for(int i =0;i<target.length();i++){\\n          \\n            if(target.charAt(i) != flip){\\n                  flip = target.charAt(i);\\n                  count++;        \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801262,
                "title": "c-easy-solution-w-explanation-o-1-space-and-o-n-time",
                "content": "Do \\u2B06\\uFE0F UPVOTE IF IT WAS HELPFUL!!\\n\\n**INTUITION**- If we observe carefully we will find that if there is a group of 1\\'s present having \\n                           1 at last index then it can be made using 1 operation only. Similarly If there is any                                    group of 1\\'s present in between then it will take 2 operation. \\n\\t\\t\\t\\t\\t\\t   **For eg**- 001100 will first converted into 00**1**111 and then 0011**0**0.(Highlited                              index is the satrting index of flipping).So we can calulcate no of group and just check                              for if there is any group ending on last index or not.\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minFlips(string s) {\\n\\t\\t\\t\\tint one_group=0,n=s.size();\\n\\t\\t\\t\\tbool first=true,right=false;\\n\\t\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\t\\tif(s[i]==\\'1\\' && (i==n-1 || s[i+1]==\\'0\\')){\\n\\t\\t\\t\\t\\t\\tif(i==n-1) right=true;\\n\\t\\t\\t\\t\\t   one_group++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(one_group==0) return 0;\\n\\t\\t\\t\\tif(right)\\n\\t\\t\\t\\t\\treturn 1*1+(one_group-1)*2;\\n\\t\\t\\t\\treturn (one_group)*2;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minFlips(string s) {\\n\\t\\t\\t\\tint one_group=0,n=s.size();\\n\\t\\t\\t\\tbool first=true,right=false;\\n\\t\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\t\\tif(s[i]==\\'1\\' && (i==n-1 || s[i+1]==\\'0\\')){\\n\\t\\t\\t\\t\\t\\tif(i==n-1) right=true;\\n\\t\\t\\t\\t\\t   one_group++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1732639,
                "title": "c-eay-to-understand-simple-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans=0;\\n        int n=target.size();\\n        bool one=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[i]==\\'0\\'&&!one)\\n            continue;\\n            else if(target[i]==\\'0\\'&&one)\\n            {\\n                ans++;\\n                one=false;\\n            }\\n            else if(target[i]==\\'1\\'&&!one)\\n            {\\n                ans++;\\n                one=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans=0;\\n        int n=target.size();\\n        bool one=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[i]==\\'0\\'&&!one)\\n            continue;\\n            else if(target[i]==\\'0\\'&&one)\\n            {\\n                ans++;\\n                one=false;\\n            }\\n            else if(target[i]==\\'1\\'&&!one)\\n            {\\n                ans++;\\n                one=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606118,
                "title": "java-just-count-switching-numbers-o-n",
                "content": "if you like it pls upvote\\n\\nJAVA\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int res= 0;\\n        if(target.charAt(0) == \\'1\\') res++;\\n        \\n        for(int i =1 ; i< target.length();i++){\\n            if(target.charAt(i) != target.charAt(i-1))res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int res= 0;\\n        if(target.charAt(0) == \\'1\\') res++;\\n        \\n        for(int i =1 ; i< target.length();i++){\\n            if(target.charAt(i) != target.charAt(i-1))res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329787,
                "title": "most-easy-logic-c-o-n",
                "content": "In this code I\\'ve counted the number of changes from 0 to 1 and 1 to 0. The total no. of convertion between 0-1 or 1-0 is the ANSWER. Here one thing to notice, when it starts from 1, initially all lights are off, so we have to turn on all light first. That\\'s why 1more extra Flips to be add as the first flip isn\\'t counted in the loop.\\n\\n```\\n    int minFlips(string target) {\\n        int count=0;\\n        if(target[0]==\\'1\\')\\n            ++count;\\n        for(int i=0;i<target.size()-1;i++)\\n            if(target[i]!=target[i+1])\\n                ++count;\\n        \\n        return count;\\n    }\\n```\\nIf you like this approach, Upvote \\uD83D\\uDE4C\\nHave you any doubt plz comment below.\\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int minFlips(string target) {\\n        int count=0;\\n        if(target[0]==\\'1\\')\\n            ++count;\\n        for(int i=0;i<target.size()-1;i++)\\n            if(target[i]!=target[i+1])\\n                ++count;\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1190315,
                "title": "python-o-n-solution-with-intuition",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\'\\'\\'\\n        Intuition: the min number of flips equals the number of toggles between 0 and 1 starting with 0.\\n        prev: previous character (0 at first)\\n        \\'\\'\\'\\n        flips = 0\\n        prev = \\'0\\'\\n        for num in target:\\n            if num != prev:\\n                flips += 1\\n                prev = num\\n        return flips\\n```\\n\\n\\nRuntime: 64 ms, faster than 83.85% of Python3 online submissions for Bulb Switcher IV.\\nMemory Usage: 14.9 MB, less than 35.00% of Python3 online submissions for Bulb Switcher IV.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\'\\'\\'\\n        Intuition: the min number of flips equals the number of toggles between 0 and 1 starting with 0.\\n        prev: previous character (0 at first)\\n        \\'\\'\\'\\n        flips = 0\\n        prev = \\'0\\'\\n        for num in target:\\n            if num != prev:\\n                flips += 1\\n                prev = num\\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168464,
                "title": "very-simple-solution-95-faster",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        x=target[0]\\n        c=int(x)\\n        for i in target:\\n            if(i!=x):\\n                c=c+1\\n                x=i\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        x=target[0]\\n        c=int(x)\\n        for i in target:\\n            if(i!=x):\\n                c=c+1\\n                x=i\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928023,
                "title": "c-one-liner-o-1-space",
                "content": "We don\\'t need to maintain a vector having current status of bulbs. What we need to do is just keep the count of number of flips. Since we initialized the string to \\'000\\', after odd number of flips from the left, the state of bulbs will 1, and after even number of flips it will be 0. So we just need an equality check or XOR between the num_flips and the ith element of target string.\\n\\n\\n```\\nint minFlips(string target) {\\n        int num_flips = 0;\\n        for(auto x: target)\\n            if(num_flips%2 ^ (x-\\'0\\')) num_flips++;\\n        \\n        return num_flips;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minFlips(string target) {\\n        int num_flips = 0;\\n        for(auto x: target)\\n            if(num_flips%2 ^ (x-\\'0\\')) num_flips++;\\n        \\n        return num_flips;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 808020,
                "title": "java-solution-for-loop",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int state=0;\\n        int n=target.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(target.charAt(i)-\\'0\\'!=state){\\n                c++;\\n                state=target.charAt(i)-\\'0\\';\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int state=0;\\n        int n=target.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(target.charAt(i)-\\'0\\'!=state){\\n                c++;\\n                state=target.charAt(i)-\\'0\\';\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765564,
                "title": "python-0-n-solution",
                "content": "The idea is to \"remove\" from target repeated \\'1\\' and \\'0\\'. Count of flips for \\'10111\\' and for \\'101\\' is the same. Count of flips is length of result sequence.\\n\\nSome examples of targets:\\n\\n\\t\\t\\ttarget=10     taget=100(0...)\\n\\n\\t\\t\\t00             000(0...)\\n\\t\\t\\t11             111(1...)\\n\\t\\t\\t10             100(0...) \\n\\nflips=2\\n\\n--------------\\n\\ttarget = 101          target = 1011(1...)\\n\\n\\t000                        0000(0...)\\n\\t111                        1111(1...)\\n\\t100                        1000(0...)\\n\\t101                        1011(1...)\\n\\nflips=3\\n\\n\\n```\\n    def minFlips(self, target: str) -> int:\\n        flips = 0\\n        i0 = target.find(\\'1\\')\\n        if i0 ==-1:\\n            return flips\\n        flips = 1\\n        for i in range(i0 + 1, len(target)):\\n            if target[i] != target[i-1]:\\n                flips += 1\\n            \\n        return flips\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is to \"remove\" from target repeated \\'1\\' and \\'0\\'. Count of flips for \\'10111\\' and for \\'101\\' is the same. Count of flips is length of result sequence.\\n\\nSome examples of targets:\\n\\n\\t\\t\\ttarget=10     taget=100(0...)\\n\\n\\t\\t\\t00             000(0...)\\n\\t\\t\\t11             111(1...)\\n\\t\\t\\t10             100(0...) \\n\\nflips=2\\n\\n--------------\\n\\ttarget = 101          target = 1011(1...)\\n\\n\\t000                        0000(0...)\\n\\t111                        1111(1...)\\n\\t100                        1000(0...)\\n\\t101                        1011(1...)\\n\\nflips=3\\n\\n\\n```\\n    def minFlips(self, target: str) -> int:\\n        flips = 0\\n        i0 = target.find(\\'1\\')\\n        if i0 ==-1:\\n            return flips\\n        flips = 1\\n        for i in range(i0 + 1, len(target)):\\n            if target[i] != target[i-1]:\\n                flips += 1\\n            \\n        return flips\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 756162,
                "title": "bulb-switcher-iv-intuitive-explanation-greedy-approach-c-like-bit-flip-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        // Greedy approach\\n        // left to right\\n        // bcz if a particular ith bulb doesn\\'t match with the target \\n        // it is 100% sure to change its state, so it 100% must to flip it, no other alternative\\n        // so it is 100% sure that we have to flip all bulbs from i to n-1\\n        \\n        // So now their are only two points to think upon \\n        // Initially all are off ie (say) \"00000\" and we want \"10111\" if in\\n        // above eg. if we want \"00000\" then we don\\'t need to anything(no flips) \\n        // above eg. if we want \"10000\" then we  need to something (some flips)\\n        \\n        // First point\\n        // So to have a measure of need to do something (some flips) and nothing(no flips) will be done by\\n        // variable state\\n        \\n        // Second point \\n        // if current bulb is not match with  state(expected state of bulb) ie we are bound to do a flip\\n        \\n        int state=0;//initially all zero\\n        int cnt=0;\\n        \\n        for(auto b:target)\\n        {\\n            int curr=b-\\'0\\';\\n            \\n            if(curr!=state)\\n            {\\n                cnt++;\\n                state=curr; // now this the expected state of all bulbs of i to n-1\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\ntarget=\"10111\"\\n\\ns=\"00000\" state=0 (initially)\\n\\n(i=0  and target[i]!=state[i]) // Need a flip\\ns=\"11111\"  state=1  \\n\\n(i=1  and target[i]!=state[i]) // Need a flip\\ns=\"10000\"  state=0 \\n\\n(i=2  and target[i]!=state[i]) // Need a flip\\ns=\"10111\"  state=2\\n\\n(i=3  and target[i]==state[i]) //Not Need a flip\\n\\n(i=4  and target[i]==state[i]) //Not Need a flip",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        // Greedy approach\\n        // left to right\\n        // bcz if a particular ith bulb doesn\\'t match with the target \\n        // it is 100% sure to change its state, so it 100% must to flip it, no other alternative\\n        // so it is 100% sure that we have to flip all bulbs from i to n-1\\n        \\n        // So now their are only two points to think upon \\n        // Initially all are off ie (say) \"00000\" and we want \"10111\" if in\\n        // above eg. if we want \"00000\" then we don\\'t need to anything(no flips) \\n        // above eg. if we want \"10000\" then we  need to something (some flips)\\n        \\n        // First point\\n        // So to have a measure of need to do something (some flips) and nothing(no flips) will be done by\\n        // variable state\\n        \\n        // Second point \\n        // if current bulb is not match with  state(expected state of bulb) ie we are bound to do a flip\\n        \\n        int state=0;//initially all zero\\n        int cnt=0;\\n        \\n        for(auto b:target)\\n        {\\n            int curr=b-\\'0\\';\\n            \\n            if(curr!=state)\\n            {\\n                cnt++;\\n                state=curr; // now this the expected state of all bulbs of i to n-1\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756104,
                "title": "c-easy-to-understand-complete-explanation",
                "content": "Initially all the bits in the string will be \\'0\\'. Whenever we encounter a different bit while comparing with corrseponding bit in target we have to flip that bit and all the right bits to it in our initial string. If we try to modify every bit next to it we will get a TLE. \\n\\nSo instead we use flipcount and just make sure that next bit we are encountering will be correct one greedily. Whenever flipcount is odd that implies it\\'s value should be opposite of what initial value is. We do this irrespective of whether the bits of target and initial strings matches because at every k we are deciding the value of k+1. It will be clear with an example.\\n\\ninitial = \"00000\"  target = \"10111\"                *Flipped string*\\nk =0 flipcount =1;  initial  = \"0**1**000\"           *(1**1**111)*\\nk=1 flipcount = 2;  initial = \"01**0**00\"          *(10**0**00)*    //no change for bit of index 2 as 2 flips will make it 0;\\nk=2 flipcount = 3;  initial = \"010**1**0\"          *(101**1**1)*\\nk=3 flipcount = 3; initial = \"0101**1**\"           *(1011**1**)* \\n\\nIn every iteration we can see that (k+1) bit in the initial string and Flipped string are same \\n\\ninitial = \"00000\"  target = \"11000\"                *Flipped string*\\nk =0 flipcount =1;  initial  = \"0**1**000\"           *(1**1**111)*\\nk=1 flipcount = 1;  initial = \"01**1**00\"          *(11**1**11)*    \\nk=2 flipcount = 2;  initial = \"011**0**0\"          *(110**0**0)*\\nk=3 flipcount = 2; initial = \"0110**0**\"           *(1100**0**)* \\n\\nComes out of loop and check for the last bit whether they are equal or not\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.length();\\n        string initial = target;\\n        for(int i=0;i<n;i++)\\n            initial[i] = \\'0\\';\\n        int flipcount =0;\\n        for(int k=0;k<n-1;k++){\\n            if(target[k]!=initial[k]){\\n                flipcount++;\\n                if(flipcount%2==1){\\n                    initial[k+1] == \\'0\\' ? initial[k+1] = \\'1\\' : initial[k+1] = \\'0\\';\\n                }\\n            }\\n            else{\\n                if(flipcount%2==1){\\n                    initial[k+1] == \\'0\\' ? initial[k+1] = \\'1\\' : initial[k+1] = \\'0\\';\\n                }\\n            }\\n        }\\n        if(target[n-1]!=initial[n-1]){\\n                flipcount++;\\n        }\\n        \\n        return flipcount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.length();\\n        string initial = target;\\n        for(int i=0;i<n;i++)\\n            initial[i] = \\'0\\';\\n        int flipcount =0;\\n        for(int k=0;k<n-1;k++){\\n            if(target[k]!=initial[k]){\\n                flipcount++;\\n                if(flipcount%2==1){\\n                    initial[k+1] == \\'0\\' ? initial[k+1] = \\'1\\' : initial[k+1] = \\'0\\';\\n                }\\n            }\\n            else{\\n                if(flipcount%2==1){\\n                    initial[k+1] == \\'0\\' ? initial[k+1] = \\'1\\' : initial[k+1] = \\'0\\';\\n                }\\n            }\\n        }\\n        if(target[n-1]!=initial[n-1]){\\n                flipcount++;\\n        }\\n        \\n        return flipcount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756066,
                "title": "simple-java-solution-in-5-lines-o-n-time-complexity",
                "content": "The logic behind this solution is to compare every character of target string with its previous character. Whenever there is a change of character(from 1 to 0 or 0 to 1), make a flip.\\n\\n\\tclass Solution {\\n\\t\\tpublic int minFlips(String target) {\\n\\n\\t\\t\\tint count = 0, len = target.length();\\n\\n\\t\\t\\tfor (int i = len - 1; i > 0; i--) {\\n\\t\\t\\t\\tif (target.charAt(i) != target.charAt(i-1)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn target.charAt(0) == \\'0\\' ? count : count + 1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minFlips(String target) {\\n\\n\\t\\t\\tint count = 0, len = target.length();\\n\\n\\t\\t\\tfor (int i = len - 1; i > 0; i--) {\\n\\t\\t\\t\\tif (target.charAt(i) != target.charAt(i-1)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 755896,
                "title": "explanation-how-i-approached-this-prob",
                "content": "```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        sawOne = False\\n        reseterZero = True\\n        reseterOne = True\\n        counter = 0\\n        for i in range(len(target)):\\n            if target[i] == \\'1\\' and reseterOne:\\n                sawOne = True\\n                reseterZero = True\\n                counter += 1\\n                reseterOne = False\\n            elif target[i] == \\'0\\' and reseterZero and sawOne:\\n                reseterOne = True\\n                counter += 1\\n                reseterZero = False\\n        return counter\\n```\\n\\nDont care about my crappy code, there is a more condensed and better way, but it still is O(n) O(1) \\n\\n1. do it intuitively, and you will realize the trick to this question\\n2. how would you do 111101\\n\\tFirst, you probably deal with the beginning ones first\\n\\t000000 -> 111111 -> 111100\\n\\tThen deal with the last 1\\n\\t111101\\n\\tThis can tell you that, after deal with one part of the string, you can ignore, as you care about the characters after a selected index\\n\\t1111 - 00, 1111 can be in a sense \"detached\" as you know its good\\n3. Once you see this, you can parse your way to finding every \"section\", as you must deal with alternating 0s and 1s and not the complete subarrays of 1s and 0s\\n\\t\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        sawOne = False\\n        reseterZero = True\\n        reseterOne = True\\n        counter = 0\\n        for i in range(len(target)):\\n            if target[i] == \\'1\\' and reseterOne:\\n                sawOne = True\\n                reseterZero = True\\n                counter += 1\\n                reseterOne = False\\n            elif target[i] == \\'0\\' and reseterZero and sawOne:\\n                reseterOne = True\\n                counter += 1\\n                reseterZero = False\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755860,
                "title": "c-o-n-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans = 0;\\n        int val = \\'0\\';\\n        for(char x: target){\\n            if(x != val){\\n                ans++;\\n                if(val == \\'0\\') val = \\'1\\';\\n                else val = \\'0\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans = 0;\\n        int val = \\'0\\';\\n        for(char x: target){\\n            if(x != val){\\n                ans++;\\n                if(val == \\'0\\') val = \\'1\\';\\n                else val = \\'0\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755858,
                "title": "c-simple-o-n-time-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n=target.size();\\n        int sum=0;\\n        int count=0;\\n    \\n        for(int i=0;i<n;++i){\\n            int t=1-(target[i]==\\'0\\');\\n            if((sum%2)!=t){ \\n              sum+=1;\\n              count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n=target.size();\\n        int sum=0;\\n        int count=0;\\n    \\n        for(int i=0;i<n;++i){\\n            int t=1-(target[i]==\\'0\\');\\n            if((sum%2)!=t){ \\n              sum+=1;\\n              count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 755790,
                "title": "simulation-with-greedy-approach",
                "content": "Idea: \\nThe goal is to find how many similiar region/neighborhood are there begining from leftmost \\'1\\'\\nFor example:\\n\"10111\"  means  \"1\" + \"0\" +  \"111\"\\nSo the answer is 3\\n\\n\\nSolution 1: Greedy (simulation)\\n```\\nclass Solution {\\npublic: // Time/Space: O(N); O(1)\\n    int minFlips(string target) {\\n        const int n = target.size();\\n        int ans = 0;\\n        int beg = 0;\\n        while(beg < n && target[beg]==\\'0\\') beg++; // beg: location of 1st \\'1\\'\\n        char prev;\\n        if(beg!=0) prev = target[beg - 1];\\n        for(int i = beg; i<n;){\\n            if(i ==0 ||  target[i] != prev) ans++;\\n            int next = i+1;\\n            while(next < n && target[next]== target[i]) next++;\\n            prev = target[next-1];\\n            i = next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nSoluion 2: BFS,TLE\\n```\\nclass Solution {\\npublic://BFS, simple but will cause TLE error\\n    int minFlips(string target) {\\n        const int n = target.size();\\n        string start(n, \\'0\\');\\n        queue<string> q{{start}};\\n        unordered_set<string> seen; seen.insert(start);\\n        for(int step = 0; q.size();step++){\\n          for(auto sz = q.size(); sz-->0;){\\n            auto cur = q.front();q.pop();\\n            if(cur == target) return step;\\n            for(int i = 0; i < n; i++){\\n                string next(flipSwitch(cur, i));\\n                if(seen.count(next)) continue;\\n                q.emplace(next);\\n                seen.emplace(next);\\n            }            \\n          }\\n        }\\n        return -1;\\n    }\\n    \\nprivate:\\n    string flipSwitch(string& cur, const int j){\\n        string ans(cur);\\n        for(int i=j; i < cur.size(); i++) ans[i]=cur[i]==\\'0\\'?\\'1\\':\\'0\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic: // Time/Space: O(N); O(1)\\n    int minFlips(string target) {\\n        const int n = target.size();\\n        int ans = 0;\\n        int beg = 0;\\n        while(beg < n && target[beg]==\\'0\\') beg++; // beg: location of 1st \\'1\\'\\n        char prev;\\n        if(beg!=0) prev = target[beg - 1];\\n        for(int i = beg; i<n;){\\n            if(i ==0 ||  target[i] != prev) ans++;\\n            int next = i+1;\\n            while(next < n && target[next]== target[i]) next++;\\n            prev = target[next-1];\\n            i = next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic://BFS, simple but will cause TLE error\\n    int minFlips(string target) {\\n        const int n = target.size();\\n        string start(n, \\'0\\');\\n        queue<string> q{{start}};\\n        unordered_set<string> seen; seen.insert(start);\\n        for(int step = 0; q.size();step++){\\n          for(auto sz = q.size(); sz-->0;){\\n            auto cur = q.front();q.pop();\\n            if(cur == target) return step;\\n            for(int i = 0; i < n; i++){\\n                string next(flipSwitch(cur, i));\\n                if(seen.count(next)) continue;\\n                q.emplace(next);\\n                seen.emplace(next);\\n            }            \\n          }\\n        }\\n        return -1;\\n    }\\n    \\nprivate:\\n    string flipSwitch(string& cur, const int j){\\n        string ans(cur);\\n        for(int i=j; i < cur.size(); i++) ans[i]=cur[i]==\\'0\\'?\\'1\\':\\'0\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093873,
                "title": "python-c-o-n-using-flips-parity",
                "content": "The strategy here is to keep track of parity of the already made flips. The code is self-explanatory.\\n\\n```python []\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\n        flips = 0\\n        for b in target:\\n            if flips % 2 == 1 - int(b):\\n                flips += 1\\n\\n        return flips\\n\\n```\\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int minFlips(string target)\\n    {\\n        int flips = 0;\\n        \\n        for (char b : target)\\n            if ((flips % 2 == 1) == (b == \\'0\\'))\\n                flips += 1;\\n\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\n        flips = 0\\n        for b in target:\\n            if flips % 2 == 1 - int(b):\\n                flips += 1\\n\\n        return flips\\n\\n```\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int minFlips(string target)\\n    {\\n        int flips = 0;\\n        \\n        for (char b : target)\\n            if ((flips % 2 == 1) == (b == \\'0\\'))\\n                flips += 1;\\n\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057564,
                "title": "c-o-1-space-solution",
                "content": "# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char temp = \\'0\\';\\n        int cnt=0;\\n        for(int i=0; i<target.length(); i++){\\n            if(target[i]!=temp){\\n                temp = target[i]; cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char temp = \\'0\\';\\n        int cnt=0;\\n        for(int i=0; i<target.length(); i++){\\n            if(target[i]!=temp){\\n                temp = target[i]; cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645584,
                "title": "c-easy-code-with-good-readability-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans = 0;\\n        char cBit = \\'0\\';\\n        for(auto bit : target){\\n            if(cBit != bit){\\n                cBit = bit;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans = 0;\\n        char cBit = \\'0\\';\\n        for(auto bit : target){\\n            if(cBit != bit){\\n                cBit = bit;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145888,
                "title": "golang-counting-number-of-1-s",
                "content": "```\\npackage main\\n\\n// url: https://leetcode.com/problems/minimum-suffix-flips/\\n// date: 05-02-2023 : 04:11 pm\\n\\nfunc minFlips(target string) int {\\n\\tcount := 0\\n\\n\\tfor i := 0; i < len(target); i++ {\\n\\t\\tch := target[i]\\n\\n\\t\\tif ch == \\'1\\' {\\n            // Count consecutive 1\\'s\\n\\t\\t\\tfor i+1 < len(target) && target[i+1] == ch {\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\n            // First flip for the consecutive 1\\'s.\\n            // Second flip to set rest of the bits to original state (Because the 1st flip might have changed the state of the rest).\\n\\t\\t\\tcount += 2\\n\\t\\t}\\n\\t}\\n\\n    // The last one\\'s do not require the extra flip.\\n\\tif target[len(target)-1] == \\'1\\' {\\n\\t\\tcount--\\n\\t}\\n\\n\\treturn count\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\n// url: https://leetcode.com/problems/minimum-suffix-flips/\\n// date: 05-02-2023 : 04:11 pm\\n\\nfunc minFlips(target string) int {\\n\\tcount := 0\\n\\n\\tfor i := 0; i < len(target); i++ {\\n\\t\\tch := target[i]\\n\\n\\t\\tif ch == \\'1\\' {\\n            // Count consecutive 1\\'s\\n\\t\\t\\tfor i+1 < len(target) && target[i+1] == ch {\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\n            // First flip for the consecutive 1\\'s.\\n            // Second flip to set rest of the bits to original state (Because the 1st flip might have changed the state of the rest).\\n\\t\\t\\tcount += 2\\n\\t\\t}\\n\\t}\\n\\n    // The last one\\'s do not require the extra flip.\\n\\tif target[len(target)-1] == \\'1\\' {\\n\\t\\tcount--\\n\\t}\\n\\n\\treturn count\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2972360,
                "title": "intuitive-approach-fully-explained",
                "content": "# Intuition\\n<strong>we are told to do some flips on string s=\"000..0\" so that it becomes equal to target. \\nbut actually we are going to do the opposite, i.e., we\\'ll do some flips on target so that it becomes equal to string s. (\"000..0\")</strong>\\n\\n# Approach\\n**so when will we flip the bits?**\\nidea behind this approach is to first identify the state of bits and accordingly decide whether to flip or not **(increment flip counter.)**\\nwe are not actually flipping the bit, rather we are keeping a check of the state the bit is in. \\n**2(two) flips reverses the flip operation and converts that bit as it was, originally** hence\\n\\n1) if flip % 2 == 0, i.e., 0, 2, 4, then it means the bits are in original state and if s[i]==1 then we increment the flip counter by 1\\n2) else if flip % 2 != 0(odd), then it means bits are in flipped state(we\\'ll assume it) so whole condition will be reversed therefore if flip%2!=0 and s[i]==\\'0\\', then we will increment flip counter\\n\\n# Complexity\\n- Time complexity:\\n**O(N) since we are only traversing on the string once**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int flip=0;\\n        for(char c:target)\\n        {\\n            if(flip%2==0 and c==\\'1\\')\\n            flip++;\\n            else if(flip%2!=0 and c==\\'0\\')\\n            flip++;\\n\\n            //for any other case, we will not increment flip counter\\n        }\\n        return flip;\\n    }\\n};\\n```\\n### if this helped you, then please upvote\\uD83D\\uDC9B",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int flip=0;\\n        for(char c:target)\\n        {\\n            if(flip%2==0 and c==\\'1\\')\\n            flip++;\\n            else if(flip%2!=0 and c==\\'0\\')\\n            flip++;\\n\\n            //for any other case, we will not increment flip counter\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839284,
                "title": "short-3-line-code-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n    int cnt = 0;\\n    for(int i = 0; i < target.size()-1; i++) if(target[i] != target[i+1]) cnt++;\\n    return (target[0] == \\'0\\') ?  cnt : cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n    int cnt = 0;\\n    for(int i = 0; i < target.size()-1; i++) if(target[i] != target[i+1]) cnt++;\\n    return (target[0] == \\'0\\') ?  cnt : cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694904,
                "title": "go-one-pass-o-n-o-1",
                "content": "Count the number of bits which is different from the previous bits.\\n\\nIf the previous bit is same as the current bit, we already flip the current bit to the right value when processing the previous bit.\\n\\n\\nn: Length of string `target`\\nTime: **O(n)**\\nExtra Space: **O(1)**\\n\\n**Go**\\n```Go\\nfunc minFlips(target string) int {\\n\\tres := 0\\n\\tif target[0] == byte(\\'1\\') {\\n\\t\\tres++\\n\\t}\\n\\tfor i := 1; i < len(target); i++ {\\n\\t\\tif target[i-1] != target[i] {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```Go\\nfunc minFlips(target string) int {\\n\\tres := 0\\n\\tif target[0] == byte(\\'1\\') {\\n\\t\\tres++\\n\\t}\\n\\tfor i := 1; i < len(target); i++ {\\n\\t\\tif target[i-1] != target[i] {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2670172,
                "title": "minimum-suffix-flips-go-one-pass-time-o-n-space-o-1",
                "content": "```go\\nfunc minFlips(target string) int {\\n\\n    var flips int\\n    \\n    for i := range target {\\n        if target[i] != \\'0\\' + byte(flips % 2) {\\n            flips++\\n        }\\n    }\\n    \\n    return flips\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc minFlips(target string) int {\\n\\n    var flips int\\n    \\n    for i := range target {\\n        if target[i] != \\'0\\' + byte(flips % 2) {\\n            flips++\\n        }\\n    }\\n    \\n    return flips\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2470709,
                "title": "clean-and-simple-4-line-python-solution-speed-99",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\n        count = (target.count(\\'01\\') + target.count(\\'10\\'))\\n        \\n        if target[0] == \\'1\\':\\n            count += 1\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\n        count = (target.count(\\'01\\') + target.count(\\'10\\'))\\n        \\n        if target[0] == \\'1\\':\\n            count += 1\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376872,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String s) {\\n        int ans = 0;\\n        char crr = \\'0\\';\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=crr){\\n                ans ++;\\n                crr = s.charAt(i);\\n            }\\n        }\\n        // System.out.println(ans);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minFlips(String s) {\\n        int ans = 0;\\n        char crr = \\'0\\';\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=crr){\\n                ans ++;\\n                crr = s.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304307,
                "title": "fastest-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int c=0;\\n        char flag=\\'0\\';\\n        for(char ch:target.toCharArray())\\n        {\\n            if(ch!=flag)\\n            {\\n                c++;\\n                flag=ch;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minFlips(String target) {\\n        int c=0;\\n        char flag=\\'0\\';\\n        for(char ch:target.toCharArray())\\n        {\\n            if(ch!=flag)\\n            {\\n                c++;\\n                flag=ch;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2298323,
                "title": "c-continous-stream-of-1s-and-0s",
                "content": "* Count Continous stream of 1s and 0s. But if the last most stream is of zero then dont add it in `op`. \\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int op = 0 , i = target.size() - 1 ;\\n        while(i >= 0){\\n            char curr = target[i] ;\\n            while(i >= 0 and target[i] == curr) --i ;\\n            if(i == -1 and curr == \\'0\\') continue ;\\n            ++op ;\\n        }\\n        \\n        return op ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int op = 0 , i = target.size() - 1 ;\\n        while(i >= 0){\\n            char curr = target[i] ;\\n            while(i >= 0 and target[i] == curr) --i ;\\n            if(i == -1 and curr == \\'0\\') continue ;\\n            ++op ;\\n        }\\n        \\n        return op ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280493,
                "title": "73-o-n-tc-and-70-o-1-sc-easy-python-solution",
                "content": "```\\ndef minFlips(self, target: str) -> int:\\n\\tn = len(target)\\n\\tans = 0\\n\\tfor i in range(n):\\n\\t\\tif (target[i] == \"0\" and ans%2) or (target[i] == \"1\" and ans%2 == 0):\\n\\t\\t\\tans += 1\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef minFlips(self, target: str) -> int:\\n\\tn = len(target)\\n\\tans = 0\\n\\tfor i in range(n):\\n\\t\\tif (target[i] == \"0\" and ans%2) or (target[i] == \"1\" and ans%2 == 0):\\n\\t\\t\\tans += 1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2203146,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int cnt=0;\\n        char prev=\\'0\\';\\n        for(char c:target.toCharArray()){\\n            if(prev!=c){\\n                cnt++; prev=c;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minFlips(String target) {\\n        int cnt=0;\\n        char prev=\\'0\\';\\n        for(char c:target.toCharArray()){\\n            if(prev!=c){\\n                cnt++; prev=c;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2122670,
                "title": "easy-greedy-solution-in-c-well-explained",
                "content": "We can use a variable ***last*** to know what value in the string target needs to be flipped.Initially ***last=1*** because the whole string is ***0*** and hence whenever there is ***1*** in the target it needs to flipped.\\nNow, once flip is performed the **last** value is also flipped because the initial string now contains all **1s** to the right of the index at which flip was performed.\\nWe flip the continuos segment of **last** to minimize the number of flips.\\n\\n***Code in C++***\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string &target) {\\n        int last=1, i=0,ans=0,n = target.length();\\n        while(i<n){\\n            if(target[i]-\\'0\\'==last){\\n                while(target[i]-\\'0\\'==last) i++;\\n                ans++;\\n                 last=!last;\\n            }else{\\n                i++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string &target) {\\n        int last=1, i=0,ans=0,n = target.length();\\n        while(i<n){\\n            if(target[i]-\\'0\\'==last){\\n                while(target[i]-\\'0\\'==last) i++;\\n                ans++;\\n                 last=!last;\\n            }else{\\n                i++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095335,
                "title": "single-loop-greedy-solution",
                "content": "class Solution {\\npublic:\\n\\n    int minFlips(string t) {\\n        int reg=0,n=t.size();\\n        if(t[0]==\\'1\\')reg++;\\n        for(int i=1;i<t.size();i++){\\n            if((t[i]==\\'0\\'&&t[i-1]==\\'1\\')||(t[i]==\\'1\\'&&t[i-1]==\\'0\\'))// finding the no. of switching regions(i.e. from 1->0 or 0->1)\\n                reg++;\\n        }\\n        return reg;\\n        //Please upvote if you like the solution \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09.......\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minFlips(string t) {\\n        int reg=0,n=t.size();\\n        if(t[0]==\\'1\\')reg++;\\n        for(int i=1;i<t.size();i++){\\n            if((t[i]==\\'0\\'&&t[i-1]==\\'1\\')||(t[i]==\\'1\\'&&t[i-1]==\\'0\\'))// finding the no. of switching regions(i.e. from 1->0 or 0->1)\\n                reg++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1960907,
                "title": "basic-solution-c-intuitive-just-check-previous-and-edit-continously",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int minFlips(string target) {\\n       \\n        char prev = \\'0\\';\\n        int count=0;\\n        \\n        for(int i=0; i<target.size(); i++)\\n        {\\n            if(target[i]!=prev)\\n            {\\n                count++;\\n                prev = target[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939784,
                "title": "4-liner-python",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        n=0\\n        for i in range(1,len(target)):\\n            n+=1 if target[i]!=target[i-1] else 0        \\n        return n+int(target[0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        n=0\\n        for i in range(1,len(target)):\\n            n+=1 if target[i]!=target[i-1] else 0        \\n        return n+int(target[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916592,
                "title": "easy-4-line-c-o-n",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int minFlips(string nums) {\\n        int c=nums[0]==\\'0\\'?0:1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1])c++;\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string nums) {\\n        int c=nums[0]==\\'0\\'?0:1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1])c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1765263,
                "title": "easy-python-solution",
                "content": "one flip is needed for every change in characters of s.\\nso we count the **flips**.\\n\\n```\\nclass Solution:\\n    def minFlips(self, target):\\n        prev = target[0]\\n        ans = int(prev)\\n        for ch in target[1:]:\\n            if ch != prev:\\n                prev = ch\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target):\\n        prev = target[0]\\n        ans = int(prev)\\n        for ch in target[1:]:\\n            if ch != prev:\\n                prev = ch\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719625,
                "title": "greedy-with-explanation-c-python-javascript-java",
                "content": "Even though the operation is given from right to left, it\\'s better to traverse left to right.\\nInitially all bits are 0, so state is false, and we just check if current bit matches the bit in the output.\\nIf it doesn\\'t, just update flips and change the configuration, even flips will mean 0s, and odd flips means 1s.\\n1-1 = 0 and 0 - 0 = 0, anything else means, we must flip.\\nE.g. \"00000\" -> \"10111\"\\n\"00000\"\\n```  ^```\\nFirst bit is a no match, so flip:\\n\"11111\"\\n``` `^```\\nNow second bit is a no match, so flip,\\n\"10000\"\\n```  `   ^```\\nNow third bit is a no match, you guessed it flip,\\n\"10111\"\\n\\nAnd the desired output state is reached.\\n\\nC++\\n```cpp\\nint flips = 0;\\nfor(const auto &bit: target) if(flips%2 - (bit-\\'0\\') != 0) flips++;\\nreturn flips;\\n```\\nPython\\n```py\\ndef minFlips(self, target: str) -> int:\\n    flips = 0\\n    for bit in target:\\n        if (ord(bit) - ord(\\'0\\')) - flips%2 != 0:\\n            flips += 1\\n    return flips\\n```\\nJavaScript\\n```js\\nlet flips = 0;\\n[...target].forEach((bit) => {\\n\\t// bit.charCodeAt(0) - \\'0\\'.charCodeAt(0) - flips%2 != 0\\n    if((bit == \\'1\\' && flips%2 === 0) || (bit == \\'0\\' && flips%2 === 1)) {\\n        flips++\\n   }\\n})\\nreturn flips\\n```\\nJava\\n```\\npublic int minFlips(String target) {\\n    int flips = 0;\\n    for(char bit: target.toCharArray()) {\\n        if((bit - \\'0\\') - flips%2 != 0) {\\n            flips += 1;\\n        }\\n    }\\n    return flips;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```  ^```\n``` `^```\n```  `   ^```\n```cpp\\nint flips = 0;\\nfor(const auto &bit: target) if(flips%2 - (bit-\\'0\\') != 0) flips++;\\nreturn flips;\\n```\n```py\\ndef minFlips(self, target: str) -> int:\\n    flips = 0\\n    for bit in target:\\n        if (ord(bit) - ord(\\'0\\')) - flips%2 != 0:\\n            flips += 1\\n    return flips\\n```\n```js\\nlet flips = 0;\\n[...target].forEach((bit) => {\\n\\t// bit.charCodeAt(0) - \\'0\\'.charCodeAt(0) - flips%2 != 0\\n    if((bit == \\'1\\' && flips%2 === 0) || (bit == \\'0\\' && flips%2 === 1)) {\\n        flips++\\n   }\\n})\\nreturn flips\\n```\n```\\npublic int minFlips(String target) {\\n    int flips = 0;\\n    for(char bit: target.toCharArray()) {\\n        if((bit - \\'0\\') - flips%2 != 0) {\\n            flips += 1;\\n        }\\n    }\\n    return flips;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1713099,
                "title": "c-intuition-explaination-concise-o-n-code",
                "content": "On working out examples you will yourself realise that, its better to iterate from left because if we start from right then our ans will keep on changing on every flip.\\nThe optimisation here is that we don\\'t actually need to flip the entire 0 string, we can just predict what the next character would be as 0 after very even flips will be 0 . \\n\\nThe code below can help u understand. \\nPlease upvote if it helped :)\\n\\n```\\nclass Solution {\\npublic:\\nint minFlips(string target) {\\n\\tint c = 0;\\n\\tint n = target.length();\\n\\tint i = 0, cnt = 0;\\n\\twhile (i < n) {\\n\\t\\tif (target[i] - \\'0\\' != c) {\\n\\t\\t\\tcnt++;\\n\\t\\t\\tc ^= 1;\\n\\t\\t}\\n\\n\\t\\ti++;\\n\\t}\\n\\treturn cnt;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint minFlips(string target) {\\n\\tint c = 0;\\n\\tint n = target.length();\\n\\tint i = 0, cnt = 0;\\n\\twhile (i < n) {\\n\\t\\tif (target[i] - \\'0\\' != c) {\\n\\t\\t\\tcnt++;\\n\\t\\t\\tc ^= 1;\\n\\t\\t}\\n\\n\\t\\ti++;\\n\\t}\\n\\treturn cnt;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704259,
                "title": "c-one-liner-regex-o-n",
                "content": "```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution \\n{\\n    public int MinFlips(string target) => Regex.Matches(\"0\" + target, \"(0(?=1))|(1(?=0))\").Count;\\n}\\n```\\nOR\\n```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution \\n{\\n    public int MinFlips(string target) => 2 * Regex.Matches(target, \"10\").Count + (target.Last() == \\'1\\' ? 1 : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution \\n{\\n    public int MinFlips(string target) => Regex.Matches(\"0\" + target, \"(0(?=1))|(1(?=0))\").Count;\\n}\\n```\n```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution \\n{\\n    public int MinFlips(string target) => 2 * Regex.Matches(target, \"10\").Count + (target.Last() == \\'1\\' ? 1 : 0);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616829,
                "title": "java-greedy-easy-why-medium-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n         char start=\\'0\\';\\n        int count =0;\\n        for(char ch:target.toCharArray()){\\n            if(ch!=start){\\n                start=ch;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n         char start=\\'0\\';\\n        int count =0;\\n        for(char ch:target.toCharArray()){\\n            if(ch!=start){\\n                start=ch;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597700,
                "title": "java-simple-greedy-solution",
                "content": "It is easy to observe the pattern, i.e if you start from left to right anytime there is a change in the character that means you have to do one operation to switch. Based upon that you can understand that the question is just to count the number of changes encountered while also checking if the start character is \\'0\\' you have do not have to final flip.\\n\\nTime Complexity:- O(n), where n = length of target\\nSpace Complexity:- O(1).\\n\\n```\\n\\t\\tint changes = 0;\\n        final int secondLastIndex = target.length() - 2;\\n        for (int i = secondLastIndex; i >= 0; i--) {\\n            final int nextIndex = i + 1;\\n            final char nextCharacter = target.charAt(nextIndex);\\n            final char currentCharacter = target.charAt(i);\\n            if (currentCharacter != nextCharacter) {\\n                changes++;\\n            }\\n        }\\n        return target.charAt(0) == \\'0\\' ? changes : changes + 1;\\n```",
                "solutionTags": [
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\n\\t\\tint changes = 0;\\n        final int secondLastIndex = target.length() - 2;\\n        for (int i = secondLastIndex; i >= 0; i--) {\\n            final int nextIndex = i + 1;\\n            final char nextCharacter = target.charAt(nextIndex);\\n            final char currentCharacter = target.charAt(i);\\n            if (currentCharacter != nextCharacter) {\\n                changes++;\\n            }\\n        }\\n        return target.charAt(0) == \\'0\\' ? changes : changes + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592552,
                "title": "c-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char ch=\\'0\\';\\n        int count=0;\\n        for(int i=0;i<target.size();i++){\\n            if(target[i]!=ch){\\n                count++;\\n                ch=target[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char ch=\\'0\\';\\n        int count=0;\\n        for(int i=0;i<target.size();i++){\\n            if(target[i]!=ch){\\n                count++;\\n                ch=target[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554888,
                "title": "easy-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int res=0;\\n\\t\\t//flip=true represents all bits from i to n-1 are flipped\\n        bool flip=false;\\n        for(auto i:target)\\n        {\\n\\t\\t\\t//get the char after flips\\n            char curr=(flip==true) ? \\'1\\'  : \\'0\\';\\n            if(curr!=i)\\n            {\\n                res++;\\n                flip=!flip;  //flip the bits from i to n-1\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int res=0;\\n\\t\\t//flip=true represents all bits from i to n-1 are flipped\\n        bool flip=false;\\n        for(auto i:target)\\n        {\\n\\t\\t\\t//get the char after flips\\n            char curr=(flip==true) ? \\'1\\'  : \\'0\\';\\n            if(curr!=i)\\n            {\\n                res++;\\n                flip=!flip;  //flip the bits from i to n-1\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533082,
                "title": "c-100-fast-o-n-t-c-o-1-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n     int ans=0;\\n        char next=\\'0\\';\\n      \\n\\t  for(int i=0; i<target.size(); i++){\\n            if(next!=target[i]) \\n            {\\n                ans++;\\n                next=target[i];\\n            }\\n        }\\n           return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n     int ans=0;\\n        char next=\\'0\\';\\n      \\n\\t  for(int i=0; i<target.size(); i++){\\n            if(next!=target[i]) \\n            {\\n                ans++;\\n                next=target[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1485731,
                "title": "c-brute-force-to-optimal-greedy-explained-clean-beginner-easy-to-understand",
                "content": "# ***Idea***\\n```\\n    This problem is a good greedy problem we have to obtain a specific configuration providied by target\\n    \\n    A flip operation is defined as follows:\\n        Choose any bulb (index i) of your current configuration.\\n        Flip each bulb from index i to index n - 1.\\n \\n    --------------------------------------------------------------------------------\\n    Brute force way :\\n        target = 10111\\n        traverse from right to left pick every 1 and apply operation\\n        \\n        10111 -> 01000 -> 00111 -> 00000\\n        \\n        Time : O(N^2) , space : O(1)\\n    --------------------------------------------------------------------------------\\n    we can do better by using greedy approach :\\n    Observation from brute force approach : we tries to flip a group of 1\\'s at a time\\n    From this we concludes that => res = (number of 1\\'s group + number of 0\\'s group) - 1 (first 0 group if it exists)\\n    \\n    take above example again : 10111\\n        we have 2 group of 1\\'s and 1 group of 0\\'s , first group is nonzero so we subtract nothing!!\\n        res = 2 + 1 = 3\\n        \\n    another example : 0010111 [same example with some 0\\'s appended at front]\\n        we have 2 group of 1\\'s + we have 2 group of 0\\'s BUT we have first group of 0\\'s so we subtract 1\\n        \\n        res = 2 + 2 - 1 = 3\\n    Time : O(N) , space : O(1)\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int num_of_grps = 0;\\n        \\n        for(int i = 0 ; i < target.size() ; ++i)\\n        {\\n            if(target[i] != target[i + 1])\\n                ++num_of_grps;\\n        }\\n        if(target[0] == \\'0\\')\\n            return num_of_grps - 1;\\n        else \\n            return num_of_grps;\\n    }\\n};\\n```\\n# ***If you liked the explanation , Give it an Upvote :)***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    This problem is a good greedy problem we have to obtain a specific configuration providied by target\\n    \\n    A flip operation is defined as follows:\\n        Choose any bulb (index i) of your current configuration.\\n        Flip each bulb from index i to index n - 1.\\n \\n    --------------------------------------------------------------------------------\\n    Brute force way :\\n        target = 10111\\n        traverse from right to left pick every 1 and apply operation\\n        \\n        10111 -> 01000 -> 00111 -> 00000\\n        \\n        Time : O(N^2) , space : O(1)\\n    --------------------------------------------------------------------------------\\n    we can do better by using greedy approach :\\n    Observation from brute force approach : we tries to flip a group of 1\\'s at a time\\n    From this we concludes that => res = (number of 1\\'s group + number of 0\\'s group) - 1 (first 0 group if it exists)\\n    \\n    take above example again : 10111\\n        we have 2 group of 1\\'s and 1 group of 0\\'s , first group is nonzero so we subtract nothing!!\\n        res = 2 + 1 = 3\\n        \\n    another example : 0010111 [same example with some 0\\'s appended at front]\\n        we have 2 group of 1\\'s + we have 2 group of 0\\'s BUT we have first group of 0\\'s so we subtract 1\\n        \\n        res = 2 + 2 - 1 = 3\\n    Time : O(N) , space : O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int num_of_grps = 0;\\n        \\n        for(int i = 0 ; i < target.size() ; ++i)\\n        {\\n            if(target[i] != target[i + 1])\\n                ++num_of_grps;\\n        }\\n        if(target[0] == \\'0\\')\\n            return num_of_grps - 1;\\n        else \\n            return num_of_grps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483119,
                "title": "very-clean-solution-o-n-time-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count = 0;\\n        char bulb = \\'0\\';\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(bulb != target[i])\\n            {\\n                bulb = target[i];\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count = 0;\\n        char bulb = \\'0\\';\\n        for(int i=0;i<target.length();i++)\\n        {\\n            if(bulb != target[i])\\n            {\\n                bulb = target[i];\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415116,
                "title": "cpp-12ms-94",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count=0;\\n        if(target[0] == \\'1\\') count++;\\n        for(int i=1;i<target.length();i++){\\n                if(target[i-1]!=target[i]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count=0;\\n        if(target[0] == \\'1\\') count++;\\n        for(int i=1;i<target.length();i++){\\n                if(target[i-1]!=target[i]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401570,
                "title": "java-o-n",
                "content": "class Solution {\\n    public int minFlips(String t) {\\n        \\n        char prevChar = \\'0\\';\\n        \\n        int cntr=0;\\n        \\n        for(int i=0;i<t.length();i++){\\n            \\n            char curChar = t.charAt(i);\\n            \\n            if(prevChar!=curChar){\\n                cntr++;\\n                prevChar=curChar;\\n            }\\n            \\n        }\\n        return cntr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minFlips(String t) {\\n        \\n        char prevChar = \\'0\\';\\n        \\n        int cntr=0;\\n        \\n        for(int i=0;i<t.length();i++){\\n            \\n            char curChar = t.charAt(i);\\n            \\n            if(prevChar!=curChar){\\n                cntr++;\\n                prevChar=curChar;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1355608,
                "title": "c-count-no-of-times-bulb-state-changes-99-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n\\t// Initial position is taken as 0\\n        int curr = 0,ans=0;\\n        for(int i=0;i<target.length();i++){\\n\\t\\t// For each number of time when the bulb state changes, 1 flip is to be done.\\n\\t\\t// E.g. 000111 : State changes once, so one flip. 111000: As we started from initial position 0, state\\n\\t\\t//changes to 1 and then 0. Thus, no. of flips is 2.\\n            if(target[i]-\\'0\\'!=curr){\\n                ans++;\\n                curr=target[i]-\\'0\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n\\t// Initial position is taken as 0\\n        int curr = 0,ans=0;\\n        for(int i=0;i<target.length();i++){\\n\\t\\t// For each number of time when the bulb state changes, 1 flip is to be done.\\n\\t\\t// E.g. 000111 : State changes once, so one flip. 111000: As we started from initial position 0, state\\n\\t\\t//changes to 1 and then 0. Thus, no. of flips is 2.\\n            if(target[i]-\\'0\\'!=curr){\\n                ans++;\\n                curr=target[i]-\\'0\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349307,
                "title": "simplest-java-o-n-one-pass",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        \\n        int result = 0;\\n        char[] chars = target.toCharArray();\\n        boolean flag = false;\\n        \\n        for(int i = 0; i < chars.length; i++) {\\n            if(chars[i] == \\'1\\' && flag == false) {\\n                result++;\\n                flag = true;\\n            }\\n            if(chars[i] == \\'0\\' && flag == true) {\\n                result++;\\n                flag = false;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        \\n        int result = 0;\\n        char[] chars = target.toCharArray();\\n        boolean flag = false;\\n        \\n        for(int i = 0; i < chars.length; i++) {\\n            if(chars[i] == \\'1\\' && flag == false) {\\n                result++;\\n                flag = true;\\n            }\\n            if(chars[i] == \\'0\\' && flag == true) {\\n                result++;\\n                flag = false;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346029,
                "title": "simplest-o-n-intuitive-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans = 0;\\n            int state = 0;\\n            for(int i=0;i<target.length();i++){\\n                if( target[i]-\\'0\\' != state){\\n                    ans++;\\n                    state = 1-state;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ans = 0;\\n            int state = 0;\\n            for(int i=0;i<target.length();i++){\\n                if( target[i]-\\'0\\' != state){\\n                    ans++;\\n                    state = 1-state;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293866,
                "title": "c-easy-short-code-o-n-time-complexity-o-1-space-complexity",
                "content": "**Goal:** Find number of bulb switches.\\n**Human method:** \\nExample:  target = \"10111\"\\nbulb states = 00000 (start, all OFF)\\n1) Start from 1st light bulb and turn all lights ON if target[0] is 1). Move to 2nd light bulb. \\nbulb states = **1**1111\\n3) ( all ON)\\n2) Here again, if target[1] is different from 2nd bulbs current \"bulb state\" then switch at 2nd bulb. (In our case it is).\\nbulb states = 1**0**000\\n3) Redo step 2. I.e check if 3rd bulbs current state is same as target[2] then continue, else switch at 3rd buld. (In our case, no switch).\\nRepeating the above steps give:\\n1) 00000\\n2)  **1**1111\\n3) 1**0**000\\n4) 10**1**11\\n\\nTotal changes highlighted  = 3 (Correct)\\n\\n**Looking at individual light bulb changes:**\\n\\nHere: 0 - OFF, 1- ON\\n1) At start all 0. So 1st bulb = OFF. But target = ON. Hence switching all bulbs ON. Now first bulb is ON.  number of switches (ns = 1)\\n2)  Second bulb is in the same state as 1st bulbs current state that is ON. But target = OFF. Hence, switching all bulbs after 2nd (& 2nd) OFF. Now, 2nd bulb is OFF. [ns=2].\\n3) 3rd bulb is currently OFF. target is ON. Hence we switch. [ns = 3]\\n4) 4th bulb is ON and desired is ON. Hence no switching. [ns = 3]\\n5) 5th bulb is ON and desired is ON. Hence no switching. [ns = 3]\\n\\nHence, from above we can observe that switching happens if the previous light bulbs state is different from current light bulbs target. \\n[Further clarification: Current light bulb (index -[i]) state is the same as previous [i-1] because all switches after (and including ) [i-1] are switched ON or OFF based on the target of previous [i-1] bulb\\'s target.\\n\\nThis code below checks each individual element and if there is a change if increases the count in ```res```.\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int res= target[0] ==\\'0\\'? 0:1;\\n        for(int i=1; i<size(target);++i) if(target[i]!=target[i-1]) ++res;\\n        return res;\\n    }\\n};\\n```\\n\\nHope this helps :)\\nPs: This is my first post",
                "solutionTags": [],
                "code": "```res```\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int res= target[0] ==\\'0\\'? 0:1;\\n        for(int i=1; i<size(target);++i) if(target[i]!=target[i-1]) ++res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290367,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.size(), cnt = 0;\\n        bool flag = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = \\'0\\';\\n            if(flag)\\n                c = \\'1\\';\\n            if(c != target[i])\\n            {\\n                flag = !flag;\\n                cnt += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.size(), cnt = 0;\\n        bool flag = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = \\'0\\';\\n            if(flag)\\n                c = \\'1\\';\\n            if(c != target[i])\\n            {\\n                flag = !flag;\\n                cnt += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259430,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\nint minFlips(string target) {\\n\\n    int ans=0;\\n    char curr=\\'0\\';\\n    for(int i=0;i<target.size();i++)\\n    {\\n        if(curr!=target[i])\\n        {\\n            curr=target[i];\\n            ans++;\\n        }\\n    }\\n    return ans;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minFlips(string target) {\\n\\n    int ans=0;\\n    char curr=\\'0\\';\\n    for(int i=0;i<target.size();i++)\\n    {\\n        if(curr!=target[i])\\n        {\\n            curr=target[i];\\n            ans++;\\n        }\\n    }\\n    return ans;\\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185096,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int found = 1,c=0;\\n        for(int i=0; i<target.size(); i++) {\\n            if(target[i]-\\'0\\' == found) {\\n                c++;\\n                found = !found;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int found = 1,c=0;\\n        for(int i=0; i<target.size(); i++) {\\n            if(target[i]-\\'0\\' == found) {\\n                c++;\\n                found = !found;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173746,
                "title": "faster-than-96-34-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int count = 0;\\n        char j = \\'0\\';\\n        for (char c : target.toCharArray()) {\\n\\n            if (c != j) {\\n                count++;\\n                j = j == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int count = 0;\\n        char j = \\'0\\';\\n        for (char c : target.toCharArray()) {\\n\\n            if (c != j) {\\n                count++;\\n                j = j == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157678,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        i=0\\n        count = 0\\n        while(i<len(target) and target[i]==\\'0\\'):\\n            i+=1\\n        while(i<len(target)):\\n            if(i==0 or target[i]!=target[i-1]):\\n                count+=1\\n            i+=1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minFlips(self, target):\\n        i=0\\n        count = 0\\n        while(i<len(target) and target[i]==\\'0\\'):\\n            i+=1\\n        while(i<len(target)):\\n            if(i==0 or target[i]!=target[i-1]):\\n                count+=1\\n            i+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120196,
                "title": "share-my-easy-c-solution-o-n",
                "content": "### **Idea**\\n\\n> We just need to scan all the character of the string from head to tail. And we initialize a flip status starts with `0`. If the character is not the same as current flip status, then flip all the characters from the current position to the end and also update the flip status. \\n \\nConsider the following two examples.\\n- Example-1:  Target to`10111` (n = 5)\\n0. `00000`\\n1. `11111`    flip `index 0 ~ n-1`\\n2. `10000`    flip `index 1 ~ n-1`\\n3. `10111`    flip `index 2 ~ n-1`\\n\\n- Example-2:  Target to `101` (n = 3)\\n0. `000`       \\n1. `111`        flip `index 0 ~ n-1`\\n2. `100`        flip `index 1 ~ n-1`\\n3. `101`        flip `index 2 ~ n-1`\\n\\n\\n### **Code**\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int res = 0;\\n        char curr = \\'0\\';\\n        for (auto &e : target){\\n            if (e != curr){\\n                ++res;\\n                curr = curr == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n### **Performance**\\n- Runtime: 12 ms, faster than 97.52%\\n- Memory Usage: 9.3 MB, less than 95.81%",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int res = 0;\\n        char curr = \\'0\\';\\n        for (auto &e : target){\\n            if (e != curr){\\n                ++res;\\n                curr = curr == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103279,
                "title": "python-medium",
                "content": "\\tdef minFlips(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        if len(set(target))==1:\\n            return 0\\n        if target[0]==\"0\":\\n            count=0\\n        else:\\n            count=1\\n        for i in range(len(target)-1):\\n            if target[i]!=target[i+1]:\\n                count=count+1\\n        return count",
                "solutionTags": [],
                "code": "\\tdef minFlips(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        if len(set(target))==1:\\n            return 0\\n        if target[0]==\"0\":\\n            count=0\\n        else:\\n            count=1\\n        for i in range(len(target)-1):\\n            if target[i]!=target[i+1]:\\n                count=count+1\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 1081041,
                "title": "java-easy-solution-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int len = target.length();\\n        int count = 0;\\n        int flippedNum = 0;\\n        for(int i=0;i<len;i++) {\\n            if(flippedNum != (target.charAt(i) - \\'0\\')) {\\n                if(flippedNum == 0) {\\n                    flippedNum = 1;\\n                } else {\\n                    flippedNum = 0;\\n                }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int len = target.length();\\n        int count = 0;\\n        int flippedNum = 0;\\n        for(int i=0;i<len;i++) {\\n            if(flippedNum != (target.charAt(i) - \\'0\\')) {\\n                if(flippedNum == 0) {\\n                    flippedNum = 1;\\n                } else {\\n                    flippedNum = 0;\\n                }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055976,
                "title": "python3-100-faster",
                "content": "```\\ndef minFlips(self, target: str) -> int:\\n        c= 2 * target.count(\\'10\\')\\n        return  c+ 1 if target[-1] == \\'1\\' else c\\n```",
                "solutionTags": [],
                "code": "```\\ndef minFlips(self, target: str) -> int:\\n        c= 2 * target.count(\\'10\\')\\n        return  c+ 1 if target[-1] == \\'1\\' else c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 993651,
                "title": "java-streams-and-scala-solutions-for-the-curious",
                "content": "These solutions are way slower than the imperative one but they\\'re fun to understand:\\n\\nThe main idea is to figure out what will the accumulator be for the reduce operation. \\n\\nWe learn from the imperative solution that we need two variables, one to accumulate the flips and one to remember the past state:\\n\\n```\\n\\tpublic int minFlips(String target) {\\n\\t\\tint numberOfFlips = 0;\\n\\t\\tchar last = \\'0\\';\\n\\t\\t\\n\\t\\tfor(char c : target.toCharArray()) {\\n\\t\\t\\tif (c != last) {\\n\\t\\t\\t\\tnumberOfFlips++;\\n\\t\\t\\t\\tlast = c;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn numberOfFlips;\\n\\t}\\n```\\n(Runtime: 4 ms, Memory Usage: 39.3 MB)\\n\\nSo our accumulator must have two members somehow. I found two possibilities \\n1. the more direct and simple to get: a tuple / array with two elements\\n2. the hacky solution, if you insist in having a single member: accumulate the flips as absolute value and use the sign to remember past state\\n\\n**So for the first strategy:**\\nA. My first solution that is kind of lengthy and has a lot of imperative smell:\\n\\n**Java**\\nRuntime: 11 ms\\nMemory Usage: 39.7 MB\\n```\\n\\tpublic int minFlips(String target) {\\n\\t\\treturn target.chars()\\n\\t\\t\\t\\t.mapToObj(c -> new int[]{c - \\'0\\', 1})\\n\\t\\t\\t\\t.reduce(new int[]{0, 0}, Solution::accumulateSignFlipsOperatorWithArrays)\\n\\t\\t\\t\\t[1];\\n\\t}\\n\\t\\n\\tprivate static int[] accumulateSignFlipsOperatorWithArrays(int[] acc, int[] element) {\\n\\t\\tif (element[0] != acc[0]) {\\n\\t\\t\\tacc[0] = element[0];\\n\\t\\t\\tacc[1] += element[1];\\n\\t\\t}\\n\\t\\treturn acc;\\n\\t}\\n```\\n\\nB. Then a good friend was curious how does it look like in Scala:\\n\\n**Scala**\\nRuntime: 520 ms (huge difference)\\nMemory Usage: 57.8 MB\\n\\n```\\nobject Solution {\\n  def minFlips(target: String): Int =\\n    target\\n      .map(c => (c - \\'0\\', 1))\\n      .fold((0, 0))((acc, c) => if (c._1 != acc._1) (c._1, acc._2 + c._2) else acc)\\n      ._2\\n}\\n```\\n\\nC. And then the Scala solution gave me some ideas how to shorten the Java solution (do not reuse the arrays and simulate the expression based returns with the ternary operator)\\n\\n**Java**\\nRuntime: 11 ms\\nMemory Usage: 39.5 MB\\n\\n```\\npublic static int minFlips(String target) {\\n\\t\\treturn target.chars()\\n\\t\\t\\t\\t.mapToObj(c -> new int[]{c - \\'0\\', 1})\\n\\t\\t\\t\\t.reduce(new int[]{0, 0}, (acc, elem) -> elem[0] != acc[0] ? new int[]{elem[0], acc[1] + elem[1]} : acc)\\n\\t\\t\\t\\t[1];\\n\\t}\\n```\\n\\nAnd to my surprise the time has not changed and the memory usage dropped a bit (?!)\\n\\n**The second strategy:**\\nThe hacky solution with only one member for the accumulator where the sign is representing past state and the accumulator sums absolute values:\\n\\n```\\nclass Solution {\\n\\tpublic static int minFlips(String target) {\\n\\t\\treturn Math.abs(target.chars()\\n\\t\\t\\t\\t.map(c -> c == \\'0\\' ?  1 : -1)\\n\\t\\t\\t\\t.reduce(1, (acc, c) -> acc / c < 0 ? -acc + c : acc)\\n\\t\\t\\t\\t) - 1;\\n\\t}\\n}\\n```\\nRuntime: 8 ms\\nMemory Usage: 39.3 MB\\n\\nI hope you enjoyed these and if you have any ideas for improvements please share.\\n\\nThanks\\n\\n\\n\\n\\t\\n\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minFlips(String target) {\\n\\t\\tint numberOfFlips = 0;\\n\\t\\tchar last = \\'0\\';\\n\\t\\t\\n\\t\\tfor(char c : target.toCharArray()) {\\n\\t\\t\\tif (c != last) {\\n\\t\\t\\t\\tnumberOfFlips++;\\n\\t\\t\\t\\tlast = c;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn numberOfFlips;\\n\\t}\\n```\n```\\n\\tpublic int minFlips(String target) {\\n\\t\\treturn target.chars()\\n\\t\\t\\t\\t.mapToObj(c -> new int[]{c - \\'0\\', 1})\\n\\t\\t\\t\\t.reduce(new int[]{0, 0}, Solution::accumulateSignFlipsOperatorWithArrays)\\n\\t\\t\\t\\t[1];\\n\\t}\\n\\t\\n\\tprivate static int[] accumulateSignFlipsOperatorWithArrays(int[] acc, int[] element) {\\n\\t\\tif (element[0] != acc[0]) {\\n\\t\\t\\tacc[0] = element[0];\\n\\t\\t\\tacc[1] += element[1];\\n\\t\\t}\\n\\t\\treturn acc;\\n\\t}\\n```\n```\\nobject Solution {\\n  def minFlips(target: String): Int =\\n    target\\n      .map(c => (c - \\'0\\', 1))\\n      .fold((0, 0))((acc, c) => if (c._1 != acc._1) (c._1, acc._2 + c._2) else acc)\\n      ._2\\n}\\n```\n```\\npublic static int minFlips(String target) {\\n\\t\\treturn target.chars()\\n\\t\\t\\t\\t.mapToObj(c -> new int[]{c - \\'0\\', 1})\\n\\t\\t\\t\\t.reduce(new int[]{0, 0}, (acc, elem) -> elem[0] != acc[0] ? new int[]{elem[0], acc[1] + elem[1]} : acc)\\n\\t\\t\\t\\t[1];\\n\\t}\\n```\n```\\nclass Solution {\\n\\tpublic static int minFlips(String target) {\\n\\t\\treturn Math.abs(target.chars()\\n\\t\\t\\t\\t.map(c -> c == \\'0\\' ?  1 : -1)\\n\\t\\t\\t\\t.reduce(1, (acc, c) -> acc / c < 0 ? -acc + c : acc)\\n\\t\\t\\t\\t) - 1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990919,
                "title": "java-4-ms-single-pass",
                "content": "The answer is number of groups of 0\\'s and 1\\'s ignoring leftmost 0\\'s\\neg.\\n1100101\\n11  00  1  0  1\\nnumber of groups is 5 so answer is 5\\neg.\\n0001111\\n000  1111\\ntwo groups but ignore leftmost 0\\'s so answer is 1\\n```\\nclass Solution {\\n    public int minFlips(String S)\\n    {\\n        char[] s = S.toCharArray();\\n        int n=0,\\n        i=0;\\n        while(i<s.length && s[i]==\\'0\\')\\n        {\\n            i++;\\n        }\\n        while(i<s.length)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                n++;\\n            }\\n            while(i<s.length && s[i]==\\'1\\')\\n            {\\n                i++;\\n            }\\n            if(i<s.length && s[i]==\\'0\\')\\n            {\\n                n++;\\n            }\\n            while(i<s.length && s[i]==\\'0\\')\\n            {\\n                i++;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String S)\\n    {\\n        char[] s = S.toCharArray();\\n        int n=0,\\n        i=0;\\n        while(i<s.length && s[i]==\\'0\\')\\n        {\\n            i++;\\n        }\\n        while(i<s.length)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                n++;\\n            }\\n            while(i<s.length && s[i]==\\'1\\')\\n            {\\n                i++;\\n            }\\n            if(i<s.length && s[i]==\\'0\\')\\n            {\\n                n++;\\n            }\\n            while(i<s.length && s[i]==\\'0\\')\\n            {\\n                i++;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969127,
                "title": "easy-java-solution",
                "content": "# class Solution {\\n    public int minFlips(String target){  \\n      int ans=0;\\n        char bit=\\'0\\';\\n        for(int i=0;i<target.length();i++){\\n            char c=target.charAt(i);\\n            if(c!=bit){\\n                ans++;\\n                bit=target.charAt(i);\\n            }\\n        }\\n      return ans;\\n     \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minFlips(String target){  \\n      int ans=0;\\n        char bit=\\'0\\';\\n        for(int i=0;i<target.length();i++){\\n            char c=target.charAt(i);\\n            if(c!=bit){\\n                ans++;\\n                bit=target.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963638,
                "title": "c-easy-solution-o-n-time-o-1-space-faster-than-86",
                "content": "***If the value at the current  index is same as the previous index then the time to flip both the elements  will be the same.*** \\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.length();\\n        int count = 0;\\n        char prev = \\'0\\';\\n        for(int i=0;i<n;i++) {\\n            if(target[i]!=prev)\\n            {\\n                count++;\\n                prev = target[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.length();\\n        int count = 0;\\n        char prev = \\'0\\';\\n        for(int i=0;i<n;i++) {\\n            if(target[i]!=prev)\\n            {\\n                count++;\\n                prev = target[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946541,
                "title": "o-n-time-without-extra-space",
                "content": "We just need to calculate the number of times the bulb\\'s status is not the same as the previous bulb. Add 1 if the 1st bulb is on(i.e 1)\\n\\n```\\nint minFlips(string target) {\\n        char p = \\'0\\';\\n        int ans = 0;\\n        for (auto c:target){\\n            if(p!=c){\\n                ans++;\\n                p = c;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minFlips(string target) {\\n        char p = \\'0\\';\\n        int ans = 0;\\n        for (auto c:target){\\n            if(p!=c){\\n                ans++;\\n                p = c;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918895,
                "title": "c-simple-o-n-solution-with-explanation",
                "content": "We only need to consider how many consecutive \\'1\\' appears in our string, and don\\'t forget if the string end with \\'1\\' situation.\\n```\\nclass Solution \\n{\\npublic:\\n    int minFlips(string target) \\n    {\\n        int ret = 0;\\n        for(int i = 0; i < target.size(); i++)\\n        {\\n            if(i != target.size() - 1 && target[i] == \\'1\\' && target[i + 1] == \\'0\\')\\n                ret += 2;\\n        }\\n        return target.back() == \\'1\\' ? ret + 1 : ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minFlips(string target) \\n    {\\n        int ret = 0;\\n        for(int i = 0; i < target.size(); i++)\\n        {\\n            if(i != target.size() - 1 && target[i] == \\'1\\' && target[i + 1] == \\'0\\')\\n                ret += 2;\\n        }\\n        return target.back() == \\'1\\' ? ret + 1 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910462,
                "title": "java-simple-and-fast",
                "content": "Check 2 conditions\\n1) If the character is 0 and switch is on\\n2) If the character is 1 and switch is off\\n\\n```\\nclass Solution {\\n    //At every index match the state..if the state is different.. we need a flip\\n    public int minFlips(String target) {\\n        int minCount = 0;\\n        boolean off = true;\\n        for(char c : target.toCharArray()){\\n            if((c == \\'0\\' && !off) || (c == \\'1\\' && off)){\\n                off = !off;\\n                minCount++;\\n            }\\n        }\\n        return minCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //At every index match the state..if the state is different.. we need a flip\\n    public int minFlips(String target) {\\n        int minCount = 0;\\n        boolean off = true;\\n        for(char c : target.toCharArray()){\\n            if((c == \\'0\\' && !off) || (c == \\'1\\' && off)){\\n                off = !off;\\n                minCount++;\\n            }\\n        }\\n        return minCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907663,
                "title": "simple-c-solution-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n,i,cnt=0,flip=0;\\n        vector<int> ans;\\n        for(i=0;i<target.size();i++){\\n                if(target[i]==\\'1\\'&&cnt==0){\\n                        cnt++;\\n                        if(i==target.size()-1){\\n                                ans.push_back(cnt);\\n                        }\\n                }\\n                else if(target[i]==\\'1\\'&&cnt!=0){\\n                        cnt++;\\n                        if(i==target.size()-1){\\n                                ans.push_back(cnt);\\n                        }\\n                }\\n                else if(target[i]==\\'0\\'&&cnt!=0){\\n                        ans.push_back(cnt);\\n                        cnt=0;\\n                }\\n        }\\n        if(target[target.size()-1]==\\'1\\'){\\n                if(ans.size()>1)\\n                flip=(ans.size()-1)*2+1;\\n                else flip=1;\\n        }\\n        else{\\n                flip=ans.size()*2;\\n        }\\n            return flip;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n,i,cnt=0,flip=0;\\n        vector<int> ans;\\n        for(i=0;i<target.size();i++){\\n                if(target[i]==\\'1\\'&&cnt==0){\\n                        cnt++;\\n                        if(i==target.size()-1){\\n                                ans.push_back(cnt);\\n                        }\\n                }\\n                else if(target[i]==\\'1\\'&&cnt!=0){\\n                        cnt++;\\n                        if(i==target.size()-1){\\n                                ans.push_back(cnt);\\n                        }\\n                }\\n                else if(target[i]==\\'0\\'&&cnt!=0){\\n                        ans.push_back(cnt);\\n                        cnt=0;\\n                }\\n        }\\n        if(target[target.size()-1]==\\'1\\'){\\n                if(ans.size()>1)\\n                flip=(ans.size()-1)*2+1;\\n                else flip=1;\\n        }\\n        else{\\n                flip=ans.size()*2;\\n        }\\n            return flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905568,
                "title": "very-easy-cpp-xor-solution",
                "content": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        int flip=0;\\n         int count=0;\\n        for(int i=0;i<target.size();i++){\\n            if(target[i]-\\'0\\'!=flip){\\n                flip = flip^1;\\n            count++;\\n        }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        int flip=0;\\n         int count=0;\\n        for(int i=0;i<target.size();i++){\\n            if(target[i]-\\'0\\'!=flip){\\n                flip = flip^1;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 837102,
                "title": "best-solution-you-gonna-have-in-java",
                "content": "Remeber we should not update the result if zero is mounted at starting postion of target. And after that every time the digit changes the result is incremented by one.\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char[] str = target.toCharArray();\\n        int result = 0;\\n        char prev = \\'0\\';\\n        \\n        for(int i=0;i<str.length;i++){\\n            if(str[i] != prev){\\n                prev = str[i];\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char[] str = target.toCharArray();\\n        int result = 0;\\n        char prev = \\'0\\';\\n        \\n        for(int i=0;i<str.length;i++){\\n            if(str[i] != prev){\\n                prev = str[i];\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825951,
                "title": "java-4-lines-simple",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int ans = target.charAt(0)==\\'1\\'?1:0;\\n        for(int i=1;i<target.length();i++)\\n            if(target.charAt(i-1)!=target.charAt(i))\\n                ans++;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int ans = target.charAt(0)==\\'1\\'?1:0;\\n        for(int i=1;i<target.length();i++)\\n            if(target.charAt(i-1)!=target.charAt(i))\\n                ans++;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818597,
                "title": "c-with-explanation-for-1529",
                "content": "Example: 1011101\\n\\nThe transitions we see are: \\n```\\n0000000 -> [0,7] 1111111 -> [1,6] 1000000 -> [2,5] 1011111 -> [5,2] 1011100 -> [6,1] 1011101\\n```\\n[ ] indicates index of bulb and how many to flip from there.\\n\\nWe quickly see that flips are required when there is a transition - a rising edge - from 0 -> 1 or a falling edge 1 -> 0. \\n\\n```\\n  1   0   1   1   1   0   1\\n+---+   +-----------+   +---\\n|   |   |           |   |      <-- edges = 5\\n+   +---+           +---+   \\n```\\n\\nTherefore, we can simply count them as follows:\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string t) {\\n        char p = \\'0\\'; int sz = t.size(), i = 0, c = 0;\\n        while(i < sz) { c += p != t[i]; p = t[i++]; }\\n        return c;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n0000000 -> [0,7] 1111111 -> [1,6] 1000000 -> [2,5] 1011111 -> [5,2] 1011100 -> [6,1] 1011101\\n```\n```\\n  1   0   1   1   1   0   1\\n+---+   +-----------+   +---\\n|   |   |           |   |      <-- edges = 5\\n+   +---+           +---+   \\n```\n```\\nclass Solution {\\npublic:\\n    int minFlips(string t) {\\n        char p = \\'0\\'; int sz = t.size(), i = 0, c = 0;\\n        while(i < sz) { c += p != t[i]; p = t[i++]; }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811644,
                "title": "python-pythonic-solution-o-n",
                "content": "A simple solution for a simple problem.\\n\\n``` python\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        cnt = int(target[0])\\n        for b1, b2 in zip(target, target[1:]): # go through both bulbs at once\\n            if b1 != b2: cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` python\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        cnt = int(target[0])\\n        for b1, b2 in zip(target, target[1:]): # go through both bulbs at once\\n            if b1 != b2: cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791887,
                "title": "python3-visualized-solution-beats-99-48",
                "content": "You don\\'t really need to do the flip.\\nThis can be done through observation.\\nWe can count how many continuous bits do we have (i.e. \\'000...0\\' and \\'111...1\\' blocks) to get to the answer.\\nThe only thing we need to notice is that we start when encounter first \\'1...1\\' block, because if it\\'s all zero, we don\\'t need to flip.\\n\\nSo the algorithm is count continuous blocks, that\\'ll explain everything.\\n\\n![image](https://assets.leetcode.com/users/images/d19ef059-62b3-4548-a52c-8f5c8da6a143_1597429035.1340857.png)\\n\\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        flipcount=0\\n        prev=\\'0\\'\\n        for c in target:\\n            if(c!=prev):\\n                prev=c\\n                flipcount+=1\\n        return flipcount\\n```\\n\\nComplexity:\\nObviously, we need to scan the string once and only once,\\nso it\\'s O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        flipcount=0\\n        prev=\\'0\\'\\n        for c in target:\\n            if(c!=prev):\\n                prev=c\\n                flipcount+=1\\n        return flipcount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789078,
                "title": "100-fast-c-cpp",
                "content": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        char ch=\\'0\\';\\n        int count=0;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(ch!=target[i])\\n            {\\n                count++;\\n                ch=target[i];\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        char ch=\\'0\\';\\n        int count=0;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(ch!=target[i])\\n            {\\n                count++;\\n                ch=target[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 772183,
                "title": "java-o-n-solution-with-explanation",
                "content": "We can rephase this problem. How many steps to change from the \"target\" to all zeros?\\nFor example:\\nTarget = \"10111\" -> End Pattern = \"00000\"\\nWe start from the leftmost character.\\nreadIdx = 0. char = 1. Since it\\'s \\'1\\', then we need to flip it.  **flipCount = 1**\\nreadIdx = 1. char = 0. We did a flip at index 0, so the current char should become 1.   **flipCount = 2**\\nreadIdx = 2. char = 1. We did two flips (cancelled out) above, so the current char at this index is still 1. **flipCount = 3**\\nreadIdx = 3. char = 1. We did three flips above, so the current char at this index is 0. **flipCount = 3**\\nreadIdx = 4. char = 1. We did three flips above, so the current char at this index is 0. **flipCount = 3**\\n\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int steps = 0;\\n        char[] targetArr = target.toCharArray();\\n        int readIdx = 0;\\n        while (readIdx < targetArr.length) {\\n            boolean isOne = targetArr[readIdx] == \\'1\\';\\n            if (steps % 2 != 0) {\\n                isOne = !isOne;\\n            }\\n            if (isOne) {\\n                steps++;\\n            }\\n            readIdx++;\\n        }\\n        return steps;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minFlips(String target) {\\n        int steps = 0;\\n        char[] targetArr = target.toCharArray();\\n        int readIdx = 0;\\n        while (readIdx < targetArr.length) {\\n            boolean isOne = targetArr[readIdx] == \\'1\\';\\n            if (steps % 2 != 0) {\\n                isOne = !isOne;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 762454,
                "title": "simple-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        if(s.size()==0)return 0;\\n        int c=0;\\n        if(s[0]==\\'1\\')c++;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]!=s[i-1])c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string s) {\\n        if(s.size()==0)return 0;\\n        int c=0;\\n        if(s[0]==\\'1\\')c++;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]!=s[i-1])c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761425,
                "title": "rust-one-pass-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_flips(target: String) -> i32 {\\n        let (mut flips, mut bit) = (0, \\'0\\');\\n        \\n        for l in target.chars() {\\n            if l != bit {\\n                flips += 1;\\n                bit = if bit == \\'0\\' { \\'1\\' } else { \\'0\\' }\\n            }\\n        }\\n        \\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_flips(target: String) -> i32 {\\n        let (mut flips, mut bit) = (0, \\'0\\');\\n        \\n        for l in target.chars() {\\n            if l != bit {\\n                flips += 1;\\n                bit = if bit == \\'0\\' { \\'1\\' } else { \\'0\\' }\\n            }\\n        }\\n        \\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761271,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int result = 0;\\n        char prev = \\'0\\';\\n        for (int i = 0; i < target.length(); i++) {\\n            if (prev != target.charAt(i)) {\\n                result ++;\\n                prev = target.charAt(i);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int result = 0;\\n        char prev = \\'0\\';\\n        for (int i = 0; i < target.length(); i++) {\\n            if (prev != target.charAt(i)) {\\n                result ++;\\n                prev = target.charAt(i);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761236,
                "title": "c-one-liner",
                "content": "```\\npublic int MinFlips(string target) => target\\n\\t.Select((c, i) => (A: i == 0 ? \\'0\\' : target[i - 1], B: c))\\n\\t.Select(t => (t.A - \\'0\\') ^ (t.B - \\'0\\'))\\n\\t.Sum();\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MinFlips(string target) => target\\n\\t.Select((c, i) => (A: i == 0 ? \\'0\\' : target[i - 1], B: c))\\n\\t.Select(t => (t.A - \\'0\\') ^ (t.B - \\'0\\'))\\n\\t.Sum();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760227,
                "title": "java-solution-o-n",
                "content": "class Solution {\\n    public int minFlips(String target) {\\n\\n        int n =target.length();        \\n        char[] str=target.toCharArray();\\n        \\n        int count=str[0]-\\'0\\';\\n        \\n        for(int i=1;i<n;i++)\\n            if(str[i]!=str[i-1])\\n                count++;\\n             \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minFlips(String target) {\\n\\n        int n =target.length();        \\n        char[] str=target.toCharArray();\\n        \\n        int count=str[0]-\\'0\\';\\n        \\n        for(int i=1;i<n;i++)\\n            if(str[i]!=str[i-1])\\n                count++;\\n             \\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 760219,
                "title": "javascript-clean-3-liner-o-n-no-bit-manipulation",
                "content": "```javascript\\nvar minFlips = function(target) {\\n    // remove the leading zeros, they have no effect\\n    let alt = 0; target = target.replace(/^0+/, \\'\\');\\n    \\n    for(let i = 0; i < target.length; i++) {\\n        if(target[i] !== target[i+1]) alt++;\\n    }\\n    return alt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minFlips = function(target) {\\n    // remove the leading zeros, they have no effect\\n    let alt = 0; target = target.replace(/^0+/, \\'\\');\\n    \\n    for(let i = 0; i < target.length; i++) {\\n        if(target[i] !== target[i+1]) alt++;\\n    }\\n    return alt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759937,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char a=\\'0\\';\\n        int count=0;\\n        int i=0;\\n    while(i<target.length()){\\n        if(a==target.charAt(i)){\\n            i++;\\n        }\\n        else{\\n            if(a==\\'0\\'){\\n                a=\\'1\\';\\n            }\\n            else{\\n                a=\\'0\\';\\n            }\\n            count++;\\n        }\\n    }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minFlips(String target) {\\n        char a=\\'0\\';\\n        int count=0;\\n        int i=0;\\n    while(i<target.length()){\\n        if(a==target.charAt(i)){\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 757785,
                "title": "python-3-lots-of-text-4-lines-code",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \"\"\"\\n        Given a target sequence of bulbs on and off and starting\\n        with all bulbs off, this program determines the minimum\\n        number of flips needed to reach the target.  Each flip\\n        causes the bulbs at the flip location and to the right\\n        to switch from off to on or on to off.\\n\\n        :param target: target sequence of 1\\'s and 0\\'s where a 1\\n                       represents bulb on and 0 represents bulb off\\n        :type target: str\\n        :return: number of bulb flips to reach target\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        The target sequence of bulbs is partitioned into segments.\\n        Each segment of bulbs is either all on (1\\'s) or all off (0\\'s).\\n        The initial state of the bulbs is all off. The sequence of\\n        flips starts at the first bulb of the rightmost segment and\\n        proceeds one segment at a time going left until the leftmost\\n        segment of 1\\'s in target is reached and flipped on.\\n        \\n        For example, if the target is \"001011101\", the sequence of\\n        flips would look like:\\n        \\n                target: 0 0 1 0 1 1 1 0 1\\n                bulbs:  0 0 0 0 0 0 0 0 0   Initial State\\n                        0 0 0 0 0 0 0 0 1   Flip 1\\n                        0 0 0 0 0 0 0 1 0   Flip 2\\n                        0 0 0 0 1 1 1 0 1   Flip 3\\n                        0 0 0 1 0 0 0 1 0   Flip 4\\n                        0 0 1 0 1 1 1 0 1   Flip 5\\n        \\n        Note that the bulbs represented are untouched.\\n        \\n        The number of segments is counted by detecting 0-to-1\\n        and 1-to-0 transitions.\\n        \"\"\"\\n        segments = target.count( \"01\" ) + target.count( \"10\" )\\n        if target[0] == \\'1\\':\\n            return segments + 1\\n        return segments\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \"\"\"\\n        Given a target sequence of bulbs on and off and starting\\n        with all bulbs off, this program determines the minimum\\n        number of flips needed to reach the target.  Each flip\\n        causes the bulbs at the flip location and to the right\\n        to switch from off to on or on to off.\\n\\n        :param target: target sequence of 1\\'s and 0\\'s where a 1\\n                       represents bulb on and 0 represents bulb off\\n        :type target: str\\n        :return: number of bulb flips to reach target\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        The target sequence of bulbs is partitioned into segments.\\n        Each segment of bulbs is either all on (1\\'s) or all off (0\\'s).\\n        The initial state of the bulbs is all off. The sequence of\\n        flips starts at the first bulb of the rightmost segment and\\n        proceeds one segment at a time going left until the leftmost\\n        segment of 1\\'s in target is reached and flipped on.\\n        \\n        For example, if the target is \"001011101\", the sequence of\\n        flips would look like:\\n        \\n                target: 0 0 1 0 1 1 1 0 1\\n                bulbs:  0 0 0 0 0 0 0 0 0   Initial State\\n                        0 0 0 0 0 0 0 0 1   Flip 1\\n                        0 0 0 0 0 0 0 1 0   Flip 2\\n                        0 0 0 0 1 1 1 0 1   Flip 3\\n                        0 0 0 1 0 0 0 1 0   Flip 4\\n                        0 0 1 0 1 1 1 0 1   Flip 5\\n        \\n        Note that the bulbs represented are untouched.\\n        \\n        The number of segments is counted by detecting 0-to-1\\n        and 1-to-0 transitions.\\n        \"\"\"\\n        segments = target.count( \"01\" ) + target.count( \"10\" )\\n        if target[0] == \\'1\\':\\n            return segments + 1\\n        return segments\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757281,
                "title": "c-one-pass-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char c = \\'0\\';\\n        int ans = 0;\\n        for(char ch : target) {\\n            if(ch == c) continue;\\n            c = c == \\'1\\' ? \\'0\\' : \\'1\\';\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char c = \\'0\\';\\n        int ans = 0;\\n        for(char ch : target) {\\n            if(ch == c) continue;\\n            c = c == \\'1\\' ? \\'0\\' : \\'1\\';\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756538,
                "title": "java-simple-solution-greedy-100-fast",
                "content": "\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        /*\\n\\t\\tFor everry character we compare with the target whether we need to flip it or not .\\n\\t\\t[0,0,0,0,0] ---- > [1,0,1,1,0];\\n\\t\\tstartin with 0 we need to flip to get the first char ; -> [1,1,1,1,1]\\n\\t\\twe got the first one so we move to the next one .again the next one we want is 0 and we have 1.\\n\\t\\tso flip [1,0,0,0,0].  we got two postion similar . \\n\\t\\tnext for third again flip [1,0,1,1,1].now the the next char is similar to no need to fip . and for the last char one last flip .\\n\\t\\t\\n\\t\\t*/\\n\\t\\t\\n\\t\\t\\n        int minFlips = 0;\\n        char prevChar =\\'0\\';\\n        for(char c:target.toCharArray()){\\n  \\n            if(c != prevChar){\\n                minFlips++;\\n                prevChar = c;\\n            }\\n            \\n        }\\n        return minFlips;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int minFlips(String target) {\\n        /*\\n\\t\\tFor everry character we compare with the target whether we need to flip it or not .\\n\\t\\t[0,0,0,0,0] ---- > [1,0,1,1,0];\\n\\t\\tstartin with 0 we need to flip to get the first char ; -> [1,1,1,1,1]\\n\\t\\twe got the first one so we move to the next one .again the next one we want is 0 and we have 1.\\n\\t\\tso flip [1,0,0,0,0].  we got two postion similar . \\n\\t\\tnext for third again flip [1,0,1,1,1].now the the next char is similar to no need to fip . and for the last char one last flip .\\n\\t\\t\\n\\t\\t*/\\n\\t\\t\\n\\t\\t\\n        int minFlips = 0;\\n        char prevChar =\\'0\\';\\n        for(char c:target.toCharArray()){\\n  \\n            if(c != prevChar){\\n                minFlips++;\\n                prevChar = c;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 756393,
                "title": "python-easy-solution-for-beginners",
                "content": "Upvote if you like it\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        n = len(target)\\n        r = \\'0\\'*n\\n        if n == 1:\\n            return int(target==\"1\")\\n        if r==target:\\n            return 0\\n        \\n        x=0\\n        y=0\\n        s = target\\n        for i in range(n):\\n            # print(s[i],y)\\n\\n            if y==1 and s[i]==\\'1\\':\\n                continue\\n            elif y==0 and s[i]==\\'0\\':\\n                continue\\n            else:\\n\\n                x+=1\\n                if y==1: y=0\\n                else: y=1\\n        return x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        n = len(target)\\n        r = \\'0\\'*n\\n        if n == 1:\\n            return int(target==\"1\")\\n        if r==target:\\n            return 0\\n        \\n        x=0\\n        y=0\\n        s = target\\n        for i in range(n):\\n            # print(s[i],y)\\n\\n            if y==1 and s[i]==\\'1\\':\\n                continue\\n            elif y==0 and s[i]==\\'0\\':\\n                continue\\n            else:\\n\\n                x+=1\\n                if y==1: y=0\\n                else: y=1\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756309,
                "title": "c-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count=0;\\n        int j=0;\\n        while(target[j]==\\'0\\'){j++;}\\n        for(int i=target.length()-2;i>=j;i--){\\n            if(abs(target[i]-target[i+1])==1)count++;\\n        }\\n        if(j<target.size())return count+1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int count=0;\\n        int j=0;\\n        while(target[j]==\\'0\\'){j++;}\\n        for(int i=target.length()-2;i>=j;i--){\\n            if(abs(target[i]-target[i+1])==1)count++;\\n        }\\n        if(j<target.size())return count+1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756303,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char pre = \\'0\\';\\n        int cnt = 0;\\n        for (char c : target.toCharArray()) {\\n            char cur = c;\\n            if (c != pre) cnt++;\\n            pre = c;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        char pre = \\'0\\';\\n        int cnt = 0;\\n        for (char c : target.toCharArray()) {\\n            char cur = c;\\n            if (c != pre) cnt++;\\n            pre = c;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756185,
                "title": "c-one-pass-n",
                "content": "Idea is to traverse the target string from left and count the number of flips from 0 to 1 and vice versa.\\nAlso, ingore the leading zeroes\\n\\n```\\n\\t\\t\\tpublic int MinFlips(string target)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Corner Case\\n\\t\\t\\t\\tif (target == null) return 0;\\n\\t\\t\\t\\t// Trim leading zeroes \\n\\t\\t\\t\\ttarget = target.TrimStart(new Char[] { \\'0\\' });\\n\\t\\t\\t\\tint n = target.Length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If all zeroes\\n\\t\\t\\t\\tif (n == 0) return 0;\\n\\t\\t\\t\\tint res = 1;\\n\\t\\t\\t\\tfor (int i = 1; i < n; i++)\\n\\t\\t\\t\\t\\tif (target[i - 1] != target[i])\\n\\t\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\tpublic int MinFlips(string target)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Corner Case\\n\\t\\t\\t\\tif (target == null) return 0;\\n\\t\\t\\t\\t// Trim leading zeroes \\n\\t\\t\\t\\ttarget = target.TrimStart(new Char[] { \\'0\\' });\\n\\t\\t\\t\\tint n = target.Length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If all zeroes\\n\\t\\t\\t\\tif (n == 0) return 0;\\n\\t\\t\\t\\tint res = 1;\\n\\t\\t\\t\\tfor (int i = 1; i < n; i++)\\n\\t\\t\\t\\t\\tif (target[i - 1] != target[i])\\n\\t\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 756141,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.size();\\n        int flip = 0, cnt=0;\\n        for (int i=0;i<n;i++) {\\n            if (target[i]-\\'0\\' == flip) continue;\\n            else {\\n                cnt++;\\n                flip = 1-flip;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int n = target.size();\\n        int flip = 0, cnt=0;\\n        for (int i=0;i<n;i++) {\\n            if (target[i]-\\'0\\' == flip) continue;\\n            else {\\n                cnt++;\\n                flip = 1-flip;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755942,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int ans = 0;\\n        char prev = \\'0\\';\\n        for(char c : target.toCharArray()){\\n            ans += (prev == c) ? 0 : 1;\\n            prev = c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int ans = 0;\\n        char prev = \\'0\\';\\n        for(char c : target.toCharArray()){\\n            ans += (prev == c) ? 0 : 1;\\n            prev = c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755931,
                "title": "greedy-python",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        res = 0\\n        \\n        cur_state = \\'0\\'\\n        \\n        for ch in target:\\n            \\n            if ch != cur_state:\\n                res += 1\\n                cur_state = \\'0\\' if cur_state == \\'1\\' else \\'1\\'\\n            \\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        res = 0\\n        \\n        cur_state = \\'0\\'\\n        \\n        for ch in target:\\n            \\n            if ch != cur_state:\\n                res += 1\\n                cur_state = \\'0\\' if cur_state == \\'1\\' else \\'1\\'\\n            \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755926,
                "title": "concise-python-solution-with-explanation",
                "content": "Iterate from left to right, if current bit is different from previous, then do one flip.\\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        target = \\'0\\' + target\\n        res, n = 0, len(target)\\n        for i in range(1, n):\\n            res += target[i] != target[i - 1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        target = \\'0\\' + target\\n        res, n = 0, len(target)\\n        for i in range(1, n):\\n            res += target[i] != target[i - 1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755881,
                "title": "one-pass-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(String t) {\\n        int res=0;boolean first_one=false;\\n        for(int i=0;i<t.length();i++){\\n            if(t.charAt(i)==\\'0\\' && !first_one)continue;\\n            if(first_one && t.charAt(i)!=t.charAt(i-1))res++;\\n            if(t.charAt(i)==\\'1\\')first_one=true;\\n        }\\n        if(!first_one)return res;\\n        return res+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String t) {\\n        int res=0;boolean first_one=false;\\n        for(int i=0;i<t.length();i++){\\n            if(t.charAt(i)==\\'0\\' && !first_one)continue;\\n            if(first_one && t.charAt(i)!=t.charAt(i-1))res++;\\n            if(t.charAt(i)==\\'1\\')first_one=true;\\n        }\\n        if(!first_one)return res;\\n        return res+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755871,
                "title": "python-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\n        count = 0\\n        flip = \\'0\\'\\n        for bulb in target:\\n            if bulb != flip:\\n                count += 1\\n                flip = \\'1\\' if flip == \\'0\\' else \\'0\\'\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        \\n        count = 0\\n        flip = \\'0\\'\\n        for bulb in target:\\n            if bulb != flip:\\n                count += 1\\n                flip = \\'1\\' if flip == \\'0\\' else \\'0\\'\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755846,
                "title": "c-o-n-greedy",
                "content": "start checking from left if it element is same with curr( initially=0) then simply increase i and then check if it is not same then you have to change rest values so change curr=target[i] and ans++\\nsimply traverse string in this way.\\n\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        int ans=0;\\n        char curr=\\'0\\';\\n        for(int i=0;i<target.size();i++){\\n            if(curr!=target[i]){\\n                curr=target[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        int ans=0;\\n        char curr=\\'0\\';\\n        for(int i=0;i<target.size();i++){\\n            if(curr!=target[i]){\\n                curr=target[i];\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 755822,
                "title": "o-n-c-greedy",
                "content": "Count the flips until now. If you encounter \\'1\\' and flips until now are even, increase the flips by 1.  If you encounter \\'0\\' and flips until now are odd, increase the flips by 1. \\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string t) {\\n        int f = 0 ;\\n        for(char c : t) {\\n            if(c==\\'1\\' && f%2==0 || c==\\'0\\'&& f%2==1 ) f++; \\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string t) {\\n        int f = 0 ;\\n        for(char c : t) {\\n            if(c==\\'1\\' && f%2==0 || c==\\'0\\'&& f%2==1 ) f++; \\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755817,
                "title": "o-n-greedy-consecutive-best-method-python",
                "content": "```class Solution:\\n    def minFlips(self, target: str) -> int:\\n        ope=0\\n        n=len(target)\\n        c=\"0\"\\n        for i in range(n):\\n            if target[i]!=c:\\n                ope+=1\\n                c=target[i]\\n        return ope\\n            \\n         ```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def minFlips(self, target: str) -> int:\\n        ope=0\\n        n=len(target)\\n        c=\"0\"\\n        for i in range(n):\\n            if target[i]!=c:\\n                ope+=1\\n                c=target[i]\\n        return ope\\n            \\n         ```",
                "codeTag": "Java"
            },
            {
                "id": 755808,
                "title": "c-easy-with-diagram",
                "content": "If we observe carefully we only need to check the changes in the characters of the string and then return the total change. Since the initial string is `\"000..\"`, so we also need to take into account the `change` if the first character is 1.\\n![image](https://assets.leetcode.com/users/images/2434d09c-7795-467d-a2fe-54464c092234_1595736139.952737.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int prev = 0, curr = 0, count = 0;\\n        for(char x: target) {\\n            int n = x - \\'0\\';\\n            curr = n;\\n            count += curr ^ prev;\\n            prev = curr;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int prev = 0, curr = 0, count = 0;\\n        for(char x: target) {\\n            int n = x - \\'0\\';\\n            curr = n;\\n            count += curr ^ prev;\\n            prev = curr;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755792,
                "title": "python-o-n-with-detailed-explanation-examples",
                "content": "```\\nInstead of 00000 -> 10111, we do 10111 -> 00000\\n- If there are all 1\\'s in the trailing part, (...111),\\n  To convert that to ...000 takes only 1 flip from end. (...111 -> ...000)\\n\\n- If there are 1\\'s & then all trailing 0\\'s, (...1100),\\n  To convert that to ...0000 takes 2 flips.\\n  one for it\\'s full length, other from first 0 th to end. (...1100 -> ...0011 -> ...000)\\n\\nBasically, if the last set (from end) of numbers are 1, (10111),\\nconvert them by flipping once. (10111 -> 10000)\\n\\nThen it\\'s just the number of contiguous group of 1\\'s * 2.\\n\\nExample:\\n\\n0110111011\\nconvert last (end) set of 1\\'s to 0 by flipping once.\\n0110111000\\nthere are 2 groups of 1 (11 & 111), \\nit takes 2 flips for each to get converted to 0.\\nhence, 2*2 + 1 = 5\\n\\n0110111011 -> 0110111000 -> 0110000111 -> 0110000000 -> 0001111111 -> 0000000000\\n\\nto find the contiguous group of 1\\'s, \\nwe just need to find the number of \"10\"s occuring in string.\\nwe already know the string ends with 0 due to the previous operation.\\n\\nTime: O(n)\\nSpace: O(1)\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        res = 0\\n        endOnes = 0\\n        oneGroup = 0\\n        size = len(target)\\n        \\n        for i in range(size-1,-1,-1):\\n            if target[i] == \"1\":\\n                endOnes += 1\\n            else: # break when first 0 found\\n                break\\n                \\n        target = target[:size-endOnes] + \"0\"*endOnes\\n        if endOnes != 0: # if one at end exist,\\n            res += 1\\n        \\n        for i in range(1,len(target)):\\n            char = target[i-1]+target[i]\\n            if char == \"10\":\\n                oneGroup += 1\\n        \\n        res += (oneGroup*2)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nInstead of 00000 -> 10111, we do 10111 -> 00000\\n- If there are all 1\\'s in the trailing part, (...111),\\n  To convert that to ...000 takes only 1 flip from end. (...111 -> ...000)\\n\\n- If there are 1\\'s & then all trailing 0\\'s, (...1100),\\n  To convert that to ...0000 takes 2 flips.\\n  one for it\\'s full length, other from first 0 th to end. (...1100 -> ...0011 -> ...000)\\n\\nBasically, if the last set (from end) of numbers are 1, (10111),\\nconvert them by flipping once. (10111 -> 10000)\\n\\nThen it\\'s just the number of contiguous group of 1\\'s * 2.\\n\\nExample:\\n\\n0110111011\\nconvert last (end) set of 1\\'s to 0 by flipping once.\\n0110111000\\nthere are 2 groups of 1 (11 & 111), \\nit takes 2 flips for each to get converted to 0.\\nhence, 2*2 + 1 = 5\\n\\n0110111011 -> 0110111000 -> 0110000111 -> 0110000000 -> 0001111111 -> 0000000000\\n\\nto find the contiguous group of 1\\'s, \\nwe just need to find the number of \"10\"s occuring in string.\\nwe already know the string ends with 0 due to the previous operation.\\n\\nTime: O(n)\\nSpace: O(1)\\n```\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        res = 0\\n        endOnes = 0\\n        oneGroup = 0\\n        size = len(target)\\n        \\n        for i in range(size-1,-1,-1):\\n            if target[i] == \"1\":\\n                endOnes += 1\\n            else: # break when first 0 found\\n                break\\n                \\n        target = target[:size-endOnes] + \"0\"*endOnes\\n        if endOnes != 0: # if one at end exist,\\n            res += 1\\n        \\n        for i in range(1,len(target)):\\n            char = target[i-1]+target[i]\\n            if char == \"10\":\\n                oneGroup += 1\\n        \\n        res += (oneGroup*2)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755787,
                "title": "java-o-n-solution",
                "content": "\\n    public int minFlips(String target) {\\n        if(target.length() ==0 ||  target.indexOf(\\'1\\') == -1) return 0;\\n    \\n        String[] split = target.split(\"0\");\\n        int blockLength = 0;\\n        for(String s : split){\\n            if(s.indexOf(\\'1\\') == -1) continue;\\n            else blockLength++;\\n        }\\n        int offset = (target.charAt(target.length()-1) == \\'0\\')?2:1;\\n        return 2*(blockLength-1)+offset;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int minFlips(String target) {\\n        if(target.length() ==0 ||  target.indexOf(\\'1\\') == -1) return 0;\\n    \\n        String[] split = target.split(\"0\");\\n        int blockLength = 0;\\n        for(String s : split){\\n            if(s.indexOf(\\'1\\') == -1) continue;\\n            else blockLength++;\\n        }\\n        int offset = (target.charAt(target.length()-1) == \\'0\\')?2:1;\\n        return 2*(blockLength-1)+offset;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 755780,
                "title": "javascript-python3-c-count-bit-flips",
                "content": "**Synopsis:**\\n\\nSimply count how many times the value of consecutive \"bits\" is flipped during a linear scan from left-to-right.\\n\\n---\\n\\n**Contest 199 Screenshare:** https://www.youtube.com/watch?v=ufTyfhb0wQY&feature=youtu.be\\n\\n---\\n\\n*Javascript*\\n```\\nlet minFlips = (s, cur = \\'0\\', cnt = 0) => {\\n    for (let c of s)\\n        if (cur != c)\\n            cur = c, ++cnt;\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minFlips(self, s: str, cur = \\'0\\', cnt = 0) -> int:\\n        for c in s:\\n            if cur != c:\\n                cur = c\\n                cnt += 1\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minFlips(string s, char cur = \\'0\\', int cnt = 0) {\\n        for (auto c: s)\\n            if (cur != c)\\n                cur = c, ++cnt;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet minFlips = (s, cur = \\'0\\', cnt = 0) => {\\n    for (let c of s)\\n        if (cur != c)\\n            cur = c, ++cnt;\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def minFlips(self, s: str, cur = \\'0\\', cnt = 0) -> int:\\n        for c in s:\\n            if cur != c:\\n                cur = c\\n                cnt += 1\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minFlips(string s, char cur = \\'0\\', int cnt = 0) {\\n        for (auto c: s)\\n            if (cur != c)\\n                cur = c, ++cnt;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755773,
                "title": "c-accepted-solution-count-64ms-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ones = 0, zeros = 0;\\n        for(char c : target){\\n            if(c == \\'1\\') ones++;\\n            else zeros++;\\n        } \\n        int count = 0;\\n        bool isOne = true;\\n        for(int i = 0; i < target.length(); i++){\\n            if(isOne && target[i] == \\'1\\'){\\n                ones--;\\n                isOne = false;\\n                count++;\\n            }\\n            if(!isOne && target[i] == \\'0\\'){\\n                zeros--;\\n                isOne = true;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        int ones = 0, zeros = 0;\\n        for(char c : target){\\n            if(c == \\'1\\') ones++;\\n            else zeros++;\\n        } \\n        int count = 0;\\n        bool isOne = true;\\n        for(int i = 0; i < target.length(); i++){\\n            if(isOne && target[i] == \\'1\\'){\\n                ones--;\\n                isOne = false;\\n                count++;\\n            }\\n            if(!isOne && target[i] == \\'0\\'){\\n                zeros--;\\n                isOne = true;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755772,
                "title": "easy-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        int n=target.size();\\n        int cnt=0;\\n        cnt+=(target[0]-\\'0\\');\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n         if(target[i]!=target[i-1])\\n             cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int minFlips(string target) {\\n        \\n        int n=target.size();\\n        int cnt=0;\\n        cnt+=(target[0]-\\'0\\');\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n         if(target[i]!=target[i-1])\\n             cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 755760,
                "title": "count-each-change",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char prev = \\'0\\';\\n        int ans = 0;\\n        for (auto c : target) {\\n            if (c != prev) {\\n                ++ans;\\n            }\\n            prev = c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        char prev = \\'0\\';\\n        int ans = 0;\\n        for (auto c : target) {\\n            if (c != prev) {\\n                ++ans;\\n            }\\n            prev = c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094691,
                "title": "simple-java-solution-this-should-ve-been-an-easy-problem",
                "content": "# Intuition\\nSaw a pattern based on number of changes from 1 to 0\\n\\n# Approach\\nregardless how many 1\\'s and 0\\'s there are, the only time a flip is needed if there is a change from 1 to 0 when reading the string. For example 10000000 needs two flips, but 10000000000000010 needs 3. The case changes slightly if string starts with 0 or 1, as shown in the code.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        for(int i = 1; i < target.length();i++){\\n            if(target.charAt(i)!=target.charAt(i-1))\\n                flips++;\\n        }\\n        if(flips == 0)\\n            return flips;\\n        \\n        if(target.charAt(0)==\\'1\\')\\n            return flips+1;\\n        else\\n            return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        for(int i = 1; i < target.length();i++){\\n            if(target.charAt(i)!=target.charAt(i-1))\\n                flips++;\\n        }\\n        if(flips == 0)\\n            return flips;\\n        \\n        if(target.charAt(0)==\\'1\\')\\n            return flips+1;\\n        else\\n            return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090779,
                "title": "python-code-beats-79",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        numofflips=0\\n        lastnum=\"0\"\\n        if target[0]==1:\\n            numofflips=1\\n            lastnum=\"1\"\\n        for i in range(0,len(target)):\\n            r=target[i]\\n            if lastnum!=target[i]:\\n                numofflips=numofflips+1\\n            lastnum=target[i]\\n        return numofflips\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        numofflips=0\\n        lastnum=\"0\"\\n        if target[0]==1:\\n            numofflips=1\\n            lastnum=\"1\"\\n        for i in range(0,len(target)):\\n            r=target[i]\\n            if lastnum!=target[i]:\\n                numofflips=numofflips+1\\n            lastnum=target[i]\\n        return numofflips\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075855,
                "title": "identify-a-pattern-for-the-flip",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe tough part of this question is to find a correct way to flip it. We may get misleading by example. \\n\\nE.g.\\n00000->0**1111**->1**0000**->10**111**\\ni=1      \\ni=0         \\ni=2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso we can figure out we need twice operations to flip if there a pattern like **10**. it\\'s a breakpoint. And if the 0 is the last zero, we just need to filp the rest once.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        \\n    int lastZero=target.lastIndexOf(\"0\");\\n   \\n    char[]charArray=target.toCharArray();\\n    int res = 0;\\n    for(int i=1;i<charArray.length;i++){\\n        if(i>lastZero){\\n          res++;\\n          break;\\n        }\\n        if(charArray[i]==\\'0\\'&&charArray[i]!=charArray[i-1]){\\n          res+=2;\\n        }\\n    }\\n    return res;\\n    }\\n}\\n```\\n\\n\\n# Code from CN website\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        char prev = \\'0\\';\\n        int n = target.length();\\n        for (int i = 0; i < n; i++) {\\n            char curr = target.charAt(i);\\n            if (curr != prev) {\\n                flips++;\\n                prev = curr;\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n\\n\\u4F5C\\u8005\\uFF1A\\u529B\\u6263\\u5B98\\u65B9\\u9898\\u89E3\\n\\u94FE\\u63A5\\uFF1Ahttps://leetcode.cn/problems/minimum-suffix-flips/solutions/357878/deng-pao-kai-guan-iv-by-leetcode-solution/\\n\\u6765\\u6E90\\uFF1A\\u529B\\u6263\\uFF08LeetCode\\uFF09\\n\\u8457\\u4F5C\\u6743\\u5F52\\u4F5C\\u8005\\u6240\\u6709\\u3002\\u5546\\u4E1A\\u8F6C\\u8F7D\\u8BF7\\u8054\\u7CFB\\u4F5C\\u8005\\u83B7\\u5F97\\u6388\\u6743\\uFF0C\\u975E\\u5546\\u4E1A\\u8F6C\\u8F7D\\u8BF7\\u6CE8\\u660E\\u51FA\\u5904\\u3002\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n        \\n    int lastZero=target.lastIndexOf(\"0\");\\n   \\n    char[]charArray=target.toCharArray();\\n    int res = 0;\\n    for(int i=1;i<charArray.length;i++){\\n        if(i>lastZero){\\n          res++;\\n          break;\\n        }\\n        if(charArray[i]==\\'0\\'&&charArray[i]!=charArray[i-1]){\\n          res+=2;\\n        }\\n    }\\n    return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        char prev = \\'0\\';\\n        int n = target.length();\\n        for (int i = 0; i < n; i++) {\\n            char curr = target.charAt(i);\\n            if (curr != prev) {\\n                flips++;\\n                prev = curr;\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n\\n\\u4F5C\\u8005\\uFF1A\\u529B\\u6263\\u5B98\\u65B9\\u9898\\u89E3\\n\\u94FE\\u63A5\\uFF1Ahttps://leetcode.cn/problems/minimum-suffix-flips/solutions/357878/deng-pao-kai-guan-iv-by-leetcode-solution/\\n\\u6765\\u6E90\\uFF1A\\u529B\\u6263\\uFF08LeetCode\\uFF09\\n\\u8457\\u4F5C\\u6743\\u5F52\\u4F5C\\u8005\\u6240\\u6709\\u3002\\u5546\\u4E1A\\u8F6C\\u8F7D\\u8BF7\\u8054\\u7CFB\\u4F5C\\u8005\\u83B7\\u5F97\\u6388\\u6743\\uFF0C\\u975E\\u5546\\u4E1A\\u8F6C\\u8F7D\\u8BF7\\u6CE8\\u660E\\u51FA\\u5904\\u3002\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073878,
                "title": "easiest-greedy-approach-with-full-explanation-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince we are asked to find miniumum, it means we can take greedy approach  as Greedy can be used to find min/max.\\n\\nhow greedy approach works generally? we don\\'t care about the next step, We just find the optimum step evertime.\\n\\nIn this case it would be if a bit is different that means we have to flip, if the bit is same we ignore. \\n\\n\\nWe maintain a prev/lastflipped char which would tell us what was the bit previously. \\n\\nA Little visulisation of the solution \\nI/p  :10111\\n\\nso we have to convert 00000 (temp) to 10111\\n\\nWe set the lastflipped to 0 initially as all bits are 0 \\n\\n\\ncompare first char of i/p  i.e 1 with lastflipped. Not same, so to make it same we flip the bits, so now our temp = 11111 , lastflipped = 1 and count = 1 \\n\\nnow compare the next character i.e 0 with lastflipped not same again \\nwe flip, so temp = 10000 , lastflipped = 0 , count = 2 \\n\\nnow compare next character i.e 1 with lastflipped . not same \\nwe flip, so temp = 10111 , lastflipped = 1 count = 3 \\n\\nnow we compare next i.e 1 with lastflipped . same skip . similarly till the end. \\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n\\n        int count =0 ;\\n        char lastflipped  =\\'0\\';\\n        for(int i = 0 ;i <target.length(); i++)\\n        {\\n            char c = target.charAt(i);\\n            if(c != lastflipped)\\n            {\\n                // we need to flip and increment cout \\n                count++; \\n                lastflipped = c ; \\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(String target) {\\n\\n        int count =0 ;\\n        char lastflipped  =\\'0\\';\\n        for(int i = 0 ;i <target.length(); i++)\\n        {\\n            char c = target.charAt(i);\\n            if(c != lastflipped)\\n            {\\n                // we need to flip and increment cout \\n                count++; \\n                lastflipped = c ; \\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4069052,
                "title": "python3-o-n-linear-scan-backwards",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        idx = len(target)-1\\n        flip_count = 0\\n        for i in range(len(target)-1,-1,-1):\\n            if target[i] == \\'1\\':\\n                if i == len(target) - 1 or target[i+1] == \\'0\\':\\n                    flip_count += 1\\n            else:\\n                if i != 0 and target[i-1] == \\'1\\':\\n                    flip_count += 1\\n        return flip_count\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        idx = len(target)-1\\n        flip_count = 0\\n        for i in range(len(target)-1,-1,-1):\\n            if target[i] == \\'1\\':\\n                if i == len(target) - 1 or target[i+1] == \\'0\\':\\n                    flip_count += 1\\n            else:\\n                if i != 0 and target[i-1] == \\'1\\':\\n                    flip_count += 1\\n        return flip_count\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043241,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\nthe number of flips is the number of changes from 0 to 1 or 1 to 0 plus the left most 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minFlips(char * target){\\n    char* s = target;\\n    int changes = 0;\\n\\n    //dont care about left zeroz\\n    while (*s != \\'\\\\0\\' && *s == \\'0\\'){\\n        s++;\\n    }\\n\\n    //count changes\\n    while (*s != \\'\\\\0\\'){\\n        //add one change for the left most one\\n        if (changes == 0){\\n            changes++;\\n        }\\n        if (*(s+1) != *s && *(s+1) != \\'\\\\0\\'){\\n            changes++;\\n        }\\n        s++;\\n    }\\n    return changes;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minFlips(char * target){\\n    char* s = target;\\n    int changes = 0;\\n\\n    //dont care about left zeroz\\n    while (*s != \\'\\\\0\\' && *s == \\'0\\'){\\n        s++;\\n    }\\n\\n    //count changes\\n    while (*s != \\'\\\\0\\'){\\n        //add one change for the left most one\\n        if (changes == 0){\\n            changes++;\\n        }\\n        if (*(s+1) != *s && *(s+1) != \\'\\\\0\\'){\\n            changes++;\\n        }\\n        s++;\\n    }\\n    return changes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039848,
                "title": "python-just-go-from-left-to-right-o-n",
                "content": "```\\n\"\"\"\\nSimple idea here is go from left to right, trying to convert target to zero array.\\n\\nIf 1 on i index found (or 0 when flipped) then we do +1 operation and flip our target.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        total = 0\\n        flipped = False\\n \\n        for i in range(len(target)):\\n            if not flipped and target[i] == \\'0\\' or flipped and target[i] == \\'1\\':\\n                continue\\n                \\n            flipped = not flipped\\n            total += 1\\n\\n        return total\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n\"\"\"\\nSimple idea here is go from left to right, trying to convert target to zero array.\\n\\nIf 1 on i index found (or 0 when flipped) then we do +1 operation and flip our target.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        total = 0\\n        flipped = False\\n \\n        for i in range(len(target)):\\n            if not flipped and target[i] == \\'0\\' or flipped and target[i] == \\'1\\':\\n                continue\\n                \\n            flipped = not flipped\\n            total += 1\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010294,
                "title": "simple-pythonic-solution",
                "content": "# Intuition\\nSimple pythonic solution\\n\\n# Approach\\nOne pass solution\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, input: str) -> int:\\n        count = set()\\n        n = len(input)\\n        for i in range(n):\\n            if input[i] == \\'1\\':\\n                count.add(i)\\n        \\n        nums = [\\'0\\'] * n\\n        flips = 0\\n        checkOne = False\\n        \\n        for i in range(n):\\n            if i in count and nums[i] != \\'1\\' and not checkOne:\\n                nums[i] = \\'1\\'\\n                flips += 1\\n                checkOne = True\\n            elif checkOne and i not in count:               \\n                nums[i] = \\'0\\'\\n                flips += 1\\n                checkOne = False\\n                        \\n        return flips\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, input: str) -> int:\\n        count = set()\\n        n = len(input)\\n        for i in range(n):\\n            if input[i] == \\'1\\':\\n                count.add(i)\\n        \\n        nums = [\\'0\\'] * n\\n        flips = 0\\n        checkOne = False\\n        \\n        for i in range(n):\\n            if i in count and nums[i] != \\'1\\' and not checkOne:\\n                nums[i] = \\'1\\'\\n                flips += 1\\n                checkOne = True\\n            elif checkOne and i not in count:               \\n                nums[i] = \\'0\\'\\n                flips += 1\\n                checkOne = False\\n                        \\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009775,
                "title": "pseudo-inverting-bits-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot from 2023-09-06 22-15-40.png](https://assets.leetcode.com/users/images/9554f661-35f6-4c56-9f09-d1dd8bd0d8be_1694002587.9030352.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        unsigned n = target.length();\\n        string str(n, \\'0\\');\\n        \\n        int flips = 0;\\n        bool flip = 0;\\n        for (unsigned i = 0; i < n; ++i) {\\n            if (flip != target[i] - \\'0\\') {\\n                flips++;\\n                flip = !flip;\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(string target) {\\n        unsigned n = target.length();\\n        string str(n, \\'0\\');\\n        \\n        int flips = 0;\\n        bool flip = 0;\\n        for (unsigned i = 0; i < n; ++i) {\\n            if (flip != target[i] - \\'0\\') {\\n                flips++;\\n                flip = !flip;\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009744,
                "title": "python-1-line",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return reduce(lambda res, c: res + (res & 1 != int(c)), target.lstrip(\\'0\\'), 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return reduce(lambda res, c: res + (res & 1 != int(c)), target.lstrip(\\'0\\'), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991857,
                "title": "easy-solution-with-foo-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minFlips(target: string): number {\\n    let res: number = 0;\\n    let flag: boolean = false;\\n    for(let i = 0; i < target.length; i++){\\n        if((target[i] === \"1\" && flag === false) || (target[i] === \"0\" && flag === true)){\\n            res++;\\n            flag = !flag\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minFlips(target: string): number {\\n    let res: number = 0;\\n    let flag: boolean = false;\\n    for(let i = 0; i < target.length; i++){\\n        if((target[i] === \"1\" && flag === false) || (target[i] === \"0\" && flag === true)){\\n            res++;\\n            flag = !flag\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971770,
                "title": "c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate from left to right. Flip if not matching.\\n- Record the remaining bits are at \\'1\\' or \\'0\\'\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinFlips(string target) {\\n        bool zero = true;\\n        int flips = 0;\\n\\n        foreach(char c in target)\\n        {\\n            if ((zero && (c == \\'1\\')) ||\\n                (!zero && (c == \\'0\\')))\\n            {\\n                flips++;\\n                zero = !zero;\\n            }\\n        }\\n\\n        return flips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(string target) {\\n        bool zero = true;\\n        int flips = 0;\\n\\n        foreach(char c in target)\\n        {\\n            if ((zero && (c == \\'1\\')) ||\\n                (!zero && (c == \\'0\\')))\\n            {\\n                flips++;\\n                zero = !zero;\\n            }\\n        }\\n\\n        return flips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1803712,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "The Acceptance Rate looks skewed to me at the first read \\uD83D\\uDE05"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "How the hell this is easy ?? Am i  am missing something :)"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Notice that you know the initial state of the string. If you go from left to right then you can predict the state of s[i] by using flips count as of now. \\nIf flips count is even -> s[i] is 0 \\nIf flips count is odd -> s[i] is 1"
                    }
                ]
            },
            {
                "id": 1834396,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "The Acceptance Rate looks skewed to me at the first read \\uD83D\\uDE05"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "How the hell this is easy ?? Am i  am missing something :)"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Notice that you know the initial state of the string. If you go from left to right then you can predict the state of s[i] by using flips count as of now. \\nIf flips count is even -> s[i] is 0 \\nIf flips count is odd -> s[i] is 1"
                    }
                ]
            },
            {
                "id": 1998378,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "The Acceptance Rate looks skewed to me at the first read \\uD83D\\uDE05"
                    },
                    {
                        "username": "_Ritik_Singh_",
                        "content": "How the hell this is easy ?? Am i  am missing something :)"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Notice that you know the initial state of the string. If you go from left to right then you can predict the state of s[i] by using flips count as of now. \\nIf flips count is even -> s[i] is 0 \\nIf flips count is odd -> s[i] is 1"
                    }
                ]
            }
        ]
    }
]