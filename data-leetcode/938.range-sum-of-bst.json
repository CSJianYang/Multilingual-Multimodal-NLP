[
    {
        "title": "Range Sum of BST",
        "question_content": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\n&nbsp;\nExample 1:\n\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15\nOutput: 32\nExplanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\nExample 2:\n\nInput: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\nOutput: 23\nExplanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 2 * 104].\n\t1 <= Node.val <= 105\n\t1 <= low <= high <= 105\n\tAll Node.val are unique.",
        "solutions": [
            {
                "id": 192019,
                "title": "java-python-3-3-similar-recursive-and-1-iterative-methods-w-comment-analysis",
                "content": "Three similar recursive and one iterative methods, choose one you like.\\n\\n**Method 1:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        if (root.val < L) return rangeSumBST(root.right, L, R); // left branch excluded.\\n        if (root.val > R) return rangeSumBST(root.left, L, R); // right branch excluded.\\n        return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); // count in both children.\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        elif root.val > R:\\n            return self.rangeSumBST(root.left, L, R)\\n        return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n```\\nThe following are two more similar recursive codes.\\n\\n**Method 2:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        return (L <= root.val && root.val <= R ? root.val : 0) + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R);\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        return self.rangeSumBST(root.left, L, R) + \\\\\\n                self.rangeSumBST(root.right, L, R) + \\\\\\n                (root.val if L <= root.val <= R else 0)\\n```\\n**Method 3:**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) { return 0; }\\n        int sum = 0;\\n        if (root.val > L) { sum += rangeSumBST(root.left, L, R); } // left child is a possible candidate.\\n        if (root.val < R) { sum += rangeSumBST(root.right, L, R); } // right child is a possible candidate.\\n        if (root.val >= L && root.val <= R) { sum += root.val; } // count root in.\\n        return sum;\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        sum = 0\\n        if root.val > L:\\n            sum += self.rangeSumBST(root.left, L, R)\\n        if root.val < R:\\n            sum += self.rangeSumBST(root.right, L, R)\\n        if L <= root.val <= R:\\n            sum += root.val     \\n        return sum\\n```\\n\\n**Method 4: Iterative version**\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        stk.push(root);\\n        int sum = 0;\\n        while (!stk.isEmpty()) {\\n            TreeNode n = stk.pop();\\n            if (n == null) { continue; }\\n            if (n.val > L) { stk.push(n.left); } // left child is a possible candidate.\\n            if (n.val < R) { stk.push(n.right); } // right child is a possible candidate.\\n            if (L <= n.val && n.val <= R) { sum += n.val; }\\n        }\\n        return sum;\\n    }\\n```\\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        stk, sum = [root], 0\\n        while stk:\\n            node = stk.pop()\\n            if node:\\n                if node.val > L:\\n                    stk.append(node.left)    \\n                if node.val < R:\\n                    stk.append(node.right)\\n                if L <= node.val <= R:\\n                    sum += node.val    \\n        return sum\\n```\\n**Analysis:**\\n\\nAll 4 methods will DFS traverse all nodes in worst case, and if we count in the recursion trace space cost, the complexities are as follows:\\n\\n**Time: O(n), space: O(h)**, where `n` is the number of total nodes, `h` is the height of the tree..",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        if (root.val < L) return rangeSumBST(root.right, L, R); // left branch excluded.\\n        if (root.val > R) return rangeSumBST(root.left, L, R); // right branch excluded.\\n        return root.val + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R); // count in both children.\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        elif root.val > R:\\n            return self.rangeSumBST(root.left, L, R)\\n        return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0; // base case.\\n        return (L <= root.val && root.val <= R ? root.val : 0) + rangeSumBST(root.right, L, R) + rangeSumBST(root.left, L, R);\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        return self.rangeSumBST(root.left, L, R) + \\\\\\n                self.rangeSumBST(root.right, L, R) + \\\\\\n                (root.val if L <= root.val <= R else 0)\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) { return 0; }\\n        int sum = 0;\\n        if (root.val > L) { sum += rangeSumBST(root.left, L, R); } // left child is a possible candidate.\\n        if (root.val < R) { sum += rangeSumBST(root.right, L, R); } // right child is a possible candidate.\\n        if (root.val >= L && root.val <= R) { sum += root.val; } // count root in.\\n        return sum;\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        sum = 0\\n        if root.val > L:\\n            sum += self.rangeSumBST(root.left, L, R)\\n        if root.val < R:\\n            sum += self.rangeSumBST(root.right, L, R)\\n        if L <= root.val <= R:\\n            sum += root.val     \\n        return sum\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        stk.push(root);\\n        int sum = 0;\\n        while (!stk.isEmpty()) {\\n            TreeNode n = stk.pop();\\n            if (n == null) { continue; }\\n            if (n.val > L) { stk.push(n.left); } // left child is a possible candidate.\\n            if (n.val < R) { stk.push(n.right); } // right child is a possible candidate.\\n            if (L <= n.val && n.val <= R) { sum += n.val; }\\n        }\\n        return sum;\\n    }\\n```\n```\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        stk, sum = [root], 0\\n        while stk:\\n            node = stk.pop()\\n            if node:\\n                if node.val > L:\\n                    stk.append(node.left)    \\n                if node.val < R:\\n                    stk.append(node.right)\\n                if L <= node.val <= R:\\n                    sum += node.val    \\n        return sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205181,
                "title": "java-4-lines-beats-100",
                "content": "```\\n public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        if(root.val > R) return rangeSumBST(root.left, L, R);\\n        if(root.val < L) return rangeSumBST(root.right, L, R);\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        if(root.val > R) return rangeSumBST(root.left, L, R);\\n        if(root.val < L) return rangeSumBST(root.right, L, R);\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 596106,
                "title": "c-easy-explaination-step-by-step-100",
                "content": "```\\n/*I ll be giving as much details as possible as to what s going on in the recursion stack.\\nLets take the binary tree to be [10,5,15,3,7,null,18]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t/\\\\\\n\\t\\t\\t\\t\\t  5  15\\n\\t\\t\\t\\t\\t /\\\\   \\\\\\n\\t\\t\\t       3  7   18\\ndo your inorder traversal as routine\\n                                                                      sum = 0\\n                    |   3      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    we reach the NULL condition of the traversal\\n            as 3 has no left or right nodes a sum of 0 is passed to 3       3    <-\\n                                                                           /  \\\\    \\\\\\n                                                                         NULL  NULL 0\\n           3 is popped out of the stack ans analyzed\\n                    |          |  3\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n            but as 3 < 7 (L)\\n            sum value is not changed                                   sum=0\\n            then 7 is pushed into the stack\\n                    |   7      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n            as 7 has no leaf nodes inorder(root->left) = NULL\\n                                   sum+=7(as 7 is in the range)       sum=7\\n                                   inorder(root->right) = NULL\\n                                   sum=7 is passed to the call stack\\n                    |          |  7\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                Now as both the left and right nodes are visited 5 is analyzed.\\n                inorder(root->left) = 5\\n                But since 5 is not in the range sum value doesnt change.\\n                Now 5 is popped out of the stack.\\n                    |          |   5   \\n                    |          |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    inorder(rot->right)  continues excecution.\\n                    |   18     |  \\n                    |   15     |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n                    18 has no childeren thus sum=7 is passed on to the root.\\n                    18 is not in the range so sum doesnt change.\\n                    this process continues and 15 gets added to the sum giving sum=22\\n                    then 10 gets added  sum=32\\n                    */\\n     int sum=0;\\n    int inorder(TreeNode* root,int L,int R)\\n    {\\n        if(root){\\n        inorder(root->left,L,R);\\n        if(root->val>=L && root->val<=R)\\n            sum+=root->val;\\n        inorder(root->right,L,R);\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root)return 0;\\n        return inorder(root,L,R);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*I ll be giving as much details as possible as to what s going on in the recursion stack.\\nLets take the binary tree to be [10,5,15,3,7,null,18]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t/\\\\\\n\\t\\t\\t\\t\\t  5  15\\n\\t\\t\\t\\t\\t /\\\\   \\\\\\n\\t\\t\\t       3  7   18\\ndo your inorder traversal as routine\\n                                                                      sum = 0\\n                    |   3      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    we reach the NULL condition of the traversal\\n            as 3 has no left or right nodes a sum of 0 is passed to 3       3    <-\\n                                                                           /  \\\\    \\\\\\n                                                                         NULL  NULL 0\\n           3 is popped out of the stack ans analyzed\\n                    |          |  3\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n            but as 3 < 7 (L)\\n            sum value is not changed                                   sum=0\\n            then 7 is pushed into the stack\\n                    |   7      |  \\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n            as 7 has no leaf nodes inorder(root->left) = NULL\\n                                   sum+=7(as 7 is in the range)       sum=7\\n                                   inorder(root->right) = NULL\\n                                   sum=7 is passed to the call stack\\n                    |          |  7\\n                    |   5      |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                Now as both the left and right nodes are visited 5 is analyzed.\\n                inorder(root->left) = 5\\n                But since 5 is not in the range sum value doesnt change.\\n                Now 5 is popped out of the stack.\\n                    |          |   5   \\n                    |          |  \\n                    |   10     |  <-------inorder(root->left)\\n                    |__________|\\n                    inorder(rot->right)  continues excecution.\\n                    |   18     |  \\n                    |   15     |  \\n                    |   10     |  <-------inorder(root->right)\\n                    |__________|\\n                    18 has no childeren thus sum=7 is passed on to the root.\\n                    18 is not in the range so sum doesnt change.\\n                    this process continues and 15 gets added to the sum giving sum=22\\n                    then 10 gets added  sum=32\\n                    */\\n     int sum=0;\\n    int inorder(TreeNode* root,int L,int R)\\n    {\\n        if(root){\\n        inorder(root->left,L,R);\\n        if(root->val>=L && root->val<=R)\\n            sum+=root->val;\\n        inorder(root->right,L,R);\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root)return 0;\\n        return inorder(root,L,R);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936480,
                "title": "python-simple-dfs-explained",
                "content": "One way to solve this problem is just iterate over our tree and for each element check if it is range or not. However here we are given, that out tree is `BST`, that is left subtree is always lesser than node lesser than right subtree. So, let us modify classical `dfs` a bit, where we traverse only nodes we need:\\n\\n1. Check value `node.val` and if it is in our range, add it to global sum.\\n2. We need to visit left subtree only if `node.val > low`, that is if `node.val < low`, it means, that all nodes in left subtree less than `node.val`, that is less than `low` as well.\\n3. Similarly, we visit right subtree only if `node.val < high`.\\n\\n**Complexity**: time complexity is `O(n)`, where `n` is nubmer of nodes in our tree, space complexity potentially `O(n)` as well. We can impove our estimations a bit and say, that time and space is `O(m)`, where `m` is number of nodes in our answer.\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        def dfs(node):\\n            if not node: return\\n            if low <= node.val <= high: self.out += node.val\\n            if node.val > low:  dfs(node.left)\\n            if node.val < high: dfs(node.right)\\n                \\n        self.out = 0\\n        dfs(root)\\n        return self.out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        def dfs(node):\\n            if not node: return\\n            if low <= node.val <= high: self.out += node.val\\n            if node.val > low:  dfs(node.left)\\n            if node.val < high: dfs(node.right)\\n                \\n        self.out = 0\\n        dfs(root)\\n        return self.out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409173,
                "title": "clean-and-fast-94-4-line-python3-code",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if root == None: return 0\\n        if root.val > R: return self.rangeSumBST(root.left,L,R)\\n        if root.val < L: return self.rangeSumBST(root.right,L,R)\\n        return root.val + self.rangeSumBST(root.left,L,R) + self.rangeSumBST(root.right,L,R)      \\n                   \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if root == None: return 0\\n        if root.val > R: return self.rangeSumBST(root.left,L,R)\\n        if root.val < L: return self.rangeSumBST(root.right,L,R)\\n        return root.val + self.rangeSumBST(root.left,L,R) + self.rangeSumBST(root.right,L,R)      \\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628229,
                "title": "c-python-simple-solution-w-explanation-dfs-bfs-w-optimizations-o-1-morris",
                "content": "We are given a BST and range `[L, H]`. We need to return sum of all nodes between this range.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Simple DFS)***\\n\\nWe can perform a simple DFS traversal over the tree and if the current node\\'s value is within the range `[L, H]`, then we will add it to the final sum. The same process can be carried out recursively till whole tree is explored.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        return  (root -> val >= L && root -> val <= H ? root -> val : 0) +  // add root\\'s value if it lies within [L, H]\\n                rangeSumBST(root -> left, L, H) +   // recurse left\\n                rangeSumBST(root -> right, L, H);   // recurse right\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        return  (root.val if root.val >= L and root.val <= H else 0) + \\\\\\n                self.rangeSumBST(root.left, L, H) + \\\\\\n                self.rangeSumBST(root.right, L, H)\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the number of nodes in the given tree\\n***Space Complexity :*** `O(H)`, where `H` is the height of the tree. This is required for recursive stack. In case of skewed tree, this would be `O(N)`, while in case of balanced tree, this would be `O(logN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (BST Optimized DFS)***\\n\\nIn the above solution, we aren\\'t taking the advantage of the fact that our given tree is a BST. We can reduce the search space in some cases by doing conditional recursion. \\n* If the root\\'s value is less than `L`, then it\\'s useless to further recurse the left sub-tree because we know that every node in left sub-tree will be less than `L` as well. **So iterate `root -> left` only when `root -> val > L`**\\n* Similarly, if root\\'s value is greater than `H`, we must not further recurse the right sub-tree. **So iterate `root -> right` only when `root -> val < H`**\\n\\nThe above two conditional checks help prune some recursive branches and thus optimize the solution slightly. Note that the time complexity still remains the same as the range can cover all nodes of BST.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        int ans = root -> val >= L && root -> val <= H ? root -> val : 0;\\n        if(root -> val > L) ans += rangeSumBST(root -> left, L, H);\\n        if(root -> val < H) ans += rangeSumBST(root -> right, L, H);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        ans = root.val if root.val >= L and root.val <= H else 0\\n        if root.val > L: ans += self.rangeSumBST(root.left, L, H)\\n        if root.val < H: ans += self.rangeSumBST(root.right, L, H)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, more specifically, this solution would only iterate the nodes which lie within the range `[L, H]`\\n***Space Complexity :*** `O(H)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BST Optimized BFS)***\\n\\nThe same thing can be done using BFS traversal as well. Similar to above approach, we will only push a left or right child into queue if the root\\'s value is `> L` or `< H` respectively\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* T, int L, int H) {\\n        queue<TreeNode*> q;\\n        q.push(T);\\n        int sum = 0, v;\\n        while(size(q)) {\\n            T = q.front(); q.pop();\\n            v = T -> val;\\n            if(v >= L and v <= H)   sum += v;\\n            if(v > L && T -> left)  q.push(T -> left);\\n            if(v < H && T -> right) q.push(T -> right);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, T, L, H):\\n        q, ans, v = deque([T]), 0, 0\\n        while q:\\n            T = q.popleft()\\n            v = T.val\\n            if v >= L and v <= H:  ans += v\\n            if v > L and T.left:   q.append(T.left)\\n            if v < H and T.right:  q.append(T.right)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(W)`, where `W` is the width of BST. In case of skewed tree, it will be `O(1)` and in case of balanced tree it will be `O(N/2) ~ O(N)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Morris Traversal)***\\n\\nWe can also use the Morris traversal (using the inorder version in this case) to optimze on space. I have also made some modification to prune further searches where we know that required node wont be found. You can read more on morris traversal **[here](https://leetcode.com/problems/binary-tree-inorder-traversal/solution/)** and **[here](https://stackoverflow.com/questions/5502916)**.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // finding predecessor of root\\n                while(pre -> right && pre -> val <= H) pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                pre -> right = root;        // adding temporary link\\n                auto tmp = root;\\n                root = root -> left;                    \\n                tmp -> left = nullptr;      // avoiding inifinte loop\\n            }\\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                if(root -> val < H) root = root -> right;\\n                else break;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThe above version modifies the tree. The following can be used if tree modification is not allowed- \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // find predecessor of root\\n                while(pre -> right && pre -> right != root)  pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                if(!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;                    \\n                }\\n                else {                    \\n                    if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                    pre -> right = nullptr;  // revert the changes - remove temporary link\\n                    root = root -> right;\\n                }\\n            } \\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                root = root -> right;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThe 1st version is optimized to prune redundant search wherever possible, but I guess the 2nd version only prunes left branches. If there\\'s a more optimized version of morris traversal that restores the tree as well, do comment below...\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(1)`, only constant space is being used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        return  (root -> val >= L && root -> val <= H ? root -> val : 0) +  // add root\\'s value if it lies within [L, H]\\n                rangeSumBST(root -> left, L, H) +   // recurse left\\n                rangeSumBST(root -> right, L, H);   // recurse right\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        return  (root.val if root.val >= L and root.val <= H else 0) + \\\\\\n                self.rangeSumBST(root.left, L, H) + \\\\\\n                self.rangeSumBST(root.right, L, H)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        if(!root) return 0;\\n        int ans = root -> val >= L && root -> val <= H ? root -> val : 0;\\n        if(root -> val > L) ans += rangeSumBST(root -> left, L, H);\\n        if(root -> val < H) ans += rangeSumBST(root -> right, L, H);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root, L, H):\\n        if not root: return 0\\n        ans = root.val if root.val >= L and root.val <= H else 0\\n        if root.val > L: ans += self.rangeSumBST(root.left, L, H)\\n        if root.val < H: ans += self.rangeSumBST(root.right, L, H)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* T, int L, int H) {\\n        queue<TreeNode*> q;\\n        q.push(T);\\n        int sum = 0, v;\\n        while(size(q)) {\\n            T = q.front(); q.pop();\\n            v = T -> val;\\n            if(v >= L and v <= H)   sum += v;\\n            if(v > L && T -> left)  q.push(T -> left);\\n            if(v < H && T -> right) q.push(T -> right);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, T, L, H):\\n        q, ans, v = deque([T]), 0, 0\\n        while q:\\n            T = q.popleft()\\n            v = T.val\\n            if v >= L and v <= H:  ans += v\\n            if v > L and T.left:   q.append(T.left)\\n            if v < H and T.right:  q.append(T.right)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // finding predecessor of root\\n                while(pre -> right && pre -> val <= H) pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                pre -> right = root;        // adding temporary link\\n                auto tmp = root;\\n                root = root -> left;                    \\n                tmp -> left = nullptr;      // avoiding inifinte loop\\n            }\\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                if(root -> val < H) root = root -> right;\\n                else break;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int H) {\\n        int ans = 0;\\n        while(root) \\n            if(root -> left && root -> val >= L) {\\n                auto pre = root -> left;  \\n                // find predecessor of root\\n                while(pre -> right && pre -> right != root)  pre = pre -> right;\\n                // make root as right child of predecessor (temporary link)\\n                if(!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;                    \\n                }\\n                else {                    \\n                    if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                    pre -> right = nullptr;  // revert the changes - remove temporary link\\n                    root = root -> right;\\n                }\\n            } \\n\\t\\t\\telse {\\n                if(root -> val >= L && root -> val <= H) ans += root -> val;\\n                root = root -> right;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127563,
                "title": "0ms-java-solution-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374212,
                "title": "javascript-solution",
                "content": "```\\nvar rangeSumBST = function(root, L, R) {\\n    var sum = 0;\\n    if (root == null) {\\n        return sum;\\n    }\\n\\n    if (root.val > L) {\\n        sum += rangeSumBST(root.left, L, R);\\n    }\\n    if (root.val <= R && root.val >= L) {\\n        sum += root.val;\\n    }\\n    if (root.val < R) {\\n        sum += rangeSumBST(root.right, L, R);    \\n    }    \\n    \\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n    var sum = 0;\\n    if (root == null) {\\n        return sum;\\n    }\\n\\n    if (root.val > L) {\\n        sum += rangeSumBST(root.left, L, R);\\n    }\\n    if (root.val <= R && root.val >= L) {\\n        sum += root.val;\\n    }\\n    if (root.val < R) {\\n        sum += rangeSumBST(root.right, L, R);    \\n    }    \\n    \\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 498058,
                "title": "100-00-fast-in-memory-and-run-time-dfs-recursive-iterative-solution",
                "content": "Compare yourself, as the different ways are below: satisfied? \\nDon\\'t look at runtime, as this may change time to time on each submission. Have a look at optimized approach.\\n\\n-------\\nRuntime: 84 ms, faster than 98.75% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.1 MB, less than 99.09% of C++ online submissions for Range Sum of BST.\\nIf root\\'s value is greater than L then move left, and if it\\'s value if less than R then move right.\\nTime Complexity: **O(N)**, where N is the number of nodes in the tree.\\nSpace Complexity: **O(H)**, where H is the height of the tree. i.e. **O(1)**\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* node = st.top(); st.pop();\\n            if(node->val>=L && node->val<=R) rangeSum+=node->val;\\n            if(node->val > L) {if(node->left) st.push(node->left);}\\n            if(node->val < R) {if(node->right) st.push(node->right);}\\n        }\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n---------------\\nTime Complexity **O(n)** & Space Complexity **O(n)**\\nRuntime: 96 ms, faster than 95.88% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.1 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n        return ((root->val>=L && root->val<=R)? root->val : 0) + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n    }\\n};\\n```\\n\\n---------------\\nRuntime: 80 ms, faster than 92.88% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n    return ((root->val>=L && root->val<=R)? (root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R)) : (root->val<L)? rangeSumBST(root->right,L,R): rangeSumBST(root->left,L,R));\\n    }\\n};\\n```\\n\\n--------------\\nRuntime: 92 ms, faster than 96.85% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 89.09% of C++ online submissions for Range Sum of BST.\\n```\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root, int L, int R, int rangeSum){\\n        if(!root) return 0;\\n        else if(root->val>=L && root->val<=R){\\n            rangeSum+=helper(root->left,L,R,0);\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum + root->val;\\n        }else if(root->val > L){\\n            rangeSum+=helper(root->left,L,R,0);\\n            return rangeSum;\\n        }else if(root->val < R){\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum;\\n        }\\n        return 0;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        std::ios::sync_with_stdio(false);\\n        return helper(root,L,R,0);\\n    }\\n};\\n```\\n\\n-----------------\\nRuntime: 92 ms, faster than 96.92% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 86.36% of C++ online submissions for Range Sum of BST.\\nSolution: **We traverse the tree using a depth first search. If node.val falls outside the range [L, R], (for example node.val < L), then we know that only the right branch could have nodes with value inside [L, R].**\\nTC: **O(n)**, SC: **O(n)**\\n```\\nclass Solution { // dfs\\nprivate:\\n    int rangeSum;\\npublic:\\n    void dfs(TreeNode* root, int L, int R){\\n        if(!root) return;\\n        if(root->val>=L && root->val<=R) rangeSum+=root->val;\\n        if(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        rangeSum = 0;\\n        dfs(root,L,R);\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n----------------------\\nRuntime: 148 ms, faster than 76.44% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41.2 MB, less than 88.18% of C++ online submissions for Range Sum of BST.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int &rangeSum, int L, int R, bool isDone){\\n        if(!root || isDone) return;\\n        dfs(root->left,rangeSum,L,R,false);\\n        if(root->val>=L && root->val<=R){\\n            rangeSum+=root->val;\\n            if(root->val==R) isDone = true;\\n        }\\n        dfs(root->right,rangeSum,L,R,false);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        dfs(root,rangeSum,L,R,false);\\n        return rangeSum;\\n    }\\n};\\n```\\n\\n--------\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* node = st.top(); st.pop();\\n            if(node->val>=L && node->val<=R) rangeSum+=node->val;\\n            if(node->val > L) {if(node->left) st.push(node->left);}\\n            if(node->val < R) {if(node->right) st.push(node->right);}\\n        }\\n        return rangeSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n        return ((root->val>=L && root->val<=R)? root->val : 0) + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root) return 0;\\n    return ((root->val>=L && root->val<=R)? (root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R)) : (root->val<L)? rangeSumBST(root->right,L,R): rangeSumBST(root->left,L,R));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root, int L, int R, int rangeSum){\\n        if(!root) return 0;\\n        else if(root->val>=L && root->val<=R){\\n            rangeSum+=helper(root->left,L,R,0);\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum + root->val;\\n        }else if(root->val > L){\\n            rangeSum+=helper(root->left,L,R,0);\\n            return rangeSum;\\n        }else if(root->val < R){\\n            rangeSum+=helper(root->right,L,R,0);\\n            return rangeSum;\\n        }\\n        return 0;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        std::ios::sync_with_stdio(false);\\n        return helper(root,L,R,0);\\n    }\\n};\\n```\n```\\nclass Solution { // dfs\\nprivate:\\n    int rangeSum;\\npublic:\\n    void dfs(TreeNode* root, int L, int R){\\n        if(!root) return;\\n        if(root->val>=L && root->val<=R) rangeSum+=root->val;\\n        if(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        rangeSum = 0;\\n        dfs(root,L,R);\\n        return rangeSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int &rangeSum, int L, int R, bool isDone){\\n        if(!root || isDone) return;\\n        dfs(root->left,rangeSum,L,R,false);\\n        if(root->val>=L && root->val<=R){\\n            rangeSum+=root->val;\\n            if(root->val==R) isDone = true;\\n        }\\n        dfs(root->right,rangeSum,L,R,false);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int rangeSum(0);\\n        dfs(root,rangeSum,L,R,false);\\n        return rangeSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885368,
                "title": "python3-dfs-one-liner-recursive-iterative-explained",
                "content": "**One-liner**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```\\n\\n**Recursive 1** (more readable)\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root: \\n            return 0\\n        \\n        # When value is less than low, everything on it\\'s left doesn\\'t matter, \\n        # so only return the sum from its right children\\n        if root.val<low: \\n            return self.rangeSumBST(root.right,low,high)\\n        \\n        # Same thing for high.\\n        elif root.val>high: \\n            return self.rangeSumBST(root.left,low,high)\\n        \\n        # The current value is in the range, so return the sum of its left, right and own value\\n        else:\\n            return root.val + self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high)\\n```\\n\\n**Recursive 2**\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        def dfs(node):\\n            nonlocal res\\n            if not node: return\\n            \\n            # increase res only when the node value is in the range\\n            if low<=node.val<=high: res += node.val\\n            \\n            # The only time we don\\'t want to go left, is when the nodel value <= low.\\n            # Because it is a BST, and if the current value is aleady <= low, \\n            # there is no more hope!\\n            if node.val>low: dfs(node.left)\\n            \\n            # Same as above, but going right\\n            if node.val<high: dfs(node.right)\\n\\n        dfs(root)\\n        return res\\n```\\n\\n**Iterative** (same idea as Recursive 2)\\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        q = [root]\\n        while q:\\n            cur = q.pop()\\n            if cur:\\n                if low <= cur.val <= high:\\n                    res += cur.val\\n                if cur.val > low:\\n                    q.append(cur.left)\\n                if cur.val < high:\\n                    q.append(cur.right)\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        return 0 if not root else self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high) + int(low<=root.val<=high) * root.val\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root: \\n            return 0\\n        \\n        # When value is less than low, everything on it\\'s left doesn\\'t matter, \\n        # so only return the sum from its right children\\n        if root.val<low: \\n            return self.rangeSumBST(root.right,low,high)\\n        \\n        # Same thing for high.\\n        elif root.val>high: \\n            return self.rangeSumBST(root.left,low,high)\\n        \\n        # The current value is in the range, so return the sum of its left, right and own value\\n        else:\\n            return root.val + self.rangeSumBST(root.right,low,high) + self.rangeSumBST(root.left,low,high)\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        def dfs(node):\\n            nonlocal res\\n            if not node: return\\n            \\n            # increase res only when the node value is in the range\\n            if low<=node.val<=high: res += node.val\\n            \\n            # The only time we don\\'t want to go left, is when the nodel value <= low.\\n            # Because it is a BST, and if the current value is aleady <= low, \\n            # there is no more hope!\\n            if node.val>low: dfs(node.left)\\n            \\n            # Same as above, but going right\\n            if node.val<high: dfs(node.right)\\n\\n        dfs(root)\\n        return res\\n```\n```python\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = 0\\n        q = [root]\\n        while q:\\n            cur = q.pop()\\n            if cur:\\n                if low <= cur.val <= high:\\n                    res += cur.val\\n                if cur.val > low:\\n                    q.append(cur.left)\\n                if cur.val < high:\\n                    q.append(cur.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251711,
                "title": "cpp-beats-96-better-than-o-n-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n      \\n      if(!root) return 0;\\n      \\n      if(root->val >= L && root->val <= R){\\n        return root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n      }else if(root->val < L){\\n        return rangeSumBST(root->right,L,R);\\n      }else {\\n        return rangeSumBST(root->left,L,R);\\n      }\\n    }\\n  \\n  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n      \\n      if(!root) return 0;\\n      \\n      if(root->val >= L && root->val <= R){\\n        return root->val + rangeSumBST(root->left,L,R) + rangeSumBST(root->right,L,R);\\n      }else if(root->val < L){\\n        return rangeSumBST(root->right,L,R);\\n      }else {\\n        return rangeSumBST(root->left,L,R);\\n      }\\n    }\\n  \\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192018,
                "title": "c-2-lines",
                "content": "Just doing regular tree traversal and adding values within [L, R]. Note that in the solution description, we are given BST, however, this solution  works for any binary tree.\\n\\nOf course, we can optimize a bit for the fact that this is BST. I checked the runtime and did not see any difference in the runtime. Both naive and optimized solution gave me 68 ms.\\n```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;\\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;\\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1627913,
                "title": "c-easy-to-solve-detailed-explanation-while-optimizing-approach",
                "content": "**Intuition:**\\nActually the question is pretty straightforward ,Basically the question maker is asking us to  add all the numbers in a BST with a certain range given for numbers like say range is given as  [Low,High]=[2,7] then we need to add all the values in BST with the numbers satisfying this range. So major people who thought of a solution will be either using  recursion ,DFS or BFS.\\n*Now, let\\'s talk about approach*\\n\\n**Algorithm:**\\nIn the following algorithm we will be discussing the solution of dfs approach .\\n1. let` sumofRange` be a variable that will be our final result . After this let\\'s declare a dfs helper function .\\n2. The base case will be when the tree is empty so we return null\\n3. we have to find the` sumofRange` so for that we need to add all the root values which satisfyes the condition that `node values should be more than low and less than high` .If this is true than add it to `sumofRange`\\n4. After this let\\'s dig the depth\\'s of the tree i.e Left childs and Right childs.\\n5. Now just call out the dfs helper function in the main function \\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    int sumofRange;\\n    void dfs(TreeNode* root, int L, int R){\\n\\t\\t//Base case\\n        if(!root) return;\\n\\t\\t//If in range add \\n        if(root->val >= L && root->val <= R) sumofRange += root->val;\\n        //Digging the depths of the tree\\n\\t\\tif(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        sumofRange = 0;\\n        dfs(root,L,R);\\n        return sumofRange;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(n) [n=number of nodes]`*\\n**Space Complexity:** *`O(h) [h=height of tree] [Considering recursive calls]`*\\n\\n\\n**Space Optimized Approach:**\\nAfter exploring some other options, I found that we can actually optimize the space.\\nThe logic is almost same as we discussed in the above approach .The main difference is that we use a stack for storing the data of nodes . So everytime we can just peek and pop the last values that we entered\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int sumofRange(0);\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* node = stack.top(); stack.pop();\\n            if(node->val>=L && node->val<=R) sumofRange+=node->val;\\n            if(node->val > L) {if(node->left) stack.push(node->left);}\\n            if(node->val < R) {if(node->right) stack.push(node->right);}\\n        }\\n        return sumofRange;\\n    }\\n};\\n```\\n\\n**Time Complexity:** *`O(n) [n=number of nodes]`*\\n**Space Complexity:** *`O(h) [h=height of the tree]`*\\n\\n\\n........*continuation from previous posts..\\nTill now in the Discovery of Dr.Cheems Ancient Ruins arc.. A sudden discovery of algorithm created a rift a humans mind who discovered this algos and from where this algo\\'s came. After some investigation they found out that there was certaing identity in ancient time known as Dr.Cheems Doge who was renowed for his intelligence. After inspecting a bit more they found out that at a certain place there was ancient ruins of his lab. The excavation of the ruins happened under a group of 5 great archeologists.A mysterious call came to seize the excavation but they didn\\'t stop. After some excavation the doors started vibrating and changed colors also a mysterious passcode panel came front...\\nTo be continued in the next post*.........\\n\\n**Feel free to comment and upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofRange;\\n    void dfs(TreeNode* root, int L, int R){\\n\\t\\t//Base case\\n        if(!root) return;\\n\\t\\t//If in range add \\n        if(root->val >= L && root->val <= R) sumofRange += root->val;\\n        //Digging the depths of the tree\\n\\t\\tif(root->val > L) dfs(root->left,L,R);\\n        if(root->val < R) dfs(root->right,L,R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        sumofRange = 0;\\n        dfs(root,L,R);\\n        return sumofRange;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int sumofRange(0);\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* node = stack.top(); stack.pop();\\n            if(node->val>=L && node->val<=R) sumofRange+=node->val;\\n            if(node->val > L) {if(node->left) stack.push(node->left);}\\n            if(node->val < R) {if(node->right) stack.push(node->right);}\\n        }\\n        return sumofRange;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349978,
                "title": "python-use-visualization-help-you-think-about-it",
                "content": "1. L = 7, R = 15, sum=32:\\n```\\n         *10\\n         /  \\\\\\n       *5    *15\\n       / \\\\     \\\\\\n      3   *7    18\\n```\\n\\t  \\n2.  L = 6, R = 10, sum=23 :\\n```\\n\\t            *10\\n               /    \\\\\\n              5      15\\n             / \\\\     / \\\\\\n            3   *7  13  18\\n           /   /\\n         1    *6\\n\\n```\\n```\\nclass Solution(object):\\n    def rangeSumBST(self, root, L, R):\\n        def dfs(node):\\n            if node:\\n                if L<= node.val <= R:\\n                    self.ans += node.val\\n                    #print(node.val)\\n                if node.val>L:\\n                    dfs(node.left)\\n                if node.val<R:\\n                    dfs(node.right)\\n        self.ans = 0\\n        dfs(root)\\n        return self.ans\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n         *10\\n         /  \\\\\\n       *5    *15\\n       / \\\\     \\\\\\n      3   *7    18\\n```\n```\\n\\t            *10\\n               /    \\\\\\n              5      15\\n             / \\\\     / \\\\\\n            3   *7  13  18\\n           /   /\\n         1    *6\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193702,
                "title": "javascript-2-solutions-easy-to-understand-beats-100",
                "content": "1. Sum while recursing through the tree\\n```\\nvar rangeSumBST = function(root, L, R) {\\n    // base case\\n    if(root == null) {\\n        return 0;\\n    }\\n    \\n    if(root.val > R) {\\n        return rangeSumBST(root.left, L, R);\\n    } else if(root.val < L) {\\n        return rangeSumBST(root.right, L, R);\\n    } else {\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n};\\n```\\n\\n2. Do inorder traversal to get all nodes on tree in order, and then sum all values >= L and <=R. This is less efficient than previous solution because we are traversing all nodes, but this can be easier to understand.\\n```\\nvar rangeSumBST = function(root, L, R) {\\n    var arr = [], sum=0;\\n    inorder(root, arr);\\n    \\n    for(var i=0; i<arr.length; i++) {\\n        if(arr[i] >= L && arr[i] <= R) {\\n            sum = sum + arr[i];\\n        }\\n    }\\n    \\n    return sum;\\n};\\n\\nvar inorder = function(root, arr) {\\n    if(root == null) {\\n        return;\\n    }\\n    \\n    inorder(root.left, arr);\\n    arr.push(root.val);\\n    inorder(root.right, arr);\\n \\n    return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n    // base case\\n    if(root == null) {\\n        return 0;\\n    }\\n    \\n    if(root.val > R) {\\n        return rangeSumBST(root.left, L, R);\\n    } else if(root.val < L) {\\n        return rangeSumBST(root.right, L, R);\\n    } else {\\n        return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n};\\n```\n```\\nvar rangeSumBST = function(root, L, R) {\\n    var arr = [], sum=0;\\n    inorder(root, arr);\\n    \\n    for(var i=0; i<arr.length; i++) {\\n        if(arr[i] >= L && arr[i] <= R) {\\n            sum = sum + arr[i];\\n        }\\n    }\\n    \\n    return sum;\\n};\\n\\nvar inorder = function(root, arr) {\\n    if(root == null) {\\n        return;\\n    }\\n    \\n    inorder(root.left, arr);\\n    arr.push(root.val);\\n    inorder(root.right, arr);\\n \\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193235,
                "title": "python3-easy-to-understand-inorder-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return self.inorder(root, 0, L, R)\\n            \\n    def inorder(self, root, value, L, R):\\n        if root:\\n            value = self.inorder(root.left, value, L, R)\\n            if root.val >= L and root.val <= R:\\n                value += root.val\\n            value = self.inorder(root.right, value, L, R)\\n        \\n        return value\\n```\\n\\n**UPDATE**\\nWe may optimize this by setting the \\n```\\nif root.val >= L and root.val <= R:\\n``` \\nas\\n```\\nif root.val > R:\\n\\treturn value\\nelif root.val >= L:\\n\\tvalue += root.val\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return self.inorder(root, 0, L, R)\\n            \\n    def inorder(self, root, value, L, R):\\n        if root:\\n            value = self.inorder(root.left, value, L, R)\\n            if root.val >= L and root.val <= R:\\n                value += root.val\\n            value = self.inorder(root.right, value, L, R)\\n        \\n        return value\\n```\n```\\nif root.val >= L and root.val <= R:\\n```\n```\\nif root.val > R:\\n\\treturn value\\nelif root.val >= L:\\n\\tvalue += root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320320,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, L, R) {\\n    // check if value is in the given range\\n    const isInBetween = val => val >= L && val <= R;\\n    // sum the value if it\\'s in the range\\n    const add = (val, sum) => isInBetween(val) ? sum += val : sum;\\n\\t// traverse through the nodes and sum the values in range\\n    const preorder =(root, sum) => {\\n        if (!root) return sum;\\n        return add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\\n    } \\n    return preorder(root, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, L, R) {\\n    // check if value is in the given range\\n    const isInBetween = val => val >= L && val <= R;\\n    // sum the value if it\\'s in the range\\n    const add = (val, sum) => isInBetween(val) ? sum += val : sum;\\n\\t// traverse through the nodes and sum the values in range\\n    const preorder =(root, sum) => {\\n        if (!root) return sum;\\n        return add(root.val, sum) + preorder(root.left, sum) + preorder(root.right, sum);\\n    } \\n    return preorder(root, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885382,
                "title": "python-c-java-dfs-bfs-binary-search-explained-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs conditional traversal of a Binary Search Tree. Time complexity is linear: **O(N)**. Space complexity is logarithmic (for a balanced tree): **O(logN)**.\\n****\\n\\n**Comment.** Binary Search Tree (BST) is a type of binary tree for which the left (right) subtree of each node is also a BST with all values being less (greater) than the node\\'s value. This defines a recursive strategy to compute range sums, namely:\\n1. Take node\\'s value if it\\'s in range. \\n2. If node\\'s value is greater than the lower bound then search for valid values in the left subtree.\\n3. If node\\'s value is less than the upper bound then search for valid values in the right subtree.\\n\\n**Python #1.** DFS.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root : return 0\\n        \\n        s = root.val if low <= root.val <= high else 0\\n        if low  <= root.val : s += self.rangeSumBST(root.left,  low, high)\\n        if high >= root.val : s += self.rangeSumBST(root.right, low, high)\\n        \\n        return s\\n```\\n\\n**Python #2.** BFS.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        dq, s = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if low  <= node.val <= high        : s += node.val\\n            if low  <= node.val and node.left  : dq.append(node.left)\\n            if high >= node.val and node.right : dq.append(node.right)\\n        return s\\n```\\n\\nThere is also a more expensive, however, interesting approach. \\n\\n**Python #3.** Collect values in order then binary search.\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def inorder(n, v):\\n            if n: inorder(n.left, v), v.append(n.val), inorder(n.right, v)\\n        \\n        vals = []\\n        inorder(root, vals)\\n        \\n        return sum(vals[bisect_left(vals, low) : bisect_right(vals, high)])\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/2RVvrN38/shared\" frameBorder=\"0\" width=\"800\" height=\"260\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** DFS one-liner.\\n```\\nclass Solution:\\n    def rangeSumBST(self, r, l, h):\\n        \\n        return 0 if not r else (l <= r.val <= h) * r.val + \\\\\\n                               self.rangeSumBST(r.right, l, h) + \\\\\\n                               self.rangeSumBST(r.left,  l, h)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        if not root : return 0\\n        \\n        s = root.val if low <= root.val <= high else 0\\n        if low  <= root.val : s += self.rangeSumBST(root.left,  low, high)\\n        if high >= root.val : s += self.rangeSumBST(root.right, low, high)\\n        \\n        return s\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        dq, s = deque([root]), 0\\n        while dq:\\n            node = dq.popleft()\\n            if low  <= node.val <= high        : s += node.val\\n            if low  <= node.val and node.left  : dq.append(node.left)\\n            if high >= node.val and node.right : dq.append(node.right)\\n        return s\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def inorder(n, v):\\n            if n: inorder(n.left, v), v.append(n.val), inorder(n.right, v)\\n        \\n        vals = []\\n        inorder(root, vals)\\n        \\n        return sum(vals[bisect_left(vals, low) : bisect_right(vals, high)])\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, r, l, h):\\n        \\n        return 0 if not r else (l <= r.val <= h) * r.val + \\\\\\n                               self.rangeSumBST(r.right, l, h) + \\\\\\n                               self.rangeSumBST(r.left,  l, h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703641,
                "title": "python-2-elegant-solutions-recursive-and-iterative",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            if node.val < L: return dfs(node.right)\\n            elif node.val > R: return dfs(node.left)\\n            else: return dfs(node.left) + dfs(node.right) + node.val\\n        return dfs(root)\\n        \\n        ## APPROACH : ITERATIVE ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        stack = [root]\\n        ans = 0\\n        while(stack):\\n            node = stack.pop()\\n            if node:\\n                if L <= node.val <= R: ans += node.val\\n                if L < node.val: stack.append(node.left)\\n                if R > node.val: stack.append(node.right)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            if node.val < L: return dfs(node.right)\\n            elif node.val > R: return dfs(node.left)\\n            else: return dfs(node.left) + dfs(node.right) + node.val\\n        return dfs(root)\\n        \\n        ## APPROACH : ITERATIVE ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(H) ##\\n        stack = [root]\\n        ans = 0\\n        while(stack):\\n            node = stack.pop()\\n            if node:\\n                if L <= node.val <= R: ans += node.val\\n                if L < node.val: stack.append(node.left)\\n                if R > node.val: stack.append(node.right)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192011,
                "title": "c-recursion",
                "content": "    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root || L > R)\\n            return 0;\\n        \\n        if(root->val < L)\\n            return rangeSumBST(root->right, L, R);\\n        \\n        if(root->val > R)\\n            return rangeSumBST(root->left, L, R);\\n        \\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    }",
                "solutionTags": [],
                "code": "    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(!root || L > R)\\n            return 0;\\n        \\n        if(root->val < L)\\n            return rangeSumBST(root->right, L, R);\\n        \\n        if(root->val > R)\\n            return rangeSumBST(root->left, L, R);\\n        \\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 480481,
                "title": "simple-recursive-solution-faster-than-96",
                "content": "```\\nconst rangeSumBST = (root, L, R) => {\\n    let sum = 0;\\n    const traverse = (root) => {\\n        if (root.val >= L && root.val <= R) sum += root.val;\\n        if (root.left !== null) traverse(root.left);\\n        if (root.right !== null) traverse(root.right);\\n    }\\n    traverse(root);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst rangeSumBST = (root, L, R) => {\\n    let sum = 0;\\n    const traverse = (root) => {\\n        if (root.val >= L && root.val <= R) sum += root.val;\\n        if (root.left !== null) traverse(root.left);\\n        if (root.right !== null) traverse(root.right);\\n    }\\n    traverse(root);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192148,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        return root and self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) + (L <= root.val <= R) * root.val or 0\\n```\\n* More readable\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        if not root: return 0\\n        l = self.rangeSumBST(root.left, L, R)\\n        r = self.rangeSumBST(root.right, L, R)\\n        return l + r + (L <= root.val <= R) * root.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        return root and self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) + (L <= root.val <= R) * root.val or 0\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        if not root: return 0\\n        l = self.rangeSumBST(root.left, L, R)\\n        r = self.rangeSumBST(root.right, L, R)\\n        return l + r + (L <= root.val <= R) * root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192020,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.val >= L && root.val <= R) {\\n            return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n        } else if (root.val < L) {\\n            return rangeSumBST(root.right, L, R);\\n        } else {\\n            return rangeSumBST(root.left, L, R);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.val >= L && root.val <= R) {\\n            return root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n        } else if (root.val < L) {\\n            return rangeSumBST(root.right, L, R);\\n        } else {\\n            return rangeSumBST(root.left, L, R);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097555,
                "title": "simple-easy-to-understand-java-0-ms-faster-than-100-00-using-dfs-clean-code-with-comment",
                "content": "```\\n\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294243,
                "title": "python-beat-90-simple-solution",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val >= L and root.val <= R:\\n            return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        else:\\n            return self.rangeSumBST(root.left, L, R)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        elif root.val >= L and root.val <= R:\\n            return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)\\n        elif root.val < L:\\n            return self.rangeSumBST(root.right, L, R)\\n        else:\\n            return self.rangeSumBST(root.left, L, R)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628107,
                "title": "java-dfs-bst-specific-0ms-can-merge-into-one-line",
                "content": "Original codes:\\n```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null)\\n        \\treturn 0;\\n        int val = 0, left = 0, right = 0;\\n        if (root.val >= low && root.val <= high)\\n            val = root.val;\\n        if (root.val > low)\\n        \\tleft = rangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n        \\tright = rangeSumBST(root.right, low, high);\\n        return val + left + right;\\n    }\\n```\\nOne line of codes (seperate to multiple lines for easy-understanding):\\n```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n    \\treturn root == null ? 0 :\\n    \\t\\t   (root.val >= low && root.val <= high ? root.val : 0) +\\n    \\t\\t   (root.val > low  ? rangeSumBST(root.left,  low, high) : 0) + \\n    \\t\\t   (root.val < high ? rangeSumBST(root.right, low, high) : 0);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null)\\n        \\treturn 0;\\n        int val = 0, left = 0, right = 0;\\n        if (root.val >= low && root.val <= high)\\n            val = root.val;\\n        if (root.val > low)\\n        \\tleft = rangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n        \\tright = rangeSumBST(root.right, low, high);\\n        return val + left + right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213314,
                "title": "python-3-faster-than-99-54-simple-solution",
                "content": "````\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        if root:\\n            if root.val<low:\\n                return self.rangeSumBST(root.right,low,high)\\n            elif root.val>high:\\n                return self.rangeSumBST(root.left,low,high)\\n            return root.val + self.rangeSumBST(root.left,low,high) + self.rangeSumBST(root.right,low,high)\\n        else:\\n            return 0",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "````\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        if root:\\n            if root.val<low:\\n                return self.rangeSumBST(root.right,low,high)\\n            elif root.val>high:\\n                return self.rangeSumBST(root.left,low,high)\\n            return root.val + self.rangeSumBST(root.left,low,high) + self.rangeSumBST(root.right,low,high)\\n        else:\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 339587,
                "title": "c-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void inorder(TreeNode* root, int L, int R){\\n        if(root->left)inorder(root->left, L, R);\\n        if(root->val>=L && root->val<=R)sum+=root->val;\\n        if(root->right)inorder(root->right, L, R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        \\n        //SOLUCHAN STARTS HERE - DUN DUN DUN DUN \\n        inorder(root, L, R);\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void inorder(TreeNode* root, int L, int R){\\n        if(root->left)inorder(root->left, L, R);\\n        if(root->val>=L && root->val<=R)sum+=root->val;\\n        if(root->right)inorder(root->right, L, R);\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        \\n        //SOLUCHAN STARTS HERE - DUN DUN DUN DUN \\n        inorder(root, L, R);\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193674,
                "title": "jave-easy-to-understand-2ms-solution-tree-pruning",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        helper(root, L, R);\\n        return sum;\\n    }\\n    \\n    public void helper(TreeNode root, int L, int R){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.val <= R && root.val >= L){\\n            sum += root.val;\\n            helper(root.left, L, R);\\n            helper(root.right, L, R);\\n        }else if(root.val < L){\\n            helper(root.right, L, R); //no need to go left since the left branch must be smaller than L\\n        }else{ //root great than R\\n            helper(root.left, L, R); //no need to go right since the right branch must be larger than R\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        helper(root, L, R);\\n        return sum;\\n    }\\n    \\n    public void helper(TreeNode root, int L, int R){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.val <= R && root.val >= L){\\n            sum += root.val;\\n            helper(root.left, L, R);\\n            helper(root.right, L, R);\\n        }else if(root.val < L){\\n            helper(root.right, L, R); //no need to go left since the left branch must be smaller than L\\n        }else{ //root great than R\\n            helper(root.left, L, R); //no need to go right since the right branch must be larger than R\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580124,
                "title": "javascript-simple-dfs-solution",
                "content": "Runtime: 148 ms, faster than 98.20% of JavaScript online submissions for Range Sum of BST.\\nMemory Usage: 66.8 MB, less than 100.00% of JavaScript online submissions for Range Sum of BST.\\n```\\nfunction rangeSumBST(root, l, r) {\\n  let sum = 0\\n  dfs(root)\\n  return sum\\n  \\n  function dfs(node) {\\n    if (!node) {\\n      return\\n    }\\n    \\n    if (node.val < l) {\\n      dfs(node.right)\\n      return\\n    }\\n    \\n    if (node.val > r) {\\n      dfs(node.left)\\n      return\\n    }\\n\\n    sum += node.val\\n    dfs(node.left)\\n    dfs(node.right)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction rangeSumBST(root, l, r) {\\n  let sum = 0\\n  dfs(root)\\n  return sum\\n  \\n  function dfs(node) {\\n    if (!node) {\\n      return\\n    }\\n    \\n    if (node.val < l) {\\n      dfs(node.right)\\n      return\\n    }\\n    \\n    if (node.val > r) {\\n      dfs(node.left)\\n      return\\n    }\\n\\n    sum += node.val\\n    dfs(node.left)\\n    dfs(node.right)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886115,
                "title": "c-using-preorder-traversal-explained",
                "content": "# Intuition\\nAs we know we need to find the sum between the ranges , so very first thing that comes in our mind is to check all the nodes one by one any try out.... (Using Recursion Do the Traversal)\\n\\n# Approach\\n1. build a rescursive function to call check each node of BST\\n2. if my node current value lies under the given ranges then I\\'ll take that into my sum\\n3. Contuniue calling recursively untill the tree is not finished\\n4. Return the sum between ranges\\n\\n# Complexity\\n- **Time complexity: O(n)**  -> here n is number of nodes\\n\\n- **Space complexity: O(n)**  -> stack space of recursion\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void find(TreeNode* root,int low,int high,int& sum)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n\\n        find(root->left,low,high,sum);\\n        find(root->right,low,high,sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum = 0;\\n        find(root,low,high,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(TreeNode* root,int low,int high,int& sum)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n\\n        find(root->left,low,high,sum);\\n        find(root->right,low,high,sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum = 0;\\n        find(root,low,high,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724024,
                "title": "python-3-300ms-simple-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        s=0\\n        if root.val>=low and root.val<=high:\\n            s=s+root.val\\n        s=s+self.rangeSumBST(root.left,low,high)\\n        s=s+self.rangeSumBST(root.right,low,high)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        s=0\\n        if root.val>=low and root.val<=high:\\n            s=s+root.val\\n        s=s+self.rangeSumBST(root.left,low,high)\\n        s=s+self.rangeSumBST(root.right,low,high)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192579,
                "title": "python-solution",
                "content": "DFS recursive:\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            if L <= root.val <= R:\\n                self.res += root.val\\n            if L <= root.val:\\n                dfs(root.left)\\n            if R >= root.val:\\n                dfs(root.right)\\n        self.res = 0\\n        dfs(root)\\n        return self.res\\n```\\nDFS iterative:\\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        stack = [root]\\n        res = 0\\n        while stack:\\n            u = stack.pop()\\n            if L <= u.val <= R:\\n                res += u.val\\n            if u.left and u.val >= L:\\n                stack.append(u.left)\\n            if u.right and u.val <= R:\\n                stack.append(u.right)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            if L <= root.val <= R:\\n                self.res += root.val\\n            if L <= root.val:\\n                dfs(root.left)\\n            if R >= root.val:\\n                dfs(root.right)\\n        self.res = 0\\n        dfs(root)\\n        return self.res\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root, L, R):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        stack = [root]\\n        res = 0\\n        while stack:\\n            u = stack.pop()\\n            if L <= u.val <= R:\\n                res += u.val\\n            if u.left and u.val >= L:\\n                stack.append(u.left)\\n            if u.right and u.val <= R:\\n                stack.append(u.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886005,
                "title": "7th-december-daily-challenge-leetcode",
                "content": "# Intuition\\nMy Very First intuition to solve this approach was to traverse the tree in inorder manner, I did that and stored values of each Node in a seperate array and then traversed the array to sum up values following the given constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBut then I made a little change in the Inorder Traversal Algorithm and rather than to store in another array I updated the sums variable(variable storing my answer) at that place and then simply returned the sums variable storing my anser.\\nNote: I defined a class variable sums to store my answer, so that I can update its value in a helper function findSum from inside the function.\\n\\nNote: The findSum function I used is simply a modified version of Inorder Traversal Function\\n\\nVote up if this Helps!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is same as that of inorder traversal, that is O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf we consider the size of the stack for function calls then O(h + 1) and one is added for sums variable, where h is the height of the tree.\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    sums = 0\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        def findSum(root):\\n            if root:\\n                findSum(root.left)\\n                if root.val <= high and root.val >= low:\\n                    self.sums += root.val\\n                findSum(root.right)\\n        findSum(root)\\n        \\n        return self.sums\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    sums = 0\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        def findSum(root):\\n            if root:\\n                findSum(root.left)\\n                if root.val <= high and root.val >= low:\\n                    self.sums += root.val\\n                findSum(root.right)\\n        findSum(root)\\n        \\n        return self.sums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885406,
                "title": "python-3-6-lines-two-versions-w-explanation-t-m-98-92",
                "content": "A binary *search* tree is more than just a binary tree. For each node *node*, every node value in `node`\\'s left tree is less than `node.val`, and every node value in `node`\\'s right tree is greater than `node.val`.\\n\\nHere\\'s the plan:\\n- Traverse the tree recursively or iteratively, and at each node visited, return the sum of all qualifying node values in its two subtrees. However, for any `node`:\\n\\n- If `node.val` is less than `low`, then we know that each value in node\\'s left subtree is also less than `low`; if so, we do not need to traverse *node*\\'s left subtree.\\n- Likewise, If `node.val` is greater than `high`, then we know that each value in `node`\\'s right subtree is also greater than `high`; if so, we do not need to traverse `node`\\'s right subtree.\\n\\nHere is the recursive version\\n\\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        def dfs(node):\\n\\n            if not node: return 0\\n\\n            if node.val <  low: return dfs(node.right)\\n            if node.val > high: return dfs(node.left )\\n            \\n            return dfs(node.left ) + dfs(node.right) + node.val\\n\\n        return dfs(root)\\n```\\n[https://leetcode.com/problems/range-sum-of-bst/submissions/855830563/](http://)\\n\\n\\n\\nI could be wrong, but I think that, worst-case, time is *O*(*N*) and space is *O*(*N*).\\n\\nHere\\'s the iterative version:\\n\\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        ans, stack = 0, deque([root])\\n\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n\\n            if   node.val <  low: stack.append(node.right)\\n            elif node.val > high: stack.append(node.left )\\n            else:\\n                ans+= node.val\\n                stack.append(node.left )\\n                stack.append(node.right)\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        def dfs(node):\\n\\n            if not node: return 0\\n\\n            if node.val <  low: return dfs(node.right)\\n            if node.val > high: return dfs(node.left )\\n            \\n            return dfs(node.left ) + dfs(node.right) + node.val\\n\\n        return dfs(root)\\n```\n```\\nclass Solution: \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n\\n        ans, stack = 0, deque([root])\\n\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n\\n            if   node.val <  low: stack.append(node.right)\\n            elif node.val > high: stack.append(node.left )\\n            else:\\n                ans+= node.val\\n                stack.append(node.left )\\n                stack.append(node.right)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548320,
                "title": "c-solution-recursive-6-lines-easy-to-understand",
                "content": "**If the solution helps,please do consider upvoting it.**\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        if(!root)\\n            return 0;\\n       if(root->val>high)\\n           return rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        return root->val +rangeSumBST(root->left,low,high) +rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        if(!root)\\n            return 0;\\n       if(root->val>high)\\n           return rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        return root->val +rangeSumBST(root->left,low,high) +rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535543,
                "title": "java-recursive-and-iterative",
                "content": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0;\\n        if (root.val <= L) return rangeSumBST(root.right, L, R) + (root.val == L ? root.val : 0);\\n        if (root.val >= R) return rangeSumBST(root.left, L, R) + (root.val == R ? root.val : 0);\\n        return rangeSumBST(root.left, L, R) + root.val + rangeSumBST(root.right, L, R);\\n    }\\n```\\n\\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> st = new Stack<>();\\n        st.add(root);\\n        int sum = 0;\\n        while (!st.isEmpty()){\\n            TreeNode n = st.pop();\\n            if (n == null) continue;\\n            if (n.val >= L && n.val <= R) sum += n.val;\\n            if (n.val > L) st.push(n.left);\\n            if (n.val < R) st.push(n.right);\\n        }\\n        return sum;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if (root == null) return 0;\\n        if (root.val <= L) return rangeSumBST(root.right, L, R) + (root.val == L ? root.val : 0);\\n        if (root.val >= R) return rangeSumBST(root.left, L, R) + (root.val == R ? root.val : 0);\\n        return rangeSumBST(root.left, L, R) + root.val + rangeSumBST(root.right, L, R);\\n    }\\n```\n```\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        Stack<TreeNode> st = new Stack<>();\\n        st.add(root);\\n        int sum = 0;\\n        while (!st.isEmpty()){\\n            TreeNode n = st.pop();\\n            if (n == null) continue;\\n            if (n.val >= L && n.val <= R) sum += n.val;\\n            if (n.val > L) st.push(n.left);\\n            if (n.val < R) st.push(n.right);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480659,
                "title": "c-solution",
                "content": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (!root) {\\n        return 0;\\n    }\\n    if(root->val<L){\\n        return rangeSumBST(root->right, L, R);\\n    }\\n    if(root->val>R){\\n        return rangeSumBST(root->left, L, R);\\n    }\\n    return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (!root) {\\n        return 0;\\n    }\\n    if(root->val<L){\\n        return rangeSumBST(root->right, L, R);\\n    }\\n    if(root->val>R){\\n        return rangeSumBST(root->left, L, R);\\n    }\\n    return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885975,
                "title": "easy-java-solution-using-recursion",
                "content": "\\n\\n```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        rangeSum(root,low,high);\\n        return sum;\\n        \\n    }\\n        \\n    public void rangeSum(TreeNode root,int low,int high){\\n        \\n        if(root != null){\\n           \\n        if(low <= root.val && root.val <= high ){\\n            sum +=root.val;\\n        }\\n        if(low < root.val  )\\n            rangeSum(root.left,low,high);\\n\\n        if(root.val <= high )\\n            rangeSum(root.right,low,high);\\n        \\n        \\n    }\\n        \\n    }\\n}\\n```\\n## \\n## Please Upvote if it helped.\\n## Thanks",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        rangeSum(root,low,high);\\n        return sum;\\n        \\n    }\\n        \\n    public void rangeSum(TreeNode root,int low,int high){\\n        \\n        if(root != null){\\n           \\n        if(low <= root.val && root.val <= high ){\\n            sum +=root.val;\\n        }\\n        if(low < root.val  )\\n            rangeSum(root.left,low,high);\\n\\n        if(root.val <= high )\\n            rangeSum(root.right,low,high);\\n        \\n        \\n    }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885967,
                "title": "c-inorder-traversal-intuitive-approach",
                "content": "# Intuition\\nInorder traversal of BST returns nodes in sorted order.\\n\\n# Approach\\nWhile sorting nodes by using inorder traversal, we sum up all the nodes values lies between the range.\\n\\n# Complexity\\n- Time complexity: O(N) \\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void inorder(TreeNode* node, int &low, int &high, int &sum)\\n    {\\n        if(!node) return;\\n        inorder(node->left, low, high, sum);\\n        if(node->val >= low && node->val <= high) sum += node->val;\\n        inorder(node->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum=0;\\n        inorder(root, low, high, sum);\\n        return sum;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void inorder(TreeNode* node, int &low, int &high, int &sum)\\n    {\\n        if(!node) return;\\n        inorder(node->left, low, high, sum);\\n        if(node->val >= low && node->val <= high) sum += node->val;\\n        inorder(node->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        int sum=0;\\n        inorder(root, low, high, sum);\\n        return sum;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021676,
                "title": "python-easy-explanation-2-methods",
                "content": "```\\nPlatform: leetcode.com\\n938. Range Sum of BST\\nLink: https://leetcode.com/problems/range-sum-of-bst/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 17/1/2021\\nSubmission: https://leetcode.com/submissions/detail/444136335/\\n(Time, Space) Complexity : O(n), O(H)\\n\\nRange sum of BST \\n\\n1.  We can solve this problem using recursion and iteration \\n\\niteration                                  Recursion \\n1. implemented using loops                  1. implemented using function calls \\n2. Defined by the control variable          2. Defined by the parameter value in the stack\\nvalue  \\n3. iteration makes size of Code            3. Recursion decreses the size of code\\nbigger                                      \\n4. Loop ends when control variable          4. Recursion ends when base case are True\\nsatisfy the condition \\n5. Infinite loops uses CPU Cycle            5. Infinite Recursion cause stack overflow at particular point or might crash the system\\n6. Execution is faster                      6. Execution is slower\\n```\\n\\n# Method 01 \\n# Inorder traversal ( Left child , Node , Right child)\\n\\n**Disadvantage of using Inorder traversal method**\\n\\n1. Using this approach we are visiting at each node of the binary tree and we are not utilizing the benefit of binary tree.\\n\\n2. Time: O(n), space: O(h), where n is the number of total nodes, h is the height of the tree.\\n\\n\\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\n\\t\\t# Left \\n        self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node \\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\t\\n\\t\\t# Right\\n        self.inOrderTraversal(root.right, low,high,output)\\n\\n```\\n\\nSo what we do when we search a particular number in a binary tree\\n\\nfirst we check if a number is less then a root, if yes then we search in left subtree else if it\\'s greater then we search in right subtree of root node\\n\\nsame here, we see \\n```\\n1. if low < root :\\n\\t\\t inOrderTraversal( root.left, low, high)\\n\\n2. if High > root :\\n\\t\\t inOrderTraversal( root.right, low, high)     \\n```\\n\\n# Method 02 \\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\t\\n\\t\\t# left \\n        if low<root.val:\\n            self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node\\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\n\\t\\t# RIght \\n        if high>root.val:\\n            self.inOrderTraversal(root.right, low,high,output)\\n```\\n\\n# Method 03 \\n## Same Logic but reduction in line of code\\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        total = 0\\n        if root==None:\\n            return 0\\n        if low <= root.val <= high:\\n            total +=root.val\\n        if low<root.val:\\n            total += self.rangeSumBST(root.left, low,high)\\n        if high>root.val:\\n            total += self.rangeSumBST(root.right, low,high)\\n        \\n        return total \\n```\\n\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nPlatform: leetcode.com\\n938. Range Sum of BST\\nLink: https://leetcode.com/problems/range-sum-of-bst/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 17/1/2021\\nSubmission: https://leetcode.com/submissions/detail/444136335/\\n(Time, Space) Complexity : O(n), O(H)\\n\\nRange sum of BST \\n\\n1.  We can solve this problem using recursion and iteration \\n\\niteration                                  Recursion \\n1. implemented using loops                  1. implemented using function calls \\n2. Defined by the control variable          2. Defined by the parameter value in the stack\\nvalue  \\n3. iteration makes size of Code            3. Recursion decreses the size of code\\nbigger                                      \\n4. Loop ends when control variable          4. Recursion ends when base case are True\\nsatisfy the condition \\n5. Infinite loops uses CPU Cycle            5. Infinite Recursion cause stack overflow at particular point or might crash the system\\n6. Execution is faster                      6. Execution is slower\\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\n\\t\\t# Left \\n        self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node \\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\t\\n\\t\\t# Right\\n        self.inOrderTraversal(root.right, low,high,output)\\n\\n```\n```\\n1. if low < root :\\n\\t\\t inOrderTraversal( root.left, low, high)\\n\\n2. if High > root :\\n\\t\\t inOrderTraversal( root.right, low, high)     \\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        output = []\\n        if root==None:\\n            return 0\\n        self.inOrderTraversal(root,low,high,output)\\n        return sum(output) \\n    \\n    def inOrderTraversal(self, root,low,high,output):\\n        if root == None:\\n            return\\n\\t\\t\\t\\n\\t\\t# left \\n        if low<root.val:\\n            self.inOrderTraversal(root.left, low,high,output)\\n\\t\\t\\n\\t\\t# Node\\n        if low <= root.val <= high:\\n            output.append(root.val)\\n\\t\\t\\n\\t\\t# RIght \\n        if high>root.val:\\n            self.inOrderTraversal(root.right, low,high,output)\\n```\n```\\nclass Solution:    \\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        total = 0\\n        if root==None:\\n            return 0\\n        if low <= root.val <= high:\\n            total +=root.val\\n        if low<root.val:\\n            total += self.rangeSumBST(root.left, low,high)\\n        if high>root.val:\\n            total += self.rangeSumBST(root.right, low,high)\\n        \\n        return total \\n```",
                "codeTag": "Java"
            },
            {
                "id": 939761,
                "title": "java-dfs-bfs-with-explanation",
                "content": "**DFS**\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        int sum = root.val <= high && root.val >= low ? root.val : 0;\\n        int left = 0;\\n        int right = 0;\\n        if(root.left != null){\\n            left = rangeSumBST(root.left,low,high);\\n        } \\n        if(root.right != null){\\n            right = rangeSumBST(root.right, low, high);\\n        }\\n        return sum + left + right;\\n    }\\n}\\n```\\n**BFS**\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root); // add root node\\n        int sum = 0;\\n        while(!q.isEmpty()){\\n            int itr = q.size();\\n            while(itr > 0){\\n                TreeNode dummy = q.poll();\\n                sum += (dummy.val >= low && dummy.val <= high) ? dummy.val : 0;\\n                if(dummy.left != null)\\n                    q.add(dummy.left);\\n                if(dummy.right != null)\\n                    q.add(dummy.right);\\n                itr--;\\n            }\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\\n   \\n**PROBLEM OVERVIEW**\\nWe are essentially tasked with finding the sum of all nodes whose values are between the inclusive range [low,high].\\n\\n**SOLUTION ASSESSMENT**\\nThe first things that come to mind are any tree-traversla algorithms (I have an inclination to utilize DFS or BFS, and I will show both approaches)\\n\\n**PSEUDOCODE RECURSION DFS**\\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n1. If(root == null) return 0;\\n2. sum = node.val if within [low,high] : 0;\\n3. int leftSum = rangeSum(node.left,low,high); //left node\\n4. int rightSum = rangeSum(node.right,low,high); //right node\\n5. return sum + leftSum + rightSum\\n}\\n```\\n\\nThe heart of this solution lies with the recursive calls in lines 3-4. It will essentially visit all the nodes in the left branch and* return the leftSum* and all the right nodes in the branch and return the rightSum. Finally, the answer will be the current node + left + right.\\n\\n**PSUEDOCODE ITERATIVE BFS**\\n```\\n1. if root is null return 0; // corner case\\n2. initialize Queue<TreeNode> q and int sum\\n3. add root to q\\n4. while q is not empty {\\n\\t5. itr = q.size() // this is because the current \"size\" is the # of elements in that row\\n\\t6. while itr > 0\\n\\t\\t7. get node from list and add to answer if sum is in range\\n\\t\\t8. add left and right nodes if they exist\\n}\\n9. return sum\\n```\\nIn the BFS solution, the current Queue of TreeNodes is read in FIFO order, so it maintains an order (not that it matters in this problem). \\nThe key steps lie in 5 and 7-8; for 5 regulates the number of iterations in that particular \"row\" of the tree, which is the current size of the Queue. Line 7-8 add the children of that current row in left -> order.\\n\\n**TIME COMPLEXITY**\\nThe code for both runs in O(n) time complexity because it always visits every node.\\nNOTE: even though BFS solution has nested while loops, they are only called a maximum of n times, where n is the number of nodes in the tree.\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        int sum = root.val <= high && root.val >= low ? root.val : 0;\\n        int left = 0;\\n        int right = 0;\\n        if(root.left != null){\\n            left = rangeSumBST(root.left,low,high);\\n        } \\n        if(root.right != null){\\n            right = rangeSumBST(root.right, low, high);\\n        }\\n        return sum + left + right;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null)\\n            return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root); // add root node\\n        int sum = 0;\\n        while(!q.isEmpty()){\\n            int itr = q.size();\\n            while(itr > 0){\\n                TreeNode dummy = q.poll();\\n                sum += (dummy.val >= low && dummy.val <= high) ? dummy.val : 0;\\n                if(dummy.left != null)\\n                    q.add(dummy.left);\\n                if(dummy.right != null)\\n                    q.add(dummy.right);\\n                itr--;\\n            }\\n        }\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n1. If(root == null) return 0;\\n2. sum = node.val if within [low,high] : 0;\\n3. int leftSum = rangeSum(node.left,low,high); //left node\\n4. int rightSum = rangeSum(node.right,low,high); //right node\\n5. return sum + leftSum + rightSum\\n}\\n```\n```\\n1. if root is null return 0; // corner case\\n2. initialize Queue<TreeNode> q and int sum\\n3. add root to q\\n4. while q is not empty {\\n\\t5. itr = q.size() // this is because the current \"size\" is the # of elements in that row\\n\\t6. while itr > 0\\n\\t\\t7. get node from list and add to answer if sum is in range\\n\\t\\t8. add left and right nodes if they exist\\n}\\n9. return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584412,
                "title": "2-javascript-solutions",
                "content": "You need to return sum of values in range of numbers between L and R. Not between nodes of L and R\\n```\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    if(!root) return sum;\\n    if(root.val<=R && root.val>=L)\\n        sum += root.val;\\n    return sum + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n};\\n\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    let stack = [root];\\n    while(stack.length){\\n        let node = stack.pop();\\n        sum+=node.val>=L &&node.val<=R ? node.val : 0;\\n        if(node.left)\\n            stack.push(node.left);\\n        if(node.right)\\n            stack.push(node.right);\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    if(!root) return sum;\\n    if(root.val<=R && root.val>=L)\\n        sum += root.val;\\n    return sum + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n};\\n\\nvar rangeSumBST = function(root, L, R, sum=0) {\\n    let stack = [root];\\n    while(stack.length){\\n        let node = stack.pop();\\n        sum+=node.val>=L &&node.val<=R ? node.val : 0;\\n        if(node.left)\\n            stack.push(node.left);\\n        if(node.right)\\n            stack.push(node.right);\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469046,
                "title": "c-easy-fast-and-understandable",
                "content": "```\\nRuntime: 144 ms, faster than 86.30% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int counter = 0;\\n        \\n        rangeSum(root, counter, L, R);\\n        \\n        return counter;\\n    }\\n    \\n    void rangeSum(TreeNode* root, int& counter, int L, int R){\\n        \\n        if(root->val >= L && root->val <= R){\\n            counter += root->val;\\n        }\\n        if(root->left != NULL){\\n            rangeSum(root->left, counter, L, R);\\n        }\\n        if(root->right != NULL){\\n            rangeSum(root->right, counter, L, R);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nRuntime: 144 ms, faster than 86.30% of C++ online submissions for Range Sum of BST.\\nMemory Usage: 41 MB, less than 100.00% of C++ online submissions for Range Sum of BST.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int counter = 0;\\n        \\n        rangeSum(root, counter, L, R);\\n        \\n        return counter;\\n    }\\n    \\n    void rangeSum(TreeNode* root, int& counter, int L, int R){\\n        \\n        if(root->val >= L && root->val <= R){\\n            counter += root->val;\\n        }\\n        if(root->left != NULL){\\n            rangeSum(root->left, counter, L, R);\\n        }\\n        if(root->right != NULL){\\n            rangeSum(root->right, counter, L, R);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885654,
                "title": "java-runtime-0ms-faster-than-100-recursive-iterative-solutions",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Approach\\nDepth-First Search\\n\\n# Code\\nRecursive Implementation \\n```\\nclass Solution {\\n    private int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (low < root.val) rangeSumBST(root.left, low, high);\\n        if (root.val < high) rangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```\\n\\nIterative Implementation\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        while (!stack.empty()) {\\n            TreeNode current = stack.pop();\\n            if (current == null) continue;\\n            if (current.val >= low && current.val <= high) sum += current.val;\\n            if (low < current.val) stack.push(current.left);\\n            if (current.val < high) stack.push(current.right);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2022-12-07 \\u0432 06.04.34.png](https://assets.leetcode.com/users/images/efd4433e-de08-4faa-ac6d-0e80535a2838_1670382321.6916676.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return sum;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (low < root.val) rangeSumBST(root.left, low, high);\\n        if (root.val < high) rangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        while (!stack.empty()) {\\n            TreeNode current = stack.pop();\\n            if (current == null) continue;\\n            if (current.val >= low && current.val <= high) sum += current.val;\\n            if (low < current.val) stack.push(current.left);\\n            if (current.val < high) stack.push(current.right);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361957,
                "title": "java-short-0ms-solution-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Range Sum of BST.\\nMemory Usage: 67.1 MB, less than 42.28% of Java online submissions for Range Sum of BST.\\n```\\nclass Solution {\\n    int sum = 0;\\n    int lo = 0; // low\\n    int hi = 0; // and high\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        lo = low;\\n        hi = high;\\n        addSum(root);\\n        return sum;\\n    }\\n    \\n    void addSum(TreeNode root) {\\n        if (root == null) return;\\n        if (root.val >= lo && root.val <= hi) { // if the root value is in the range\\n            sum += root.val; // add to sum\\n            addSum(root.left); // left\\n            addSum(root.right); // right\\n        } else if (root.val < lo) addSum(root.right); // if the root value is too small\\n        else addSum(root.left); // if the root value is too big\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    int lo = 0; // low\\n    int hi = 0; // and high\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        lo = low;\\n        hi = high;\\n        addSum(root);\\n        return sum;\\n    }\\n    \\n    void addSum(TreeNode root) {\\n        if (root == null) return;\\n        if (root.val >= lo && root.val <= hi) { // if the root value is in the range\\n            sum += root.val; // add to sum\\n            addSum(root.left); // left\\n            addSum(root.right); // right\\n        } else if (root.val < lo) addSum(root.right); // if the root value is too small\\n        else addSum(root.left); // if the root value is too big\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628151,
                "title": "daily-leetcoding-challenge-14-december-2021",
                "content": "**Solution in c++**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(!root) return 0;\\n        int sum = 0;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        return sum + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n\\n    }\\n};\\n```\\n**if you understand solution then dont forget to upvote**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(!root) return 0;\\n        int sum = 0;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        return sum + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227687,
                "title": "c-easy-to-understand-iterative-o-n-time-complexity",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)\\n        return 0;\\n        int sum=0;\\n        if(root->val<=high&&root->val>=low)\\n        {\\n            sum+=root->val;\\n        }\\n        if(root->val>high)\\n        {\\n            sum+=rangeSumBST(root->left,low,high);\\n        }\\n        else if(root->val<low)\\n        {\\n            sum+=rangeSumBST(root->right,low,high);\\n        }\\n        else\\n        {\\n            sum+=rangeSumBST(root->right,low,high)+rangeSumBST(root->left,low,high);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)\\n        return 0;\\n        int sum=0;\\n        if(root->val<=high&&root->val>=low)\\n        {\\n            sum+=root->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 936934,
                "title": "c-python-in-order-bst-traverse",
                "content": "```\\nclass Solution { // DFS: in-order traverse\\npublic: // Time/Space Complexity: O(N); O(N)\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> nums;\\n        dfs(root, nums);\\n        int ans = 0;\\n        for(auto e: nums) \\n            if(e >= low && e <=high) ans += e;\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root) return;\\n        dfs(root->left, nums);\\n        nums.push_back(root->val);\\n        dfs(root->right, nums);\\n    }\\n};\\n```\\n\\nApproach 2(python)\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def dfs(root):\\n            if root:\\n                dfs(root.left)\\n                nums.append(root.val)\\n                dfs(root.right)\\n        \\n        nums=[]\\n        dfs(root)\\n        running_sum = list(itertools.accumulate(nums))\\n        left = max(bisect.bisect_left(nums, low)-1, 0)\\n        right = min(bisect.bisect_left(nums, high), len(nums) - 1)                \\n        return running_sum[right] - running_sum[left]\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution { // DFS: in-order traverse\\npublic: // Time/Space Complexity: O(N); O(N)\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> nums;\\n        dfs(root, nums);\\n        int ans = 0;\\n        for(auto e: nums) \\n            if(e >= low && e <=high) ans += e;\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root) return;\\n        dfs(root->left, nums);\\n        nums.push_back(root->val);\\n        dfs(root->right, nums);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        \\n        def dfs(root):\\n            if root:\\n                dfs(root.left)\\n                nums.append(root.val)\\n                dfs(root.right)\\n        \\n        nums=[]\\n        dfs(root)\\n        running_sum = list(itertools.accumulate(nums))\\n        left = max(bisect.bisect_left(nums, low)-1, 0)\\n        right = min(bisect.bisect_left(nums, high), len(nums) - 1)                \\n        return running_sum[right] - running_sum[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572265,
                "title": "js-fast-and-simple-solution",
                "content": "\\n\\n```js\\nvar rangeSumBST = function(root, L, R) {\\n    if(!root)return 0  \\n    let v = (root.val <= R && root.val >= L)? root.val : 0\\n    return v + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nvar rangeSumBST = function(root, L, R) {\\n    if(!root)return 0  \\n    let v = (root.val <= R && root.val >= L)? root.val : 0\\n    return v + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 284771,
                "title": "javascript-recursive-solution",
                "content": "```\\nconst rangeSumBST = (root, L, R) => {\\n\\tif (root === null) {\\n  \\t    return 0;\\n    }    \\n\\n    return (root.val >= L && root.val <= R ? root.val : 0) + rangeSumBST(root.left, L , R) + rangeSumBST(root.right, L , R);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nconst rangeSumBST = (root, L, R) => {\\n\\tif (root === null) {\\n  \\t    return 0;\\n    }    \\n\\n    return (root.val >= L && root.val <= R ? root.val : 0) + rangeSumBST(root.left, L , R) + rangeSumBST(root.right, L , R);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213098,
                "title": "rust-recursive-solution",
                "content": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, l: i32, r: i32) -> i32 {\\n        if let Some(root) = root {\\n            let mut sum = 0;\\n            if l <= root.borrow().val && root.borrow().val <=r {\\n                sum += root.borrow().val;\\n            }\\n            \\n            if l < root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().left.clone(), l, r);\\n            }\\n            \\n            if r > root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().right.clone(), l, r);\\n            }\\n            return sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, l: i32, r: i32) -> i32 {\\n        if let Some(root) = root {\\n            let mut sum = 0;\\n            if l <= root.borrow().val && root.borrow().val <=r {\\n                sum += root.borrow().val;\\n            }\\n            \\n            if l < root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().left.clone(), l, r);\\n            }\\n            \\n            if r > root.borrow().val {\\n                sum += Self::range_sum_bst(root.borrow().right.clone(), l, r);\\n            }\\n            return sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459881,
                "title": "my-rangesumbst",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum=0;\\n\\n    if(root){\\n        sum+=(root.val>=low&&root.val<=high)?root.val:0;\\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum=0;\\n\\n    if(root){\\n        sum+=(root.val>=low&&root.val<=high)?root.val:0;\\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887527,
                "title": "java-100-solution-range-sum-of-bst",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return sum;\\n        if(root.val>=low && root.val<=high)\\n            sum+=root.val;\\n        \\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return sum;\\n        if(root.val>=low && root.val<=high)\\n            sum+=root.val;\\n        \\n        sum+=rangeSumBST(root.left,low,high);\\n        sum+=rangeSumBST(root.right,low,high);\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886299,
                "title": "python-97-84-faster-explained-line-by-line-recursive-solution",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\t    s = 0 # answer is zero initially\\n\\t    if root: # if we have a root\\n\\t\\t    if low <= root.val <= high: # if in the right range\\n\\t\\t\\t    s += root.val \\n            # if the root is in the range [low, high]\\n\\t\\t    if low <= root.val: \\n\\t\\t\\t    s += self.rangeSumBST(root.left,low,high) # add nodes to the left sub tree\\n\\t\\t    if root.val <= high: \\n\\t\\t\\t    s += self.rangeSumBST(root.right,low,high) # add nodes to the right sub tree\\n\\t    return s\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\t    s = 0 # answer is zero initially\\n\\t    if root: # if we have a root\\n\\t\\t    if low <= root.val <= high: # if in the right range\\n\\t\\t\\t    s += root.val \\n            # if the root is in the range [low, high]\\n\\t\\t    if low <= root.val: \\n\\t\\t\\t    s += self.rangeSumBST(root.left,low,high) # add nodes to the left sub tree\\n\\t\\t    if root.val <= high: \\n\\t\\t\\t    s += self.rangeSumBST(root.right,low,high) # add nodes to the right sub tree\\n\\t    return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886158,
                "title": "easy-explained-recursion-optimized-2-line-code-cpp",
                "content": "# Approach\\nWe are doing regular tree traversal and adding values within [L, R]. Note that in the solution description, we are given BST, however, this solution works for any binary tree.\\n\\n# CPP Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic://Thanks to Bhalerao-2002\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;//If tree is not Exist \\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R)/*For Left Side traversal of BST*/ + rangeSumBST(root->right, L, R)/*For Right Side traversal of BST*/;\\n}\\n};\\n```\\n# Upvote If it Helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic://Thanks to Bhalerao-2002\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n  if (root == nullptr) return 0;//If tree is not Exist \\n  return (root->val >= L && root->val <= R ? root->val : 0) +\\n    rangeSumBST(root->left, L, R)/*For Left Side traversal of BST*/ + rangeSumBST(root->right, L, R)/*For Right Side traversal of BST*/;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885461,
                "title": "97-27-fast-javascript-very-easy-to-understand-solution",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let iterate = (node=root) =>{\\n        if(!node) return;\\n\\n        iterate(node.left)\\n\\n        if(node.val>=low && node.val<=high) sum += node.val;\\n\\n        iterate(node.right)\\n    }\\n\\n    iterate()\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let iterate = (node=root) =>{\\n        if(!node) return;\\n\\n        iterate(node.left)\\n\\n        if(node.val>=low && node.val<=high) sum += node.val;\\n\\n        iterate(node.right)\\n    }\\n\\n    iterate()\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885377,
                "title": "c-easy-to-understand-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Case-1** : If currVal is in range [>=low && <= high] \\n         Then **traverse both** the left and right subtree\\n\\n**Case-2 :** If [currVal <= low] \\nThen traverse only the right subtree\\n\\n**Case-3 :** If [currVal >= high]\\nThen traverse only the left subtree\\n        \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* curr, int& low, int& high)\\n    {\\n        if (curr == NULL) return 0;\\n        \\n        int ans = 0;\\n        bool isInRange = false;\\n        if (curr->val >= low && curr->val <= high) \\n        {\\n            isInRange = true;\\n            ans += curr->val;\\n        }\\n        \\n        if (isInRange || (curr->val <= low)) ans += solve(curr->right, low, high);\\n        if (isInRange || (curr->val >= high)) ans += solve(curr->left, low, high);\\n        return ans;\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        return solve(root, low, high);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* curr, int& low, int& high)\\n    {\\n        if (curr == NULL) return 0;\\n        \\n        int ans = 0;\\n        bool isInRange = false;\\n        if (curr->val >= low && curr->val <= high) \\n        {\\n            isInRange = true;\\n            ans += curr->val;\\n        }\\n        \\n        if (isInRange || (curr->val <= low)) ans += solve(curr->right, low, high);\\n        if (isInRange || (curr->val >= high)) ans += solve(curr->left, low, high);\\n        return ans;\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n        return solve(root, low, high);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508766,
                "title": "python-elegant-short-recursive-three-lines",
                "content": "\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        return self.rangeSumBST(root.left, low, high) + \\\\\\n               self.rangeSumBST(root.right, low, high) + \\\\\\n               root.val * (low <= root.val <= high)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        return self.rangeSumBST(root.left, low, high) + \\\\\\n               self.rangeSumBST(root.right, low, high) + \\\\\\n               root.val * (low <= root.val <= high)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2369507,
                "title": "c-two-solutions-recursion-and-queue",
                "content": "Apporach 1: \\nUsing Inorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n       if(root==NULL)\\n        {\\n            return sum;\\n        }\\n        rangeSumBST(root->left,low,high);\\n         if(root->val>high){\\n            return sum;\\n        }\\n        if(root->val>=low&&root->val<=high)\\n        {\\n            sum=sum+root->val;\\n        }\\n       rangeSumBST(root->right,low,high);\\n        return sum;\\n    }\\n};\\n```\\n\\nApproach 2:\\nUsing Queue and property of BST:\\nExplaination :\\n1. Take a Queue data structure and push root to it;\\n2. If node->val is in the range then both the subtrees can be in the range so we w\\'ll add both left and right child : node->right and node->right to the queue.\\n3. If the node->val is lower than (low) ,the left subtree will also be smaller than (low) but there is a possibility that its right child can be in the range , so we\\'ll eliminate left subtree and add node->right to the queue.\\n4. If the node->val is greater than (high),the rightt subtree will also be greater than (low) ,but  there is a possibility that its leftt child can be in the range , so we\\'ll eliminate right subtree and add node->right to the queue.\\n**CODE**\\n```\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)return 0;\\n    int sum =0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n          TreeNode* node=q.front();\\n            q.pop();\\n            if(node->val<low)\\n            {\\n                if(node->right!=NULL)q.push(node->right);\\n            }\\n            else if(node->val >high && node->left!=NULL){\\n                q.push(node->left);                \\n            }\\n            else if(node->val>=low && node->val <=high){\\n                sum+=(node->val);\\n                if(node->left!=NULL)q.push(node->left);\\n                if(node->right!=NULL)q.push(node->right);\\n            } \\n        }\\n        return sum;\\n    }\\n\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n       if(root==NULL)\\n        {\\n            return sum;\\n        }\\n        rangeSumBST(root->left,low,high);\\n         if(root->val>high){\\n            return sum;\\n        }\\n        if(root->val>=low&&root->val<=high)\\n        {\\n            sum=sum+root->val;\\n        }\\n       rangeSumBST(root->right,low,high);\\n        return sum;\\n    }\\n};\\n```\n```\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root==NULL)return 0;\\n    int sum =0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n          TreeNode* node=q.front();\\n            q.pop();\\n            if(node->val<low)\\n            {\\n                if(node->right!=NULL)q.push(node->right);\\n            }\\n            else if(node->val >high && node->left!=NULL){\\n                q.push(node->left);                \\n            }\\n            else if(node->val>=low && node->val <=high){\\n                sum+=(node->val);\\n                if(node->left!=NULL)q.push(node->left);\\n                if(node->right!=NULL)q.push(node->right);\\n            } \\n        }\\n        return sum;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943473,
                "title": "python-recursive-memory-usage-less-than-93",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        suma = 0\\n        def search(node):\\n            nonlocal suma\\n            if node:\\n                if node.val <= high and node.val >=low:\\n                    suma+=node.val\\n                search(node.left)\\n                search(node.right)\\n        search(root)\\n        return(suma)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        suma = 0\\n        def search(node):\\n            nonlocal suma\\n            if node:\\n                if node.val <= high and node.val >=low:\\n                    suma+=node.val\\n                search(node.left)\\n                search(node.right)\\n        search(root)\\n        return(suma)",
                "codeTag": "Java"
            },
            {
                "id": 1628957,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void fun(TreeNode* root, int low, int high){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val<low){\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>=low && root->val<=high){\\n            res+=root->val;\\n            fun(root->left,low, high);\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>high){\\n            fun(root->left,low, high);\\n        }\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        fun(root, low, high);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void fun(TreeNode* root, int low, int high){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val<low){\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>=low && root->val<=high){\\n            res+=root->val;\\n            fun(root->left,low, high);\\n            fun(root->right,low, high);\\n        }\\n        if(root->val>high){\\n            fun(root->left,low, high);\\n        }\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        fun(root, low, high);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628367,
                "title": "c-super-simple-and-easy-recursive-solution",
                "content": "We iterate through the entire tree.\\nFor every node, if its value is within the range, we add it to `res`.\\n```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res += root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res += root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434547,
                "title": "c-solution-91-faster-recursion",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val >= low && root->val <= high){\\n\\t\\t\\t\\tsum+=root->val;\\n\\t\\t\\t}\\n\\t\\t\\trangeSumBST(root->left,low,high);\\n\\t\\t\\trangeSumBST(root->right,low,high);\\n\\n\\t\\t\\treturn sum;\\n\\n\\n\\t\\t}\\n\\n\\t};\\n\\t\\n**\\tPlease upvote if it helped. **",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1387035,
                "title": "easy-recursive-python3-solution-faster-than-99",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        s = 0\\n        def explore(root, low, high):\\n            nonlocal s\\n            if low<=root.val<=high:\\n                s += root.val\\n            if root.left and low<root.val:\\n                explore(root.left, low, high)\\n            if root.right and high>=root.val:\\n                explore(root.right, low, high)\\n        explore(root, low, high)\\n        return s\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\\n        s = 0\\n        def explore(root, low, high):\\n            nonlocal s\\n            if low<=root.val<=high:\\n                s += root.val\\n            if root.left and low<root.val:\\n                explore(root.left, low, high)\\n            if root.right and high>=root.val:\\n                explore(root.right, low, high)\\n        explore(root, low, high)\\n        return s\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1011277,
                "title": "rust-treenode-implementation-could-be-simplified",
                "content": "Current TreeNode in rust looks like that \\n```\\npub struct TreeNode {\\n   pub val: i32,\\n   pub left: Option<Rc<RefCell<TreeNode>>>,\\n   pub right: Option<Rc<RefCell<TreeNode>>>,\\n }\\n ```\\n But since each node in tree has only one owner it could be simplified to \\n ```\\npub struct TreeNode {\\n    pub val: i32,\\n    pub left: Option<Box<TreeNode>>,\\n    pub right: Option<Box<TreeNode>>,\\n}\\n```\\nHow does it help ?\\n1. It will work faster since we don\\'t do reference counting. So compared to current 12-20 ms we will get  better results for rust.\\n2. Code to build tree becomes simpler.\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct TreeNode {\\n   pub val: i32,\\n   pub left: Option<Rc<RefCell<TreeNode>>>,\\n   pub right: Option<Rc<RefCell<TreeNode>>>,\\n }\\n ```\n```\\npub struct TreeNode {\\n    pub val: i32,\\n    pub left: Option<Box<TreeNode>>,\\n    pub right: Option<Box<TreeNode>>,\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936564,
                "title": "simple-dfs-solution-java",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int[] res = new int[1];\\n        dfs(root, low, high, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode root, int low, int high, int[] sum){\\n        if(root == null) return;\\n        if(root.val <= high && root.val >= low) sum[0] += root.val;\\n        dfs(root.left, low, high, sum);\\n        dfs(root.right, low, high, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int[] res = new int[1];\\n        dfs(root, low, high, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode root, int low, int high, int[] sum){\\n        if(root == null) return;\\n        if(root.val <= high && root.val >= low) sum[0] += root.val;\\n        dfs(root.left, low, high, sum);\\n        dfs(root.right, low, high, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936292,
                "title": "c-super-simple-recursive-easiest-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res+=root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root, int low, int high) {\\n        if (!root) return;\\n        if (root->val <= high && root->val >= low) res+=root->val;\\n        rec(root->left, low, high);\\n        rec(root->right, low, high);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        rec(root, low, high);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838391,
                "title": "brute-force-solution-optimal-solution-in-c",
                "content": "Brute-force solution is quite obvious, simply DFS the tree and add the current node value aslong as its in range L<-->R\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l) (*res)+=root->val;\\n    if(root->left) dfs(root->left,l,r,res);\\n    if(root->right)dfs(root->right,l,r,res);\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\\n\\na more optimal solution is to check if the current node value is not in range of L<--->R then check if its lower than L or higher than R,\\nif its higher than R we need to check the left subtree(lower value elements).\\nelse if its lower than L we need to check the right subtree(higher value elements).\\nthus we reduce the traversal time on the tree\\ncode :\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l){\\n       (*res)+=root->val; \\n    if(root->left)  dfs(root->left,l,r,res);\\n    if(root->right) dfs(root->right,l,r,res);\\n    \\n    } \\n    else if(root->val>r) {\\n        if(root->left) dfs(root->left,l,r,res);\\n    }\\n    else if(root->val<l)if(root->right) dfs(root->right,l,r,res);\\n\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l) (*res)+=root->val;\\n    if(root->left) dfs(root->left,l,r,res);\\n    if(root->right)dfs(root->right,l,r,res);\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid dfs(struct TreeNode* root,int l,int r,int *res) {\\n    if(root->val <=r && root->val >=l){\\n       (*res)+=root->val; \\n    if(root->left)  dfs(root->left,l,r,res);\\n    if(root->right) dfs(root->right,l,r,res);\\n    \\n    } \\n    else if(root->val>r) {\\n        if(root->left) dfs(root->left,l,r,res);\\n    }\\n    else if(root->val<l)if(root->right) dfs(root->right,l,r,res);\\n\\n}\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    int res = 0;\\n    dfs(root,L,R,&res);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 813295,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        return ((root.val >= L && root.val <= R) ? root.val : 0) + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return 0;\\n        return ((root.val >= L && root.val <= R) ? root.val : 0) + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783846,
                "title": "c-optimized-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root == NULL) return 0;\\n        if(root->val<L) return rangeSumBST(root->right,L,R);\\n        else if(root->val>R) return rangeSumBST(root->left,L,R);\\n\\n        int ans = root->val;\\n        ans+= rangeSumBST(root->left,L,R);\\n        ans+= rangeSumBST(root->right,L,R);      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root == NULL) return 0;\\n        if(root->val<L) return rangeSumBST(root->right,L,R);\\n        else if(root->val>R) return rangeSumBST(root->left,L,R);\\n\\n        int ans = root->val;\\n        ans+= rangeSumBST(root->left,L,R);\\n        ans+= rangeSumBST(root->right,L,R);      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770913,
                "title": "sweet-short-recursive-c-solution-97-21",
                "content": "```\\nclass Solution {\\npublic:\\n  int rangeSumBST(TreeNode* root, int L, int R) {\\n    if(!root) return 0;\\n\\t// to save time we will only go to the left when we are not sure what lies on the left\\n\\t// in simple words, if the current root->val == L then there is no need to go to the left\\n\\t// because it is guaranteed all the values would be smaller than L\\n\\t// similarly for right too\\n    return ((root->val > L) ? rangeSumBST(root->left, L, R) : 0) + \\n\\t\\t   ((root->val < R) ? rangeSumBST(root->right, L, R) : 0) + \\n\\t\\t   ((root->val <= R && root->val >= L) ? root->val : 0);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int rangeSumBST(TreeNode* root, int L, int R) {\\n    if(!root) return 0;\\n\\t// to save time we will only go to the left when we are not sure what lies on the left\\n\\t// in simple words, if the current root->val == L then there is no need to go to the left\\n\\t// because it is guaranteed all the values would be smaller than L\\n\\t// similarly for right too\\n    return ((root->val > L) ? rangeSumBST(root->left, L, R) : 0) + \\n\\t\\t   ((root->val < R) ? rangeSumBST(root->right, L, R) : 0) + \\n\\t\\t   ((root->val <= R && root->val >= L) ? root->val : 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739437,
                "title": "javascript-dfs",
                "content": "```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = 0){\\n  if(!root) return 0;\\n  if(root.val >= L && root.val <= R ){\\n    res = root.val;\\n  }\\n  return res + dfs(root.left, L, R) + dfs(root.right, L, R)\\n}\\n```\\n\\nAnother DFS option:\\n\\n```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = {total : 0}){\\n  if(!root) return res;\\n  if(root.val >= L && root.val <= R ){\\n    res.total += root.val;\\n  }\\n  dfs(root.left, L, R, res)\\n  dfs(root.right, L, R, res)\\n  return res.total;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = 0){\\n  if(!root) return 0;\\n  if(root.val >= L && root.val <= R ){\\n    res = root.val;\\n  }\\n  return res + dfs(root.left, L, R) + dfs(root.right, L, R)\\n}\\n```\n```\\nvar rangeSumBST = function(root, L, R) {\\n  return dfs(root, L, R)\\n};\\n\\nfunction dfs(root, L, R, res = {total : 0}){\\n  if(!root) return res;\\n  if(root.val >= L && root.val <= R ){\\n    res.total += root.val;\\n  }\\n  dfs(root.left, L, R, res)\\n  dfs(root.right, L, R, res)\\n  return res.total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515506,
                "title": "intuitive-python-solution",
                "content": "I saw some inorder solutions for python , but like any other recursion problem, I like to just break it down into two parts:\\ni) recursive part.\\nii) base case to terminate recursion.\\n\\nBase case is trivial:\\n```\\nif not root:\\n  return 0\\n```\\n\\nCase I\\n```\\nif root.val > R \\n\\tans = self.rangeSum(root.left, L,R)\\n```\\nCase II\\n```\\nif root.val < L:\\n\\tans = self.rangeSum(root.right, L, R)\\n```\\nCase III\\nwhen root value lies in between\\n```\\n\\tans = root.val + self.rangeSum(root.left, L, R) + self.rangeSum(root.right, L, R)\\n```\\n\\nFull code beats 98%\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        total = 0\\n        if root.val > R:\\n            total = self.rangeSumBST(root.left, L, R)\\n        elif root.val < L :\\n            total = self.rangeSumBST(root.right, L, R)\\n        else:\\n            total = root.val + self.rangeSumBST(root.left, L, R) \\\\\\n            + self.rangeSumBST(root.right, L, R)\\n        return total\\n```\\n\\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nif not root:\\n  return 0\\n```\n```\\nif root.val > R \\n\\tans = self.rangeSum(root.left, L,R)\\n```\n```\\nif root.val < L:\\n\\tans = self.rangeSum(root.right, L, R)\\n```\n```\\n\\tans = root.val + self.rangeSum(root.left, L, R) + self.rangeSum(root.right, L, R)\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n        if not root:\\n            return 0\\n        total = 0\\n        if root.val > R:\\n            total = self.rangeSumBST(root.left, L, R)\\n        elif root.val < L :\\n            total = self.rangeSumBST(root.right, L, R)\\n        else:\\n            total = root.val + self.rangeSumBST(root.left, L, R) \\\\\\n            + self.rangeSumBST(root.right, L, R)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500831,
                "title": "java-beats-100-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n    \\n        if(root==null)\\n        return 0;\\n    \\n        else if(L<=root.val&&root.val<=R)\\n        return rangeSumBST(root.left,L,R)+rangeSumBST(root.right,L,R)+root.val;\\n    \\n        else if(L>root.val)\\n        return rangeSumBST(root.right,L,R);\\n    \\n        else \\n        return rangeSumBST(root.left,L,R);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n    \\n        if(root==null)\\n        return 0;\\n    \\n        else if(L<=root.val&&root.val<=R)\\n        return rangeSumBST(root.left,L,R)+rangeSumBST(root.right,L,R)+root.val;\\n    \\n        else if(L>root.val)\\n        return rangeSumBST(root.right,L,R);\\n    \\n        else \\n        return rangeSumBST(root.left,L,R);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384415,
                "title": "c-solution",
                "content": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (root == NULL)\\n        return 0;\\n    else if (root->val >= L && root->val <= R)\\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    else\\n        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeSumBST(struct TreeNode* root, int L, int R){\\n    if (root == NULL)\\n        return 0;\\n    else if (root->val >= L && root->val <= R)\\n        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n    else\\n        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290385,
                "title": "c-short-solution",
                "content": "```\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(nullptr == root) return 0;\\n        int sum = 0;\\n        if(root->val >= L && root->val <= R) sum += root->val;\\n        if(root->val <= R) sum += rangeSumBST(root->right, L, R);\\n        if(root->val >= L) sum += rangeSumBST(root->left, L, R);\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(nullptr == root) return 0;\\n        int sum = 0;\\n        if(root->val >= L && root->val <= R) sum += root->val;\\n        if(root->val <= R) sum += rangeSumBST(root->right, L, R);\\n        if(root->val >= L) sum += rangeSumBST(root->left, L, R);\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260017,
                "title": "swift",
                "content": "\\n```\\nclass Solution {\\n    func rangeSumBST(_ root: TreeNode?, _ L: Int, _ R: Int) -> Int {\\n        var sum = 0\\n        guard let node = root else { return sum }\\n        if L <= node.val &&  node.val <= R {\\n            sum += node.val\\n        }\\n        if L < node.val {\\n            sum = sum + rangeSumBST(node.left, L, R)\\n        }\\n        if node.val < R {\\n            sum = sum + rangeSumBST(node.right, L, R)\\n        }\\n\\n        return sum\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rangeSumBST(_ root: TreeNode?, _ L: Int, _ R: Int) -> Int {\\n        var sum = 0\\n        guard let node = root else { return sum }\\n        if L <= node.val &&  node.val <= R {\\n            sum += node.val\\n        }\\n        if L < node.val {\\n            sum = sum + rangeSumBST(node.left, L, R)\\n        }\\n        if node.val < R {\\n            sum = sum + rangeSumBST(node.right, L, R)\\n        }\\n\\n        return sum\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194047,
                "title": "medium-i-don-t-think-so",
                "content": "No way this is medium, all the test cases pass without even adding the early termination condition. \\n```\\n    public int rangeSumBST(TreeNode root, int l, int r) {\\n    \\tStack<TreeNode> s = new Stack<>();\\n    \\ts.add(root);\\n    \\tint sum = 0;\\n    \\twhile(!s.isEmpty()) {\\n    \\t\\tTreeNode n = s.pop();\\n    \\t\\tif(n != null) {\\n        \\t\\tif(n.val >= l && n.val <= r) {\\n        \\t\\t\\tsum += n.val;\\n        \\t\\t}\\n        \\t\\tif(n.val > l) s.add(n.left);\\n        \\t\\tif(n.val < r) s.add(n.right); \\n    \\t\\t}  \\t\\t\\n    \\t}\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int rangeSumBST(TreeNode root, int l, int r) {\\n    \\tStack<TreeNode> s = new Stack<>();\\n    \\ts.add(root);\\n    \\tint sum = 0;\\n    \\twhile(!s.isEmpty()) {\\n    \\t\\tTreeNode n = s.pop();\\n    \\t\\tif(n != null) {\\n        \\t\\tif(n.val >= l && n.val <= r) {\\n        \\t\\t\\tsum += n.val;\\n        \\t\\t}\\n        \\t\\tif(n.val > l) s.add(n.left);\\n        \\t\\tif(n.val < r) s.add(n.right); \\n    \\t\\t}  \\t\\t\\n    \\t}\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192875,
                "title": "simple-recursive-c-code-beats-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if (root ==NULL){return 0;}\\n        else if (root->val > R)\\n            return rangeSumBST(root->left, L,R);\\n        else if (root->val < L)\\n            return rangeSumBST(root->right, L,R);\\n        else\\n            return root->val+rangeSumBST(root->left,L,root->val)+rangeSumBST(root->right, root->val,R);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if (root ==NULL){return 0;}\\n        else if (root->val > R)\\n            return rangeSumBST(root->left, L,R);\\n        else if (root->val < L)\\n            return rangeSumBST(root->right, L,R);\\n        else\\n            return root->val+rangeSumBST(root->left,L,root->val)+rangeSumBST(root->right, root->val,R);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994954,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923247,
                "title": "easy-java-solution-for-beginners-binary-tree-concept-no-bst",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            sum += rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            sum += rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(root.val >= low && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            sum += rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            sum += rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013606,
                "title": "very-easy-to-understand-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum=0; \\n        if(root==NULL) return 0;\\n\\n        int l=rangeSumBST(root->left,low,high);\\n        int r=rangeSumBST(root->right,low,high);\\n\\n        sum=l+r;\\n\\n        if(root->val >= low && root->val <= high){\\n            sum+=root->val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum=0; \\n        if(root==NULL) return 0;\\n\\n        int l=rangeSumBST(root->left,low,high);\\n        int r=rangeSumBST(root->right,low,high);\\n\\n        sum=l+r;\\n\\n        if(root->val >= low && root->val <= high){\\n            sum+=root->val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892550,
                "title": "c-easy-4-lines-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t//time: O(less than total nodes) i.e bcz we are moving on nodes in range[low,high], space: O(height)\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root == NULL) return 0;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tif(root->val >= low && root->val <= high)  sum += root->val;\\n\\t\\t\\tif(root->val >= low)  sum += rangeSumBST(root->left, low, high); //travel on left child\\n\\t\\t\\tif(root->val <= high)   sum += rangeSumBST(root->right, low, high); //travel on right child\\n\\t\\t\\treturn sum;\\n\\t   }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//time: O(less than total nodes) i.e bcz we are moving on nodes in range[low,high], space: O(height)\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root == NULL) return 0;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tif(root->val >= low && root->val <= high)  sum += root->val;\\n\\t\\t\\tif(root->val >= low)  sum += rangeSumBST(root->left, low, high); //travel on left child\\n\\t\\t\\tif(root->val <= high)   sum += rangeSumBST(root->right, low, high); //travel on right child\\n\\t\\t\\treturn sum;\\n\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 2886868,
                "title": "simple-tree-traversal",
                "content": "# Code\\n```\\n=class Solution \\n{\\n    private:\\n        int sum=0;\\n\\n    public:\\n        void treeTraversal(TreeNode* root, int low, int high)\\n        {\\n            if(root)\\n            {\\n                treeTraversal(root->left, low, high);\\n\\n                if(root->val >= low && root->val <= high)\\n                {\\n                    sum += root->val;\\n                }\\n\\n                treeTraversal(root->right, low, high);\\n            }\\n        }\\n\\n        int rangeSumBST(TreeNode* root, int low, int high)\\n        {\\n            treeTraversal(root, low, high);\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n=class Solution \\n{\\n    private:\\n        int sum=0;\\n\\n    public:\\n        void treeTraversal(TreeNode* root, int low, int high)\\n        {\\n            if(root)\\n            {\\n                treeTraversal(root->left, low, high);\\n\\n                if(root->val >= low && root->val <= high)\\n                {\\n                    sum += root->val;\\n                }\\n\\n                treeTraversal(root->right, low, high);\\n            }\\n        }\\n\\n        int rangeSumBST(TreeNode* root, int low, int high)\\n        {\\n            treeTraversal(root, low, high);\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886354,
                "title": "java-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H), where H is the height of the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        ans = 0;\\n        dfs(root, L, R);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node, int L, int R) {\\n        if (node != null) {\\n            if (L <= node.val && node.val <= R)\\n                ans += node.val;\\n            if (L < node.val)\\n                dfs(node.left, L, R);\\n            if (node.val < R)\\n                dfs(node.right, L, R);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        ans = 0;\\n        dfs(root, L, R);\\n        return ans;\\n    }\\n\\n    public void dfs(TreeNode node, int L, int R) {\\n        if (node != null) {\\n            if (L <= node.val && node.val <= R)\\n                ans += node.val;\\n            if (L < node.val)\\n                dfs(node.left, L, R);\\n            if (node.val < R)\\n                dfs(node.right, L, R);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885832,
                "title": "java-solution-0ms-beats-100",
                "content": "\\n```\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        if(root.val > high) return rangeSumBST(root.left, low, high);\\n        if(root.val < low) return rangeSumBST(root.right, low, high);\\n        return root.val + rangeSumBST(root.left, low,high) + rangeSumBST(root.right, low, high); \\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        if(root.val > high) return rangeSumBST(root.left, low, high);\\n        if(root.val < low) return rangeSumBST(root.right, low, high);\\n        return root.val + rangeSumBST(root.left, low,high) + rangeSumBST(root.right, low, high); \\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885646,
                "title": "easy-and-faster-than-98-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf Explainatory Code.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHopeYou Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for recursion stack space\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0; // Initialised Sum\\n    void Traversal(TreeNode* root,int low,int high)\\n    {\\n        if(root==NULL) // If Node is NULL then we return \\n        return;\\n        Traversal(root->left,low,high); // To check for left Node\\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\\n        Traversal(root->right,low,high); // To check for right Node\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr); // To make input output fast\\n        Traversal(root,low,high); //To Traverse in BST\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0; // Initialised Sum\\n    void Traversal(TreeNode* root,int low,int high)\\n    {\\n        if(root==NULL) // If Node is NULL then we return \\n        return;\\n        Traversal(root->left,low,high); // To check for left Node\\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\\n        Traversal(root->right,low,high); // To check for right Node\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr); // To make input output fast\\n        Traversal(root,low,high); //To Traverse in BST\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2349128,
                "title": "range-sum-of-bst-by-using-inorder",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    void inorder(TreeNode*root, vector<int>&v){\\n        if(root==NULL) return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n        \\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        inorder(root, v);\\n        int sum=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low  && v[i]<=high){\\n               sum+=v[i]; \\n            }\\n        }\\n        return sum;\\n    }\\n}; \\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode*root, vector<int>&v){\\n        if(root==NULL) return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1903109,
                "title": "faster-than-100-solution-java-algorithm",
                "content": "hello Leetcoder, hope you are well\\n\\nYpu are reading this means you want to konw other apporach or you are stuck in this problem, so\\nLet me help you\\n\\n**Problem Understanding**\\nThis problem is saying basically you have a Binary Search Tree and a range [low, high], you have to traverse through the BST and find all nodes which lies between the range and calculate sum of those nodes.\\n\\nNow think about BST property : we will use the this property to calculate the sum between range [low, high].\\n\\t* \\tLeft child\\'s root.data  < root.data\\n\\t* \\tright child\\'s root.data > root.data\\n![image](https://assets.leetcode.com/users/images/0893e510-f313-49b9-80a3-08b1fe050737_1648806799.7505903.png)\\n\\n**According to the above rule we can say this**\\n```\\n\\troot.val < low \\n\\t\\tWe don\\'t have to traverse left sub-tree cause all left sub tree nodes values will be less than low that we don\\'t need\\n\\troot.val > high\\n\\t\\tWe  don\\'t need to traverse right sub-tree cause all right sub-tree nodes value will be greater than high that we don\\'t need\\n```\\n\\nNow how we calculate the sum?\\n\\n**Algorithum**\\n1. check base case : root == null ?\\n2. now element sub-trees based on above assumption.\\n3. if root.data lies between range[low, high], call for both left and right sub-tree and add current node value into sum\\n4. return this sum;\\n\\nTime complexity   T(n) = O(n)\\n\\n**Code**\\n\\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        \\n        if(root.val < low) { // discard the left sub-tree\\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        if(root.val > high) { //  discard the right sub-tree\\n            return rangeSumBST(root.left, low, high);\\n        }\\n        \\n        return rangeSumBST(root.left, low, high) + root.val + rangeSumBST(root.right, low, high);\\n    }\\n```\\n\\t\\t\\t\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\troot.val < low \\n\\t\\tWe don\\'t have to traverse left sub-tree cause all left sub tree nodes values will be less than low that we don\\'t need\\n\\troot.val > high\\n\\t\\tWe  don\\'t need to traverse right sub-tree cause all right sub-tree nodes value will be greater than high that we don\\'t need\\n```\n```\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root == null) return 0;\\n        \\n        if(root.val < low) { // discard the left sub-tree\\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        if(root.val > high) { //  discard the right sub-tree\\n            return rangeSumBST(root.left, low, high);\\n        }\\n        \\n        return rangeSumBST(root.left, low, high) + root.val + rangeSumBST(root.right, low, high);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842871,
                "title": "recurisve-python-solution-with-comments",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        if not(root): return root\\n        # return nextNode(root, low, high, 0)\\n        return getsum(root, low, high, 0)\\n    \\n    \\n# Ordinary: Binary Tree Recursion;\\ndef nextNode(root, lo, hi, sumi):\\n    # base case;\\n    if not(root): return sumi\\n    # main case\\n    sumi = nextNode(root.left, lo, hi, sumi)\\n    if(root.val >= lo and root.val <= hi):\\n        sumi = sumi + root.val\\n    sumi = nextNode(root.right, lo, hi, sumi)\\n    return sumi\\n\\n\\n# Little More Optimized\\ndef getsum(root, lo, hi, res):\\n    if not root: \\n        return res\\n    if(root.val >= lo and root.val <= hi):\\n        res += root.val\\n    if(root.val > lo):                      # going left only when root\\'s value greater than low;\\n        res = getsum(root.left,lo,hi,res)\\n    if(root.val <= hi):                     # going right onyl when root\\'s value smaller than high;\\n        res = getsum(root.right,lo,hi,res)\\n    return res\\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def rangeSumBST(self, root, low, high):\\n        if not(root): return root\\n        # return nextNode(root, low, high, 0)\\n        return getsum(root, low, high, 0)\\n    \\n    \\n# Ordinary: Binary Tree Recursion;\\ndef nextNode(root, lo, hi, sumi):\\n    # base case;\\n    if not(root): return sumi\\n    # main case\\n    sumi = nextNode(root.left, lo, hi, sumi)\\n    if(root.val >= lo and root.val <= hi):\\n        sumi = sumi + root.val\\n    sumi = nextNode(root.right, lo, hi, sumi)\\n    return sumi\\n\\n\\n# Little More Optimized\\ndef getsum(root, lo, hi, res):\\n    if not root: \\n        return res\\n    if(root.val >= lo and root.val <= hi):\\n        res += root.val\\n    if(root.val > lo):                      # going left only when root\\'s value greater than low;\\n        res = getsum(root.left,lo,hi,res)\\n    if(root.val <= hi):                     # going right onyl when root\\'s value smaller than high;\\n        res = getsum(root.right,lo,hi,res)\\n    return res\\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829411,
                "title": "scala-tailrec",
                "content": "```\\ndef rangeSumBST(root: TreeNode, low: Int, high: Int): Int = {\\n        import scala.util.control.TailCalls.{TailRec, done}\\n        def dfs(tn: TreeNode) : TailRec[Int] = tn match {\\n            case null => done(0)\\n            case n =>\\n                val t = if (low <= n.value && n.value <= high) n.value else 0\\n                for {\\n                    l <- dfs(n.left)\\n                    r <- dfs(n.right)\\n                } yield l + r + t\\n        }\\n        dfs(root).result\\n    }\\n```",
                "solutionTags": [
                    "Scala",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef rangeSumBST(root: TreeNode, low: Int, high: Int): Int = {\\n        import scala.util.control.TailCalls.{TailRec, done}\\n        def dfs(tn: TreeNode) : TailRec[Int] = tn match {\\n            case null => done(0)\\n            case n =>\\n                val t = if (low <= n.value && n.value <= high) n.value else 0\\n                for {\\n                    l <- dfs(n.left)\\n                    r <- dfs(n.right)\\n                } yield l + r + t\\n        }\\n        dfs(root).result\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769566,
                "title": "c-recursion-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif(root->val > high)\\n\\t\\t\\t\\treturn rangeSumBST(root->left , low , high);\\n\\t\\t\\telse if(root->val < low)\\n\\t\\t\\t\\treturn rangeSumBST(root->right , low , high);\\n\\t\\t\\treturn root->val + rangeSumBST(root->left , low , high) + \\n\\t\\t\\t\\t   rangeSumBST(root->right , low , high);\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint rangeSumBST(TreeNode* root, int low, int high) {\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif(root->val > high)\\n\\t\\t\\t\\treturn rangeSumBST(root->left , low , high);\\n\\t\\t\\telse if(root->val < low)\\n\\t\\t\\t\\treturn rangeSumBST(root->right , low , high);\\n\\t\\t\\treturn root->val + rangeSumBST(root->left , low , high) + \\n\\t\\t\\t\\t   rangeSumBST(root->right , low , high);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1724362,
                "title": "python3-faster",
                "content": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        summ=0\\n        if root.val>=low and root.val<=high:\\n            summ+=root.val\\n        summ=summ+self.rangeSumBST(root.left,low,high)\\n        summ=summ+self.rangeSumBST(root.right,low,high)\\n        return summ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if root is None:\\n            return 0\\n        summ=0\\n        if root.val>=low and root.val<=high:\\n            summ+=root.val\\n        summ=summ+self.rangeSumBST(root.left,low,high)\\n        summ=summ+self.rangeSumBST(root.right,low,high)\\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682399,
                "title": "java-easy-recursion-o-n-0ms-faster-than-100-submission",
                "content": "```\\nclass Solution{\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n      if(root==null) return 0;\\n        if(root.val>low && root.val>high){\\n           return rangeSumBST(root.left,low,high);\\n        }else if(root.val<low && root.val<high){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            int l=rangeSumBST(root.left,low,high);\\n            int r=rangeSumBST(root.right,low,high);\\n            return l+r+root.val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n      if(root==null) return 0;\\n        if(root.val>low && root.val>high){\\n           return rangeSumBST(root.left,low,high);\\n        }else if(root.val<low && root.val<high){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            int l=rangeSumBST(root.left,low,high);\\n            int r=rangeSumBST(root.right,low,high);\\n            return l+r+root.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629351,
                "title": "easy-to-understand-python-solution",
                "content": "```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:                               # If the node does not exist or is null\\n\\t\\treturn 0                               # add a 0 value for that node\\n\\t\\n\\telif root.val >= low and root.val <= high: # If it exists and is in the inclusive range of low and high, return it\\'s val\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # and recurse into left and right branches\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telse:                                      # If it exists but is outside of the range, we still\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # recurse into left and right branches because a child node may be in range\\n\\t\\treturn self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\\n\\n\\n\\nOptimized version:\\n\\n```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\telif root.val >= low and root.val <= high:\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telif root.val < low:                               # If the node is less than the low range,\\n\\t\\treturn self.rangeSumBST(root.right, low, high) # all left children will also be, so we only pursue right\\n\\t\\n\\telif root.val > high:                              # same principle here, but in the other direction\\n\\t\\treturn self.rangeSumBST(root.left, low, high)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:                               # If the node does not exist or is null\\n\\t\\treturn 0                               # add a 0 value for that node\\n\\t\\n\\telif root.val >= low and root.val <= high: # If it exists and is in the inclusive range of low and high, return it\\'s val\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # and recurse into left and right branches\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telse:                                      # If it exists but is outside of the range, we still\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       # recurse into left and right branches because a child node may be in range\\n\\t\\treturn self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\n```\\ndef rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\telif root.val >= low and root.val <= high:\\n\\t\\treturn root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n\\t\\n\\telif root.val < low:                               # If the node is less than the low range,\\n\\t\\treturn self.rangeSumBST(root.right, low, high) # all left children will also be, so we only pursue right\\n\\t\\n\\telif root.val > high:                              # same principle here, but in the other direction\\n\\t\\treturn self.rangeSumBST(root.left, low, high)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1628460,
                "title": "c-99-faster-93-less-space-using-std-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        uint32_t sum = 0;\\n        std::stack<TreeNode*> nodes_to_pass;\\n        nodes_to_pass.push(root);\\n        while(!nodes_to_pass.empty()) {\\n            TreeNode* current_node = nodes_to_pass.top();\\n            if (current_node->val >= low && current_node->val <= high) {\\n                sum += current_node->val;\\n            }\\n            nodes_to_pass.pop();\\n            if (current_node->left && current_node->val >= low) {\\n                nodes_to_pass.push(current_node->left);\\n            }\\n            if (current_node->right && current_node->val <= high) {\\n                nodes_to_pass.push(current_node->right);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        uint32_t sum = 0;\\n        std::stack<TreeNode*> nodes_to_pass;\\n        nodes_to_pass.push(root);\\n        while(!nodes_to_pass.empty()) {\\n            TreeNode* current_node = nodes_to_pass.top();\\n            if (current_node->val >= low && current_node->val <= high) {\\n                sum += current_node->val;\\n            }\\n            nodes_to_pass.pop();\\n            if (current_node->left && current_node->val >= low) {\\n                nodes_to_pass.push(current_node->left);\\n            }\\n            if (current_node->right && current_node->val <= high) {\\n                nodes_to_pass.push(current_node->right);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627963,
                "title": "python3-iterative-bfs-explained",
                "content": "We are using a queue to do the Breadth-First Search iteratively. For every node, we check whether the value is in the range. Children are added to the queue only if they can have nodes in the given range using the main property of the Binary Tree: greater nodes go to the right, smaller nodes to the left. That allows us to avoid useless passes through the tree.\\n\\nTime: **O(N)** - for the BFS\\nSpace: **O(logN)** - for the queue\\n\\nRuntime: 196 ms, faster than **94.28%** of Python3 online submissions for Range Sum of BST.\\nMemory Usage: 22.4 MB, less than **5.88%** of Python3 online submissions for Range Sum of BST.\\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:\\n        res = 0\\n        \\n        q = deque([root])\\n        while q:\\n            c = q.popleft()\\n            v, l, r = c.val, c.left, c.right\\n\\n            if lo <= v and v <= hi:\\n                res += v\\n                \\n            if l and (lo < v or v > hi):\\n                q.append(l)\\n                \\n            if r and (lo > v or v < hi):\\n                q.append(r)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:\\n        res = 0\\n        \\n        q = deque([root])\\n        while q:\\n            c = q.popleft()\\n            v, l, r = c.val, c.left, c.right\\n\\n            if lo <= v and v <= hi:\\n                res += v\\n                \\n            if l and (lo < v or v > hi):\\n                q.append(l)\\n                \\n            if r and (lo > v or v < hi):\\n                q.append(r)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627949,
                "title": "easy-recursive-solution-in-c",
                "content": "\\n//smjh\\n\\n``` \\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n      if(root == NULL) return 0;\\n        \\n       if(root->val > high){\\n           return rangeSumBST(root->left,low ,high);\\n       }\\n        else if(root->val <low){\\n            return rangeSumBST(root->right,low,high);\\n        }\\n        \\n        return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        \\n    }\\n\\t\\nDo upvote if you find it helpful",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n//smjh\\n\\n``` \\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n      if(root == NULL) return 0;\\n        \\n       if(root->val > high){\\n           return rangeSumBST(root->left,low ,high);\\n       }\\n        else if(root->val <low){\\n            return rangeSumBST(root->right,low,high);\\n        }\\n        \\n        return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        \\n    }\\n\\t\\nDo upvote if you find it helpful",
                "codeTag": "Unknown"
            },
            {
                "id": 1627797,
                "title": "python3-clean-7-lines-o-n-time-beats-94-28-o-n-space-dfs",
                "content": "Below is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root: return 0\\n        res = root.val if low <= root.val <= high else 0\\n        if root.val <= low: return res + self.rangeSumBST(root.right, low, high)\\n        if root.val >= high: return res + self.rangeSumBST(root.left, low, high)\\n        return res + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root: return 0\\n        res = root.val if low <= root.val <= high else 0\\n        if root.val <= low: return res + self.rangeSumBST(root.right, low, high)\\n        if root.val >= high: return res + self.rangeSumBST(root.left, low, high)\\n        return res + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518247,
                "title": "c-recursive-solution",
                "content": "**Uncomment the commented part to see the recursive call pattern for better understanding.**\\n*Do upvote if you understand the solution : )*\\n\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n      \\n      if(root == NULL) \\n      {\\n          // cout<<\" sum : \"<<sum<<endl;\\n          return sum;\\n      }\\n      // cout<<\"For value : \"<<root->val<<\" sum : \"<<sum<<endl;\\n\\n      if(root->val>=low && root->val<=high)\\n      {\\n          sum+=root->val;\\n          rangeSumBST(root->left,low,high);\\n          rangeSumBST(root->right,low,high);\\n      }\\n      else if (root->val < low)\\n      {\\n        rangeSumBST(root->right,low,high);\\n      }\\n      else\\n      {\\n        rangeSumBST(root->left,low,high);\\n      }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) \\n    {\\n      \\n      if(root == NULL) \\n      {\\n          // cout<<\" sum : \"<<sum<<endl;\\n          return sum;\\n      }\\n      // cout<<\"For value : \"<<root->val<<\" sum : \"<<sum<<endl;\\n\\n      if(root->val>=low && root->val<=high)\\n      {\\n          sum+=root->val;\\n          rangeSumBST(root->left,low,high);\\n          rangeSumBST(root->right,low,high);\\n      }\\n      else if (root->val < low)\\n      {\\n        rangeSumBST(root->right,low,high);\\n      }\\n      else\\n      {\\n        rangeSumBST(root->left,low,high);\\n      }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1324875,
                "title": "java-cpp-one-liner-soln-brute-force-and-java-clean-soln-using-bst",
                "content": "Java:\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        return (root != null && root.val <= high && root.val >= low ? root.val : 0) + (root == null ? 0 : rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high));\\n    }\\n}\\n```\\ncpp:\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n        return (root != NULL && root->val <= high && root->val >= low ? root->val : 0) + (root == NULL ? 0 : rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high));\\n    }\\n};\\n```\\n\\nJava (clean code):\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        if (root == null) return 0;\\n        \\n        if (root.val >= low && root.val <= high) {\\n            \\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n        else if (root.val < low) {\\n            \\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        else {\\n            return rangeSumBST(root.left, low, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        return (root != null && root.val <= high && root.val >= low ? root.val : 0) + (root == null ? 0 : rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high));\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n        return (root != NULL && root->val <= high && root->val >= low ? root->val : 0) + (root == NULL ? 0 : rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high));\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        \\n        if (root == null) return 0;\\n        \\n        if (root.val >= low && root.val <= high) {\\n            \\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n        else if (root.val < low) {\\n            \\n            return rangeSumBST(root.right, low, high);\\n        }\\n        \\n        else {\\n            return rangeSumBST(root.left, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309553,
                "title": "100-faster-and-99-5-less-memory-consumption-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(root==NULL){\\n            return sum;\\n        }\\n       \\n        if(root->val>=low&&root->val<=high){\\n                sum+=root->val;\\n        }\\n        rangeSumBST(root->left,low, high);\\n        rangeSumBST(root->right,low, high);\\n        root->left=root->right=nullptr;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(root==NULL){\\n            return sum;\\n        }\\n       \\n        if(root->val>=low&&root->val<=high){\\n                sum+=root->val;\\n        }\\n        rangeSumBST(root->left,low, high);\\n        rangeSumBST(root->right,low, high);\\n        root->left=root->right=nullptr;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1298049,
                "title": "c-recursion-dfs-bst-property-usage",
                "content": "Some of the recent solutions that I\\'ve seen is missing important BST property in their codes. \\nHere is the code that uses BST property during traversing.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n        if(root->val>=low and root->val<=high)\\n            return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);\\n        else if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        else\\n            return rangeSumBST(root->left,low,high);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n        if(root->val>=low and root->val<=high)\\n            return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);\\n        else if(root->val<low)\\n            return rangeSumBST(root->right,low,high);\\n        else\\n            return rangeSumBST(root->left,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292484,
                "title": "3-line-code-lmaooooo-dfs",
                "content": "**I don\\'t think this code requires intiution but for beginner here is the brute force first approach all you need to calculate sum right? so what you could do is check if your root value is lie b/w the range just add it in your answer and call on your left and right childs and add their answer too return the answer**\\n\\n\\n**since it\\'s BST we can improve our logic check if your root->val is greater than high? if yes this means no need to call on right child it will never give you an answer so call on only left now check if root->val is less than low? if yes no need to call on left it won\\'t give you an answer so call on right only now if both the cases are not true it means your root value is lie  b/w range so add root->val in your answer and call on left and right simple that\\'s it bois/girls.......... don\\'t forget to upvote \\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)return 0;\\n        if(root->val>high)return rangeSumBST(root->left, low,high);\\n        else if(root->val<low)return rangeSumBST(root->right,low,high);\\n        else return root->val + rangeSumBST(root->left, low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)return 0;\\n        if(root->val>high)return rangeSumBST(root->left, low,high);\\n        else if(root->val<low)return rangeSumBST(root->right,low,high);\\n        else return root->val + rangeSumBST(root->left, low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248688,
                "title": "simple-recursive-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        ans+=rangeSumBST(root.left,low,high);\\n        if(inRange(root.val,low,high))ans+=root.val;\\n        ans+=rangeSumBST(root.right,low,high);\\n        return ans;\\n    }\\n    public boolean inRange(int n,int low,int high)\\n    {\\n        return n>=low&&n<=high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        ans+=rangeSumBST(root.left,low,high);\\n        if(inRange(root.val,low,high))ans+=root.val;\\n        ans+=rangeSumBST(root.right,low,high);\\n        return ans;\\n    }\\n    public boolean inRange(int n,int low,int high)\\n    {\\n        return n>=low&&n<=high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243988,
                "title": "c-better-than-o-n-clean",
                "content": "**if the current node value is not in the range  low and high  then you have decide if is it possible to go right   and left**\\n\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(root==NULL)\\n            return 0;\\n        if(root->val<=high and root->val>=low)\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        if(root->val>high)\\n            return  rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);    \\n        return 0;\\n        \\n    }",
                "solutionTags": [],
                "code": "**if the current node value is not in the range  low and high  then you have decide if is it possible to go right   and left**\\n\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        \\n        if(root==NULL)\\n            return 0;\\n        if(root->val<=high and root->val>=low)\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        if(root->val>high)\\n            return  rangeSumBST(root->left,low,high);\\n        if(root->val<low)\\n            return rangeSumBST(root->right,low,high);    \\n        return 0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1219173,
                "title": "easy-java-recursion",
                "content": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n        int rootsum =0;\\n        int ls = rangeSumBST(root.left, low, high);\\n        int rs = rangeSumBST(root.right, low, high);\\n        if(root.val>= low && root.val <= high) rootsum = root.val;\\n        else rootsum = 0;\\n        int sum = ls+ rs+ rootsum;\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n        int rootsum =0;\\n        int ls = rangeSumBST(root.left, low, high);\\n        int rs = rangeSumBST(root.right, low, high);\\n        if(root.val>= low && root.val <= high) rootsum = root.val;\\n        else rootsum = 0;\\n        int sum = ls+ rs+ rootsum;\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1218050,
                "title": "use-of-the-fact-that-it-is-bst-explaination-beginner-90-fast",
                "content": "**JUST WANT TO GET IMPLEMENTATION JUMP TO CODE**\\n\\nBasic property of bst is that it contains its left child as smaller or equal to node and its right child greater to it,(the equal child can be kept any of the side).\\n\\n\\nin the given diagram \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t/   \\\\\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t5          15\\n\\t\\t\\t\\t\\t\\t\\t   /  \\\\\\\\           \\\\\\\\\\n\\t\\t\\t\\t\\t\\t\\t 3       7           18\\nthe node value(10) is in given range therefore the possibilty of having a in-range value on both subtrees  is possible,\\ntherefore we take a extra memory(taking queue) and add both its child to it\\nQueue has 5,15 now .\\npicking 5(as of fifo).\\nnow 5 is smaller than the lower value but its right child can have a value greater to it which might be in  given range,so we eliminate the left subtree and add the right child of it to the queue.\\n\\nnow,queue become 15,7.\\nas 15 is in range we\"ll again add both of its child to queue.\\nand the process goes....\\nthe moment we get a node in given range we take the sum of it and add it to a variable.\\n\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n          if(root==NULL)return 0;\\n        queue<TreeNode*>q;\\n        int res=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode*temp=q.front();\\n            q.pop();\\n            if(temp->val<low)\\n            {\\n                if(temp->right!=NULL)q.push(temp->right);\\n            }\\n            else if(temp->val>high)\\n            {\\n                if(temp->left!=NULL)q.push(temp->left);\\n            }\\n\\n            else if(temp->val>=low&&temp->val<=high)\\n            {\\n                res+=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);   \\n            }\\n           \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**HAPPY CODING!**\\n\\n\\n\\n\\n\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n          if(root==NULL)return 0;\\n        queue<TreeNode*>q;\\n        int res=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode*temp=q.front();\\n            q.pop();\\n            if(temp->val<low)\\n            {\\n                if(temp->right!=NULL)q.push(temp->right);\\n            }\\n            else if(temp->val>high)\\n            {\\n                if(temp->left!=NULL)q.push(temp->left);\\n            }\\n\\n            else if(temp->val>=low&&temp->val<=high)\\n            {\\n                res+=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);   \\n            }\\n           \\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159445,
                "title": "3-line-c-solution-without-creating-new-function",
                "content": "end to end recursive c++ solution.\\n\\n```\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL) return 0;\\n        \\n        if(root->val>=low && root->val<=high){\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL) return 0;\\n        \\n        if(root->val>=low && root->val<=high){\\n            return root->val + rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146310,
                "title": "javascript-stack-easy",
                "content": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let stack = [root];\\n    let sum = 0;\\n    while(stack.length !== 0) {\\n        let currentNode = stack.pop();\\n        if (currentNode !== null) {\\n            if (currentNode.val >= low && currentNode.val <= high) {\\n                sum += currentNode.val;\\n            }\\n            // when current value is greater than low, we check the left node since the left node is always smaller than current node\\n            if (currentNode.val > low) {\\n                stack.push(currentNode.left);\\n            }\\n            if (currentNode.val < high) {\\n                stack.push(currentNode.right);\\n            }\\n        }\\n    }\\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar rangeSumBST = function(root, low, high) {\\n    let stack = [root];\\n    let sum = 0;\\n    while(stack.length !== 0) {\\n        let currentNode = stack.pop();\\n        if (currentNode !== null) {\\n            if (currentNode.val >= low && currentNode.val <= high) {\\n                sum += currentNode.val;\\n            }\\n            // when current value is greater than low, we check the left node since the left node is always smaller than current node\\n            if (currentNode.val > low) {\\n                stack.push(currentNode.left);\\n            }\\n            if (currentNode.val < high) {\\n                stack.push(currentNode.right);\\n            }\\n        }\\n    }\\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1131662,
                "title": "simple-js-faster-than-95",
                "content": "```\\nconst rangeSumBST =(root, low, high)=> {\\n    let q = [];\\n    q.push(root);\\n    let sum =0;\\n    while(q.length){\\n        const temp = q.pop();\\n        if(temp.left) q.push(temp.left);\\n        if(temp.right) q.push(temp.right);\\n        sum = temp.val>=low && temp.val<=high ? sum+temp.val : sum;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst rangeSumBST =(root, low, high)=> {\\n    let q = [];\\n    q.push(root);\\n    let sum =0;\\n    while(q.length){\\n        const temp = q.pop();\\n        if(temp.left) q.push(temp.left);\\n        if(temp.right) q.push(temp.right);\\n        sum = temp.val>=low && temp.val<=high ? sum+temp.val : sum;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093153,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node == NULL)\\n                continue;\\n            if(node->val >= low && node->val <= high)\\n                sum += node->val;\\n            \\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node == NULL)\\n                continue;\\n            if(node->val >= low && node->val <= high)\\n                sum += node->val;\\n            \\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937409,
                "title": "follow-up-question-for-interview-preparations",
                "content": "I see that many people got confused by the language of the question, but still this question seems easy.\\nIf this question were to appear in a interview, it will be a warm up question and then it will be slightly modified to add complexity.\\n\\nOne such question - How can we handle if there are multiple queries for getting range sum ? i.e. ```getRangeSumBST(int low, int high)``` is called again and again with different low, high values. \\nHow would you optimize? \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```getRangeSumBST(int low, int high)```",
                "codeTag": "Unknown"
            },
            {
                "id": 936345,
                "title": "c-recursive-one-liner-solutions-explained-100-time-80-space",
                "content": "This is a rather straightfoward problem and we might easily solve it calling a helper `dfs` function to gradually go top-down, from node to node, to solve it.\\n\\nI preferred going for an extra bit of challenge and writing directly a recursive one-liner, ignoring the condition that it is a BST, since I found little value in potentially skipping a conditional every time we examine a node, whereas that would have costed much more code complexity.\\n\\nTo do so, I \"hid\" the result variable as a fourth optional parameter, defaulted to `0`.\\n\\nI will then return it when `root == NULL`, ie: we ended up out of the tree; otherwise, I will call recursively our `rangeSumBST` function on both the `left` and `right` branches, with a twist:\\n* the call to the `left` branch will keep increasing `res` with the value of the current `root->val`;\\n* the call to the `right` branch will every time reset `res` to `0` and compute a sub-sum from scratch.\\n\\nOnce all the recursive calls will be done, we I will have to just the result of `root->val` plus the sub-sum of everything to the left of it with the sub-sum of whatever is at the right of it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high, int res = 0) {\\n        return root ? rangeSumBST(root->left, low, high, res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, low, high) : res;\\n    }\\n};\\n```\\n\\nAnd looking back to the one-liner I wrote in May, one that has some earlier stopping condition, I really struggle to find it worth in terms of extra performances, since it is one more check at each step.\\n\\nBasically at each iteration we update the upper and lower limit `low` and `high` as we go: going `left` will reduce potentially reduce `high`, while going `right` will have us check if we need to update `low`.\\n\\nAt the beginning of our code, we are not checking that `root` is not `NULL`, plus the new condition `low <= high`, meaning we already reached a part of the tree that does not matter to us.\\n\\nFor example, if we started with `low == 10` and `high == 20`, moving `left` after having it a node with value `9` or lower (and thus having updated `high` to that value) would not be meaningul, since by definition any value to its left needs to be smaller in a BST; similarly moving `right` after encountering anything `> 20` should have us halt right there.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        return root && low <= high ? (root->val >= low && root->val <= high ? root->val : 0) + rangeSumBST(root->left, low, min(high, root->val)) + rangeSumBST(root->right, max(root->val, low), high) : 0;\\n    }\\n};\\n```\\n\\nHybrid of the 2 approaches, using also [RedaKerouicha](https://leetcode.com/RedaKerouicha/)\\'s suggestion:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, const int low, const int high, const int res = 0) {\\n        return root && low <= high ? rangeSumBST(root->left, low, min(high, root->val), res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, max(root->val, low), high) : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high, int res = 0) {\\n        return root ? rangeSumBST(root->left, low, high, res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, low, high) : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        return root && low <= high ? (root->val >= low && root->val <= high ? root->val : 0) + rangeSumBST(root->left, low, min(high, root->val)) + rangeSumBST(root->right, max(root->val, low), high) : 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, const int low, const int high, const int res = 0) {\\n        return root && low <= high ? rangeSumBST(root->left, low, min(high, root->val), res + (root->val >= low && root->val <= high ? root->val : 0)) + rangeSumBST(root->right, max(root->val, low), high) : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825233,
                "title": "recursive-solution-dfs-solution-with-one-trick-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // recursive solution\\n\\t\\n\\t``\\n    //one simple trick you bcan use is that you can find the inorder of bst and add l to r all values\\n\\t``\\n\\t\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n         int ans = 0;\\n        dfs(root, L, R,ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int L, int R,int & ans) {\\n        if (node != NULL) {\\n            if (L <= node -> val && node ->  val <= R)\\n                ans += node -> val;\\n            if (L < node -> val)\\n                dfs(node -> left, L, R,ans);\\n            if (node ->  val < R)\\n                dfs(node -> right, L, R,ans);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // recursive solution\\n\\t\\n\\t``\\n    //one simple trick you bcan use is that you can find the inorder of bst and add l to r all values\\n\\t``\\n\\t\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n         int ans = 0;\\n        dfs(root, L, R,ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int L, int R,int & ans) {\\n        if (node != NULL) {\\n            if (L <= node -> val && node ->  val <= R)\\n                ans += node -> val;\\n            if (L < node -> val)\\n                dfs(node -> left, L, R,ans);\\n            if (node ->  val < R)\\n                dfs(node -> right, L, R,ans);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637185,
                "title": "go-recursive",
                "content": "```go\\nfunc rangeSumBST(root *TreeNode, L int, R int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    res := 0\\n    \\n    // Node is within range\\n    if root.Val >= L && root.Val <= R {\\n        res += root.Val\\n    }\\n    \\n    // Range is overlapped with left tree\\n    if root.Val > L {\\n        res += rangeSumBST(root.Left, L, R)\\n    }\\n    \\n    // Range is overlapped with right tree\\n    if root.Val < R {\\n        res += rangeSumBST(root.Right, L, R)\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc rangeSumBST(root *TreeNode, L int, R int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    res := 0\\n    \\n    // Node is within range\\n    if root.Val >= L && root.Val <= R {\\n        res += root.Val\\n    }\\n    \\n    // Range is overlapped with left tree\\n    if root.Val > L {\\n        res += rangeSumBST(root.Left, L, R)\\n    }\\n    \\n    // Range is overlapped with right tree\\n    if root.Val < R {\\n        res += rangeSumBST(root.Right, L, R)\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359598,
                "title": "scala-using-pattern-matching",
                "content": "```\\nobject Solution {\\n    def rangeSumBST(root: TreeNode, L: Int, R: Int): Int = root match {\\n        case r if r == null => \\n            0\\n        case r if r.value < L => \\n            rangeSumBST(r.right,L,R)\\n        case r if r.value > R => \\n            rangeSumBST(r.left,L,R)\\n        case r => \\n            r.value + rangeSumBST(r.right,L,R) + rangeSumBST(r.left,L,R)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def rangeSumBST(root: TreeNode, L: Int, R: Int): Int = root match {\\n        case r if r == null => \\n            0\\n        case r if r.value < L => \\n            rangeSumBST(r.right,L,R)\\n        case r if r.value > R => \\n            rangeSumBST(r.left,L,R)\\n        case r => \\n            r.value + rangeSumBST(r.right,L,R) + rangeSumBST(r.left,L,R)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 333717,
                "title": "c-one-liner",
                "content": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n\\treturn root ? (root->val >= L && root->val <= R ? root->val : 0) + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) : 0;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint rangeSumBST(TreeNode* root, int L, int R) {\\n\\treturn root ? (root->val >= L && root->val <= R ? root->val : 0) + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299679,
                "title": "simple-java-solution-0ms-faster-than-100-solution",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return -1;\\n        if(root.val >=L && root.val<=R) ans+= root.val;\\n        if(root.val>L) rangeSumBST(root.left, L, R);\\n        if(root.val<R) rangeSumBST(root.right, L, R);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int rangeSumBST(TreeNode root, int L, int R) {\\n        if(root == null) return -1;\\n        if(root.val >=L && root.val<=R) ans+= root.val;\\n        if(root.val>L) rangeSumBST(root.left, L, R);\\n        if(root.val<R) rangeSumBST(root.right, L, R);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296103,
                "title": "i-am-confused-on-how-to-represent-this-tree",
                "content": "so if we have \\n\\nroot = [10, 5, 15, 3, 7, null, 18], L = 7, R = 15\\n\\nShouldn\\'t the output be 37 because the tree would be represented this way\\n\\n                             10\\n\\t\\t\\t\\t\\t\\t\\t /  \\\\\\n\\t\\t\\t\\t\\t\\t   5    15\\n\\t\\t\\t\\t\\t\\t  /  \\\\    \\\\\\n\\t\\t\\t\\t\\t\\t 3\\t 7\\t 18\\n\\t\\t\\t\\t\\t\\t \\nIf the previous representation is the correct way, then the answer should be 37 because 7+5+10+15\\n\\nHow are they getting 32?\\n",
                "solutionTags": [],
                "code": "so if we have \\n\\nroot = [10, 5, 15, 3, 7, null, 18], L = 7, R = 15\\n\\nShouldn\\'t the output be 37 because the tree would be represented this way\\n\\n                             10\\n\\t\\t\\t\\t\\t\\t\\t /  \\\\\\n\\t\\t\\t\\t\\t\\t   5    15\\n\\t\\t\\t\\t\\t\\t  /  \\\\    \\\\\\n\\t\\t\\t\\t\\t\\t 3\\t 7\\t 18\\n\\t\\t\\t\\t\\t\\t \\nIf the previous representation is the correct way, then the answer should be 37 because 7+5+10+15\\n\\nHow are they getting 32?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 284070,
                "title": "c-code-using-dfs",
                "content": "````\\n\\npublic int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root == null) return 0;\\n        return ((root.val>=L && root.val<=R) ? root.val : 0)+\\n            RangeSumBST(root.left,L,R)+\\n        RangeSumBST(root.right,L,R);\\n    }\\n\\n// using a variable\\n\\npublic class Solution {\\n    private int sum = 0;\\n    public int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root!=null)\\n        {\\n            RangeSumBST(root.left,L,R);\\n            sum+= (root.val>=L && root.val<=R) ? root.val : 0;\\n            RangeSumBST(root.right,L,R);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\n\\npublic int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root == null) return 0;\\n        return ((root.val>=L && root.val<=R) ? root.val : 0)+\\n            RangeSumBST(root.left,L,R)+\\n        RangeSumBST(root.right,L,R);\\n    }\\n\\n// using a variable\\n\\npublic class Solution {\\n    private int sum = 0;\\n    public int RangeSumBST(TreeNode root, int L, int R)\\n    {\\n        if(root!=null)\\n        {\\n            RangeSumBST(root.left,L,R);\\n            sum+= (root.val>=L && root.val<=R) ? root.val : 0;\\n            RangeSumBST(root.right,L,R);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196165,
                "title": "c-simple-bfs",
                "content": "```\\n public int RangeSumBST(TreeNode root, int L, int R) {\\n        \\n        var totalSum = 0;\\n\\n        var que = new Queue<TreeNode>();\\n        que.Enqueue(root);\\n\\n        while (que.Count() > 0)\\n        {\\n            root = que.Dequeue();\\n          if(root.val >= L && root.val <= R){\\n              totalSum += root.val;\\n          }\\n\\n            if (root.left != null)\\n            {\\n                que.Enqueue(root.left);\\n            }\\n            if (root.right != null)\\n            {\\n                que.Enqueue(root.right);\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int RangeSumBST(TreeNode root, int L, int R) {\\n        \\n        var totalSum = 0;\\n\\n        var que = new Queue<TreeNode>();\\n        que.Enqueue(root);\\n\\n        while (que.Count() > 0)\\n        {\\n            root = que.Dequeue();\\n          if(root.val >= L && root.val <= R){\\n              totalSum += root.val;\\n          }\\n\\n            if (root.left != null)\\n            {\\n                que.Enqueue(root.left);\\n            }\\n            if (root.right != null)\\n            {\\n                que.Enqueue(root.right);\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192065,
                "title": "c-with-morris-inorder-traversal",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n   \\n    int inorderTraversal(TreeNode* root,int L, int R){\\n        int sum = 0;\\n        TreeNode *cur = root,*pre;\\n        while(cur!=nullptr){\\n            if(cur->left!=nullptr){\\n                pre = cur->left;\\n                while(pre->right!=nullptr && pre->right!=cur){\\n                    pre = pre->right;\\n                }\\n                if(pre->right==nullptr){\\n                    pre->right = cur;\\n                    cur = cur->left;\\n                }else{\\n                    if(cur->val>=L && cur->val<=R)\\n                        sum+=cur->val;\\n                    pre->right = nullptr;\\n                    cur = cur->right;\\n                }\\n            }else{\\n                if(cur->val>=L && cur->val<=R)\\n                        sum+=cur->val;\\n                cur = cur->right;\\n            }\\n        }\\n        return sum;\\n    }\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        if(root==nullptr)\\n            return 0;\\n        return inorderTraversal(root,L,R);\\n    }\\n};\\n\\'\\'\\'\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    int inorderTraversal(TreeNode* root,int L, int R){\\n        int sum = 0;\\n        TreeNode *cur = root,*pre;\\n        while(cur!=nullptr){\\n            if(cur->left!=nullptr){\\n                pre = cur->left;\\n                while(pre->right!=nullptr && pre->right!=cur){\\n                    pre = pre->right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4004175,
                "title": "well-defined-full-explanation-c-solution-easy-to-understand",
                "content": "Solution is quite simple. Lets recall the properties of a Binary Search Tree.\\n\\nBinary Search Tree is a node-based binary tree data structure which has the following properties:\\n\\n1. The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n2. The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n3. The left and right subtree each must also be a binary search tree.\\n\\nThe code I\\'ve provided is a recursive function for traversing a binary search tree (BST) in a modified form of Inorder Traversal. In a standard Inorder Traversal, you would visit nodes in ascending order. However, this function is modified to only visit nodes that fall within a specified range defined by low and high.\\n\\nHere\\'s how it works:\\n\\n1. If the current node\\'s value (root->val) is within the range [low, high], it includes the value of the current node in the sum and then recursively calls the function on both the left and right subtrees.\\n\\n2. If the current node\\'s value is less than low, it means that all values in the left subtree are also less than low, so it recursively calls the function on the right subtree only.\\n\\n3. If the current node\\'s value is greater than high, it means that all values in the right subtree are also greater than high, so it recursively calls the function on the left subtree only.\\n\\nThis approach efficiently eliminates the need to visit nodes that are guaranteed to be outside the specified range, making it a modified Inorder Traversal tailored for this specific problem.\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL)return 0;\\n        \\n        if(root->val >= low && root->val <= high){\\n            return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n        }\\n        \\n        //use property of BST that how elements are arranged.\\n        //if we have root value lessThan LOW then, discard the left part of the BST.\\n        if(root->val<low)\\n            return rangeSumBST(root->right , low , high);\\n        //if we have root value greaterThan HIGH then, discard the right part of the BST.\\n        return rangeSumBST(root->left , low , high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == NULL)return 0;\\n        \\n        if(root->val >= low && root->val <= high){\\n            return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n        }\\n        \\n        //use property of BST that how elements are arranged.\\n        //if we have root value lessThan LOW then, discard the left part of the BST.\\n        if(root->val<low)\\n            return rangeSumBST(root->right , low , high);\\n        //if we have root value greaterThan HIGH then, discard the right part of the BST.\\n        return rangeSumBST(root->left , low , high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525288,
                "title": "solution",
                "content": "```C++ []\\nconst int ZERO = [](){\\n     ios_base::sync_with_stdio(false);\\n     cin.tie(nullptr);\\n     return 0;\\n}();\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == nullptr) return 0;\\n\\n        if(root->val < low) root->left = nullptr;\\n        if(root->val > high) root->right = nullptr;\\n\\n        return (root->val >= low && root->val <=high ? root->val : 0) +rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root:\\n            return 0 \\n        elif root.val<low:\\n            return self.rangeSumBST(root.right,low,high) \\n        elif root.val>high:\\n            return self.rangeSumBST(root.left,low,high) \\n        return root.val + self.rangeSumBST(root.left,low,high)+self.rangeSumBST(root.right,low,high)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int ans = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        helper(root, low, high);\\n        return ans;\\n    }\\n    public void helper(TreeNode root, int low, int high) {\\n        if (root == null) return;\\n\\n        if (root.val > low) {\\n            helper(root.left, low, high);\\n        }\\n        if (root.val >= low && root.val <= high) {\\n            ans += root.val;\\n        }\\n        if (root.val < high) {\\n            helper(root.right, low, high);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nconst int ZERO = [](){\\n     ios_base::sync_with_stdio(false);\\n     cin.tie(nullptr);\\n     return 0;\\n}();\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(root == nullptr) return 0;\\n\\n        if(root->val < low) root->left = nullptr;\\n        if(root->val > high) root->right = nullptr;\\n\\n        return (root->val >= low && root->val <=high ? root->val : 0) +rangeSumBST(root->left,low,high) + rangeSumBST(root->right,low,high);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if not root:\\n            return 0 \\n        elif root.val<low:\\n            return self.rangeSumBST(root.right,low,high) \\n        elif root.val>high:\\n            return self.rangeSumBST(root.left,low,high) \\n        return root.val + self.rangeSumBST(root.left,low,high)+self.rangeSumBST(root.right,low,high)\\n```\n```Java []\\nclass Solution {\\n    public int ans = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        helper(root, low, high);\\n        return ans;\\n    }\\n    public void helper(TreeNode root, int low, int high) {\\n        if (root == null) return;\\n\\n        if (root.val > low) {\\n            helper(root.left, low, high);\\n        }\\n        if (root.val >= low && root.val <= high) {\\n            ans += root.val;\\n        }\\n        if (root.val < high) {\\n            helper(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395967,
                "title": "easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        if(root.val>=low && root.val<=high){\\n            return root.val+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n        }else if(root.val<low){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            return rangeSumBST(root.left,low,high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        if(root.val>=low && root.val<=high){\\n            return root.val+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n        }else if(root.val<low){\\n            return rangeSumBST(root.right,low,high);\\n        }else{\\n            return rangeSumBST(root.left,low,high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344324,
                "title": "python3-iterative-dfs-recursive-dfs-bfs",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterative DFS\\nRecursive DFS\\nBFS\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n\\n                                                    #recursive DFS\\n        # a = []\\n        # def dfs(node):\\n        #     if not node:\\n        #         return\\n        #     if low <= node.val <= high:\\n        #         a.append(node.val)\\n        #     dfs(node.left)\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # return sum(a)\\n\\n                                                            #DFS                                        \\n        stack = [(root, root.val)]\\n        a = 0\\n        while stack:\\n            node, val = stack.pop()\\n            if low <= val <= high:\\n                a += val\\n            if node.left:\\n                stack.append((node.left, node.left.val))\\n            if node.right:\\n                stack.append((node.right, node.right.val))\\n        return a\\n\\n                                                            #BSF\\n        \\n        # d = collections.deque([(root, root.val)])\\n        # a = 0\\n        # while d:\\n        #     node, val = d.popleft()\\n        #     if low <= val <= high:\\n        #         a += val\\n        #     if not ( node.left or node.right):\\n        #         continue\\n        #     if node.left:\\n        #         d.append((node.left, node.left.val))\\n        #     if node.right:\\n        #         d.append((node.right, node.right.val))\\n        # return a\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n\\n                                                    #recursive DFS\\n        # a = []\\n        # def dfs(node):\\n        #     if not node:\\n        #         return\\n        #     if low <= node.val <= high:\\n        #         a.append(node.val)\\n        #     dfs(node.left)\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # return sum(a)\\n\\n                                                            #DFS                                        \\n        stack = [(root, root.val)]\\n        a = 0\\n        while stack:\\n            node, val = stack.pop()\\n            if low <= val <= high:\\n                a += val\\n            if node.left:\\n                stack.append((node.left, node.left.val))\\n            if node.right:\\n                stack.append((node.right, node.right.val))\\n        return a\\n\\n                                                            #BSF\\n        \\n        # d = collections.deque([(root, root.val)])\\n        # a = 0\\n        # while d:\\n        #     node, val = d.popleft()\\n        #     if low <= val <= high:\\n        #         a += val\\n        #     if not ( node.left or node.right):\\n        #         continue\\n        #     if node.left:\\n        #         d.append((node.left, node.left.val))\\n        #     if node.right:\\n        #         d.append((node.right, node.right.val))\\n        # return a\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240199,
                "title": "storing-values-in-range-c-omar-kashif",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    First we store all the values (from the tree) that are in the range\\n    then we simply sum them up, and return the sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    void foo(TreeNode* root, int low, int high, vector<int>&a)\\n    {\\n        if(root==nullptr)\\n            return;\\n        if(root->val>=low && root->val<=high)\\n            a.push_back(root->val);\\n        if(root->right!=nullptr)\\n            foo(root->right,low,high,a);\\n        if(root->left!=nullptr)\\n            foo(root->left,low,high,a);\\n    }\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        foo(root,low,high,v);\\n        int n=v.size(), sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=v[i];\\n        return sum;\\n    }\\n    // Code by OK!\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    void foo(TreeNode* root, int low, int high, vector<int>&a)\\n    {\\n        if(root==nullptr)\\n            return;\\n        if(root->val>=low && root->val<=high)\\n            a.push_back(root->val);\\n        if(root->right!=nullptr)\\n            foo(root->right,low,high,a);\\n        if(root->left!=nullptr)\\n            foo(root->left,low,high,a);\\n    }\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int>v;\\n        foo(root,low,high,v);\\n        int n=v.size(), sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=v[i];\\n        return sum;\\n    }\\n    // Code by OK!\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142790,
                "title": "range-path-sum-bst-optimal-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val <= high){\\n            rangeSumBST(root.left, low, high);\\n            sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        }\\n        else if(root.val>=high){\\n            rangeSumBST(root.left, low, high);\\n        } else {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val <= high){\\n            rangeSumBST(root.left, low, high);\\n            sum += root.val;\\n            rangeSumBST(root.right, low, high);\\n        }\\n        else if(root.val>=high){\\n            rangeSumBST(root.left, low, high);\\n        } else {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888265,
                "title": "cpp-recursion-efficient-solution",
                "content": "# Approach\\nCheck if current node is betweeen [low, high] and recurse accordingly for the subtrees.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root) return 0;\\n    \\n        if(root->val < low) return rangeSumBST(root->right, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else if(root->val > high) return rangeSumBST(root->left, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else return root->val + rangeSumBST(root->right, low, high) + rangeSumBST(root->left, low, high);\\n        // Required nodes can be in both subtree + Add node->val\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root) return 0;\\n    \\n        if(root->val < low) return rangeSumBST(root->right, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else if(root->val > high) return rangeSumBST(root->left, low, high);\\n        // Only nodes in right Subtree are needed\\n\\n        else return root->val + rangeSumBST(root->right, low, high) + rangeSumBST(root->left, low, high);\\n        // Required nodes can be in both subtree + Add node->val\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888217,
                "title": "simple-java-solution-0ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sum = 0;\\n\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(low <= root.val && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sum = 0;\\n\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        if(low <= root.val && root.val <= high) {\\n            sum += root.val;\\n        }\\n        if(root.val > low) {\\n            rangeSumBST(root.left, low, high);\\n        }\\n        if(root.val < high) {\\n            rangeSumBST(root.right, low, high);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888145,
                "title": "938-range-sum-of-bst-java-0-ms-faster-than-100-00-using-dfs-clean-code-with-comment",
                "content": "If you like the solution then an Upvote would really be an O(n) decision :)\\n```\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }\\n    private void dfs(TreeNode node, int low, int high){\\n        if(node == null) return;\\n        \\n        int currentVal = node.val;\\n        \\n        //add in sum, if its value in range\\n        if(currentVal >= low && currentVal <= high) sum += currentVal;\\n        \\n        //no need to check in left, if current val is less than low\\n        //As it given,this is BST, so in left there will lesser number\\n        if(currentVal >= low)\\n        dfs(node.left, low, high);\\n        \\n        //no need to check in right, if current val is greater that high\\n        if(currentVal <= high)\\n        dfs(node.right, low, high);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        \\n        dfs(root, low, high);\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2888105,
                "title": "java-simple-100-faster-solution",
                "content": "# Intuition\\nThink of it as a binary search... Just with one change that you\\'re not actually looking for a value but for a range of values.\\n\\n# Approach\\nJust follow the similar strategy as you would follow in case of Binary Search that is discard halves if your current node falls out of range.\\n\\n# Complexity\\n- Time complexity:\\nO(N) -> In worst case all your elements might fall in range\\n- Space complexity:\\nO(N) -> Recursive Stack Space\\n# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n\\n        if(root.val < low){   // if current node value is less than low than move it to greater side that is right side\\n            return rangeSumBST(root.right, low, high);\\n        }else if(root.val > high){  // if current node value is greater than high than move it to lower side that is left side\\n            return rangeSumBST(root.left, low, high);\\n        }else{  // if it\\'s in range add the current value and repeat for left and right subtree\\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null) return 0;\\n\\n        if(root.val < low){   // if current node value is less than low than move it to greater side that is right side\\n            return rangeSumBST(root.right, low, high);\\n        }else if(root.val > high){  // if current node value is greater than high than move it to lower side that is left side\\n            return rangeSumBST(root.left, low, high);\\n        }else{  // if it\\'s in range add the current value and repeat for left and right subtree\\n            return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887794,
                "title": "how-do-i-replace-vecdeque-with-vec-allahu-s-greatest-warrior",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdd them up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVist every node withing range and add them to sum before returnign sum\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```rs\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, low: i32, high: i32) -> i32 {\\n        let mut stack: std::collections::VecDeque<Option<Rc<RefCell<TreeNode>>>> = std::collections::VecDeque::new();\\n        stack.push_back(root);\\n\\n        let mut sum:i32 = 0;\\n        while let Some(stack_object) = stack.pop_front() {\\n            let node = stack_object.as_ref().unwrap().replace(TreeNode::new(0));\\n            if node.val <= high && node.val >= low { \\n                sum += node.val; \\n            }\\n        \\n            if node.val > low && node.left.is_some() { stack.push_back(node.left); }\\n            if node.val < high && node.right.is_some() { stack.push_back(node.right); }\\n        }\\n        sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn range_sum_bst(root: Option<Rc<RefCell<TreeNode>>>, low: i32, high: i32) -> i32 {\\n        let mut stack: std::collections::VecDeque<Option<Rc<RefCell<TreeNode>>>> = std::collections::VecDeque::new();\\n        stack.push_back(root);\\n\\n        let mut sum:i32 = 0;\\n        while let Some(stack_object) = stack.pop_front() {\\n            let node = stack_object.as_ref().unwrap().replace(TreeNode::new(0));\\n            if node.val <= high && node.val >= low { \\n                sum += node.val; \\n            }\\n        \\n            if node.val > low && node.left.is_some() { stack.push_back(node.left); }\\n            if node.val < high && node.right.is_some() { stack.push_back(node.right); }\\n        }\\n        sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887681,
                "title": "simple-c-solution-with-comments",
                "content": "# Intuition and Approach\\nWe traverse the tree using a depth first search. If root\\'s data falls inside the range` [low, high]`, then we will add root\\'s data in `sum` else we will traverse left branch and right branch until root is `NULL`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // sum will store the sum of values of all nodes with a value\\n    // in the inclusive range [low, high].\\n    int sum = 0;\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        //Edge Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        //Checking if the root\\'s data lies in the inclusive\\n        // range [low, high] if yes then add the value of \\n        //root\\'s data in sum\\n        if(root->val >= low && root->val <= high){\\n            sum += root->val;\\n        }\\n        //Calling left and right branch\\n        rangeSumBST(root->left,low,high);\\n        rangeSumBST(root->right,low,high);\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:O(n), where n is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n), is a worst case space required by stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // sum will store the sum of values of all nodes with a value\\n    // in the inclusive range [low, high].\\n    int sum = 0;\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        //Edge Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        //Checking if the root\\'s data lies in the inclusive\\n        // range [low, high] if yes then add the value of \\n        //root\\'s data in sum\\n        if(root->val >= low && root->val <= high){\\n            sum += root->val;\\n        }\\n        //Calling left and right branch\\n        rangeSumBST(root->left,low,high);\\n        rangeSumBST(root->right,low,high);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887668,
                "title": "extremely-easy-just-do-one-traversal-c",
                "content": "# Approach\\n- Do any type of binary tree traversal and store the node values.\\n- Iterate over the values and apply the conditions.\\n\\n(This approach is quite lengthy and this question can be done in traversing tree and applying conditions simultaneously.)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   void preorder(TreeNode* root, vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> v;\\n        preorder(root,v);\\n        int ans=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low && v[i]<=high) ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   void preorder(TreeNode* root, vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        vector<int> v;\\n        preorder(root,v);\\n        int ans=0;\\n        for(int i=0; i<v.size();i++){\\n            if(v[i]>=low && v[i]<=high) ans+=v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887584,
                "title": "easy-approach",
                "content": "# Intuition\\nFirst thought that must comes to mind must be to store inorder traversal in case of BST.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Storing inorder traversal \\n2.Then,from low to high range add the available values.\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,ans);\\n       ans.push_back(root->val);\\n        inorder(root->right,ans);\\n        \\n    }\\n\\npublic:\\n\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n//            \\n//      // inorder ->sorted array\\n//     // from low to high elements hai \\n//      //or fir unka sum kralenge\\n            vector<int> ans;\\n            inorder(root,ans);\\n\\n        int sum = 0;\\n        \\n        for (int i : ans) {\\n            if (i >= low && i <= high)\\n            sum += i;\\n        }\\n        \\n        return sum;\\n            \\n    }\\n\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,ans);\\n       ans.push_back(root->val);\\n        inorder(root->right,ans);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2887479,
                "title": "simple-c-recursive",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int RangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        if (root == null)\\n            return sum;\\n        if (root.val >= low && root.val <= high)\\n            sum += root.val;\\n        if (root.val > low)\\n            sum += RangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n            sum += RangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RangeSumBST(TreeNode root, int low, int high) {\\n        int sum = 0;\\n        if (root == null)\\n            return sum;\\n        if (root.val >= low && root.val <= high)\\n            sum += root.val;\\n        if (root.val > low)\\n            sum += RangeSumBST(root.left, low, high);\\n        if (root.val < high)\\n            sum += RangeSumBST(root.right, low, high);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887423,
                "title": "go-recursive-solution-beats-100-naive-and-optimal-solution-explained",
                "content": "1. Naive approach \\n\\nTraverse the entire tree, note the nodes that falls under the range, and add them all together. This is the simplest possible solution with O(N) time complexity and O(N) memory.\\n\\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n        var sum = 0\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := rangeSumBST(root.Left, low, high)\\n\\n        r := rangeSumBST(root.Right, low, high)\\n        return sum + l + r\\n}\\n```\\n\\n2. Optimal Solution\\n\\nNow, can we do better? **YES**.  There are plenty of **unneccesary** work in the previous solution. \\n\\nRemember, it\\'s a **Binary Search Tree**, meaning, the left node is guaranteed to have a smaller value than the root, and the right node is guaranteed to have a greater value than the root. \\n\\nWhy would we want to traverse the **LEFT** subtree if the **low >= root.Val**, similarly, why would we want to traverse the **RIGHT** subtree if **high <= root.Val**?\\n\\nWith these optimizations our avg. time complexity becomes O(logN) on average.\\n\\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n\\n        var sum = 0\\n\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := 0\\n        r := 0\\n\\n        if low <= root.Val {\\n                l = rangeSumBST(root.Left, low, high)\\n        }\\n\\n        if high >= root.Val {\\n                r = rangeSumBST(root.Right, low, high)\\n        }\\n\\n        return sum + l + r\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Binary Search Tree"
                ],
                "code": "```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n        var sum = 0\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := rangeSumBST(root.Left, low, high)\\n\\n        r := rangeSumBST(root.Right, low, high)\\n        return sum + l + r\\n}\\n```\n```\\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\\n        if root == nil {\\n                return 0\\n        }\\n\\n        var sum = 0\\n\\n        if root.Val >= low && root.Val <= high {\\n                sum += root.Val\\n        }\\n\\n        l := 0\\n        r := 0\\n\\n        if low <= root.Val {\\n                l = rangeSumBST(root.Left, low, high)\\n        }\\n\\n        if high >= root.Val {\\n                r = rangeSumBST(root.Right, low, high)\\n        }\\n\\n        return sum + l + r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887003,
                "title": "5-lines-very-easy-solution-using-normal-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\tdef rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n\\t\\treturn self.helper(root,0,L,R)\\n\\n\\tdef helper(self,node,res,L,R):\\n\\t\\tif not node:\\n\\t\\t\\treturn res\\n\\t\\tif node.val>=L and node.val<=R:\\n\\t\\t\\tres+=node.val\\n\\t\\tres=self.helper(node.left,res,L,R)\\n\\t\\tres=self.helper(node.right,res,L,R)\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n\\tdef rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:\\n\\t\\treturn self.helper(root,0,L,R)\\n\\n\\tdef helper(self,node,res,L,R):\\n\\t\\tif not node:\\n\\t\\t\\treturn res\\n\\t\\tif node.val>=L and node.val<=R:\\n\\t\\t\\tres+=node.val\\n\\t\\tres=self.helper(node.left,res,L,R)\\n\\t\\tres=self.helper(node.right,res,L,R)\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886533,
                "title": "easy-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n\\n        if(root->val < low)\\n            return rangeSumBST(root->right , low , high);\\n            \\n        if(root->val >high)\\n            return rangeSumBST(root->left , low , high);\\n        \\n        return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if(!root)\\n            return 0;\\n\\n        if(root->val < low)\\n            return rangeSumBST(root->right , low , high);\\n            \\n        if(root->val >high)\\n            return rangeSumBST(root->left , low , high);\\n        \\n        return root->val + rangeSumBST(root->left , low , high) + rangeSumBST(root->right , low , high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886501,
                "title": "2-lines-hot-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        return ((root.val>=low && root.val<=high)?root.val:0)+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null) return 0;\\n        return ((root.val>=low && root.val<=high)?root.val:0)+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886238,
                "title": "range-sum-of-bst-100ms-solution-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing with any order Traversal and Cheaking the Condition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) squeue tree:worst case\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n    stack<TreeNode*>st;\\n    st.push(root);\\n    int sum=0;\\n    while(!st.empty()){\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        if(temp->val>=low && temp->val<=high) sum+=temp->val;\\n        if(temp->left!=NULL) st.push(temp->left);\\n        if(temp->right!=NULL) st.push(temp->right);\\n    }\\n    return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n    stack<TreeNode*>st;\\n    st.push(root);\\n    int sum=0;\\n    while(!st.empty()){\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        if(temp->val>=low && temp->val<=high) sum+=temp->val;\\n        if(temp->left!=NULL) st.push(temp->left);\\n        if(temp->right!=NULL) st.push(temp->right);\\n    }\\n    return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886031,
                "title": "simple-dfs-solution-beats-90-python",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = []\\n        if not root:\\n            return 0\\n        def DFS(node):\\n            if node:\\n                if low <= node.val <= high :\\n                    res.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        DFS(root)\\n        return sum(res)\\n\\n```\\n\\n**Upvote if you like the solution.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        res = []\\n        if not root:\\n            return 0\\n        def DFS(node):\\n            if node:\\n                if low <= node.val <= high :\\n                    res.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        DFS(root)\\n        return sum(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885741,
                "title": "simple-3-line-python-java-c-solution",
                "content": "# Intuition\\nA classical Recursion Problem similar to find height and depth of tree.\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if (root == NULL) return 0;\\n\\n        int child = rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n        if (root->val >= low && root->val <= high){\\n            return root->val + child; \\n        }\\n        return child;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if (root == None): return 0\\n\\n        val = root.val if low <= root.val <= high else 0\\n\\n        return val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\\n```Java []\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int val = (low <= root.val && root.val <= high) ? root.val: 0;\\n        return val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right,low, high);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        if (root == NULL) return 0;\\n\\n        int child = rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\\n        if (root->val >= low && root->val <= high){\\n            return root->val + child; \\n        }\\n        return child;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        if (root == None): return 0\\n\\n        val = root.val if low <= root.val <= high else 0\\n\\n        return val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\\n```\n```Java []\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int val = (low <= root.val && root.val <= high) ? root.val: 0;\\n        return val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right,low, high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885585,
                "title": "3-approaches-faster-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Pre order Traversal : root -> left -> right\\n- Check if values of these nodes lie in given range \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0\\n        \\n        ans = 0\\n        if low <= root.val <= high:\\n            ans += root.val\\n        ans += self.rangeSumBST(root.left,low,high)\\n        ans += self.rangeSumBST(root.right,low,high)\\n\\n        return ans \\n        \\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        return (root.val if low <= root.val <= high else 0) + \\\\\\n                self.rangeSumBST(root.left,low,high) + \\\\\\n                self.rangeSumBST(root.right,low,high)\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In a BST, value of left node < value of root < value of right node\\n- So, we will take advantage of the same. \\n- Add the value of left node only if root val > low, because, if root val < low then left nodes value will also be less. \\n- Add the value of right node only if root val < high , because, if root val > high then right nodes value will also be more.\\n- Doing this just to reduce the number of iterations \\n\\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        # Taking advantage of BST\\n        if not root:\\n            return 0 \\n        \\n        ans = 0\\n        ans += root.val if low <= root.val <= high else 0 \\n        if root.val > low:\\n            ans += self.rangeSumBST(root.left,low,high)\\n        if root.val < high:\\n            ans += self.rangeSumBST(root.right,low,high)\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0\\n        \\n        ans = 0\\n        if low <= root.val <= high:\\n            ans += root.val\\n        ans += self.rangeSumBST(root.left,low,high)\\n        ans += self.rangeSumBST(root.right,low,high)\\n\\n        return ans \\n        \\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        if not root:\\n            return 0 \\n        \\n        return (root.val if low <= root.val <= high else 0) + \\\\\\n                self.rangeSumBST(root.left,low,high) + \\\\\\n                self.rangeSumBST(root.right,low,high)\\n```\n```\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n\\n        # Taking advantage of BST\\n        if not root:\\n            return 0 \\n        \\n        ans = 0\\n        ans += root.val if low <= root.val <= high else 0 \\n        if root.val > low:\\n            ans += self.rangeSumBST(root.left,low,high)\\n        if root.val < high:\\n            ans += self.rangeSumBST(root.right,low,high)\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885572,
                "title": "range-sum-easy-java-solution-o-n",
                "content": "# Intuition\\nWe can do traversal either (Pre , Post or IN) does\\'nt matter.\\n\\n# Approach\\nWe need to just check the current node lies in between low and high inclusive edge.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(h)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n     if(root == null) \\n        return result;\\n        \\n        if(root.val == low || root.val == high || (root.val>low) && (root.val<high)){\\n            result+=root.val;\\n        }\\n        rangeSumBST(root.left, low, high);\\n        rangeSumBST(root.right, low, high);\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n     if(root == null) \\n        return result;\\n        \\n        if(root.val == low || root.val == high || (root.val>low) && (root.val<high)){\\n            result+=root.val;\\n        }\\n        rangeSumBST(root.left, low, high);\\n        rangeSumBST(root.right, low, high);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885555,
                "title": "video-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVisit all the nodes. Use one of the traversal methods. I used DFS (preOrder traversal) to solve the problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://youtu.be/ENL_c3n9BCU\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nThe Code below is a more optimized solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); // value of nodes to the left sub tree is always less than the root node\\n        if(node.val < high) dfs(node.right); // value of nodes to the right sub tree is always greater than the root node\\n    }\\n    dfs(root);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nvar rangeSumBST = function(root, low, high) {\\n    let sum = 0;\\n\\n    let dfs = function(node) {\\n        if (!node) return;\\n        if (node.val >= low && node.val <= high) sum += node.val;\\n        f(node.val > low) dfs(node.left); // value of nodes to the left sub tree is always less than the root node\\n        if(node.val < high) dfs(node.right); // value of nodes to the right sub tree is always greater than the root node\\n    }\\n    dfs(root);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2885529,
                "title": "java-using-complete-tree-traversal",
                "content": "# Intuition\\nTraverse the entire tree, but add only those nodes whose values fall within the range.\\n\\n# Approach\\nDeclare a global variable \\'sum\\' to store the range sum.\\nTraverse the tree using DFS.\\nIn each recursion, check if the node value is in between high and low. If so, add node value to \\'sum\\'.\\nReturn \\'sum\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - where n is the total number of nodes in the tree\\n\\n- Space complexity:\\nAverage case - log(n) [stack space used by recursive calls]\\nWorst case - O(n) if the tree is completely skewed.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        traverse(root, low, high);\\n        return sum;\\n    }\\n\\n    void traverse(TreeNode node, int low, int high){\\n        if(node == null){\\n            return;\\n        }\\n        if(node.val >= low && node.val <= high){\\n            sum += node.val;\\n        }\\n\\n        traverse(node.left, low, high);\\n        traverse(node.right, low, high);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        sum = 0;\\n        traverse(root, low, high);\\n        return sum;\\n    }\\n\\n    void traverse(TreeNode node, int low, int high){\\n        if(node == null){\\n            return;\\n        }\\n        if(node.val >= low && node.val <= high){\\n            sum += node.val;\\n        }\\n\\n        traverse(node.left, low, high);\\n        traverse(node.right, low, high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564692,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565457,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1566300,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565640,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568256,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568153,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568258,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568194,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568158,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708160,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1564692,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565457,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1566300,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1565640,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568256,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568153,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568258,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568194,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568158,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708160,
                "content": [
                    {
                        "username": "Letitia_Xi",
                        "content": "I was confused about it for a while, hope it can help. So for the first example, it is 7+10+15=32, 5 is in the path but not counted."
                    },
                    {
                        "username": "coder_abhi0713",
                        "content": "We have to print only between the range of  7 and 15 including both as well So thats why 5 is not counted for solution - [10,5,15,3,7,null,18] = 7 + 10 + 15 = 32"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "onesmus1024",
                        "content": "[@noob_nishi](/noob_nishi) Nice explanation kindly contact  molyneww@gmail.com for a link up"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "ranajay206",
                        "content": "Recall BST\\'s property that elements of left subtree are lower than root and right subtree are higher than root.  From this property you can solve this problem ..  "
                    },
                    {
                        "username": "eminesa",
                        "content": "Our range is start 7 to end of 15 and 5 is not between 7 and 15 so we will not add our range. I hope it will help you :) "
                    },
                    {
                        "username": "shaniko",
                        "content": "Hi I m having a hard time on what the question is asking.  I wish it was more clear. Would someone please help me understand. I know how to draw the tree from the array. I just can understand the question"
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution for this question here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low) to high(till u encounter element high) including them .\\n\\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "Traverse the tree in any order(inorder,preorder,postorder) and take a sum variable and add all the values that are greater than equal to 7 but less than equal to 15.... i .e. 7,10,15  => 32"
                    },
                    {
                        "username": "NGC7023",
                        "content": "The type of root is TreeNode, but the input parameter \\'root\\' is a list.\\nHow the BST is initialized? Why node.left and node.right can be set to the right number?\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/range-sum-of-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sooyaaa__",
                        "content": "Hihi, this is my solution in C++\\n```\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int low, int high, int &sum) {\\n        if(root == nullptr) return;\\n        if(root->val >= low && root->val <= high) sum += root->val;\\n        traversal(root->left, low, high, sum);\\n        traversal(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int res = 0;\\n        traversal(root, low, high, res);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bojangles217",
                        "content": "Can anyone properly explain this?\\n\\nThanks."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "Question statement is simple as it is, you may be having doubts about why 5 is not being added to the solution. It is because 5 is not in the range between low(7) and high(15).\nyou just have to sum the values of nodes that connect low to high (inclusively) but don't add the node value which does not belong to the given Range.\nI hope you understood now.\n"
                    },
                    {
                        "username": "tanny0303",
                        "content": "While traversing through the tree in inorder manner you need to add values of elements from low(when u encounter element low)  to high(till u encounter element high) including them . \\n"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32..."
                    },
                    {
                        "username": "Linnnnn",
                        "content": "I realized the Example.1 Tree like this\\uFF1A\\n\\n![image](https://assets.leetcode.com/users/gabbylin/image_1559206800.png)\\n\\nWhy is range sum between the 7 and 15 is 32 ?\\nNo matter how I add, the Output is not 32.\\n"
                    },
                    {
                        "username": "ranajay206",
                        "content": "the value in [7,15] are 7,10 & 15 . so thire sum = 7+10+15=32 . which is equal to output ."
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...\\n(Remember not to add 5 you may think it lies in the path but thats not the correct visualization) so add values that are equal to 7 and greater than 7 but smaller than 15 ."
                    },
                    {
                        "username": "mikeshmistry",
                        "content": "Input: root = [10,5,15,3,7,null,18], L = 7, R = 15\\nOutput: 32\\n\\nHow did we get 32 ??"
                    },
                    {
                        "username": "Ruildo",
                        "content": "your code must add numbers from the Array from 7 to 15, that means it would be 7,10,15. 7+10+15 = 32"
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "add all the value in range l to r available  there."
                    },
                    {
                        "username": "itsmesohit",
                        "content": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null ) return 0;\n        if(root.left ==null && root.right == null) return root.val;\n        return travers(root, low, high, 0);\n    }\n    int travers(TreeNode root, int l, int h, int sum ){\n        if(root == null ) return 0;\n        int some = 0;\n        if(root.val >= l && root.val <= h){\n            some = root.val;\n        }\n        int lsum = travers(root.left, l,h,sum);\n        int rsum = travers(root. Right, l ,h, sum);\n        return lsum + rsum+ some;\n    }\n}"
                    },
                    {
                        "username": "hey_mannu",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32...."
                    },
                    {
                        "username": "joemer123",
                        "content": "From the example given, can you help me figure out how the tree is made. Im having problems visualizing it"
                    },
                    {
                        "username": "aditya_astrophysics",
                        "content": "it\\'s just level-order traversal."
                    },
                    {
                        "username": "SheinmanMichael",
                        "content": "I wrote an in-depth solution here: https://michaelsheinman.medium.com/leetcode-tree-questions-what-you-should-know-dedab7bf4b47"
                    },
                    {
                        "username": "antonybstack",
                        "content": "I found a solution, but I want to recreate the solution on an IDE to save. The method takes TreeNode root as the first parameter, but TreeNode object isnt an array, it\\'s int. So how does the input work on the leetcode browser, because it looks like root is an array. Thanks for any help"
                    },
                    {
                        "username": "JadeEye",
                        "content": "I think you may have got the answer by now. If not, the leetcode has other helper functions in solution class or the main file itself, which parses the array list and then converts it into a valid binary (search) tree. If it was a part of the question itself, it would be redundant"
                    },
                    {
                        "username": "avnishwork99",
                        "content": "class Solution {\\n    //Taking a global int to store the sum\\n    int sum = 0;\\n    //traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null)\\n            return 0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n            rangeSumBST(root.left,low,high);\\n            rangeSumBST(root.right,low,high);\\n        }  \\n        if(root.val<low)\\n            rangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\n        else if(root.val>high)\\n            rangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\n        return sum;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1569696,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1569538,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1750570,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708348,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708107,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1574985,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1574286,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1573324,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1572624,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1708189,
                "content": [
                    {
                        "username": "SugumarVenkatesan",
                        "content": "I am getting 37 as the answer:\\n\\n15+10+5+7 = 37.\\n\\nPlease explain how to calculate to get 32 as the answer."
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "brother the is 5 which you have added by mistake 5 is not in the given range, so exclude seven.\\ncheck for the test case which is adding 5 ( low>root->val ).\\nHope you have got the answer.\\n"
                    },
                    {
                        "username": "rohitsp927",
                        "content": "You need to sum up all the values that lie between 7 and 15 including 7 & 15 so the values are :- [7,10,15] and their sum = 32."
                    },
                    {
                        "username": "rameshwarbhand3",
                        "content": "your range is 7 and 15, so 5 not include it you get 32 as output."
                    },
                    {
                        "username": "asldev",
                        "content": "the Sum should in the range(7, 15) inclusive. Therefore it would be 15 + 10 + 7 = 32. We will count 5 because it is less than 7;"
                    },
                    {
                        "username": "Yamyao",
                        "content": "The testcase is passed while the same input goes to wrong answer after submit.Anyone helps me?\\n![image](https://assets.leetcode.com/users/yamyao/image_1561024266.png)\\n\\n"
                    },
                    {
                        "username": "shadab034",
                        "content": "Try this solution\\nint x = 0, y = 0;\\n        if(root != NULL){\\n            if((root->val >= low) && (root->val <= high)){\\n                x = rangeSumBST(root->left,low,high);\\n                y = rangeSumBST(root->right,low,high);\\n                return x + y + root->val;\\n            }\\n            else if(root->val < low){\\n                x = 0;\\n                y = rangeSumBST(root->right,low,high);\\n                return y;\\n            }\\n            else if(root->val > high){\\n                x = rangeSumBST(root->left,low,high);\\n                y = 0;\\n                return x;\\n            }\\n        }\\n        return 0;"
                    },
                    {
                        "username": "kaushik552k",
                        "content": "public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        if(root.val<=high && root.val>=low)\\n            sum+=root.val;\\n        return sum+rangeSumBST(root.left,low,high)+rangeSumBST(root.right,low,high);\\n}"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "in each recursive call, sum again initialize to 0,so instead of sum+=root.val , sum=root.val is also true;"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "The intuition to solve this problem is to Traverse the entire tree by doing a BFS, at each iteration of the BFS, add the current node\\'s value to your running sum if its value is between L and R (inclusive). Then check if the current node has a left child and if its value could be within the range of L, if it could be add the left child to the queue to be processed. Then check if the current node has a right child and if its value could be within the range of R, if it could be add the right child to the queue to be processed. Once your BFS is finished, return your sum."
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Posting some tips here, hopefully it helps\\n- Array can be used to represent a tree structure. It has nothing to do with this problem. Take the root node and work off that.\\n- Given a low and a high point, it asks for the sum of all numbers in between. If there\\'s a node happens to have same value as the endpoints, they are included, aka [low, high]\\n- It\\'s basically asking to traverse a tree. Recursion is probly the best option, unless you want to achieve the peak performance, then go with a loop. lol\\nGood luck!"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/edb9bfb6-a580-49a0-8018-dfb975fee753_1614383016.3246884.png)\\n"
                    },
                    {
                        "username": "Pranshu1sati",
                        "content": "class Solution {\n    int sum =0;\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null) return 0;\n        if(root.val>=low && root.val <= high){\n            rangeSumBST(root.left,low,high);\n           System.out.println(root.val);\n                sum += root.val;\n            rangeSumBST(root.right,low,high);\n        }\n        if(root.val<low){\n            rangeSumBST(root.left,low,high);\n        }\n        else{\n            rangeSumBST(root.right,low,high);\n        }\n        return sum;\n    }\n}\nSame code runs perfectly fine on local enviornment on vscode.\nI don'y know how to share pictures but i'll post links to my local code plz check it out and help me plzzz\n\n https://imgur.com/a/eW8O9xf"
                    },
                    {
                        "username": "naryshkov",
                        "content": "I have the same data in the test case and in the submission section but have different results. How is it possible?\\n![image](https://assets.leetcode.com/users/images/fc02d448-bc6b-46b4-bf54-9fa604482281_1598552769.6714475.png)\\n"
                    },
                    {
                        "username": "hassansmallah",
                        "content": "after lots of searching, i found out that 5 is lower than \\'7\\' that\\'s why we dont count it in!\\ndescription is very bad of this task!\\n\\ncheers"
                    },
                    {
                        "username": "Joey1412",
                        "content": "What\\'s wrong with it?\\nthe result of \\'runcode\\' and result of \\'submit\\' with the same input have different outputs??\\nwhy????\\n\\n![image](https://assets.leetcode.com/users/joey1412/image_1555382053.png)\\n\\n"
                    },
                    {
                        "username": "AkashSharma_",
                        "content": "Easy Recursive Java solution\\nclass Solution {\\n    public static int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root==null){\\n            return 0;\\n        }\\n        int sum=0;\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        if(root.val>low){\\n            sum+=rangeSumBST(root.left,low,high);\\n        }\\n        if(root.val<high){\\n            sum+=rangeSumBST(root.right,low,high);\\n        }\\n        return sum;\\n    }\\n} \\nPlease Upvote"
                    }
                ]
            },
            {
                "id": 1884872,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1828371,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1808389,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1806120,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1793409,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1728241,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1710992,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1710160,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709654,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709386,
                "content": [
                    {
                        "username": "itssonaliregude",
                        "content": "Can Anyone explain me why this is not woking ??\\nclass Solution {\\n    \\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         int sum = 0 ;\\n        \\n        helper(root ,low , high, sum );\\n        return sum;\\n    }\\n    public void helper(TreeNode root , int low, int high,int sum){\\n       if(root == null) return;\\n       \\n       if(root.val >= low && root.val <= high){\\n        sum = sum + root.val;\\n       }\\n       \\n      helper(root.left  , low , high ,sum);\\n      helper(root.right , low , high ,sum);\\n    }\\n}"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "try sending Treenode* root rather than Treenode root"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "If the range is inclusive then for Example 2 since the root is 10 and all values are asked inclusive should the correct equation be 6+10+10=26 instead of 6+7+0=23?"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "values in range of 6 to 10 are 6,7 and 10 thus sum=6+7+10=23"
                    },
                    {
                        "username": "X_Yashu",
                        "content": "int res=0;\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\n       if(root==null)return res;\\n       if(root.val >=low && root.val<=high)res+=root.val;\\n\\n        rangeSumBST(root.left,low,high);\\n        rangeSumBST(root.right,low,high);\\n        return res;\\n    }\\n\\ni am litte bit confuse about recursive call "
                    },
                    {
                        "username": "marcuskim1989",
                        "content": "I think this description should specify that the values `low` and `high` themselves are actually in the tree"
                    },
                    {
                        "username": "dhruv0911",
                        "content": "Recursive Java Solution Using a global variable\\n\\nclass Solution {\\n    int sum=0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n         ans(root,low,high);\\n         return sum;\\n    }\\n    public void ans(TreeNode root, int low, int high){\\n        if(root==null){\\n             return;\\n        }\\n        if(root.val>=low && root.val<=high){\\n            sum+=root.val;\\n        }\\n        ans(root.left,low,high);\\n        ans(root.right,low,high);\\n\\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Infox_92",
                        "content": "class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int L, int R) {\\n        int s = 0;\\n\\t\\t\\t\\t\\n        if (root == NULL) return s;\\n        if (root->val >= L && root->val <= R) s += root->val;\\n        if (root->val > L) s += rangeSumBST(root->left, L, R);\\n        if (root->val < R) s += rangeSumBST(root->right, L, R);\\n\\t\\t\\t\\t\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "danxb13",
                        "content": "Im a bit lost on how the question chooses \\'low=7\\' and \\'high=15\\' instead of \\'low=3\\' and \\'high=18\\' - sorry for the out of the box question."
                    },
                    {
                        "username": "AMerrill",
                        "content": "The low and high are added inputs to restrict the output sum. They do not represent the min and max of the BST."
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript Based Unique solution\\nConvert root node into string and replace all unwanted character.\\nThen convert them into array and print the range element sum"
                    },
                    {
                        "username": "Uma_06",
                        "content": " `class Solution {\\npublic:\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        queue<TreeNode*> q;q.push(root);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node =q.front(); q.pop();\\n            if(node->val<=high && node->val>=low){sum += node->val;}\\n            if(node->left){q.push(node->left);}\\n            if(node->right){q.push(node->right);}\\n        }\\n        return sum;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1709084,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1709076,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708946,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708852,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708813,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708734,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708728,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708719,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708628,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708620,
                "content": [
                    {
                        "username": "Pianist_01",
                        "content": "\\nclass Solution {\\npublic:\\n    \\n    \\n    int sum(TreeNode* root,int low,int high){\\n\\nint total=0;\\n\\n        if(root==NULL){\\n\\nreturn total;\\n\\n        }\\n\\n\\n           if(root->val >=low &&  root->val <=high)\\n               total+=root->val;\\n\\n          \\n        int s1 =   sum(root->right,low,high);\\n\\n           \\n             int s2 =      sum(root->left,low,high);\\n\\n           \\n\\nreturn total+s1+s2;\\n\\n    }\\n    \\n    \\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n\\n\\n         \\n        \\n        int sumn = sum(root,low,high);\\n\\n        return sumn;\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "HelmiDev",
                        "content": "First focus on just what do u have now which is the root:\\nimagine we only have the root in our BST so if root.value in [low , high ] we return root.value else we return just 0.\\nso we just need to repeat this to all nodes using recursion"
                    },
                    {
                        "username": "jagdeepsgh9",
                        "content": "I was trying different methods to solve the question to compare space and the complexity and in one of the methods I used a static variable to store the sum. however, this is not giving me desired results. It is adding the result from previous test case to next. How do I report this ? or am I  doing something wrong. Below is my code\\nclass Solution {\\n\\n    static int count =0;\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root==null)\\n            return count;\\n        if(root.val >=low && root.val <=high){\\n            count += root.val;\\n         }\\n        if (root.val>low)\\n            rangeSumBST(root.left, low, high);\\n        if (root.val<high)\\n            rangeSumBST(root.right, low, high);\\n\\n         return count;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Bhagyaaa_15",
                        "content": "*JAVA Recursion*\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if (root.val >= low && root.val <= high) sum += root.val;\\n        if (root.val > low) sum += rangeSumBST(root.left, low, high);\\n        if (root.val < high) sum += rangeSumBST(root.right, low, high);\\n\\n        return sum;\\n    }\\n} "
                    },
                    {
                        "username": "stark369",
                        "content": "// solution in c++;\\nint rangeSumBST(TreeNode* root, int Low, int high) {\\n        if(!root) return 0;\\n        if(root->val >=Low &&  root->val<=high){\\n            return root->val+ rangeSumBST(root->left,Low,high) +rangeSumBST(root->right,Low,high);\\n        }\\n        else if(root->val<Low){\\n            return rangeSumBST(root->right,Low,high);\\n        }\\n        else{\\n            return rangeSumBST(root->left,Low,high);\\n        }\\n    }"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\n//Taking a global int to store the sum\\nint sum = 0;\\n//traverse the tree and use the property of the binary search tree, i.e, inorder traveral of tree would give you the sorted data\\npublic int rangeSumBST(TreeNode root, int low, int high) {\\nif(root==null)\\nreturn 0;\\nif(root.val>=low && root.val<=high){\\nsum+=root.val;\\nrangeSumBST(root.left,low,high);\\nrangeSumBST(root.right,low,high);\\n}\\nif(root.val<low)\\nrangeSumBST(root.right,low,high); //only right because root val is low so left is always smaller and we can neglect it\\nelse if(root.val>high)\\nrangeSumBST(root.left,low,high); //only left because root val is low so right is always higher and we can neglect it\\nreturn sum;\\n}\\n}"
                    },
                    {
                        "username": "govindbanura",
                        "content": "pls share solution in Solutions tab"
                    },
                    {
                        "username": "govindbanura",
                        "content": "This code is showing runtime error as \"local variable 'total' referenced before assignment\" but I'm able to use low and high in the dfs() function. Why is that?\ntotal variable should be accessible in dfs() function too?\n\n`def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:`\n`.    total = 0`\n`.    def dfs(node):`\n`.    .    ...`\n`.    .   if node.val >= low and node.val <= high:`\n`.    .        total += node.val `\n\n "
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "Because you assign to `total` in `dfs`, `total` in `rangeSumBST` and `total` in `dfs` are different variables.  To fix this add `nonlocal total` inside `dfs`.  Here is some extra read about this\\nhttps://stackoverflow.com/questions/1261875/python-nonlocal-statement-keyword"
                    },
                    {
                        "username": "singhal97",
                        "content": "Hey can anyone tell why bst done very slow in this approach. I done bfs approach and only beats 5%. Also it couldn\\'t seem that by applying dfs it would give very good complexity."
                    },
                    {
                        "username": "iamtj45",
                        "content": "\\n int inorder(struct TreeNode* root,int *arr1){\\n     static int i=0;\\n     if(root==NULL){return ; }else{\\n \\n   // *returnSize=*returnSize+1;\\n    \\n    inorder(root->left,arr1);\\n  arr1[(i)++] = root->val;\\n    inorder(root->right,arr1);\\n\\n    }\\n    return i ;\\n }\\nint rangeSumBST(struct TreeNode* root, int low, int high){\\nint p,j,k,l,m,sum=low+high;\\nint *arr1=malloc(1000*sizeof(int));\\n\\n  k=inorder(root,arr1);\\nfor(p=0;p<k-1;p++){\\n    if(arr1[p]>low && arr1[p]<high){\\n        sum+=arr1[p];\\n    }\\n}\\nreturn sum;\\n}\\n\\nhelp me as above code passes only 20 test cases"
                    },
                    {
                        "username": "EGP-M",
                        "content": "Is it possible to calculate the \"average\" time complexity in this question?\nAlmost all the questions on Leetcode only talks about worst case, which use big-O, but in one of interviews I've gotten before, they asked me \"average\" time complexity for each question they asked, and I didn't know how to answer them.\nappreciate it if anyone can share learning resources or tips to calculate \"average\" time complexity."
                    }
                ]
            },
            {
                "id": 1708508,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708395,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708376,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708264,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708252,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708244,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708237,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708236,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708204,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            },
            {
                "id": 1708188,
                "content": [
                    {
                        "username": "kunaljainwin",
                        "content": "Well so many people didn\\'t got the question while it looks clear cut."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        self.result = 0\\n        def dfs(node):\\n            if not node:\\n               return None\\n            if low <= node.val <= high:\\n                self.result += node.val\\n            if node.val > low:\\n                dfs(node.left)\\n            if node.val < high:\\n                dfs(node.right)\\n        dfs(root)\\n        return self.result"
                    },
                    {
                        "username": "Hari0610",
                        "content": "easy cpp solution in O(N) time complexity \\n\\'\\'\\'\\nint rangeSumBST(TreeNode* root, int low, int high) {\\n        if( root == NULL )\\n            return 0;\\n        int sum = 0;\\n        if( root->val <= high && root->val >= low )\\n            sum += root->val;\\n        sum += rangeSumBST(root->left, low, high );\\n        sum += rangeSumBST(root->right, low, high );\\n        return sum;\\n    }\\n\\'\\'\\'"
                    },
                    {
                        "username": "Ak_15",
                        "content": "Im getting 10 as the output everytime when i return the sum using recursion inOrderTraversing\nint sum=0;\n        \n        if(root==null)\n        {\n            return 0;\n        }\n        if(root.val<=low && root.val>=high))\n        {\n            sum+=root.val;\n        }\n        preOrderTraversing(root.left,low,high);\n        preOrderTraversing(root.right,low,high);\n        return sum;\n\nThis code is inside the preOrderTraversing method\nHELP MEE GUYSSSSSSSSSSSSSSSSSSSSSSS\n `"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Arun kumar](/Ak_15) \\n1. Check condition LOW<= val <= HIGH\\n2. Recall sum\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        int sum=0;            \\n        if(root!=null){ \\n            if(root.val>=low && root.val<=high) {sum+=root.val;}\\n            sum+= rangeSumBST(root.left,low,high);\\n            sum+= rangeSumBST(root.right,low,high);\\n        }        \\n        return sum;     \\n    }\\n}"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "1. Signs inside root.val<=low && root.val>=high should be inverted. You have to add current val only if it is inside [low, high], not otherwise.\\n2. Returned results from preOrderTraversing should be added to the sum."
                    },
                    {
                        "username": "harshadi",
                        "content": " `# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\\n        sum = 0\\n        def dfs(node):\\n            nonlocal sum\\n            if node is None:\\n                return sum\\n            if dfs(node.left): dfs(node.left)\\n            if node.val<= high and node.val >= low:\\n                sum+= node.val\\n            if dfs(node.right): dfs(node.right)\\n        dfs(root)\\n        return sum`"
                    },
                    {
                        "username": "Msey",
                        "content": "[VIDEO](https://www.youtube.com/watch?v=edfGASf_QxE) For beginners:\n"
                    },
                    {
                        "username": "jisan047",
                        "content": "In this problem we just need to traverse over the tree in any order(inorder, preorder, postorder). And check if current node\\'s value is in the range given with the input. If it is in the range just added the value to the result and continue traversing. "
                    },
                    {
                        "username": "itsmesohit",
                        "content": "Here\\'s my solution using recursion\\n\\n\\n\\nclass Solution {\\n    public int rangeSumBST(TreeNode root, int low, int high) {\\n        if(root == null ) return 0;\\n        if(root.left ==null && root.right == null) return root.val;\\n        return travers(root, low, high, 0);\\n    }\\n    int travers(TreeNode root, int l, int h, int sum ){\\n        if(root == null ) return 0;\\n        int some = 0;\\n        if(root.val >= l && root.val <= h){\\n            some = root.val;\\n        }\\n        int lsum = travers(root.left, l,h,sum);\\n        int rsum = travers(root. Right, l ,h, sum);\\n        return lsum + rsum+ some;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "nayansinghal23",
                        "content": "// TIME COMPLEXITY :- O(N)\\n// SPACE COMPLEXITY :- O(N)\\n\\n/*\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int low, int high, int & sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        solve(root->left, low, high, sum);\\n        if(root->val >= low && root->val <= high) {\\n            sum += root->val;\\n        }\\n        solve(root->right, low, high, sum);\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        int sum = 0;\\n        solve(root, low, high, sum);\\n        return sum;\\n    }\\n};\\n*/"
                    },
                    {
                        "username": "MuleHakim",
                        "content": "Implement using DFS\\nI used recursive approach to implement DFS.\\nIf recursively travel though the tree if any value falls outside the range, for example if value is less than \"low\", then we can conclude that our answer is there somewhere in right branch of the tree."
                    }
                ]
            }
        ]
    }
]