[
    {
        "title": "Remove Duplicates from Sorted List",
        "question_content": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n&nbsp;\nExample 1:\n\nInput: head = [1,1,2]\nOutput: [1,2]\n\nExample 2:\n\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 300].\n\t-100 <= Node.val <= 100\n\tThe list is guaranteed to be sorted in ascending order.",
        "solutions": [
            {
                "id": 28625,
                "title": "3-line-java-recursive-solution",
                "content": "This solution is inspired by renzid https://leetcode.com/discuss/33043/3-line-recursive-solution\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null || head.next == null)return head;\\n            head.next = deleteDuplicates(head.next);\\n            return head.val == head.next.val ? head.next : head;\\n    }\\n\\nEnjoy!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "This solution is inspired by renzid https://leetcode.com/discuss/33043/3-line-recursive-solution\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null || head.next == null)return head;\\n            head.next = deleteDuplicates(head.next);\\n            return head.val == head.next.val ? head.next : head;\\n    }\\n\\nEnjoy!",
                "codeTag": "Unknown"
            },
            {
                "id": 28614,
                "title": "my-pretty-solution-java",
                "content": "    public class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            ListNode list = head;\\n             \\n             while(list != null) {\\n            \\t if (list.next == null) {\\n            \\t\\t break;\\n            \\t }\\n            \\t if (list.val == list.next.val) {\\n            \\t\\t list.next = list.next.next;\\n            \\t } else {\\n            \\t\\t list = list.next;\\n            \\t }\\n             }\\n             \\n             return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            ListNode list = head;\\n             \\n             while(list != null) {\\n            \\t if (list.next == null) {\\n            \\t\\t break;\\n            \\t }",
                "codeTag": "Java"
            },
            {
                "id": 28621,
                "title": "simple-iterative-python-6-lines-60-ms",
                "content": "    def deleteDuplicates(self, head):\\n        cur = head\\n        while cur:\\n            while cur.next and cur.next.val == cur.val:\\n                cur.next = cur.next.next     # skip duplicated node\\n            cur = cur.next     # not duplicate of current node, move to next node\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def deleteDuplicates(self, head):\\n        cur = head\\n        while cur:\\n            while cur.next and cur.next.val == cur.val:\\n                cur.next = cur.next.next     # skip duplicated node\\n            cur = cur.next     # not duplicate of current node, move to next node\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 28663,
                "title": "easy-to-understand-c-solution",
                "content": "no need to initialize a new node\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* cur = head;\\n            while(cur) {\\n            \\twhile(cur->next && cur->val == cur->next->val) {\\n            \\t\\tcur->next = cur->next->next;\\n            \\t}\\n            \\tcur = cur->next;\\n            }\\n            return head;\\n        }",
                "solutionTags": [],
                "code": "no need to initialize a new node\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* cur = head;\\n            while(cur) {\\n            \\twhile(cur->next && cur->val == cur->next->val) {\\n            \\t\\tcur->next = cur->next->next;\\n            \\t}\\n            \\tcur = cur->next;\\n            }\\n            return head;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3257316,
                "title": "c-python-c-java-easiest-solution-o-n-time",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while (temp&&temp->next)\\n        {\\n            if (temp->next->val==temp->val)\\n            {\\n                temp->next=temp->next->next;\\n                continue;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        temp = head\\n        while (temp and temp.next):\\n            if (temp.next.val == temp.val):\\n                temp.next = temp.next.next\\n                continue\\n            temp = temp.next\\n        return head\\n        \\n```\\n\\n# C\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    struct ListNode* temp=head;\\n    while (temp&&temp->next)\\n    {\\n        if (temp->next->val==temp->val)\\n        {\\n            temp->next=temp->next->next;\\n            continue;\\n        }\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null && temp.next != null)\\n        {\\n            if (temp.next.val==temp.val)\\n            {\\n                temp.next=temp.next.next;\\n                continue;\\n            }\\n            temp=temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while (temp&&temp->next)\\n        {\\n            if (temp->next->val==temp->val)\\n            {\\n                temp->next=temp->next->next;\\n                continue;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        temp = head\\n        while (temp and temp.next):\\n            if (temp.next.val == temp.val):\\n                temp.next = temp.next.next\\n                continue\\n            temp = temp.next\\n        return head\\n        \\n```\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    struct ListNode* temp=head;\\n    while (temp&&temp->next)\\n    {\\n        if (temp->next->val==temp->val)\\n        {\\n            temp->next=temp->next->next;\\n            continue;\\n        }\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null && temp.next != null)\\n        {\\n            if (temp.next.val==temp.val)\\n            {\\n                temp.next=temp.next.next;\\n                continue;\\n            }\\n            temp=temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28730,
                "title": "concise-solution-and-memory-freeing",
                "content": "I noticed that the solutions posted here are too long and complicated. They use unnecessary variables and/or checks etc.\\nThe solution can be much more concise. Here is my solution:\\n\\n    class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode* cur = head;\\n            while (cur) {\\n                while (cur->next && cur->val == cur->next->val)\\n                    cur->next = cur->next->next;\\n                cur = cur->next;\\n            }\\n            return head;\\n        }\\n    };\\n\\n**Note about freeing memory**. We need to free memory when we delete a node. But don't use `delete node;` construct on an interview without discussing it with the interviewer. A list node can be allocated in many different ways and we can use `delete node;` only if we are sure that the nodes were allocated with `new TreeNode(...);`.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode* cur = head;\\n            while (cur) {\\n                while (cur->next && cur->val == cur->next->val)\\n                    cur->next = cur->next->next;\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 943403,
                "title": "python-simple-solution",
                "content": "**Solution 1:**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            while cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            cur=cur.next\\n        return head\\n        \\n```\\n\\n**Solution 2:**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            if cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            while cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            cur=cur.next\\n        return head\\n        \\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur=head\\n        while cur:\\n            if cur.next and cur.next.val==cur.val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28722,
                "title": "javascript-solution",
                "content": "I didn't see many JS solutions, so I thought I'd share\\n\\n<pre>\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n    \\n    while(current) {\\n        if(current.next !== null && current.val == current.next.val) {\\n            current.next = current.next.next;\\n        } else {\\n            current = current.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n</pre>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "I didn't see many JS solutions, so I thought I'd share\\n\\n<pre>\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n    \\n    while(current) {\\n        if(current.next !== null && current.val == current.next.val) {\\n            current.next = current.next.next;\\n        } else {\\n            current = current.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n</pre>",
                "codeTag": "Unknown"
            },
            {
                "id": 314650,
                "title": "c-code-8-ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892275,
                "title": "python3-o-n-beats-95-80-41-ms-simple-with-explanation",
                "content": "# Approach\\n- We first deal with edge case of head being `None` rather than a `ListNode`\\n- Next we create a new variable `curr` to point at our current node, starting with the `head` node\\n- If `curr.next` is another node, we compare `curr.val` and `curr.next.val`\\n    - If the values are the same, we must remove one from the linked list\\n        - We keep the first node and remove the second by updating the first\\'s .next (`curr.next`) to the next node\\'s `.next` (`curr.next.next`)\\n    - If the values differ, we move point `curr` to the next node\\n- We repeat the previous process until the current node does not point to another node, at which point we return `head`, the de-duplicated linked list\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return None\\n\\n        curr = head\\n\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n\\n        return head\\n\\n```\\n\\n## Please upvote if you find this helpful! :D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return None\\n\\n        curr = head\\n\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765793,
                "title": "easy-java-solution-beats-100-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n    ListNode temp = head;\\n        if (head == null)\\n        {\\n            return head;\\n        }\\n        \\n        while (temp.next !=null)\\n        {\\n            if (temp.val != temp.next.val) {\\n                temp = temp.next;\\n            }\\n            else temp.next = temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/c78d9c13-efe2-4e13-a6e9-c5c7c4f16a18_1689361724.747828.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n    ListNode temp = head;\\n        if (head == null)\\n        {\\n            return head;\\n        }\\n        \\n        while (temp.next !=null)\\n        {\\n            if (temp.val != temp.next.val) {\\n                temp = temp.next;\\n            }\\n            else temp.next = temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414474,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 1 ms, faster than 92.17% of Java online submissions for Remove Duplicates from Sorted List.\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if(head == null || head.next == null)\\n            return head;\\n        // Initialize a pointer curr with the address of head node...\\n        ListNode curr = head;\\n        // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n        while( curr != null && curr.next != null){\\n            // If the value of curr is equal to the value of prev...\\n            // It means the value is present in the linked list...\\n            if(curr.val == curr.next.val){\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr.next = curr.next.next;\\n            }\\n            // Otherwise, we increment the curr pointer...\\n            else{\\n                curr = curr.next; \\n            }\\n        }\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 4 ms, faster than 81.52% of C++ online submissions for Remove Duplicates from Sorted List.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Special case...\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        // Initialize two pointers tmp(slow) and curr(fast)...\\n        ListNode* tmp = head;\\n        ListNode* curr = head->next;\\n        // Traverse all element through a while loop if curr node is not null...\\n        while(curr!=NULL) {\\n            // If the value of curr is equal to the value of tmp...\\n            // It means the value is present in the linked list...\\n            if(tmp->val == curr->val) {\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr=curr->next;\\n            }\\n            // Otherwise, we increment both the pointers.\\n            else {\\n                tmp->next = curr;\\n                tmp = curr;\\n                curr = tmp->next;\\n            }\\n        }\\n        tmp->next = NULL;\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 36 ms, faster than 79.68% of Python online submissions for Remove Duplicates from Sorted List.\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```\\n                    \\n# **JavaScript Solution:**\\nRuntime: 82 ms, faster than 84.86% of JavaScript online submissions for Remove Duplicates from Sorted List.\\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if(head == null || head.next == null)\\n        return head;\\n    // Initialize a pointer curr with the address of head node...\\n    let curr = head;\\n    // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n    while( curr != null && curr.next != null){\\n        // If the value of curr is equal to the value of prev...\\n        // It means the value is present in the linked list...\\n        if(curr.val == curr.next.val){\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr.next = curr.next.next;\\n        }\\n        // Otherwise, we increment the curr pointer...\\n        else{\\n            curr = curr.next; \\n        }\\n    }\\n    return head;        // Return the sorted linked list without any duplicate element...\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // Special case...\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    // Initialize two pointers tmp(slow) and curr(fast)...\\n    struct ListNode* tmp = head;\\n    struct ListNode* curr = head->next;\\n    // Traverse all element through a while loop if curr node is not null...\\n    while(curr!=NULL) {\\n        // If the value of curr is equal to the value of tmp...\\n        // It means the value is present in the linked list...\\n        if(tmp->val == curr->val) {\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr=curr->next;\\n        }\\n        // Otherwise, we increment both the pointers.\\n        else {\\n            tmp->next = curr;\\n            tmp = curr;\\n            curr = tmp->next;\\n        }\\n    }\\n    tmp->next = NULL;\\n    return head;        // Return the sorted linked list without any duplicate element...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if(head == null || head.next == null)\\n            return head;\\n        // Initialize a pointer curr with the address of head node...\\n        ListNode curr = head;\\n        // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n        while( curr != null && curr.next != null){\\n            // If the value of curr is equal to the value of prev...\\n            // It means the value is present in the linked list...\\n            if(curr.val == curr.next.val){\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr.next = curr.next.next;\\n            }\\n            // Otherwise, we increment the curr pointer...\\n            else{\\n                curr = curr.next; \\n            }\\n        }\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Special case...\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        // Initialize two pointers tmp(slow) and curr(fast)...\\n        ListNode* tmp = head;\\n        ListNode* curr = head->next;\\n        // Traverse all element through a while loop if curr node is not null...\\n        while(curr!=NULL) {\\n            // If the value of curr is equal to the value of tmp...\\n            // It means the value is present in the linked list...\\n            if(tmp->val == curr->val) {\\n                // Hence we do not need to include curr again in the linked list...\\n                // So we increment the value of curr...\\n                curr=curr->next;\\n            }\\n            // Otherwise, we increment both the pointers.\\n            else {\\n                tmp->next = curr;\\n                tmp = curr;\\n                curr = tmp->next;\\n            }\\n        }\\n        tmp->next = NULL;\\n        return head;        // Return the sorted linked list without any duplicate element...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if(head == null || head.next == null)\\n        return head;\\n    // Initialize a pointer curr with the address of head node...\\n    let curr = head;\\n    // Traverse all element through a while loop if curr node and the next node of curr node are present...\\n    while( curr != null && curr.next != null){\\n        // If the value of curr is equal to the value of prev...\\n        // It means the value is present in the linked list...\\n        if(curr.val == curr.next.val){\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr.next = curr.next.next;\\n        }\\n        // Otherwise, we increment the curr pointer...\\n        else{\\n            curr = curr.next; \\n        }\\n    }\\n    return head;        // Return the sorted linked list without any duplicate element...\\n};\\n```\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // Special case...\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    // Initialize two pointers tmp(slow) and curr(fast)...\\n    struct ListNode* tmp = head;\\n    struct ListNode* curr = head->next;\\n    // Traverse all element through a while loop if curr node is not null...\\n    while(curr!=NULL) {\\n        // If the value of curr is equal to the value of tmp...\\n        // It means the value is present in the linked list...\\n        if(tmp->val == curr->val) {\\n            // Hence we do not need to include curr again in the linked list...\\n            // So we increment the value of curr...\\n            curr=curr->next;\\n        }\\n        // Otherwise, we increment both the pointers.\\n        else {\\n            tmp->next = curr;\\n            tmp = curr;\\n            curr = tmp->next;\\n        }\\n    }\\n    tmp->next = NULL;\\n    return head;        // Return the sorted linked list without any duplicate element...\\n}\\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Handle special case that the list is empty\\n        if head == None:\\n            return head\\n        # Initialize curr with the address of head node...\\n        curr = head\\n        # Travel the list until the second last node\\n        while curr.next != None:\\n            # If the value of curr is equal to the value of prev...\\n            # It means the value is present in the linked list...\\n            if curr.val == curr.next.val:\\n                # Hence we do not need to include curr again in the linked list...\\n                # So we increment the value of curr...\\n                tmp = curr.next\\n                curr.next = curr.next.next\\n                del tmp\\n            # Otherwise, we increment the curr pointer...\\n            else:\\n                curr = curr.next\\n        return head         # Return the sorted linked list without any duplicate element...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28699,
                "title": "clear-python-code-beat-90",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        first, second = head, head.next if head else None\\n        while second:\\n            if first.val == second.val:\\n                second = second.next\\n                first.next = second\\n            else:\\n                first = second\\n                second = second.next\\n                \\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        first, second = head, head.next if head else None\\n        while second:\\n            if first.val == second.val:\\n                second = second.next\\n                first.next = second\\n            else:\\n                first = second\\n                second = second.next\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023588,
                "title": "java-runtime-0ms-beats-100-00",
                "content": "# Intuition\\nThe problem requires removing duplicates from a sorted singly-linked list. The approach involves iterating through the list and removing duplicates while maintaining the sorted order.\\n\\n# Approach\\n- Initialize a pointer `current` to the head of the linked list to traverse the list.\\n- Start a while loop that continues until `current` reaches the end of the list or `current.next` reaches null.\\n- Inside the loop, compare the value of the current node `current.val` with the value of the next node `current.next.val`.\\n- If the values are equal, it indicates a duplicate node. In this case, update the `next` pointer of the current node `current.next` to skip the next node (remove the duplicate).\\n- If the values are not equal, move the `current` pointer to the next node, continuing the traversal.\\n- Repeat the loop until the end of the list is reached, ensuring that all duplicates are removed while maintaining the sorted order of the remaining nodes.\\n- After the loop, return the modified linked list, which contains no duplicates.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the linked list once, where n is the number of nodes in the list. Each node is examined once to identify and remove duplicates.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of additional memory space for variables, regardless of the size of the input linked list, making its space complexity constant.\\n\\n# Code\\n```java\\nclass Solution {\\n   public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/03822e25-72a1-4bde-a0fe-7a31db27fa1f_1694283728.4735084.webp)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n   public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455325,
                "title": "python-whithot-other-space",
                "content": "use cur to skip node which value are equal, and then return head\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur = head\\n        while(cur):\\n            if(cur.next and cur.next.val==cur.val):\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```\\n\\nRuntime: 36 ms, faster than 94.20% of Python3 online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Remove Duplicates from Sorted List.\\n\\n**If it helps you , Please give me a vote star\\nThanks**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        cur = head\\n        while(cur):\\n            if(cur.next and cur.next.val==cur.val):\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28636,
                "title": "clean-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null) return head;\\n        ListNode dummy=head;\\n        while(dummy.next!=null){\\n            if(dummy.next.val==dummy.val){\\n                dummy.next=dummy.next.next;\\n            }else dummy=dummy.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null) return head;\\n        ListNode dummy=head;\\n        while(dummy.next!=null){\\n            if(dummy.next.val==dummy.val){\\n                dummy.next=dummy.next.next;\\n            }else dummy=dummy.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 344741,
                "title": "my-idiomatic-solution-rust",
                "content": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut h = head;\\n        let mut p1 = h.as_mut().unwrap();\\n        while let Some(p2) = p1.next.as_mut() {\\n            if p1.val == p2.val {\\n                p1.next = p2.next.take();\\n            } else {\\n                p1 = p1.next.as_mut().unwrap();\\n            }\\n        }\\n        h\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut h = head;\\n        let mut p1 = h.as_mut().unwrap();\\n        while let Some(p2) = p1.next.as_mut() {\\n            if p1.val == p2.val {\\n                p1.next = p2.next.take();\\n            } else {\\n                p1 = p1.next.as_mut().unwrap();\\n            }\\n        }\\n        h\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506294,
                "title": "c-and-python-simple-solution",
                "content": "**C++ :**\\n\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\tif(!head) return head;\\n\\tListNode* tmp = head;\\n\\n\\twhile(tmp && tmp -> next)\\n\\t{\\n\\t\\tif(tmp -> val == tmp -> next -> val)\\n\\t\\t\\ttmp -> next = tmp -> next -> next;\\n\\t\\telse\\n\\t\\t\\ttmp = tmp -> next; \\n\\t}\\n\\n\\treturn head;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\ttemp = head\\n\\twhile temp and temp.next:\\n\\t\\tif temp.val == temp.next.val:\\n\\t\\t\\ttemp.next = temp.next.next\\n\\t\\telse:\\n\\t\\t\\ttemp = temp.next\\n\\n\\treturn head\\n```\\n\\n**Like it ? please upvote**\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\tif(!head) return head;\\n\\tListNode* tmp = head;\\n\\n\\twhile(tmp && tmp -> next)\\n\\t{\\n\\t\\tif(tmp -> val == tmp -> next -> val)\\n\\t\\t\\ttmp -> next = tmp -> next -> next;\\n\\t\\telse\\n\\t\\t\\ttmp = tmp -> next; \\n\\t}\\n\\n\\treturn head;\\n}\\n```\n```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\ttemp = head\\n\\twhile temp and temp.next:\\n\\t\\tif temp.val == temp.next.val:\\n\\t\\t\\ttemp.next = temp.next.next\\n\\t\\telse:\\n\\t\\t\\ttemp = temp.next\\n\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 28765,
                "title": "c-concise-solution",
                "content": "        \\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *cur = head;\\n        while (cur && cur->next) {\\n            if (cur->val == cur->next->val)\\n                cur->next = cur->next->next;\\n            else\\n                cur = cur->next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *cur = head;\\n        while (cur && cur->next) {\\n            if (cur->val == cur->next->val)\\n                cur->next = cur->next->next;\\n            else\\n                cur = cur->next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 801992,
                "title": "javascript-solution-83",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    if(!head) return head\\n    var cur = head\\n    \\n    while(cur!=null && cur.next != null) {\\n        if(cur.next.val === cur.val) {\\n            cur.next = cur.next.next\\n        }else {\\n            cur = cur.next\\n        }\\n    }\\n    return head\\n}\\n```\\n\\n**Runtime: 76 ms, faster than 94.64% of JavaScript online submissions for Remove Duplicates from Sorted List.**\\n\\n**Memory Usage: 38.6 MB, less than 44.03% of JavaScript online submissions for Remove Duplicates from Sorted List.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    if(!head) return head\\n    var cur = head\\n    \\n    while(cur!=null && cur.next != null) {\\n        if(cur.next.val === cur.val) {\\n            cur.next = cur.next.next\\n        }else {\\n            cur = cur.next\\n        }\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557910,
                "title": "rust-simple-concise-iterative-0ms-100",
                "content": "This would be a simple thing in C/C++, but with Rust\\'s super strict borrow checking and the general usage model for `Option` wrapping `Box` it\\'s challenging to find a solution that looks concise and is efficient. But I think I have it here. Any \"crustaceans\" who see a better way and want to offer advice, please let me know.\\n\\n```rust\\nimpl Solution {\\n    \\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> \\n    {\\n        let mut curr_opt = head.as_mut();\\n        \\n        while let Some(curr) = curr_opt {\\n            let mut next_opt = curr.next.take();\\n            \\n            while let Some(next) = next_opt.as_mut() {    \\n                if next.val == curr.val \\n                     { next_opt  = next.next.take(); }\\n                else { curr.next = next_opt;  break; }\\n            }\\n            curr_opt = curr.next.as_mut();\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Linked List"
                ],
                "code": "```rust\\nimpl Solution {\\n    \\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> \\n    {\\n        let mut curr_opt = head.as_mut();\\n        \\n        while let Some(curr) = curr_opt {\\n            let mut next_opt = curr.next.take();\\n            \\n            while let Some(next) = next_opt.as_mut() {    \\n                if next.val == curr.val \\n                     { next_opt  = next.next.take(); }\\n                else { curr.next = next_opt;  break; }\\n            }\\n            curr_opt = curr.next.as_mut();\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28745,
                "title": "easy-understand-java-solution",
                "content": " public ListNode deleteDuplicates(ListNode head) {\\n\\n        ListNode temp = head;\\n\\n        while(temp!=null&&temp.next!=null){\\n\\n            if(temp.val == temp.next.val){\\n\\n                temp.next = temp.next.next;\\n            }\\n            else\\n                temp = temp.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": " public ListNode deleteDuplicates(ListNode head) {\\n\\n        ListNode temp = head;\\n\\n        while(temp!=null&&temp.next!=null){\\n\\n            if(temp.val == temp.next.val){\\n\\n                temp.next = temp.next.next;\\n            }\\n            else\\n                temp = temp.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28828,
                "title": "one-liner-in-ruby",
                "content": "Recursively remove duplicates from the rest of the list, then possibly drop the head (if it's a duplicate of the value after it).\\n\\nRuby:\\n\\n    def delete_duplicates(h)\\n        h && (h.next = delete_duplicates(h.next)) && h.next.val == h.val ? h.next : h\\n    end\\n\\n---\\n\\nBad C++ versions:\\n\\n    return h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val ? h->next : h;\\n\\nAs @shawnyi pointed out, that leaks memory. So `delete`:\\n\\n    if (h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val) delete h, h = h->next; return h;\\n\\nAs @drbombe pointed out, I shouldn't access `h->next` after deleting `h`. Not sure what I was thinking. I certainly knew that. I guess I just focused on the algorithm and didn't care as long as it gets accepted (which it does).\\n\\nFor a proper version, see @drbombe's solution below.",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "Recursively remove duplicates from the rest of the list, then possibly drop the head (if it's a duplicate of the value after it).\\n\\nRuby:\\n\\n    def delete_duplicates(h)\\n        h && (h.next = delete_duplicates(h.next)) && h.next.val == h.val ? h.next : h\\n    end\\n\\n---\\n\\nBad C++ versions:\\n\\n    return h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val ? h->next : h;\\n\\nAs @shawnyi pointed out, that leaks memory. So `delete`:\\n\\n    if (h && (h->next = deleteDuplicates(h->next)) && h->next->val == h->val) delete h, h = h->next; return h;\\n\\nAs @drbombe pointed out, I shouldn't access `h->next` after deleting `h`. Not sure what I was thinking. I certainly knew that. I guess I just focused on the algorithm and didn't care as long as it gets accepted (which it does).\\n\\nFor a proper version, see @drbombe's solution below.",
                "codeTag": "Python3"
            },
            {
                "id": 2676904,
                "title": "easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        /* if head = NULL */\\n        if(!head) return head;\\n        /* setting the curr at head */\\n        ListNode *curr = head;\\n        while(curr->next){\\n            /* if curr value == curr next value the we have to delete next value */\\n            if(curr->val == curr->next->val){\\n                /* stroing next address for deleting further */\\n                ListNode *temp = curr->next;\\n                \\n                /* changing curr pointer to next of next */\\n                curr->next = curr->next->next;\\n                delete temp;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        /* if head = NULL */\\n        if(!head) return head;\\n        /* setting the curr at head */\\n        ListNode *curr = head;\\n        while(curr->next){\\n            /* if curr value == curr next value the we have to delete next value */\\n            if(curr->val == curr->next->val){\\n                /* stroing next address for deleting further */\\n                ListNode *temp = curr->next;\\n                \\n                /* changing curr pointer to next of next */\\n                curr->next = curr->next->next;\\n                delete temp;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335394,
                "title": "swift-remove-duplicates-from-sorted-list-test-cases",
                "content": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var node = head\\n        while let next = node?.next {\\n            node!.val == next.val ? (node!.next = next.next) : (node = next)\\n        }\\n        return head\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.deleteDuplicates(.init([1,1,2]))\\n        let expected = ListNode([1,2])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n    func test1() {\\n        let res = s.deleteDuplicates(.init([1,1,2,3,3]))\\n        let expected = ListNode([1,2,3])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var node = head\\n        while let next = node?.next {\\n            node!.val == next.val ? (node!.next = next.next) : (node = next)\\n        }\\n        return head\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.deleteDuplicates(.init([1,1,2]))\\n        let expected = ListNode([1,2])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n    func test1() {\\n        let res = s.deleteDuplicates(.init([1,1,2,3,3]))\\n        let expected = ListNode([1,2,3])\\n        XCTAssertEqual(res?.val, expected?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935684,
                "title": "very-understandable-javascript-two-pointer-solution-o-n-time-o-1-space",
                "content": "Let p = prev, n = next. Now walk through the code using p and n\\n```\\n1->1->2->3->3->4\\np  n\\n\\n1->   2->3->3->4\\np     n\\n\\n1->2->3->3->4\\np  n\\n\\n1->2->3->3->4\\n   p  n\\n\\n1->2->3->3->4\\n      p  n\\n\\t  \\n1->2->3   ->4\\n\\t  p  n\\n\\t  \\n1->2->3->4\\n\\t  p  n\\n\\n1->2->3->4\\n\\t     p  n\\n```\\n\\nCode: \\n```\\nvar deleteDuplicates = function(head) {\\n  if (!head) return null;\\n  // Init prev as 1st node, next as 2nd node\\n  let prev = head, next = head.next;\\n\\n  // Iterate until next is null, which is end of list\\n  while (next) {\\n    if (prev.val === next.val) {\\n\\t  // If next is a duplicate, skip over it by pointing its prev to its next\\n      prev.next = next.next;\\n    } else {\\n\\t  // Else, just move prev forward to continue through the list\\n      prev = prev.next;\\n    }\\n\\t// Always move next forward, it moves along with prev\\n    next = next.next;\\n  }\\n\\n  return head;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n1->1->2->3->3->4\\np  n\\n\\n1->   2->3->3->4\\np     n\\n\\n1->2->3->3->4\\np  n\\n\\n1->2->3->3->4\\n   p  n\\n\\n1->2->3->3->4\\n      p  n\\n\\t  \\n1->2->3   ->4\\n\\t  p  n\\n\\t  \\n1->2->3->4\\n\\t  p  n\\n\\n1->2->3->4\\n\\t     p  n\\n```\n```\\nvar deleteDuplicates = function(head) {\\n  if (!head) return null;\\n  // Init prev as 1st node, next as 2nd node\\n  let prev = head, next = head.next;\\n\\n  // Iterate until next is null, which is end of list\\n  while (next) {\\n    if (prev.val === next.val) {\\n\\t  // If next is a duplicate, skip over it by pointing its prev to its next\\n      prev.next = next.next;\\n    } else {\\n\\t  // Else, just move prev forward to continue through the list\\n      prev = prev.next;\\n    }\\n\\t// Always move next forward, it moves along with prev\\n    next = next.next;\\n  }\\n\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28743,
                "title": "remove-duplicates-from-sorted-unsorted-list-in-java",
                "content": "Remove duplicates from sorted linked list : \\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode fakeHead = head;\\n        while(fakeHead != null && fakeHead.next != null){\\n            if(fakeHead.val == fakeHead.next.val){\\n                fakeHead.next = fakeHead.next.next;\\n            } else{\\n                fakeHead = fakeHead.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n\\nRemove duplicates from unsorted linked list (works on sorted list as well) : \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        Set<Integer> set = new HashSet<>();\\n        ListNode pre = null;\\n        ListNode fakeHead = head;\\n        while(fakeHead != null){\\n            if(!set.add(fakeHead.val)){\\n                pre.next = fakeHead.next;\\n            } else{\\n                pre = fakeHead;\\n            }\\n            fakeHead = fakeHead.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Remove duplicates from sorted linked list : \\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode fakeHead = head;\\n        while(fakeHead != null && fakeHead.next != null){\\n            if(fakeHead.val == fakeHead.next.val){\\n                fakeHead.next = fakeHead.next.next;\\n            } else{\\n                fakeHead = fakeHead.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n\\nRemove duplicates from unsorted linked list (works on sorted list as well) : \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        Set<Integer> set = new HashSet<>();\\n        ListNode pre = null;\\n        ListNode fakeHead = head;\\n        while(fakeHead != null){\\n            if(!set.add(fakeHead.val)){\\n                pre.next = fakeHead.next;\\n            } else{\\n                pre = fakeHead;\\n            }\\n            fakeHead = fakeHead.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3154174,
                "title": "simple-java-c-100-readable-easy-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n public class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode temp = head;\\n    while (temp != null) {\\n        while(temp.next != null && temp.next.val == temp.val) {\\n           temp.next = temp.next.next;\\n        }\\n        temp = temp.next;\\n    }\\n    return head;\\n}\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n public class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode temp = head;\\n    while (temp != null) {\\n        while(temp.next != null && temp.next.val == temp.val) {\\n           temp.next = temp.next.next;\\n        }\\n        temp = temp.next;\\n    }\\n    return head;\\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921891,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var current = head\\n        var last: ListNode?\\n        \\n        while current != nil {\\n            if last != nil && current!.val == last!.val {\\n                last?.next = current?.next\\n            \\n            } else {\\n                last = current\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var current = head\\n        var last: ListNode?\\n        \\n        while current != nil {\\n            if last != nil && current!.val == last!.val {\\n                last?.next = current?.next\\n            \\n            } else {\\n                last = current\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308429,
                "title": "simple-python-solution",
                "content": "```\\n\\t\\tif not head:\\n            return None\\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tif not head:\\n            return None\\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3026270,
                "title": "javascript-easy-solution-with-explanation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe purpose of this code is to remove duplicate nodes from a linked list. It does this by iterating through the linked list and comparing the values stored in each node to the values stored in the nodes that come after it. If it finds two nodes with the same value, it deletes the second of the two nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function begins by checking if the head argument is null, in which case it returns null. This check handles the case of an empty linked list.\\n2. The function then declares a local variable curr and initializes it to head. This variable will be used to iterate through the linked list and delete any duplicate nodes.\\n3. The function then enters a while loop that continues as long as curr.next is not null. This loop will iterate through the entire linked list.\\n4. Within the loop, the function checks if the value stored in the current node (curr.val) is equal to the value stored in the next node (curr.next.val). If these values are equal, then the current node and the next node are duplicates, and the next node needs to be deleted.\\n5. To delete the next node, the function first stores a reference to the node after the next node (next_next). This is necessary because after the next node is deleted, we will need to update curr.next to skip over the deleted node and point to the node after the next node.\\n6. The function then declares a local variable nodeToDelete and initializes it to curr.next, which is the node that needs to be deleted.\\n7. The function then calls the built-in delete function and passes it nodeToDelete, which deletes the node from the linked list.\\n8. Finally, the function updates curr.next to point to the node after the next node (next_next), effectively skipping over the deleted node.\\n9. If the values stored in curr.val and curr.next.val are not equal, then the current node and the next node are not duplicates, and the loop simply advances curr to the next node by updating curr to curr.next.\\n10. After the loop completes, the function returns head, which is the reference to the head node of the linked list with the duplicates removed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the number of nodes in the linked list. This is because the function iterates through the entire linked list once, performing a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1), because the function only uses a constant amount of space regardless of the size of the input. The only variables that are allocated are \"curr\",\" next_next\", and \"nodeToDelete\", which are all fixed-size variables that do not depend on the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    //empty list\\n    if(head == null)\\n    return null;\\n\\n   let curr = head;\\n    while(curr.next != null){\\n    \\n        if(curr.val == curr.next.val){\\n          let next_next = curr.next.next;\\n          let nodeToDelete = curr.next;\\n          delete(nodeToDelete);\\n          curr.next = next_next;\\n        }\\n        else//not equal\\n        { \\n          curr = curr.next;\\n        }\\n       \\n    }\\nreturn head;\\n};\\n**<!-- Please upvote if you like this solution -->**\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    //empty list\\n    if(head == null)\\n    return null;\\n\\n   let curr = head;\\n    while(curr.next != null){\\n    \\n        if(curr.val == curr.next.val){\\n          let next_next = curr.next.next;\\n          let nodeToDelete = curr.next;\\n          delete(nodeToDelete);\\n          curr.next = next_next;\\n        }\\n        else//not equal\\n        { \\n          curr = curr.next;\\n        }\\n       \\n    }\\nreturn head;\\n};\\n**<!-- Please upvote if you like this solution -->**\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258359,
                "title": "simplest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode* pointer = head;\\n        while(pointer != NULL && pointer->next != NULL)\\n        {\\n            if(pointer->val == pointer->next->val)\\n            {\\n                pointer->next = pointer->next->next; //if the val of current node is equals to the val of next node then skip the node\\n            }\\n            else\\n            {\\n                pointer = pointer->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n**Like the solution? Please upvote.....**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode* pointer = head;\\n        while(pointer != NULL && pointer->next != NULL)\\n        {\\n            if(pointer->val == pointer->next->val)\\n            {\\n                pointer->next = pointer->next->next; //if the val of current node is equals to the val of next node then skip the node\\n            }\\n            else\\n            {\\n                pointer = pointer->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28750,
                "title": "4-ms-c-solution",
                "content": "    if (head) {\\n        struct ListNode *p = head;\\n        while (p->next) {\\n            if (p->val != p->next->val) {\\n                p = p->next;\\n            }\\n            else {\\n                struct ListNode *tmp = p->next;\\n                p->next = p->next->next;\\n                free(tmp);\\n            }\\n        }\\n    }\\n    \\n    return head;",
                "solutionTags": [],
                "code": "    if (head) {\\n        struct ListNode *p = head;\\n        while (p->next) {\\n            if (p->val != p->next->val) {\\n                p = p->next;\\n            }\\n            else {\\n                struct ListNode *tmp = p->next;\\n                p->next = p->next->next;\\n                free(tmp);\\n            }\\n        }\\n    }\\n    \\n    return head;",
                "codeTag": "Unknown"
            },
            {
                "id": 3333593,
                "title": "6-lines-code-in-python3",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr=head\\n        while curr:\\n            while curr.next and curr.next.val==curr.val:\\n                curr.next=curr.next.next\\n            curr=curr.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr=head\\n        while curr:\\n            while curr.next and curr.next.val==curr.val:\\n                curr.next=curr.next.next\\n            curr=curr.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333386,
                "title": "awesome-trick-with-7-lines-of-code",
                "content": "\\n# One Pointers Approach--->Time:O(N)\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current=head\\n        while current and current.next:\\n            if current.val==current.next.val:\\n                current.next=current.next.next\\n            else:\\n                current=current.next\\n        return head\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current=head\\n        while current and current.next:\\n            if current.val==current.next.val:\\n                current.next=current.next.next\\n            else:\\n                current=current.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662393,
                "title": "simple-python-solution-faster-than-97-36",
                "content": "**O(N) Time & O(1) Space Solution**\\n```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tfront = head #points to the front of the linked list\\n\\twhile head and head.next: #while we aren\\'t at the end of the list\\n\\t\\tif head.val == head.next.val: #if the next node has the same value\\n\\t\\t\\thead.next = head.next.next #skip it\\n\\t\\telse: #not a duplicate\\n\\t\\t\\thead = head.next #otherwise move forward\\n\\treturn front #return the front of the linked list\\n```\\nIn this solution, we use ```front``` to keep track of the front of the linkedlist. Then, we go through the list up until the end and check to see if the value of the current node is equal to the value of the next node. If it is, then we skip the duplicate node by setting ```head.next = head.next.next```. If we just removed a duplicate, we don\\'t know if the next node is also a duplicate, so we should not move forward with ```head = head.next``` like we do when we do not find a duplicate.\\nThis solution only needs to look at every node once, giving ```O(N)``` time complexity. Since it requires a constant amount of additional space, the memory complexity is ```O(1)```.\\n\\nP.S. ```while head and head.next``` is the same as ```while head is not None and head.next is not None``` \\u2013\\u2013 it just checks that neither of them are ```None```.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tfront = head #points to the front of the linked list\\n\\twhile head and head.next: #while we aren\\'t at the end of the list\\n\\t\\tif head.val == head.next.val: #if the next node has the same value\\n\\t\\t\\thead.next = head.next.next #skip it\\n\\t\\telse: #not a duplicate\\n\\t\\t\\thead = head.next #otherwise move forward\\n\\treturn front #return the front of the linked list\\n```\n```front```\n```head.next = head.next.next```\n```head = head.next```\n```O(N)```\n```O(1)```\n```while head and head.next```\n```while head is not None and head.next is not None```\n```None```",
                "codeTag": "Python3"
            },
            {
                "id": 1570266,
                "title": "java-faster-than-100",
                "content": "\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode curr = head;\\n        if(head == null) return null;\\n\\t\\t\\n\\t\\t// if the head.next == null it means that the list contains only one node (head) \\n\\t\\t//so there is no duplicates  we will simply return the head of the list\\n\\t\\t\\n        if(head.next == null) return head;\\n        else{\\n            while(curr.next != null){\\n\\t\\t\\t//we compare the data of the current node with the next node if they are equal\\n\\t\\t\\t//we remove the next node \\n                if(curr.val == curr.next.val) \\n                    curr.next = curr.next.next;\\n                else\\n\\t\\t\\t\\t//if they are not equal we simply move forward\\n                    curr=curr.next;\\n            }\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode curr = head;\\n        if(head == null) return null;\\n\\t\\t\\n\\t\\t// if the head.next == null it means that the list contains only one node (head) \\n\\t\\t//so there is no duplicates  we will simply return the head of the list\\n\\t\\t\\n        if(head.next == null) return head;\\n        else{\\n            while(curr.next != null){\\n\\t\\t\\t//we compare the data of the current node with the next node if they are equal\\n\\t\\t\\t//we remove the next node \\n                if(curr.val == curr.next.val) \\n                    curr.next = curr.next.next;\\n                else\\n\\t\\t\\t\\t//if they are not equal we simply move forward\\n                    curr=curr.next;\\n            }\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1342775,
                "title": "short-c-solution-using-recursion",
                "content": "Base case is head==NULL or head->next==NULL hence, we already have an empty list or list with a single element (no duplicates)\\nDecide what will be the next of the current head by recursively calling the function deleteDupliactes.\\nWhy this will work?\\nBecause as soon as we hit the base case, we will get an unique value for the tail. Now that unique value is passed as a next element for the previous element. If the value is same as previous elements value (compared during returning of function),  we will return the unique value itself, if the value is different, return the previous element which will have next element as this unique value.\\nExample:\\nA->B->C, going deep into recursion, first we get C, we compare with B, if(B!=C) we get A->next = B\\ni.e. A->B->C but if (B==C) we get A->next = C, hence A->C. This will also checked for values between A and C and so on.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next ==NULL)\\n            return head;\\n        head->next = deleteDuplicates(head->next);\\n        return head->val==head->next->val ? head->next : head;\\n    }\\n};\\n```\\nTime complexity = O(N)\\nSpace complexity = O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next ==NULL)\\n            return head;\\n        head->next = deleteDuplicates(head->next);\\n        return head->val==head->next->val ? head->next : head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28790,
                "title": "python-109ms-why-my-solution-is-fast-than-others",
                "content": "I just use a while loop to find duplicates. And my runtime is 109ms.\\n\\nA common runtime in python is 200ms ~ 400ms.\\n\\n    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head == None:\\n                return head\\n                \\n            node = head\\n            \\n            while node.next:\\n                if node.val == node.next.val:\\n                    node.next = node.next.next\\n                else:\\n                    node = node.next\\n                    \\n            return head",
                "solutionTags": [],
                "code": "I just use a while loop to find duplicates. And my runtime is 109ms.\\n\\nA common runtime in python is 200ms ~ 400ms.\\n\\n    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head == None:\\n                return head\\n                \\n            node = head\\n            \\n            while node.next:\\n                if node.val == node.next.val:\\n                    node.next = node.next.next\\n                else:\\n                    node = node.next\\n                    \\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 28620,
                "title": "share-a-recursive-solution-in-python",
                "content": "There is straight forward iterative solution, but it turns out recursive is quite few lines and not too hard to understand.\\n\\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head and head.next and head.val != head.next.val:\\n                head.next = self.deleteDuplicates(head.next)\\n            elif head and head.next:\\n                head = self.deleteDuplicates(head.next)\\n            return head",
                "solutionTags": [],
                "code": "There is straight forward iterative solution, but it turns out recursive is quite few lines and not too hard to understand.\\n\\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a ListNode\\n        def deleteDuplicates(self, head):\\n            if head and head.next and head.val != head.next.val:\\n                head.next = self.deleteDuplicates(head.next)\\n            elif head and head.next:\\n                head = self.deleteDuplicates(head.next)\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 2290759,
                "title": "python-beats-94-explained-with-diagrams",
                "content": "**Runtime: 42 ms, faster than 94.70% of Python3 online submissions for Remove Duplicates from Sorted List.**\\n**Memory Usage: 13.8 MB, less than 70.70% of Python3 online submissions for Remove Duplicates from Sorted List.**\\n\\nThe theme to solve this question is just like how we solve regular linked list problems. \\n\\nWe go with initializing two variables start and node with head then we move node to start.next\\n\\nLike in this example:-\\n![image](https://assets.leetcode.com/users/images/3c2f7589-5374-43a1-9c56-c0e8f203a2f6_1657981559.5628524.png)\\n now `start` is 1 and `node` is 1(2nd one)\\n we loop through the list and check if `start==node` and if that is true like in this case, what we need to do is set `start.next=node.next` now since the First `1` in the above diagram now points to `2` and the next thing we need to take care of is that we need to change this as I have illustated in the following pictures:-\\n \\n ![image](https://assets.leetcode.com/users/images/ecaeab50-b851-4dfa-94c7-7614a0402709_1658518230.7136285.jpeg)\\n ![image](https://assets.leetcode.com/users/images/94b27264-6072-4f8a-b1a3-705ac89a2012_1658518253.6033578.jpeg)\\n ![image](https://assets.leetcode.com/users/images/54f6551d-388c-43f3-9d1a-561c08359025_1658518264.8918567.jpeg)\\n\\n \\nFrom here it\\'s cake walk, you need to continue the loop and that\\'s it. The Probelm is Solved!!\\n\\n**Code**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head \\n        start=node=head\\n        node=head.next\\n        while start and node:\\n            if start.val==node.val:\\n                start.next=node.next\\n                node.next=None\\n                node=start.next\\n            else:\\n                start=start.next\\n                node=node.next\\n        return head\\n```\\n\\n\\n_______________________________________________________________________________________________\\n_________________________________________________________________________________________________\\nEdit 1:\\nthe line `node.next=None` can be omitted as we wont ever reach that node\\n_________________________________________________________________________________________________\\n_________________________________________________________________________________________________\\n\\n\\nIf you liked my efforts then pls pls **UPVOTE** the post, it will encourage me to do more of this stuff!\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head \\n        start=node=head\\n        node=head.next\\n        while start and node:\\n            if start.val==node.val:\\n                start.next=node.next\\n                node.next=None\\n                node=start.next\\n            else:\\n                start=start.next\\n                node=node.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914980,
                "title": "easy-solution-one-pointer-two-while-loops",
                "content": "The outer `while` loops over distinct values, the inner `while` skips duplicates.\\n```csharp\\npublic class Solution\\n{\\n    public ListNode DeleteDuplicates(ListNode head)\\n    {\\n        ListNode n = head;\\n\\n        while (n is not null)\\n        {\\n            while (n.val == n.next?.val)\\n            {\\n                n.next = n.next.next;\\n            }\\n            n = n.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode DeleteDuplicates(ListNode head)\\n    {\\n        ListNode n = head;\\n\\n        while (n is not null)\\n        {\\n            while (n.val == n.next?.val)\\n            {\\n                n.next = n.next.next;\\n            }\\n            n = n.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28785,
                "title": "clear-java-solution",
                "content": "    public class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null) return null;\\n            ListNode pre = head;\\n            ListNode cur = head.next;\\n            while(cur != null){\\n                if(cur.val == pre.val){\\n                    pre.next = cur.next;\\n                    cur = cur.next;\\n                }\\n                else{\\n                    pre = pre.next;\\n                    cur = pre.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode deleteDuplicates(ListNode head) {\\n            if(head == null) return null;\\n            ListNode pre = head;\\n            ListNode cur = head.next;\\n            while(cur != null){\\n                if(cur.val == pre.val){\\n                    pre.next = cur.next;\\n                    cur = cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28800,
                "title": "python-recursive-and-iterative-solutions",
                "content": "```\\ndef deleteDuplicates(self, head):\\n\\tif not head or not head.next:\\n\\t\\treturn head\\n\\th = self.deleteDuplicates(head.next)\\n\\thead.next = h if head.val != h.val else h.next\\n\\treturn head\\n```\\n\\t\\t\\n\\tdef deleteDuplicates1(self, head):\\n        node = head\\n        while node and node.next:\\n            if node.val == node.next.val:\\n                node.next = node.next.next\\n            else:\\n                node = node.next\\n        return head\\n        \\n    def deleteDuplicates(self, head):\\n        dic = {}\\n        node = head\\n        while node:\\n            dic[node.val] = dic.get(node.val, 0) + 1\\n            node = node.next\\n        node = head\\n        while node:\\n            tmp = node\\n            for _ in xrange(dic[node.val]):\\n                tmp = tmp.next\\n            node.next = tmp\\n            node = node.next\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef deleteDuplicates(self, head):\\n\\tif not head or not head.next:\\n\\t\\treturn head\\n\\th = self.deleteDuplicates(head.next)\\n\\thead.next = h if head.val != h.val else h.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2693121,
                "title": "java-solution-diagram",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        head.next = deleteDuplicates(head.next);\\n        return head.val == head.next.val ? head.next : head;\\n}\\n    }\\n```\\n\\n\\n**![image](https://assets.leetcode.com/users/images/1f497680-383f-44c3-b9a5-7087f7d1c43e_1665552943.6387627.png)**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        head.next = deleteDuplicates(head.next);\\n        return head.val == head.next.val ? head.next : head;\\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149146,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode*temp = head;\\n        \\n        if(!head) return head;\\n        \\n        while(head->next) {\\n            if(head->val == head->next->val) {\\n                head->next = head->next->next;\\n            }\\n            else{\\n                head = head->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode*temp = head;\\n        \\n        if(!head) return head;\\n        \\n        while(head->next) {\\n            if(head->val == head->next->val) {\\n                head->next = head->next->next;\\n            }\\n            else{\\n                head = head->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746631,
                "title": "simple-and-easy-beats-100",
                "content": "# upvote if you feel it easy\\uD83D\\uDE0A\\u2764\\n# Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while(temp!=null && temp.next != null) {\\n            if(temp.val == temp.next.val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while(temp!=null && temp.next != null) {\\n            if(temp.val == temp.next.val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475241,
                "title": "python-c-with-clear-explanation",
                "content": "## Below you will find the code implementation for both C and Python.\\n\\n# Approach:\\n1. In order to eliminate the duplicate nodes, we have to iterate over the linked list and compare for the duplicate values.\\n2. Create a **tem**porary **ref**erence (`curr`) to the **hea**d **nod**e.\\n3. **Ite**rate until you reach **NULL**.\\n`while(curr != NULL && curr->next != NULL)`\\n4. Check if the **cur**rent **nod**e **val**ue **is equal** to the **nex**t **nod**e **val**ue.\\n`if(curr->val == curr->next->val)`\\n5. If **$yes$**, **ski**p the **nex**t **nod**e by **poi**nting the **nex**t of the **cur**rent **nod**e to the **nex**t of the **nex**t **nod**e.\\n`curr->next = curr->next->next;`\\n6. If **$no$**, then we have a **new** **val**ue, so **mov**e the **poi**nter to the **nex**t of the **cur**rent **nod**e.\\n`curr = curr->next;`\\n7. **Ret**urn `head` since we are using the same linked list.\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n\\n```C []\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* curr = head;\\n\\n    while(curr != NULL && curr->next != NULL){\\n        if(curr->val == curr->next->val)\\n            curr->next = curr->next->next;\\n        else\\n            curr = curr->next;\\n    }\\n\\n    return head;\\n}\\n```\\n```python []\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n                \\n```\\n\\n### Please consider upvoting if you liked it or comment if you have an alternative approach! Thank you!",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* curr = head;\\n\\n    while(curr != NULL && curr->next != NULL){\\n        if(curr->val == curr->next->val)\\n            curr->next = curr->next->next;\\n        else\\n            curr = curr->next;\\n    }\\n\\n    return head;\\n}\\n```\n```python []\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393864,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* new_list = head;\\n    struct ListNode* temp = head;\\n    while (temp != NULL && temp->next != NULL) {\\n        if (temp->val == temp->next->val) {\\n            temp->next = temp->next->next;\\n        } else {\\n            temp = temp->next;\\n        }\\n    }\\n    return new_list;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* new_list = head;\\n    struct ListNode* temp = head;\\n    while (temp != NULL && temp->next != NULL) {\\n        if (temp->val == temp->next->val) {\\n            temp->next = temp->next->next;\\n        } else {\\n            temp = temp->next;\\n        }\\n    }\\n    return new_list;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101800,
                "title": "easy-simple-code-in-c-with-100-testcase-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a node temp which is equal to head \\nrun a loop until the temp!=NULL temp->next!=NUll which means until tail appears .\\nif(temp->val == temp->next->val)//i.e if temp and next node is equal then make temp->next equal to temp->next->next\\ntemp->next=temp->next->next;\\nelse\\ntemp=temp->next;  //itterate the node to next.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp = head;\\n        while(temp !=NULL && temp->next!=NULL){\\n            if(temp->val == temp->next->val){\\n                temp->next=temp->next->next;\\n               \\n            }\\n            else{\\n                temp=temp->next;\\n            }\\n        } \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp = head;\\n        while(temp !=NULL && temp->next!=NULL){\\n            if(temp->val == temp->next->val){\\n                temp->next=temp->next->next;\\n               \\n            }\\n            else{\\n                temp=temp->next;\\n            }\\n        } \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078821,
                "title": "javascript-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n\\n    while(current) {\\n        if(current.next!==null && current.val==current.next.val) {\\n            current.next = current.next.next;\\n        }\\n        else {\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    var current = head;\\n\\n    while(current) {\\n        if(current.next!==null && current.val==current.next.val) {\\n            current.next = current.next.next;\\n        }\\n        else {\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821993,
                "title": "python-98-89-faster-6-lines-o-n-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        while temp:\\n            while temp.next!=None and temp.val == temp.next.val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        while temp:\\n            while temp.next!=None and temp.val == temp.next.val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595755,
                "title": "python-solution-easy-explained-faster-than-89-79",
                "content": "If you like the solution, your upvote is appreciated! \\uD83E\\uDD1D\\n\\nExplanation:\\n\\nIn the first while loop, we continue as long as the current node and the next node exist.\\n\\nIn the second while loop, we continue to replace the next value, if it is the same as the current value. In a sense, we skip the next value if it is the same.\\n\\nWhen we reach the end of the linked list, and current node or next node is None, we can return the linked list from the beginning (head).\\n\\nAnd that is it!\\n\\nIf you did not yet, upvote to make my day \\uD83C\\uDF1E\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        \\n    \\n        while current != None and current.next != None:\\n              while current.val == current.next.val:\\n                    current.next = current.next.next\\n                    if current.next == None:\\n                        break\\n              current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        \\n    \\n        while current != None and current.next != None:\\n              while current.val == current.next.val:\\n                    current.next = current.next.next\\n                    if current.next == None:\\n                        break\\n              current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177026,
                "title": "c-java-explained-w-visual",
                "content": "Runtime Complexity: **`O(n)`**\\nSpace Complexity: **`O(1)`** (in-place)\\n\\n**There are two main actions to know:**\\n\\n#### (1) Traversal with a pointer: ```ptr = ptr.next;```\\n#### (2) Deletion of a target node: ```prev.next = target.next;``` or ```prev.next = prev.next.next;```\\n\\nWe will iterate through the list with a pointer `ListNode` `ptr` to accomplish our task. To check if a duplicate for `ptr.val` exists, we simply have to see if `ptr.next.val` is equal to `ptr.val`, because the array is sorted and duplicates are contiguous.\\n\\nThe following code is identical for both C# and Java:\\n```\\nif(head == null){return null;} //Don\\'t forget this edge case\\nListNode ptr = head; //Helps for returning at the end\\n\\nwhile(ptr.next != null){ //Terminates if there is no next node(end of list)\\n\\tif(ptr.next.val == ptr.val){ //Check for duplicate next node\\n\\t\\tptr.next = ptr.next.next; //Delete next node\\n\\t}\\n\\telse{\\n\\t\\tptr = ptr.next; //Advance if no duplicate is found\\n\\t}\\n}\\nreturn head; //Return the original start of list\\n```\\n\\nThe effect of our code is as such:\\n![image](https://assets.leetcode.com/users/images/081e8010-3642-4eff-bcba-68c30d95c893_1655785996.077856.png)\\n\\n\\n> Please upvote if this helps in any way!",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```ptr = ptr.next;```\n```prev.next = target.next;```\n```prev.next = prev.next.next;```\n```\\nif(head == null){return null;} //Don\\'t forget this edge case\\nListNode ptr = head; //Helps for returning at the end\\n\\nwhile(ptr.next != null){ //Terminates if there is no next node(end of list)\\n\\tif(ptr.next.val == ptr.val){ //Check for duplicate next node\\n\\t\\tptr.next = ptr.next.next; //Delete next node\\n\\t}\\n\\telse{\\n\\t\\tptr = ptr.next; //Advance if no duplicate is found\\n\\t}\\n}\\nreturn head; //Return the original start of list\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142759,
                "title": "java-0ms-recursive-best-solution",
                "content": "# Please Upvote If You Find This Helpful\\n![image](https://assets.leetcode.com/users/images/84fe7943-54b9-442c-be63-2b148540f196_1655030408.0951629.png)\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        while (head.next != null && head.val == head.next.val) head.next = head.next.next;\\n        head.next = deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```\\n# Please Upvote If You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        while (head.next != null && head.val == head.next.val) head.next = head.next.next;\\n        head.next = deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122525,
                "title": "js-simple-cutting",
                "content": "Overwrite `next` with `next.next` to cut next node when `current.next` exist, and `current.val` equals `current.next.val`.\\nIf not, continue normal traverse: `current = current.next;`\\n\\n![image](https://assets.leetcode.com/users/images/679e51b1-f16f-4b7f-8081-b7c097254645_1654615175.1876688.jpeg)\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n  let current = head;\\n  \\n  while (current) {\\n    if (current.next && current.val === current.next.val) {\\n      current.next = current.next.next;\\n    } else {\\n      current = current.next;\\n    }\\n  }\\n  \\n  return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n  let current = head;\\n  \\n  while (current) {\\n    if (current.next && current.val === current.next.val) {\\n      current.next = current.next.next;\\n    } else {\\n      current = current.next;\\n    }\\n  }\\n  \\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792789,
                "title": "python-java-simple-implementation",
                "content": "**Python 3**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t\\t# current element\\n        e = head\\n        while e:\\n\\t\\t\\t# loop until current element\\'s value is different to it\\'s next element\\'s value\\n            while e.next and e.next.val == e.val:\\n                e.next = e.next.next\\n            e = e.next\\n                \\n        return head\\t\\t\\n```\\n**Java**\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode e = head;\\n        while (e != null){\\n            while (e.next != null && e.next.val == e.val){\\n                e.next = e.next.next;\\n            }\\n            e = e.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\\n* Time complexity: O(n)\\n* Space complexity: O(1)",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t\\t# current element\\n        e = head\\n        while e:\\n\\t\\t\\t# loop until current element\\'s value is different to it\\'s next element\\'s value\\n            while e.next and e.next.val == e.val:\\n                e.next = e.next.next\\n            e = e.next\\n                \\n        return head\\t\\t\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode e = head;\\n        while (e != null){\\n            while (e.next != null && e.next.val == e.val){\\n                e.next = e.next.next;\\n            }\\n            e = e.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736671,
                "title": "c-easy-implementation",
                "content": "**please upvote if you like my solution**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL)return NULL;\\n    struct ListNode* temp=head,*nextnode;\\n    while(temp->next!=0){\\n        if(temp->val==temp->next->val){\\n            nextnode=temp->next->next;\\n            free(temp->next);\\n            temp->next=nextnode;\\n        }\\n        else\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL)return NULL;\\n    struct ListNode* temp=head,*nextnode;\\n    while(temp->next!=0){\\n        if(temp->val==temp->next->val){\\n            nextnode=temp->next->next;\\n            free(temp->next);\\n            temp->next=nextnode;\\n        }\\n        else\\n        temp=temp->next;\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646445,
                "title": "concise-explanation-with-c-code",
                "content": "Suppose the Linked List is  \\n1 -> 2 -> 2 -> 3 -> 3\\n\\nWe first take a temporary pointer and point to the Head of the List, then we traverse the List. \\nIf at any moment we find the value of the next of the temporary pointer with itself is same, we simply delete the next of the temporary pointer and go on traversing our list.\\n\\n# Code:-\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode *temp = head;\\n        while(temp->next) {\\n            if(temp->val == temp->next->val) {\\n                ListNode *link = temp->next;\\n                temp->next = temp->next->next; \\n                delete link;\\n            }\\n            else {\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nRead below for more clarification:-\\nfor list:- **1 -> 2 -> 2 -> 3 -> 3**\\n# Step 1:-\\ntemp = 1\\ntemp->next = 2,\\nhere both are different hence we go in the else part.\\nThe List Now becomes:-\\n**1->2->2->3->3**\\n\\n# Step 2:-\\ntemp = 2\\ntemp->next = 2\\nhere as both are same, we store the temp->next in **link** node(so that we can free memory later) and disrupt the connection of temp(2) with temp->next(2) and make temp with temp->next->next(3).\\nAfter this step, we need to free the memory of the deleted Node.\\nThe List Now becomes:-\\n**1->2->3->3**\\n\\n# Step 3:-\\ntemp = 2\\ntemp->next = 3,\\nhere both are different hence we go in the else part.\\nThe List Now becomes:-\\n**1->2->3->3**\\n\\n# Step 4:-\\ntemp = 3\\ntemp->next = 3\\nHere, again as both are same, we just follow the same procedure in **Step2**.\\nThe List Now becomes:-\\n**1->2->3**\\n\\n# Step 5:-\\ntemp=3\\ntemp->next = NULL\\nNow our while condition becomes false, hence we move out of the loop.\\n\\n\\n# \\uD83D\\uDC80DANGER\\uD83D\\uDC80:-\\nWe must provide a check condition at the beginning of our code, to handle the case of **[]**, else we are bound the get a Run Time Error.\\n\\nAt the end, we return the Head with the modified Linked List.\\n\\nHappy Coding, \\nsayak04.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode *temp = head;\\n        while(temp->next) {\\n            if(temp->val == temp->next->val) {\\n                ListNode *link = temp->next;\\n                temp->next = temp->next->next; \\n                delete link;\\n            }\\n            else {\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636022,
                "title": "c-4-lines-of-most-simple-iterative-and-recurrsive-solution",
                "content": "I added both iterative and simple recursive solution in simplest manner.\\nOnly one line difference in both soluton\\n1. Iterative Solution (faster)\\n```\\n        ListNode* curr = head;\\n        while(curr != NULL && curr -> next != NULL) {\\n            if(curr -> val == curr -> next -> val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        return head;\\n```\\n2. Recursive Solution (2 times slower than iterative)\\n```\\nListNode* curr = head;\\nif(curr != NULL && curr -> next != NULL) {\\n                if(curr -> val == curr -> next -> val) {\\n                        curr -> next = curr -> next -> next;\\n                } else {\\n                    curr = curr -> next;\\n                }\\n                deleteDuplicates(curr);\\n            }\\n        return head;\\n```\\n**Upvote if this helped!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        ListNode* curr = head;\\n        while(curr != NULL && curr -> next != NULL) {\\n            if(curr -> val == curr -> next -> val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        return head;\\n```\n```\\nListNode* curr = head;\\nif(curr != NULL && curr -> next != NULL) {\\n                if(curr -> val == curr -> next -> val) {\\n                        curr -> next = curr -> next -> next;\\n                } else {\\n                    curr = curr -> next;\\n                }\\n                deleteDuplicates(curr);\\n            }\\n        return head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356619,
                "title": "go-simple-solution-with-recursion-0-ms",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t} else if head.Val == head.Next.Val {\\n\\t\\thead = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t} else {\\n\\t\\thead.Next = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t} else if head.Val == head.Next.Val {\\n\\t\\thead = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t} else {\\n\\t\\thead.Next = deleteDuplicates(head.Next)\\n\\t\\treturn head\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346260,
                "title": "python-straight-forward-methods",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        while current!=None and current.next!=None:\\n            if current.val==current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        current = head\\n        while current!=None and current.next!=None:\\n            if current.val==current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293968,
                "title": "c-straightforward-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var root = head;\\n        while (head != null) {\\n            var pre = head;\\n            while (head != null && head.val == pre.val)\\n                head= head.next;\\n            pre.next = head;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var root = head;\\n        while (head != null) {\\n            var pre = head;\\n            while (head != null && head.val == pre.val)\\n                head= head.next;\\n            pre.next = head;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917809,
                "title": "remove-duplicates-from-the-linked-list-runtime-beats-85-11-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the values are ``sorted``, we can just compare the current value with the next value to check for ``duplicates``. Traversing through the linked list and checking for this condition in each node will solve the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start with assigning the current node to the head of the linked list\\n- Traverse through the link list and ``compare`` the ``current`` node value with the ``next`` node value. If the values are same then ``current.next`` should point to ``current.next.next``. This will skip the next node\\n- While traversal we should also check if  ``current.next`` exists. If not then terminate the loop\\n- After succesful traversal the derived link list will contain no duplicates\\n- Return the ``head``\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        while current and current.next:\\n            if current.val == current.next.val: current.next = current.next.next\\n            else: current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        while current and current.next:\\n            if current.val == current.next.val: current.next = current.next.next\\n            else: current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283672,
                "title": "easy-solution-in-c-o-n-time",
                "content": "# Intuition\\nWe can solve this problem by traversing the linked list and keeping track of the current node and the next node. If the value of the current node is equal to the value of the next node, we know that the next node is a duplicate and we need to remove it. We can remove the next node by changing the next pointer of the current node to point to the node after the next node. We continue this process until we reach the end of the linked list.\\n\\n# Approach\\n- Start at the head of the linked list.\\n- While the current node and the next node are not null:\\n    a. If the value of the current node is equal to the value of the next node, remove the next node by changing the next pointer of the current node to point to the node after the next node.\\n    b. If the values are not equal, move on to the next pair of nodes.\\n- Return the head of the modified linked list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            if(head==NULL){\\n            return NULL;\\n        }\\n       ListNode* curr = head;\\n       while(curr != NULL){\\n           if(curr->next != NULL && curr->val == curr->next->val ){\\n               ListNode* temp = curr->next;\\n               curr->next = curr->next->next;\\n               delete temp;\\n           }\\n           else{\\n           curr = curr->next;\\n           }\\n       } \\n       return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n            if(head==NULL){\\n            return NULL;\\n        }\\n       ListNode* curr = head;\\n       while(curr != NULL){\\n           if(curr->next != NULL && curr->val == curr->next->val ){\\n               ListNode* temp = curr->next;\\n               curr->next = curr->next->next;\\n               delete temp;\\n           }\\n           else{\\n           curr = curr->next;\\n           }\\n       } \\n       return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185214,
                "title": "beats-94-95-83-remove-duplicates-from-sorted-list-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n94.95%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Check if the linked list is empty\\n        if not head:\\n            return None\\n        \\n        # Initialize two pointers: current and previous\\n        prev = head\\n        current = head.next\\n        \\n        while current:\\n            # If the current node\\'s value is equal to the previous node\\'s value, delete the current node\\n            if current.val == prev.val:\\n                prev.next = current.next\\n                current = current.next\\n            # If the current node\\'s value is different, move the pointers to the next node\\n            else:\\n                prev = current\\n                current = current.next\\n        \\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Check if the linked list is empty\\n        if not head:\\n            return None\\n        \\n        # Initialize two pointers: current and previous\\n        prev = head\\n        current = head.next\\n        \\n        while current:\\n            # If the current node\\'s value is equal to the previous node\\'s value, delete the current node\\n            if current.val == prev.val:\\n                prev.next = current.next\\n                current = current.next\\n            # If the current node\\'s value is different, move the pointers to the next node\\n            else:\\n                prev = current\\n                current = current.next\\n        \\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115484,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        \\n        if(head == null)\\n            return null;\\n\\n        if(head.next == null)\\n            return head;\\n\\n        ListNode prevNode = head;\\n        for(ListNode node = head.next; node != null; node = node.next)\\n        {\\n            if(node.val == prevNode.val)\\n            {\\n                prevNode.next = node.next;\\n            }\\n            else \\n            {\\n                prevNode = node;\\n            }\\n        }\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        \\n        if(head == null)\\n            return null;\\n\\n        if(head.next == null)\\n            return head;\\n\\n        ListNode prevNode = head;\\n        for(ListNode node = head.next; node != null; node = node.next)\\n        {\\n            if(node.val == prevNode.val)\\n            {\\n                prevNode.next = node.next;\\n            }\\n            else \\n            {\\n                prevNode = node;\\n            }\\n        }\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086107,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* c=head;\\n        ListNode* p=new ListNode(1);\\n        ListNode* k=p;\\n        while(c)\\n        {\\n            while(c->next && c->val==c->next->val)\\n            c=c->next;\\n            // cout<<\"f\";\\n            p->next=c;\\n            p=p->next;\\n            c=c->next;\\n        }\\n        p->next=NULL;\\n        return k->next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* c=head;\\n        ListNode* p=new ListNode(1);\\n        ListNode* k=p;\\n        while(c)\\n        {\\n            while(c->next && c->val==c->next->val)\\n            c=c->next;\\n            // cout<<\"f\";\\n            p->next=c;\\n            p=p->next;\\n            c=c->next;\\n        }\\n        p->next=NULL;\\n        return k->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3070363,
                "title": "o-n-o-1-python-solution-explained",
                "content": "Hello **Tenno Leetcoders**,\\n\\nFor this problem, we want to remove nodes with duplicated values and return a new sorted linked list\\n\\n### Iterative Step\\n\\n\\t1) One of the edge cases, we need to watch out for is when our `head` is `None`  then we simply return `None`\\n\\n\\t2) Our first node will become our current head \\n\\n\\t3) We will only perform removal process if current.next has a node and check for the following:\\n\\t\\n\\t\\t- if current head value equals to next node value, then remove the duplicated node by setting next node \\n\\t\\tto the node after the duplicated node \\n\\t\\t\\n\\t\\t-  If not equal, we will check the next node \\n\\t\\n\\t4) We will then return the de-duped linked list by returning the head\\n\\n### Code\\n```\\n   def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if not head: return None\\n        \\n        current = head\\n        print(current)\\n         \\n        while current.next:\\n            \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next   \\n                \\n        return head\\n```\\n\\n\\n#### Time Complexity: O(n)\\n\\n#### Space Complexity: O(1)\\n\\n\\n ***Upvote if this tenno\\'s discussion helped you in some type of way***\\n  \\n***Warframe\\'s short clip of the day***\\n![image](https://assets.leetcode.com/users/images/1175511c-ddd4-40cd-a397-ea689aec52bd_1674066252.4141765.gif)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n   def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if not head: return None\\n        \\n        current = head\\n        print(current)\\n         \\n        while current.next:\\n            \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next   \\n                \\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2332700,
                "title": "java-best-and-easy-solution-1-ms",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode list = head;\\n         \\n         while(list != null) {\\n        \\t if (list.next == null) {\\n        \\t\\t break;\\n        \\t }\\n        \\t if (list.val == list.next.val) {\\n        \\t\\t list.next = list.next.next;\\n        \\t }\\n           else {\\n        \\t\\t list = list.next;\\n        \\t }\\n         }\\n         \\n         return head;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode list = head;\\n         \\n         while(list != null) {\\n        \\t if (list.next == null) {\\n        \\t\\t break;\\n        \\t }\\n        \\t if (list.val == list.next.val) {\\n        \\t\\t list.next = list.next.next;\\n        \\t }\\n           else {\\n        \\t\\t list = list.next;\\n        \\t }\\n         }\\n         \\n         return head;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893349,
                "title": "100-fastest-typescript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let prev = head\\n  let curr = head.next\\n\\n  while (curr) {\\n    while (curr && curr.val === prev.val) { curr = curr.next as ListNode }\\n\\n    prev.next = curr\\n    prev = curr\\n\\n    if (curr) { curr = curr.next as ListNode }\\n  }\\n\\n  return head\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let prev = head\\n  let curr = head.next\\n\\n  while (curr) {\\n    while (curr && curr.val === prev.val) { curr = curr.next as ListNode }\\n\\n    prev.next = curr\\n    prev = curr\\n\\n    if (curr) { curr = curr.next as ListNode }\\n  }\\n\\n  return head\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797468,
                "title": "python-simple-python-solution-using-iterative-approach",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tnode = head\\n\\n\\t\\t\\twhile node!= None and node.next != None:\\n\\n\\t\\t\\t\\tif node.val == node.next.val:\\n\\n\\t\\t\\t\\t\\tnode.next=node.next.next\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tnode=node.next\\n\\n\\t\\t\\treturn head",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tnode = head\\n\\n\\t\\t\\twhile node!= None and node.next != None:\\n\\n\\t\\t\\t\\tif node.val == node.next.val:\\n\\n\\t\\t\\t\\t\\tnode.next=node.next.next\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tnode=node.next\\n\\n\\t\\t\\treturn head",
                "codeTag": "Java"
            },
            {
                "id": 1448498,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut result_list = ListNode::new(0);\\n        let mut result_list_iterator = &mut result_list;\\n        let mut input_list_iterator = head.as_ref();\\n        let mut previous_val = i32::MIN;\\n        \\n        while let Some(node) = input_list_iterator {\\n            if node.val != previous_val {\\n                result_list_iterator.next = Some(Box::new(ListNode::new(node.val)));\\n                result_list_iterator = result_list_iterator.next.as_mut().unwrap();\\n                previous_val = node.val;\\n            }\\n            input_list_iterator = node.next.as_ref();\\n        }\\n        \\n        result_list.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut result_list = ListNode::new(0);\\n        let mut result_list_iterator = &mut result_list;\\n        let mut input_list_iterator = head.as_ref();\\n        let mut previous_val = i32::MIN;\\n        \\n        while let Some(node) = input_list_iterator {\\n            if node.val != previous_val {\\n                result_list_iterator.next = Some(Box::new(ListNode::new(node.val)));\\n                result_list_iterator = result_list_iterator.next.as_mut().unwrap();\\n                previous_val = node.val;\\n            }\\n            input_list_iterator = node.next.as_ref();\\n        }\\n        \\n        result_list.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445853,
                "title": "recursive-c",
                "content": "...\\nListNode* deleteDuplicate(ListNode* head)\\n{\\n\\n       if(head==NULL || head->next==NULL)          \\n        {                                           \\n         return head;                               \\n        }\\n        \\n        head->next  =  deleteDuplicates(head->next);\\n        if(head->val==head->next->val)\\n        {\\n          return head->next;\\n        }\\n        \\n        return head; \\n}\\n\\n...\\n",
                "solutionTags": [],
                "code": "...\\nListNode* deleteDuplicate(ListNode* head)\\n{\\n\\n       if(head==NULL || head->next==NULL)          \\n        {                                           \\n         return head;                               \\n        }\\n        \\n        head->next  =  deleteDuplicates(head->next);\\n        if(head->val==head->next->val)\\n        {\\n          return head->next;\\n        }\\n        \\n        return head; \\n}\\n\\n...\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1223275,
                "title": "good-code-without-memory-leak-c-ez-to-understnad",
                "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        \\n        ListNode *curr=head;\\n        \\n        while(curr!=NULL){\\n            \\n            if(curr->next!=NULL && curr->val==curr->next->val){\\n                \\n                ListNode *temp=curr->next;\\n                curr->next = curr->next->next;\\n                \\n                delete temp;\\n                \\n                \\n            }\\n            \\n            else{\\n                curr=curr->next;\\n            }\\n            \\n            \\n            \\n            \\n        }\\n        return head;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1078121,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        ListNode node1 = head,\\n                 node2 = head.next;\\n        \\n        while (node2 != null)\\n            if (node1.val == node2.val)\\n            {\\n                node1.next = node2.next;\\n                node2.next = null;\\n                node2 = node1.next;\\n            }\\n            else\\n            {\\n                node1 = node2;\\n                node2 = node2?.next;\\n            }\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        ListNode node1 = head,\\n                 node2 = head.next;\\n        \\n        while (node2 != null)\\n            if (node1.val == node2.val)\\n            {\\n                node1.next = node2.next;\\n                node2.next = null;\\n                node2 = node1.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 680569,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var temp =head;\\n        while(head != null && head.next != null)\\n        {\\n            if(head.val == head.next.val){\\n                head.next = head.next.next;\\n            }\\n            else{\\n                head = head.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode DeleteDuplicates(ListNode head) {\\n        var temp =head;\\n        while(head != null && head.next != null)\\n        {\\n            if(head.val == head.next.val){\\n                head.next = head.next.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 386405,
                "title": "4ms-c-solution",
                "content": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* cur = head;\\n    while (cur && cur->next) {\\n        if(cur->val == cur->next->val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    struct ListNode* cur = head;\\n    while (cur && cur->next) {\\n        if(cur->val == cur->next->val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189606,
                "title": "4-simple-solutions-javascript",
                "content": "**Solution #1**\\nThis solution **CAN NOT** be used if the array is not sorted.\\n\\nO(1) Space\\nO(n) Time\\n\\n```\\nvar deleteDuplicates = function(head) {\\n    let cur = head;\\n    \\n    while (cur && cur.next) {\\n        if (cur.val === cur.next.val) {\\n            // skip duplicates\\t\\t\\t\\t\\n            cur.next = cur.next.next;\\n        } else {\\n            cur = cur.next;\\n        }\\n    }\\n    \\n    return head;\\n}\\n```\\n\\n**Solution #2**\\n\\nfast and slow\\nO(1) Space\\nO(n) Time\\n\\n ```\\n\\n var deleteDuplicates = function(head) {\\n\\t let preHead = new ListNode();\\n\\t preHead.next = head;\\n\\n\\t let cur = preHead.next;\\n\\t let prev = preHead;\\n\\n\\t while (cur) {\\n\\t\\t\\t // when dups are found don\\'t move prev.\\n\\t\\t\\t if (cur.val === prev.val) {\\n\\t\\t\\t\\t\\t prev.next = cur.next;\\n\\t\\t\\t } else {\\n\\t\\t\\t\\t\\t prev = prev.next;\\n\\t\\t\\t }\\n\\t\\t\\t cur = cur.next;\\n\\t }\\n\\n\\t return preHead.next;\\n }\\n ```\\n\\n**Solution #3**\\nthis solution can be used even if the array is not sorted.\\n\\nO(1) Space\\nO(n2) Time\\n\\n```\\n\\n var deleteDuplicates = function(head) {\\n    \\n    let current = head;\\n    \\n    while (current) {\\n        let runner = current;\\n        \\n        // remove dups after the current node \\n        while (runner.next) {\\n            if (runner.val === runner.next.val) {\\n                // skip Dups\\n                runner.next = runner.next.next;\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        current = current.next;   \\n    }\\n    \\n    return head;\\n}\\n```\\n\\n\\n**Solution #4**\\nUsing Hash Table\\n\\nthis solution can be used even if the array is not sorted.\\n\\nO(n) Space\\nO(n) Time\\n\\n```\\nvar deleteDuplicates = function(head) {\\n    const dups = {};\\n    let cur = head;\\n    let prev;\\n    while (cur) {\\n        if (!dups[cur.val]) {\\n            dups[cur.val] = true;\\n            prev = cur;\\n        } else {\\n            prev.next = cur.next;\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let cur = head;\\n    \\n    while (cur && cur.next) {\\n        if (cur.val === cur.next.val) {\\n            // skip duplicates\\t\\t\\t\\t\\n            cur.next = cur.next.next;\\n        } else {\\n            cur = cur.next;\\n        }\\n    }\\n    \\n    return head;\\n}\\n```\n```\\n\\n var deleteDuplicates = function(head) {\\n\\t let preHead = new ListNode();\\n\\t preHead.next = head;\\n\\n\\t let cur = preHead.next;\\n\\t let prev = preHead;\\n\\n\\t while (cur) {\\n\\t\\t\\t // when dups are found don\\'t move prev.\\n\\t\\t\\t if (cur.val === prev.val) {\\n\\t\\t\\t\\t\\t prev.next = cur.next;\\n\\t\\t\\t } else {\\n\\t\\t\\t\\t\\t prev = prev.next;\\n\\t\\t\\t }\\n\\t\\t\\t cur = cur.next;\\n\\t }\\n\\n\\t return preHead.next;\\n }\\n ```\n```\\n\\n var deleteDuplicates = function(head) {\\n    \\n    let current = head;\\n    \\n    while (current) {\\n        let runner = current;\\n        \\n        // remove dups after the current node \\n        while (runner.next) {\\n            if (runner.val === runner.next.val) {\\n                // skip Dups\\n                runner.next = runner.next.next;\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        current = current.next;   \\n    }\\n    \\n    return head;\\n}\\n```\n```\\nvar deleteDuplicates = function(head) {\\n    const dups = {};\\n    let cur = head;\\n    let prev;\\n    while (cur) {\\n        if (!dups[cur.val]) {\\n            dups[cur.val] = true;\\n            prev = cur;\\n        } else {\\n            prev.next = cur.next;\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28812,
                "title": "c-c-simple-solution",
                "content": "C++ version\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head;\\n        while(node != NULL){\\n           if((node->next != NULL) && (node->next->val == node->val))\\n           {\\n               ListNode* oldNext = node->next;\\n               node->next = node->next->next;\\n               delete oldNext;\\n           }\\n           else\\n               node = node->next;\\n       } \\n       return head;\\n    }\\n\\t\\nC# version\\n\\n    public ListNode DeleteDuplicates(ListNode head) {\\n         ListNode node = head;\\n        while(node != null){\\n           if((node.next != null) && (node.next.val == node.val))\\n               node.next = node.next.next;\\n           else\\n               node = node.next;\\n       } \\n       return head;       \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "C++ version\\n\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head;\\n        while(node != NULL){\\n           if((node->next != NULL) && (node->next->val == node->val))\\n           {\\n               ListNode* oldNext = node->next;\\n               node->next = node->next->next;\\n               delete oldNext;\\n           }\\n           else\\n               node = node->next;\\n       } \\n       return head;\\n    }\\n\\t\\nC# version\\n\\n    public ListNode DeleteDuplicates(ListNode head) {\\n         ListNode node = head;\\n        while(node != null){\\n           if((node.next != null) && (node.next.val == node.val))\\n               node.next = node.next.next;\\n           else\\n               node = node.next;\\n       } \\n       return head;       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28773,
                "title": "two-pointers-java-solution",
                "content": "        public ListNode deleteDuplicates(ListNode head) {\\n    \\t\\tif(head==null || head.next==null) return head;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode curr = p.next;\\n    \\t\\twhile(curr!=null) {\\n    \\t\\t\\tif(curr.val!=p.val) {\\n    \\t\\t\\t\\tp.next=curr;\\n    \\t\\t\\t\\tp=curr;\\n    \\t\\t\\t}\\n    \\t\\t\\tcurr=curr.next;\\n    \\t\\t}\\n    \\t\\tp.next=curr;\\n    \\t\\treturn head;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        public ListNode deleteDuplicates(ListNode head) {\\n    \\t\\tif(head==null || head.next==null) return head;\\n    \\t\\tListNode p = head;\\n    \\t\\tListNode curr = p.next;\\n    \\t\\twhile(curr!=null) {\\n    \\t\\t\\tif(curr.val!=p.val) {\\n    \\t\\t\\t\\tp.next=curr;\\n    \\t\\t\\t\\tp=curr;\\n    \\t\\t\\t}\\n    \\t\\t\\tcurr=curr.next;\\n    \\t\\t}\\n    \\t\\tp.next=curr;\\n    \\t\\treturn head;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3558535,
                "title": "simple-java-solution-beats-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode list = head;         \\n        while(list != null) {\\n            if (list.next == null) break; \\n            if (list.val == list.next.val) list.next = list.next.next;\\n            else list = list.next;\\n        }         \\n        return head;\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode list = head;         \\n        while(list != null) {\\n            if (list.next == null) break; \\n            if (list.val == list.next.val) list.next = list.next.next;\\n            else list = list.next;\\n        }         \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506654,
                "title": "fast-ts-js-solution-beats-97-19",
                "content": "![image.png](https://assets.leetcode.com/users/images/320f510c-a43a-4577-93ae-4bc05025084a_1683684477.138928.png)\\n\\nAs it is sorted we know that the next val can be similar. \\n\\nHence, we check for that and shift the pointer `->` `next`.\\n\\n# Code\\n```tsx\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let node = head\\n\\n    while(node !== null){\\n        if(node.next !== null){\\n            if(node.val === node.next.val){\\n                node.next = node.next.next\\n                continue\\n            }\\n        }\\n\\n        node = node.next\\n    }\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```tsx\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let node = head\\n\\n    while(node !== null){\\n        if(node.next !== null){\\n            if(node.val === node.next.val){\\n                node.next = node.next.next\\n                continue\\n            }\\n        }\\n\\n        node = node.next\\n    }\\n\\n    return head\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451851,
                "title": "easy-solution",
                "content": "# Approach\\n![image.png](https://assets.leetcode.com/users/images/feca6847-02cc-4730-911b-6254abae6b57_1682368667.526796.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode current = head;\\n\\n        while (current != null && current.next != null) {\\n            if (current.val == current.next.val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n\\n        return head;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998601,
                "title": "simple-fast-and-efficient-c-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the next value is same, then simply connect the current node to the next-to-next node and repeat this process until you reach the end which is NULL\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I am handling the edge case where the first node is empty because not only that is a good practice but leetcode always has such test cases too : )\\n# Complexity\\n- Time complexity: O(n) (Worst Case) (Since we have to go through the entire list)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) (Since we are not creating new nodes)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Handling the Edge Case of empty list\\n        if(head == NULL) \\n            return head;\\n        ListNode* temp = head;\\n        // This is our temporary variable \\n        // We will use it to iterate through the list\\n        // While the head pointer remains intact\\n\\n        while(temp->next != NULL){\\n            // Since we have to compare the next node\\'s value\\n            // Our main condition is whether next node is NULL\\n            if(temp->next->val == temp->val){\\n                temp->next = temp->next->next;\\n                // Skip over the node connecting to next one\\n            }\\n            else{\\n                temp = temp->next; // Simply move through the list\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Handling the Edge Case of empty list\\n        if(head == NULL) \\n            return head;\\n        ListNode* temp = head;\\n        // This is our temporary variable \\n        // We will use it to iterate through the list\\n        // While the head pointer remains intact\\n\\n        while(temp->next != NULL){\\n            // Since we have to compare the next node\\'s value\\n            // Our main condition is whether next node is NULL\\n            if(temp->next->val == temp->val){\\n                temp->next = temp->next->next;\\n                // Skip over the node connecting to next one\\n            }\\n            else{\\n                temp = temp->next; // Simply move through the list\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884254,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863725,
                "title": "javascript-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\n\\nvar deleteDuplicates = function(head) {\\n    if(head===null) return head;\\n    let node  = head;\\n    while(node && node.next) {\\n        if(node.next.val === node.val) {\\n            node.next = node.next.next\\n        }else {\\n            node = node.next\\n        }\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\n\\nvar deleteDuplicates = function(head) {\\n    if(head===null) return head;\\n    let node  = head;\\n    while(node && node.next) {\\n        if(node.next.val === node.val) {\\n            node.next = node.next.next\\n        }else {\\n            node = node.next\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2862948,
                "title": "easy-to-understand-cpp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* prev=head;\\n        ListNode* nnext=head;\\n        while(nnext!=NULL && prev->next!=NULL){\\n            nnext=prev->next;\\n            if(nnext->val==prev->val){\\n                prev->next=prev->next->next;\\n                delete nnext;\\n                nnext=prev->next;\\n                continue;\\n            }\\n            prev=nnext;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* prev=head;\\n        ListNode* nnext=head;\\n        while(nnext!=NULL && prev->next!=NULL){\\n            nnext=prev->next;\\n            if(nnext->val==prev->val){\\n                prev->next=prev->next->next;\\n                delete nnext;\\n                nnext=prev->next;\\n                continue;\\n            }\\n            prev=nnext;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754975,
                "title": "java-runtime-0ms-faster-than-100-memory-usage-less-than-95-98",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode sentinel = new ListNode(0, head);\\n        ListNode pred = sentinel;\\n\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                pred.next = head.next;\\n            } else {\\n                pred = pred.next;\\n            }\\n            head = head.next;\\n        }\\n        return sentinel.next;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/986282c2-03ac-4cbb-9bbf-4b52311cd57e_1667028644.6378608.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode sentinel = new ListNode(0, head);\\n        ListNode pred = sentinel;\\n\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                pred.next = head.next;\\n            } else {\\n                pred = pred.next;\\n            }\\n            head = head.next;\\n        }\\n        return sentinel.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732826,
                "title": "c-java-0-ms-100-00-faster-4-lines-code",
                "content": "````\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *ans = head;\\n        while(ans && ans->next){\\n            if(ans->val == ans->next->val) ans->next = ans->next->next;\\n            else ans = ans->next;\\n        }\\n        return head;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *ans = head;\\n        while(ans && ans->next){\\n            if(ans->val == ans->next->val) ans->next = ans->next->next;\\n            else ans = ans->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460238,
                "title": "java-most-decisive-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)\\n            return head;\\n \\n        ListNode j = head;\\n \\n        while( j!= null && j.next != null){\\n            if(j.val == j.next.val){\\n                j.next = j.next.next;\\n            }else{\\n                j = j.next; \\n            }\\n        }\\n \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)\\n            return head;\\n \\n        ListNode j = head;\\n \\n        while( j!= null && j.next != null){\\n            if(j.val == j.next.val){\\n                j.next = j.next.next;\\n            }else{\\n                j = j.next; \\n            }\\n        }\\n \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184653,
                "title": "python-easy-solution-explained-beginners",
                "content": "**Try to read explaination, mainly in the note, you will get very clear understanding how to do these kind of problems.**\\n* Since given linked list is in sorted manner, it is guaranteed that duplicates will be together.\\n* So, we check the current node value with the next node\\'s value\\n\\t* if it is True:\\n\\t\\t* we simply point current node\\'s next with next node\\'s next \\n\\t* else:\\n\\t\\t* we simply move our pointer to next node.\\n\\n**NOTE** -\\n* we are not moving our currrent pointer to next after finding duplicate and changing current\\'s next to next node\\'s next. we are doing it only if we donot find any duplicates. **why**?\\n\\t* it will work for every case, but it will fail for the case if we have duplicates at the end.\\n\\t* let\\'s take an example of [1, 1, 2, 3, 3]\\n\\t* while head.next:\\n\\t\\t* head.val == head.next.val; simply point head.next = head.next.next \\n\\t\\t* and if we move head pointer to head.next, that is fine currpointer is at 2. head.val != head.next.val, move head pointer to next\\n\\t\\t* head.val == head.next.val, simply point head.next = head.next.next. and if we move head pointer to head.next, now current head is at None and our LL is 1->2->3. and when we are checking while loop we get an error that None doesn\\'t have next.\\n\\t\\t* so if we donot move our pointer to next if we find the duplicate then we will be able to cover all the cases.\\n* Now, you can get doubt what if we have while condition as while head:\\n\\t* that\\'s completely normal, here we are comparing current\\'s value with it\\'s next value. so at first we have to check whether curr.next is present or not.\\n* after every thing is done simply return the head that we stored in a temp, since we are moving our head pointer.\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return\\n        temp = head\\n        while head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return temp\\n```\\n**Kindly Upvote if it helps :)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:\\n            return\\n        temp = head\\n        while head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119715,
                "title": "javascript-efficient-solution-meme",
                "content": "The key idea is traverse through list, and compare next node value with current, but step to the next node only if value is different\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    const headPointer = head;\\n    \\n    while (head !== null) {\\n        if (head.next !== null && head.val === head.next.val) {\\n            head.next = head.next.next;\\n        } else {\\n            head = head.next;\\n        }\\n    }\\n    \\n    return headPointer;\\n};\\n```\\n\\n**If you like solution or meme, upvote for motivate me**\\n\\nMeme#13 *see my other solutions for more memes!\\n\\n![image](https://assets.leetcode.com/users/images/acb34c8e-1feb-46e6-bf1b-63f75af2b4a9_1654544828.9435894.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    const headPointer = head;\\n    \\n    while (head !== null) {\\n        if (head.next !== null && head.val === head.next.val) {\\n            head.next = head.next.next;\\n        } else {\\n            head = head.next;\\n        }\\n    }\\n    \\n    return headPointer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106100,
                "title": "c-simple-solution",
                "content": "**upvote if you liked the solution(^ _^)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode* temp= head;\\n        while(temp->next!=NULL){\\n            if(temp->val!= temp->next->val) temp = temp->next;\\n            else\\n                temp->next= temp->next->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL) return head;\\n        ListNode* temp= head;\\n        while(temp->next!=NULL){\\n            if(temp->val!= temp->next->val) temp = temp->next;\\n            else\\n                temp->next= temp->next->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704166,
                "title": "python-3-30ms-faster-than-98-iterative-5-lines-solution-easy-approach",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        cur=head\\n        while cur and cur.next:\\n            if cur.val==cur.next.val:\\n                cur.next=cur.next.next\\n                continue\\n            cur=cur.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        cur=head\\n        while cur and cur.next:\\n            if cur.val==cur.next.val:\\n                cur.next=cur.next.next\\n                continue\\n            cur=cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631411,
                "title": "iterative-simple-and-easy-c",
                "content": "Implementation\\n\\n**Iterative Approach\\nTime Complexity = O(N), Space Complexity = O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur = head;\\n        while(cur){            \\n            if(cur->next && cur->next->val == cur->val) cur->next = cur->next->next;\\n            else cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur = head;\\n        while(cur){            \\n            if(cur->next && cur->next->val == cur->val) cur->next = cur->next->next;\\n            else cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570831,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n def deleteDuplicates(head: ListNode): ListNode = {\\n    head match {\\n      case h if h == null => h\\n      case h if h.next == null => h\\n      case h if h.next.x == h.x => deleteDuplicates(h.next)\\n      case h => new ListNode(h.x, deleteDuplicates(h.next))\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n def deleteDuplicates(head: ListNode): ListNode = {\\n    head match {\\n      case h if h == null => h\\n      case h if h.next == null => h\\n      case h if h.next.x == h.x => deleteDuplicates(h.next)\\n      case h => new ListNode(h.x, deleteDuplicates(h.next))\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1511046,
                "title": "python-simplest-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        tempHead = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return tempHead\\n            \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        tempHead = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                head.next = head.next.next\\n            else:\\n                head = head.next\\n        return tempHead\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354556,
                "title": "python-solution-for-remove-duplicates-from-sorted-list",
                "content": "**Method 1**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        l1 = head\\n        values = set()\\n        while l1:\\n            values.add(l1.val)\\n            l1 = l1.next\\n            \\n        dummy = current = ListNode(0)\\n        values = sorted(values)\\n        for i in values:\\n            current.next = ListNode(val=int(i))\\n            current = current.next\\n                  \\n        current.next = None\\n        return dummy.next\\n```\\n\\n**Method 2**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```\\n\\t \\nIf you like it, please **UPVOTE** it motivates me to write more of these posts !!\\nHappy Coding :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        l1 = head\\n        values = set()\\n        while l1:\\n            values.add(l1.val)\\n            l1 = l1.next\\n            \\n        dummy = current = ListNode(0)\\n        values = sorted(values)\\n        for i in values:\\n            current.next = ListNode(val=int(i))\\n            current = current.next\\n                  \\n        current.next = None\\n        return dummy.next\\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr=curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117432,
                "title": "faster-than-100-c-short-solution-without-memory-leak",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *temp=head;\\n        while(temp)\\n        {\\n            int element=temp->val;\\n            while(temp->next && element==temp->next->val) //checks if node after temp is its duplicate\\n\\t\\t\\t//since nodes are deleted U don\\'t need to move temp (temp=temp->next) \\n            {\\n                ListNode* m=temp->next;\\n                temp->next=m->next;\\n                delete m;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *temp=head;\\n        while(temp)\\n        {\\n            int element=temp->val;\\n            while(temp->next && element==temp->next->val) //checks if node after temp is its duplicate\\n\\t\\t\\t//since nodes are deleted U don\\'t need to move temp (temp=temp->next) \\n            {\\n                ListNode* m=temp->next;\\n                temp->next=m->next;\\n                delete m;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 972872,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        curr = head\\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        curr = head\\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869704,
                "title": "easy-python-beats-98-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head: return\\n\\t\\t# We\\'ll track the prev and current nodes.\\n        prev = head\\n        cur = head.next\\n\\t\\t# Set the prev.next to None (we update this when we find the next != node)\\n        prev.next = None\\n        while cur:\\n\\t\\t    # If the vals of the two nodes are the same advance cur.\\n            if cur.val == prev.val:\\n                cur = cur.next\\n\\t\\t\\t# Otherwise we know they are different vals.\\n            else:\\n\\t\\t\\t    # We set our prevs next to the current node.\\n                prev.next = cur\\n\\t\\t\\t\\t# We advance cur.\\n                cur = cur.next\\n\\t\\t\\t\\t# We advance prev.\\n                prev = prev.next\\n\\t\\t\\t\\t# Then set prev.next to None until we find another node.\\n                prev.next = None\\n                \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head: return\\n\\t\\t# We\\'ll track the prev and current nodes.\\n        prev = head\\n        cur = head.next\\n\\t\\t# Set the prev.next to None (we update this when we find the next != node)\\n        prev.next = None\\n        while cur:\\n\\t\\t    # If the vals of the two nodes are the same advance cur.\\n            if cur.val == prev.val:\\n                cur = cur.next\\n\\t\\t\\t# Otherwise we know they are different vals.\\n            else:\\n\\t\\t\\t    # We set our prevs next to the current node.\\n                prev.next = cur\\n\\t\\t\\t\\t# We advance cur.\\n                cur = cur.next\\n\\t\\t\\t\\t# We advance prev.\\n                prev = prev.next\\n\\t\\t\\t\\t# Then set prev.next to None until we find another node.\\n                prev.next = None\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738168,
                "title": "c-simplest-solution-beats-98",
                "content": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *temp=head;\\n        while(temp) {\\n        \\twhile(temp->next && temp->val==temp->next->val) {\\n                ListNode *t=temp->next->next;\\n                delete temp->next;\\n        \\t\\ttemp->next=t;\\n        \\t}\\n        \\ttemp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *temp=head;\\n        while(temp) {\\n        \\twhile(temp->next && temp->val==temp->next->val) {\\n                ListNode *t=temp->next->next;\\n                delete temp->next;\\n        \\t\\ttemp->next=t;\\n        \\t}\\n        \\ttemp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502590,
                "title": "recursive-solution-for-concept-building",
                "content": "class Solution:\\n    \\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        \\n            if head is None:\\n                return\\n    \\n            if head.next is not None:\\n        \\n                if head.val == head.next.val:\\n            \\n                    temp = head.next.next\\n                    head.next = None\\n                    head.next = temp\\n                    self.deleteDuplicates(head)\\n                else:\\n            \\n                    self.deleteDuplicates(head.next)\\n            \\n            return head\\n                                      \\n        \\n            \\n            \\n        \\n        \\n        \\n            \\n            \\n        \\n        \\n\\t\\t\\n#steps:\\n#1) check if head is None > \\n#2) check if head.next is not None> \\n#above two condition helps not to call on None type object\\n#3) compare 1st element of LL to 2nd(head.val == head.val.next)\\n#4) if they are same store the next.next element of LL in temp\\n#5) break the LL by assigning head.next = None\\n#6) now assign head.next to temp \\n#7) now call on self.deleteDuplicates(head) \\n#you wont choose head.next because it fails for  1->1->1->NONE\\n#8) WHEN next element is not same : more forward >self.deleteDuplicates(head.next)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "class Solution:\\n    \\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        \\n            if head is None:\\n                return\\n    \\n            if head.next is not None:\\n        \\n                if head.val == head.next.val:\\n            \\n                    temp = head.next.next\\n                    head.next = None\\n                    head.next = temp\\n                    self.deleteDuplicates(head)\\n                else:\\n            \\n                    self.deleteDuplicates(head.next)\\n            \\n            return head\\n                                      \\n        \\n            \\n            \\n        \\n        \\n        \\n            \\n            \\n        \\n        \\n\\t\\t\\n#steps:\\n#1) check if head is None > \\n#2) check if head.next is not None> \\n#above two condition helps not to call on None type object\\n#3) compare 1st element of LL to 2nd(head.val == head.val.next)\\n#4) if they are same store the next.next element of LL in temp\\n#5) break the LL by assigning head.next = None\\n#6) now assign head.next to temp \\n#7) now call on self.deleteDuplicates(head) \\n#you wont choose head.next because it fails for  1->1->1->NONE\\n#8) WHEN next element is not same : more forward >self.deleteDuplicates(head.next)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 275378,
                "title": "javascript-solution-simple",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    let curr = head;\\n    \\n    while(curr.next) {\\n        if (curr.val === curr.next.val) {\\n            curr.next = curr.next.next;\\n        } else {\\n            curr = curr.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    if (!head) return head;\\n    \\n    let curr = head;\\n    \\n    while(curr.next) {\\n        if (curr.val === curr.next.val) {\\n            curr.next = curr.next.next;\\n        } else {\\n            curr = curr.next;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 241787,
                "title": "python-3-pointer-listnode-100-96",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        now = head\\n        while head and now.next:\\n            if now.val == now.next.val:\\n                now.next = now.next.next\\n            else:\\n                now = now.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        now = head\\n        while head and now.next:\\n            if now.val == now.next.val:\\n                now.next = now.next.next\\n            else:\\n                now = now.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28618,
                "title": "iterative-python-solution-beats-99-8",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        current = head\\n        while current and current.next: \\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 28623,
                "title": "recursive-solution-in-swift-and-my-illustration",
                "content": "Here is my swift code and my illustration for someone who can hardly understand recursive as me ... :)\\n\\n```\\nfunc deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n    if head == nil || head?.next == nil { return head }\\n    head!.next = deleteDuplicates(head!.next)\\n    return head!.val == head!.next?.val ? head!.next : head\\n}\\n```\\n![](https://windsuzu.github.io/leetcode-83/remove_nodes.gif)",
                "solutionTags": [],
                "code": "```\\nfunc deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n    if head == nil || head?.next == nil { return head }\\n    head!.next = deleteDuplicates(head!.next)\\n    return head!.val == head!.next?.val ? head!.next : head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969975,
                "title": "100-faster-java-c-short-and-easy-for-understanding",
                "content": "\\n\\n# Approach\\n- Create ListNode Current for point nodes\\n- Initialy Current point to head\\n\\n- Iterate while loop until last Node\\n- if next node value is erqual to current node value than skip next node and jump to next node of next node.\\n  else next node value are different than current node value than make current node = next node\\n- Example 1:\\n  1 -> 1 -> 2\\n  initialy current node is first 1\\n  next node of current node is second 1\\n  both have same values so we update current.next for skip next element\\n current.next(second 1)=current.next.next(2) \\n 1 -> 2 \\n\\n# Complexity\\n- Time complexity: O(n);\\n\\n- Space complexity: O(1);\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        ListNode* Current=head;\\n\\n        while(Current!=NULL && Current->next!=NULL)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n\\n            if(Current->val==Current->next->val)\\n            {\\n                Current->next=Current->next->next;\\n            }\\n            else\\n            {\\n                Current=Current->next;\\n            }\\n        }\\n        return head;  \\n    }\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) \\n    {\\n        ListNode Current=head;\\n\\n        while(Current!=null && Current.next!=null)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n            if(Current.val==Current.next.val)\\n            {\\n                Current.next=Current.next.next;\\n            }\\n            else\\n            {\\n                Current=Current.next;\\n            }\\n        }\\n        return head;    \\n    }\\n}\\n```\\n\\nUpvote if code is usefull for you.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        ListNode* Current=head;\\n\\n        while(Current!=NULL && Current->next!=NULL)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n\\n            if(Current->val==Current->next->val)\\n            {\\n                Current->next=Current->next->next;\\n            }\\n            else\\n            {\\n                Current=Current->next;\\n            }\\n        }\\n        return head;  \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) \\n    {\\n        ListNode Current=head;\\n\\n        while(Current!=null && Current.next!=null)\\n        {\\n            // if next node value is silmilar to current node\\n            // skip next node and update current.next\\n            if(Current.val==Current.next.val)\\n            {\\n                Current.next=Current.next.next;\\n            }\\n            else\\n            {\\n                Current=Current.next;\\n            }\\n        }\\n        return head;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917726,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916584,
                "title": "python3-beats-90-efficient-removal-of-duplicates-from-a-sorted-linked-list",
                "content": "# Intuition\\nOur goal is to remove duplicate nodes while maintaining the order. Since the list is sorted, duplicate nodes will be adjacent to each other. We just need to skip them.\\n\\n# Approach\\n1. We start with a pointer called `curr` that initially points to the `head` of the linked list.\\n1. We use a while loop to iterate through the linked list as long as `curr` is not None and `curr.next` is not None. This loop will help us traverse the linked list and examine each pair of adjacent nodes.\\n1. Inside the loop, we compare the value of the current node `curr `with the value of the next node `curr.next`.\\n1. If the values are equal, it means we\\'ve found a duplicate node. In this case, we **update the next pointer of the current node** `curr` **to skip the next node and directly point to the node after the duplicate.** This effectively removes the duplicate node from the linked list.\\n1. If the values are not equal i.e. not duplicates, we move the `curr` **pointer** **one step forward** to examine the next pair of nodes.\\n1. The loop continues until we reach the end of the linked list or until we\\'ve checked all pairs of adjacent nodes.\\n1. Finally, we return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\nThe algorithm iterates through the entire linked list once. Thus, the time complexity is $$O(n)$$, where n is the number of nodes in the linked list.\\n\\n- Space complexity:\\nWe are using only a constant amount of extra space to store the curr pointer. No additional data structures are used, so the space complexity is $$O(1)$$.\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Sort"
                ],
                "code": "```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789177,
                "title": "c-solution-o-1-space-optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL  ||  head->next==NULL) return head;\\n\\n        ListNode*prev=NULL;\\n        ListNode*temp=NULL;\\n        ListNode*curr=head;\\n\\n        while(curr!=NULL){\\n            if(prev==NULL){\\n                prev=curr;\\n                temp=prev;\\n                curr=curr->next;\\n                continue;\\n            }\\n            if(curr->val == prev->val){\\n                curr=curr->next;\\n                if(curr==NULL) prev->next=NULL;\\n            }\\n            else{\\n                prev->next=curr;\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL  ||  head->next==NULL) return head;\\n\\n        ListNode*prev=NULL;\\n        ListNode*temp=NULL;\\n        ListNode*curr=head;\\n\\n        while(curr!=NULL){\\n            if(prev==NULL){\\n                prev=curr;\\n                temp=prev;\\n                curr=curr->next;\\n                continue;\\n            }\\n            if(curr->val == prev->val){\\n                curr=curr->next;\\n                if(curr==NULL) prev->next=NULL;\\n            }\\n            else{\\n                prev->next=curr;\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761114,
                "title": "siimple-linked-list-solution-easy-to-understand-simple-logic",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL or head->next==NULL)return head;\\n        ListNode* p=head;\\n        while(p!=NULL and p->next!=NULL){\\n            if(p->val==p->next->val){\\n                p->next=p->next->next;\\n            }\\n            else{\\n                p=p->next;\\n            }\\n        }\\n        return head;\\n      }\\n    };",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL or head->next==NULL)return head;\\n        ListNode* p=head;\\n        while(p!=NULL and p->next!=NULL){\\n            if(p->val==p->next->val){\\n                p->next=p->next->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3459803,
                "title": "100-simple-and-easy-code-for-removing-duplicates",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while(current != null && current.next != null) {\\n            if(current.val == current.next.val) {\\n                current.next = current.next.next;\\n            }\\n            else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while(current != null && current.next != null) {\\n            if(current.val == current.next.val) {\\n                current.next = current.next.next;\\n            }\\n            else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446457,
                "title": "two-pointer-approach-with-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove the duplicates from the linked list !!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, prev and curr, with the first and the second nodes of the linked list, respectively.\\n2. While curr is not NULL, compare the value of curr and prev nodes.\\n3. If they have the same value, update prev->next to curr->next and move curr to the next node.\\n4. If they have different values, move both prev and curr to their next nodes.\\n5. Return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL)\\n        {\\n            return head;\\n        }\\n\\n        ListNode* curr = head->next;\\n        ListNode* prev = head;\\n\\n        if(curr == NULL || prev == NULL)\\n        {\\n            return head;\\n        }\\n\\n        while(curr != NULL)\\n        {\\n            if(curr->val == prev->val)\\n            {\\n                curr = curr->next;\\n                prev->next = curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL)\\n        {\\n            return head;\\n        }\\n\\n        ListNode* curr = head->next;\\n        ListNode* prev = head;\\n\\n        if(curr == NULL || prev == NULL)\\n        {\\n            return head;\\n        }\\n\\n        while(curr != NULL)\\n        {\\n            if(curr->val == prev->val)\\n            {\\n                curr = curr->next;\\n                prev->next = curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436205,
                "title": "easy-python3-solution-with-explanation",
                "content": "# Explanation \\n\\n- Set curr to the head and iterate till `curr` and `curr.next` is not None\\n- if `curr` node and `curr.next` have same value then just skip that node and set `curr.next = curr.next.next` else `curr = curr.next` and just return the `head`\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val == curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334014,
                "title": "easiest-solution-ever-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null) {\\n            while(temp.next != null && temp.next.val == temp.val) \\n                temp.next = temp.next.next;\\n            temp = temp.next;\\n        } return head;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head;\\n        while (temp != null) {\\n            while(temp.next != null && temp.next.val == temp.val) \\n                temp.next = temp.next.next;\\n            temp = temp.next;\\n        } return head;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332247,
                "title": "different-solutions-using-map-and-iterative-way",
                "content": "**1. Using Hasmap to store the occurence of all nodes values(i.e. frequency) , and then again traverse to find frequency>1 , if yes remove that node.**\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n    \\n    if(head == NULL || head->next == NULL) return head;   // if head is null or head ka next is null (i.e only one element ) then return head .\\n\\n    ListNode* temp = head;\\n\\n    map<int,int> m;\\n\\n    while(temp != nullptr){\\n        m[temp->val]++;\\n        temp = temp->next;\\n    }\\n    temp = head;\\n    while(temp != nullptr){\\n        \\n        if(m[temp->val]>1){              // If frquency is greater than 1 , then remove that node and decrease the frequency\\n            m[temp->val]--;\\n            ListNode* del = temp->next;\\n            temp->next = del->next;    // remove the connection of temp node using a new node del which is pointing to temp ka next.\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n        \\n        \\n\\n    }\\n    \\n    return head;\\n\\n}\\n};\\n```\\n2. Iterative Approach .\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n\\n    ListNode* temp = head;\\n\\n    \\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }\\n\\n    while(temp->next != nullptr){\\n\\n        if(temp->val == temp->next->val){\\n            ListNode* del = temp->next;\\n            temp->next = del->next;\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n\\n        \\n    }\\n\\nreturn head;\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n    \\n    if(head == NULL || head->next == NULL) return head;   // if head is null or head ka next is null (i.e only one element ) then return head .\\n\\n    ListNode* temp = head;\\n\\n    map<int,int> m;\\n\\n    while(temp != nullptr){\\n        m[temp->val]++;\\n        temp = temp->next;\\n    }\\n    temp = head;\\n    while(temp != nullptr){\\n        \\n        if(m[temp->val]>1){              // If frquency is greater than 1 , then remove that node and decrease the frequency\\n            m[temp->val]--;\\n            ListNode* del = temp->next;\\n            temp->next = del->next;    // remove the connection of temp node using a new node del which is pointing to temp ka next.\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n        \\n        \\n\\n    }\\n    \\n    return head;\\n\\n}\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode *deleteDuplicates(ListNode *head) {\\n\\n    ListNode* temp = head;\\n\\n    \\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }\\n\\n    while(temp->next != nullptr){\\n\\n        if(temp->val == temp->next->val){\\n            ListNode* del = temp->next;\\n            temp->next = del->next;\\n            delete del;\\n        }else{\\n            temp = temp->next;\\n        }\\n\\n        \\n    }\\n\\nreturn head;\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142463,
                "title": "easy-c-solution-linked-list-best-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approache by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n \\n /*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        while(curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                curr->next = curr->next->next;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n \\n /*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        while(curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                curr->next = curr->next->next;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030179,
                "title": "updated-step-wise-java-beats-100-runtime-100-space-easy-to-understand",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe list is already sorted so we only need to check the consecutive ListNode values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    1. Check the base condition.\\n    2. Traverse the list to access the element.\\n    3. Compare the consecutive node values. \\n    4. Remove the duplicate elements.\\n    5. Finally, return the head node.\\nFollow the code below to understand the solution.\\n\\n              **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n        //Step: 1\\n        //if the list is empty, return null.\\n        if(head == null) return head;\\n        \\n        //initialize preNode from head.\\n        ListNode preNode = head;\\n\\n        //initialize curNode from head.next.\\n        ListNode preNode = head.next;\\n\\n\\n        //Step: 2\\n        //Traverse till the last node.\\n        while(curNode != null)\\n        {\\n            //Step: 3\\n            //if the consecutive nodes have duplicate value.\\n            if(preNode.val==curNode.val)\\n            {\\n                //Step: 4\\n                //change the pointers to delete curNode.\\n                preNode.next=curNode.next;\\n            }\\n            //if the values are not duplicate.\\n            else\\n            {\\n                //Simply, update the preNode to curNode.\\n                preNode=curNode;\\n            }\\n            //curNode reference will get updated in both cases.\\n            //So, write it out of if-else block.\\n            curNode=curNode.next;\\n        }\\n\\n        //Step: 5\\n        //Finally, return the head node.\\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n\\n        //Step: 1\\n        //if the list is empty, return null.\\n        if(head == null) return head;\\n        \\n        //initialize preNode from head.\\n        ListNode preNode = head;\\n\\n        //initialize curNode from head.next.\\n        ListNode preNode = head.next;\\n\\n\\n        //Step: 2\\n        //Traverse till the last node.\\n        while(curNode != null)\\n        {\\n            //Step: 3\\n            //if the consecutive nodes have duplicate value.\\n            if(preNode.val==curNode.val)\\n            {\\n                //Step: 4\\n                //change the pointers to delete curNode.\\n                preNode.next=curNode.next;\\n            }\\n            //if the values are not duplicate.\\n            else\\n            {\\n                //Simply, update the preNode to curNode.\\n                preNode=curNode;\\n            }\\n            //curNode reference will get updated in both cases.\\n            //So, write it out of if-else block.\\n            curNode=curNode.next;\\n        }\\n\\n        //Step: 5\\n        //Finally, return the head node.\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005436,
                "title": "easy-java-solution-beats-100",
                "content": "Hope this helps.\\nDo Upvote if you like it !!\\n\\nThanks :)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode node) {\\n        if(node==null){\\n            return node;\\n        }\\n        ListNode head=node;\\n        while(node.next!=null){\\n            if(node.val==node.next.val){\\n                node.next=node.next .next;\\n            }\\n            else{\\n                node=node.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode node) {\\n        if(node==null){\\n            return node;\\n        }\\n        ListNode head=node;\\n        while(node.next!=null){\\n            if(node.val==node.next.val){\\n                node.next=node.next .next;\\n            }\\n            else{\\n                node=node.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974847,
                "title": "c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ans = deleteDuplicates(head->next);\\n        if(head->val == ans->val)\\n            head->next = ans->next;\\n        return head;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ans = deleteDuplicates(head->next);\\n        if(head->val == ans->val)\\n            head->next = ans->next;\\n        return head;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954526,
                "title": "my-first-easy-solution-0ms-100-java",
                "content": "- 166/166 cases passed (0 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 83.92 % of java submissions (42 MB)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        ListNode out=new ListNode(),t=out;\\n\\n        while(head!=null){\\n            while(head.next!=null && head.val==head.next.val)\\n                head=head.next;\\n            t.next=new ListNode(head.val);\\n            t=t.next;\\n            head=head.next;    \\n        }\\n        return out.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        ListNode out=new ListNode(),t=out;\\n\\n        while(head!=null){\\n            while(head.next!=null && head.val==head.next.val)\\n                head=head.next;\\n            t.next=new ListNode(head.val);\\n            t=t.next;\\n            head=head.next;    \\n        }\\n        return out.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809763,
                "title": "java-easy-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        //First we check if the head is null or not \\n        // if the head is null we simply return the head \\n        if(head == null) return head;\\n        ListNode node = head; \\n        //Here we perform a while loop until the node value is null \\n        while(node.next != null){\\n            //Through a if else condition we check if the value of the current node is equal to the value of the next node \\n            //if the value of the current node is same as the next one we simply skip the next node by \"node.next = node.next.next\"\\n            if(node.val == node.next.val) node.next = node.next.next;\\n            else node = node.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        //First we check if the head is null or not \\n        // if the head is null we simply return the head \\n        if(head == null) return head;\\n        ListNode node = head; \\n        //Here we perform a while loop until the node value is null \\n        while(node.next != null){\\n            //Through a if else condition we check if the value of the current node is equal to the value of the next node \\n            //if the value of the current node is same as the next one we simply skip the next node by \"node.next = node.next.next\"\\n            if(node.val == node.next.val) node.next = node.next.next;\\n            else node = node.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805997,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode listNode = head;\\n\\n        while (listNode != null && listNode.next != null) {\\n            if (listNode.val == listNode.next.val)  {\\n                listNode.next = listNode.next.next;\\n            } else {\\n                listNode = listNode.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode listNode = head;\\n\\n        while (listNode != null && listNode.next != null) {\\n            if (listNode.val == listNode.next.val)  {\\n                listNode.next = listNode.next.next;\\n            } else {\\n                listNode = listNode.next;\\n            }\\n        }\\n        return head;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790045,
                "title": "easy-solution-faster-than-97-of-solution",
                "content": "# Intuition\\nWe will link node to the next element which is not the duplicate\\n\\n# Approach\\nTake two pointer q and p , p will move faster and q will remain at head only. p will move until q->val==p->val;\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nNone\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        struct ListNode *p=head;\\n        struct ListNode *q=head;\\n       while(p){\\n       while( p && q && p->val==q->val){\\n           p=p->next;\\n       }\\n       q->next=p;\\n       q=p;\\n       if(p){\\n       p=p->next;\\n       }\\n       }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        struct ListNode *p=head;\\n        struct ListNode *q=head;\\n       while(p){\\n       while( p && q && p->val==q->val){\\n           p=p->next;\\n       }\\n       q->next=p;\\n       q=p;\\n       if(p){\\n       p=p->next;\\n       }\\n       }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728818,
                "title": "c-easy-solution",
                "content": "class Solution\\n{\\n    public:\\n        ListNode* deleteDuplicates(ListNode *head)\\n        {\\n            if (head == NULL)\\n                return head;\\n\\n            ListNode *curr = head;\\n            while (curr->next != NULL)\\n            {\\n                if (curr->val == curr->next->val)\\n                {\\n                    ListNode *temp = curr->next;\\n                    curr->next = curr->next->next;\\n                    delete temp;\\n                }\\n                else\\n                    curr = curr->next;\\n            }\\n            return head;\\n        }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution\\n{\\n    public:\\n        ListNode* deleteDuplicates(ListNode *head)\\n        {\\n            if (head == NULL)\\n                return head;\\n\\n            ListNode *curr = head;\\n            while (curr->next != NULL)\\n            {\\n                if (curr->val == curr->next->val)\\n                {\\n                    ListNode *temp = curr->next;\\n                    curr->next = curr->next->next;\\n                    delete temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2721853,
                "title": "linear-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        pt=head\\n        prev=pt\\n        pt=pt.next\\n        while pt:\\n            if pt.val==prev.val:\\n                prev.next=pt.next\\n                pt=pt.next\\n            else:\\n                prev=pt\\n                pt=pt.next\\n        return head\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        pt=head\\n        prev=pt\\n        pt=pt.next\\n        while pt:\\n            if pt.val==prev.val:\\n                prev.next=pt.next\\n                pt=pt.next\\n            else:\\n                prev=pt\\n                pt=pt.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663946,
                "title": "simple-and-efficient-approach-in-python",
                "content": "Hi Leets! I have solved it using a simple and efficient way. The algorithm I thought is that we will traverse through the linked list and if our current node is equal to the next node then we will just skip the next node and go to the next node of next. Through this we will be skipping the same nodes.\\n```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        current = head\\n        nxt = head.next\\n        while nxt is not None:\\n            if current.val == nxt.val:\\n                current.next = nxt.next\\n                nxt = current  # If there are more than two same elements we will check them again\\n            current = nxt\\n            nxt = nxt.next\\n        return head\\n```\\nIf any queries feel free to ask :)",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        current = head\\n        nxt = head.next\\n        while nxt is not None:\\n            if current.val == nxt.val:\\n                current.next = nxt.next\\n                nxt = current  # If there are more than two same elements we will check them again\\n            current = nxt\\n            nxt = nxt.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637753,
                "title": "o-n-100-faster-iterative",
                "content": "***Approach : i will traverse over the list if i find value of current node equal to value of next node i will jump to curr->next->node (equals to deleting the curr->next node ).***\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==nullptr)\\n            return head;\\n        \\n        ListNode *temp=head;\\n        \\n        while(temp){\\n            \\n                if(temp->next != nullptr and temp->val == temp->next->val){\\n                    temp->next = temp->next->next;\\n                }\\n                else{\\n                    temp=temp->next;\\n                }    \\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head==nullptr)\\n            return head;\\n        \\n        ListNode *temp=head;\\n        \\n        while(temp){\\n            \\n                if(temp->next != nullptr and temp->val == temp->next->val){\\n                    temp->next = temp->next->next;\\n                }\\n                else{\\n                    temp=temp->next;\\n                }    \\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637683,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head \\n        while curr :\\n            while curr.next and curr.next.val == curr.val:\\n                curr.next = curr.next.next\\n            curr = curr.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head \\n        while curr :\\n            while curr.next and curr.next.val == curr.val:\\n                curr.next = curr.next.next\\n            curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508423,
                "title": "simple-and-easy-java-solution-100-faster",
                "content": "```\\n\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while (current != null && current.next != null) {\\n            if (current.next.val == current.val) current.next = current.next.next;\\n            else current = current.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n        while (current != null && current.next != null) {\\n            if (current.next.val == current.val) current.next = current.next.next;\\n            else current = current.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248548,
                "title": "python-solution-explained-time-o-n-space-o-1",
                "content": "# Explaination:\\nThis problem is asking us to delete all duplicate nodes, so after we visit a node, if there are any other nodes with the same value, delete them and only keep the first instance of that node.\\n**Example:** 1->1->2->3\\nAs you can see `1` appears twice, we want to remove the duplicate, that would be the second `1`. \\nAfter removing it the result should look like: 1->2->3\\n\\n**Solution Breakdown:**\\n1. We create a variable `current` and initialize it to be the `head` of our linked list input\\n2. We setup our `while` loop to keep iterating while `current` and `current.next` are **NOT** `None`. The reason we do this is because we want to check the `current` node and one node after the `current` node and we want to compare their values to see if they are the same.\\n3. If the `current` node value is the same as the `current.next` value, we found a duplicate, so we change the pointer to skip the `.next` node and point to the node AFTER `current.next`. The reason why we do this is because we want to get rid of duplicates. So 1->1->2->3, the first `1` in that list will now skip the second `1` and point to the `2` like 1->2->3.\\n4. Notice how we don\\'t update `current`, we only update `current.next`, this is because there can be more duplicates. Imagine our input was 1->1->1->2->3. After updating `current.next` it would become 1->1->2->3, we deleted the second `1` in the list and pointed the first `1` to the third `1`. But if we update our current to be `current.next.next` we will end up not deleting the third `1` which is also a duplicate. `current` would point to that `1` and the next node after would be `2`, then our `if` statement would not catch the duplicate. Since we didn\\'t update the `current` we are still at the first `1` so `current.val` will be `1` and `current.next.val` will be `1` now we can delete that last one to make the list 1->2->3.\\n5. If `current` and `current.next` do not have the same values, we just update `current` like normal and set it to `current.next`\\n6. We return `head` after we finish.\\n\\n**Time O(N) | Space O(1):**\\nTime is O(N) because at most we are just going through the entire linked list once\\nSpace is O(1) because we don\\'t have anything saved in memory which is scaling with our input. We only have a variable which we use to update pointers.\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        \\n        while current and current.next:\\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        \\n        while current and current.next:\\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078592,
                "title": "my-sweet-o-n-solution-c",
                "content": "we have to traverse the linkedlist and have to ignore the duplicates by changing the link\\nby accessing the `prev` and `ptr->next` pointer which are neighbours of duplicate elements ,those pointer will help to remove the duplicate .\\n\\n\\n```\\n    ListNode *deleteDuplicates(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        ListNode *prev = ptr;\\n        if (!head)\\n        {\\n            return NULL;\\n        }\\n        while (ptr->next)\\n        {\\n            if (ptr->val == ptr->next->val)\\n            {\\n                ptr = ptr->next;\\n            }\\n            else\\n            {\\n                prev->next = ptr->next;\\n                ptr = ptr->next;\\n                prev = ptr;\\n            }\\n        }\\n        prev->next = NULL;\\n        return h;\\n    }\\n```\\n##### Feel free to ask any **doubts** in the comment section.\\n##### If you like this solution, do **UPVOTE**.\\n##### Happy Coding :)",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n    ListNode *deleteDuplicates(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        ListNode *prev = ptr;\\n        if (!head)\\n        {\\n            return NULL;\\n        }\\n        while (ptr->next)\\n        {\\n            if (ptr->val == ptr->next->val)\\n            {\\n                ptr = ptr->next;\\n            }\\n            else\\n            {\\n                prev->next = ptr->next;\\n                ptr = ptr->next;\\n                prev = ptr;\\n            }\\n        }\\n        prev->next = NULL;\\n        return h;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077456,
                "title": "rust-typescript",
                "content": "Runtime: 3 ms, faster than 55.95% of Rust online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 2.1 MB, less than 72.62% of Rust online submissions for Remove Duplicates from Sorted List.\\n\\n```\\ntype Node = Option<Box<ListNode>>;\\nimpl Solution {\\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        \\n        if head.is_none() { return None }        \\n        let mut curr_node = head.as_mut().unwrap();\\n        \\n        while let Some(node) = curr_node.next.as_mut() { \\n            if curr_node.val == node.val { \\n                curr_node.next = node.next.take()\\n            } else  { \\n                curr_node = curr_node.next.as_mut().unwrap()\\n            }\\n        }\\n        head \\n    }\\n}\\n```\\n\\n#### TypeScript \\nRuntime: 121 ms, faster than 31.50% of TypeScript online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 45 MB, less than 67.89% of TypeScript online submissions for Remove Duplicates from Sorted List.\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    if (!head) { return null; }\\n    \\n    let curr_node: ListNode = head;\\n    while (curr_node.next) { \\n        if (curr_node.val === curr_node.next.val) { \\n            curr_node.next = curr_node.next.next\\n        } else { \\n            curr_node = curr_node.next\\n        }\\n    }\\n    return head \\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ntype Node = Option<Box<ListNode>>;\\nimpl Solution {\\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        \\n        if head.is_none() { return None }        \\n        let mut curr_node = head.as_mut().unwrap();\\n        \\n        while let Some(node) = curr_node.next.as_mut() { \\n            if curr_node.val == node.val { \\n                curr_node.next = node.next.take()\\n            } else  { \\n                curr_node = curr_node.next.as_mut().unwrap()\\n            }\\n        }\\n        head \\n    }\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    if (!head) { return null; }\\n    \\n    let curr_node: ListNode = head;\\n    while (curr_node.next) { \\n        if (curr_node.val === curr_node.next.val) { \\n            curr_node.next = curr_node.next.next\\n        } else { \\n            curr_node = curr_node.next\\n        }\\n    }\\n    return head \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877373,
                "title": "simple-typescript-o-n-with-one-pointer",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let p = head;\\n    while(p && p.next) {\\n        if(p.val === p.next.val) {\\n            p.next = p.next.next;\\n        } else {\\n            p = p.next;\\n        }\\n    } \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n    let p = head;\\n    while(p && p.next) {\\n        if(p.val === p.next.val) {\\n            p.next = p.next.next;\\n        } else {\\n            p = p.next;\\n        }\\n    } \\n    return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837194,
                "title": "java-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\t\\n\\twhile(current != null && current.next != null){\\n\\t  if(current.val == current.next.val){\\n\\t      current.next = current.next.next;\\n\\t  }else{\\n\\t      current = current.next;\\n\\t  }\\n\\t}\\n\\treturn head;\\n    }\\n}\\n```\\nPerform a dry run for better understanding .\\nHappy coding,\\nUpvote if helped !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode current = head;\\n\\t\\n\\twhile(current != null && current.next != null){\\n\\t  if(current.val == current.next.val){\\n\\t      current.next = current.next.next;\\n\\t  }else{\\n\\t      current = current.next;\\n\\t  }\\n\\t}\\n\\treturn head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807742,
                "title": "python-3-faster-than-98-o-n",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None:\\n            return head\\n        ptr = head\\n        while(ptr.next!=None):\\n            if ptr.val==ptr.next.val:\\n                ptr.next = ptr.next.next\\n            else:\\n                ptr = ptr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None:\\n            return head\\n        ptr = head\\n        while(ptr.next!=None):\\n            if ptr.val==ptr.next.val:\\n                ptr.next = ptr.next.next\\n            else:\\n                ptr = ptr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779974,
                "title": "python-simple-and-efficient",
                "content": "```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        itr = head\\n        \\n        if itr is None:\\n            return itr\\n        \\n        while itr.next:\\n            if itr.val == itr.next.val:\\n                itr.next = itr.next.next\\n            else:\\n                itr = itr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        itr = head\\n        \\n        if itr is None:\\n            return itr\\n        \\n        while itr.next:\\n            if itr.val == itr.next.val:\\n                itr.next = itr.next.next\\n            else:\\n                itr = itr.next\\n        \\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769910,
                "title": "o-n-tc-and-o-1-space-algorithm-iterative",
                "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==temp->val){\\n                temp->next=temp->next->next;\\n                continue;\\n            }\\n            temp=temp->next;            \\n        }\\n        \\n        return head;\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==temp->val){\\n                temp->next=temp->next->next;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1759668,
                "title": "java-solution-with-dry-run",
                "content": "```\\n/*\\n curr\\n  1 --------> 2---------> 3 ----------> 3 ------->null\\n  \\n  curr.val = 1 , curr.next.val =2   1!=2 so move curr to it\\'s next \\n\\n\\n\\n            curr\\n  1 --------> 2---------> 3 ----------> 3 ------->null\\n\\ncurr.val = 2 , curr.next.val =3   2!=3 so move curr to it\\'s next \\n\\n\\n                        curr\\n  1 --------> 2---------> 3     3 ------->null\\n                          |________________|\\n  curr.val = 3 , curr.next.val =3   3==3 so move curr.next to it\\'s next\\'s next\\n  As we found the duplicate element hence breaking the link of duplicate elements\\n\\n\\nNow curr.next is pointing to null it means , we have removed all duplicate elements till curr and now we can return head of list\\n\\nFinal List\\n\\nhead\\n  1----------->2---------->3------>null\\n\\n*/\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null) return null;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr.next != null)\\n        {\\n            if(curr.val == curr.next.val)\\n            {\\n                curr.next = curr.next.next;\\n            }\\n            else\\n                curr = curr.next;\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null) return null;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr.next != null)\\n        {\\n            if(curr.val == curr.next.val)\\n            {\\n                curr.next = curr.next.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1664584,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val==curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        while curr and curr.next:\\n            if curr.val==curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626515,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null){\\n            return head;\\n        }\\n        ListNode temp=head;\\n        while(temp.next!=null){\\n            if(temp.val==temp.next.val){\\n                temp.next=temp.next.next;\\n            }else{\\n                temp=temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1584417,
                "title": "javascript-o-n-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    let curr = head;\\n    while(curr&&curr.next){\\n        if(curr.val === curr.next.val){\\n            curr.next = curr.next.next;\\n        }else{\\n            curr=curr.next;   \\n        }        \\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n    let curr = head;\\n    while(curr&&curr.next){\\n        if(curr.val === curr.next.val){\\n            curr.next = curr.next.next;\\n        }else{\\n            curr=curr.next;   \\n        }        \\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1495686,
                "title": "c-solution-o-n-t-c",
                "content": "Upvote if you like the solution ->\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while(temp!=NULL &&temp->next!=NULL){\\n            if(temp->val==temp->next->val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        while(temp!=NULL &&temp->next!=NULL){\\n            if(temp->val==temp->next->val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494834,
                "title": "short-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        if(head.val==head.next.val) head=deleteDuplicates(head.next);\\n        head.next =deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        if(head.val==head.next.val) head=deleteDuplicates(head.next);\\n        head.next =deleteDuplicates(head.next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450058,
                "title": "c-iterative-and-recursive-solutions",
                "content": "#### Iterative Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t\\tListNode* curr = head;\\n\\t\\t\\tListNode* temp = NULL;\\n\\t\\t\\twhile(curr && curr -> next){\\n\\t\\t\\t\\tif(curr -> val == curr -> next -> val){\\n\\t\\t\\t\\t\\ttemp = curr -> next;\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t\\tdelete temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};\\n#### Recursive Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t\\tif(!head || !(head -> next)){\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t}\\n\\t\\t\\tif(head -> val == head -> next -> val){\\n\\t\\t\\t\\tListNode* temp = head -> next;\\n\\t\\t\\t\\thead -> next = head -> next -> next;\\n\\t\\t\\t\\tdelete temp;\\n\\t\\t\\t\\tdeleteDuplicates(head);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tdeleteDuplicates(head -> next);\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t\\tListNode* curr = head;\\n\\t\\t\\tListNode* temp = NULL;\\n\\t\\t\\twhile(curr && curr -> next){\\n\\t\\t\\t\\tif(curr -> val == curr -> next -> val){\\n\\t\\t\\t\\t\\ttemp = curr -> next;\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t\\tdelete temp;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1435205,
                "title": "elixir-304-ms-50-9-mb-recursion-pattern-matching",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\\n  def delete_duplicates(nil), do: nil\\n  def delete_duplicates(%ListNode{val: _, next: nil} = current_node), do: current_node\\n                               \\n  def delete_duplicates(%ListNode{val: val, next: %ListNode{val: val, next: _} = next_node} = _current_node) do \\n    delete_duplicates(next_node)                      \\n  end\\n      \\n  def delete_duplicates(%ListNode{val: _, next: next_node} = current_node) do\\n    %ListNode{current_node | next: delete_duplicates(next_node)}\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec delete_duplicates(head :: ListNode.t | nil) :: ListNode.t | nil\\n  def delete_duplicates(nil), do: nil\\n  def delete_duplicates(%ListNode{val: _, next: nil} = current_node), do: current_node\\n                               \\n  def delete_duplicates(%ListNode{val: val, next: %ListNode{val: val, next: _} = next_node} = _current_node) do \\n    delete_duplicates(next_node)                      \\n  end\\n      \\n  def delete_duplicates(%ListNode{val: _, next: next_node} = current_node) do\\n    %ListNode{current_node | next: delete_duplicates(next_node)}\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1348034,
                "title": "c-code",
                "content": "Runtime: 4 ms, faster than 94.60% of C online submissions for Remove Duplicates from Sorted List.\\nMemory Usage: 6.5 MB, less than 66.03% of C online submissions for Remove Duplicates from Sorted List.\\n\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL || head->next == NULL)return head;\\n    struct ListNode *temp=head->next,*lastValidElement=head;\\n    while(temp!=NULL){\\n        if(temp->val != lastValidElement->val){\\n            lastValidElement->next=temp;\\n            lastValidElement=temp;\\n        }\\n        temp=temp->next;\\n    }\\n    lastValidElement->next=temp;\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    if(head==NULL || head->next == NULL)return head;\\n    struct ListNode *temp=head->next,*lastValidElement=head;\\n    while(temp!=NULL){\\n        if(temp->val != lastValidElement->val){\\n            lastValidElement->next=temp;\\n            lastValidElement=temp;\\n        }\\n        temp=temp->next;\\n    }\\n    lastValidElement->next=temp;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113182,
                "title": "c-83-remove-duplicates-from-sorted-list",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head; \\n        while (node) \\n            if (node->next && node->val == node->next->val) node->next = node->next->next; \\n            else node = node->next; \\n        return head; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* node = head; \\n        while (node) \\n            if (node->next && node->val == node->next->val) node->next = node->next->next; \\n            else node = node->next; \\n        return head; \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568765,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1572757,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1669069,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571190,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1805936,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571189,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2059381,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2051834,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2047974,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2046475,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1568765,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1572757,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1669069,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571190,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1805936,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 1571189,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2059381,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2051834,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2047974,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2046475,
                "content": [
                    {
                        "username": "samiksha_9",
                        "content": "Hi. \\n\\nI\\'m new to python programming. It\\'d be very helpful if someone can explain why do we use Optional?\\n\\n\\'\\'\\'\\n def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\'\\'\\'\\n\\n**Here, why do we use Optional[ListNode]? How is it useful? **\\n"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "https://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/\\nCheck here\\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In Python, the [Optional] type is used to represent values that can either be of some type T or None. It is often used as a function parameter or return type to indicate that the function can handle or return None values in addition to values of type T. This can be useful for representing the absence of a value, or to indicate that a function may not always return a value of type T."
                    },
                    {
                        "username": "apollo_codes",
                        "content": "It is so that head can have None value, so Optional provides an option of having its value as None other than than of the mentioned type"
                    },
                    {
                        "username": "hj414",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Can you please explain with some example? still didn\\'t understand, i am new to new to python CP. "
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It\\'s just an edge case that you\\'re likely need to handle on interview."
                    },
                    {
                        "username": "anlunx",
                        "content": "Why give a null test case?"
                    },
                    {
                        "username": "arobe91594",
                        "content": "From the constraints given, the number of elements in the input list includes 0. It is actually very important to handle those sorts of edge cases, especially if your function is going to handle user-generated or otherwise unfiltered data. Many vulnerabilities come from developers not considering edge cases."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Hello everyone, I am not able to understand that any changes done to current(temp pointer to the node) changes value in head. Can anyone explain\\n        var current = head;\\n        while (current.next != null) {\\n            if (current.next.val == current.val) {\\n                current.next = current.next.next;\\n            } \\n            else {\\n                current = current.next;\\n            }\\n        }\\n\\nIs it because its reference type? \\n        "
                    },
                    {
                        "username": "Aaditya720",
                        "content": "firstly you have to take a temp variable like `LinstNode current = head` then as you say about the reference, the current var has head reference that help us to traverse through all the list without interrupting the main content "
                    },
                    {
                        "username": "techguyash",
                        "content": "I tried same kind of solution But it didnt work for me too."
                    },
                    {
                        "username": "yixing",
                        "content": "In an interview, will that matter if we forget to delete the duplicate nodes? It appears we do not need to delete here."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "I Tryed the problem without excluding the duplicate pointers, it wont work, aparently it causes Time Limit Exceed. Anyways, it is important to deal properly with memory allocation. Memory leak can generate serious implications in your application."
                    },
                    {
                        "username": "arobe91594",
                        "content": "It is language-specific and it probably depends on the interviewer. If you are developing a c++ solution, the interviewer would probably care, but not so much in a C# solution. That being said, from the problem description, it is unclear how the input data was allocated, so blindly calling delete on a pointer is not a great option either.\\n\\nYou would need more context to know how to properly handle allocation."
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n=head\\n        if head is None:\\n            return None\\n        while n is not None and n.next is not None:\\n            #print(n.val)\\n            if n.val==n.next.val:\\n                n.next=n.next.next\\n            else:\\n                n=n.next\\n        return head\\n   ```"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@AnkitModak](/AnkitModak) because if you don\\'t assign a new node at the beginning, then at the end the head node will point to null or for your case \"none\" in python. That\\'s why you need a dummy head like n"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Hello, \\nCan you tell me why n = head works, but if I dont assign it to a variable, it doesnt?\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "# \\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post **any solutions** in this discussion."
                    },
                    {
                        "username": "kaiwensun",
                        "content": "![0_1472570012478_upload-707c3bc5-254d-4e5b-960f-7e3589b92fed](/uploads/files/1472570018113-upload-707c3bc5-254d-4e5b-960f-7e3589b92fed.png) \\nI bet most C/C++ coders didn't free memory of deleted nodes in their accepted solutions. But Java is still faster than C/C++..."
                    },
                    {
                        "username": "arobe91594",
                        "content": "For C/C++ solutions, there is not enough information in the problem description to assume that the memory for those nodes was dynamically allocated, so trying to free the memory is not necessarily the correct approach. That said, ignoring memory allocation is not a habit which new C/C++ programmers should form."
                    },
                    {
                        "username": "Niraj_Deore",
                        "content": "Does the question guarantee that there will be only 2 similar adjacent elements ??\\n\\nBeacause ,if there might be case like  [1->2->2->2->3] we need to use 2 loops."
                    },
                    {
                        "username": "abrumm",
                        "content": "You would still only need one loop if you are using a while and comparing the current and next value of the linked list. \\nExplanation: [1->2->2->2->3] as my linked list\\ncurrent = head; -> val 1\\nPass 1: Is 1 == 2? No, so move current to current.next which is 2\\nPass 2: Is 2 == 2? Yes, so we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 3: Is 2 == 2? Yes, so again we now we need to remove this. So we move our current.next pointer to the value after that\\nPass 4: Is 2 == 3? No, we move current to current.next\\nThere should be no pass five because current.next will be null since we are at the end of our linked list"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "Simple Approach \\n\\nIn this approach we will only use single pointer and iterate over the list while checking for duplicate nodes and deleting them simultanously also.\\n\\n1. Initialize a pointer to head, here I used \\'temp\\' and iterate it over the linked list.\\n\\n2. In each each iteration check if data of next node of temp and data of current node of temp are equal or not , if both data are equal then we have a duplicate value , so update the next node of \\'temp\\' to temp->next->next;\\n\\n3. While we update the next value of temp if duplicate value is found we also need to delete the node where duplicate value exist, NOTE:- It will be better practice if you store the node to be deleted in another variable and then delete this variable instead of directly deleting the node to be delected bcoz it may lead to errors.\\n\\n4. But if the next value of temp is not equal to temp i.e no duplicate value then move the temp to next position , repeat this process and when the loop terminates you will get your list without duplicate values."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Additional tests:\\n[1,1,1]\\n[1,2,2]\\n[1,1,2,3,3]\\n[1,1,2,2,3,3]\\n[1,2,2,3]\\n[1]\\n[]\\n[1,1]"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "I used two pointers and got the answer from my head, it works but i don\\'t know why "
                    }
                ]
            },
            {
                "id": 2018890,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 2009520,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1996312,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1996151,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1994408,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1991819,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1933403,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1930282,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1914738,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1895135,
                "content": [
                    {
                        "username": "user3502Cr",
                        "content": "This was particularly annoying with edge cases. The original definition for ListNode doesnt let you distinguish between geniune 0 starting points and fake ones.\\nI had to redefine ListNode to get the right answer:\\nfunction ListNode(val, next) {\\n    this.val = (val===undefined ? null : val) //0 changed to null\\n    this.next = (next===undefined ? null : next)\\n  }"
                    },
                    {
                        "username": "prashant1000",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n      if (head==null) return head;\\n       ListNode prv= null;\\n       ListNode curr= head;\\n\\n       while(curr!=null){\\n           prv= curr;\\n           curr= curr.next;\\n           if(prv.val == curr.val){\\n               prv.next= curr.next;\\n               curr=curr.next;\\n           }\\n       } \\n\\n       return head;\\n    }\\n}\\n\\nwhat\\'s wrong in this solution??"
                    },
                    {
                        "username": "huynhcam",
                        "content": "I think in line \"curr= curr.next;\"\\nnew \"curr\" must be not null"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge encourages the use of recursion and backtracking. It also revolves around the concept of combinations, which is a fundamental principle in combinatorics. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem helps reinforce your understanding of linked lists, a fundamental data structure in computer science. It helps you understand how nodes are connected and how changing these connections can modify the list."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Can some please help me out to rectify the code or logical part i have done wrong out here \n\n   set<int>s;\n        ListNode*curr=head;\n        while(curr!=NULL)\n        {\n            s.insert(curr->val);\n            curr=curr->next;\n        }   \n        ListNode*fill=head;\n        for(auto it:s)\n        {\n            int t=it;\n            fill->val=t;\n            fill=fill->next;            \n        } \n        fill=NULL;       \n        return head ;\ntest case : [1,1,2,2,2,3,3,5,5]\noutput I am getting : [1,2,3,5,2]\ndesired [1,2,3,5]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "You\\'re trying to remove duplicates from a linked list. The logic you used with the set is correct for deduplication. However, the problem arises in the second part of the code where you\\'re trying to update the list with the values from the set. The error in your code is that you\\'re not updating the next pointer of the last node in the new list to NULL, leading to a loop back to the previous values.\\n\\nTo possibly fix the issue, after you\\'ve updated the list from the set values, set the next pointer of the last node to NULL. "
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "The below code would suggest an approach that beats 100%, here we look for the node which is the last among duplicates and put it as next to our prev node with different value. Hope this helps\n```\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = head;\n        ListNode* curr = head;\n        if(head == NULL) return head;\n        while(curr != nullptr){\n            while(curr->next != NULL && curr->next->val == curr->val){\n                curr = curr->next;\n            }\n            prev->next = curr->next;\n            curr = prev->next;\n            // curr = curr->next;\n            prev = prev->next;\n        }\n        \n        return head;\n    }\n};\n```"
                    },
                    {
                        "username": "peacfulJsCyberPsycho",
                        "content": "why run test cases my code was passed  succesful but in case with Submit appear new error \"is not valid value for the expected return type ListNode\"  "
                    },
                    {
                        "username": "ViniMolz",
                        "content": "Could your code be returning like a null value? Or another value your code cannot handle? Also, there are many other tests that leetcode uses when you want to submit your code. I already passed all run test cases but got stuck with the extra test cases when submitting."
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "if(head->next==NULL or head==NULL){\\n             return head;\\n         }\\nwrote this condition still showing error of null member access. why?"
                    },
                    {
                        "username": "MananM5911",
                        "content": "it's because currently HEAD == null, so you cannot check HEAD.NEXT == null. You can simply just remove the first check and you are good to go!"
                    },
                    {
                        "username": "dmallett",
                        "content": "Change your if statement to check if head is null before checking if head->next is null. Right now, when head is null and you go to check head->next you\\'ll get a seg fault. Here if head is null it will never get to the second condition: if (head == NULL || head->next == NULL)."
                    },
                    {
                        "username": "vxlkx",
                        "content": "As far as I know we\\'re supposed to \"delete\" the duplicate nodes by unlinking it from the previous node (at least in python). Are there more effective ways?"
                    },
                    {
                        "username": "staaceyD",
                        "content": "[@dmallett](/dmallett) yes, python do have garbage collector, so just unlinking nodes should be fine"
                    },
                    {
                        "username": "dmallett",
                        "content": "Unlinking it is O(1) since we already have a pointer to the node we\\'re deleting. I think it\\'s the most effective thing. I don\\'t know much about python, does it have garbage collection? At least in my c++ solution I had a separate pointer to the duplicate node and called delete on it."
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used to test my code\\n```\\n[1,1,2]\\n[1,1,2,3,3]\\n[1,1,1,1]\\n[1,2,3,4,4]\\n[1]\\n[1,1,1,1,1,2,3,3,3,4,4]\\n[-99,-30,-30,-30,1,1,1,2,2,2,2,2,33,33,33,33]\\n[]\\n```"
                    }
                ]
            },
            {
                "id": 1891177,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1884913,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1806864,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1805944,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1804752,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1800759,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1792814,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1779291,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1771755,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1761387,
                "content": [
                    {
                        "username": "forbiddenlogic",
                        "content": "What to do about the NULL test case? I am unable to submit because it gives runtime error for the not satisfying the NULL test case"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "In that case return nothing (NULL or None or head).\\nIn python for example:\\nif not head: return"
                    },
                    {
                        "username": "gow8004",
                        "content": "Ggg"
                    },
                    {
                        "username": "siddharth_jain",
                        "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* prev = head;\\n        ListNode* temp = head->next;\\n\\n        while(temp!=NULL){\\n            if(prev->val==temp->val){\\n                temp=temp->next;\\n            }else{\\n                prev->next=temp;\\n                prev=temp;\\n                temp=temp->next;\\n            }\\n\\n        }\\n\\n        prev->next=temp;\\n        prev=temp;\\n\\n        return head;\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Nagadinesh99",
                        "content": "In Python why do we need to store in temp, **temp=head**\\n\\ni have Tried with out using temp, then i am not getting the answer\\n\\nIf i have using the temp i am getting the ans\\n\\nPlease can any one explain to me"
                    },
                    {
                        "username": "tulasi33",
                        "content": "without using temp, we are going to perform actual modifications to the head which means we may lost the starting point of the linked list. So, in order to maintain the actual head as it is and keep on changing the nodes we use another one temp which contains the head as it\\'s initial value.\\n"
                    },
                    {
                        "username": "indexmefastcom",
                        "content": "In Java solution, why we must create a temp variable called current and assign it to head? Can anyone please explain it to me?"
                    },
                    {
                        "username": "aliusaid55",
                        "content": "because we need to read the whole list if we move out the head we could lost the track of previous nodes \\n"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "if you dont assign a pointer to the head, you will lose track of the head :)"
                    },
                    {
                        "username": "Anshul_b07",
                        "content": "That\\'s because if you return the variable that you used for iterating over the list, the variable will only contain the Node that you visited last while traversing."
                    },
                    {
                        "username": "yash_3698",
                        "content": "class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        t1=head\\n        while t1.next:\\n            if t1.next.val==t1.val:\\n                t1.next=t1.next.next\\n            else:\\n                t1=t1.val\\n        return head   \\ngetting error int oj has no attriute next"
                    },
                    {
                        "username": "Kiyotaka_7",
                        "content": "What is wrong in my code it isn\\'t working properly....????\\n\\n\\n `struct ListNode* deleteDuplicates(struct ListNode* head){\\n\\n    if(head == NULL || head->next == NULL){\\n        return head;\\n    }else{\\n        struct ListNode* temp =head;\\n\\n        while(!temp->next){\\n            if(temp->val == temp->next->val){\\n                temp->next = temp->next->next;\\n                struct ListNode *del = temp->next;\\n                free(del);\\n            }\\n        }\\n        temp = temp->next;\\n    }\\n    return head;\\n}`\\n"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Why my code  is not working where is the problem?\\n\\n `class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\tMap <Integer,Integer>map=new HashMap<>();\\n\\t\\n\\tListNode curr=head;\\n\\twhile(curr.next!=null){\\n\\tif(map.containsKey(curr.val)){\\n\\t   map.put(curr.val,map.get(curr.val)+1); \\n\\t}else{\\n\\t    map.put(curr.val,1);\\n\\t}\\n\\t curr=curr.next;\\n\\t}\\n\\tcurr=head;\\n\\twhile(curr.next!=null){\\n\\t    if(map.containsKey(curr.val) && map.get(curr.val)>1){\\n\\t        remove(curr);\\n\\t        int value=map.get(curr.val);\\n\\t        value--;\\n\\t        map.put(curr.val,value);\\n\\t    }\\n\\t     curr=curr.next;\\n\\t}\\n\\treturn head;\\n    }\\n\\n    void remove(ListNode del){\\n        ListNode temp=del;\\n        temp.val=del.next.val;\\n        temp.next=temp.next.next;\\n    }\\n}`"
                    },
                    {
                        "username": "DigDug",
                        "content": " I find it hard to think of a good way to create a node and its next counterpart in the same loop. Is that even possible or is there a more efficient approach"
                    },
                    {
                        "username": "mritunjay12",
                        "content": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr -> val == curr->next->val){  \\n                // same\\n                ListNode* temp = curr->next;\\n                curr->next = temp->next;\\n                //curr->next == curr->next->next;\\n                delete(temp);\\n\\n            }else{\\n                curr= curr->next;\\n            }\\n        }\\n        return head;\\n    } \\n\\nvery easy and simple code in c++ :)"
                    }
                ]
            },
            {
                "id": 1760992,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1757025,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1751092,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1743305,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1742504,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1735792,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1735520,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1735051,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1734963,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1734960,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3030179/simple-java-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "The_Finder",
                        "content": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n       ListNode tmp = head;\\n       if( tmp==null || tmp.next==null){\\n         return tmp;\\n       }\\n         \\n         while(head.val==tmp.next.val){\\n             tmp= tmp.next;\\n             if(tmp.next ==null) break;\\n         }\\n         head.next = tmp.next;\\n        \\n         ListNode ans = deleteDuplicates(tmp.next);\\n         return head;\\n      \\n    }\\n}"
                    },
                    {
                        "username": "sarthak2511",
                        "content": "MY C++ solution Using two pointers Remove Duplicates from Sorted List\\n\\nclass Solution {\\npublic:\\nListNode* deleteDuplicates(ListNode* head) {\\nListNode*current=head;\\nif(head==NULL) return NULL;\\nif(head->next==NULL) return head;\\n\\n    ListNode*front= head->next;\\n    while(front!=NULL){\\n        if(current->val==front->val){\\n            current->next= front->next;\\n            front=current->next;\\n        }\\n        else {\\n            front = front->next;\\n            current= current->next;\\n        }\\n    }\\n    return head;\\n}\\n};"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n         return head;\\n        ListNode *current=head;\\n        while(current->next!=NULL)\\n        {\\n            if(current->val==current->next->val)\\n            {\\n                current->next=current->next->next;\\n            }\\n            else\\n            {\\n                current=current->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/remove-duplicates-from-sorted-list-leet-code-83/"
                    },
                    {
                        "username": "appukumar",
                        "content": "We have not used the sorted  hint in this problem Why? please anyone tell me"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Okay so here\\'s my code. \\n\\n`if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(prev.next != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`\\n\\nHowever, when I first tried it in stead of using while(prev.next != null) I wrote while(curr != null) and it gave me an NullPointerException. Does anyone know why? \\n\\nThanks."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "You are accessing the next element with the declaration of curr = head.next\\nBecause of this, if the LinkedList is having only ONE element, then NullPointerException will be thrown.\\nYou can try a different approach\\nThis involves only ONE temporary variable\\n\\n```java\\nif (head == null) return head;\\nListNode curr = head;\\nwhile ( curr.next != null ) {\\n    if ( curr.next.val == curr.val )\\n        curr.next = curr.next.next;\\n    else\\n        curr = curr.next;\\n}\\nreturn head\\n```"
                    },
                    {
                        "username": "surajha",
                        "content": "i think you should put a condition to check that is head is null or not because i have got the same problem and its is solved when i put \\n\\nif(head==null){\\n                return null;\\n            }\\n\\nthis before the while loop to check the condition , i hope this will solve your problem\\n"
                    },
                    {
                        "username": "isaachin7",
                        "content": "Hey, relatively new to Linked Nodes so I just wanted to ask a question. \\n\\nI got a NullPointerException when I did this. Anyone know why?\\n\\n `if(head == null ) {\\n            return head;\\n        }\\n\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        while(curr != null) {\\n            if(prev.next.val == prev.val) {\\n                prev.next = prev.next.next;\\n            } else {\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return head;`"
                    }
                ]
            },
            {
                "id": 1734831,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1728794,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1725799,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1717545,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1716382,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1710022,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1700982,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1694676,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1692816,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            },
            {
                "id": 1686376,
                "content": [
                    {
                        "username": "hari_aravi",
                        "content": "why won\\'t set (head) work as a solution for this problem?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because it4s a linked list not a list."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/83_remove_duplicate_from_sorted.cpp"
                    },
                    {
                        "username": "durundeashok",
                        "content": "Simple logic is the \\ntaje a temp node pointing to the head of the linked list \\nthen iterate if val of two consecative node is same then delete one \\nelse iterate to next of node\\nlastly return the head node of the llinked list \\n"
                    },
                    {
                        "username": "joelkalonji",
                        "content": "In the code, the use of Optional[ListNode] as the type for the head parameter and the return value of the deleteDuplicates method indicates that the function can handle ListNode objects as input, as well as None values. This allows the function to work correctly even if the input is None, and it allows the caller of the function to check if the returned value is None to determine if the input list was empty."
                    },
                    {
                        "username": "techguyash",
                        "content": "Why is this not working\\n\\n\\t\\tListNode temp=head;\\n\\t\\tListNode tail=temp.next;\\n\\n\\t\\t\\twhile(temp!=null && tail!=null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(temp.val== tail.val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.next=tail.next;\\n\\t\\t\\t\\t\\tListNode todel=tail;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t\\ttodel=null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp=temp.next;\\n\\t\\t\\t\\t\\ttail=tail.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n"
                    },
                    {
                        "username": "shashank1719",
                        "content": "You are making question too much complicated, you can solve by using one pointer only."
                    },
                    {
                        "username": "Axnjr",
                        "content": "var deleteDuplicates = function(head) {\\n    var nw = head\\n    while(nw != null){\\n        if(nw.val === nw.next.val){ // cannot read null\\n            nw.next=nw.next.next\\n        }\\n        nw = nw.next\\n    }\\n    console.log(head)\\n};\\n\\nWhat\\'s wrong in it ?"
                    },
                    {
                        "username": "__shalini__",
                        "content": "you have missed to check if nw.next != null .. following should work\\nif(nw.next != null  && nw.val == nw.next.val){ // cannot read null\\nnw.next=nw.next.next;\\n}\\nelse nw = nw.next;\\n}"
                    },
                    {
                        "username": "priyanshujangid221133",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        //  case\\n        if(head == NULL || head->next == NULL)\\n           return head;\\n        \\n        ListNode* temp = head->next;\\n        ListNode* curr = head;\\n\\n        while(temp!=NULL){\\n            \\n            if(curr->val != temp->val){\\n              curr->next = temp;\\n              curr = curr->next;\\n            }\\n            temp = temp->next;\\n        }\\n        //  last ma current ma temp copy karana padaga\\n        curr->next = temp;\\n        return head;\\n    }"
                    },
                    {
                        "username": "deleted_user",
                        "content": "ListNode* deleteDuplicates(ListNode* head) {\n\n\"jo bhi line comment  hein wo thik hein but leetcode accept nii kar raha \" dont know why.\n\n        //if(head==NULL && head->next==NULL){\n         //   return head;\n      //  }\n        ListNode*curr=head;\n        while(curr!=NULL){\n            if(curr->next!=NULL && curr->val==curr->next->val){\n               // delete(curr->next);\n                curr->next=curr->next->next; \n            }\n            else{\n                curr=curr->next;\n            }\n        }\n        return head;\n    }\n      "
                    },
                    {
                        "username": "kumar_apurv",
                        "content": "Hi\\nI am trying to solve this problem using hashmap\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = new ListNode(0);\\n        ListNode curr = temp;\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int i =0;\\n        while(head!=null)\\n        {\\n            map.put(head.val,map.getOrDefault(head.val,0)+1);\\n            head = head.next;\\n        }\\n        for(int j : map.keySet())\\n        {\\n            temp= map.get(j); // error\\n            temp = temp.next;\\n        }\\n        System.out.println(map);\\n        return curr.next;\\n    }\\n}\\n and I am getting an error.Can anyone tell me mistake I am making\\n"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Line 18: Char 41: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:27:41\\n\\nWhy this error occurs and how to deal with it?\\n"
                    },
                    {
                        "username": "kripasindhu-007",
                        "content": "You are trying to access that node of the list that is NULL. Pleases check the condition till where the loop is running."
                    }
                ]
            }
        ]
    },
    {
        "title": "Customers Who Never Order",
        "question_content": "<p>Table: <code>Customers</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all customers who never order anything.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n<strong>Output:</strong> \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n</pre>\n",
        "solutions": [
            {
                "id": 53579,
                "title": "three-accepted-solutions",
                "content": "    SELECT A.Name from Customers A\\n    WHERE NOT EXISTS (SELECT 1 FROM Orders B WHERE A.Id = B.CustomerId)\\n\\n    SELECT A.Name from Customers A\\n    LEFT JOIN Orders B on  a.Id = B.CustomerId\\n    WHERE b.CustomerId is NULL\\n\\n    SELECT A.Name from Customers A\\n    WHERE A.Id NOT IN (SELECT B.CustomerId from Orders B)",
                "solutionTags": [],
                "code": "    SELECT A.Name from Customers A\\n    WHERE NOT EXISTS (SELECT 1 FROM Orders B WHERE A.Id = B.CustomerId)\\n\\n    SELECT A.Name from Customers A\\n    LEFT JOIN Orders B on  a.Id = B.CustomerId\\n    WHERE b.CustomerId is NULL\\n\\n    SELECT A.Name from Customers A\\n    WHERE A.Id NOT IN (SELECT B.CustomerId from Orders B)",
                "codeTag": "Unknown"
            },
            {
                "id": 3202156,
                "title": "to-the-point-solution-without-join",
                "content": "**Please Upvote if you like the approach**\\n![meme.gif](https://assets.leetcode.com/users/images/24e0fc7d-4d6f-4c01-9441-db1d4ef79f3a_1681319548.2573514.gif)\\n\\n# Code\\n```\\nSELECT name as Customers\\nfrom Customers\\nwhere id not in (\\n    select customerId\\n    from Orders\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name as Customers\\nfrom Customers\\nwhere id not in (\\n    select customerId\\n    from Orders\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1308782,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nSELECT Name AS Customers\\nFROM CUSTOMERS\\nLEFT JOIN ORDERS\\nON ORDERS.CustomerID = Customers.Id\\nWHERE Orders.CustomerID IS NULL\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT Name AS Customers\\nFROM CUSTOMERS\\nLEFT JOIN ORDERS\\nON ORDERS.CustomerID = Customers.Id\\nWHERE Orders.CustomerID IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446610,
                "title": "easy-solution",
                "content": "select name as customers from customers\\nwhere id not in (select customerId from orders);\\n\\n#upvote is appreciated.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select name as customers from customers\\nwhere id not in (select customerId from orders);\\n\\n#upvote is appreciated.",
                "codeTag": "Unknown"
            },
            {
                "id": 3848456,
                "title": "easy-pandas-2-methods-with-detailed-explanation",
                "content": "\\n# Code -1\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    # Select the customers whose \\'id\\' is not present in the orders DataFrame\\'s \\'customerId\\' column.\\n    df = customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\n\\n    # Build a DataFrame that only contains the \\'name\\' column and rename it as \\'Customers\\'.\\n    df = df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n\\n    return df\\n\\n```\\n# Explanation\\n- df = customers[\\\\~customers[\\'id\\'].isin(orders[\\'customerId\\'])]: In this line, we use boolean indexing to filter the rows from the \\'customers\\' DataFrame. The condition \\\\~customers[\\'id\\'].isin(orders[\\'customerId\\']) checks if the \\'id\\' column in the \\'customers\\' DataFrame is not present in the \\'customerId\\' column of the \\'orders\\' DataFrame. The tilde (~) operator negates the result, so we select only the rows where the \\'id\\' is not found in the \\'customerId\\' column of the \\'orders\\' DataFrame.\\n\\n- df = df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'}): After filtering, we create a new DataFrame df containing only the \\'name\\' column. The [[\\'name\\']] part is used to select only the \\'name\\' column and keep it as a DataFrame. Then, we rename this column from \\'name\\' to \\'Customers\\' using the rename function. The resulting DataFrame df contains the names of customers who never placed any orders, and the column is labeled as \\'Customers\\'.\\n\\n\\nIn summary, the find_customers function takes two DataFrames, \\'customers\\' and \\'orders\\', and filters the \\'customers\\' DataFrame to find customers whose \\'id\\' is not present in the \\'orders\\' DataFrame\\'s \\'customerId\\' column. It then returns a new DataFrame with the names of these customers, labeled as \\'Customers\\'. This function effectively finds customers who never placed any orders.\\n\\n# Code -2\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    # Merge the customers DataFrame with the orders DataFrame using a left join on \\'id\\' and \\'customerId\\'\\n    merged_df = customers.merge(orders, how=\\'left\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    \\n    # Use the \\'customerId\\' column to create a boolean mask for customers who never placed any orders\\n    mask = merged_df[\\'customerId\\'].isna()\\n    \\n    # Filter the rows using the boolean mask\\n    result_df = merged_df[mask]\\n    \\n    # Select only the \\'name\\' column from the result DataFrame and rename it as \\'Customers\\'\\n    result_df = result_df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n    \\n    return result_df\\n```\\n# Approach\\n- We first merge the \\'customers\\' DataFrame with the \\'orders\\' DataFrame using a left join. This allows us to have a DataFrame where each row represents a customer and includes any orders they may have placed.\\n\\n- We create a boolean mask named mask by checking if the \\'customerId\\' column in the merged DataFrame is null. This mask will be True for customers who never placed any orders and False for customers who placed orders.\\n\\n- We use the boolean mask mask to filter the rows from the \\'customers\\' DataFrame, selecting only those customers who never placed any orders.\\n\\n- We select only the \\'name\\' column from the filtered DataFrame and rename it as \\'Customers\\'.\\n\\n- Finally, we return the resulting DataFrame containing the names of customers who never placed any orders, labeled as \\'Customers\\'.\\n\\nThis approach achieves the same goal of finding customers who never placed any orders but uses a different technique involving a left join and boolean masking.\\n![upvote img.jpg](https://assets.leetcode.com/users/images/441daa56-1fa3-4101-a22b-1bbfd544f186_1690899691.199999.jpeg)\\n\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    # Select the customers whose \\'id\\' is not present in the orders DataFrame\\'s \\'customerId\\' column.\\n    df = customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\n\\n    # Build a DataFrame that only contains the \\'name\\' column and rename it as \\'Customers\\'.\\n    df = df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n\\n    return df\\n\\n```\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    # Merge the customers DataFrame with the orders DataFrame using a left join on \\'id\\' and \\'customerId\\'\\n    merged_df = customers.merge(orders, how=\\'left\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    \\n    # Use the \\'customerId\\' column to create a boolean mask for customers who never placed any orders\\n    mask = merged_df[\\'customerId\\'].isna()\\n    \\n    # Filter the rows using the boolean mask\\n    result_df = merged_df[mask]\\n    \\n    # Select only the \\'name\\' column from the result DataFrame and rename it as \\'Customers\\'\\n    result_df = result_df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n    \\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2943074,
                "title": "left-join",
                "content": "# ***Please Upvote if it helps \\uD83E\\uDEF0***\\n# Code :-\\n```\\n# Write your MySQL query statement below\\nSELECT c.name AS Customers \\nFROM Customers c LEFT JOIN Orders o \\nON c.id=o.customerId \\nWHERE o.customerId IS NULL;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT c.name AS Customers \\nFROM Customers c LEFT JOIN Orders o \\nON c.id=o.customerId \\nWHERE o.customerId IS NULL;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620211,
                "title": "easy-joins-with-attached-document",
                "content": "\\n```\\nSELECT Customers.name AS Customers\\nFROM Customers\\nLEFT JOIN Orders\\nON Customers.id = Orders.customerId\\nWHERE Orders.customerId is null;\\n```\\n![image](https://assets.leetcode.com/users/images/430549df-fb7e-456e-af18-8f68072bdd3e_1664069167.1572943.png)\\n",
                "solutionTags": [],
                "code": "```\\nSELECT Customers.name AS Customers\\nFROM Customers\\nLEFT JOIN Orders\\nON Customers.id = Orders.customerId\\nWHERE Orders.customerId is null;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3349089,
                "title": "fundamental-approach-sql-select",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name AS \"Customers\"\\nFROM Customers WHERE Customers.id not in (\\n    SELECT customerId FROM Orders\\n);\\n// Please consider upvoting, if the solution helped! Thank you :)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name AS \"Customers\"\\nFROM Customers WHERE Customers.id not in (\\n    SELECT customerId FROM Orders\\n);\\n// Please consider upvoting, if the solution helped! Thank you :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141590,
                "title": "mysql-solution-using-not-in",
                "content": "```\\nselect name as Customers from customers where id not in (select customerid from orders);\\n```",
                "solutionTags": [],
                "code": "```\\nselect name as Customers from customers where id not in (select customerid from orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53576,
                "title": "a-solution-using-not-in-and-another-one-using-left-join",
                "content": "605 ms\\n\\n    SELECT Name as Customers from Customers\\n    LEFT JOIN Orders\\n    ON Customers.Id = Orders.CustomerId\\n    WHERE Orders.CustomerId IS NULL;\\n\\n675ms\\n\\n    SELECT Name as Customers from Customers\\n    WHERE Id NOT IN (SELECT CustomerId from Orders);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "605 ms\\n\\n    SELECT Name as Customers from Customers\\n    LEFT JOIN Orders\\n    ON Customers.Id = Orders.CustomerId\\n    WHERE Orders.CustomerId IS NULL;\\n\\n675ms\\n\\n    SELECT Name as Customers from Customers\\n    WHERE Id NOT IN (SELECT CustomerId from Orders);",
                "codeTag": "Unknown"
            },
            {
                "id": 1924410,
                "title": "easy-and-straight-forward-sql-query",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT Customers.name AS Customers \\nFROM Customers\\nWHERE Customers.id NOT IN \\n(\\n   SELECT customerId from Orders\\n);\\n```\\n**Please don\\'t forget to upvote me.**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Customers.name AS Customers \\nFROM Customers\\nWHERE Customers.id NOT IN \\n(\\n   SELECT customerId from Orders\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386051,
                "title": "2-different-solutions-easy-to-understand",
                "content": "```\\n# 1.\\nSELECT c.name  as Customers\\nFROM Customers c LEFT JOIN Orders o\\nON c.id = o.customerId\\nwhere o.customerId is NULL;\\n\\n# 2.\\nSELECT c.name as Customers from Customers c\\nWHERE c.id not in (select o.customerId from Orders o);\\n```\\n**If you have any doubts, feel free to ask...\\nIf you understand the concept. Don\\'t Forget to upvote \\uD83D\\uDE0A\\nand PLEASE DO UPVOTE**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# 1.\\nSELECT c.name  as Customers\\nFROM Customers c LEFT JOIN Orders o\\nON c.id = o.customerId\\nwhere o.customerId is NULL;\\n\\n# 2.\\nSELECT c.name as Customers from Customers c\\nWHERE c.id not in (select o.customerId from Orders o);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2748434,
                "title": "2-ways-exists-nested-mysql",
                "content": "## Here are two ways of solving the query:\\n\\n1. Using EXISTS:\\n\\n```MySQL []\\nSELECT name AS Customers FROM Customers A WHERE NOT EXISTS (SELECT * FROM Orders B WHERE A.id = B.customerId);\\n```\\n\\n2. Using nested Query\\n\\n```MySQL []\\nSELECT name as customers FROM Customers WHERE id not in (SELECT customerId FROM Orders);\\n```\\n\\n`Another Note:`\\n`\\nRemember, mySQL is case-insensitive. Typing the table names in lower case or all upper case makes on difference. Same goes for data contents within the table.\\n`\\n\\n*Leave a upvote if it helped!*\\n\\nConnect on LinkedIn: https://www.linkedin.com/in/gourab-roy-824652172/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```MySQL []\\nSELECT name AS Customers FROM Customers A WHERE NOT EXISTS (SELECT * FROM Orders B WHERE A.id = B.customerId);\\n```\n```MySQL []\\nSELECT name as customers FROM Customers WHERE id not in (SELECT customerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3844182,
                "title": "5-easy-solutions-mysql-pandas-beats-100-in-both-time-and-space",
                "content": "# Code\\n```\\n# Solution 1\\nSELECT name as Customers\\nFROM Customers C\\nWHERE C.Id NOT IN (SELECT O.CustomerId from Orders O)\\n\\n# Solution 2\\nSELECT name as Customers\\nFROM Customers A LEFT JOIN Orders B on  A.Id = B.CustomerId\\nWHERE B.CustomerId is NULL\\n\\n# Solution 3\\nSELECT name as Customers\\nFROM Customers A\\nWHERE NOT EXISTS (SELECT name FROM Orders B WHERE A.Id = B.CustomerId)\\n```\\n```\\n# Solution 1\\nimport pandas as pd\\n\\ndef customers_who_never_order(customers: pd.DataFrame, orders: pd.DataFrame)->pd.DataFrame:\\n    # Select the rows which `id` is not present in orders[\\'customerId\\'].\\n    df = customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\n\\n    # Build a dataframe that only contains the column `name` \\n    # and rename the column `name` as `Customers`.\\n    df = df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n    return df\\n\\n# Solution 2\\nimport pandas as pd\\n\\ndef customers_who_never_order(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = customers.merge(orders, left_on=\\'id\\', right_on=\\'customerId\\', how=\\'left\\')\\n    df = df[df[\\'customerId\\'].isna()]\\n    df = df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n    return df\\n```\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Solution 1\\nSELECT name as Customers\\nFROM Customers C\\nWHERE C.Id NOT IN (SELECT O.CustomerId from Orders O)\\n\\n# Solution 2\\nSELECT name as Customers\\nFROM Customers A LEFT JOIN Orders B on  A.Id = B.CustomerId\\nWHERE B.CustomerId is NULL\\n\\n# Solution 3\\nSELECT name as Customers\\nFROM Customers A\\nWHERE NOT EXISTS (SELECT name FROM Orders B WHERE A.Id = B.CustomerId)\\n```\n```\\n# Solution 1\\nimport pandas as pd\\n\\ndef customers_who_never_order(customers: pd.DataFrame, orders: pd.DataFrame)->pd.DataFrame:\\n    # Select the rows which `id` is not present in orders[\\'customerId\\'].\\n    df = customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\n\\n    # Build a dataframe that only contains the column `name` \\n    # and rename the column `name` as `Customers`.\\n    df = df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n    return df\\n\\n# Solution 2\\nimport pandas as pd\\n\\ndef customers_who_never_order(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = customers.merge(orders, left_on=\\'id\\', right_on=\\'customerId\\', how=\\'left\\')\\n    df = df[df[\\'customerId\\'].isna()]\\n    df = df[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 53586,
                "title": "here-are-3-solutions",
                "content": "select c.Name from Customers c\\nwhere c.Id not in (select customerId from Orders)\\n\\nselect c.Name from Customers c\\nwhere (select count(*) from Orders o where o.customerId=c.id)=0 \\n\\nselect c.Name from Customers c\\nwhere not exists (select * from Orders o where o.customerId=c.id)",
                "solutionTags": [],
                "code": "select c.Name from Customers c\\nwhere c.Id not in (select customerId from Orders)\\n\\nselect c.Name from Customers c\\nwhere (select count(*) from Orders o where o.customerId=c.id)=0 \\n\\nselect c.Name from Customers c\\nwhere not exists (select * from Orders o where o.customerId=c.id)",
                "codeTag": "Unknown"
            },
            {
                "id": 2686691,
                "title": "easy-fast-142ms",
                "content": "**Upvote if you like the solution**\\u270C\\uFE0F\\n```\\nselect c.name as Customers \\nfrom Customers c\\nwhere c.id not in (select customerId from Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect c.name as Customers \\nfrom Customers c\\nwhere c.id not in (select customerId from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802374,
                "title": "sql-simplest-solution",
                "content": "```\\nSELECT Name as Customers\\nFROM Customers\\nWHERE Id not in (SELECT CustomerId \\n                 FROM Orders)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Name as Customers\\nFROM Customers\\nWHERE Id not in (SELECT CustomerId \\n                 FROM Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423831,
                "title": "awesome-code-sql",
                "content": "\\n# Code\\n```\\nselect name as Customers from customers where id not in\\n(\\n    select customerId from orders \\n)\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers from customers where id not in\\n(\\n    select customerId from orders \\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827162,
                "title": "100-easy-fast-clean-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT name AS Customers FROM Customers WHERE \\n\\nCustomers.id NOT IN (SELECT customerId FROM Orders)\\n```\\nIF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE !\\n\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/311f5496-d288-43d3-9257-702d7c37edb3_1690525082.0344095.jpeg)\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT name AS Customers FROM Customers WHERE \\n\\nCustomers.id NOT IN (SELECT customerId FROM Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3214813,
                "title": "183-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nTo find the customers who never ordered anything, we can use a LEFT JOIN between the Customers table and the Orders table. This will give us all customers with NULL orders. Here is the SQL query for this problem:\\n\\n```\\nSELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o ON c.id = o.customerId\\nWHERE o.id IS NULL;\\n\\n```\\nThis query selects the name column from the Customers table and left joins it with the Orders table on the customer ID. Then, it uses a WHERE clause to filter out the customers who have placed an order by checking for NULL values in the Orders table. Finally, the result is sorted by the customer name.\\n\\nThe output of the given input will be:\\n```\\n+-----------+\\n| Customers |\\n+-----------+\\n| Henry     |\\n| Max       |\\n+-----------+\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o ON c.id = o.customerId\\nWHERE o.id IS NULL;\\n\\n```\n```\\n+-----------+\\n| Customers |\\n+-----------+\\n| Henry     |\\n| Max       |\\n+-----------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987574,
                "title": "2-simple-sql-solutions",
                "content": "Solution 1.\\nMore concise but less common.\\n```\\nSELECT name AS Customers FROM Customers \\nWHERE id not in (SELECT customerId FROM Orders)\\n```\\n\\nSolution 2.\\nLonger but more common and readable.\\n```\\nSELECT name AS Customers FROM Customers \\nLEFT JOIN Orders\\n    ON Customers.id = Orders.customerId\\nWHERE Orders.id IS NULL\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name AS Customers FROM Customers \\nWHERE id not in (SELECT customerId FROM Orders)\\n```\n```\\nSELECT name AS Customers FROM Customers \\nLEFT JOIN Orders\\n    ON Customers.id = Orders.customerId\\nWHERE Orders.id IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538676,
                "title": "simle-accepted-solution",
                "content": "```\\nselect Name as Customers\\nfrom Customers c\\nwhere c.Id not in (select CustomerId  from Orders)\\n```\\n\\n**Like it ? lease upvote !**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Name as Customers\\nfrom Customers c\\nwhere c.Id not in (select CustomerId  from Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681035,
                "title": "mysql-solution",
                "content": "\\nSelection of only those people whose id does not fall into the selection of people who made orders.\\n```\\nSELECT name AS \\'Customers\\'\\n    FROM Customers\\n    WHERE id NOT IN (\\n        SELECT C.id\\n        FROM Customers AS C INNER JOIN Orders AS O\\n        ON O.customerId = C.id\\n    )\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name AS \\'Customers\\'\\n    FROM Customers\\n    WHERE id NOT IN (\\n        SELECT C.id\\n        FROM Customers AS C INNER JOIN Orders AS O\\n        ON O.customerId = C.id\\n    )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555890,
                "title": "easiest-solution-mysql-beginners",
                "content": "```\\nSELECT name as Customers FROM Customers\\nWHERE Customers.ID NOT IN (SELECT customerID FROM Orders);\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nSELECT name as Customers FROM Customers\\nWHERE Customers.ID NOT IN (SELECT customerID FROM Orders);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539636,
                "title": "mysql-easy-in-solution",
                "content": "```\\nselect name as Customers from customers where id not in\\n(select customerId from orders)\\n```",
                "solutionTags": [],
                "code": "```\\nselect name as Customers from customers where id not in\\n(select customerId from orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421034,
                "title": "mysql-2-different-approach-one-line-solution-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT name AS Customers FROM Customers LEFT JOIN Orders ON (Orders.customerId = Customers.id) WHERE Orders.id IS NULL\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT A.Name AS Customers FROM Customers A WHERE A.Id NOT IN (SELECT B.CustomerId FROM Orders B)`\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name AS Customers FROM Customers LEFT JOIN Orders ON (Orders.customerId = Customers.id) WHERE Orders.id IS NULL\\n```\n```\\nSELECT A.Name AS Customers FROM Customers A WHERE A.Id NOT IN (SELECT B.CustomerId FROM Orders B)`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191010,
                "title": "simple-mysql-solution-using-left-join",
                "content": "```\\nSELECT Name AS \\'Customers\\' FROM Customers c LEFT JOIN Orders o ON c.Id = o.CustomerId WHERE o.CustomerId IS NULL\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Name AS \\'Customers\\' FROM Customers c LEFT JOIN Orders o ON c.Id = o.CustomerId WHERE o.CustomerId IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3060535,
                "title": "mysql-left-join-and-alias-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/655a025e-5fb4-4805-b327-85635052fcd5_1673896280.457174.png)\\n\\n\\n\\tSELECT c.name AS Customers FROM \\n\\t(customers AS c LEFT JOIN orders AS o ON c.id = o.customerId) WHERE o.id IS NULL;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/655a025e-5fb4-4805-b327-85635052fcd5_1673896280.457174.png)\\n\\n\\n\\tSELECT c.name AS Customers FROM \\n\\t(customers AS c LEFT JOIN orders AS o ON c.id = o.customerId) WHERE o.id IS NULL;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2427793,
                "title": "mysql-not-in-clause-solution",
                "content": "```\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN\\n(\\nSELECT customerId FROM Orders\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN\\n(\\nSELECT customerId FROM Orders\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53596,
                "title": "share-my-first-db-answer",
                "content": "I learn database from  a Standford tutorial.\\n\\nhttps://www.youtube.com/watch?v=D-k-h0GuFmE&list=PL6hGtHedy2Z4EkgY76QOcueU8lAC4o6c3\\n\\n    select Name as Customers\\n    from Customers\\n    where Id not in\\n    (select CustomerId as Id from Orders);",
                "solutionTags": [],
                "code": "I learn database from  a Standford tutorial.\\n\\nhttps://www.youtube.com/watch?v=D-k-h0GuFmE&list=PL6hGtHedy2Z4EkgY76QOcueU8lAC4o6c3\\n\\n    select Name as Customers\\n    from Customers\\n    where Id not in\\n    (select CustomerId as Id from Orders);",
                "codeTag": "Unknown"
            },
            {
                "id": 3525501,
                "title": "mysql-solution-for-customers-who-never-order-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to find customers who are not present in the Orders table, indicating that they have not placed any orders.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The subquery (Select CustomerId from Orders) retrieves the customer IDs from the Orders table.\\n2. The main query Select Name as Customers from Customers selects the names (Name) of customers from the Customers table.\\n3. The where clause where Id not in (Select CustomerId from Orders) filters the customers based on their IDs, excluding those IDs that are present in the subquery result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the SQL query depends on the size of the Customers and Orders tables and the efficiency of the database engine\\'s query optimization and execution. Assuming proper indexing and optimization, the time complexity can vary but is typically in the order of O(n log n) or O(n), where n is the number of rows in the Customers table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the SQL query is determined by the memory required to store the result set, which in this case is the names of customers who have not placed any orders. The space complexity is proportional to the number of rows returned by the query.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect Name as Customers from Customers where Id not in \\n(\\n    Select CustomerId from Orders\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect Name as Customers from Customers where Id not in \\n(\\n    Select CustomerId from Orders\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042783,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect name as \\'Customers\\' from Customers\\nwhere id not in (select customerid from Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name as \\'Customers\\' from Customers\\nwhere id not in (select customerid from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728751,
                "title": "customers-that-dont-order",
                "content": "# Intuition\\nRequires Join\\n\\n# Approach\\nFigure out which join is to be used and then where condition\\n\\n# Complexity\\n- Time complexity:\\nBegginer\\n\\n- Space complexity:\\n4 lines\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect customers.name as Customers from customers\\nleft join orders\\non customers.id = orders.customerid\\nwhere orders.customerid is null;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect customers.name as Customers from customers\\nleft join orders\\non customers.id = orders.customerid\\nwhere orders.customerid is null;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229410,
                "title": "two-simple-solutions-nested-query-left-join",
                "content": "```\\n#Nested Query:\\nSELECT name AS Customers FROM Customers \\nWHERE id NOT IN ( SELECT customerId FROM orders );\\n```\\n\\n```\\n# Left Join\\nSELECT c.name AS Customers \\nFROM Customers c LEFT JOIN Orders o\\nON c.id=o.CustomerId\\nWHERE o.id is NULL;\\n```\\n\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#Nested Query:\\nSELECT name AS Customers FROM Customers \\nWHERE id NOT IN ( SELECT customerId FROM orders );\\n```\n```\\n# Left Join\\nSELECT c.name AS Customers \\nFROM Customers c LEFT JOIN Orders o\\nON c.id=o.CustomerId\\nWHERE o.id is NULL;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177956,
                "title": "customers-who-never-order",
                "content": "```\\nSELECT\\n    name as Customers\\nFROM \\n    Customers\\nwhere \\n    id NOT IN (SELECT customerId FROM Orders);\\n```\\nUpvote IF IT Help",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    name as Customers\\nFROM \\n    Customers\\nwhere \\n    id NOT IN (SELECT customerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967367,
                "title": "mysql-using-not-in",
                "content": "```\\nselect c1.name as Customers \\n  from Customers  c1\\n         Where c1.id not in ( select  O.customerId \\n                      from Orders O );\\n\\t\\t\\t\\t\\t  \\n\\t\\tIF Helpful Please Like And Upvoke\\t\\t\\t  \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect c1.name as Customers \\n  from Customers  c1\\n         Where c1.id not in ( select  O.customerId \\n                      from Orders O );\\n\\t\\t\\t\\t\\t  \\n\\t\\tIF Helpful Please Like And Upvoke\\t\\t\\t  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803873,
                "title": "best-easiest-simplest-mysql-using-subquery-183-customers-who-never-order",
                "content": "```\\nselect name as Customers from customers where id NOT IN \\n(select customerId from Orders);\\n\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers from customers where id NOT IN \\n(select customerId from Orders);\\n\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917184,
                "title": "simple-python-pandas-solution",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    never_o=pd.DataFrame()\\n    never_o[\\'Customers\\']=customers[~customers.id.isin(orders.customerId)][\\'name\\']\\n    return never_o\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    never_o=pd.DataFrame()\\n    never_o[\\'Customers\\']=customers[~customers.id.isin(orders.customerId)][\\'name\\']\\n    return never_o\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3848527,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    return customers[\\n        ~customers[\\'id\\'].isin(orders[\\'customerId\\'])\\n    ][[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n```\\n```SQL []\\nSELECT name AS \\'Customers\\'\\n  FROM Customers\\n WHERE id NOT IN (\\n    SELECT customerId\\n      FROM Orders\\n);\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Pandas"
                ],
                "code": "```Python []\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    return customers[\\n        ~customers[\\'id\\'].isin(orders[\\'customerId\\'])\\n    ][[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n```\n```SQL []\\nSELECT name AS \\'Customers\\'\\n  FROM Customers\\n WHERE id NOT IN (\\n    SELECT customerId\\n      FROM Orders\\n);\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3486442,
                "title": "used-two-approach-one-using-simple-where-and-one-using-join",
                "content": "# upvote if you like the solution\\n\\n# best approach\\nselect name as customers from customers\\nwhere id not in (select customerId from orders);\\n\\n# using joins\\nSELECT customers.name AS customers\\nFROM customers\\nLEFT JOIN orders\\nON customers.id = orders.customerId\\nWHERE orders.customerId IS NULL;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# upvote if you like the solution\\n\\n# best approach\\nselect name as customers from customers\\nwhere id not in (select customerId from orders);\\n\\n# using joins\\nSELECT customers.name AS customers\\nFROM customers\\nLEFT JOIN orders\\nON customers.id = orders.customerId\\nWHERE orders.customerId IS NULL;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2479390,
                "title": "mysql-2-solutions-very-easy-nested-query-join",
                "content": "\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\nPlease upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\nAny suggestions and improvements are always welcome.\\nSolution 1: Join, long, not good \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n\\u2705 Runtime: 591 ms, faster than 50.77% of MySQL.\\n\\n```\\nselect name as Customers\\nfrom Customers a\\nleft join Orders b\\non a.id = b.customerId\\nwhere customerId is null\\n```\\nSolution 2: Nested query \\uD83C\\uDFAF\\n\\u2705 Runtime: 495 ms, faster than 69.10% of MySQL.\\n\\n```\\nselect name as Customers \\nfrom Customers \\nwhere id not in (select customerId from Orders)\\n```\\nIf you like the solutions, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers\\nfrom Customers a\\nleft join Orders b\\non a.id = b.customerId\\nwhere customerId is null\\n```\n```\\nselect name as Customers \\nfrom Customers \\nwhere id not in (select customerId from Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282032,
                "title": "3-simple-solutions-1-not-in-2-not-exists-3-left-join",
                "content": "**1. Using NOT IN**\\nselect name as Customers from customers c\\nwhere c.id not in (select customerId from orders)\\n\\n**2. Using NOT EXISTS**\\nselect name as Customers from customers c\\nwhere not exists (select 1 from orders o where c.id = o.customerId)\\n\\n**3. LEFT JOIN**\\nselect name as Customers from customers c\\nleft join orders o\\non c.id = o.customerId\\nwhere o.customerId is null",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**1. Using NOT IN**\\nselect name as Customers from customers c\\nwhere c.id not in (select customerId from orders)\\n\\n**2. Using NOT EXISTS**\\nselect name as Customers from customers c\\nwhere not exists (select 1 from orders o where c.id = o.customerId)\\n\\n**3. LEFT JOIN**\\nselect name as Customers from customers c\\nleft join orders o\\non c.id = o.customerId\\nwhere o.customerId is null",
                "codeTag": "Unknown"
            },
            {
                "id": 2273370,
                "title": "mysql-beginner-friendly-fully-explained-sub-query-concept",
                "content": "**Please Upvote If you like it :)**\\nConcept Of the Day - **Subquery**\\n* The subquery can be nested inside a SELECT, INSERT, UPDATE, or DELETE statement or inside another subquery.\\n* A subquery is usually added within the WHERE Clause of another SQL SELECT statement.\\n\\nHere Subquery is present in where clause\\n### Solution\\n```\\nselect name as Customers from Customers where id not in (select customerId from Orders)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers from Customers where id not in (select customerId from Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2149872,
                "title": "a-solution-using-not-in-easy-to-understand",
                "content": "\\tSELECT Name as Customers from Customers\\n\\tWHERE id NOT IN(SELECT customerId from Orders)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT Name as Customers from Customers\\n\\tWHERE id NOT IN(SELECT customerId from Orders)",
                "codeTag": "Unknown"
            },
            {
                "id": 1960828,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nselect name as Customers\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id\\nwhere Orders.id is null\\n```\\nBy using **left join** we can see customer, who has never make orders. Orders.id will be **null**, because **join** will not find rows for them in Orders.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id\\nwhere Orders.id is null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606227,
                "title": "easy-to-understand",
                "content": "```\\nselect c.name as \\'Customers\\'\\nfrom Customers as c\\nwhere (select count(*) from Orders where Orders.customerID=c.id)=0;",
                "solutionTags": [],
                "code": "```\\nselect c.name as \\'Customers\\'\\nfrom Customers as c\\nwhere (select count(*) from Orders where Orders.customerID=c.id)=0;",
                "codeTag": "Unknown"
            },
            {
                "id": 1179274,
                "title": "several-ways-to-solve-this-type-of-questions-in-a-not-in-b",
                "content": "Genrally this type of questions contain more than one table (sometimes one table but comparing among fields), and the goal is to find records in table A but not in table B. More complicated questions are looking for records in table A but not in table B with certian critera (e.g. range of time, overlaps, flags, distinct values).\\n\\nSimilar questions: 1084, 1581, 1809, 577, 1350, 1607, 607\\n\\nSimilar type of questions: \\nhttps://leetcode.com/problems/customers-who-bought-products-a-and-b-but-not-c/discuss/1220534/four-solutions-for-this-type-of-questions-in-a-and-b-andnot-c\\n\\nSolution 1: Use left outer join\\n```\\nSELECT customers.Name as Customers\\n  FROM customers\\n  LEFT JOIN Orders\\n    ON customers.id = Orders.CustomerId\\n WHERE customerId IS NULL\\n```\\n\\nSolution 2: Put records not needed in a subquery. Then select records from table A WHERE the records are NOT IN/EXIST in the records selected by the subquery. \\n```\\nSELECT customers.Name as Customers\\n  FROM customers\\n WHERE ID not in (SELECT CustomerId FROM Orders)\\n```\\nSolution 3: Create a flag using SUM(CASE WHEN). And select all records with the corresponding flag. \\n```\\nSELECT Name AS Customers\\n  FROM(\\nSelect Customers.id, Name, SUM(CASE WHEN Customers.id = Orders.Customerid THEN 1 ELSE 0 END) AS score\\n  FROM Customers\\n  LEFT JOIN Orders\\n    ON Customers.id = Orders.CustomerId\\n GROUP BY 1,2)a\\n WHERE a.score = 0\\n ```\\n\\nSolution 4: If there\\'s a range or there are multiple records for one id, using GROUP BY + HAVING (criteria) to evaluate the aggregated results. This solution does not really apply to this question..",
                "solutionTags": [],
                "code": "```\\nSELECT customers.Name as Customers\\n  FROM customers\\n  LEFT JOIN Orders\\n    ON customers.id = Orders.CustomerId\\n WHERE customerId IS NULL\\n```\n```\\nSELECT customers.Name as Customers\\n  FROM customers\\n WHERE ID not in (SELECT CustomerId FROM Orders)\\n```\n```\\nSELECT Name AS Customers\\n  FROM(\\nSelect Customers.id, Name, SUM(CASE WHEN Customers.id = Orders.Customerid THEN 1 ELSE 0 END) AS score\\n  FROM Customers\\n  LEFT JOIN Orders\\n    ON Customers.id = Orders.CustomerId\\n GROUP BY 1,2)a\\n WHERE a.score = 0\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 964998,
                "title": "left-join-simple",
                "content": "select customers.name as customers from customers left join orders on Customers.Id=Orders.CustomerId\\nwhere orders.Id is null",
                "solutionTags": [],
                "code": "select customers.name as customers from customers left join orders on Customers.Id=Orders.CustomerId\\nwhere orders.Id is null",
                "codeTag": "Unknown"
            },
            {
                "id": 839191,
                "title": "mysql-simple-solution-beats-100-in-less-space-self-explanatory",
                "content": "```\\n# Write your MySQL query statement below\\nselect\\n    c.Name as \\'Customers\\'\\nfrom Customers c\\nwhere not exists (select o.CustomerId\\nfrom Orders o\\nwhere c.Id = o.CustomerId);\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    c.Name as \\'Customers\\'\\nfrom Customers c\\nwhere not exists (select o.CustomerId\\nfrom Orders o\\nwhere c.Id = o.CustomerId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53604,
                "title": "just-a-solution",
                "content": "    select Name as Customers from Customers where Customers.id not in (select CustomerId from Orders);",
                "solutionTags": [],
                "code": "    select Name as Customers from Customers where Customers.id not in (select CustomerId from Orders);",
                "codeTag": "Unknown"
            },
            {
                "id": 4055429,
                "title": "pandas-sql-easy-customers-who-never-order-easy-explained",
                "content": "First Approach\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051717047/)\\n\\n```\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Perform a left join between \\'Customers\\' and \\'Orders\\'\\n    merged = customers.merge(orders, left_on=\\'id\\', right_on=\\'customerId\\', how=\\'left\\')\\n\\n    # Filter rows where \\'customerId\\' in \\'Orders\\' is null\\n    null_customerID = merged[merged[\\'customerId\\'].isnull()]\\n    \\n    # # We select the \\'name\\' column and rename the column from \\'name\\' to \\'customers\\' within the selected DataFrame. So, the resulting DataFrame will have a \\'customers\\' column containing the data from the original \\'name\\' column, but it does not change the original DataFrame. \\n    renamed_column = null_customerID[[\\'name\\']].rename(columns={\\'name\\': \\'customers\\'})\\n\\n    return renamed_column\\n```\\n\\nSecond Approach\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051717306/)\\n\\n```\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, extract customer id\\n        customer_id = customers[\\'id\\']\\n    # Then, extract the column named \\'customerId\\' from the orders DataFrame.\\n        orders_made_by_customer = orders[\\'customerId\\']\\n\\n    # Extract names of customers whose IDs are not in the \\'customerId\\' column of \\'Orders\\'\\n        customer_notIn_orderList = customers[~customer_id.isin(orders_made_by_customer)]\\n\\n    # We select the \\'name\\' column and rename the column from \\'name\\' to \\'customers\\' within the selected DataFrame. So, the resulting DataFrame will have a \\'customers\\' column containing the data from the original \\'name\\' column, but it does not change the original DataFrame. \\n        renamed_column = customer_notIn_orderList[[\\'name\\']].rename(columns={\\'name\\': \\'customers\\'})\\n\\n        return renamed_column\\n\\n```\\n\\n**SQL**\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1061394161/)\\n\\n```\\nSELECT name AS Customers\\nFROM Customers \\nWHERE Customers.id not in (\\n    SELECT customerId \\n    FROM Orders\\n);\\n```\\n\\n```\\n-- Select the \"name\" column from the \"Customers\" table and rename it as \"Customers\"\\nSELECT name AS Customers\\n\\n-- Specify the source table as \"Customers\" from which data will be retrieved\\nFROM Customers \\n\\n-- Begin a conditional clause to filter rows\\nWHERE Customers.id not in (\\n    -- Subquery: Select the \"customerId\" column from the \"Orders\" table\\n    SELECT customerId \\n    FROM Orders\\n);\\n-- Close the conditional clause\\n```\\n\\n![image](https://assets.leetcode.com/users/images/357e507c-e995-46f4-84b1-d7221c426fda_1695221986.4232628.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Perform a left join between \\'Customers\\' and \\'Orders\\'\\n    merged = customers.merge(orders, left_on=\\'id\\', right_on=\\'customerId\\', how=\\'left\\')\\n\\n    # Filter rows where \\'customerId\\' in \\'Orders\\' is null\\n    null_customerID = merged[merged[\\'customerId\\'].isnull()]\\n    \\n    # # We select the \\'name\\' column and rename the column from \\'name\\' to \\'customers\\' within the selected DataFrame. So, the resulting DataFrame will have a \\'customers\\' column containing the data from the original \\'name\\' column, but it does not change the original DataFrame. \\n    renamed_column = null_customerID[[\\'name\\']].rename(columns={\\'name\\': \\'customers\\'})\\n\\n    return renamed_column\\n```\n```\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, extract customer id\\n        customer_id = customers[\\'id\\']\\n    # Then, extract the column named \\'customerId\\' from the orders DataFrame.\\n        orders_made_by_customer = orders[\\'customerId\\']\\n\\n    # Extract names of customers whose IDs are not in the \\'customerId\\' column of \\'Orders\\'\\n        customer_notIn_orderList = customers[~customer_id.isin(orders_made_by_customer)]\\n\\n    # We select the \\'name\\' column and rename the column from \\'name\\' to \\'customers\\' within the selected DataFrame. So, the resulting DataFrame will have a \\'customers\\' column containing the data from the original \\'name\\' column, but it does not change the original DataFrame. \\n        renamed_column = customer_notIn_orderList[[\\'name\\']].rename(columns={\\'name\\': \\'customers\\'})\\n\\n        return renamed_column\\n\\n```\n```\\nSELECT name AS Customers\\nFROM Customers \\nWHERE Customers.id not in (\\n    SELECT customerId \\n    FROM Orders\\n);\\n```\n```\\n-- Select the \"name\" column from the \"Customers\" table and rename it as \"Customers\"\\nSELECT name AS Customers\\n\\n-- Specify the source table as \"Customers\" from which data will be retrieved\\nFROM Customers \\n\\n-- Begin a conditional clause to filter rows\\nWHERE Customers.id not in (\\n    -- Subquery: Select the \"customerId\" column from the \"Orders\" table\\n    SELECT customerId \\n    FROM Orders\\n);\\n-- Close the conditional clause\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3813558,
                "title": "an-easy-to-understand-solution",
                "content": "# Code\\n```\\nSELECT name as Customers FROM Customers WHERE id NOT IN (SELECT customerId FROM Orders); \\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT name as Customers FROM Customers WHERE id NOT IN (SELECT customerId FROM Orders); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272942,
                "title": "sql-server-clean-easy",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT customerId FROM Orders)\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT customerId FROM Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3242502,
                "title": "easy-sql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT name  AS Customers FROM Customers WHERE id not in (SELECT customerId FROM Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT name  AS Customers FROM Customers WHERE id not in (SELECT customerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2781976,
                "title": "easy-mysql-beginner-solution",
                "content": "\\n# Code\\n```\\nselect name as Customers\\nfrom Customers c\\nwhere id not in (select customerId from Orders);\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect name as Customers\\nfrom Customers c\\nwhere id not in (select customerId from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2731902,
                "title": "simple-one-line-solution-mysql",
                "content": "SELECT name AS Customers FROM Customers WHERE id NOT IN ( Select customerId From Orders);\\n\\n#header is Customer in the required output ,thus using as in the query.",
                "solutionTags": [],
                "code": "SELECT name AS Customers FROM Customers WHERE id NOT IN ( Select customerId From Orders);\\n\\n#header is Customer in the required output ,thus using as in the query.",
                "codeTag": "Unknown"
            },
            {
                "id": 2664616,
                "title": "mysql-not-in",
                "content": "select name as customers\\nfrom customers\\nwhere id not in (select customerid from orders)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select name as customers\\nfrom customers\\nwhere id not in (select customerid from orders)",
                "codeTag": "Unknown"
            },
            {
                "id": 2624561,
                "title": "you-can-do-it-with-both-sub-query-and-join",
                "content": "/* Write your T-SQL query statement below */\\n\\nselect Customers.name as Customers\\nfrom Customers\\nleft join Orders on Customers.id= Orders.customerId\\nwhere Orders.customerId is null\\n\\n    \\n-- sub query \\nSELECT c.Name as Customers\\nFROM Customers c\\nWHERE c.id not in (\\nSELECT o.CustomerId FROM Orders o\\n);",
                "solutionTags": [],
                "code": "/* Write your T-SQL query statement below */\\n\\nselect Customers.name as Customers\\nfrom Customers\\nleft join Orders on Customers.id= Orders.customerId\\nwhere Orders.customerId is null\\n\\n    \\n-- sub query \\nSELECT c.Name as Customers\\nFROM Customers c\\nWHERE c.id not in (\\nSELECT o.CustomerId FROM Orders o\\n);",
                "codeTag": "Unknown"
            },
            {
                "id": 2523693,
                "title": "simple-solution-with-each-step-explanation",
                "content": "```select name as Customers from Customers where id not in (select customerId from Orders);```\\n\\n\\nname as Customers: We are creating a Alias name for name in Customer Table as Customers.\\n\\n(select customerId from Orders): First Select Customerid from Orders.\\n\\nThen check with Customer Table. So, as My final result is from Customer table. \\n\\n where id not in: This will give the result which ids are not in Orders table.\\n \\n \\n Give it a upvote if you like this solution.\\n\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```select name as Customers from Customers where id not in (select customerId from Orders);```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432908,
                "title": "mssql-one-liner-simple-easy",
                "content": "```\\nselect name as Customers from Customers where id not in (select customerId from Orders);\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect name as Customers from Customers where id not in (select customerId from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2384314,
                "title": "faster-than-99-67-subquery",
                "content": "```\\nselect name as customers from Customers where id not in (select customerId from Orders);\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect name as customers from Customers where id not in (select customerId from Orders);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2348671,
                "title": "easy-2-liner-sql-solution",
                "content": "\\n* SELECT Name AS Customers FROM CUSTOMERS LEFT JOIN ORDERS ON ORDERS.CustomerID = Customers.Id\\n* WHERE Orders.CustomerID IS NULL",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "\\n* SELECT Name AS Customers FROM CUSTOMERS LEFT JOIN ORDERS ON ORDERS.CustomerID = Customers.Id\\n* WHERE Orders.CustomerID IS NULL",
                "codeTag": "Unknown"
            },
            {
                "id": 2088820,
                "title": "sql-left-join",
                "content": "```\\nSELECT NAME AS \\'CUSTOMERS\\'FROM CUSTOMERS LEFT JOIN ORDERS\\nON CUSTOMERS.ID = ORDERS.CUSTOMERID\\nWHERE ORDERS.CUSTOMERID IS NULL\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT NAME AS \\'CUSTOMERS\\'FROM CUSTOMERS LEFT JOIN ORDERS\\nON CUSTOMERS.ID = ORDERS.CUSTOMERID\\nWHERE ORDERS.CUSTOMERID IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042319,
                "title": "accepted-solution-for-mysql-clean-simple-code",
                "content": "```\\nSELECT name AS Customers FROM Customers \\nWHERE id NOT IN (SELECT customerId FROM Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name AS Customers FROM Customers \\nWHERE id NOT IN (SELECT customerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001365,
                "title": "simple-sql-query",
                "content": "```\\nselect c.name as Customers\\nfrom Customers c\\nwhere c.id Not In (select customerId from Orders );",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect c.name as Customers\\nfrom Customers c\\nwhere c.id Not In (select customerId from Orders );",
                "codeTag": "Unknown"
            },
            {
                "id": 1965700,
                "title": "183-customers-who-never-order",
                "content": "```\\nselect name as customers from customers AS c\\nleft join orders AS O\\nON c.ID = o.customerID where o.customerId is null;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as customers from customers AS c\\nleft join orders AS O\\nON c.ID = o.customerID where o.customerId is null;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333510,
                "title": "easy-solution-using-sub-query",
                "content": "**Approach**\\n* Since we have the CustomerId column as a foreign key in the Orders table, we need to find all those customers whose Id is not present in CustomerId column of Orders table. \\n* This in turn means that they haven\\'t ordered anything.\\n* So, first we write a sub-query to find all the CustomerIds present in the orders table (Find customers who have ordered something)\\n* Then we filter those Ids from the Customers table which are not a part of the above list of Ids.\\n\\n\\n**QUERY**\\n\\n```\\nselect Name as Customers from Customers C where C.Id not in (select CustomerId from Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Name as Customers from Customers C where C.Id not in (select CustomerId from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071249,
                "title": "a-very-intuitive-and-simple-solution-memory-0b-less-than-100-00",
                "content": "```\\nSELECT Name as Customers \\nFROM Customers\\nWHERE id not in (SELECT CustomerId  FROM Orders)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Name as Customers \\nFROM Customers\\nWHERE id not in (SELECT CustomerId  FROM Orders)",
                "codeTag": "Unknown"
            },
            {
                "id": 1025460,
                "title": "mysql-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT\\n    c.name AS customers\\nFROM\\n    customers AS c\\nLEFT JOIN \\n    orders AS o\\nON o.customerid = c.id\\nWHERE\\n    o.customerid IS NULL\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    c.name AS customers\\nFROM\\n    customers AS c\\nLEFT JOIN \\n    orders AS o\\nON o.customerid = c.id\\nWHERE\\n    o.customerid IS NULL\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53582,
                "title": "a-very-simple-solutions-beats-100-runtime-474-ms",
                "content": "select Name as Customers from Customers where id not in(select CustomerId from Orders);",
                "solutionTags": [],
                "code": "select Name as Customers from Customers where id not in(select CustomerId from Orders);",
                "codeTag": "Unknown"
            },
            {
                "id": 53575,
                "title": "using-distinct-beats-99-of-the-solutions",
                "content": "    select \\n    Name \\n    from \\n    (\\n        select \\n        c.Name, \\n        o.CustomerId\\n        from Customers c \\n        left join (select distinct CustomerId from Orders) o \\n        on c.Id=o.CustomerId \\n    ) t \\n    where t.CustomerId is null\\n    ;",
                "solutionTags": [],
                "code": "    select \\n    Name \\n    from \\n    (\\n        select \\n        c.Name, \\n        o.CustomerId\\n        from Customers c \\n        left join (select distinct CustomerId from Orders) o \\n        on c.Id=o.CustomerId \\n    ) t \\n    where t.CustomerId is null\\n    ;",
                "codeTag": "Unknown"
            },
            {
                "id": 4051574,
                "title": "using-isin-and-negating-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* we just need to select the indicies which are not existing in the orders list\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First you have to know isin() function:\\n    * it takes a list as input, and loop over the calling object, and for each element, it check if this element exist in the provided list or not. \\n    * if it exist, it set its index to True, else it set it as False.\\n    * Then it return list of binary (or bool True, False or 1,0)\\n* Then you have to know that we do not have isnotin() but to apply its logic, we use isin() then prefix it with **~** telda symbol. \\n* Then you have to know rename() method, which we use it to change the name of the pd.Series column name.\\n* Last function to know is .loc[firstParam, secondParam], it takes two parameters\\n    * firstParam: it should be a list of indicies, where you want to select.\\n    * secondParam: it should be a list of columns, that you want to select from.  \\n* Then now you are ready to solve the problem easily, by just \\n    1. get the customers Id column.\\n    2. then apply on it isin() \\n    3. pass to isin(orders.customerId) to search for all the customers who did an order.\\n    4. then use telda **~** to get the customers who did not order.\\n    5. then pass this list to the first parameter of loc method.\\n    6. then the second parameter should be the **name** column, to retrieve the name of the customers who did not order any thing.\\n    7. then you have to use the rename method to change the column name from name to **Customers**.\\n    8. Then just create a dataframe object, and put inside it this coulmn to match the return type of the functio\\n    9. Then return that dataframe.\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n\\n    return pd.DataFrame(customers.loc[~customers.id.isin(orders.customerId), \\'name\\'].rename(\\'Customers\\'))\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    \\n\\n    return pd.DataFrame(customers.loc[~customers.id.isin(orders.customerId), \\'name\\'].rename(\\'Customers\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3891231,
                "title": "pandas-solution-for-beginners",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n\\n\\tcustomers = customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\n\\n\\tresult = customers[[\\'name\\']].rename(columns = {\\'name\\': \\'Customers\\'})\\n\\n\\treturn result\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n\\n\\tcustomers = customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\n\\n\\tresult = customers[[\\'name\\']].rename(columns = {\\'name\\': \\'Customers\\'})\\n\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3864013,
                "title": "pandas-left-anti-join",
                "content": "Left anti join selects only the rows that are present in left dataFrame as per the join-condition.\\n\\nIn other words, \\n`left-anti-join  == (left-join AND  .isna())`\\n\\nHere we are using  the pandas\\' inbuilt `_merge` indicator\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n\\n    joined_df = pd.merge(customers, orders, left_on=\"id\", right_on=\"customerId\", how=\"outer\", indicator=True)\\n    \\n    return joined_df[joined_df[\"_merge\"] == \"left_only\"][[\"name\"]].rename(columns={\"name\": \"Customers\"})\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n\\n    joined_df = pd.merge(customers, orders, left_on=\"id\", right_on=\"customerId\", how=\"outer\", indicator=True)\\n    \\n    return joined_df[joined_df[\"_merge\"] == \"left_only\"][[\"name\"]].rename(columns={\"name\": \"Customers\"})\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3859541,
                "title": "eassy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name as Customers FROM Customers A LEFT JOIN Orders B on  A.Id = B.CustomerId WHERE B.CustomerId is NULL\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name as Customers FROM Customers A LEFT JOIN Orders B on  A.Id = B.CustomerId WHERE B.CustomerId is NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851559,
                "title": "python-easy-solutions",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    cust_order = orders[\\'customerId\\'].unique()\\n    cust_without_order = customers[~customers[\\'id\\'].isin(cust_order)]\\n    return cust_without_order[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    cust_order = orders[\\'customerId\\'].unique()\\n    cust_without_order = customers[~customers[\\'id\\'].isin(cust_order)]\\n    return cust_without_order[[\\'name\\']].rename(columns={\\'name\\': \\'Customers\\'})\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3851554,
                "title": "1-line",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    return (customers.loc[~customers[\"id\"].isin(orders[\"customerId\"]), [\"name\"]].rename(columns={\"name\":\"Customers\"}))\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    return (customers.loc[~customers[\"id\"].isin(orders[\"customerId\"]), [\"name\"]].rename(columns={\"name\":\"Customers\"}))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3849621,
                "title": "my-solution",
                "content": "\\n# Code\\n```\\nselect name as Customers \\nfrom Customers c left join Orders o\\non c.id = o.customerId\\nwhere customerId is null\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers \\nfrom Customers c left join Orders o\\non c.id = o.customerId\\nwhere customerId is null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539806,
                "title": "sub-query-with-easy-understanding-for-beginners",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT name as Customers FROM Customers\\nwhere id NOT IN \\n(Select customerId FROM Orders);\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT name as Customers FROM Customers\\nwhere id NOT IN \\n(Select customerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480948,
                "title": "two-approaches-1-left-join-2-not-in",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.Name as customers from customers as c left join \\norders as o on c.id=o.customerid where o.customerid IS NULL;\\n\\n```\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Name as customers from customers where \\nid not in(select customerid from orders);\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.Name as customers from customers as c left join \\norders as o on c.id=o.customerid where o.customerid IS NULL;\\n\\n```\n```\\n# Write your MySQL query statement below\\nselect Name as customers from customers where \\nid not in(select customerid from orders);\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3290902,
                "title": "easy-sql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN\\n(SELECT CUSTOMERID FROM ORDERS);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN\\n(SELECT CUSTOMERID FROM ORDERS);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3064622,
                "title": "it-is-very-simple-we-just-have-to-check-the-table-and-write-the-query-acc-to-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name as customers from Customers\\nwhere id not in ( select customerId from Orders);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name as customers from Customers\\nwhere id not in ( select customerId from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2890110,
                "title": "mysql-left-join",
                "content": "https://leetcode.com/submissions/detail/855952677/   \\n```\\n# Write your MySQL query statement below\\nselect c.name as \\'Customers\\'\\n\\tfrom Customers as c\\n\\tleft join Orders as o\\n\\ton c.id = o.customerId\\n\\twhere o.customerID is null\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.name as \\'Customers\\'\\n\\tfrom Customers as c\\n\\tleft join Orders as o\\n\\ton c.id = o.customerId\\n\\twhere o.customerID is null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2835582,
                "title": "easiest-solution-mysql-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name as customers from customers where id not in (select customerId from orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name as customers from customers where id not in (select customerId from orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725901,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name as Customers from Customers where id NOT in(select customerId from Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name as Customers from Customers where id NOT in(select customerId from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2665764,
                "title": "mysql-using-join",
                "content": "\\t\\t#MySQL \\n\\t\\tSELECT NAME AS CUSTOMERS FROM CUSTOMERS\\n\\t\\tLEFT JOIN ORDERS\\n\\t\\tON CUSTOMERS.ID=ORDERS.customerId\\n\\t\\tWHERE ORDERS.customerId IS NULL;",
                "solutionTags": [],
                "code": "\\t\\t#MySQL \\n\\t\\tSELECT NAME AS CUSTOMERS FROM CUSTOMERS\\n\\t\\tLEFT JOIN ORDERS\\n\\t\\tON CUSTOMERS.ID=ORDERS.customerId\\n\\t\\tWHERE ORDERS.customerId IS NULL;",
                "codeTag": "Unknown"
            },
            {
                "id": 2618447,
                "title": "2-easy-and-simple-solutions",
                "content": "SELECT customers.name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN\\n(\\n    SELECT Customerid FROM Orders\\n);\\n\\n/*\\nSELECT name AS Customers\\nFROM Customers C\\nLEFT JOIN Orders O\\nON C.Id = O.CustomerId\\nWHERE O.CustomerId IS NULL;\\n*/",
                "solutionTags": [],
                "code": "SELECT customers.name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN\\n(\\n    SELECT Customerid FROM Orders\\n);\\n\\n/*\\nSELECT name AS Customers\\nFROM Customers C\\nLEFT JOIN Orders O\\nON C.Id = O.CustomerId\\nWHERE O.CustomerId IS NULL;\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 2497581,
                "title": "multiple-solutions",
                "content": "## Solution 1: `NOT IN` + second `SELECT`\\n\\n```sql\\nSELECT Customers.name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN (SELECT customerId FROM Orders)\\n```\\n\\n## Solution 2: `LEFT JOIN` + `IS NULL`\\n\\n```sql\\nSELECT Customers.name AS Customers\\nFROM Customers\\nLEFT JOIN Orders\\nON Customers.id = Orders.customerId\\nWHERE Orders.customerId IS NULL\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT Customers.name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN (SELECT customerId FROM Orders)\\n```\n```sql\\nSELECT Customers.name AS Customers\\nFROM Customers\\nLEFT JOIN Orders\\nON Customers.id = Orders.customerId\\nWHERE Orders.customerId IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497309,
                "title": "easy-mysql-solution-simple-to-understand",
                "content": "\\tSELECT Name AS Customers\\n\\tFROM CUSTOMERS\\n\\tLEFT JOIN ORDERS\\n\\tON ORDERS.CustomerID = Customers.Id\\n\\tWHERE Orders.CustomerID IS NULL\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT Name AS Customers\\n\\tFROM CUSTOMERS\\n\\tLEFT JOIN ORDERS\\n\\tON ORDERS.CustomerID = Customers.Id\\n\\tWHERE Orders.CustomerID IS NULL\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2490927,
                "title": "mysql-solution-easy-understanding-nested-select-query",
                "content": "```\\nselect name as Customers \\nfrom Customers\\nwhere id not in (select customerId from Orders )\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers \\nfrom Customers\\nwhere id not in (select customerId from Orders )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478520,
                "title": "simple-one-line-solution",
                "content": "```\\nselect name as Customers from Customers where Customers.id not in (select customerId from Orders)\\n```",
                "solutionTags": [],
                "code": "```\\nselect name as Customers from Customers where Customers.id not in (select customerId from Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2415017,
                "title": "mysql-easy-2-lines",
                "content": "```\\nselect name as Customers from customers where  id not in(\\nselect customerId from Orders );",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers from customers where  id not in(\\nselect customerId from Orders );",
                "codeTag": "Unknown"
            },
            {
                "id": 2409713,
                "title": "easy-solution-of-customers-who-never-order-using-left-join",
                "content": "SELECT c.name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id=o.customerId\\nWHERE o.customerID is NULL;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT c.name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id=o.customerId\\nWHERE o.customerID is NULL;",
                "codeTag": "Unknown"
            },
            {
                "id": 2376105,
                "title": "mysql-left-join-good-luck",
                "content": "```\\n# Write your MySQL query statement below\\n\\n/**\\nHERE Two Tables Customers/ Orders\\nid is the primary key of both tables. So JOIN key is Customers.id = Orders.customerId\\nCustomer table indicates the ID and name of a customer.\\nOrders table indicates the ID of an order and the ID of the customer who ordered it.\\n\\nPROBLEM:  report all customers who never order anything\\n\\nSTEPS: \\nLEFT JOIN the Customers table with Orders table\\nand filter the customerId of Orders table is NULL\\n*/\\n\\nSELECT \\n\\n    name AS Customers\\n    \\nFROM Customers c\\nLEFT JOIN Orders o\\nON c.id = o.customerId \\nwhere o.customerId is null\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n/**\\nHERE Two Tables Customers/ Orders\\nid is the primary key of both tables. So JOIN key is Customers.id = Orders.customerId\\nCustomer table indicates the ID and name of a customer.\\nOrders table indicates the ID of an order and the ID of the customer who ordered it.\\n\\nPROBLEM:  report all customers who never order anything\\n\\nSTEPS: \\nLEFT JOIN the Customers table with Orders table\\nand filter the customerId of Orders table is NULL\\n*/\\n\\nSELECT \\n\\n    name AS Customers\\n    \\nFROM Customers c\\nLEFT JOIN Orders o\\nON c.id = o.customerId \\nwhere o.customerId is null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2359101,
                "title": "mssql-solution",
                "content": "SELECT NAME AS CUSTOMERS \\nFROM CUSTOMERS\\nLEFT JOIN ORDERS\\nON CUSTOMERS.ID=ORDERS.CUSTOMERID\\nWHERE ORDERS.ID IS NULL",
                "solutionTags": [],
                "code": "SELECT NAME AS CUSTOMERS \\nFROM CUSTOMERS\\nLEFT JOIN ORDERS\\nON CUSTOMERS.ID=ORDERS.CUSTOMERID\\nWHERE ORDERS.ID IS NULL",
                "codeTag": "Unknown"
            },
            {
                "id": 2358605,
                "title": "simple-solution-using-not-in",
                "content": "```\\nSELECT Customers.name AS Customers \\nFROM Customers\\nWHERE Customers.id NOT IN \\n(\\n   SELECT customerId from Orders\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Customers.name AS Customers \\nFROM Customers\\nWHERE Customers.id NOT IN \\n(\\n   SELECT customerId from Orders\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325557,
                "title": "simple-nested-subquery",
                "content": "```\\nSelect name as \\'customers\\' from customers where id not in (select customerId from orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect name as \\'customers\\' from customers where id not in (select customerId from orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2321900,
                "title": "mysql-easy-to-understand",
                "content": "```\\nSELECT name AS Customers FROM Customers\\n    WHERE Customers.id \\n        NOT IN (SELECT Orders.customerId FROM Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name AS Customers FROM Customers\\n    WHERE Customers.id \\n        NOT IN (SELECT Orders.customerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232432,
                "title": "faster-tham-98-66-easy-to-understand-without-join",
                "content": "If this post was helpful in any way please upvote this post\\n\\n```\\nselect name as \"Customers\"\\nfrom Customers\\nwhere id not in (\\nselect customerId\\nfrom Orders\\n);\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ff3b7a1e-13df-4743-8bdc-c88ad48fe51f_1656853304.0357132.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as \"Customers\"\\nfrom Customers\\nwhere id not in (\\nselect customerId\\nfrom Orders\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216505,
                "title": "183-customers-who-never-order",
                "content": "```\\n\\nselect name as Customers from Customers where id not in(select customerId from Orders);\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n\\nselect name as Customers from Customers where id not in(select customerId from Orders);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198090,
                "title": "top-96-21-solution",
                "content": "Solution of the Day!\\n\\n```\\nselect name \\'Customers\\' from customers \\nwhere id not in (select customerid from orders);\\n```\\nPS:- You can get the same result if you  do have the premium subscription.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name \\'Customers\\' from customers \\nwhere id not in (select customerid from orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129337,
                "title": "join-notes",
                "content": "Add of two tables\\n1. union (combine two tables by rows and only save repeated rows once) \\n\\n```\\nselect id, col from table 1\\nunion\\nselect id, col from table 2;\\n```\\n\\n2. union all (combine two tables by rows and save repeated rows ) \\n```\\n\\nselect id, col from table 1\\nunion all\\nselect id, col from table 2;\\n```\\n\\n3. inner join\\nJoin is like a cross-product of rows of tables and inner join is selcting the same id\\n\\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a **inner join** table2 as b\\non a.col1 = b.col1\\n```\\n\\n4. left join \\n\\nA \\\\ B with the intersection of A and B\\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a left join table2 as b\\non a.col1 = b.col1\\n```\\n\\n(if the value in a.col1 is not in b.col, assume it exists and the value is null in table 2)\\n\\nonly A \\\\ B \\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a left join table2 as b\\non b.col1 is null; \\n```\\n\\nonly select the value in a.col1 and not in b.col\\n\\n5. right join \\n\\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a right join table2 as b\\non a.col1 = b.col1\\n```\\n\\n(if the value in b.col1 is not in a.col, assume it exists and the value is Null in table1)\\n\\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a right join table2 as b\\non a.col1 is null; \\n```\\n\\n6. outer join \\n\\n```\\n SELECT * \\n    -> FROM Table_A\\n    -> LEFT JOIN Table_B \\n    -> ON Table_A.PK = Table_B.PK\\n    -> UNION ALL\\n    -> SELECT *\\n    -> FROM Table_A\\n    -> RIGHT JOIN Table_B \\n    -> ON Table_A.PK = Table_B.PK\\n    -> WHERE Table_A.PK IS NULL;\\n```\\n\\n7. outer join exclude inner join\\n\\n\\tQUESTION 1965\\n```\\n SELECT * \\n    -> FROM Table_A\\n    -> LEFT JOIN Table_B\\n    -> ON Table_A.PK = Table_B.PK\\n    -> WHERE Table_B.PK IS NULL\\n    -> UNION ALL\\n    -> SELECT *\\n    -> FROM Table_A\\n    -> RIGHT JOIN Table_B\\n    -> ON Table_A.PK = Table_B.PK\\n    -> WHERE Table_A.PK IS NULL;\\n```\\n\\nref \\n\\nhttps://zhuanlan.zhihu.com/p/108582096 \\nhttps://zhuanlan.zhihu.com/p/29234064",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect id, col from table 1\\nunion\\nselect id, col from table 2;\\n```\n```\\n\\nselect id, col from table 1\\nunion all\\nselect id, col from table 2;\\n```\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a **inner join** table2 as b\\non a.col1 = b.col1\\n```\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a left join table2 as b\\non a.col1 = b.col1\\n```\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a left join table2 as b\\non b.col1 is null; \\n```\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a right join table2 as b\\non a.col1 = b.col1\\n```\n```\\nselect a.col1, a.col2, b.col2\\nfrom table1 as a right join table2 as b\\non a.col1 is null; \\n```\n```\\n SELECT * \\n    -> FROM Table_A\\n    -> LEFT JOIN Table_B \\n    -> ON Table_A.PK = Table_B.PK\\n    -> UNION ALL\\n    -> SELECT *\\n    -> FROM Table_A\\n    -> RIGHT JOIN Table_B \\n    -> ON Table_A.PK = Table_B.PK\\n    -> WHERE Table_A.PK IS NULL;\\n```\n```\\n SELECT * \\n    -> FROM Table_A\\n    -> LEFT JOIN Table_B\\n    -> ON Table_A.PK = Table_B.PK\\n    -> WHERE Table_B.PK IS NULL\\n    -> UNION ALL\\n    -> SELECT *\\n    -> FROM Table_A\\n    -> RIGHT JOIN Table_B\\n    -> ON Table_A.PK = Table_B.PK\\n    -> WHERE Table_A.PK IS NULL;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117698,
                "title": "sql-solution-using-left-join",
                "content": "**Please do upvote if this is useful!**\\n```\\n# Write your MySQL query statement below\\nSelect Customers.name as Customers \\nfrom Customers \\nleft join Orders \\non Orders.customerId=Customers.id \\nwhere Orders.id is null;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Please do upvote if this is useful!**\\n```\\n# Write your MySQL query statement below\\nSelect Customers.name as Customers \\nfrom Customers \\nleft join Orders \\non Orders.customerId=Customers.id \\nwhere Orders.id is null;",
                "codeTag": "Unknown"
            },
            {
                "id": 2117664,
                "title": "easy-sql-solution",
                "content": "**Please do upvote if you find this solution helpful**\\n\\nFirstly, all the customerId\\'s are going to be fetched from orders table and after that we gonna select all the id \\'s from customers table which are not in the array.\\n```\\nSelect Customers.name as Customers\\nfrom Customers \\nwhere Customers.id NOT IN \\n(\\nSelect customerId\\nfrom Orders\\n);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Please do upvote if you find this solution helpful**\\n\\nFirstly, all the customerId\\'s are going to be fetched from orders table and after that we gonna select all the id \\'s from customers table which are not in the array.\\n```\\nSelect Customers.name as Customers\\nfrom Customers \\nwhere Customers.id NOT IN \\n(\\nSelect customerId\\nfrom Orders\\n);",
                "codeTag": "Unknown"
            },
            {
                "id": 2029223,
                "title": "183-customers-who-never-order",
                "content": "```\\nSELECT name AS Customers\\nFROM Customers\\n     LEFT JOIN\\n     Orders\\nON Customers.id = Orders.customerId\\nWHERE Orders.customerId IS NULL;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name AS Customers\\nFROM Customers\\n     LEFT JOIN\\n     Orders\\nON Customers.id = Orders.customerId\\nWHERE Orders.customerId IS NULL;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973606,
                "title": "2-solutions-sol-1-not-in-sol-2-left-join-98-53-time-63-88-time",
                "content": "```\\n# Solution 1: using NOT IN\\nselect name as Customers from customers where id not in (\\n    select customerId from Orders \\n);\\n\\n# Solution 2: using LEFT JOIN\\nselect name as Customers from customers \\nleft join \\norders on customers.id = orders.customerId where orders.customerId is null;\\n```",
                "solutionTags": [],
                "code": "```\\n# Solution 1: using NOT IN\\nselect name as Customers from customers where id not in (\\n    select customerId from Orders \\n);\\n\\n# Solution 2: using LEFT JOIN\\nselect name as Customers from customers \\nleft join \\norders on customers.id = orders.customerId where orders.customerId is null;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1950753,
                "title": "ms-sql-solution",
                "content": "select customers.name as Customers\\nfrom customers \\nleft join \\norders\\non customers.id= orders.customerid\\nwhere orders.customerid is null",
                "solutionTags": [],
                "code": "select customers.name as Customers\\nfrom customers \\nleft join \\norders\\non customers.id= orders.customerid\\nwhere orders.customerid is null",
                "codeTag": "Unknown"
            },
            {
                "id": 1943532,
                "title": "customers-who-never-order-easy-solution",
                "content": "```\\nSELECT NAME AS \\'CUSTOMERS\\' FROM CUSTOMERS\\nWHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT NAME AS \\'CUSTOMERS\\' FROM CUSTOMERS\\nWHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878238,
                "title": "two-different-ways-to-solve",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT name AS Customers FROM Customers LEFT JOIN Orders ON (Orders.customerId = Customers.id) WHERE Orders.id IS NULL\\n```\\n\\n\\n\\n```\\n# Write your MySQL query statement below\\nSELECT name AS Customers FROM Customers AS c WHERE c.id NOT IN (SELECT customerId FROM Orders)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name AS Customers FROM Customers LEFT JOIN Orders ON (Orders.customerId = Customers.id) WHERE Orders.id IS NULL\\n```\n```\\n# Write your MySQL query statement below\\nSELECT name AS Customers FROM Customers AS c WHERE c.id NOT IN (SELECT customerId FROM Orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857072,
                "title": "simple-solution",
                "content": "```\\nselect name as Customers from Customers where id not in (select distinct customerId from Orders );\\n```",
                "solutionTags": [],
                "code": "```\\nselect name as Customers from Customers where id not in (select distinct customerId from Orders );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1608458,
                "title": "easiest-solution",
                "content": "select name as Customers \\nfrom Customers\\nwhere id  not in (select customerId from orders)",
                "solutionTags": [],
                "code": "select name as Customers \\nfrom Customers\\nwhere id  not in (select customerId from orders)",
                "codeTag": "Unknown"
            },
            {
                "id": 1383500,
                "title": "mysql-faster-96-using-left-join-and-cte",
                "content": "```# Write your MySQL query statement below\\nWITH null_selector AS\\n  (SELECT t.*,\\n          i.CustomerId\\n   FROM Customers AS t\\n   LEFT JOIN Orders AS i ON t.Id = i.CustomerId)\\nSELECT Name AS Customers\\nFROM null_selector\\nWHERE CustomerId IS NULL\\n```",
                "solutionTags": [],
                "code": "```# Write your MySQL query statement below\\nWITH null_selector AS\\n  (SELECT t.*,\\n          i.CustomerId\\n   FROM Customers AS t\\n   LEFT JOIN Orders AS i ON t.Id = i.CustomerId)\\nSELECT Name AS Customers\\nFROM null_selector\\nWHERE CustomerId IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1297239,
                "title": "mysql-3-ways-exists-not-in-left-join",
                "content": "```\\n#select name Customers from Customers where Id not in (select CustomerId from Orders)\\n#select name Customers from Customers left join Orders on Customers.Id=Orders.CustomerId where Orders.Id is null;\\nselect name Customers from Customers where not exists (select CustomerId from Orders where Orders.CustomerId=Customers.Id)\\n```",
                "solutionTags": [],
                "code": "```\\n#select name Customers from Customers where Id not in (select CustomerId from Orders)\\n#select name Customers from Customers left join Orders on Customers.Id=Orders.CustomerId where Orders.Id is null;\\nselect name Customers from Customers where not exists (select CustomerId from Orders where Orders.CustomerId=Customers.Id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232712,
                "title": "using-left-join",
                "content": "```\\nSelect c.Name Customers from Customers c left join orders o on(c.id = o.customerId) where o.Customerid is NULL;\\n```",
                "solutionTags": [],
                "code": "```\\nSelect c.Name Customers from Customers c left join orders o on(c.id = o.customerId) where o.Customerid is NULL;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 862014,
                "title": "i-use-left-outer-join",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nSELECT C1.Name AS Customers\\nFROM Customers C1\\nLEFT OUTER JOIN Orders O1 ON C1.Id = O1.CustomerId\\nWHERE O1.CustomerId IS NULL\\nORDER BY Customers ASC\\n```\\n\\u4F7F\\u7528\\u4E86\\u5DE6\\u8FDE\\u63A5\\uFF0C\\u68C0\\u67E5\\u7A7A\\u503C\\uFF0C\\u6700\\u540E\\u5347\\u5E8F\\u6392\\u5217\\n\\u770B\\u4E86\\u7B54\\u6848\\u611F\\u89C9\\u7528existsye\\'ke\\'y",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT C1.Name AS Customers\\nFROM Customers C1\\nLEFT OUTER JOIN Orders O1 ON C1.Id = O1.CustomerId\\nWHERE O1.CustomerId IS NULL\\nORDER BY Customers ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 644024,
                "title": "ms-sql-solution",
                "content": "```\\nSELECT c.Name as Customers\\nFROM Customers c\\n--Bring in all Customer Id\\'s regardless if there is a corrsponding value in the Orders Table\\nLEFT OUTER JOIN Orders o\\nON c.Id = o.CustomerId\\n--Drop all the values where CustomerId is not NULL i.e. those customers had placed an order\\nWHERE CustomerId IS NULL\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT c.Name as Customers\\nFROM Customers c\\n--Bring in all Customer Id\\'s regardless if there is a corrsponding value in the Orders Table\\nLEFT OUTER JOIN Orders o\\nON c.Id = o.CustomerId\\n--Drop all the values where CustomerId is not NULL i.e. those customers had placed an order\\nWHERE CustomerId IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623598,
                "title": "better-than-88-not-in",
                "content": "select name as customers from customers where id not in (select customerid from orders)\\n",
                "solutionTags": [],
                "code": "select name as customers from customers where id not in (select customerid from orders)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 502668,
                "title": "ms-sql-server-solution-using-not-exists",
                "content": "```\\nSELECT\\n c.Name AS \\'Customers\\'\\nFROM\\n Customers c\\nWHERE\\n NOT EXISTS (SELECT 1 FROM Orders o WHERE o.CustomerId = c.Id)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n c.Name AS \\'Customers\\'\\nFROM\\n Customers c\\nWHERE\\n NOT EXISTS (SELECT 1 FROM Orders o WHERE o.CustomerId = c.Id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280442,
                "title": "left-join-faster",
                "content": "SELECT ct.Name as Customers\\nFROM Customers as ct\\nLeft JOIN Orders od\\nOn ct.Id=od.CustomerId\\nwhere od.CustomerId is null\\n",
                "solutionTags": [],
                "code": "SELECT ct.Name as Customers\\nFROM Customers as ct\\nLeft JOIN Orders od\\nOn ct.Id=od.CustomerId\\nwhere od.CustomerId is null\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 53568,
                "title": "my-solution-with-not-exists",
                "content": "SELECT Name AS Customers\\nFROM Customers\\nWHERE NOT EXISTS\\n(SELECT CustomerID FROM Orders WHERE Customers.ID=Orders.CustomerID)",
                "solutionTags": [],
                "code": "SELECT Name AS Customers\\nFROM Customers\\nWHERE NOT EXISTS\\n(SELECT CustomerID FROM Orders WHERE Customers.ID=Orders.CustomerID)",
                "codeTag": "Unknown"
            },
            {
                "id": 53569,
                "title": "here-is-my-one-line-solution",
                "content": "```\\nSELECT Name AS Customers FROM Customers  WHERE Id NOT IN (SELECT CustomerId FROM Orders);\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Name AS Customers FROM Customers  WHERE Id NOT IN (SELECT CustomerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008183,
                "title": "easy-merge-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we need to find the cutomers who never ordered anything this can be found by merging both the table using outer join on \\'customerId\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to rename the id column from the customer table column as \\'customerId\\' inorder to match with the column names on both tables. It is also required as per the output that we need to rename the name of the \\'names\\' column as \\'Customers\\'.\\n\\nAfter joining both the tables we can check for the Customers with null values in the order id column.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    nOrd = pd.merge(customers.rename(columns = {\\'id\\': \\'customerId\\', \\'name\\': \\'Customers\\'}), orders, on = \\'customerId\\', how = \\'outer\\')\\n    filDf = nOrd[nOrd[\\'id\\'].isnull()]\\n    return filDf[[\\'Customers\\']]\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    nOrd = pd.merge(customers.rename(columns = {\\'id\\': \\'customerId\\', \\'name\\': \\'Customers\\'}), orders, on = \\'customerId\\', how = \\'outer\\')\\n    filDf = nOrd[nOrd[\\'id\\'].isnull()]\\n    return filDf[[\\'Customers\\']]\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3972622,
                "title": "183-customers-who-never-order-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect name as Customers from Customers where id NOT IN (select DISTINCT customerId from Orders )\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name as Customers from Customers where id NOT IN (select DISTINCT customerId from Orders )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944249,
                "title": "easy-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT NAME Customers FROM CUSTOMERS WHERE ID NOT IN(SELECT CUSTOMERID FROM ORDERS);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT NAME Customers FROM CUSTOMERS WHERE ID NOT IN(SELECT CUSTOMERID FROM ORDERS);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864240,
                "title": "easy-to-understand-solution-for-beginners-using-pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nchanged name of id and name column to customerId and Customers to merge the table order to customers on column customerId merge is same as merge in mysql you have to define the merge type whether outer inner left right etc. then filtered replaced null values with 0 to represent that customer have 0 orders using fillna() which is used to fill in your data inplace of null. after that we save our filtered out data in a new dataframe and return customers column from it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    customers.rename(columns={\"id\":\"customerId\",\"name\":\"Customers\"}, inplace=True)\\n    new_df = pd.merge(customers,orders,how=\"left\", on=\"customerId\")\\n    new_df[\"id\"].fillna(0, inplace=True)\\n    df = new_df[(new_df[\"id\"]==0)]\\n    return df[[\"Customers\"]]\\n```",
                "solutionTags": [
                    "Python3",
                    "Database",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    customers.rename(columns={\"id\":\"customerId\",\"name\":\"Customers\"}, inplace=True)\\n    new_df = pd.merge(customers,orders,how=\"left\", on=\"customerId\")\\n    new_df[\"id\"].fillna(0, inplace=True)\\n    df = new_df[(new_df[\"id\"]==0)]\\n    return df[[\"Customers\"]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3845188,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef customers_who_never_order(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df=pd.DataFrame()\\n    x=orders[\\'customerId\\'].unique()\\n    df[\\'Customers\\']=customers[~customers[\\'id\\'].isin(x)][[\\'name\\']]\\n    return df\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef customers_who_never_order(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df=pd.DataFrame()\\n    x=orders[\\'customerId\\'].unique()\\n    df[\\'Customers\\']=customers[~customers[\\'id\\'].isin(x)][[\\'name\\']]\\n    return df\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3829372,
                "title": "customers-who-never-order-mysql-solution-code",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect name as Customers from Customers\\nwhere id not in(select customerId  from Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name as Customers from Customers\\nwhere id not in(select customerId  from Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643402,
                "title": "sql-solution-cant-get-any-easier",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name AS Customers \\nFROM Customers\\nWHERE id NOT IN (SELECT customerId AS id FROM Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name AS Customers \\nFROM Customers\\nWHERE id NOT IN (SELECT customerId AS id FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3613799,
                "title": "fastest-solution-with-two-liner-code",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal is to find the customers who never placed an order. To achieve this, we can utilize a LEFT JOIN operation to match customers with orders. If a customer doesn\\'t have a corresponding order (i.e., the customerId is NULL), it means they never placed an order.\\n\\n# Approach\\n1. Select the name column from the Customers table as Customers.\\n1. Perform a LEFT JOIN operation between the Customers and Orders tables using the customerId as the join condition.\\n1. Filter out the rows where the customerId in the Orders table is NULL. These are the customers who never placed an order.\\n1. Return the result, which will be the list of customer names (Customers) who never placed an order.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution depends on the size of the Customers and Orders tables. In the worst case, we may need to compare every customer with every order, resulting in a time complexity of $$O(n*m)$$, where n is the number of customers and m is the number of orders.\\n- Space complexity:\\nThe space complexity of this solution depends on the size of the result set, which is the list of customers who never placed an order. In the worst case, if no customer placed an order, the result set will contain all customers, resulting in a space complexity of $$O(n)$$, where n is the number of customers.\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.name as Customers from Customers c\\nleft join Orders o on o.customerId=c.id where o.customerId is null\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/506e2db4-8d2b-4cc9-801d-7ee4961e238d_1686230333.1361094.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.name as Customers from Customers c\\nleft join Orders o on o.customerId=c.id where o.customerId is null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218328,
                "title": "mysql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.name as Customers from Customers as c left join Orders as o on c.id=o.customerId where o.id is NULL;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.name as Customers from Customers as c left join Orders as o on c.id=o.customerId where o.id is NULL;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675277,
                "title": "most-intutive-answer",
                "content": "We will simply do left outer join and select those customer\\'s name from customer table that have null values in order table columns (like order id would be null for them).\\n\\nSELECT c.name AS  Customers FROM Customers c LEFT JOIN Orders o ON c.id=o.customerId WHERE o.id IS NULL",
                "solutionTags": [],
                "code": "We will simply do left outer join and select those customer\\'s name from customer table that have null values in order table columns (like order id would be null for them).\\n\\nSELECT c.name AS  Customers FROM Customers c LEFT JOIN Orders o ON c.id=o.customerId WHERE o.id IS NULL",
                "codeTag": "Unknown"
            },
            {
                "id": 2650448,
                "title": "mysql-simple-solution-using-aggregation-100-less-memory",
                "content": "```\\nselect name as Customers\\nfrom Customers left join Orders\\non Customers.id = Orders.customerId\\ngroup by Customers.id\\nhaving count(Orders.id) = 0\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers\\nfrom Customers left join Orders\\non Customers.id = Orders.customerId\\ngroup by Customers.id\\nhaving count(Orders.id) = 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646304,
                "title": "might-be-the-easiest",
                "content": "```\\nselect name as Customers from Customers  where id not in (select customerid from Orders );\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name as Customers from Customers  where id not in (select customerid from Orders );\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642578,
                "title": "mysql-query",
                "content": "`SELECT C.name as Customers from Customers C\\nWhere id NOT IN (SELECT customerId from Orders);`",
                "solutionTags": [],
                "code": "`SELECT C.name as Customers from Customers C\\nWhere id NOT IN (SELECT customerId from Orders);`",
                "codeTag": "Unknown"
            },
            {
                "id": 2623606,
                "title": "inner-join-failed",
                "content": "Could someone please let me know what mistake I have made for the below to fail submission?\\n\\n```SELECT c.name FROM Customers c WHERE c.id NOT IN (SELECT c.id FROM Customers c INNER JOIN Orders o ON c.id = o.customerId);```",
                "solutionTags": [],
                "code": "```SELECT c.name FROM Customers c WHERE c.id NOT IN (SELECT c.id FROM Customers c INNER JOIN Orders o ON c.id = o.customerId);```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599343,
                "title": "simple-subquery-solution-filtering-not-on-the-basis-of-names-of-customers-but-their-ids",
                "content": "SELECT name as Customers from customers\\nWHERE id not in\\n        (SELECT c.id \\n        from Customers c\\n        JOIN orders o\\n        ON c.id= o.customerId\\n        )",
                "solutionTags": [],
                "code": "SELECT name as Customers from customers\\nWHERE id not in\\n        (SELECT c.id \\n        from Customers c\\n        JOIN orders o\\n        ON c.id= o.customerId\\n        )",
                "codeTag": "Unknown"
            },
            {
                "id": 2593979,
                "title": "customers-who-never-order",
                "content": "Easy solution \\nMysql\\n\\nselect name as customers\\nfrom customers \\nleft join orders on customers.id = orders.customerId \\nwhere customerId is null;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Easy solution \\nMysql\\n\\nselect name as customers\\nfrom customers \\nleft join orders on customers.id = orders.customerId \\nwhere customerId is null;",
                "codeTag": "Unknown"
            },
            {
                "id": 2585057,
                "title": "left-join-simple-solution",
                "content": "SELECT c.name Customers\\nFROM Customers c\\nLEFT JOIN Orders O\\nON c.id = o.customerId\\nWHERE c.Id NOT IN (SELECT customerID FROM orders )",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT c.name Customers\\nFROM Customers c\\nLEFT JOIN Orders O\\nON c.id = o.customerId\\nWHERE c.Id NOT IN (SELECT customerID FROM orders )",
                "codeTag": "Unknown"
            },
            {
                "id": 2584697,
                "title": "simple-easy-query-for-begineers",
                "content": "**IF THIS QUERY HELPS YOU THEN PLEASE UPVOTE**\\t\\n\\t\\n\\tSelect name as Customers from Customers where id not in (select customerId from orders)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**IF THIS QUERY HELPS YOU THEN PLEASE UPVOTE**\\t\\n\\t\\n\\tSelect name as Customers from Customers where id not in (select customerId from orders)",
                "codeTag": "Unknown"
            },
            {
                "id": 2579129,
                "title": "left-join-solution",
                "content": "```\\nSELECT name AS Customers FROM Customers \\nLEFT JOIN Orders\\nON Customers.id=Orders.customerId\\nWHERE Orders.id IS NULL\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT name AS Customers FROM Customers \\nLEFT JOIN Orders\\nON Customers.id=Orders.customerId\\nWHERE Orders.id IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568317,
                "title": "easy-straight-forward-solution-must-try",
                "content": "SELECT Name AS Customers\\nFROM CUSTOMERS\\nLEFT JOIN ORDERS\\nON ORDERS.CustomerID = Customers.Id\\nWHERE Orders.CustomerID IS NULL",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "SELECT Name AS Customers\\nFROM CUSTOMERS\\nLEFT JOIN ORDERS\\nON ORDERS.CustomerID = Customers.Id\\nWHERE Orders.CustomerID IS NULL",
                "codeTag": "Unknown"
            },
            {
                "id": 2529364,
                "title": "simple-and-easy-solution-mysql",
                "content": "select name Customers from customers left join orders on customers.id = orders.customerid where orders.id is null\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select name Customers from customers left join orders on customers.id = orders.customerid where orders.id is null\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2512981,
                "title": "easy-solution-using-joins",
                "content": "**#Solution using Left Join**\\n\\nSELECT name AS Customers\\nFROM Customers AS C\\nLEFT JOIN Orders AS O\\nON C.id = O.customerId\\nWHERE O.CustomerId IS NULL\\n;\\n\\n**LEFT JOIN** returns all the matching rows + non matching rows from the left table.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**#Solution using Left Join**\\n\\nSELECT name AS Customers\\nFROM Customers AS C\\nLEFT JOIN Orders AS O\\nON C.id = O.customerId\\nWHERE O.CustomerId IS NULL\\n;\\n\\n**LEFT JOIN** returns all the matching rows + non matching rows from the left table.",
                "codeTag": "Unknown"
            },
            {
                "id": 2505100,
                "title": "the-easiest-and-best-solution-must-watch",
                "content": "SELECT name as Customers \\nFROM customers \\nLEFT JOIN orders ON customers.id=orders.customerid\\nWHERE orders.customerID is NULL;",
                "solutionTags": [],
                "code": "SELECT name as Customers \\nFROM customers \\nLEFT JOIN orders ON customers.id=orders.customerid\\nWHERE orders.customerID is NULL;",
                "codeTag": "Unknown"
            },
            {
                "id": 2488304,
                "title": "oracle-subquery",
                "content": "```\\nSELECT c.name as Customers\\nFROM Customers c \\nWHERE id NOT IN (SELECT customerID FROM Orders);",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT c.name as Customers\\nFROM Customers c \\nWHERE id NOT IN (SELECT customerID FROM Orders);",
                "codeTag": "Unknown"
            },
            {
                "id": 2485532,
                "title": "mysql-solution-fast-easy",
                "content": "please upvote \\uD83D\\uDD3C\\n```\\nSELECT name AS Customers FROM Customers\\nWHERE  id NOT IN \\n\\t(SELECT customerId FROM Orders) \\n```\\nplease upvote \\uD83D\\uDD3C",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name AS Customers FROM Customers\\nWHERE  id NOT IN \\n\\t(SELECT customerId FROM Orders) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474382,
                "title": "customers-who-never-ordered-simple-approach",
                "content": "```\\nSELECT Customers.name AS Customers FROM Customers WHERE Customers.id NOT IN (SELECT customerId FROM Orders);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Customers.name AS Customers FROM Customers WHERE Customers.id NOT IN (SELECT customerId FROM Orders);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474238,
                "title": "mysql-query-easy-and-complete-explanation",
                "content": "This is an example of Nested Query\\n\\nIn SQL SELECT we first need to give the names of COLUMN which we need in output and use \"as\" to change it\\'s output name to \"Customers\" \\nAnd then FROM -- To indicate the table name, from where we are taking data\\nFinally WHERE -- To specify the condition over row values of mentioned columns\\n\\t\\t\\t\\t\\t\\nInside this WHERE we are checking the nested condition:\\n1. SELECT the customerId column from Orders table this will give rows of all the customers who orders\\n2. Now we need to take negative of above output -- \"NOT IN\" the rows we got from inner query to get customers who don\\'t order\\n\\n\\n\\t\\tSELECT Customers.name as Customers\\n\\t\\tFROM Customers\\n\\t\\tWHERE Customers.id NOT IN (\\n\\t\\t\\tSELECT Orders.customerId\\n\\t\\t\\tFROM Orders\\n\\t\\t);",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "This is an example of Nested Query\\n\\nIn SQL SELECT we first need to give the names of COLUMN which we need in output and use \"as\" to change it\\'s output name to \"Customers\" \\nAnd then FROM -- To indicate the table name, from where we are taking data\\nFinally WHERE -- To specify the condition over row values of mentioned columns\\n\\t\\t\\t\\t\\t\\nInside this WHERE we are checking the nested condition:\\n1. SELECT the customerId column from Orders table this will give rows of all the customers who orders\\n2. Now we need to take negative of above output -- \"NOT IN\" the rows we got from inner query to get customers who don\\'t order\\n\\n\\n\\t\\tSELECT Customers.name as Customers\\n\\t\\tFROM Customers\\n\\t\\tWHERE Customers.id NOT IN (\\n\\t\\t\\tSELECT Orders.customerId\\n\\t\\t\\tFROM Orders\\n\\t\\t);",
                "codeTag": "Unknown"
            },
            {
                "id": 2473694,
                "title": "one-line-mysql-solution",
                "content": "```\\nselect name customers from customers where id not in (select customerId from orders)\\n```",
                "solutionTags": [],
                "code": "```\\nselect name customers from customers where id not in (select customerId from orders)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461900,
                "title": "using-exists-and-subquery",
                "content": "SELECT name AS Customers\\nFROM customers c\\nWHERE NOT EXISTS (SELECT customerId FROM orders WHERE customerId = c.id)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT name AS Customers\\nFROM customers c\\nWHERE NOT EXISTS (SELECT customerId FROM orders WHERE customerId = c.id)",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565450,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1570798,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1575089,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1572484,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1746396,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1574977,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1576224,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1671966,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1759999,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 2010074,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1565450,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1570798,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1575089,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1572484,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1746396,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1574977,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1576224,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1671966,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1759999,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 2010074,
                "content": [
                    {
                        "username": "fuxian",
                        "content": "You all know that in() and not in() have some limitation on number of the list. So, if you will be challenged with interviewed by guys with practical experience"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "You can easily do this: \\n# Write your MySQL query statement below\\n\\nselect c.name as Customers\\nfrom customers c left join orders o on c.id = o.customerId\\nwhere o.customerId is null;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "skumarnvcghd",
                        "content": "Left outer join is used to join two tables. If there is not values exist in second table then it inserts null value in that column. And that is the value \"null\" we need to find in join. :-)\\n\\nselect name as Customers from Customers c1 left outer join Orders o1\\non c1.id = o1.customerId where o1.id is null"
                    },
                    {
                        "username": "prOcenT",
                        "content": "MS SQL\\n\\nselect Name as Customers\\nfrom Customers\\nwhere Id not in (select CustomerId from Orders)"
                    },
                    {
                        "username": "liujiayi0531",
                        "content": "# Write your MySQL query statement below\\nSelect Name as \\'Customers\\' from (Customers left join Orders on Customers.Id = Orders.CustomerId)\\nwhere CustomerId is null"
                    },
                    {
                        "username": "Sanushgowda",
                        "content": "SELECT c.name AS Customers\\nFROM Customers c\\nLEFT JOIN Orders o\\n    ON c.id = o.customerId\\nWHERE o.customerId is NULL;"
                    },
                    {
                        "username": "Simplevolk",
                        "content": "cool answer"
                    },
                    {
                        "username": "Aman_j1",
                        "content": "\\'\\'\\'\\n\\nselect name as customers \\nfrom customers\\nwhere id not in \\n(select customerid from orders);\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "xingchengyusi",
                        "content": "First time I tried this problem use `WHERE Orders.customerId = NULL` not `WHERE Orders.customerId IS NULL`. So that I search some reasons of this error.\\n\\n1. `NULL` is an special markers to indicate a data value not exists, not a data value. So that cannot use `=` to check for equality of.\\n2. However, if I want to assign an variable, using `=` is Ok.\\n\\nRefs:\\n[w3schools](https://www.w3schools.com/SQL/sql_null_values.asp)\\n[wiki](https://en.wikipedia.org/wiki/Null_%28SQL%29)"
                    },
                    {
                        "username": "i00lii",
                        "content": "Hi, \n\nIs anybody know why the version with inner select `select ... from ... where id not in (select ...)` is faster than single select `select ... join ... where customerId in null` according to the acceptance time distribution? \n\nI thought single select is more friendy for the database and it's more preffered. Is it happenes due to small amount of records is the database? \n"
                    },
                    {
                        "username": "miapeng911",
                        "content": "SELECT name AS Customers\\nFROM Customers AS c\\nLEFT JOIN Orders AS o\\nON c.id = o.customerId\\nWHERE customerId IS NULL;"
                    },
                    {
                        "username": "edithi",
                        "content": "To implement the find_customers function, which identifies customers who have never placed an order, you can follow a series of steps. First, perform a left join between the Customers and Orders DataFrames using the appropriate key columns (id and customerId). This merge operation combines the two DataFrames and associates each customer with their orders, if any. Next, employ boolean indexing to filter out the rows where the customerId is null. This step effectively identifies customers who haven\\'t placed an order since their corresponding customerId is absent in the merged DataFrame. After filtering, select the name column to retain only the customer names. To match the expected output format, you may need to rename the column to \\'Customers\\'. Finally, return the resulting DataFrame containing the names of customers who have never placed an order. By following these steps, you can efficiently filter and extract the desired information to identify customers without any orders."
                    }
                ]
            },
            {
                "id": 1977273,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 1575472,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 1574420,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 1573538,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 1572976,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 1572669,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 2076422,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 2037665,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 2015291,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 2014483,
                "content": [
                    {
                        "username": "Sreenibhogi",
                        "content": "It says Wrong Answer although the output is same.\\nselect name \"Customers \"\\nFROM Customers\\nWHERE id NOT IN (select customerId  from Orders)\\n\\nOutput\\n| Customers  |\\n| ---------- |\\n| Max        |\\n| Henry      |\\n\\nExpected\\n| Customers |\\n| --------- |\\n| Henry     |\\n| Max       |"
                    },
                    {
                        "username": "faizrazadec",
                        "content": "hey, did you sort out this problem, i was facing the same problem"
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect customers.Name as Customers from customers where customers.id not in (select customerid from orders) ;"
                    },
                    {
                        "username": "user6859B",
                        "content": "\\nSELECT NAME CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\\n"
                    },
                    {
                        "username": "rj007",
                        "content": "\\'\\'\\'\\nselect name as Customers\\nfrom customers c\\nwhere id not in (select customerid\\n                from orders)\\n\\t\\t\\t\\t\\'\\'\\'"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(05): #183. Customers Who Never Order](https://medium.com/@s9811219/\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB-leetcode-database-sql-\\u89C0\\u5FF5\\u89E3\\u6790-05-183-customers-who-never-order-ce749c706d3)\\n\\nWelcome to kindly clap & like in medium. Let\\'s discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1567397119.png)\\n"
                    },
                    {
                        "username": "CodeJedi",
                        "content": "183. submission marked wrong even though its correct.\\n\\nThis an easy sql statement, but the web site keeps stating my answer is wrong even though it is correct.\\nThe \"correct\" answer shown apparently includes the name \"James\", but \"James\" is NOT a name in this question..."
                    },
                    {
                        "username": "user5460vN",
                        "content": "\\nselect name as Customers\\nfrom Customers \\nleft join Orders\\non Customers.id = Orders.customerId\\nwhere Orders.id is null"
                    },
                    {
                        "username": "Jingwei_Too123",
                        "content": "I was surprise this solution is wrong \\n\\nimport pandas as pd\\n\\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(customers, orders, how=\\'outer\\', left_on=\\'id\\', right_on=\\'customerId\\')\\n    df = df[df[\\'customerId\\'] != df[\\'customerId\\']]\\n    df.rename(columns={\\'name\\':\\'Customers\\'}, inplace=True)\\n\\n    return df[\\'Customers\\'].to_frame()"
                    },
                    {
                        "username": "ersujansharma",
                        "content": "SELECT name as Customers from customers LEFT JOIN orders on Customers.id = orders.customerId WHERE customerID is null\\n is the best simple solution that i get."
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "``SELECT name AS Customers FROM Customers\\nWHERE Customers.id NOT IN (\\n  SELECT DISTINCT customerId FROM Orders\\n);``\\n\\nthis worked for me."
                    }
                ]
            },
            {
                "id": 2009128,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 2006716,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 2005756,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 2005227,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 2000043,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 1997060,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 1943020,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 1937016,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 1897317,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 1895263,
                "content": [
                    {
                        "username": "vishalkumarrajput",
                        "content": "SELECT name as Customers\\nFROM Customers C\\nLEFT JOIN Orders O ON C.id = O.customerId\\nWHERE O.id IS NULL;"
                    },
                    {
                        "username": "shreyashbhandarig28",
                        "content": "customers[~customers[\\'id\\'].isin(orders[\\'customerId\\'])]\\ntry this out for those who are doing the challenge using pandas"
                    },
                    {
                        "username": "Karthika_Subramanyam",
                        "content": "(Pandas) \\nWithout using Join, just use condition to find out the no order customers, then create a dataframe of the column name \"Customers\" and no order customers then return the dataframe."
                    },
                    {
                        "username": "faizrazadec",
                        "content": "I\\'m facing an issue, that when i run my code, they said it\\'s corect and accepted, but when i click on submit it shows that \"wrong answer\"\\nwill anyone help me to solve problem"
                    },
                    {
                        "username": "Sohail17",
                        "content": "the code might not be passing all the testcases after submission , provide the code here\\n"
                    },
                    {
                        "username": "PhoshokoML",
                        "content": "I feel like in some way using the \".issuperset()\" function associated with sets could optimize the speed but I have no angle of using it"
                    },
                    {
                        "username": "knock_knock47",
                        "content": "good to think for the problem using pandas!!\\n"
                    },
                    {
                        "username": "F-said",
                        "content": "In vs Join\\n\\nHey y\\'all, can anyone provide some insight on the performance between IN subqueries and the LEFT JOIN query?\\n\\nFor this type of problem, which query would be preferred? I know the SQL engine does some query optimization in the backend, but is there any objective way to figure out which query would be objectively \"better\"? Thanks for your knowledge."
                    },
                    {
                        "username": "ShubhamSingh1998",
                        "content": "select name as Customers from Customers \\nleft join Orders using(id)\\nwhere id not in(select customerId from Orders); \\n\\ntry my Solution and thank me later."
                    },
                    {
                        "username": "user5582li",
                        "content": "SELECT name as Customers\\n FROM Customers\\n WHERE Customers.id NOT IN(SELECT Customers.id from Customers\\n JOIN Orders ON Customers.id = Orders.customerId);"
                    },
                    {
                        "username": "Ishani_56",
                        "content": "Why cannot we use except operator"
                    }
                ]
            },
            {
                "id": 1891442,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1890701,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1887638,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1885973,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1881574,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1869547,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1866813,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1860967,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1860079,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1844767,
                "content": [
                    {
                        "username": "lex8390",
                        "content": "Can be solved using either a subquery combined with operators or with a left join. In the first case, the query excludes certain values from the subquery and in the second case, the query searches for certain values. "
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Anti Join not supported ?? "
                    },
                    {
                        "username": "sumukhi27",
                        "content": "yeah except is also not supported"
                    },
                    {
                        "username": "prachi_ag",
                        "content": "# Write your MySQL query statement below:\\nThis worked for me:\\nSELECT name as Customers from Customers where id not in (select customerId from orders );"
                    },
                    {
                        "username": "sumukhi27",
                        "content": "Why is using \\'EXCEPT\\' giving error?"
                    },
                    {
                        "username": "Mohsin_Rajpoot",
                        "content": "can someone define why this produce wrong results\\nselect name from Customers,Orders\\nwhere (Customer.id != Orders.customerId;"
                    },
                    {
                        "username": "4ebyrek",
                        "content": "select Customers.name as Customers\\nfrom Customers \\nleft join Orders on Customers.id = Orders.customerId\\nwhere orders.Id is null;"
                    },
                    {
                        "username": "AKASH_Chauhan",
                        "content": "I did this with hit and trial(not sure it someone else already did) and it worked, but will this work with large no. of rows and also how to improve this one.? And if there are expert here please share your approach so that all can improve their understanding and learn new ways.\\n# Write your MySQL query statement below\\nwith t1 as (select name, customers.id, count(customerid) as COU \\nfrom customers \\nleft join orders \\non orders.customerid = customers.id \\ngroup by name, customers.id)\\n\\nselect name as Customers from t1 where COU<1"
                    },
                    {
                        "username": "bossbhai",
                        "content": "select name as customers from customers where id in (2,4)"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nselect c.name as Customers from Customers as c where c.id not in (select o.customerId from orders as o)"
                    },
                    {
                        "username": "samridhi01",
                        "content": "this one  is a example of nested sub query. "
                    },
                    {
                        "username": "amanjhabak7",
                        "content": "Hello I have been trying this code but it\\'s not getting me those remaining Customers\\n\\nwith cte as (\\n  select c.id,c.name, o.customerId as oC\\n  from Customers as c\\n  left join Orders as o\\n  on c.id = o.customerId\\n)\\n\\nselect name,id,oC as Customers\\nfrom cte\\nwhere id!=oC"
                    }
                ]
            },
            {
                "id": 1840370,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1833648,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1826700,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1811649,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1810669,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1803045,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1794840,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1793529,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1793413,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1792640,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id ,name from Customers),\\ncte2 as (select id,customerId from Orders)\\n\\nselect name as Customers from\\ncte a \\nleft join cte2 b on a.id=b.customerId\\nwhere b.customerID is null"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "Anyone know why the following query fails?\\n`\\nSELECT name AS Customers\\nFROM Customers\\nWHERE Customers.id NOT IN Orders.CustomerId;\\n`"
                    },
                    {
                        "username": "fseifishahpar",
                        "content": "select name as Customers from Customers c\\nwhere c.id not in (select customerId from Orders);"
                    },
                    {
                        "username": "007gabrisati",
                        "content": "Doesn\\'t LeetCode recognize EXCEPT as table1 minus table2?\\n"
                    },
                    {
                        "username": "Sandhya615",
                        "content": "# Write your MySQL query statement below\\nselect name as Customers from Customers left join Orders on Customers.id = Orders.customerId\\nwhere Orders.id is null ;\\n"
                    },
                    {
                        "username": "akshatkant1311",
                        "content": "select name from Customers\\nMINUS\\nselect name from Customers where id in (\\n    select customerid from Orders \\n) Can anyone tell whats wrong????"
                    },
                    {
                        "username": "Ili_K",
                        "content": "Can someone please explain why I get \"Not unique table/alias: \\'Customers\\'\" when I use the statement:\\n\\nSELECT name\\nFROM Customers\\nLEFT OUTER JOIN Customers ON Customers.id=Orders.customerId\\nWHERE Orders.id=null\\n;"
                    },
                    {
                        "username": "alirabbi3112",
                        "content": "Here is my Solution with no join but using Not in operator. \\nIn this section \" SELECT Customers.name as Customers\\nFROM Customers \" I get the name from Customer table then in where clause compare which not in order table which will shown \"WHERE Customers.id NOT IN (SELECT Orders.customerId FROM Orders);\""
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "Still learning joins but I thought Inner join would help in this case . \\nBecause we need to find whats not common. \\n\\nSo I wrote a query like this :\\n\\nSelect c1.name from Customers c1\\nInner join Orders o1\\non c1.id != o1.customerId\\n\\nCan someone explain why this does not work "
                    },
                    {
                        "username": "AkhilPamarthy",
                        "content": "Find Customer Referee"
                    }
                ]
            },
            {
                "id": 1787299,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1783701,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1776543,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1776049,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1774757,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1774196,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1772113,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1761588,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1758819,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1758090,
                "content": [
                    {
                        "username": "user1897wM",
                        "content": "select name as \"Customers\" from Customers where name not in (\\nselect c.name from Customers c  join Orders o on c.id = o.customerId )\\n\\nwhy this is showing wrong answers"
                    },
                    {
                        "username": "healer290401",
                        "content": "SELECT DISTINCT a.name AS Customers \\nFROM Customers a, Orders b\\nWHERE a.name NOT IN (SELECT a.name FROM Customers a INNER JOIN Orders b ON a.id = b.customerId)"
                    },
                    {
                        "username": "smarthood",
                        "content": "I think this will work!!!\\n\\nSELECT name as Customers\\nfrom Customers\\nWhere id NOT in (select customerId from Orders)"
                    },
                    {
                        "username": "azaraatif",
                        "content": "\\nselect name \\'Customers\\' from Customers \\nwhere id not in (select distinct customerId   from Orders  )\\norder by name;"
                    },
                    {
                        "username": "Hopkins666",
                        "content": "Why can\\'t I use the table I created from Select query?\\n\\nCreate Table YYY AS \\nselect count(order_number) from Orders \\nGroup by customer_number\\n\\nSelect * from YYY\\n"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`select name as Customers\\nfrom Customers\\nwhere id not in (select customerId from Orders)`"
                    },
                    {
                        "username": "xuyiouqd",
                        "content": "Can anybody tell me why my answer is correct but marked as wrong?\\nselect name\\nfrom (select Customers.id, Customers.name, Orders.id, Orders.customerId\\nfrom Customers\\nleft join Orders on Orders.customerId = Customers.id) \\nwhere customerId is null"
                    },
                    {
                        "username": "victor971125",
                        "content": "Why does it not work when I use Join instead of left join?"
                    },
                    {
                        "username": "anewanu",
                        "content": "\\nSELECT NAME FROM CUSTOMERS\\nWHERE NOT EXISTS(SELECT CUSTOMERS.NAME \\nFROM CUSTOMERS\\nINNER JOIN ORDERS \\nON CUSTOMERS.ID = ORDERS.CUSTOMERID);\\n\\n\\nWhy this query doesn\\'t give the right output but if subquery is executed individually it returns the desired output? Want to know the flow of this query!"
                    },
                    {
                        "username": "jamesbond098989",
                        "content": "WHERE statement should be used after the JOIN statement and use left join instead of inner join."
                    },
                    {
                        "username": "abdullakh",
                        "content": "Make sure the names are in the correct order (ascending) in your answer guys!"
                    }
                ]
            },
            {
                "id": 1754303,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1748721,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1742708,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1735414,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1730207,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1725672,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1718399,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1718011,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1710834,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            },
            {
                "id": 1710638,
                "content": [
                    {
                        "username": "user0160Kj",
                        "content": "select name as Customers from Customers where\\nname+id not in (select name+c.id from Customers as c\\njoin Orders on Orders.customerId = c.id)\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "select\\n    name as Customers\\nfrom Customers\\nwhere \\n    id \\n        NOT IN\\n    (select customerId from Orders)"
                    },
                    {
                        "username": "khalmatay",
                        "content": "SELECT name\\nFrom Customers\\nEXCEPT\\nSELECT name\\nFrom Customers,Orders\\nWhere Customers.id=Orders.customerId\\nWhy is don\\'t work?"
                    },
                    {
                        "username": "kavyas1989",
                        "content": "This is my solution where first i just tried to use left join as we need to consider every column from employee table to make decision , then i got table where i had null values in customer id column fr\\'om orders table then i tried to select those record where customer has not ordered  anything with the help of is null\" operator\\n\\n\\nwith ordered as (select c.* , o.customerId\\nfrom customers c left join orders o\\non c.id = o.customerId )\\n\\nselect name as customers \\nfrom ordered \\nwhere ordered.customerID is null;"
                    },
                    {
                        "username": "Sohail17",
                        "content": "select name Customers from Customers C\\nLEFT JOIN ORDERS O\\nON C.ID=O.CUSTOMERID\\nWHERE O.CUSTOMERID IS NULL\\n \\n\\nIsn\\'t this similar or using with clause is more efficient and faster ?"
                    },
                    {
                        "username": "Shumg1803",
                        "content": "\\nselect name as Customers\\nfrom Customers\\nwhere id NOT IN(select customerId from Orders)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# LEFT JOIN \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/customers-who-never-order/solutions/2943074/left-join/?orderBy=most_votes"
                    },
                    {
                        "username": "abhishekmishra9051",
                        "content": "SELECT name AS Customers FROM Customers \\nWHERE ID NOT IN (SELECT customerId FROM Orders  )"
                    },
                    {
                        "username": "sharryy",
                        "content": "You should always take care while using IN() and NOT IN() in any query with NULL values. Because it evaluates to unknown and ignores the record. Better to use NOT EXISTS to avoid this because NOT EXISTS always returns true or false."
                    },
                    {
                        "username": "pcoder007",
                        "content": "Here is a simple solution\\n\\n\\n\\nselect name as customers\\nfrom\\n(\\n    select name\\n    from customers\\n    left join orders\\n    on customers.id = orders.customerid\\n    where orders.customerid is null\\n) a"
                    },
                    {
                        "username": "liutsewei",
                        "content": "\\nSELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT DISTINCT(customerId)\\n                FROM Orders)"
                    }
                ]
            }
        ]
    }
]