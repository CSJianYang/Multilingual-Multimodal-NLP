[
    {
        "title": "Number of Recent Calls",
        "question_content": "You have a RecentCounter class which counts the number of recent requests within a certain time frame.\nImplement the RecentCounter class:\n\n\tRecentCounter() Initializes the counter with zero recent requests.\n\tint ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].\n\nIt is guaranteed that every call to ping uses a strictly larger value of t than the previous call.\n&nbsp;\nExample 1:\n\nInput\n[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n[[], [1], [100], [3001], [3002]]\nOutput\n[null, 1, 2, 3, 3]\nExplanation\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1\nrecentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2\nrecentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3\nrecentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3\n\n&nbsp;\nConstraints:\n\n\t1 <= t <= 109\n\tEach test case will call ping with strictly increasing values of t.\n\tAt most 104 calls will be made to ping.",
        "solutions": [
            {
                "id": 189239,
                "title": "java-python-3-five-solutions-treemap-treeset-arraylist-queue-circular-list",
                "content": "**Update 2**: Added 2 implementations of Python 3.\\n**Update 1**: Method 4 added for those who are interested in space optimization.\\n\\n**Mehod 1:** `TreeMap`.\\n\\nUse current time and total number of calls as the key and value of `TreeMap`, respectively.\\n\\n**Analysis**\\nTime: O(logN), space: O(N), where N is the number of ping calls from first one till now.\\n\\n```TreeMap.tailMap()``` and `put()` both cost time O(logN).\\n```\\n    TreeMap<Integer, Integer> tm;\\n\\n    public RecentCounter() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public int ping(int t) {\\n        tm.put(t, 1 + tm.size());\\n        return tm.tailMap(t - 3000).size();\\n    }\\n```\\n**Mehod 2:** `TreeSet`.\\n\\nOr similarly use ```TreeSet``` instead.\\n\\n```TreeSet.tailSet()``` and `add()` both cost time O(logN).\\n\\n```\\n    TreeSet<Integer> ts;\\n\\n    public RecentCounter() {\\n        ts = new TreeSet<>();\\n    }\\n    \\n    public int ping(int t) {\\n        ts.add(t);\\n        return ts.tailSet(t - 3000).size();\\n    }\\n```\\nSince some complain that the above two methods cause `TLE`, I guess that besides `tailMap` and `tailSet, TreeMap.put()` and `TreeSet.add()` also cost `O(logN)`, therefore the total time cost is high.\\n\\nThe following method will use less time.\\n\\n**Mehod 3:** \\n**Java: Binary Search `ArrayList`**.\\n\\nUse binary search to find the index of the ceiling of `t - 3000`, then `list.size() - index` is the answer.\\n\\n`binarySearch()` cost `O(logN)`.\\n```\\n\\n    List<Integer> list;\\n\\n    public RecentCounter() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int index = Collections.binarySearch(list, t - 3000); // search the index of t - 3000.\\n        if (index < 0) { index = ~index; } // if t - 3000 is not in list, use the index of the ceiling of t - 3000.\\n        return list.size() - index;\\n    }\\n```\\n**Python 3: bisect**\\n```\\n    def __init__(self):\\n        self.ls = []\\n\\n    def ping(self, t: int) -> int:\\n        self.ls.append(t)\\n        return len(self.ls) - bisect.bisect_left(self.ls, t - 3000)\\n```\\n**Mehod 4:** `Queue`.\\n\\nTime & space: `O(Math.min(N, 3000))`.\\n**Java**\\n```\\n    Queue<Integer> q;\\n\\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.offer(t);\\n        while (q.peek() < t - 3000) { q.poll(); }\\n        return q.size();\\n    }\\n```\\n**Python 3: deque**\\n```\\n    def __init__(self):\\n        self.dq = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.dq.append(t)\\n        while self.dq[0] < t - 3000:\\n            self.dq.popleft()\\n        return len(self.dq)\\n```\\n**Method 5: Fixed size array to implement Circular List**\\nBy **@wushangzhen**\\n\\n```\\n    int[] time;\\n    public RecentCounter() {\\n        time = new int[3001];\\n    }\\n    \\n    public int ping(int t) {\\n        int res = 0;\\n        time[t % 3001] = t;\\n        for (int i = 0; i < 3001; i++) {\\n            if (time[i] != 0 && time[i] >= t - 3000) {\\n                res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Note:** the following Python 3 implementation of the method get **TLE**:\\nLet me know if you have any idea to make it faster.\\n```\\n    def __init__(self):\\n        self.time = [0] * 3001\\n\\n    def ping(self, t: int) -> int:\\n        self.time[t % 3001] = t\\n        return sum([self.time[i] and self.time[i] >= t - 3000 for i in range(3001)])\\n```",
                "solutionTags": [],
                "code": "```TreeMap.tailMap()```\n```\\n    TreeMap<Integer, Integer> tm;\\n\\n    public RecentCounter() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public int ping(int t) {\\n        tm.put(t, 1 + tm.size());\\n        return tm.tailMap(t - 3000).size();\\n    }\\n```\n```TreeSet```\n```TreeSet.tailSet()```\n```\\n    TreeSet<Integer> ts;\\n\\n    public RecentCounter() {\\n        ts = new TreeSet<>();\\n    }\\n    \\n    public int ping(int t) {\\n        ts.add(t);\\n        return ts.tailSet(t - 3000).size();\\n    }\\n```\n```\\n\\n    List<Integer> list;\\n\\n    public RecentCounter() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int index = Collections.binarySearch(list, t - 3000); // search the index of t - 3000.\\n        if (index < 0) { index = ~index; } // if t - 3000 is not in list, use the index of the ceiling of t - 3000.\\n        return list.size() - index;\\n    }\\n```\n```\\n    def __init__(self):\\n        self.ls = []\\n\\n    def ping(self, t: int) -> int:\\n        self.ls.append(t)\\n        return len(self.ls) - bisect.bisect_left(self.ls, t - 3000)\\n```\n```\\n    Queue<Integer> q;\\n\\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.offer(t);\\n        while (q.peek() < t - 3000) { q.poll(); }\\n        return q.size();\\n    }\\n```\n```\\n    def __init__(self):\\n        self.dq = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.dq.append(t)\\n        while self.dq[0] < t - 3000:\\n            self.dq.popleft()\\n        return len(self.dq)\\n```\n```\\n    int[] time;\\n    public RecentCounter() {\\n        time = new int[3001];\\n    }\\n    \\n    public int ping(int t) {\\n        int res = 0;\\n        time[t % 3001] = t;\\n        for (int i = 0; i < 3001; i++) {\\n            if (time[i] != 0 && time[i] >= t - 3000) {\\n                res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    def __init__(self):\\n        self.time = [0] * 3001\\n\\n    def ping(self, t: int) -> int:\\n        self.time[t % 3001] = t\\n        return sum([self.time[i] and self.time[i] >= t - 3000 for i in range(3001)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189334,
                "title": "c-easy-and-clean-solution-using-queue",
                "content": "if the queue is not empty , pop the elements which are lesser than t-3000  \\nPush the current element into the queue\\nReturn queue size\\n \\n    queue<int> q;\\n    \\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        \\n\\t\\tq.push(t);\\n\\t\\t   \\n        while(q.front() < t-3000)\\n            q.pop();\\n        \\n        return q.size();\\n    }\\n",
                "solutionTags": [],
                "code": "if the queue is not empty , pop the elements which are lesser than t-3000  \\nPush the current element into the queue\\nReturn queue size\\n \\n    queue<int> q;\\n    \\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        \\n\\t\\tq.push(t);\\n\\t\\t   \\n        while(q.front() < t-3000)\\n            q.pop();\\n        \\n        return q.size();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 189425,
                "title": "python-straightforward-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p = collections.deque()        \\n\\n    def ping(self, t):\\n        self.p.append(t)\\n        while self.p[0] < t - 3000:\\n            self.p.popleft()\\n        return len(self.p)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p = collections.deque()        \\n\\n    def ping(self, t):\\n        self.p.append(t)\\n        while self.p[0] < t - 3000:\\n            self.p.popleft()\\n        return len(self.p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873333,
                "title": "python-easy-solution-using-queue-explained",
                "content": "What we need to keep in this problem is sliding window of recent calls. So, we need to remove old calls, if they are too old and append new ones. Ideal data structure is queue, and in python we usualy use `deque`. So, there are 3 simple steps to succes:\\n\\n1. Add new call time to the end of our queue.\\n2. Remove old times: we pop from the beginning of our queue until time is not older than `last - 3000`.\\n3. Return length of our queue: it will be exaclty what we need.\\n\\n**Complexity**: even though for each call of `ping` function we can potentially call a lot of `popleft()`, if we run `ping` `n` times we will have `O(n)` complexity: each element go to queue and from queue only once, so we can say amortised time complexity is `O(1)`. Space complexity can be potentially `O(3000)`. \\n\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.calls = deque()\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < self.calls[-1] - 3000:\\n            self.calls.popleft()\\n        return len(self.calls)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.calls = deque()\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < self.calls[-1] - 3000:\\n            self.calls.popleft()\\n        return len(self.calls)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322357,
                "title": "javascript-detailed-explanation-beats-99-76-o-n-time-o-n-space",
                "content": "Similar to the rate limiter question. Represent the calls at time T as a streaming array of integers using a queue.\\n1. For each call, add t to the end of the queue.\\n2. Maintain the queue so that the front is always within the time frame of t - 3000 (we trim the values that dont appear in this interval)\\n```\\nPing(1)\\nstream = [ 1 ] \\nPing(100)\\nstream = [ 1, 100 ] \\nping(3001)\\nstream = [ 1, 100, 3001 ]\\nping(3002)\\nstream = [ 100, 3001, 3002 ] \\nReturn the stream\\'s count after each call\\n```\\n```\\nvar RecentCounter = function() {\\n    this.stream = []\\n};\\nRecentCounter.prototype.ping = function(t) {\\n    this.stream.push(t) // Everytime we recieve a ping, add the time to the stream of integers\\n  /*\\n  To exclude the times that are not included within the range of t - 3000,\\n  we remove the first element from the stream while it is less than the calculated range \\n  */\\n    while(this.stream[0] < t - 3000){ \\n      this.stream.shift()\\n  } \\n    // When the loop ends the length of calls will be the length of the array\\n    return this.stream.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nPing(1)\\nstream = [ 1 ] \\nPing(100)\\nstream = [ 1, 100 ] \\nping(3001)\\nstream = [ 1, 100, 3001 ]\\nping(3002)\\nstream = [ 100, 3001, 3002 ] \\nReturn the stream\\'s count after each call\\n```\n```\\nvar RecentCounter = function() {\\n    this.stream = []\\n};\\nRecentCounter.prototype.ping = function(t) {\\n    this.stream.push(t) // Everytime we recieve a ping, add the time to the stream of integers\\n  /*\\n  To exclude the times that are not included within the range of t - 3000,\\n  we remove the first element from the stream while it is less than the calculated range \\n  */\\n    while(this.stream[0] < t - 3000){ \\n      this.stream.shift()\\n  } \\n    // When the loop ends the length of calls will be the length of the array\\n    return this.stream.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594800,
                "title": "question-and-solution-both-clearly-explained",
                "content": "ok!\\nlets do this!\\nso this is one of the worst explained questions and solutions of leetcode!\\nlet me try and make it easy for you guys!!\\n\\nso what the basic idea of the question is that several ping times will be given and we have to return the number of \" valid \" pings!\\n\\ni describe \"valid\"  as follows:\\nsuppose i ping at t=3000 \\nlet t1=3000\\nthen i again ping at t=3001\\nlet t2=3001;\\n\\n**the constraint for a ping to be a \"valid\" ping is that \"t2-t1<=3000\"\\n\"i.e the difference of two ping times should not exceed 3000\"**\\n\\nso lets try the example in the question:\\nping times are[1,100,3001,30002]\\n\\nso lets say t1=0;(because t2==1 is the first ping,no pings are made befre t==1)\\nt2=1\\nsp t2-t1<=3000(validity condition met)\\nso for t==1 we output 1;\\n\\nthen t2=100\\nt1=1\\nsame thing\\nwe return the total number of valid pings ==2;\\n\\nfor t2=3001\\nwe have :\\nt1=100;\\nt2-t1<=3000(valid)\\nalso\\nt1=1\\nt2-t1<=3000(valid)\\nso both the pings before t=3001 are valid hence output =3;\\nNOW:\\nt2=3002;\\nwe have t1=3001;\\nt2-t1<=3000\\nso valid\\nt1=100\\nt2-t1<=3000\\nso valid\\nbut t1=1;\\nt2-t1=3001\\nwhich is not less than or equal to 3000!\\nso we dont count t==1;\\ntherefore valid pings for t=3002 are t1=100,3001,3002!\\n\\nhope i was able to explain!\\n\\ncode for reference:\\n```\\n\\nhope it helps\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q = new LinkedList();\\n    }\\n\\n    public int ping(int t) {\\n        q.add(t);\\n        while (q.peek() < t - 3000)\\n            q.poll();\\n        return q.size();\\n    }\\n}\\n```\\n\\nhope it helps!\\nthank you!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nhope it helps\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q = new LinkedList();\\n    }\\n\\n    public int ping(int t) {\\n        q.add(t);\\n        while (q.peek() < t - 3000)\\n            q.poll();\\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430731,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass RecentCounter {\\n\\tpublic:\\n\\t\\tRecentCounter() {\\n\\n\\t\\t}\\n\\n\\t\\tqueue<int> q;\\n\\n\\t\\tint ping(int t) {\\n\\n\\t\\t\\tq.push(t);\\n\\n\\t\\t\\twhile(q.front() < t - 3000){\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn q.size();\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "\\tclass RecentCounter {\\n\\tpublic:\\n\\t\\tRecentCounter() {\\n\\n\\t\\t}\\n\\n\\t\\tqueue<int> q;\\n\\n\\t\\tint ping(int t) {\\n\\n\\t\\t\\tq.push(t);\\n\\n\\t\\t\\twhile(q.front() < t - 3000){\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn q.size();\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "codeTag": "Java"
            },
            {
                "id": 873418,
                "title": "python-and-c-multiple-approaches-binary-search-dequeue",
                "content": "Python \\n```\\n# USING DEQUE\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        queue = self.queue\\n        start = t - 3000\\n        queue.append(t)\\n        while(queue and queue[0] < start):\\n            queue.popleft()\\n        return len(queue)\\n```\\n\\nC++\\n```\\n//USING DEQUE\\nclass RecentCounter {\\npublic:\\n    deque<int> dq;\\n    RecentCounter() {\\n        return ;\\n    }\\n    \\n    int ping(int t) {\\n        dq.push_back(t);\\n        while(!dq.empty() && dq.front()<t-3000)\\n            dq.pop_front();\\n        return dq.size();\\n    }\\n};\\n```\\n\\n\\nBINARY SEARCH APPROACH IN PYTHON\\n```\\n# USING BINARY SEARCH\\nclass RecentCounter:\\n    def __init__(self):\\n        self.arr = []\\n\\n    def ping(self, t: int) -> int:\\n        self.arr.append(t)\\n        start = t - 3000\\n        if(t<=0):\\n            return len(self.arr)\\n      # find t which is >= start in arr\\n        def binSearch(start,arr):\\n            i = 0\\n            j = len(arr)\\n            while(i<=j):\\n                mid = (i+j)//2\\n                if(arr[mid] > start):\\n                    j = mid - 1\\n                elif(arr[mid] < start):\\n                    i = mid + 1\\n                else:\\n                    return mid\\n            return i\\n        \\n        indx = binSearch(start,self.arr)\\n        return len(self.arr) - indx\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n# USING DEQUE\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        queue = self.queue\\n        start = t - 3000\\n        queue.append(t)\\n        while(queue and queue[0] < start):\\n            queue.popleft()\\n        return len(queue)\\n```\n```\\n//USING DEQUE\\nclass RecentCounter {\\npublic:\\n    deque<int> dq;\\n    RecentCounter() {\\n        return ;\\n    }\\n    \\n    int ping(int t) {\\n        dq.push_back(t);\\n        while(!dq.empty() && dq.front()<t-3000)\\n            dq.pop_front();\\n        return dq.size();\\n    }\\n};\\n```\n```\\n# USING BINARY SEARCH\\nclass RecentCounter:\\n    def __init__(self):\\n        self.arr = []\\n\\n    def ping(self, t: int) -> int:\\n        self.arr.append(t)\\n        start = t - 3000\\n        if(t<=0):\\n            return len(self.arr)\\n      # find t which is >= start in arr\\n        def binSearch(start,arr):\\n            i = 0\\n            j = len(arr)\\n            while(i<=j):\\n                mid = (i+j)//2\\n                if(arr[mid] > start):\\n                    j = mid - 1\\n                elif(arr[mid] < start):\\n                    i = mid + 1\\n                else:\\n                    return mid\\n            return i\\n        \\n        indx = binSearch(start,self.arr)\\n        return len(self.arr) - indx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189277,
                "title": "java-super-short-deque-solution",
                "content": "```\\n    Deque<Integer> dq;\\n\\n    public RecentCounter() {\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!dq.isEmpty() && t - dq.getFirst() > 3000) dq.removeFirst();\\n        dq.addLast(t);\\n        return dq.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Deque<Integer> dq;\\n\\n    public RecentCounter() {\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!dq.isEmpty() && t - dq.getFirst() > 3000) dq.removeFirst();\\n        dq.addLast(t);\\n        return dq.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582485,
                "title": "c-code-most-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() { }\\n    \\n    int ping(int t) {\\n        int st=t-3000,c=0;\\n        q.push(t);\\n\\n        while(!q.empty() ){\\n            if(q.front() <st )\\n            q.pop();\\n            else\\n            break;\\n        }\\n\\n        return q.size();\\n\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Queue",
                    "Data Stream"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() { }\\n    \\n    int ping(int t) {\\n        int st=t-3000,c=0;\\n        q.push(t);\\n\\n        while(!q.empty() ){\\n            if(q.front() <st )\\n            q.pop();\\n            else\\n            break;\\n        }\\n\\n        return q.size();\\n\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984449,
                "title": "java-queue",
                "content": "\\n\\n# Code\\n```\\nclass RecentCounter {\\n      Queue<Integer> q;\\n    public RecentCounter() {\\n        q= new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek()<t-3000){\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n      Queue<Integer> q;\\n    public RecentCounter() {\\n        q= new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek()<t-3000){\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873209,
                "title": "python-super-simple-and-short-solution-o-1-time-o-1-space",
                "content": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.recent = []\\n\\n    def ping(self, t: int) -> int:\\n        self.recent.append(t)\\n        while self.recent[0] < t-3000:\\n            self.recent.pop(0)\\n        return len(self.recent)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.recent = []\\n\\n    def ping(self, t: int) -> int:\\n        self.recent.append(t)\\n        while self.recent[0] < t-3000:\\n            self.recent.pop(0)\\n        return len(self.recent)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826041,
                "title": "python-3-88-08-faster-used-list-as-queue",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe can use list as a queue or use collections.deque.\\ncollections.deque has a function popleft() to remove first element. Since it\\'s not available in list, we can pass index 0 to pop()\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.pop(0)\\n        self.queue.append(t)\\n        return len(self.queue)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.pop(0)\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506905,
                "title": "c-simple-solution-using-queue",
                "content": "```\\npublic class RecentCounter {\\n    private Queue<int> _queue;\\n    private const int Interval = 3000;\\n\\n    public RecentCounter() {\\n        _queue = new Queue<int>();\\n    }\\n    \\n    public int Ping(int t) {\\n        _queue.Enqueue(t);\\n        while (t - _queue.Peek() > Interval)\\n            _queue.Dequeue();\\n        return _queue.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Queue"
                ],
                "code": "```\\npublic class RecentCounter {\\n    private Queue<int> _queue;\\n    private const int Interval = 3000;\\n\\n    public RecentCounter() {\\n        _queue = new Queue<int>();\\n    }\\n    \\n    public int Ping(int t) {\\n        _queue.Enqueue(t);\\n        while (t - _queue.Peek() > Interval)\\n            _queue.Dequeue();\\n        return _queue.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269419,
                "title": "python",
                "content": "class RecentCounter(object):\\n\\n    def __init__(self):\\n        \\n        # \\u7528\\u961F\\u5217\\u601D\\u60F3\\uFF0C\\u5DE6\\u8FB9\\u51FA\\uFF0C\\u53F3\\u8FB9\\u8FDB\\n        self.queue = collections.deque()\\n        \\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        # given a time t, time t-3000 \\u4E3A 3000 \\u6BEB\\u79D2\\u4E4B\\u524D\\u7684\\u65F6\\u95F4\\u70B9\\uFF0C\\u4EFB\\u4F55\\u5C0F\\u4E8E\\u90A3\\u4E2A\\u65F6\\u95F4\\u70B9\\u7684\\u65F6\\u95F4\\u7684\\u90FD\\u4F1A\\u88AB\\u820D\\u5F03\\uFF0C \\u4ECE\\u5DE6\\u8FB9\\u51FA\\u961F\\u5217\\n        while self.queue and self.queue[0] < t-3000:\\n            self.queue.popleft()\\n            \\n        # \\u628A t \\u52A0\\u5165\\u961F\\u5217\\n        self.queue.append(t)\\n        \\n        # \\u8FD4\\u56DE\\u961F\\u5217\\u7684\\u957F\\u5EA6\\uFF0C\\u5C31\\u662F\\u961F\\u5217\\u4E2Dt\\u4EE5\\u53CAt3000\\u79D2\\u4E4B\\u524D\\u65F6\\u95F4\\u7684\\u603B\\u4E2A\\u6570\\n        return len(self.queue)\\n        \\n\\n",
                "solutionTags": [],
                "code": "class RecentCounter(object):\\n\\n    def __init__(self):\\n        \\n        # \\u7528\\u961F\\u5217\\u601D\\u60F3\\uFF0C\\u5DE6\\u8FB9\\u51FA\\uFF0C\\u53F3\\u8FB9\\u8FDB\\n        self.queue = collections.deque()\\n        \\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        # given a time t, time t-3000 \\u4E3A 3000 \\u6BEB\\u79D2\\u4E4B\\u524D\\u7684\\u65F6\\u95F4\\u70B9\\uFF0C\\u4EFB\\u4F55\\u5C0F\\u4E8E\\u90A3\\u4E2A\\u65F6\\u95F4\\u70B9\\u7684\\u65F6\\u95F4\\u7684\\u90FD\\u4F1A\\u88AB\\u820D\\u5F03\\uFF0C \\u4ECE\\u5DE6\\u8FB9\\u51FA\\u961F\\u5217\\n        while self.queue and self.queue[0] < t-3000:\\n            self.queue.popleft()\\n            \\n        # \\u628A t \\u52A0\\u5165\\u961F\\u5217\\n        self.queue.append(t)\\n        \\n        # \\u8FD4\\u56DE\\u961F\\u5217\\u7684\\u957F\\u5EA6\\uFF0C\\u5C31\\u662F\\u961F\\u5217\\u4E2Dt\\u4EE5\\u53CAt3000\\u79D2\\u4E4B\\u524D\\u65F6\\u95F4\\u7684\\u603B\\u4E2A\\u6570\\n        return len(self.queue)\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3834769,
                "title": "easy-3000-milliseconds",
                "content": "# Intuition\\nThe task requires us to count the number of recent requests within a certain time frame. The first intuition is to keep track of the requests as they come in. However, we only care about the requests that happened in the last 3000 milliseconds. This suggests that we should remove old requests that are no longer within this time frame. A queue data structure is ideal for this because it allows us to easily add new requests at the end and remove old requests from the front.\\n\\n# Approach\\nOur approach is to use a deque (double-ended queue) data structure to store the times of the requests. Each time the \\'ping\\' method is called, we add the new time at the end of the deque. We then remove all times at the front of the deque that are less than \\'t - 3000\\'. The remaining times in the deque are the requests that happened within the last 3000 milliseconds. To get the number of these requests, we simply return the length of the deque.\\n\\n# Complexity\\n- Time complexity: The time complexity of the \\'ping\\' operation is \\\\( O(1) \\\\). Each \\'ping\\' call results in a constant number of operations, which does not depend on the size of \\'t\\' or the number of requests.\\n\\n- Space complexity: The space complexity is \\\\( O(N) \\\\), where \\\\( N \\\\) is the maximum number of \\'pings\\' within a 3000 millisecond time frame. This is because all these \\'pings\\' could potentially be stored in the deque at the same time.\\n\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque() \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: \\n            self.queue.popleft() \\n        return len(self.queue)                           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque() \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: \\n            self.queue.popleft() \\n        return len(self.queue)                           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568692,
                "title": "beating-99-34-python-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/0fcc35b3-81ce-40f3-9246-62cf557178cd_1685203647.425843.png)\\n\\n\\n# Code\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873862,
                "title": "number-of-recent-calls-java",
                "content": "```\\nclass RecentCounter \\n{\\n    /* This is a really straight foreword implementation.  Instantiate a queue.  On each call to ping \\n     * add the new value to the tail of the queue and then eat the values which have timed out (i.e. \\n     * values below t - 3000) from the head of the queue.  Once the queue holds the right data set \\n     * just return it\\'s size.  My guess is most people will do something similar.\\n     *\\n\\t * n.b.  By adding t to the queue first you\\'ll always be assured of having an item which will \\n\\t * cause the while loop to terminate and won\\'t need to do a null check.\\n     */\\n    \\n    private Queue<Integer>      q = new LinkedList<Integer>();\\n\\n    public RecentCounter() {}\\n    \\n    public int ping(int t) \\n    {\\n        q.add( t );\\n        \\n        while( q.peek() < t - 3000 )\\n        {\\n            q.poll();\\n        }\\n        \\n        return q.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter \\n{\\n    /* This is a really straight foreword implementation.  Instantiate a queue.  On each call to ping \\n     * add the new value to the tail of the queue and then eat the values which have timed out (i.e. \\n     * values below t - 3000) from the head of the queue.  Once the queue holds the right data set \\n     * just return it\\'s size.  My guess is most people will do something similar.\\n     *\\n\\t * n.b.  By adding t to the queue first you\\'ll always be assured of having an item which will \\n\\t * cause the while loop to terminate and won\\'t need to do a null check.\\n     */\\n    \\n    private Queue<Integer>      q = new LinkedList<Integer>();\\n\\n    public RecentCounter() {}\\n    \\n    public int ping(int t) \\n    {\\n        q.add( t );\\n        \\n        while( q.peek() < t - 3000 )\\n        {\\n            q.poll();\\n        }\\n        \\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405318,
                "title": "python-solution-using-deque-queue",
                "content": "This is a good example of using deque (double-ended queue) data structure. deque is implemented in Python using doubly-linked list. As a result, it has much better performance compared to Python list for push/pop in both ends, and much worse when it comes to indexing. A few obvious differences between deque and list:\\n1) deque doesn\\'t support slicing;\\n2) deque has a few extra methods on the left side including appendleft(), extendleft() and popleft();\\n3) deque doesn\\'t have a sort() method. \\n\\n```\\nfrom collections import deque \\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n\\t\\t#append first, no need to check empty deque\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: self.queue.popleft()\\n        return len(self.queue)\\n```\\nUsing Python list is also possible, but it takes longer to run. \\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque \\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n\\t\\t#append first, no need to check empty deque\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: self.queue.popleft()\\n        return len(self.queue)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675606,
                "title": "python-99-5-solution-queue-4-lines",
                "content": "Basically, we don\\'t care about the ping that last for more than 3000 seconds. So just pop it out of the queue.\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "Basically, we don\\'t care about the ping that last for more than 3000 seconds. So just pop it out of the queue.\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)",
                "codeTag": "Java"
            },
            {
                "id": 1654544,
                "title": "java-solution-number-of-recent-calls-using-queue",
                "content": "Java Solution:\\n```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    int min;\\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {        \\n        q.offer(t);\\n        min = t-3000;       \\n        while(min>q.peek()){\\n            q.poll();\\n        }\\n        return q.size();        \\n    }\\n}\\n```\\nFeel free to upvote if you like this Solution.\\nHappy Coding!!!\\n[Twitter](https://twitter.com/rohit_mittal17)\\n[GitHub](https://github.com/rohitm17)\\n[Medium](https://medium.com/@rohitm17)",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    int min;\\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {        \\n        q.offer(t);\\n        min = t-3000;       \\n        while(min>q.peek()){\\n            q.poll();\\n        }\\n        return q.size();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873283,
                "title": "number-of-recent-calls-python-98-using-queue",
                "content": "```\\ncompare least recent calls to t-3000, if less then pop calls\\ndeque over list because popleft() is O(1) time over list pop(0) O(n) time\\n```\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n        return len(self.q)\\n```",
                "solutionTags": [],
                "code": "```\\ncompare least recent calls to t-3000, if less then pop calls\\ndeque over list because popleft() is O(1) time over list pop(0) O(n) time\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873253,
                "title": "number-of-recent-calls-c-using-queue-98",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        int start=t-3000;\\n        int end=t;\\n        while(q.front()<start){\\n            q.pop();\\n        }\\n        return q.size(); \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        int start=t-3000;\\n        int end=t;\\n        while(q.front()<start){\\n            q.pop();\\n        }\\n        return q.size(); \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492668,
                "title": "intuitive-javascript-solution",
                "content": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.queue.push(t);\\n    // keep pings within 3000 from the latest ping \\n    while(this.queue[0] < t - 3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.queue.push(t);\\n    // keep pings within 3000 from the latest ping \\n    while(this.queue[0] < t - 3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3118441,
                "title": "python-simple-queue-solution-beats-97",
                "content": "# Code\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.s = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.s and t - self.s[0] > 3000:\\n            self.s.pop(0)  # remove 1st el if it\\'s 3000+ away from t\\n        self.s.append(t)\\n        return len(self.s) \\n\\n```\\n\\nupdate:\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-04-03 \\u0432 13.55.16.png](https://assets.leetcode.com/users/images/5d6980a6-d23c-483e-8ce1-b6ab49b2860a_1680519361.3573725.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.s = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.s and t - self.s[0] > 3000:\\n            self.s.pop(0)  # remove 1st el if it\\'s 3000+ away from t\\n        self.s.append(t)\\n        return len(self.s) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178137,
                "title": "java-smaller-queue-solution",
                "content": "# Please Upvote If You Find This Helpful\\n```\\nclass RecentCounter {\\n    private Queue<Integer> queue;\\n    public RecentCounter() {\\n        this.queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < t - 3000) queue.remove();\\n        return queue.size();\\n    }\\n}\\n```\\n# Please Upvote If You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    private Queue<Integer> queue;\\n    public RecentCounter() {\\n        this.queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < t - 3000) queue.remove();\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880478,
                "title": "python-binary-search-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self): \\n        self.requests = []\\n\\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        left = 0\\n        right = len(self.requests)\\n        \\n        while left < right:\\n            mid = int((left + right) / 2)\\n            if self.requests[mid] >= (self.requests[-1] - 3000):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return len(self.requests) - left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self): \\n        self.requests = []\\n\\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        left = 0\\n        right = len(self.requests)\\n        \\n        while left < right:\\n            mid = int((left + right) / 2)\\n            if self.requests[mid] >= (self.requests[-1] - 3000):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return len(self.requests) - left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875210,
                "title": "easiest-possible-explanation-using-min-heap",
                "content": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n    public RecentCounter() {\\n        pq = new PriorityQueue<>((a,b)-> a-b);\\n    }\\n    \\n    public int ping(int t) {\\n        if(!pq.isEmpty()){\\n            int min = t-3000;\\n\\t\\t\\t//recursively pop elements from top of MinHeap till top element is greater than t-3000\\n            while(!pq.isEmpty() && pq.peek() < min){\\n                pq.poll();\\n            }\\n        }\\n        pq.offer(t);\\n        return pq.size();\\n    }\\n}\\n```\\n\\nThe idea above is to somehow store t values, from current_time to current_time - 3000.\\nHow can we achieve that, one of the easiset ways is to use Min Heap, so that the mimimum element is stored at top/root.\\nEach time we get a ping, we check the current top/root, if its lesser than remove elements from Min Heap recursively till top/root is greater than current_time-3000.\\nThis way at any point of time we just have the required elements in the min-heap.\\n\\nTime complexity: O(n * log(n)) Each insert, and reordering after poll takes O(log(n)) time, but while trying to empty the minheap recursively we might have to do it for n elements, hence n * log(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n    public RecentCounter() {\\n        pq = new PriorityQueue<>((a,b)-> a-b);\\n    }\\n    \\n    public int ping(int t) {\\n        if(!pq.isEmpty()){\\n            int min = t-3000;\\n\\t\\t\\t//recursively pop elements from top of MinHeap till top element is greater than t-3000\\n            while(!pq.isEmpty() && pq.peek() < min){\\n                pq.poll();\\n            }\\n        }\\n        pq.offer(t);\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874696,
                "title": "just-another-c-solution-using-bitset-no-queues",
                "content": "I assume everyone understand the queue solution. With this post I just want to show that `there are always other possibilities`\\n\\nSo we want to record all the time points in the past 3001 ms. Instead of using a vector, which is very inefficient when moving its elements, we use a bitset.\\nWhen a new call comes in, all we need to do is shift all the bits to the left by `this time - previous time`, and mark the right most bit `1`, then return the number of 1 bits.\\n\\nFurther thoughts: if the time range goes very huge, the shift operation may become slow. However, it still beats the queue method on memory usage, and runs within reasonable time frame.\\n(I tried to set the time range to 1,000,000,000 instead of 3000, it still runs. The queue method may be faster _some times_, but it is just unrealistic for the queue to hold that many of nodes)\\n\\n```cpp\\nclass RecentCounter {\\npublic:\\n    RecentCounter() : m_calls(0), m_last(0) {\\n    }\\n    \\n    int ping(int t) {\\n        m_calls <<= t - m_last;\\n        m_calls.set(0);\\n        m_last = t;\\n        return m_calls.count();\\n    }\\n    \\nprivate:\\n    bitset<3001> m_calls;\\n    int m_last; // time of previous ping()\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass RecentCounter {\\npublic:\\n    RecentCounter() : m_calls(0), m_last(0) {\\n    }\\n    \\n    int ping(int t) {\\n        m_calls <<= t - m_last;\\n        m_calls.set(0);\\n        m_last = t;\\n        return m_calls.count();\\n    }\\n    \\nprivate:\\n    bitset<3001> m_calls;\\n    int m_last; // time of previous ping()\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873222,
                "title": "c-super-simple-easy-and-short-solution-o-1-time-space",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        calls.push_back(t);\\n        while (calls[0] < t - 3000)\\n            calls.erase(calls.begin());\\n        return calls.size();\\n    }\\n    \\nprivate:\\n    vector<int> calls;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        calls.push_back(t);\\n        while (calls[0] < t - 3000)\\n            calls.erase(calls.begin());\\n        return calls.size();\\n    }\\n    \\nprivate:\\n    vector<int> calls;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726473,
                "title": "go",
                "content": "Slice (as queue) implementation: (Ping() is O(N))\\n```\\ntype RecentCounter struct {\\n    q []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.q = append(this.q, t)\\n    for i, val := range this.q {\\n        if val >= t - 3000 {\\n            this.q = this.q[i:]\\n            break\\n        }\\n    }\\n    return len(this.q)\\n}\\n```\\n\\nBinary Search: (Ping() is O(logN))\\n```\\ntype RecentCounter struct {\\n    a []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.a = append(this.a, t)\\n    \\n    idx := binarySearch(this.a, t - 3000)\\n    \\n    return len(this.a) - idx\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    lo, hi := 0, len(arr)-1\\n    \\n    for lo <= hi {\\n        mid := (lo + hi) / 2\\n        if arr[mid] > target {\\n            hi = mid - 1\\n        } else if arr[mid] < target {\\n            lo = mid + 1\\n        } else {\\n            return mid\\n        }\\n    }\\n    \\n    return lo\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RecentCounter struct {\\n    q []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.q = append(this.q, t)\\n    for i, val := range this.q {\\n        if val >= t - 3000 {\\n            this.q = this.q[i:]\\n            break\\n        }\\n    }\\n    return len(this.q)\\n}\\n```\n```\\ntype RecentCounter struct {\\n    a []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.a = append(this.a, t)\\n    \\n    idx := binarySearch(this.a, t - 3000)\\n    \\n    return len(this.a) - idx\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    lo, hi := 0, len(arr)-1\\n    \\n    for lo <= hi {\\n        mid := (lo + hi) / 2\\n        if arr[mid] > target {\\n            hi = mid - 1\\n        } else if arr[mid] < target {\\n            lo = mid + 1\\n        } else {\\n            return mid\\n        }\\n    }\\n    \\n    return lo\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490723,
                "title": "rust-24-ms",
                "content": "```\\nuse std::borrow::BorrowMut;\\nuse std::collections::VecDeque;\\n\\nstruct RecentCounter {\\n    queue: VecDeque<i32>,\\n}\\n\\nimpl RecentCounter {\\n    fn new() -> Self {\\n        RecentCounter {\\n            queue: VecDeque::new(),\\n        }\\n    }\\n\\n    fn ping(&mut self, t: i32) -> i32 {\\n        let q = self.queue.borrow_mut();\\n        q.push_back(t);\\n        while let Some(value) = q.front() {\\n            if *value < t - 3000 {\\n                q.pop_front();\\n            } else {\\n                break;\\n            }\\n        }\\n        q.len() as i32\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nuse std::borrow::BorrowMut;\\nuse std::collections::VecDeque;\\n\\nstruct RecentCounter {\\n    queue: VecDeque<i32>,\\n}\\n\\nimpl RecentCounter {\\n    fn new() -> Self {\\n        RecentCounter {\\n            queue: VecDeque::new(),\\n        }\\n    }\\n\\n    fn ping(&mut self, t: i32) -> i32 {\\n        let q = self.queue.borrow_mut();\\n        q.push_back(t);\\n        while let Some(value) = q.front() {\\n            if *value < t - 3000 {\\n                q.pop_front();\\n            } else {\\n                break;\\n            }\\n        }\\n        q.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419958,
                "title": "simple-java-solution-w-queue-comments",
                "content": "```java\\nclass RecentCounter {\\n    \\n    //primary data structure\\n    Queue<Integer> queue;\\n\\n    public RecentCounter() {\\n        //initialize our queue\\n        queue = new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        //add current ping to queue\\n        queue.offer(t);\\n        \\n        //keep removing from queue while more than 3000ms ago\\n        while (!queue.isEmpty() && t - queue.peek() > 3000) {\\n            //pop first in queue\\n            queue.poll();\\n        }\\n        \\n        //just return size of our queue (every ping here is within 3000 ms)\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```java\\nclass RecentCounter {\\n    \\n    //primary data structure\\n    Queue<Integer> queue;\\n\\n    public RecentCounter() {\\n        //initialize our queue\\n        queue = new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        //add current ping to queue\\n        queue.offer(t);\\n        \\n        //keep removing from queue while more than 3000ms ago\\n        while (!queue.isEmpty() && t - queue.peek() > 3000) {\\n            //pop first in queue\\n            queue.poll();\\n        }\\n        \\n        //just return size of our queue (every ping here is within 3000 ms)\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189291,
                "title": "simple-javascript-solution-3-lines",
                "content": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n   this.queue.push(t);\\n    while(this.queue.length && this.queue[0] < t-3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = Object.create(RecentCounter).createNew()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n   this.queue.push(t);\\n    while(this.queue.length && this.queue[0] < t-3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = Object.create(RecentCounter).createNew()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749681,
                "title": "c-very-simple-queue",
                "content": "# Code\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        int limit = t - 3000;\\n        Q.push(t);\\n        while (Q.front() < limit) Q.pop();\\n        return Q.size();\\n    }\\n\\nprivate:\\n    queue<int> Q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        int limit = t - 3000;\\n        Q.push(t);\\n        while (Q.front() < limit) Q.pop();\\n        return Q.size();\\n    }\\n\\nprivate:\\n    queue<int> Q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432422,
                "title": "kotlin-style-short-solution",
                "content": "```\\nclass RecentCounter() {\\n\\n    val list = mutableListOf<Int>()\\n\\n    fun ping(t: Int): Int {\\n        list.add(t)\\n        return list.count { it in t - 3000..t }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass RecentCounter() {\\n\\n    val list = mutableListOf<Int>()\\n\\n    fun ping(t: Int): Int {\\n        list.add(t)\\n        return list.count { it in t - 3000..t }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126484,
                "title": "c-solution-using-only-one-queue-short-simple",
                "content": "**Code:**\\n\\n```\\nclass RecentCounter\\n{\\npublic:\\n    queue<int> q;\\n\\n    RecentCounter()\\n    {\\n    }\\n\\n    int ping(int t)\\n    {\\n        q.push(t);\\n        while (q.front() < t - 3000)\\n        {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter\\n{\\npublic:\\n    queue<int> q;\\n\\n    RecentCounter()\\n    {\\n    }\\n\\n    int ping(int t)\\n    {\\n        q.push(t);\\n        while (q.front() < t - 3000)\\n        {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1316432,
                "title": "smallest-solution-in-c-ever-with-funny-explaination-3-line-code",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    priority_queue<int, vector<int>,greater<int>> res;\\n    RecentCounter() {}    //vella Constructor \\n    int ping(int t) {\\n        res.push(t);\\n        while(t-res.top() >3000)   res.pop();    //Coz difference cant be greater than 3000  \\n        return res.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    priority_queue<int, vector<int>,greater<int>> res;\\n    RecentCounter() {}    //vella Constructor \\n    int ping(int t) {\\n        res.push(t);\\n        while(t-res.top() >3000)   res.pop();    //Coz difference cant be greater than 3000  \\n        return res.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013108,
                "title": "c-simple-4-line-solution-faster-than-100-with-queue",
                "content": "Just four lines are needed for `ping`, and the constructor is not needed at all: On every call, add the current time `t` and remove all times greater smaller than `t-3000` from the back of the queue.\\n\\n```\\nclass RecentCounter {\\n    queue<int> recents;\\npublic:\\n    int ping(int t) {\\n        recents.push(t);\\n        while(recents.front() < (t - 3000))\\n            recents.pop();\\n        return recents.size();\\n    }\\n};\\n```\\n\\nFast and low memory:\\n![image](https://assets.leetcode.com/users/images/bd1c96b7-c355-4c96-a0f5-4d4395efdc3c_1610455821.3957345.png)\\n",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue<int> recents;\\npublic:\\n    int ping(int t) {\\n        recents.push(t);\\n        while(recents.front() < (t - 3000))\\n            recents.pop();\\n        return recents.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874262,
                "title": "c-2-pointers-binary-search-solution-explained-100-time-new-record-10-memory",
                "content": "As usual, I decided to sacrifice as much as possible in order to gain top speed.\\n\\nTo do so, I eschewed having any constructor and instead just set 3 class variables:\\n* `store`, an array of `10000` ints;\\n* `last` and `first`, to keep track of how extended is our window of elements, both initialised to `0`.\\n\\ni then put all the logic just in `ping`:\\n* every new element `t` is added to `store` in the `last` position, increasing `last` with the postfix operator;\\n* `first` is updated doing a binary search on the `first - last` range for any value smaller than `t - 3000`, as per specs;\\n* we return `last - first` and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass RecentCounter {\\npublic:\\n    int store[10000], last = 0, first = 0;    \\n    int ping(int t) {\\n        store[last++] = t;\\n        first = lower_bound(store + first, store + last, t - 3000) - store;\\n        return last - first;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/176d0720-7a6b-482d-bf9e-e731b730dd4a_1601588934.2631395.png)\\n\\nThe further brag:\\n![image](https://assets.leetcode.com/users/images/558b0b42-9992-49f3-ae42-1481013f6dfa_1601589054.0014238.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass RecentCounter {\\npublic:\\n    int store[10000], last = 0, first = 0;    \\n    int ping(int t) {\\n        store[last++] = t;\\n        first = lower_bound(store + first, store + last, t - 3000) - store;\\n        return last - first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873463,
                "title": "easy-python-3-solution-beginner-friendly",
                "content": "class RecentCounter:\\n\\n    def __init__(self):\\n\\t\\t#a list to store the request calls\\n        self.req=[]\\n    def ping(self, t: int) -> int:\\n        self.req.append(t)\\n\\t\\t#loop to pop out the requests which are out of time range of 300 milisecond\\n        while self.req[0]<t-3000:\\n            self.req.pop(0)\\n        return len(self.req)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)``",
                "solutionTags": [],
                "code": "class RecentCounter:\\n\\n    def __init__(self):\\n\\t\\t#a list to store the request calls\\n        self.req=[]\\n    def ping(self, t: int) -> int:\\n        self.req.append(t)\\n\\t\\t#loop to pop out the requests which are out of time range of 300 milisecond\\n        while self.req[0]<t-3000:\\n            self.req.pop(0)\\n        return len(self.req)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)``",
                "codeTag": "Java"
            },
            {
                "id": 743058,
                "title": "in-rust",
                "content": "```\\nstruct RecentCounter {\\n    pings: Vec<i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        RecentCounter { pings: vec!() }\\n    }\\n    \\n    fn ping(&mut self, t: i32) -> i32 {\\n        self.pings.push(t);\\n        return match self.pings.binary_search(&(t - 3000)) {\\n            Ok(i) => (self.pings.len() - i) as i32,\\n            Err(i) => (self.pings.len() - i) as i32,\\n        };\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * let obj = RecentCounter::new();\\n * let ret_1: i32 = obj.ping(t);\\n */\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct RecentCounter {\\n    pings: Vec<i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        RecentCounter { pings: vec!() }\\n    }\\n    \\n    fn ping(&mut self, t: i32) -> i32 {\\n        self.pings.push(t);\\n        return match self.pings.binary_search(&(t - 3000)) {\\n            Ok(i) => (self.pings.len() - i) as i32,\\n            Err(i) => (self.pings.len() - i) as i32,\\n        };\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * let obj = RecentCounter::new();\\n * let ret_1: i32 = obj.ping(t);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 636175,
                "title": "python-simple-solution-quick-explanation",
                "content": "**Quick Explanation of the Question:**\\n\\nThis question could probably be written a little more clearly so I will leave a few lines here for those who may find it helpful.  The question is saying that it will do the following:\\n\\n    In [1]: temp = RecentCounter()\\n\\tIn [2]: temp.ping(1)\\n\\tIn [3]: temp.ping(100)\\n\\tIn [4]: temp.ping(3001)\\n\\tIn [5]: temp.ping(3002)\\n\\nEverytime it calls ping, you get an input value t (the time that has elapsed since temp was created).  Your job is to return how many ping times there are between the given t and t - 3000 ms inclusive.  \\n\\t\\n\\n**Solution:**\\n\\nStore all times in a doubly ended queue (deque) so that new times can be appended to the end of the queue and removed from the beginning of the queue in constant time.  \\n\\nThe former to append the current time (t) every time ping is called.  \\n\\nThe latter to remove times less than t-3000 ms before calculating the result.\\n\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.count=0\\n        self.times = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.times.append(t)\\n        while self.times[0] < t-3000:\\n            self.times.popleft()\\n        return len(self.times)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.count=0\\n        self.times = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.times.append(t)\\n        while self.times[0] < t-3000:\\n            self.times.popleft()\\n        return len(self.times)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239143,
                "title": "c-solution",
                "content": "```\\n#define MAX_SIZE 10000\\n\\ntypedef struct {\\n    int* pingHistory;\\n    int head;\\n    int tail; \\n} RecentCounter;\\n\\nRecentCounter* recentCounterCreate() {\\n    RecentCounter* obj = malloc(sizeof(RecentCounter));\\n    obj -> pingHistory = calloc(10000, sizeof(int));\\n    obj -> head = 0;\\n    obj -> tail = 0;\\n    return obj;\\n}\\n\\nint recentCounterPing(RecentCounter* obj, int t) {\\n    obj -> pingHistory[obj->head++] = t;\\n    \\n    for(; obj->tail < obj -> head; obj->tail++)\\n    {\\n        if((t-3000) <= obj -> pingHistory[obj->tail])\\n        {\\n            break;\\n        }\\n    }\\n    return obj->head-obj->tail;\\n}\\n\\nvoid recentCounterFree(RecentCounter* obj) {\\n    free(obj->pingHistory);\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_SIZE 10000\\n\\ntypedef struct {\\n    int* pingHistory;\\n    int head;\\n    int tail; \\n} RecentCounter;\\n\\nRecentCounter* recentCounterCreate() {\\n    RecentCounter* obj = malloc(sizeof(RecentCounter));\\n    obj -> pingHistory = calloc(10000, sizeof(int));\\n    obj -> head = 0;\\n    obj -> tail = 0;\\n    return obj;\\n}\\n\\nint recentCounterPing(RecentCounter* obj, int t) {\\n    obj -> pingHistory[obj->head++] = t;\\n    \\n    for(; obj->tail < obj -> head; obj->tail++)\\n    {\\n        if((t-3000) <= obj -> pingHistory[obj->tail])\\n        {\\n            break;\\n        }\\n    }\\n    return obj->head-obj->tail;\\n}\\n\\nvoid recentCounterFree(RecentCounter* obj) {\\n    free(obj->pingHistory);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4038917,
                "title": "go-solution-easy-explanation-o-n-time-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe maintain a queue of timestamps for incoming requests. When a new request comes in, we add its timestamp to the queue. We then remove timestamps from the front of the queue that are outside the 3000 milliseconds window. The length of the queue at any point represents the number of requests within the window.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We use a queue (implemented as a slice) to store timestamps.\\n2. In the Ping method, we append the current timestamp to the queue.\\n3. We iterate through the front of the queue and remove timestamps that are older than t - 3000.\\n4. The length of the queue represents the number of requests within the window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    - The Constructor method has a time complexity of O(1).\\n    - The Ping method has a time complexity of O(N), where N is the number of requests within the 3000 milliseconds window. In practice, N is bounded by the number of calls to Ping.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    - The space complexity is O(N), where N is the number of requests within the 3000 milliseconds window.\\n\\n# Code\\n```\\ntype RecentCounter struct {\\n    requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    // Add the current timestamp to the queue\\n    this.requests = append(this.requests, t)\\n    \\n    // Remove timestamps that are outside the 3000 milliseconds window\\n    for this.requests[0] < t-3000 {\\n        this.requests = this.requests[1:]\\n    }\\n    \\n    // Return the number of requests within the window\\n    return len(this.requests)\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RecentCounter struct {\\n    requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    // Add the current timestamp to the queue\\n    this.requests = append(this.requests, t)\\n    \\n    // Remove timestamps that are outside the 3000 milliseconds window\\n    for this.requests[0] < t-3000 {\\n        this.requests = this.requests[1:]\\n    }\\n    \\n    // Return the number of requests within the window\\n    return len(this.requests)\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Ping(t);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965562,
                "title": "19ms-beats-81-34-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo Need to use array or arraylist.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just have to add new entry and check from start if any out of range element is there ? then pop it until whole queue is in range . then return queue size. It\\'s simple , In ArrayList we have to traverse it in every function call but here we are just traversing only that much which is needed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n\\n    Queue<Integer> q = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n\\n        int s = t-3000;\\n\\n        while(q.peek() < s)\\n        {\\n            q.poll();\\n        }\\n\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    Queue<Integer> q = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n\\n        int s = t-3000;\\n\\n        while(q.peek() < s)\\n        {\\n            q.poll();\\n        }\\n\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666594,
                "title": "python-solution-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n\\n# Code\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.all = []\\n\\n    def ping(self, t: int) -> int:\\n        self.all.append(t)\\n        min_time = t-3000\\n        while self.all[0] < min_time:\\n            self.all.pop(0)\\n        return len(self.all)    \\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.all = []\\n\\n    def ping(self, t: int) -> int:\\n        self.all.append(t)\\n        min_time = t-3000\\n        while self.all[0] < min_time:\\n            self.all.pop(0)\\n        return len(self.all)    \\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647168,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q=new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        q.add(t);\\n        int min=t-3000;\\n        while(q.peek()<min){\\n            q.remove();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q=new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        q.add(t);\\n        int min=t-3000;\\n        while(q.peek()<min){\\n            q.remove();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548121,
                "title": "easy-java-solution-with-deque-26ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    private LinkedList<Integer> pingList;\\n\\n    public RecentCounter() {\\n        this.pingList = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        pingList.addLast(t);\\n        while (t - 3000 > pingList.getFirst()) {\\n            pingList.removeFirst();\\n        }\\n        return pingList.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    private LinkedList<Integer> pingList;\\n\\n    public RecentCounter() {\\n        this.pingList = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        pingList.addLast(t);\\n        while (t - 3000 > pingList.getFirst()) {\\n            pingList.removeFirst();\\n        }\\n        return pingList.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521765,
                "title": "solution",
                "content": "```C++ []\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {   \\n    }\\n    int ping(int t) {\\n       q.push(t);\\n       while(q.front()<t-3000){\\n           q.pop();\\n       }\\n       return q.size(); \\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while t - 3000 > self.queue[0]:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```\\n\\n```Java []\\nclass RecentCounter {\\n    LinkedList<Integer> swin;\\n    public RecentCounter() {\\n        swin = new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        swin.addLast(t);\\n        while (swin.getFirst() < t - 3000) swin.removeFirst();\\n        return swin.size();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {   \\n    }\\n    int ping(int t) {\\n       q.push(t);\\n       while(q.front()<t-3000){\\n           q.pop();\\n       }\\n       return q.size(); \\n    }\\n};\\n```\n```Python3 []\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while t - 3000 > self.queue[0]:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```\n```Java []\\nclass RecentCounter {\\n    LinkedList<Integer> swin;\\n    public RecentCounter() {\\n        swin = new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        swin.addLast(t);\\n        while (swin.getFirst() < t - 3000) swin.removeFirst();\\n        return swin.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513494,
                "title": "python-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and t - self.queue[0] > 3000:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        \\n        return len(self.queue)\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and t - self.queue[0] > 3000:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        \\n        return len(self.queue)\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388299,
                "title": "go-solution-using-binary-search",
                "content": "```\\ntype RecentCounter struct {\\n        requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n        return RecentCounter{requests: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n        this.requests = append(this.requests, t)\\n        min := t - 3000\\n        i := binarySearch(this.requests, min)\\n        return len(this.requests) - i\\n}\\n\\nfunc binarySearch(nums []int, target int) int {\\n        l, r := 0, len(nums)-1\\n        for l <= r {\\n                mid := (l + r) / 2\\n                if num := nums[mid]; num == target {\\n                        return mid\\n                } else if num < target {\\n                        l = mid + 1\\n                } else {\\n                        r = mid - 1\\n                }\\n        }\\n\\n        return l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\ntype RecentCounter struct {\\n        requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n        return RecentCounter{requests: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n        this.requests = append(this.requests, t)\\n        min := t - 3000\\n        i := binarySearch(this.requests, min)\\n        return len(this.requests) - i\\n}\\n\\nfunc binarySearch(nums []int, target int) int {\\n        l, r := 0, len(nums)-1\\n        for l <= r {\\n                mid := (l + r) / 2\\n                if num := nums[mid]; num == target {\\n                        return mid\\n                } else if num < target {\\n                        l = mid + 1\\n                } else {\\n                        r = mid - 1\\n                }\\n        }\\n\\n        return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382418,
                "title": "100-runtime-typescript-javascript-solution",
                "content": "\\n# TypeScript Code\\n```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t: number): number {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```\\n\\n\\n# JavaScript Code\\n```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t) {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t: number): number {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857815,
                "title": "smallest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < t - 3000){\\n            q.pop();\\n        }\\n        \\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < t - 3000){\\n            q.pop();\\n        }\\n        \\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267307,
                "title": "python-deque-o-1-99-faster",
                "content": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.que = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.que.append(t)\\n        while self.que and self.que[0] < t - 3000:\\n            self.que.popleft()\\n        return len(self.que)",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.que = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.que.append(t)\\n        while self.que and self.que[0] < t - 3000:\\n            self.que.popleft()\\n        return len(self.que)",
                "codeTag": "Java"
            },
            {
                "id": 2231165,
                "title": "c-simplest-with-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue <int> qu;\\n  \\n    RecentCounter() { \\n    }\\n\\t\\n    int ping(int t) {\\n        qu.push(t); //insert ping time in queue\\n        while(qu.front() < t-3000) qu.pop(); //remove all pings before 3000ms of current time\\n        return qu.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue <int> qu;\\n  \\n    RecentCounter() { \\n    }\\n\\t\\n    int ping(int t) {\\n        qu.push(t); //insert ping time in queue\\n        while(qu.front() < t-3000) qu.pop(); //remove all pings before 3000ms of current time\\n        return qu.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238452,
                "title": "c-5-lines-of-code",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while ( q.front() < t - 3000 )      q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while ( q.front() < t - 3000 )      q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158707,
                "title": "easy-clear-100-00-of-javascript-online-submissions",
                "content": "```\\nvar RecentCounter = function() {\\n    this.oldCalls = [];    \\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.oldCalls.push(t);    \\n    \\n    while(this.oldCalls[0] < (t-3000))            \\n        this.oldCalls.shift();            \\n    \\n    return this.oldCalls.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RecentCounter = function() {\\n    this.oldCalls = [];    \\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.oldCalls.push(t);    \\n    \\n    while(this.oldCalls[0] < (t-3000))            \\n        this.oldCalls.shift();            \\n    \\n    return this.oldCalls.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979754,
                "title": "simple-java-solution-queue-o-n",
                "content": "```\\nclass RecentCounter {\\nprivate Queue<Integer> queue;\\n    public RecentCounter() {\\n       queue = new LinkedList<>(); \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\nprivate Queue<Integer> queue;\\n    public RecentCounter() {\\n       queue = new LinkedList<>(); \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949129,
                "title": "python-deque-o-1-time-o-1-space",
                "content": "1.  Consider the worst case in which t is extremely large i.e >10^6,  it takes O(3000) to iterate over the past 3000 elements, which is still a constant.\\n2.  Since we only return the size of deque, it takes O(1) space.\\n```\\nfrom collections import deque\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        low_limit=self.q[-1]-3000\\n        while self.q and self.q[0]<low_limit:\\n              self.q.popleft()\\n        return len(self.q)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        low_limit=self.q[-1]-3000\\n        while self.q and self.q[0]<low_limit:\\n              self.q.popleft()\\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914416,
                "title": "easy-python-using-queue",
                "content": "class RecentCounter:\\n\\n    def __init__(self):\\n        self.queue=list()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (self.queue[0] < t-3000):\\n            self.queue.pop(0)\\n        return len(self.queue)",
                "solutionTags": [],
                "code": "class RecentCounter:\\n\\n    def __init__(self):\\n        self.queue=list()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (self.queue[0] < t-3000):\\n            self.queue.pop(0)\\n        return len(self.queue)",
                "codeTag": "Java"
            },
            {
                "id": 874190,
                "title": "kotlin-with-an-optimised-binary-search",
                "content": "I started out pretty much with a fold operation, then realised the solution could be done with a binary search, as will follow shortly.\\nHowever, there is a further time optimisation that can be made: I know that my next boundary will never be any further to the left than my last left pointer in BS, so after each search I can cache the position of the left pointer so that I don\\'t have to start from zero every time:\\n\\n```\\nclass RecentCounter(\\n  var recentRequests: Int = 0,\\n  var leftCache: Int = 0\\n) {\\n    private var allRequests = mutableListOf<Int>()\\n    fun ping(t: Int): Int {\\n        allRequests.add(t)\\n        var l = leftCache; var r = allRequests.size - 1\\n        while (l < r) {\\n          val mid = l + (r - l) / 2\\n          if (allRequests[mid] < t - 3000) l = mid + 1\\n          else r = mid\\n        }\\n        leftCache = l\\n        return allRequests.size - l\\n    }\\n}\\n```\\n\\nNot sure why it\\'s necessary to keep a `recentRequests` count though. A bit pointless I think...",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter(\\n  var recentRequests: Int = 0,\\n  var leftCache: Int = 0\\n) {\\n    private var allRequests = mutableListOf<Int>()\\n    fun ping(t: Int): Int {\\n        allRequests.add(t)\\n        var l = leftCache; var r = allRequests.size - 1\\n        while (l < r) {\\n          val mid = l + (r - l) / 2\\n          if (allRequests[mid] < t - 3000) l = mid + 1\\n          else r = mid\\n        }\\n        leftCache = l\\n        return allRequests.size - l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873740,
                "title": "java-solution-with-a-circular-array-that-beats-100-submissions",
                "content": "The official solution recommends a dynamic data structure, which in situations like this, is a bit of an overkill, due to many unnecessary additions and removals of objects on the heap. A faster and more memory friendly approach is to leverage a static circular buffer of a fixed size, as shown below. You might consider this technique whenever you need to track some fixed number of records.\\n```\\nclass RecentCounter {\\n    // The extra padding is added for easier calculation of actual window size.\\n    private static final int WINDOW_SIZE = 3002;\\n    \\n    private final int[] timestamps = new int[WINDOW_SIZE];\\n    private int start, end;\\n\\n    public int ping(int t) {\\n        timestamps[end] = t;\\n        end = (end + 1) % WINDOW_SIZE;        \\n        // Prune away old entries from the window.\\n        while (t - timestamps[start] >= WINDOW_SIZE - 1) start = (start + 1) % WINDOW_SIZE;\\n        return start < end ? end - start : WINDOW_SIZE - start + end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RecentCounter {\\n    // The extra padding is added for easier calculation of actual window size.\\n    private static final int WINDOW_SIZE = 3002;\\n    \\n    private final int[] timestamps = new int[WINDOW_SIZE];\\n    private int start, end;\\n\\n    public int ping(int t) {\\n        timestamps[end] = t;\\n        end = (end + 1) % WINDOW_SIZE;        \\n        // Prune away old entries from the window.\\n        while (t - timestamps[start] >= WINDOW_SIZE - 1) start = (start + 1) % WINDOW_SIZE;\\n        return start < end ? end - start : WINDOW_SIZE - start + end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873449,
                "title": "cpp-solution-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n      queue<int> q;\\n      RecentCounter() {\\n      }\\n      int ping(int t) {\\n         q.push(t);\\n\\t     while(q.front() < t-3000)\\n             q.pop();\\n         return q.size();\\n      }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n      queue<int> q;\\n      RecentCounter() {\\n      }\\n      int ping(int t) {\\n         q.push(t);\\n\\t     while(q.front() < t-3000)\\n             q.pop();\\n         return q.size();\\n      }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873291,
                "title": "c-solution-with-lower-bound-easy-to-understand",
                "content": "Do <b>Upvote</b> this solution, if you like it. :)\\nIf you have any suggestions on how to improve this solution further, then feel free to comment down below.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    vector<int> requests;\\n    RecentCounter() {\\n        requests.clear();\\n    }\\n    \\n    int ping(int t) {\\n        requests.push_back(t);\\n        int num = 0;\\n        \\n        if(requests.size() == 1)\\n            return 1;\\n        else {\\n            int first = lower_bound(requests.begin(), requests.end(), t - 3000) - requests.begin();\\n            int second = lower_bound(requests.begin(), requests.end(), t) - requests.begin();\\n            cout<<second<<\" \"<<first<<endl;\\n            return second - first + 1;\\n        }\\n    }\\n};\\n\\n```\\n<b> Happy Coding :) </b>",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> requests;\\n    RecentCounter() {\\n        requests.clear();\\n    }\\n    \\n    int ping(int t) {\\n        requests.push_back(t);\\n        int num = 0;\\n        \\n        if(requests.size() == 1)\\n            return 1;\\n        else {\\n            int first = lower_bound(requests.begin(), requests.end(), t - 3000) - requests.begin();\\n            int second = lower_bound(requests.begin(), requests.end(), t) - requests.begin();\\n            cout<<second<<\" \"<<first<<endl;\\n            return second - first + 1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 873273,
                "title": "in-java",
                "content": "```\\nclass RecentCounter {\\n    ArrayList<Integer> requests = new ArrayList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        this.requests.add(t);\\n        int leftRange = t-3000;\\n        int rightRange = t;\\n        int count=0;\\n        for(Integer num:this.requests){\\n            if(num>=leftRange && num<=rightRange){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    ArrayList<Integer> requests = new ArrayList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        this.requests.add(t);\\n        int leftRange = t-3000;\\n        int rightRange = t;\\n        int count=0;\\n        for(Integer num:this.requests){\\n            if(num>=leftRange && num<=rightRange){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873207,
                "title": "number-of-recent-calls-c-10-lines",
                "content": "Keep a window for most recent pings that are at most 3000 ms apart\\n```\\nclass RecentCounter {\\n    queue<int> pings_;\\npublic:    \\n    int ping(int t) {\\n        pings_.push(t);\\n        while (t - pings_.front() > 3000)\\n            pings_.pop();        \\n        return pings_.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue<int> pings_;\\npublic:    \\n    int ping(int t) {\\n        pings_.push(t);\\n        while (t - pings_.front() > 3000)\\n            pings_.pop();        \\n        return pings_.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515296,
                "title": "python-queue",
                "content": "```python\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n\\n        while(self.queue and self.queue[0] < t - 3000):\\n            self.queue.popleft()\\n            \\n        return len(self.queue)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```python\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n\\n        while(self.queue and self.queue[0] < t - 3000):\\n            self.queue.popleft()\\n            \\n        return len(self.queue)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490516,
                "title": "binary-search-solution-using-ruby",
                "content": "```\\nclass RecentCounter\\n    def initialize()\\n        @pings = []\\n    end\\n\\n    def ping(t)\\n        @pings << t\\n        @pings.slice!(0 ... @pings.bsearch_index {|x| x >= t-3000})\\n        @pings.size\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\nclass RecentCounter\\n    def initialize()\\n        @pings = []\\n    end\\n\\n    def ping(t)\\n        @pings << t\\n        @pings.slice!(0 ... @pings.bsearch_index {|x| x >= t-3000})\\n        @pings.size\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479320,
                "title": "java-simple-solution-by-using-queue-queue-is-acted-as-a-sliding-window-for-maintaing-the-interval",
                "content": "```\\nclass RecentCounter {\\n    //inclusive [t-3000,3000]\\n    Queue<Integer>queue;\\n    public RecentCounter() {\\n        queue=new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size()>0&&queue.peek()<(t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    //inclusive [t-3000,3000]\\n    Queue<Integer>queue;\\n    public RecentCounter() {\\n        queue=new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size()>0&&queue.peek()<(t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453924,
                "title": "python-3-beats-98",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self): self.H = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.H.append(t)\\n        while self.H[0] < t - 3000: self.H.popleft()\\n        return len(self.H)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self): self.H = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.H.append(t)\\n        while self.H[0] < t - 3000: self.H.popleft()\\n        return len(self.H)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 389431,
                "title": "easy-to-understand-c-solution",
                "content": "Runtime: 204 ms, faster than 73.58% of C++ online submissions for Number of Recent Calls.\\nMemory Usage: 49.8 MB, less than 100.00% of C++ online submissions for Number of Recent Calls.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        while(t - q.front() > 3000)\\n            q.pop();\\n        return q.size();\\n    }\\n    \\n    private:\\n        queue<int> q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "solutionTags": [
                    "Queue"
                ],
                "code": "Runtime: 204 ms, faster than 73.58% of C++ online submissions for Number of Recent Calls.\\nMemory Usage: 49.8 MB, less than 100.00% of C++ online submissions for Number of Recent Calls.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        while(t - q.front() > 3000)\\n            q.pop();\\n        return q.size();\\n    }\\n    \\n    private:\\n        queue<int> q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 355572,
                "title": "a-simple-java-solution-explained",
                "content": "So, tbf, this question can be worded much, much better. For example\\n<p>\\nWrite a class RecentCounter to count \"recent\" requests.\\nIt has only one method: ping(int t), where <strong>t</strong> represents some timestamp, in milliseconds.\\nReturn the number of pings that have occurred from 3000 milliseconds ago until timestamp <strong>t</strong> parameter.\\nTherefore, any ping occurred in the \"last 3000ms\", i.e. a range [t - 3000, t] will count, including the current ping.\\nIt is guaranteed that every call to ping uses a strictly larger value of t than before.\\n</p>\\n\\n```\\nclass RecentCounter {\\n    private final Queue<Integer> requestQueue = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    /*\\n        The question does not explain clearly that t (in their example)\\n        is timeNow. They do say, that [timeNow - 3000, timeNow] (inclusive) counts.\\n        Therefore, when 3002 comes in, 3001 falls outside the range, since it was before.\\n    */\\n    public int ping(int timeNow) {\\n\\n        requestQueue.add(timeNow);\\n        \\n        while (requestQueue.peek() < (timeNow - 3000)) {\\n            requestQueue.poll();\\n        }\\n        \\n        return requestQueue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private final Queue<Integer> requestQueue = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    /*\\n        The question does not explain clearly that t (in their example)\\n        is timeNow. They do say, that [timeNow - 3000, timeNow] (inclusive) counts.\\n        Therefore, when 3002 comes in, 3001 falls outside the range, since it was before.\\n    */\\n    public int ping(int timeNow) {\\n\\n        requestQueue.add(timeNow);\\n        \\n        while (requestQueue.peek() < (timeNow - 3000)) {\\n            requestQueue.poll();\\n        }\\n        \\n        return requestQueue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282480,
                "title": "java-queue",
                "content": "```java\\nclass RecentCounter {\\n\\n    private Deque<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.size() > 0 && queue.peek() < t - 3000)\\n            queue.remove();\\n        \\n        return queue.size();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass RecentCounter {\\n\\n    private Deque<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.size() > 0 && queue.peek() < t - 3000)\\n            queue.remove();\\n        \\n        return queue.size();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257833,
                "title": "java-solution-using-queue-beats-94-44",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size() > 0) {\\n            int first = queue.peek();\\n            if(t - first > 3000)\\n                queue.poll();\\n            else\\n                break;\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size() > 0) {\\n            int first = queue.peek();\\n            if(t - first > 3000)\\n                queue.poll();\\n            else\\n                break;\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192324,
                "title": "java-array-binary-search-111-ms-o-log-3000-time-o-logn-space",
                "content": "Keep track of the rising watermark after each call to limit the search space for the next call to no more than 3000 elements.\\n\\n```\\nclass RecentCounter {\\n\\n    private int[] times;\\n    private int watermark;\\n    private int size;\\n    \\n    public RecentCounter() {\\n        times = new int[10000];\\n        watermark = 0;\\n        size = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        times[size] = t;\\n        size ++;\\n        watermark = binarySearch(t-3000, watermark, size);\\n        return size - watermark;\\n    }\\n    \\n    private int binarySearch(int t, int start, int end) {\\n        int lo = start, hi = end;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (times[mid] < t) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    private int[] times;\\n    private int watermark;\\n    private int size;\\n    \\n    public RecentCounter() {\\n        times = new int[10000];\\n        watermark = 0;\\n        size = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        times[size] = t;\\n        size ++;\\n        watermark = binarySearch(t-3000, watermark, size);\\n        return size - watermark;\\n    }\\n    \\n    private int binarySearch(int t, int start, int end) {\\n        int lo = start, hi = end;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (times[mid] < t) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189261,
                "title": "java-binary-search-o-1",
                "content": "The timestamp input is a increasing sequence \\nTherefore, in each ping, we can use binary search to search for the `target just >= t - 3000`\\nAnd return the result calculated from the index of the target\\n\\n**Optimization:**\\nMaintain a `lowerBound` index to shrink the binary search range to `[lowerBound, list.size()-1]`\\nUpdate `lowerBound` in each ping\\nThis speed up about `30ms`\\n```\\nclass RecentCounter {\\n    List<Integer> list = new ArrayList<>();\\n    int lowerBound = 0;\\n    public RecentCounter() {}\\n    public int ping(int t) {\\n        list.add(t);\\n        int r = list.size() - 1;\\n        int target = t - 3000;\\n        while (lowerBound < r) {\\n            int m = lowerBound + (r-lowerBound) / 2;\\n            if (list.get(m) >= target)\\n                r = m;\\n            else\\n                lowerBound = m + 1;\\n        }\\n        return list.size() - lowerBound;\\n    }\\n}\\n```\\n**Time Complexity:** `O(log3001)` => `O(1)`\\n**Space Complexity:** `O(N)` for list",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    List<Integer> list = new ArrayList<>();\\n    int lowerBound = 0;\\n    public RecentCounter() {}\\n    public int ping(int t) {\\n        list.add(t);\\n        int r = list.size() - 1;\\n        int target = t - 3000;\\n        while (lowerBound < r) {\\n            int m = lowerBound + (r-lowerBound) / 2;\\n            if (list.get(m) >= target)\\n                r = m;\\n            else\\n                lowerBound = m + 1;\\n        }\\n        return list.size() - lowerBound;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906604,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class RecentCounter {\\n    int counter;\\n    Queue<int> q = new Queue<int>();\\n\\n    public RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    public int Ping(int t) {\\n        q.Enqueue(t);\\n        counter += 1;\\n        while (q.Count > 0 && (q.Peek() > t || q.Peek() < (t - 3000)))\\n        {\\n            q.Dequeue();\\n            counter -= 1;\\n        }\\n\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RecentCounter {\\n    int counter;\\n    Queue<int> q = new Queue<int>();\\n\\n    public RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    public int Ping(int t) {\\n        q.Enqueue(t);\\n        counter += 1;\\n        while (q.Count > 0 && (q.Peek() > t || q.Peek() < (t - 3000)))\\n        {\\n            q.Dequeue();\\n            counter -= 1;\\n        }\\n\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879598,
                "title": "kotlin-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter() {\\n\\n    val queue = ArrayDeque<Int>()\\n\\n    fun ping(t: Int): Int {\\n        while (queue.isNotEmpty() && queue.first() < t - 3000) {\\n            queue.removeFirst()\\n        }\\n        queue.add(t)\\n        return queue.size\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass RecentCounter() {\\n\\n    val queue = ArrayDeque<Int>()\\n\\n    fun ping(t: Int): Int {\\n        while (queue.isNotEmpty() && queue.first() < t - 3000) {\\n            queue.removeFirst()\\n        }\\n        queue.add(t)\\n        return queue.size\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678085,
                "title": "simple-iterative-approach-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Arrays\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    ArrayList<Integer> calls ;\\n    public RecentCounter() {\\n        calls = new ArrayList<Integer>();\\n        }\\n    \\n    public int ping(int t) {\\n        calls.add(t);\\n        int count = 0;\\n        for(Integer call:calls){\\n            if( t-call<=3000) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    ArrayList<Integer> calls ;\\n    public RecentCounter() {\\n        calls = new ArrayList<Integer>();\\n        }\\n    \\n    public int ping(int t) {\\n        calls.add(t);\\n        int count = 0;\\n        for(Integer call:calls){\\n            if( t-call<=3000) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608833,
                "title": "c",
                "content": "\\n# Code\\n```\\npublic class RecentCounter\\n{\\n    int[] pings;\\n    int idx;\\n\\n    public RecentCounter()\\n    {\\n        pings = new int[10000];\\n        idx= 0;\\n    }\\n\\n    public int Ping(int t)\\n    {\\n        pings[idx++] = t;\\n        int left = t - 3000;\\n        int cnt = 1;\\n\\n        for(int i = idx-2; i >= 0; --i) \\n        {\\n            if (pings[i] < left)\\n                return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RecentCounter\\n{\\n    int[] pings;\\n    int idx;\\n\\n    public RecentCounter()\\n    {\\n        pings = new int[10000];\\n        idx= 0;\\n    }\\n\\n    public int Ping(int t)\\n    {\\n        pings[idx++] = t;\\n        int left = t - 3000;\\n        int cnt = 1;\\n\\n        for(int i = idx-2; i >= 0; --i) \\n        {\\n            if (pings[i] < left)\\n                return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438043,
                "title": "simple-solution-but-logical-beats-99-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw this problem for the first time, I thought problems related to queue in leetcode need to be solved by Node, but it is easier than Nodes here.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn while statement we check is it empty or not first if it is, we simply append it to queue (composition).\\nIn next Input, there is 1 in queue, so we add 1 + 3000 < t, t in this case 100, if it is the case we remove it from queue\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBig O(n Log (n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nBig O(n)\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873768,
                "title": "c-easy-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    vector<int> arr;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        arr.push_back(t);\\n        int cnt=0;\\n        for (int i : arr) if (i>=t-3000 && i<=t) cnt++;\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> arr;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        arr.push_back(t);\\n        int cnt=0;\\n        for (int i : arr) if (i>=t-3000 && i<=t) cnt++;\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857801,
                "title": "one-line-code-in-c",
                "content": "\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444491,
                "title": "java-simple-and-friendly-97",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList<>();\\n\\n    public RecentCounter() {        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < (t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList<>();\\n\\n    public RecentCounter() {        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < (t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337766,
                "title": "simple-c-queue-solution",
                "content": "Please upvote if you like my solution .\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        int x = q.front();\\n        while(x < t-3000){\\n            q.pop(); x = q.front();\\n        }\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        int x = q.front();\\n        while(x < t-3000){\\n            q.pop(); x = q.front();\\n        }\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168734,
                "title": "python3-o-n-o-n-with-explanation",
                "content": "https://photos.app.goo.gl/sFqFttroBwRzf7MaA couldn\\'t upload it here dont know \\n\\n```\\nclass RecentCounter:\\n#     O(n) || O(n)\\n# Runtime: 310ms 78.53% || memory: 19.6mb 46.67%\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (t - self.queue[0]) > 3000:\\n            self.queue.pop(0)\\n            \\n        return self.queue.__len__()\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n#     O(n) || O(n)\\n# Runtime: 310ms 78.53% || memory: 19.6mb 46.67%\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (t - self.queue[0]) > 3000:\\n            self.queue.pop(0)\\n            \\n        return self.queue.__len__()\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142681,
                "title": "kotlin-concise-solution-with-a-queue-mutablelist",
                "content": "We instantiate a queue to keep track of the ping values. When we ping, we add to the queue and we dequeue items while `t - item > 3000`. The remaining items will all be pings that took place in the last 3000ms, so we can just return the size of the queue.\\n\\n```\\nclass RecentCounter(private val queue: MutableList<Int> = mutableListOf<Int>()) {\\n    fun ping(t: Int): Int {\\n        queue.add(t)\\n        while (t - queue[0] > 3000) queue.removeAt(0)\\n        return queue.size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter(private val queue: MutableList<Int> = mutableListOf<Int>()) {\\n    fun ping(t: Int): Int {\\n        queue.add(t)\\n        while (t - queue[0] > 3000) queue.removeAt(0)\\n        return queue.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094027,
                "title": "python-deque",
                "content": "Some alternative solution with the Deque object which has Insertion or removal of elements at the end or beginning - constant O(1)\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        from collections import deque\\n        self.t = deque()\\n\\n    def ping(self, t: int) -> int:        \\n        while self.t and self.t[0] < t - 3000:\\n            self.t.popleft()\\n        self.t.append(t)\\n        return len(self.t)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        from collections import deque\\n        self.t = deque()\\n\\n    def ping(self, t: int) -> int:        \\n        while self.t and self.t[0] < t - 3000:\\n            self.t.popleft()\\n        self.t.append(t)\\n        return len(self.t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011643,
                "title": "java-queue",
                "content": "```\\nclass RecentCounter {\\n\\n    /**\\n     * Time Complexity: O(1)\\n     * Space Complexity: O(n)\\n     * @topic Number of Recent Calls\\n     * @author ArtistS\\n     */\\n    Queue<Integer> recentRequests;\\n    public RecentCounter() {\\n        recentRequests = new LinkedList<Integer>();\\n    }\\n\\n    public int ping(int t) {\\n        recentRequests.offer(t);\\n        while (recentRequests.peek() < t - 3000) {\\n            recentRequests.poll();\\n        }\\n        return recentRequests.size();\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    /**\\n     * Time Complexity: O(1)\\n     * Space Complexity: O(n)\\n     * @topic Number of Recent Calls\\n     * @author ArtistS\\n     */\\n    Queue<Integer> recentRequests;\\n    public RecentCounter() {\\n        recentRequests = new LinkedList<Integer>();\\n    }\\n\\n    public int ping(int t) {\\n        recentRequests.offer(t);\\n        while (recentRequests.peek() < t - 3000) {\\n            recentRequests.poll();\\n        }\\n        return recentRequests.size();\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981013,
                "title": "c-using-queue-easy-to-understand",
                "content": "class RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n if its help please don\\'t forget to upvote it \\uD83D\\uDE0A.",
                "solutionTags": [
                    "Array",
                    "Queue"
                ],
                "code": "class RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n if its help please don\\'t forget to upvote it \\uD83D\\uDE0A.",
                "codeTag": "Java"
            },
            {
                "id": 1889394,
                "title": "python-two-solutions-deque",
                "content": "Using a deque:\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while t - self.pings[0] > 3000:\\n            self.pings.popleft()\\n        return len(self.pings)\\n```\\n\\nOtherwise, using a list to save all the pings:\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n        self.start = 0\\n        self.cnt = 0\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        self.cnt += 1\\n        while t - self.pings[self.start] > 3000:\\n            self.start += 1\\n            self.cnt -= 1\\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while t - self.pings[0] > 3000:\\n            self.pings.popleft()\\n        return len(self.pings)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n        self.start = 0\\n        self.cnt = 0\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        self.cnt += 1\\n        while t - self.pings[self.start] > 3000:\\n            self.start += 1\\n            self.cnt -= 1\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871821,
                "title": "java-queue-5-loc-super-easy-to-understand",
                "content": "```\\nclass RecentCounter {\\n    \\n    private Queue<Integer> q;\\n    \\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek() < t - 3000) {\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    \\n    private Queue<Integer> q;\\n    \\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek() < t - 3000) {\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841306,
                "title": "beginner-friendly-python-solution",
                "content": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.calls = []\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < t-3000:\\n            self.calls.pop(0)\\n        return len(self.calls)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.calls = []\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < t-3000:\\n            self.calls.pop(0)\\n        return len(self.calls)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526660,
                "title": "linear-solution-queue",
                "content": "```\\ntype RecentCounter struct {\\n    values []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{values: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    v := this.values\\n\\t// add the new values to the queue (end of slice)\\n    v = append(v, t)\\n    \\n    ind := 0\\n\\t// remove first elements till it\\'s in range we need [t-3000:t] (because every new t is bigger than previous)\\n    for ind<len(v) && v[ind] < t-3000 {\\n        ind++\\n    }\\n\\t// cut the first values that we don\\'t need anymore, cause they will not be in range for next queries\\n    this.values = v[ind:]\\n    \\n    return len(this.values)\\n}\\n ```\\n",
                "solutionTags": [],
                "code": "```\\ntype RecentCounter struct {\\n    values []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{values: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    v := this.values\\n\\t// add the new values to the queue (end of slice)\\n    v = append(v, t)\\n    \\n    ind := 0\\n\\t// remove first elements till it\\'s in range we need [t-3000:t] (because every new t is bigger than previous)\\n    for ind<len(v) && v[ind] < t-3000 {\\n        ind++\\n    }\\n\\t// cut the first values that we don\\'t need anymore, cause they will not be in range for next queries\\n    this.values = v[ind:]\\n    \\n    return len(this.values)\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445135,
                "title": "range-and-queues",
                "content": "```\\n queue<int> q; \\n    RecentCounter(){\\n    }\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < q.back()-3000) {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n queue<int> q; \\n    RecentCounter(){\\n    }\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < q.back()-3000) {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426727,
                "title": "c-queue-simple-queue-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(t-q.front()>3000){q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(t-q.front()>3000){q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327267,
                "title": "java-simple-solution-with-queues",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> q; \\n    \\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!q.isEmpty() && t - 3000 > q.peek()) q.remove();\\n        \\n        q.add(t);\\n        \\n        return q.size();\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n \\n ```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q; \\n    \\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!q.isEmpty() && t - 3000 > q.peek()) q.remove();\\n        \\n        q.add(t);\\n        \\n        return q.size();\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1324137,
                "title": "java-binary-search",
                "content": "```\\nclass RecentCounter {\\n    private ArrayList<Integer> req = new ArrayList<>();\\n    \\n    public RecentCounter() {\\n        this.req = new ArrayList<>();    \\n    }\\n    \\n    public int ping(int t) {\\n        req.add(t);\\n        int start = t - 3000;\\n        int idx = binarySearch(req, start);\\n        idx += req.get(idx) >= start ? 0 : 1;\\n        return req.size() - idx;\\n    }\\n    \\n    // find index of element >= k\\n    public int binarySearch(ArrayList<Integer> s, int k) {\\n        int n = s.size();\\n        int l = 0; \\n        int r = n-1;\\n        while (l < r) {\\n            int mid = (l+r)/2;\\n            if (s.get(mid) == k) return mid;\\n            if (s.get(mid) > k) r = mid-1;\\n            if (s.get(mid) < k) l = mid+1;\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private ArrayList<Integer> req = new ArrayList<>();\\n    \\n    public RecentCounter() {\\n        this.req = new ArrayList<>();    \\n    }\\n    \\n    public int ping(int t) {\\n        req.add(t);\\n        int start = t - 3000;\\n        int idx = binarySearch(req, start);\\n        idx += req.get(idx) >= start ? 0 : 1;\\n        return req.size() - idx;\\n    }\\n    \\n    // find index of element >= k\\n    public int binarySearch(ArrayList<Integer> s, int k) {\\n        int n = s.size();\\n        int l = 0; \\n        int r = n-1;\\n        while (l < r) {\\n            int mid = (l+r)/2;\\n            if (s.get(mid) == k) return mid;\\n            if (s.get(mid) > k) r = mid-1;\\n            if (s.get(mid) < k) l = mid+1;\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309447,
                "title": "java",
                "content": "class RecentCounter {\\n    List<Integer> a;\\n    public RecentCounter() {\\n        a=new ArrayList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        int n=1;\\n        for(int i=a.size()-1;i>=0;i--)\\n        {\\n            if(t-a.get(i)>3000)\\n                break;\\n            n++;\\n        }\\n        a.add(t);\\n        return n;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */",
                "solutionTags": [],
                "code": "class RecentCounter {\\n    List<Integer> a;\\n    public RecentCounter() {\\n        a=new ArrayList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        int n=1;\\n        for(int i=a.size()-1;i>=0;i--)\\n        {\\n            if(t-a.get(i)>3000)\\n                break;\\n            n++;\\n        }\\n        a.add(t);\\n        return n;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1296327,
                "title": "golang-solution-faster-than-100-with-quick-explanation",
                "content": "For this solution, we have got to look at something that is said in the problem description:\\n\\n> It is ***guaranteed*** that every call to ping uses a strictly larger value of `t` than the previous call.\\n\\nSo using that, we can make a variable (Which I called `k`) and store the position of the last position of the value that is greater than or equal to `t - 3000`. Then when we add a `t` to an array, and we can keep adding to `k` so we find the number of recent calls/\\n\\n``` go\\ntype RecentCounter struct {\\n    k int\\n    arr []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{0, []int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.arr = append(this.arr, t)\\n    \\n    for this.arr[this.k] < t - 3000 {\\n        this.k++\\n    }\\n    return len(this.arr) - this.k\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\ntype RecentCounter struct {\\n    k int\\n    arr []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{0, []int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.arr = append(this.arr, t)\\n    \\n    for this.arr[this.k] < t - 3000 {\\n        this.k++\\n    }\\n    return len(this.arr) - this.k\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280732,
                "title": "using-min-heap-c-easy-approach",
                "content": "class RecentCounter {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>res;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        res.push(t);\\n               while(t-res.top()>3000)\\n               {\\n                   res.pop();\\n               }\\n           return res.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "solutionTags": [],
                "code": "class RecentCounter {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>res;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        res.push(t);\\n               while(t-res.top()>3000)\\n               {\\n                   res.pop();\\n               }\\n           return res.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1204527,
                "title": "simple-c-solution",
                "content": "```\\n\\nclass RecentCounter {\\npublic:\\n    vector<int>v;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        int count=0;\\n        int l=t-3000;\\n        int u=t;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i]>=l && v[i]<=u)\\n                count++;\\nreturn count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass RecentCounter {\\npublic:\\n    vector<int>v;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        int count=0;\\n        int l=t-3000;\\n        int u=t;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i]>=l && v[i]<=u)\\n                count++;\\nreturn count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181188,
                "title": "python-3-straightforward-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n        \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < (t - 3000):\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n        \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < (t - 3000):\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166259,
                "title": "java-solution-100",
                "content": "```\\nclass RecentCounter {\\n    List<Integer> list;\\n    public RecentCounter() {\\n        list = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int range = t - 3000;\\n        while(range > list.get(0)){\\n            list.remove(0);\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    List<Integer> list;\\n    public RecentCounter() {\\n        list = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int range = t - 3000;\\n        while(range > list.get(0)){\\n            list.remove(0);\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105645,
                "title": "108-ms-runtime-faster-than-100-c-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    int counter;\\n    RecentCounter() {\\n        counter= 0;\\n    }\\n    queue<int> myQ;\\n    int ping(int t) {\\n        myQ.push(t);\\n        while(myQ.front()<(t-3000)){//[t - 3000, t]\\n            myQ.pop();\\n            counter--;\\n        }\\n        counter++;\\n        return counter;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    int counter;\\n    RecentCounter() {\\n        counter= 0;\\n    }\\n    queue<int> myQ;\\n    int ping(int t) {\\n        myQ.push(t);\\n        while(myQ.front()<(t-3000)){//[t - 3000, t]\\n            myQ.pop();\\n            counter--;\\n        }\\n        counter++;\\n        return counter;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036132,
                "title": "python3-sliding-window-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[0] < (t - 3000):\\n            self.counter.pop(0)\\n        return len(self.counter)\\n```\\nAnother way :-\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n        self.left = 0\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[self.left] < (t - 3000):\\n            self.left += 1\\n        return len(self.counter[self.left:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[0] < (t - 3000):\\n            self.counter.pop(0)\\n        return len(self.counter)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n        self.left = 0\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[self.left] < (t - 3000):\\n            self.left += 1\\n        return len(self.counter[self.left:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023185,
                "title": "python-solution",
                "content": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975776,
                "title": "priorityqueue-soln-java",
                "content": "```\\nclass RecentCounter {\\n\\n    PriorityQueue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000)\\n            queue.poll();\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    PriorityQueue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000)\\n            queue.poll();\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949641,
                "title": "binary-search-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> v;\\n    \\n    RecentCounter() {\\n       \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        \\n        int low = t - 3000;\\n        int high = t;\\n        \\n        auto lowIdx = lower_bound(v.begin(), v.end(), low);\\n        auto highIdx = upper_bound(v.begin(), v.end(), high);\\n        \\n        return highIdx - lowIdx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> v;\\n    \\n    RecentCounter() {\\n       \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        \\n        int low = t - 3000;\\n        int high = t;\\n        \\n        auto lowIdx = lower_bound(v.begin(), v.end(), low);\\n        auto highIdx = upper_bound(v.begin(), v.end(), high);\\n        \\n        return highIdx - lowIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915985,
                "title": "5-lines-easy-soln-beat-99-21-soln-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic: queue<int>q;\\n    RecentCounter() {\\n      }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)\\n        {q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n```\\nhappy coding :)\\nplease upvote",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic: queue<int>q;\\n    RecentCounter() {\\n      }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)\\n        {q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906722,
                "title": "c-queue",
                "content": "```\\nclass RecentCounter {\\n    queue<int> requests;\\n    int counter;\\npublic:\\n    RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    int ping(int t) {\\n        requests.push(t);\\n        counter++;\\n        while(requests.front() < t-3000) {\\n            requests.pop();\\n            counter--;\\n        }\\n        return counter;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    queue<int> requests;\\n    int counter;\\npublic:\\n    RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    int ping(int t) {\\n        requests.push(t);\\n        counter++;\\n        while(requests.front() < t-3000) {\\n            requests.pop();\\n            counter--;\\n        }\\n        return counter;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896064,
                "title": "python-3-manual-binary-search",
                "content": "```\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        low = 0\\n        high = len(self.pings)-1\\n        while low<=high:\\n            mid = low + ((high-low)//2)\\n            if self.pings[mid] < t-3000:\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return len(self.pings)-max(high,low)\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        low = 0\\n        high = len(self.pings)-1\\n        while low<=high:\\n            mid = low + ((high-low)//2)\\n            if self.pings[mid] < t-3000:\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return len(self.pings)-max(high,low)\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 888330,
                "title": "simple-python-without-recursion",
                "content": "Because t always increasing, we can use a loop to drop values from our list of pings until the value is greater than or equal to the minimum window for the most recent ping. There is no requirement to keep all of the timings, so we can remove each value that doesn\\'t fall in the range. This will shorten the loop for future pings. Then the number of pings in the range is just the length of our list of pings.\\n\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pingTimes = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pingTimes.append(t)\\n        i = 0\\n        while self.pingTimes[i] < t - 3000:\\n            self.pingTimes.pop(i)\\n        \\n        return len(self.pingTimes)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pingTimes = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pingTimes.append(t)\\n        i = 0\\n        while self.pingTimes[i] < t - 3000:\\n            self.pingTimes.pop(i)\\n        \\n        return len(self.pingTimes)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882160,
                "title": "c-simple-short-solution-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() \\n    {\\n        queue<int> temp;\\n        q=temp;\\n    }\\n    \\n    int ping(int t) \\n    {\\n        q.push(t);\\n        while(!q.empty()&&q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() \\n    {\\n        queue<int> temp;\\n        q=temp;\\n    }\\n    \\n    int ping(int t) \\n    {\\n        q.push(t);\\n        while(!q.empty()&&q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875595,
                "title": "recent-counter-c-3-line",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {}\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)q.pop();\\n        return q.size();\\n    }    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {}\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)q.pop();\\n        return q.size();\\n    }    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874715,
                "title": "python-number-of-recent-calls-easy-solution-using-priority-queue",
                "content": "```py\\nimport heapq\\nfrom typing import List\\n\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.timestamps: List[int] = []\\n\\n    def ping(self, t: int) -> int:\\n        heapq.heappush(self.timestamps, t)\\n        limit = t - 3000\\n        while self.timestamps[0] < limit:\\n            self.timestamps.pop(0)\\n        return len(self.timestamps)\\n\\n```",
                "solutionTags": [],
                "code": "```py\\nimport heapq\\nfrom typing import List\\n\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.timestamps: List[int] = []\\n\\n    def ping(self, t: int) -> int:\\n        heapq.heappush(self.timestamps, t)\\n        limit = t - 3000\\n        while self.timestamps[0] < limit:\\n            self.timestamps.pop(0)\\n        return len(self.timestamps)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874688,
                "title": "c-3-lines-simple-o-n-time-o-1-o-3000-space",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.size() && q.front() < (t - 3000)) q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.size() && q.front() < (t - 3000)) q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874631,
                "title": "python-binary-search-a-bit-slower-but-effective-and-easy-to-understand",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p=[]   \\n\\n    def ping(self, t: int) -> int:\\n        self.p.append(t)\\n        if(t<=3000):\\n            return len(self.p)\\n        else:\\n            target=t-3000\\n            s,e=0,len(self.p)\\n            while(s<=e):\\n                mid=(s+e)//2\\n                if(self.p[mid]==target):\\n                    return len(self.p[mid:])\\n                elif(self.p[mid]<target):\\n                    s=mid+1\\n                else:\\n                    e=mid-1\\n            return len(self.p[s:])\\n\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p=[]   \\n\\n    def ping(self, t: int) -> int:\\n        self.p.append(t)\\n        if(t<=3000):\\n            return len(self.p)\\n        else:\\n            target=t-3000\\n            s,e=0,len(self.p)\\n            while(s<=e):\\n                mid=(s+e)//2\\n                if(self.p[mid]==target):\\n                    return len(self.p[mid:])\\n                elif(self.p[mid]<target):\\n                    s=mid+1\\n                else:\\n                    e=mid-1\\n            return len(self.p[s:])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874622,
                "title": "anyone-can-understand-this-solution",
                "content": "```\\nclass RecentCounter {\\n\\n    CustomeLL root = null;//current node at time t\\n    CustomeLL prev = null;//last node, in range of 3000\\n    \\n    int time_interval = 3000;\\n    \\n    int request_count = 0;//number of request\\n    \\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        if(root==null){\\n            root = new CustomeLL(t);\\n            prev = root;\\n            request_count++;\\n        }else{\\n            root.next = new CustomeLL(t);\\n            root = root.next;\\n            request_count++; //when new time added, increment count\\n            \\n            //check if last time and current time is in range of 3000\\n            while(prev!=root && root.t-prev.t>time_interval){\\n                prev = prev.next;\\n                request_count--;\\n            }\\n        }\\n        return request_count;\\n    }\\n}\\n//cutome linked List\\nclass CustomeLL{\\n    CustomeLL next;\\n    int t;\\n    CustomeLL(int t){\\n        this.t = t;\\n        this.next = null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    CustomeLL root = null;//current node at time t\\n    CustomeLL prev = null;//last node, in range of 3000\\n    \\n    int time_interval = 3000;\\n    \\n    int request_count = 0;//number of request\\n    \\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        if(root==null){\\n            root = new CustomeLL(t);\\n            prev = root;\\n            request_count++;\\n        }else{\\n            root.next = new CustomeLL(t);\\n            root = root.next;\\n            request_count++; //when new time added, increment count\\n            \\n            //check if last time and current time is in range of 3000\\n            while(prev!=root && root.t-prev.t>time_interval){\\n                prev = prev.next;\\n                request_count--;\\n            }\\n        }\\n        return request_count;\\n    }\\n}\\n//cutome linked List\\nclass CustomeLL{\\n    CustomeLL next;\\n    int t;\\n    CustomeLL(int t){\\n        this.t = t;\\n        this.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874365,
                "title": "javascript-clean-code-beat-99",
                "content": "```javascript\\nclass RecentCounter {\\n    constructor() {\\n        this.queue = [];\\n    }\\n    \\n    ping(t) {\\n        this.queue.push(t);\\n        while(this.queue[0] < t - 3000) this.queue.shift();\\n        return this.queue.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass RecentCounter {\\n    constructor() {\\n        this.queue = [];\\n    }\\n    \\n    ping(t) {\\n        this.queue.push(t);\\n        while(this.queue[0] < t - 3000) this.queue.shift();\\n        return this.queue.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874330,
                "title": "java-using-a-minheap-to-store-the-recent-pings",
                "content": "\\n```\\nclass RecentCounter {\\n    private static final int MAX_DURATION = 3000;\\n    private Queue<Integer> recentPings;\\n\\n    public RecentCounter() {\\n        this.recentPings = new PriorityQueue<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!recentPings.isEmpty() && (t - recentPings.peek()) > MAX_DURATION) {\\n            recentPings.remove();\\n        }\\n        recentPings.add(t);\\n        return recentPings.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private static final int MAX_DURATION = 3000;\\n    private Queue<Integer> recentPings;\\n\\n    public RecentCounter() {\\n        this.recentPings = new PriorityQueue<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!recentPings.isEmpty() && (t - recentPings.peek()) > MAX_DURATION) {\\n            recentPings.remove();\\n        }\\n        recentPings.add(t);\\n        return recentPings.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874304,
                "title": "python-3-solution-using-list-runtime-beats-98-34",
                "content": "1. In the __init__ method, initialize requests list and size to 0.\\n2. In the ping method, when there is a ping and t is passed to it, add t to the requests lists and increment the size by 1.\\n3. If the first call in the requests list is more than or equal to t - 3000, then return the size.\\n4. Otherwise, remove from the requests list all the calls before t - 3000 and everytime a call is deleted using pop on the requests list, decrement the size by 1.\\nReturn the size.\\n\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.requests = []\\n        self.size = 0\\n    \\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        self.size += 1\\n        \\n        while self.requests[0] < t - 3000:\\n            self.requests.pop(0)\\n            self.size -= 1\\n            \\n        return(self.size)\\n            \\n    \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.requests = []\\n        self.size = 0\\n    \\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        self.size += 1\\n        \\n        while self.requests[0] < t - 3000:\\n            self.requests.pop(0)\\n            self.size -= 1\\n            \\n        return(self.size)\\n            \\n    \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874298,
                "title": "java-ring-buffer-bs-solution-99-perfomance",
                "content": "I expected more perfomance for my solution. WIth predef ring buffer. UPDATED\\nNew optimized solution:\\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n     public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n\\n        int value = t - THRESHOLD + 1;\\n\\n        int l = 0;\\n        int r = length;\\n        int shift = head - length;\\n         \\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) \\n                return length = mShift > head ? THRESHOLD - mShift + head + 1 : head + 1 - mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        int lShift = (THRESHOLD + (l + shift)) % THRESHOLD;\\n\\n        return length = lShift > head ? THRESHOLD - lShift + head + 1 : head + 1 - lShift;\\n    }\\n    \\n}\\n```\\n\\n\\nOld one:\\n\\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int tail = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n    public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n        if (head == tail || tail == -1) {\\n            tail = ++tail % THRESHOLD;\\n        }\\n        length = Math.min(length + 1, THRESHOLD);\\n\\n        int idx = findIdx(t - THRESHOLD + 1);\\n        length -= idx >= tail ? idx - tail : head - idx;\\n        tail = idx;\\n      \\n        return tail > head ? head + (THRESHOLD - tail + 1) : head - tail + 1;\\n    }\\n\\n    private int findIdx(int value) {\\n        int l = 0;\\n        int r = length - 1;\\n        int shift = head - (length - 1);\\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) return mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        return (THRESHOLD + (l + shift)) % THRESHOLD;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n     public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n\\n        int value = t - THRESHOLD + 1;\\n\\n        int l = 0;\\n        int r = length;\\n        int shift = head - length;\\n         \\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) \\n                return length = mShift > head ? THRESHOLD - mShift + head + 1 : head + 1 - mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        int lShift = (THRESHOLD + (l + shift)) % THRESHOLD;\\n\\n        return length = lShift > head ? THRESHOLD - lShift + head + 1 : head + 1 - lShift;\\n    }\\n    \\n}\\n```\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int tail = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n    public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n        if (head == tail || tail == -1) {\\n            tail = ++tail % THRESHOLD;\\n        }\\n        length = Math.min(length + 1, THRESHOLD);\\n\\n        int idx = findIdx(t - THRESHOLD + 1);\\n        length -= idx >= tail ? idx - tail : head - idx;\\n        tail = idx;\\n      \\n        return tail > head ? head + (THRESHOLD - tail + 1) : head - tail + 1;\\n    }\\n\\n    private int findIdx(int value) {\\n        int l = 0;\\n        int r = length - 1;\\n        int shift = head - (length - 1);\\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) return mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        return (THRESHOLD + (l + shift)) % THRESHOLD;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874257,
                "title": "number-of-recent-calls-java-queue",
                "content": "```\\nclass RecentCounter {\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue= new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        \\n        int start = t-3000;\\n        while(!queue.isEmpty() && queue.peek()<start) queue.poll();\\n        \\n        queue.add(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue= new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        \\n        int start = t-3000;\\n        while(!queue.isEmpty() && queue.peek()<start) queue.poll();\\n        \\n        queue.add(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874195,
                "title": "simple-javascript",
                "content": "```\\nvar RecentCounter = function() {\\n    this.req = [];\\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.req.push(t);\\n    let range = [t - 3000, t];\\n    let res = 0;\\n    for (let i = 0; i < this.req.length; i++)\\n    {\\n        if (this.req[i] >= range[0] && this.req[i] <= range[1])\\n            res++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar RecentCounter = function() {\\n    this.req = [];\\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.req.push(t);\\n    let range = [t - 3000, t];\\n    let res = 0;\\n    for (let i = 0; i < this.req.length; i++)\\n    {\\n        if (this.req[i] >= range[0] && this.req[i] <= range[1])\\n            res++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874125,
                "title": "java-faster-than-99",
                "content": "I had a variable to track the index of the lowest ping time within the valid range (most recent time - 3000), and updated it each time I added a time to the list.\\n\\n```\\nclass RecentCounter {\\n\\n    /**\\n     * List of all ping requests made.\\n     */\\n    private List<Integer> requests;\\n    \\n    /**\\n     * The index containing the the first element whose value is at most 3000\\n     * less than the last element.\\n     */\\n    private int minIndex;\\n    \\n    public RecentCounter() {\\n        requests = new ArrayList<>();\\n        minIndex = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        requests.add(t); // Add new request\\n        \\n        // Increment minIndex until the element at minIndex is the first element in the 3000 range\\n        while(requests.get(minIndex) < t - 3000 && minIndex < requests.size() - 1) minIndex++;\\n        \\n        \\n        // Number of requests in range is the number of total requests minus\\n        // the index of the first element in the range\\n        return requests.size() - minIndex;\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    /**\\n     * List of all ping requests made.\\n     */\\n    private List<Integer> requests;\\n    \\n    /**\\n     * The index containing the the first element whose value is at most 3000\\n     * less than the last element.\\n     */\\n    private int minIndex;\\n    \\n    public RecentCounter() {\\n        requests = new ArrayList<>();\\n        minIndex = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        requests.add(t); // Add new request\\n        \\n        // Increment minIndex until the element at minIndex is the first element in the 3000 range\\n        while(requests.get(minIndex) < t - 3000 && minIndex < requests.size() - 1) minIndex++;\\n        \\n        \\n        // Number of requests in range is the number of total requests minus\\n        // the index of the first element in the range\\n        return requests.size() - minIndex;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 873933,
                "title": "c-very-simple-using-queue-100-runtime",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        while(!q_.empty() && q_.front() + 3000 < t) {\\n            q_.pop_front();\\n        }\\n        q_.push_back(t);\\n        return q_.size();\\n    }\\n\\nprivate:\\n    deque<int> q_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        while(!q_.empty() && q_.front() + 3000 < t) {\\n            q_.pop_front();\\n        }\\n        q_.push_back(t);\\n        return q_.size();\\n    }\\n\\nprivate:\\n    deque<int> q_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873829,
                "title": "double-ended-queue-solution-in-rust",
                "content": "```\\nuse std::collections::VecDeque;\\nuse std::cell::RefCell;\\n\\nstruct RecentCounter {\\n    reqs: RefCell<VecDeque<i32>>,\\n}\\n\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        Self { reqs: RefCell::new(VecDeque::new()) }\\n    }\\n    \\n    fn ping(&self, t: i32) -> i32 {\\n        let mut reqs = self.reqs.borrow_mut();\\n        reqs.push_back(t);\\n        while reqs.front().unwrap() < &(t - 3000) {\\n            reqs.pop_front();\\n        }\\n        reqs.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::VecDeque;\\nuse std::cell::RefCell;\\n\\nstruct RecentCounter {\\n    reqs: RefCell<VecDeque<i32>>,\\n}\\n\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        Self { reqs: RefCell::new(VecDeque::new()) }\\n    }\\n    \\n    fn ping(&self, t: i32) -> i32 {\\n        let mut reqs = self.reqs.borrow_mut();\\n        reqs.push_back(t);\\n        while reqs.front().unwrap() < &(t - 3000) {\\n            reqs.pop_front();\\n        }\\n        reqs.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873712,
                "title": "java-recent-calls-97-queue-well-explained-max-space-time-of-3k-constant-space",
                "content": "\\nSince we need to store only recent events, to avoid filling up space, we should remove older elements with event time greater than 3000.\\nSo for any event, if it\\'s event time is less than , current time - 3000, ie. if eventTime < t-3000, remove that event.\\nWe initially store all the event in a queue,  Basically store an event time in a queue.\\n\\nThe size of queue gives total number of events.\\nSince we are removing older elements, we ONLY have elements in the queue within 3000 time limit.\\nHence we return the queue size everytime.\\nWe dequeue elements from the queue, until all old elements are removed.\\n\\n```\\nclass RecentCounter {\\n\\n    Queue<Integer> recentEvents;\\n    \\n    public RecentCounter() {\\n      recentEvents = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        //while queue is not empty, and still holds events with event time more than 3000, remove those events\\n        while(recentEvents.size()>0 && recentEvents.peek()<t-3000){\\n            recentEvents.remove();\\n        }\\n        recentEvents.add(t);\\n        return recentEvents.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    Queue<Integer> recentEvents;\\n    \\n    public RecentCounter() {\\n      recentEvents = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        //while queue is not empty, and still holds events with event time more than 3000, remove those events\\n        while(recentEvents.size()>0 && recentEvents.peek()<t-3000){\\n            recentEvents.remove();\\n        }\\n        recentEvents.add(t);\\n        return recentEvents.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873705,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n\\n    public RecentCounter() {\\n        pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return a - b;\\n            }\\n        });\\n    }\\n    \\n    public int ping(int t) {\\n        pq.add(t);\\n        while(!pq.isEmpty() && pq.peek() < (t - 3000)) {\\n            pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n\\n    public RecentCounter() {\\n        pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return a - b;\\n            }\\n        });\\n    }\\n    \\n    public int ping(int t) {\\n        pq.add(t);\\n        while(!pq.isEmpty() && pq.peek() < (t - 3000)) {\\n            pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873380,
                "title": "question-explained-python-code-video-code",
                "content": "[](https://www.youtube.com/watch?v=NtNeA48tJDk)\\nhttps://www.youtube.com/watch?v=NtNeA48tJDk\\n```\\nimport collections\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nimport collections\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873355,
                "title": "c-simplest-solution-possible-beats-100-with-explanation-comments",
                "content": "```\\nclass RecentCounter {\\npublic:\\n\\t// Queue for storing requests\\n    queue<int> req;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        // If the queue contains elements which will not come in the [t-3000, t] range then pop them.\\n\\t\\t// Example: Queue: [24, 42, 45, 90] and the request comes at 6000 sec.\\n\\t\\t// Then we have to pop all the elements in the queue as they don\\'t fit into [3000, 6000] range.\\n\\t\\t\\n        while(!req.empty() && req.front() + 3000 < t){\\n            req.pop();\\n        }\\n        // Now, pushing the current request.\\n        req.push(t);\\n\\t\\t// The size of the queue will be the answer as the elements will be in the range [t-3000, t].\\n        return req.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n\\t// Queue for storing requests\\n    queue<int> req;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        // If the queue contains elements which will not come in the [t-3000, t] range then pop them.\\n\\t\\t// Example: Queue: [24, 42, 45, 90] and the request comes at 6000 sec.\\n\\t\\t// Then we have to pop all the elements in the queue as they don\\'t fit into [3000, 6000] range.\\n\\t\\t\\n        while(!req.empty() && req.front() + 3000 < t){\\n            req.pop();\\n        }\\n        // Now, pushing the current request.\\n        req.push(t);\\n\\t\\t// The size of the queue will be the answer as the elements will be in the range [t-3000, t].\\n        return req.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873318,
                "title": "java-easy-to-understand-concise-queue",
                "content": "**if helpful.... please do Upvote**\\n**Time / space Complexity: O(Math.min(N, 3000))**\\n```\\nclass RecentCounter {\\n    \\n    // It actually means the total numbers of pings within its range 3000.\\n    // 1 then count total number 1 (1-3001)\\n    // 2 then count total number 2 because previous 1 is also within its 3000 range. (1-3001)\\n    // then 3001 count total number 3 because 1 , 2 is within its 3000 range. ( also from 1- 3001)\\n    // then 3302 count total number 3 because 1 is out of its range and be omitted,\\n\\t//but then add 3002 itself. the total number 3 here is not the same meaning as previous total number 3( here is 2-3002, previous 3 is 1-3001)\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue=new LinkedList<>();       \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.peek()<t-3000){\\n            queue.remove();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    \\n    // It actually means the total numbers of pings within its range 3000.\\n    // 1 then count total number 1 (1-3001)\\n    // 2 then count total number 2 because previous 1 is also within its 3000 range. (1-3001)\\n    // then 3001 count total number 3 because 1 , 2 is within its 3000 range. ( also from 1- 3001)\\n    // then 3302 count total number 3 because 1 is out of its range and be omitted,\\n\\t//but then add 3002 itself. the total number 3 here is not the same meaning as previous total number 3( here is 2-3002, previous 3 is 1-3001)\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue=new LinkedList<>();       \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.peek()<t-3000){\\n            queue.remove();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873306,
                "title": "c-easy-and-short-solution-queue",
                "content": "```\\nclass RecentCounter {\\n    priority_queue<int, vector<int>, greater<int> > pq;\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        while( !pq.empty() && t - 3000 > pq.top() ) \\n            pq.pop(); \\n        pq.push(t);\\n        return pq.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    priority_queue<int, vector<int>, greater<int> > pq;\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        while( !pq.empty() && t - 3000 > pq.top() ) \\n            pq.pop(); \\n        pq.push(t);\\n        return pq.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873192,
                "title": "number-of-recent-calls-cpp",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> a;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        int c=0;\\n        int min=t-3000>t?t:t-3000;\\n        int max=t-3000>t?t-3000:t;\\n        a.push_back(t);\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<min){\\n                c++;\\n            }\\n        }\\n     return a.size()-c;   \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> a;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        int c=0;\\n        int min=t-3000>t?t:t-3000;\\n        int max=t-3000>t?t-3000:t;\\n        a.push_back(t);\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<min){\\n                c++;\\n            }\\n        }\\n     return a.size()-c;   \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 722615,
                "title": "c-here-s-my-approach-pretty-hard-to-understand-question-simple-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> prev;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        if(prev.empty()){\\n            prev.push_back(t);\\n            return 1;\\n        }\\n        else{\\n            int val = t - 3000;\\n            int count = 0;\\n            for(int i = prev.size() -1 ;i>=0 && val <= prev[i];i--){\\n                count++;\\n            }\\n            if(count == 0)  prev.clear();\\n            prev.push_back(t);\\n            return count + 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> prev;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        if(prev.empty()){\\n            prev.push_back(t);\\n            return 1;\\n        }\\n        else{\\n            int val = t - 3000;\\n            int count = 0;\\n            for(int i = prev.size() -1 ;i>=0 && val <= prev[i];i--){\\n                count++;\\n            }\\n            if(count == 0)  prev.clear();\\n            prev.push_back(t);\\n            return count + 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 662551,
                "title": "simple-solution-by-python-3",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while self.pings[0] < t - 3000:\\n            self.pings.pop(0)\\n        return len(self.pings)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while self.pings[0] < t - 3000:\\n            self.pings.pop(0)\\n        return len(self.pings)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627188,
                "title": "go-solution-with-queue",
                "content": "``` go\\nimport \"container/list\"\\n\\ntype RecentCounter struct {\\n\\tqueue *list.List\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{queue: list.New()}\\n}\\n\\n// Learning: Elements from the list need to be cast into specific type before being used.\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue.PushBack(t)\\n\\tfor this.queue.Front().Value.(int) < t-3000 {\\n\\t\\tthis.queue.Remove(this.queue.Front())\\n\\t}\\n\\n\\treturn this.queue.Len()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nimport \"container/list\"\\n\\ntype RecentCounter struct {\\n\\tqueue *list.List\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{queue: list.New()}\\n}\\n\\n// Learning: Elements from the list need to be cast into specific type before being used.\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue.PushBack(t)\\n\\tfor this.queue.Front().Value.(int) < t-3000 {\\n\\t\\tthis.queue.Remove(this.queue.Front())\\n\\t}\\n\\n\\treturn this.queue.Len()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 600880,
                "title": "simple-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass RecentCounter {\\n    private final Queue<Integer> queue = new LinkedList<>();\\n    \\n    public int ping(int t) {\\n        while (!queue.isEmpty() && queue.peek() < t - 3000)\\n            queue.poll();\\n        queue.offer(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private final Queue<Integer> queue = new LinkedList<>();\\n    \\n    public int ping(int t) {\\n        while (!queue.isEmpty() && queue.peek() < t - 3000)\\n            queue.poll();\\n        queue.offer(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583861,
                "title": "java-100-faster-solution",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.offer(t);\\n        while(queue.peek() < (t - 3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.offer(t);\\n        while(queue.peek() < (t - 3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581876,
                "title": "go-clean-code-112ms-beats-100",
                "content": "```\\ntype RecentCounter struct {\\n\\tqueue []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue = append(this.queue, t)\\n\\tfor this.queue[0]+3000 < t {\\n\\t\\tthis.queue = this.queue[1:]\\n\\t}\\n\\treturn len(this.queue)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype RecentCounter struct {\\n\\tqueue []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue = append(this.queue, t)\\n\\tfor this.queue[0]+3000 < t {\\n\\t\\tthis.queue = this.queue[1:]\\n\\t}\\n\\treturn len(this.queue)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 572853,
                "title": "if-u-understood-the-q-its-a-joke",
                "content": "**Let me explain the Q first in simpler words**\\nAccording to  the Q at a time **t** when a message pings then it will stay in the notification till 3000 ms after that it will disappear.We need to tell the number of messages in notifications at time t when the current ping is done.\\n\\nSay \\nt=**0** ,, notification= 0 **(1)**\\nt=**100** ,, notification= 0,100 **(2)**\\nt=**1500** ,, notification= 0,100,1500 **(3)**\\nt=**3001** ,, notification= 100,1500,3001 **(3)**\\n**(Notice that at t=3001ms notificcation message which arrived at 0ms disappeared)**\\nt=**3099** ,, norification = 100,1500,3001,3099 **(4)**\\nt=**3101** ,, notification= 1500,3001,3099,3101 **(4)**\\n**(Notice that at t=3101ms notificcation message which arrived at 100ms disappeared)**\\n\\n\\nSo logic is simple the one at first come will first go so we need just a queue\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);                                               //At time t only [(t-3000)->t] will remain in the queue\\n        while(q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);                                               //At time t only [(t-3000)->t] will remain in the queue\\n        while(q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547013,
                "title": "ruby-solution-with-custom-kueue-class",
                "content": "```\\nclass RecentCounter\\n    def initialize()\\n        @queue = Kueue.new\\n    end\\n\\n\\n=begin\\n    :type t: Integer\\n    :rtype: Integer\\n=end\\n    def ping(t)\\n        @queue.enq(t)\\n        if @queue.size > 0\\n            while t - @queue.peek > 3000\\n                @queue.shift\\n            end\\n        end\\n        @queue.size\\n    end\\n\\n\\nend\\n\\nclass Kueue\\n   \\n    attr_reader :kueue \\n    \\n    def initialize\\n        @kueue = []\\n    end\\n    \\n    def peek\\n        kueue[0]\\n    end\\n    \\n    def enq(x)\\n        @kueue << x\\n    end\\n    \\n    def shift\\n        @kueue.shift\\n    end\\n    \\n    def size\\n       kueue.length \\n    end\\nend\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter.new()\\n# param_1 = obj.ping(t)\\n```\\n\\nRuby\\'s built-in queue class does not support peeking at the first item without removing it. \\xAF\\\\\\\\_(\\u30C4)_/\\xAF Faster than 45.45% of solutions, 100% less memory. \\n\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter\\n    def initialize()\\n        @queue = Kueue.new\\n    end\\n\\n\\n=begin\\n    :type t: Integer\\n    :rtype: Integer\\n=end\\n    def ping(t)\\n        @queue.enq(t)\\n        if @queue.size > 0\\n            while t - @queue.peek > 3000\\n                @queue.shift\\n            end\\n        end\\n        @queue.size\\n    end\\n\\n\\nend\\n\\nclass Kueue\\n   \\n    attr_reader :kueue \\n    \\n    def initialize\\n        @kueue = []\\n    end\\n    \\n    def peek\\n        kueue[0]\\n    end\\n    \\n    def enq(x)\\n        @kueue << x\\n    end\\n    \\n    def shift\\n        @kueue.shift\\n    end\\n    \\n    def size\\n       kueue.length \\n    end\\nend\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter.new()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529902,
                "title": "c-this-question-sucks-heres-a-commented-90-queue-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    std::queue<int> q;\\n    RecentCounter() {\\n        return;\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n\\t\\t// Remove all pings that are too old\\n        while(!q.empty() and q.front() < t - 3000) q.pop();\\n\\t\\t// Return how many pings remain\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    std::queue<int> q;\\n    RecentCounter() {\\n        return;\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n\\t\\t// Remove all pings that are too old\\n        while(!q.empty() and q.front() < t - 3000) q.pop();\\n\\t\\t// Return how many pings remain\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489645,
                "title": "c-using-queues",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> que;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        this->que.push(t);\\n        while(que.front()<(t-3000))\\n        {\\n            que.pop();\\n        }\\n        return que.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> que;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        this->que.push(t);\\n        while(que.front()<(t-3000))\\n        {\\n            que.pop();\\n        }\\n        return que.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485711,
                "title": "simple-js-100-memory-and-100-time-optimal",
                "content": "\\n```\\nvar RecentCounter = function() {\\n    this.arr = [];\\n    this.start = 0;\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.arr.push(t);\\n    while(this.arr[this.start] < t - 3000) {\\n        this.start++;\\n    }\\n    return this.arr.length - this.start;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RecentCounter = function() {\\n    this.arr = [];\\n    this.start = 0;\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.arr.push(t);\\n    while(this.arr[this.start] < t - 3000) {\\n        this.start++;\\n    }\\n    return this.arr.length - this.start;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476693,
                "title": "python-by-double-ended-queue-run-time-90-with-explanation",
                "content": "Python by double-ended queue\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        \\n        # a double-ended queue that keep fresh calls in math interval [t-3000, t]\\n        self.call_queue = collections.deque()\\n\\n\\n\\n    def ping(self, t: int) -> int:\\n        \\n        # pop out-of-date calls which calling time is smaller than t-3000 on the front\\n        while self.call_queue and self.call_queue[0] < t-3000:    \\n            self.call_queue.popleft()\\n        \\n        \\n        # push in-coming call on the rear\\n        self.call_queue.append(t)\\n        \\n        \\n        return len(self.call_queue)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        \\n        # a double-ended queue that keep fresh calls in math interval [t-3000, t]\\n        self.call_queue = collections.deque()\\n\\n\\n\\n    def ping(self, t: int) -> int:\\n        \\n        # pop out-of-date calls which calling time is smaller than t-3000 on the front\\n        while self.call_queue and self.call_queue[0] < t-3000:    \\n            self.call_queue.popleft()\\n        \\n        \\n        # push in-coming call on the rear\\n        self.call_queue.append(t)\\n        \\n        \\n        return len(self.call_queue)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469308,
                "title": "short-kotlin-solution",
                "content": "```\\nclass RecentCounter() {\\n    \\n    var pings = listOf<Int>()\\n    \\n    fun ping(t: Int): Int {\\n        pings = pings.filter {it in (t - 3000)..t} + t\\n        return pings.size\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter() {\\n    \\n    var pings = listOf<Int>()\\n    \\n    fun ping(t: Int): Int {\\n        pings = pings.filter {it in (t - 3000)..t} + t\\n        return pings.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459575,
                "title": "c-solution-queue-t",
                "content": "Every time Ping is called we use the queue to remove any times that happened more than 3000 ms ago. The queue data struture is ideal for this problem because the oldest pings are stored at the end of the queue. When we get a new ping we just dequeue pings while they are invalid. Then we enque the new ping timestamp and return the Count value of our queue.\\n\\nAlso I made a custom queue that I used to solve the problem on my first attempt.  The custom queue was mainly created as an exercise to understand how a variable size queue is actually stored and the result is a bit rough I think. I included it below, but feel free to ignore it.\\n\\nBasically the queue keeps grows like a circular array until it is full, then all the contents are copied into a new array that is double the size of the previous one. I did not code in any mechanism for the array container to shrink though.\\n\\n```\\npublic class RecentCounter\\n    {\\n\\n        Queue<int> queue;\\n        public RecentCounter()\\n        {\\n            queue = new Queue<int>();\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            \\n            for (int i = 0; i < queue.Count; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            queue.Enqueue(t);\\n            return queue.Count;\\n        }\\n    }\\n\\t\\n\\tpublic class RecentCounterCustomQueue\\n    {\\n\\n        VariableSizeQueue<int> queue;\\n        public RecentCounterCustomQueue()\\n        {\\n            queue = new VariableSizeQueue<int>(10, -1);\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            queue.Enqueue(t);\\n            int startingCount = queue.Count - 1;\\n            for (int i = 0; i < startingCount; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            return queue.Count;\\n        }\\n    }\\n\\n    public class VariableSizeQueue<T>\\n    {\\n        public VariableSizeQueue(int capacity, T sentinelValue)\\n        {\\n            QueueInternal = new T[capacity];\\n            this.SentinelValue = sentinelValue;\\n        }\\n\\n        public T SentinelValue;\\n        public int Capacity\\n        {\\n            get => QueueInternal.Length;\\n        }\\n        public int Count = 0;\\n        public T[] QueueInternal;\\n\\n        public int QueueHeadIndex = 0;\\n        public int QueueTailIndex = 0;\\n\\n        public void Enqueue(T item)\\n        {\\n            if (QueueTailIndex == QueueHeadIndex && Count != 0)\\n                ResizeQueue();\\n            QueueInternal[QueueTailIndex] = item;\\n            Count++;\\n            QueueTailIndex = (QueueTailIndex + 1) % Capacity;\\n        }\\n\\n        //only called internally when all queue is completly full\\n        private void ResizeQueue()\\n        {\\n            //Create a new Queue starting from the beginning\\n            T[] resizedQueue = new T[Capacity * 2];\\n            int j = 0;\\n            for (int i = QueueHeadIndex; j < Capacity; i = (i + 1) % Capacity)\\n            {\\n                resizedQueue[j] = QueueInternal[i];\\n                j++;\\n            }\\n\\n            //change all of the pointers\\n            QueueHeadIndex = 0;\\n            QueueTailIndex = (Capacity);//tail will go one index to the end of old data\\n\\n            QueueInternal = resizedQueue;\\n        }\\n\\n        public T Peek()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n            return QueueInternal[QueueHeadIndex];\\n        }\\n\\n        public T Dequeue()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n\\n            T head = QueueInternal[QueueHeadIndex];\\n            QueueInternal[QueueHeadIndex] = SentinelValue;\\n            QueueHeadIndex = (QueueHeadIndex + 1) % Capacity;\\n            Count--;\\n            return head;\\n        }\\n\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "Every time Ping is called we use the queue to remove any times that happened more than 3000 ms ago. The queue data struture is ideal for this problem because the oldest pings are stored at the end of the queue. When we get a new ping we just dequeue pings while they are invalid. Then we enque the new ping timestamp and return the Count value of our queue.\\n\\nAlso I made a custom queue that I used to solve the problem on my first attempt.  The custom queue was mainly created as an exercise to understand how a variable size queue is actually stored and the result is a bit rough I think. I included it below, but feel free to ignore it.\\n\\nBasically the queue keeps grows like a circular array until it is full, then all the contents are copied into a new array that is double the size of the previous one. I did not code in any mechanism for the array container to shrink though.\\n\\n```\\npublic class RecentCounter\\n    {\\n\\n        Queue<int> queue;\\n        public RecentCounter()\\n        {\\n            queue = new Queue<int>();\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            \\n            for (int i = 0; i < queue.Count; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            queue.Enqueue(t);\\n            return queue.Count;\\n        }\\n    }\\n\\t\\n\\tpublic class RecentCounterCustomQueue\\n    {\\n\\n        VariableSizeQueue<int> queue;\\n        public RecentCounterCustomQueue()\\n        {\\n            queue = new VariableSizeQueue<int>(10, -1);\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            queue.Enqueue(t);\\n            int startingCount = queue.Count - 1;\\n            for (int i = 0; i < startingCount; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            return queue.Count;\\n        }\\n    }\\n\\n    public class VariableSizeQueue<T>\\n    {\\n        public VariableSizeQueue(int capacity, T sentinelValue)\\n        {\\n            QueueInternal = new T[capacity];\\n            this.SentinelValue = sentinelValue;\\n        }\\n\\n        public T SentinelValue;\\n        public int Capacity\\n        {\\n            get => QueueInternal.Length;\\n        }\\n        public int Count = 0;\\n        public T[] QueueInternal;\\n\\n        public int QueueHeadIndex = 0;\\n        public int QueueTailIndex = 0;\\n\\n        public void Enqueue(T item)\\n        {\\n            if (QueueTailIndex == QueueHeadIndex && Count != 0)\\n                ResizeQueue();\\n            QueueInternal[QueueTailIndex] = item;\\n            Count++;\\n            QueueTailIndex = (QueueTailIndex + 1) % Capacity;\\n        }\\n\\n        //only called internally when all queue is completly full\\n        private void ResizeQueue()\\n        {\\n            //Create a new Queue starting from the beginning\\n            T[] resizedQueue = new T[Capacity * 2];\\n            int j = 0;\\n            for (int i = QueueHeadIndex; j < Capacity; i = (i + 1) % Capacity)\\n            {\\n                resizedQueue[j] = QueueInternal[i];\\n                j++;\\n            }\\n\\n            //change all of the pointers\\n            QueueHeadIndex = 0;\\n            QueueTailIndex = (Capacity);//tail will go one index to the end of old data\\n\\n            QueueInternal = resizedQueue;\\n        }\\n\\n        public T Peek()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n            return QueueInternal[QueueHeadIndex];\\n        }\\n\\n        public T Dequeue()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n\\n            T head = QueueInternal[QueueHeadIndex];\\n            QueueInternal[QueueHeadIndex] = SentinelValue;\\n            QueueHeadIndex = (QueueHeadIndex + 1) % Capacity;\\n            Count--;\\n            return head;\\n        }\\n\\n    }\\n\\t\\n\\t",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564925,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565392,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566126,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1826057,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1905405,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566562,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564796,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565709,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1574362,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1790072,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564925,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565392,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566126,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1826057,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1905405,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566562,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564796,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565709,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1574362,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1790072,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1874703,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1953281,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1921900,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574798,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574255,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574433,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2076686,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2075388,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2066308,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2043535,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            }
        ]
    },
    {
        "title": "Linked List in Binary Tree",
        "question_content": "<p>Given a binary tree <code>root</code> and a&nbsp;linked list with&nbsp;<code>head</code>&nbsp;as the first node.&nbsp;</p>\n\n<p>Return True if all the elements in the linked list starting from the <code>head</code> correspond to some <em>downward path</em> connected in the binary tree&nbsp;otherwise return False.</p>\n\n<p>In this context downward path means a path that starts at some node and goes downwards.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png\" style=\"width: 220px; height: 280px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Nodes in blue form a subpath in the binary Tree.  \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/sample_2_1720.png\" style=\"width: 220px; height: 280px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no path in the binary tree that contains all the elements of the linked list from <code>head</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree will be in the range <code>[1, 2500]</code>.</li>\n\t<li>The number of nodes in the list will be in the range <code>[1, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val&nbsp;&lt;= 100</code>&nbsp;for each node in the linked list and binary tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 524881,
                "title": "python-recursive-solution-o-n-l-time",
                "content": "# Solution 1: Brute DFS\\nTime `O(N * min(L,H))`\\nSpace `O(H)`\\nwhere N = tree size, H = tree height, L = list length.\\n<br>\\n\\n**Java**\\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\\n**C++**\\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n    bool dfs(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (dfs(head->next, root->left) || dfs(head->next, root->right));\\n    }\\n```\\n**Python:**\\n```py\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head: return True\\n            if not root: return False\\n            return root.val == head.val and (dfs(head.next, root.left) or dfs(head.next, root.right))\\n        if not head: return True\\n        if not root: return False\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```\\n<br>\\n\\n# Solution 2: DP\\n1. Iterate the whole link, find the maximum matched length of prefix.\\n2. Iterate the whole tree, find the maximum matched length of prefix.\\n\\nAbout this dp, @fukuzawa_yumi gave a link of reference:\\nhttps://en.wikipedia.org/wiki/Knuth\\u2013Morris\\u2013Pratt_algorithm\\n\\nTime `O(N + L)`\\nSpace `O(L + H)`\\nwhere N = tree size, H = tree height, L = list length.\\n<br>\\n\\n**Java**\\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<Integer> A = new ArrayList(), dp = new ArrayList();\\n        A.add(head.val);\\n        dp.add(0);\\n        int i = 0;\\n        head = head.next;\\n        while (head != null) {\\n            while (i > 0 && head.val != A.get(i))\\n                i = dp.get(i - 1);\\n            if (head.val == A.get(i)) ++i;\\n            A.add(head.val);\\n            dp.add(i);\\n            head = head.next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    private boolean dfs(TreeNode root, int i, List<Integer> A, List<Integer> dp) {\\n        if (root == null) return false;\\n        while (i > 0 && root.val != A.get(i))\\n            i = dp.get(i - 1);\\n        if (root.val == A.get(i)) ++i;\\n        return i == dp.size() || dfs(root.left, i, A, dp) || dfs(root.right, i, A, dp);\\n    }\\n```\\n**C++**\\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<int> A = {head->val}, dp = {0};\\n        int i = 0;\\n        head = head->next;\\n        while (head) {\\n            while (i && head->val != A[i])\\n                i = dp[i - 1];\\n            i += head->val == A[i];\\n            A.push_back(head->val);\\n            dp.push_back(i);\\n            head = head->next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    bool dfs(TreeNode* root, int i, vector<int>& A, vector<int>& dp) {\\n        if (!root) return false;\\n        while (i && root->val != A[i])\\n            i = dp[i - 1];\\n        i += root->val == A[i];\\n        return i == dp.size() || dfs(root->left, i, A, dp) || dfs(root->right, i, A, dp);\\n    }\\n```\\n**Python**\\n```py\\nclass Solution(object):\\n\\n    def isSubPath(self, head, root):\\n        A, dp = [head.val], [0]\\n        i = 0\\n        node = head.next\\n        while node:\\n            while i and node.val != A[i]:\\n                i = dp[i - 1]\\n            i += node.val == A[i]\\n            A.append(node.val)\\n            dp.append(i)\\n            node = node.next\\n\\n        def dfs(root, i):\\n            if not root: return False\\n            while i and root.val != A[i]:\\n                i = dp[i - 1]\\n            i += root.val == A[i]\\n            return i == len(dp) or dfs(root.left, i) or dfs(root.right, i)\\n        return dfs(root, 0)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return dfs(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n    bool dfs(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (dfs(head->next, root->left) || dfs(head->next, root->right));\\n    }\\n```\n```py\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head: return True\\n            if not root: return False\\n            return root.val == head.val and (dfs(head.next, root.left) or dfs(head.next, root.right))\\n        if not head: return True\\n        if not root: return False\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<Integer> A = new ArrayList(), dp = new ArrayList();\\n        A.add(head.val);\\n        dp.add(0);\\n        int i = 0;\\n        head = head.next;\\n        while (head != null) {\\n            while (i > 0 && head.val != A.get(i))\\n                i = dp.get(i - 1);\\n            if (head.val == A.get(i)) ++i;\\n            A.add(head.val);\\n            dp.add(i);\\n            head = head.next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    private boolean dfs(TreeNode root, int i, List<Integer> A, List<Integer> dp) {\\n        if (root == null) return false;\\n        while (i > 0 && root.val != A.get(i))\\n            i = dp.get(i - 1);\\n        if (root.val == A.get(i)) ++i;\\n        return i == dp.size() || dfs(root.left, i, A, dp) || dfs(root.right, i, A, dp);\\n    }\\n```\n```cpp\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<int> A = {head->val}, dp = {0};\\n        int i = 0;\\n        head = head->next;\\n        while (head) {\\n            while (i && head->val != A[i])\\n                i = dp[i - 1];\\n            i += head->val == A[i];\\n            A.push_back(head->val);\\n            dp.push_back(i);\\n            head = head->next;\\n        }\\n        return dfs(root, 0, A, dp);\\n    }\\n\\n    bool dfs(TreeNode* root, int i, vector<int>& A, vector<int>& dp) {\\n        if (!root) return false;\\n        while (i && root->val != A[i])\\n            i = dp[i - 1];\\n        i += root->val == A[i];\\n        return i == dp.size() || dfs(root->left, i, A, dp) || dfs(root->right, i, A, dp);\\n    }\\n```\n```py\\nclass Solution(object):\\n\\n    def isSubPath(self, head, root):\\n        A, dp = [head.val], [0]\\n        i = 0\\n        node = head.next\\n        while node:\\n            while i and node.val != A[i]:\\n                i = dp[i - 1]\\n            i += node.val == A[i]\\n            A.append(node.val)\\n            dp.append(i)\\n            node = node.next\\n\\n        def dfs(root, i):\\n            if not root: return False\\n            while i and root.val != A[i]:\\n                i = dp[i - 1]\\n            i += root.val == A[i]\\n            return i == len(dp) or dfs(root.left, i) or dfs(root.right, i)\\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524821,
                "title": "c-simple-recursion",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool findSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool findSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535370,
                "title": "java-kmp-search-o-m-n-clean-code",
                "content": "**Solution 1: Brute force**\\n```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\\nComplexity\\n- Time: `O(m * min(n, h))`, where `n` is size of binary tree, `m` is size of linked list\\n- Space: `O(h)`, `h` is height of the binary tree.\\n\\n**Solution 2: KMP Search**\\nCan check bare KMP implement on this solution: [28. Implement strStr()](https://leetcode.com/problems/implement-strstr/discuss/535326/java-kmp-solution)\\nIdea:\\n- This problem is the same with problem: find `needle` in `haystack` where `haystack` is the binary tree, `needle` is the linked list.\\n- Convert `needle` linked list to array, so we can jump to any position of the `needle`.\\n- Compute KMP table (LPS) which is **Longest Prefix** also **Suffix**.\\n- KMP Search, where `i++` in string equal to `i.left` or `i.right` in binary tree.\\n```java\\n    int[] needle, lps;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        needle = convertLinkedListToArray(head);\\n        lps = computeKMPTable(needle);\\n        return kmpSearch(root, 0);\\n    }\\n    boolean kmpSearch(TreeNode i, int j) {\\n        if (j == needle.length) return true;\\n        if (i == null) return false;\\n        while (j > 0 && i.val != needle[j]) j = lps[j - 1];\\n        if (i.val == needle[j]) j++;\\n        return kmpSearch(i.left, j) || kmpSearch(i.right, j);\\n    }\\n    int[] computeKMPTable(int[] pattern) {\\n        int n = pattern.length;\\n        int[] lps = new int[n];\\n        for (int i = 1, j = 0; i < n; i++) {\\n            while (j > 0 && pattern[i] != pattern[j]) j = lps[j - 1];\\n            if (pattern[i] == pattern[j]) lps[i] = ++j;\\n        }\\n        return lps;\\n    }\\n    int[] convertLinkedListToArray(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        while (head != null) { list.add(head.val); head = head.next; }\\n        int[] arr = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) arr[i] = list.get(i);\\n        return arr;\\n    }\\n```\\nComplexity\\n- Time: `O(m+n)`, where `n` is size of binary tree, `m` is size of linked list\\n- Space: `O(h+m)`, `h` is height of the binary tree.",
                "solutionTags": [],
                "code": "```java\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n```\n```java\\n    int[] needle, lps;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        needle = convertLinkedListToArray(head);\\n        lps = computeKMPTable(needle);\\n        return kmpSearch(root, 0);\\n    }\\n    boolean kmpSearch(TreeNode i, int j) {\\n        if (j == needle.length) return true;\\n        if (i == null) return false;\\n        while (j > 0 && i.val != needle[j]) j = lps[j - 1];\\n        if (i.val == needle[j]) j++;\\n        return kmpSearch(i.left, j) || kmpSearch(i.right, j);\\n    }\\n    int[] computeKMPTable(int[] pattern) {\\n        int n = pattern.length;\\n        int[] lps = new int[n];\\n        for (int i = 1, j = 0; i < n; i++) {\\n            while (j > 0 && pattern[i] != pattern[j]) j = lps[j - 1];\\n            if (pattern[i] == pattern[j]) lps[i] = ++j;\\n        }\\n        return lps;\\n    }\\n    int[] convertLinkedListToArray(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        while (head != null) { list.add(head.val); head = head.next; }\\n        int[] arr = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) arr[i] = list.get(i);\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525828,
                "title": "possible-reason-for-failing-61st-test-case-accepted",
                "content": "Try checking your code against:\\n```python\\n[1,2,1,2,3]\\n[1,null,2,null,1,2,null,1,null,null,2,null,3]\\n```\\n\\n![image](https://assets.leetcode.com/users/ashishsirohi/image_1583094177.png)\\n\\n\\nAnd the reason being, the new matching path starts somwhere from already matching path. For above example,\\n`1->2->1->2` will match the linked list but matching 3 will fail as the next node in the tree is 1. So, I stopped and checked whether current node matches the head of my linked list (in this case, it does) and I started my next path matching from here and I reached the last node without completely exhausting my linked list and hence return `False` but the correct answer is `True`. The mistake I made was not checking already exhausted path again for the possible start for my next path matching in case of previous failure. Hope it makes sense.\\n\\nHere is my code which was failing for 61st test case:\\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode:\\n                return True\\n            \\n            if not tnode:\\n                return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            else:\\n                lnode = orig if tnode.val != orig.val else orig.next\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        return dfs(root, head, head)\\n```\\n\\nAnd Here is my code for accepted solution:\\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode: return True\\n            \\n            if not tnode: return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            elif tnode.val == orig.val:\\n                lnode = orig.next\\n            else:\\n                return False\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        if not head: return True\\n        if not root: return False\\n        \\n        return (dfs(root, head, head) or self.isSubPath(head, root.left)\\n                or self.isSubPath(head, root.right))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n[1,2,1,2,3]\\n[1,null,2,null,1,2,null,1,null,null,2,null,3]\\n```\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode:\\n                return True\\n            \\n            if not tnode:\\n                return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            else:\\n                lnode = orig if tnode.val != orig.val else orig.next\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        return dfs(root, head, head)\\n```\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def dfs(tnode, orig, lnode):\\n            if not lnode: return True\\n            \\n            if not tnode: return\\n            \\n            if tnode.val == lnode.val:\\n                lnode = lnode.next\\n            elif tnode.val == orig.val:\\n                lnode = orig.next\\n            else:\\n                return False\\n                \\n            if dfs(tnode.left, orig, lnode):\\n                return True\\n            elif dfs(tnode.right, orig, lnode):\\n                return True\\n        \\n        if not head: return True\\n        if not root: return False\\n        \\n        return (dfs(root, head, head) or self.isSubPath(head, root.left)\\n                or self.isSubPath(head, root.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113360,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-99-54-clean-code-and-comment-added",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        //if head val, found in tree\\n        //search path\\n        if(head.val == root.val){\\n            if(searchPath(head, root)) return true;\\n        }\\n        \\n        //path didn\\'t find\\n        //now search in left subtree, \\n        //if didn\\'t found search in right subtree\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean searchPath(ListNode listNode, TreeNode treeNode){\\n        //base cases\\n        //if tree node reched to end,\\n        //check list node reached to end or node\\n        if(treeNode == null) return listNode == null;\\n        \\n        //list node reached to end, it meand found \\n        if(listNode == null) return true;\\n        \\n        //if treeNode val is not match with list val,\\n        //return, no need to search further\\n        if(treeNode.val != listNode.val) return false;\\n        \\n        return searchPath(listNode.next, treeNode.left) \\n            || searchPath(listNode.next, treeNode.right);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        //if head val, found in tree\\n        //search path\\n        if(head.val == root.val){\\n            if(searchPath(head, root)) return true;\\n        }\\n        \\n        //path didn\\'t find\\n        //now search in left subtree, \\n        //if didn\\'t found search in right subtree\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean searchPath(ListNode listNode, TreeNode treeNode){\\n        //base cases\\n        //if tree node reched to end,\\n        //check list node reached to end or node\\n        if(treeNode == null) return listNode == null;\\n        \\n        //list node reached to end, it meand found \\n        if(listNode == null) return true;\\n        \\n        //if treeNode val is not match with list val,\\n        //return, no need to search further\\n        if(treeNode.val != listNode.val) return false;\\n        \\n        return searchPath(listNode.next, treeNode.left) \\n            || searchPath(listNode.next, treeNode.right);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524882,
                "title": "java-o-n-2",
                "content": "```\\nclass Solution {\\n    public static boolean check(TreeNode root, ListNode head) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(head == null) return true;\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return false;\\n        if(root.val != head.val) return false;\\n        return check(root.left, head.next) || check(root.right, head.next);\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        return check(root, head) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean check(TreeNode root, ListNode head) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(head == null) return true;\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return false;\\n        if(root.val != head.val) return false;\\n        return check(root.left, head.next) || check(root.right, head.next);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1121287,
                "title": "c-dynamic-programming-dfs",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<ListNode*, TreeNode*>, bool> m;\\n    bool check(ListNode* head, TreeNode* root, ListNode* ihead){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(m.count({head, root})!=0){\\n            return m[{head, root}];\\n        }\\n        bool o1=false,o2=false;\\n        if(ihead->val==root->val){\\n            o1 = check(ihead->next, root->left, ihead) || check(ihead->next, root->right, ihead);\\n        }\\n        else{\\n            o1 = check(ihead, root->left, ihead) || check(ihead, root->right, ihead);\\n        }\\n        if(head->val==root->val){\\n            o2 = check(head->next, root->left, ihead) || check(head->next, root->right, ihead);\\n        }\\n        return m[{head, root}]=o1||o2;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return check(head, root, head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<ListNode*, TreeNode*>, bool> m;\\n    bool check(ListNode* head, TreeNode* root, ListNode* ihead){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(m.count({head, root})!=0){\\n            return m[{head, root}];\\n        }\\n        bool o1=false,o2=false;\\n        if(ihead->val==root->val){\\n            o1 = check(ihead->next, root->left, ihead) || check(ihead->next, root->right, ihead);\\n        }\\n        else{\\n            o1 = check(ihead, root->left, ihead) || check(ihead, root->right, ihead);\\n        }\\n        if(head->val==root->val){\\n            o2 = check(head->next, root->left, ihead) || check(head->next, root->right, ihead);\\n        }\\n        return m[{head, root}]=o1||o2;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return check(head, root, head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630094,
                "title": "java-recursive-dfs-beats-100-time-and-space-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        //Check if a downward path is found starting from the root node.\\n        boolean ans = check(head, root);\\n        \\n        //If path is not found, check in the left and right subtrees.      \\n        if (root!=null && !ans)\\n        {\\n            ans |= isSubPath(head, root.left);\\n            ans |= isSubPath(head, root.right);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root){\\n        \\n        //If the ListNode is null, we\\'ve reached the end of the list where all values match the ones in the tree. This means we\\'ve found a path.       \\n        if (head==null)\\n            return true;\\n        \\n        //If the TreeNode is null, but the ListNode is not, we\\'ve reached the end of the subtree but not the list, so, return False.\\n        if (root==null)\\n            return false;\\n        \\n        //If the value of the current node matches the next node of the list, try to find a path in the left or right subtree, otherwise return False\\n        if (root.val==head.val)\\n            return check(head.next, root.left) || check(head.next, root.right);\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        //Check if a downward path is found starting from the root node.\\n        boolean ans = check(head, root);\\n        \\n        //If path is not found, check in the left and right subtrees.      \\n        if (root!=null && !ans)\\n        {\\n            ans |= isSubPath(head, root.left);\\n            ans |= isSubPath(head, root.right);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root){\\n        \\n        //If the ListNode is null, we\\'ve reached the end of the list where all values match the ones in the tree. This means we\\'ve found a path.       \\n        if (head==null)\\n            return true;\\n        \\n        //If the TreeNode is null, but the ListNode is not, we\\'ve reached the end of the subtree but not the list, so, return False.\\n        if (root==null)\\n            return false;\\n        \\n        //If the value of the current node matches the next node of the list, try to find a path in the left or right subtree, otherwise return False\\n        if (root.val==head.val)\\n            return check(head.next, root.left) || check(head.next, root.right);\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524852,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        res = []\\n        while head:\\n            res.append(str(head.val))\\n            head = head.next\\n        head = \"\".join(res)\\n    \\n        def dfs(root, path):\\n            if head in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)) or dfs(root.right, path+str(root.val))\\n            \\n        return dfs(root, \"\")\\n```\\n\\n@cool_shark helped improve it.\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        DELIMITER = \\'|\\'\\n        subpath = \\'\\'\\n        while head:\\n            subpath += str(head.val) + DELIMITER\\n            head = head.next\\n    \\n        def dfs(root, path):\\n            if subpath in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)+DELIMITER) or dfs(root.right, path+str(root.val)+DELIMITER)\\n            \\n        return dfs(root, \"\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        res = []\\n        while head:\\n            res.append(str(head.val))\\n            head = head.next\\n        head = \"\".join(res)\\n    \\n        def dfs(root, path):\\n            if head in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)) or dfs(root.right, path+str(root.val))\\n            \\n        return dfs(root, \"\")\\n```\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        DELIMITER = \\'|\\'\\n        subpath = \\'\\'\\n        while head:\\n            subpath += str(head.val) + DELIMITER\\n            head = head.next\\n    \\n        def dfs(root, path):\\n            if subpath in path:\\n                return True\\n            if not root:\\n                return False\\n            return dfs(root.left, path+str(root.val)+DELIMITER) or dfs(root.right, path+str(root.val)+DELIMITER)\\n            \\n        return dfs(root, \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525249,
                "title": "java-exactly-the-same-as-572-subtree-of-another-tree",
                "content": "```\\nclass Solution {\\n //   Listnode cur = null;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(dfs(head, root)) return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean dfs(ListNode h, TreeNode node) {\\n        if(h == null) return true;\\n        if(node == null) return false;\\n        if(node.val == h.val) \\n            return dfs(h.next, node.left) || dfs(h.next, node.right);\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n //   Listnode cur = null;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(dfs(head, root)) return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 524842,
                "title": "concise-10-lines-c-recursion-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(h(head, root)) return true;\\n        if(!head) return true;\\n        if(!root) return false;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool h(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val != root->val ) return false;\\n        return h(head->next, root->left) || h(head->next, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(h(head, root)) return true;\\n        if(!head) return true;\\n        if(!root) return false;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool h(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val != root->val ) return false;\\n        return h(head->next, root->left) || h(head->next, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525615,
                "title": "c-simple-8-lines-solution-beats-100-space-and-85-time",
                "content": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL) return false;\\n        return find(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n    bool find(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(root->val == head->val)\\n            return find(head->next,root->left) || find(head->next,root->right);\\n        else return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL) return false;\\n        return find(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n    bool find(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(root->val == head->val)\\n            return find(head->next,root->left) || find(head->next,root->right);\\n        else return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967733,
                "title": "easy-c-faster-than-95-less-memory-than-57",
                "content": "The main approach here is to call a recursive function to:\\n* **Check every node** if it\\'s a starting point of the match sequence in the main isSubPath function.\\n* If yes, try to find a match sequence using the match function for the downward left and right paths\\nIf you like my appraoch , please **Up vote**  it \\uD83D\\uDD25\\n\\n```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n       if(root==nullptr) return false;//if we reached the end of the tree\\n        if(match(head,root)) return true;//if we find a path to match the pattern\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);//Search for the pattern in left subtree and right subtree\\n    }\\n    bool match(ListNode* head, TreeNode* root)\\n    {\\n        if(!head) return true;//if the head is null then we found a path\\n        if(!root||root->val!=head->val) return false;//we didn\\'t find a match starting from this node\\n        return match(head->next,root->left)||match(head->next,root->right);//Continue matching from this node downwards\\n    }\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n       if(root==nullptr) return false;//if we reached the end of the tree\\n        if(match(head,root)) return true;//if we find a path to match the pattern\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);//Search for the pattern in left subtree and right subtree\\n    }\\n    bool match(ListNode* head, TreeNode* root)\\n    {\\n        if(!head) return true;//if the head is null then we found a path\\n        if(!root||root->val!=head->val) return false;//we didn\\'t find a match starting from this node\\n        return match(head->next,root->left)||match(head->next,root->right);//Continue matching from this node downwards\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2059884,
                "title": "a-test-case-suggested-to-avoid-failing-the-61st-test-case",
                "content": "I would suggest adding the following test case prior to the 61st test case.\\n\\n```\\n[1,2,3]\\n[1,4,null,2,null,null,3]\\n```\\n\\n\\nBelow is the procedure to find out why it is helpful.\\n\\nI wrote some immature code snipet and failed the 61st test case. It\\'s quite long and inconvenient to debug the root cause. Reffering to the post https://leetcode.com/problems/linked-list-in-binary-tree/discuss/525828/Possible-reason-for-failing-61st-Test-Case-Accepted, the author enumerate a test case which might lead to the failure. Howerver my code did pass the short test case and still got WA in the 61st one. It took me quite a while to find out my bug.\\n\\nMy original error code:\\n\\n```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        if(head->val==root->val)    {\\n            return isSubPath(head->next,root->left) || isSubPath(head->next,root->right);  // *** Error \\n        }\\n        else\\n            return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n```\\n\\nThe two isSubPath procedure in //*** Error line is misused, the function will return true if there is a gap between the first element and latter elements in the list. For example, the list is [1]->[2]->[3], if there is a sequence downgrading in binary tree such as 1,4,2,3 or 1,5,2,3 or 1,4,5,6,2,3, the function will reture true and get WA.\\n\\nSo it\\'s necessary to add a short and simple test case before the interminable 61st case.\\n\\nAfter changing my code to below, it passed all the test cases and got AC.\\n\\n```\\nclass Solution {\\n    bool isStartPath(ListNode* head, TreeNode* root) {\\n        if (head==nullptr) return true;\\n        if (root==nullptr) return false;\\n        return (head->val==root->val) && (isStartPath(head->next, root->left) || isStartPath(head->next, root->right));\\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        return head->val==root->val && isStartPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[1,2,3]\\n[1,4,null,2,null,null,3]\\n```\n```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        if(head->val==root->val)    {\\n            return isSubPath(head->next,root->left) || isSubPath(head->next,root->right);  // *** Error \\n        }\\n        else\\n            return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n```\n```\\nclass Solution {\\n    bool isStartPath(ListNode* head, TreeNode* root) {\\n        if (head==nullptr) return true;\\n        if (root==nullptr) return false;\\n        return (head->val==root->val) && (isStartPath(head->next, root->left) || isStartPath(head->next, root->right));\\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==nullptr)   return true;\\n        if(root==nullptr)   return false;\\n        return head->val==root->val && isStartPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940570,
                "title": "6-lines-code-beats-94",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (isStartPath(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right));\\n    }\\n\\n    private boolean isStartPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (head.val == root.val) && (isStartPath(head.next, root.left) || isStartPath(head.next, root.right));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (isStartPath(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right));\\n    }\\n\\n    private boolean isStartPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (head.val == root.val) && (isStartPath(head.next, root.left) || isStartPath(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525799,
                "title": "java-kmp-algorithm-same-idea-as-28",
                "content": "***I\\'m very surprised that the brute force approach is accepted, I think this problem aims to test if you know how to use KMP for quick pattern lookup. (also I don\\'t think this is a good interview question as KMP shouldn\\'t be required for tech interviews)***\\n\\nFirst of all, if you don\\'t know how to use KMP to match a pattern within a string, please go [Implement strStr()](https://leetcode.com/problems/implement-strstr/), the core part is to use a LPS (longest prefix suffix) array to quickly jump to possible matching index in the pattern string when the current position doesn\\'t result in a match\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int m = haystack.length();\\n        int n = needle.length();\\n        if (n > m) {\\n            return -1;\\n        }\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        int[] lps = getLPS(needle);\\n        for (int i = 0; i < n; i++) {\\n            System.out.println(lps[i]);\\n        }\\n        \\n        int i = 0, j = 0;\\n        while (i < m) {\\n            System.out.println(i + \"   \" + j);\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                if (j == n - 1) {\\n                    return i - n + 1;\\n                }\\n                i++;\\n                j++;\\n            } else if (j > 0) {\\n                j = lps[j-1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[] getLPS(String needle) {\\n        int n = needle.length();\\n        char[] chars = needle.toCharArray();\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (chars[i] == chars[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThis problem is essentially just a variation of the above string KMP issue\\n* we iterate through the linked list to build a LPS array\\n* during tree iteration, we track an index on the list\\n\\t* if the index reaches to the end of the list, we\\'re done\\n\\t* if list[index] matches current tree node, we increment index by 1 and move to current node\\'s child nodes for further check\\n\\t* if list[index] doesn\\'t match current tree node, we use LPS array to switch index to previous possible match position\\n\\t\\t* if the new index position matches current tree node, we move forward to current node\\'s child nodes with index + 1\\n\\t\\t* if index falls back to 0 and still we don\\'t find a match, means current tree node is not useful, we move to its child nodes with index = 0\\n```\\nclass Solution {\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        // convert linked list to a list array\\n        List<Integer> list_elements = new LinkedList<>();\\n        while (head != null) {\\n            list_elements.add(head.val);\\n            head = head.next;\\n        }\\n        Integer[] list = list_elements.toArray(new Integer[0]);\\n        // build LPS (longest prefix suffix array)\\n        int[] lps = getLPS(list);\\n        \\n        return check(lps, list, 0, root);\\n    }\\n    \\n    public boolean check(int[] lps, Integer[] list, int index, TreeNode root) {\\n        if (index == list.length) {\\n            return true;\\n        }\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (list[index] == root.val) {\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        } else {\\n            boolean res = false;\\n            while (index > 0 && list[index] != root.val) {\\n                index = lps[index-1];\\n            }\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        }\\n    }\\n    \\n    private int[] getLPS(Integer[] list) {\\n        int n = list.length;\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (list[i] == list[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int m = haystack.length();\\n        int n = needle.length();\\n        if (n > m) {\\n            return -1;\\n        }\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        int[] lps = getLPS(needle);\\n        for (int i = 0; i < n; i++) {\\n            System.out.println(lps[i]);\\n        }\\n        \\n        int i = 0, j = 0;\\n        while (i < m) {\\n            System.out.println(i + \"   \" + j);\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                if (j == n - 1) {\\n                    return i - n + 1;\\n                }\\n                i++;\\n                j++;\\n            } else if (j > 0) {\\n                j = lps[j-1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[] getLPS(String needle) {\\n        int n = needle.length();\\n        char[] chars = needle.toCharArray();\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (chars[i] == chars[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        // convert linked list to a list array\\n        List<Integer> list_elements = new LinkedList<>();\\n        while (head != null) {\\n            list_elements.add(head.val);\\n            head = head.next;\\n        }\\n        Integer[] list = list_elements.toArray(new Integer[0]);\\n        // build LPS (longest prefix suffix array)\\n        int[] lps = getLPS(list);\\n        \\n        return check(lps, list, 0, root);\\n    }\\n    \\n    public boolean check(int[] lps, Integer[] list, int index, TreeNode root) {\\n        if (index == list.length) {\\n            return true;\\n        }\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (list[index] == root.val) {\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        } else {\\n            boolean res = false;\\n            while (index > 0 && list[index] != root.val) {\\n                index = lps[index-1];\\n            }\\n            return check(lps, list, index + 1, root.left) | check(lps, list, index + 1, root.right);\\n        }\\n    }\\n    \\n    private int[] getLPS(Integer[] list) {\\n        int n = list.length;\\n        int[] res = new int[n];\\n        int i = 0, j = 1;\\n        while (j < n) {\\n            if (list[i] == list[j]) {\\n                res[j++] = ++i;\\n            } else if (i > 0) {\\n                i = res[i-1];\\n            } else {\\n                res[j++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524867,
                "title": "can-anyone-tell-me-why-my-code-cannot-pass-the-59th-case",
                "content": "I think the problem is that the downward pass must be continuous. I just noticed that it is stated the downward pass is connected\\n\\nThis is the accepted answer 1ms 100% time complexity O(n^2)\\n\\nclass Solution {\\n\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null) return true;\\n        if(root==null) return false;\\n        return root.val!=head.val? \\n\\t\\t\\tisSubPath(head, root.left)||isSubPath(head, root.right):\\n            dfs(head.next, root.left)||dfs(head.next, root.right)||isSubPath(head, root.left)||isSubPath(head, root.right);\\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root){\\n        if(head==null) return true;\\n        if(root==null||root.val!=head.val){\\n            return false;\\n        }\\n        return dfs(head.next,root.left)||dfs(head.next,root.right);\\n    }  \\n}\\n\\n\\nwrong answer\\nclass Solution {\\n\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root==null){\\n            if(head==null) return true;\\n            return false;\\n        }\\n        if(head==null) return true;\\n        if(root.val==head.val){\\n            head = head.next;\\n        }\\n        return isSubPath(head, root.left)||isSubPath(head, root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null) return true;\\n        if(root==null) return false;\\n        return root.val!=head.val? \\n\\t\\t\\tisSubPath(head, root.left)||isSubPath(head, root.right):\\n            dfs(head.next, root.left)||dfs(head.next, root.right)||isSubPath(head, root.left)||isSubPath(head, root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2621739,
                "title": "6-line-consise-cose-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool s(ListNode* h, TreeNode* r) {\\n        if(!h) return 1;\\n        if(!r) return 0;\\n        if(r->val == h->val) return s(h->next,r->left) || s(h->next,r->right) ;\\n        return 0;\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return 0;\\n        if(s(head,root)) return 1;\\n        return isSubPath(head,root->left) || isSubPath(head,root->right) ;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool s(ListNode* h, TreeNode* r) {\\n        if(!h) return 1;\\n        if(!r) return 0;\\n        if(r->val == h->val) return s(h->next,r->left) || s(h->next,r->right) ;\\n        return 0;\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return 0;\\n        if(s(head,root)) return 1;\\n        return isSubPath(head,root->left) || isSubPath(head,root->right) ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378283,
                "title": "beginner-friendly-java-javascrpit-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null)    return false;\\n        if(issame(head, root))  return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean issame(ListNode head, TreeNode root) {\\n        if(head == null)    return true;\\n        if(root == null)    return false;\\n        if(head.val != root.val)    return false;\\n        return issame(head.next, root.left) || issame(head.next, root.right);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar isSubPath = function(head, root) {\\n    if(!root)    return false\\n    if(issame(head, root))  return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction issame(head, root){\\n    if(!head)   return true\\n    if(!root)   return false\\n    if(head.val != root.val)    return false\\n    return issame(head.next, root.left) || issame(head.next, root.right)\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        if not root:    \\n            return False\\n        if self.issame(head, root):\\n            return True\\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n    def issame(self, head, root):\\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if head.val != root.val:\\n            return False\\n        return self.issame(head.next, root.left) or self.issame(head.next, root.right)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null)    return false;\\n        if(issame(head, root))  return true;\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    private boolean issame(ListNode head, TreeNode root) {\\n        if(head == null)    return true;\\n        if(root == null)    return false;\\n        if(head.val != root.val)    return false;\\n        return issame(head.next, root.left) || issame(head.next, root.right);\\n    }\\n}\\n```\n```\\nvar isSubPath = function(head, root) {\\n    if(!root)    return false\\n    if(issame(head, root))  return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction issame(head, root){\\n    if(!head)   return true\\n    if(!root)   return false\\n    if(head.val != root.val)    return false\\n    return issame(head.next, root.left) || issame(head.next, root.right)\\n};\\n```\n```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        if not root:    \\n            return False\\n        if self.issame(head, root):\\n            return True\\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n    def issame(self, head, root):\\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if head.val != root.val:\\n            return False\\n        return self.issame(head.next, root.left) or self.issame(head.next, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525211,
                "title": "python-sol-by-dfs-75-w-hint-and-diagram",
                "content": "Python sol by DFS.\\n\\n---\\n**Hint**:\\n\\nThink of *DFS*\\n\\nThink of *path string representation*\\n\\nThe given input linked list is a subpath of binary tree, if and only if, \\nthe **path string of linked list** is a **substring** among the **path strings of binary tree**.\\n\\n---\\n\\n**Diagram with example**:\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583046952.png)\\n\\n\\n\\n---\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def string_of_linked_list( head: ListNode ):\\n            \\n            linked_list_string = \\'\\'\\n            cur = head\\n            \\n            while cur:\\n                linked_list_string += str( cur.val ) + \\',\\'\\n                cur = cur.next\\n                \\n            return linked_list_string\\n                \\n        # ----------------------------------------------------\\n        \\n        # Get the path string of linked list\\n        linked_list_string = string_of_linked_list( head )\\n        \\n        # ----------------------------------------------------\\n            \\n        def dfs( node: TreeNode, path_string: str) -> bool:\\n            \\n            if not node:\\n                \\n                # If path string of binary tree includes path string of linked list, \\n                # then Accept and return True\\n                if path_string.find(linked_list_string) != -1:\\n                    return True\\n                else:\\n                    return False\\n                \\n                \\n            else:\\n\\n                # Update path string of binary tree, and DFS down to next level\\n\\n                path_string += str( node.val) + \\',\\'\\n                return dfs( node.left, path_string ) or dfs( node.right, path_string )\\n        \\n        # -----------------------------------------------------\\n        \\n        return dfs( root, \\'\\')\\n```\\n\\n---\\n\\nShare another DFS implementation\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(list_cur: ListNode, tree_cur:ListNode):\\n            \\n            if not list_cur:\\n                # current linked list is a subpath of given tree\\n                return True\\n            \\n            if not tree_cur:\\n                # current linked list is not a subpath of given tree\\n                return False\\n            \\n            # node value check, and keep checking on next level with DFS\\n            return list_cur.val == tree_cur.val and ( dfs(list_cur.next, tree_cur.left) or dfs(list_cur.next, tree_cur.right) )\\n            \\n        # ------------------------------------------------------\\n        \\n        if not head:\\n            # linked list is empty\\n            return True\\n        \\n        if not root:\\n            # tree is empty\\n            return False\\n        \\n        # try to match linked list with given tree in DFS\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about str.find()](https://docs.python.org/3/library/stdtypes.html?highlight=str%20find#str.find)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        def string_of_linked_list( head: ListNode ):\\n            \\n            linked_list_string = \\'\\'\\n            cur = head\\n            \\n            while cur:\\n                linked_list_string += str( cur.val ) + \\',\\'\\n                cur = cur.next\\n                \\n            return linked_list_string\\n                \\n        # ----------------------------------------------------\\n        \\n        # Get the path string of linked list\\n        linked_list_string = string_of_linked_list( head )\\n        \\n        # ----------------------------------------------------\\n            \\n        def dfs( node: TreeNode, path_string: str) -> bool:\\n            \\n            if not node:\\n                \\n                # If path string of binary tree includes path string of linked list, \\n                # then Accept and return True\\n                if path_string.find(linked_list_string) != -1:\\n                    return True\\n                else:\\n                    return False\\n                \\n                \\n            else:\\n\\n                # Update path string of binary tree, and DFS down to next level\\n\\n                path_string += str( node.val) + \\',\\'\\n                return dfs( node.left, path_string ) or dfs( node.right, path_string )\\n        \\n        # -----------------------------------------------------\\n        \\n        return dfs( root, \\'\\')\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(list_cur: ListNode, tree_cur:ListNode):\\n            \\n            if not list_cur:\\n                # current linked list is a subpath of given tree\\n                return True\\n            \\n            if not tree_cur:\\n                # current linked list is not a subpath of given tree\\n                return False\\n            \\n            # node value check, and keep checking on next level with DFS\\n            return list_cur.val == tree_cur.val and ( dfs(list_cur.next, tree_cur.left) or dfs(list_cur.next, tree_cur.right) )\\n            \\n        # ------------------------------------------------------\\n        \\n        if not head:\\n            # linked list is empty\\n            return True\\n        \\n        if not root:\\n            # tree is empty\\n            return False\\n        \\n        # try to match linked list with given tree in DFS\\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301573,
                "title": "java-beats-of-java-submissions-well-explained",
                "content": "If helpful do consider ***upvote***\\n```\\nclass Solution {\\n    \\n    public boolean isSamePath(ListNode head, TreeNode root){\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n\\n        if(root.val == head.val){//if root and head values are same then check if root left or root right tree downwpath is same as head.next linked list\\n            if(isSamePath(head.next,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where\\n            \\n            if(isSamePath(head.next,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        }\\n\\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, return false\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n        \\n\\n        if(root.val==head.val){\\n            if(isSamePath(head,root)) return true;//if linked list is present in subtree of root node then return true no need to check elsewhere\\n        }\\n        // if root.val is not equal to head.val then we check for the linked list in ledt sub tree and right sub tree OR if root.val was equal to head.val but somehow\\n        // remaning linkedlist is not similar to the downward path of the the root node then also we try to check in left and right subtree\\n        \\n        if(isSubPath(head,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where       \\n        \\n        if(isSubPath(head,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        \\n        \\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, retun false\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean isSamePath(ListNode head, TreeNode root){\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n\\n        if(root.val == head.val){//if root and head values are same then check if root left or root right tree downwpath is same as head.next linked list\\n            if(isSamePath(head.next,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where\\n            \\n            if(isSamePath(head.next,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        }\\n\\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, return false\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if(head==null) return true;//linked list all nodes present in tree, return tree\\n        if(root==null)  return false; // linked list is still remaning but root is at null, return false\\n        \\n\\n        if(root.val==head.val){\\n            if(isSamePath(head,root)) return true;//if linked list is present in subtree of root node then return true no need to check elsewhere\\n        }\\n        // if root.val is not equal to head.val then we check for the linked list in ledt sub tree and right sub tree OR if root.val was equal to head.val but somehow\\n        // remaning linkedlist is not similar to the downward path of the the root node then also we try to check in left and right subtree\\n        \\n        if(isSubPath(head,root.left)) return true;// if linked list is present in left side of root node then return true no need to check else where       \\n        \\n        if(isSubPath(head,root.right)) return true;// if linked list is present in not present in left side then check right side of root node then return true if linkedlist is present\\n        \\n        \\n        return false;// if linked list was found alredy then it was return before meeting this line, and if recursion is approching here that means no linked List found at this path, retun false\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675485,
                "title": "c-bfs-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/linked-list-in-binary-tree/submissions/\\n    \\n    Idea is do BFS of tree and once we get the a node which has the same value as that\\n    of the list head, then we start DFS of tree from that node and list head to check if that\\n    path exists from that node.\\n    \\n*/\\nclass Solution {\\npublic:\\n    bool checkPath(ListNode* head, TreeNode* root) {\\n        // if the list has ended\\n        if(!head)\\n            return true;\\n        // if the list hasnt ended but tree has\\n        if(!root)\\n            return false;\\n\\n        return head->val == root->val && (checkPath(head->next, root->left) ||\\n                                         checkPath(head->next, root->right));\\n    }\\n\\n    // TC: O(M * min(M, N)), M: size of linked list, N: No. of nodes in tree\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.emplace(root);\\n\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n\\n            // check if the current node match the list head\\n            if(curr->val == head->val && checkPath(head, curr))\\n                return true;\\n\\n            if(curr->left)\\n                q.emplace(curr->left);\\n            if(curr->right)\\n                q.emplace(curr->right);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/linked-list-in-binary-tree/submissions/\\n    \\n    Idea is do BFS of tree and once we get the a node which has the same value as that\\n    of the list head, then we start DFS of tree from that node and list head to check if that\\n    path exists from that node.\\n    \\n*/\\nclass Solution {\\npublic:\\n    bool checkPath(ListNode* head, TreeNode* root) {\\n        // if the list has ended\\n        if(!head)\\n            return true;\\n        // if the list hasnt ended but tree has\\n        if(!root)\\n            return false;\\n\\n        return head->val == root->val && (checkPath(head->next, root->left) ||\\n                                         checkPath(head->next, root->right));\\n    }\\n\\n    // TC: O(M * min(M, N)), M: size of linked list, N: No. of nodes in tree\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.emplace(root);\\n\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n\\n            // check if the current node match the list head\\n            if(curr->val == head->val && checkPath(head, curr))\\n                return true;\\n\\n            if(curr->left)\\n                q.emplace(curr->left);\\n            if(curr->right)\\n                q.emplace(curr->right);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897130,
                "title": "c-easy-to-understand-well-commented-common-mistake-explained",
                "content": "### **Intuition**\\nThe approach is to check whether the path:\\ni. starts from the current node in the tree\\nii. exists in the left subtree\\niii. exists in the right subtree\\n\\n**Why recursion?** Because in this type of situation, when we need to check for the same thing again and again on subproblems, recursion seems quite convenient and intuitive.\\n\\n### **A mistake I made initially**\\nThe first solution I came up with was to check whether the current value of the head equals the node value or not. If yes, then check in the left and right subtree for the next value in the linked list, and, if not, then check in the left and right subtree for the current value of the head.\\n```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)return true;\\n        if(!root) return false;\\n        if(head->val==root->val){\\n            return isSubPath(head->next, root->left) or isSubPath(head->next, root->right);\\n        }\\n        else{\\n            return isSubPath(head,root->left) or isSubPath(head,root->right);\\n        }\\n    }\\n```\\nWhat\\'s wrong with this? If some part of our LinkedList matches a path in the tree, then it will keep checking in the left and right part for the next value of the head without checking for the initial values.\\nExample: \\nLinked list: [2,1,2] \\nTree: [2,null, 1, null, 5, null, 2, null, 1, null, 5,null,null]\\n\\n![image](https://assets.leetcode.com/users/images/8bf3dc48-c1a1-4084-9d6d-e7b6d8866027_1648634716.2691994.png)\\n\\n\\n\\nIn the tree, [2,1,2] don\\'t exist, but still, the code will return true. Because it will first encounter 2, then it will search for 1 in the remaining part and then, similarly, it will search for 2 in the remaining tree without checking for the previous elements (2 and 1). \\n\\n## **Code**\\n```\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(!head) return true;  //if we reach the end of linkedlist return true\\n        if(!root)return false;  //if we have exhausted the current path in the tree return false\\n        \\n        return (head->val==root->val) and (dfs(head->next,root->left) or dfs(head->next,root->right)); \\n        //check for current value of tree and ll and then recurse to check for the remaining part\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);  //dfs will check whether the path starts from the current node or not \\n        // if dfs returns false, then isSubPath will recurse to check for the path in the remaining tree.\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)return true;\\n        if(!root) return false;\\n        if(head->val==root->val){\\n            return isSubPath(head->next, root->left) or isSubPath(head->next, root->right);\\n        }\\n        else{\\n            return isSubPath(head,root->left) or isSubPath(head,root->right);\\n        }\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(!head) return true;  //if we reach the end of linkedlist return true\\n        if(!root)return false;  //if we have exhausted the current path in the tree return false\\n        \\n        return (head->val==root->val) and (dfs(head->next,root->left) or dfs(head->next,root->right)); \\n        //check for current value of tree and ll and then recurse to check for the remaining part\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root) return false;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);  //dfs will check whether the path starts from the current node or not \\n        // if dfs returns false, then isSubPath will recurse to check for the path in the remaining tree.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684678,
                "title": "java-dfs",
                "content": "Ref: https://leetcode.com/problems/linked-list-in-binary-tree/discuss/524881/Python-Recursive-Solution-O(N)-Time\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return root.val == head.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return root.val == head.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549091,
                "title": "accepted-c-solution-beats-100",
                "content": "Runtime: 16 ms, faster than 100.00% of C online submissions for Linked List in Binary Tree.\\nMemory Usage: 13.6 MB, less than 100.00% of C online submissions for Linked List in Binary Tree.\\n```\\n    bool findSubPath(struct ListNode* head,struct TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(struct ListNode* head, struct TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "Runtime: 16 ms, faster than 100.00% of C online submissions for Linked List in Binary Tree.\\nMemory Usage: 13.6 MB, less than 100.00% of C online submissions for Linked List in Binary Tree.\\n```\\n    bool findSubPath(struct ListNode* head,struct TreeNode* root) {\\n        if (!head) return true;\\n        if (!root) return false;\\n        return head->val == root->val && (findSubPath(head->next, root->left) || findSubPath(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(struct ListNode* head, struct TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3109084,
                "title": "java-dfs-dfs-explained-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       // dfs with dfs \\n        \\n        return helper(head, root);\\n    }\\n    // implementing dfs with dfs \\n    \\n    // first dfs which checks from every node in the binary tree \\n    public boolean helper(ListNode head, TreeNode root)\\n    {\\n        if(root ==null)\\n            return false;\\n        if(dfs(head, root))\\n        {\\n            return true;\\n        }\\n        // if condns for if we get true then directly return true, no need to check more \\n        if(helper(head, root.left))\\n            return true;\\n          \\n        \\n        if(helper(head, root.right))\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    // second dfs which looks for the linked list \\n    public boolean dfs(ListNode head, TreeNode root)\\n    {\\n        // if we reach the end of linked list return true \\n        if(head ==null)\\n            return true;\\n        \\n        // return statement -> if linked list val doesnt match the binary tree node value \\n        if(root==null ||  head.val != root.val)\\n            return false;\\n        \\n        // return true when got true \\n        if(dfs(head.next, root.left))\\n            return true;\\n        \\n        if(dfs(head.next, root.right))\\n            return true;\\n        \\n        return false;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       // dfs with dfs \\n        \\n        return helper(head, root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2379894,
                "title": "c-solution-dfs-8lines-fast-than-98",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head,TreeNode* root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        return head->val==root->val&&(dfs(head->next,root->right)||dfs(head->next, root->left));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(!head) return true;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool dfs(ListNode* head,TreeNode* root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        return head->val==root->val&&(dfs(head->next,root->right)||dfs(head->next, root->left));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(!head) return true;\\n        return dfs(head,root) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879827,
                "title": "c-simple-dfs-recursion",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool inpath(ListNode* head, TreeNode* root)\\n    {\\n        if(root==NULL && head!=NULL)\\n            return false;\\n    \\n        if(head==NULL)\\n            return true;\\n    \\n        if(head->val!=root->val)\\n            return false;\\n        \\n        // if(root->left && head->next && root->left->val == head->next->val)\\n        bool b1=inpath(head->next,root->left);\\n        \\n        //if(root->right && head->next && root->right->val == head->next->val)\\n        bool b2=inpath(head->next,root->right);\\n    \\n        return b1||b2;\\n    \\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {        \\n        \\n        if(root==NULL)\\n            return false;\\n    \\n        if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n    \\n        bool b1=isSubPath(head,root->left);\\n        bool b2=isSubPath(head,root->right);\\n    \\n        return b1 || b2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool inpath(ListNode* head, TreeNode* root)\\n    {\\n        if(root==NULL && head!=NULL)\\n            return false;\\n    \\n        if(head==NULL)\\n            return true;\\n    \\n        if(head->val!=root->val)\\n            return false;\\n        \\n        // if(root->left && head->next && root->left->val == head->next->val)\\n        bool b1=inpath(head->next,root->left);\\n        \\n        //if(root->right && head->next && root->right->val == head->next->val)\\n        bool b2=inpath(head->next,root->right);\\n    \\n        return b1||b2;\\n    \\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {        \\n        \\n        if(root==NULL)\\n            return false;\\n    \\n        if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n    \\n        bool b1=isSubPath(head,root->left);\\n        bool b2=isSubPath(head,root->right);\\n    \\n        return b1 || b2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368483,
                "title": "c-easy-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, ListNode* head){\\n        if(head==NULL) return true;\\n        if(root==NULL || root->val!=head->val) return false;\\n        return dfs(root->left, head->next) || dfs(root->right, head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return false;\\n        if(root==NULL) return false;\\n        if(dfs(root, head)) return true;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, ListNode* head){\\n        if(head==NULL) return true;\\n        if(root==NULL || root->val!=head->val) return false;\\n        return dfs(root->left, head->next) || dfs(root->right, head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return false;\\n        if(root==NULL) return false;\\n        if(dfs(root, head)) return true;\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532774,
                "title": "python-solution",
                "content": "```\\ndef isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val and self.isPathExists(head, root):\\n\\t\\treturn True\\n\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n        \\ndef isPathExists(self, head, root):\\n\\tif head==None: \\n\\t\\treturn True\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val:\\n\\t\\treturn self.isPathExists(head.next, root.left) or self.isPathExists(head.next, root.right)\\n\\telse:\\n\\t\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val and self.isPathExists(head, root):\\n\\t\\treturn True\\n\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n        \\ndef isPathExists(self, head, root):\\n\\tif head==None: \\n\\t\\treturn True\\n\\tif root==None:\\n\\t\\treturn False\\n\\tif head.val==root.val:\\n\\t\\treturn self.isPathExists(head.next, root.left) or self.isPathExists(head.next, root.right)\\n\\telse:\\n\\t\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 526031,
                "title": "java-one-pass-solution-keep-all-possible-lists-in-a-list",
                "content": "One-Pass Solution: A different way to solve this question just for reference.  \\n\\nHave a list to store all possible remaining linkedlist avoid searching repeatedly. For every node, we need to check if it could be the real head of the list (so we add the head to our list every time). Keep searching and passing all possible lists until we reach the end of one of lists.  \\n\\n```java\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n\\tList<ListNode> list = new LinkedList<>();\\n\\treturn helper(root, list, head);\\n}\\n\\nprivate boolean helper(TreeNode root, List<ListNode> list, ListNode head) {\\n\\n\\tif (root == null) return false;\\n\\tlist.add(head);\\n\\n\\tList<ListNode> nextList = new LinkedList<>();\\n\\n\\tfor (ListNode node : list) {\\n\\t\\tif (root.val == node.val) {\\n\\t\\t\\tif (node.next == null) return true;\\n\\t\\t\\telse nextList.add(node.next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn helper(root.left, nextList, head) || helper(root.right, nextList, head);\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n\\tList<ListNode> list = new LinkedList<>();\\n\\treturn helper(root, list, head);\\n}\\n\\nprivate boolean helper(TreeNode root, List<ListNode> list, ListNode head) {\\n\\n\\tif (root == null) return false;\\n\\tlist.add(head);\\n\\n\\tList<ListNode> nextList = new LinkedList<>();\\n\\n\\tfor (ListNode node : list) {\\n\\t\\tif (root.val == node.val) {\\n\\t\\t\\tif (node.next == null) return true;\\n\\t\\t\\telse nextList.add(node.next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn helper(root.left, nextList, head) || helper(root.right, nextList, head);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525131,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef dfs(self, head, root):\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif head.val == root.val:\\n\\t\\t\\t\\treturn self.dfs(head.next, root.left) or self.dfs(head.next, root.right) \\n\\n\\t\\t\\treturn False\\n\\n\\n\\t\\tdef isSubPath(self, head, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type head: ListNode\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif self.dfs(head, root):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef dfs(self, head, root):\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif head.val == root.val:\\n\\t\\t\\t\\treturn self.dfs(head.next, root.left) or self.dfs(head.next, root.right) \\n\\n\\t\\t\\treturn False\\n\\n\\n\\t\\tdef isSubPath(self, head, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type head: ListNode\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif self.dfs(head, root):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n",
                "codeTag": "Java"
            },
            {
                "id": 525026,
                "title": "java-100-runtime-with-explanations",
                "content": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        return isSubPath(head, root, false);\\n    }\\n    \\n    private boolean isSubPath(ListNode head, TreeNode root, boolean listElementFound) {\\n        if (head == null) return true; // all list element are found\\n        if (root == null) return false; // reached the bottom of the tree\\n        if (listElementFound && root.val != head.val) return false; // if list element was previously found, but the current list element is not matching to current tree node\\n        \\n        if (root.val == head.val) { // curr node matches the first element of the list\\n            if (isSubPath(head.next, root.left, true) ||\\n                isSubPath(head.next, root.right, true)) return true;\\n            \\n            if (listElementFound) return false; // if list element was previously found, but the next list element is not found\\n        }\\n        return isSubPath(head, root.left, false) || isSubPath(head, root.right, false);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        return isSubPath(head, root, false);\\n    }\\n    \\n    private boolean isSubPath(ListNode head, TreeNode root, boolean listElementFound) {\\n        if (head == null) return true; // all list element are found\\n        if (root == null) return false; // reached the bottom of the tree\\n        if (listElementFound && root.val != head.val) return false; // if list element was previously found, but the current list element is not matching to current tree node\\n        \\n        if (root.val == head.val) { // curr node matches the first element of the list\\n            if (isSubPath(head.next, root.left, true) ||\\n                isSubPath(head.next, root.right, true)) return true;\\n            \\n            if (listElementFound) return false; // if list element was previously found, but the next list element is not found\\n        }\\n        return isSubPath(head, root.left, false) || isSubPath(head, root.right, false);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003253,
                "title": "easy-recursive-java-beats-99-69-memory-usage-less-than-86-72",
                "content": "**Run time:** O( M\\\\*N)\\n*M: size of LinkedList\\nN: Number of nodes of Tree*\\n\\nWe call the **match** function whenever the **head** of linkedList is found to be equal to **root.val**\\n\\n```\\nclass Solution {\\n    public boolean match(ListNode head, TreeNode root){\\n        if(head == null) return true;\\n        \\n        if(root == null) return false;\\n        \\n        if(head.val != root.val) return false;\\n        \\n        return match(head.next, root.left) || match(head.next, root.right);\\n            \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\n        if(head == null) return true;\\n        if(root == null) return false;\\n                \\n        if(head.val == root.val)\\n            if(match(head, root)) return true;\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean match(ListNode head, TreeNode root){\\n        if(head == null) return true;\\n        \\n        if(root == null) return false;\\n        \\n        if(head.val != root.val) return false;\\n        \\n        return match(head.next, root.left) || match(head.next, root.right);\\n            \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\n        if(head == null) return true;\\n        if(root == null) return false;\\n                \\n        if(head.val == root.val)\\n            if(match(head, root)) return true;\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870024,
                "title": "cpp-recursive-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root && head) return false;\\n        bool check = head->val == root->val;\\n        if(!check) return false;\\n        bool left = isPath(head->next, root->left);\\n        bool right = isPath(head->next, root->right);\\n        return (left || right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true;\\n        if(!root && head) return false;\\n        bool check = head->val == root->val;\\n        if(!check) return false;\\n        bool left = isPath(head->next, root->left);\\n        bool right = isPath(head->next, root->right);\\n        return (left || right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818806,
                "title": "c-dfs-approach-easy-to-understand",
                "content": "***Runtime: 52 ms, faster than 80.44% of C++ online submissions for Linked List in Binary Tree.\\nMemory Usage: 31.9 MB, less than 81.61% of C++ online submissions for Linked List in Binary Tree.***\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(isEqual(head, root)){\\n                return true;\\n            }\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n        }\\n        return false;\\n    }\\n    bool isEqual(ListNode* head, TreeNode* root){\\n        if(!head){\\n            return true;\\n        }\\n        if(!root){\\n            return false;\\n        }\\n        return head->val == root->val && (isEqual(head->next, root->left) || isEqual(head->next, root->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(isEqual(head, root)){\\n                return true;\\n            }\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n        }\\n        return false;\\n    }\\n    bool isEqual(ListNode* head, TreeNode* root){\\n        if(!head){\\n            return true;\\n        }\\n        if(!root){\\n            return false;\\n        }\\n        return head->val == root->val && (isEqual(head->next, root->left) || isEqual(head->next, root->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525230,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool IsSubPath(ListNode head, TreeNode root) \\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return IsSubPathFromRoot(head, root)  \\n               || IsSubPath(head, root.left) \\n               || IsSubPath(head, root.right);\\n    }\\n    \\n    private bool IsSubPathFromRoot(ListNode head, TreeNode root)\\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val \\n               && (IsSubPathFromRoot(head.next, root.right) \\n               || IsSubPathFromRoot(head.next, root.left));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsSubPath(ListNode head, TreeNode root) \\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return IsSubPathFromRoot(head, root)  \\n               || IsSubPath(head, root.left) \\n               || IsSubPath(head, root.right);\\n    }\\n    \\n    private bool IsSubPathFromRoot(ListNode head, TreeNode root)\\n    {\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val \\n               && (IsSubPathFromRoot(head.next, root.right) \\n               || IsSubPathFromRoot(head.next, root.left));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650945,
                "title": "java-recursive-solution-o-n-without-space",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null && root==null){\\n            return true;\\n        }\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        boolean res = f(head,root);\\n        \\n        return res || isSubPath(head,root.left) || isSubPath(head,root.right);\\n        \\n    }\\n    \\n    public static boolean f(ListNode head,TreeNode root){\\n        if(root==null && head==null){\\n            return true;\\n        }\\n        if(root==null){\\n            return false;\\n        }\\n        if(head==null){\\n\\t\\t\\n\\t\\t// If My LinkedList became null that means upto this point all the values matched with the nodes in this path so we\\'ll return true from here that we found the link list structure in tree\\n\\t\\t\\n            return true;\\n        }\\n        if(head.val!=root.val){\\n            return false;\\n        }\\n        \\n        return f(head.next,root.left) || f(head.next,root.right); // This OR operator will make sure if it gets true from any part of tree we\\'ll conserve the true value\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null && root==null){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2467765,
                "title": "c-simple-recursive-and-dfs-approach-solution",
                "content": "```\\n\\nclass Solution {\\n    \\n    bool dfs(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return dfs(head->next , root->left) || dfs(head->next, root->right);\\n    }\\n    \\n    bool SolveByRecursion(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL)\\n            return false;\\n        \\n        if(dfs(head, root))\\n                return true;\\n        \\n        return SolveByRecursion(head, root->left) || SolveByRecursion(head, root->right);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return SolveByRecursion(head, root);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    bool dfs(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return dfs(head->next , root->left) || dfs(head->next, root->right);\\n    }\\n    \\n    bool SolveByRecursion(ListNode * head, TreeNode * root)\\n    {\\n        if(head == NULL)\\n            return true;\\n        \\n        if(root == NULL)\\n            return false;\\n        \\n        if(dfs(head, root))\\n                return true;\\n        \\n        return SolveByRecursion(head, root->left) || SolveByRecursion(head, root->right);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return SolveByRecursion(head, root);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949306,
                "title": "python-95-faster-easy-soultion",
                "content": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        pattern = \"\"\\n        curr = head\\n        while curr:\\n            pattern += f\"{curr.val}-\"\\n            curr = curr.next\\n        stack = [(root, f\"{root.val}-\")]\\n        while stack:\\n            (node, curr_path) = stack.pop()\\n            if pattern in curr_path:\\n                return True\\n            if node.left:\\n                stack.append((node.left, curr_path+f\"{node.left.val}-\"))\\n            if node.right:\\n                stack.append((node.right, curr_path+f\"{node.right.val}-\"))\\n        return False\\n```",
                "solutionTags": [
                    "String",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        pattern = \"\"\\n        curr = head\\n        while curr:\\n            pattern += f\"{curr.val}-\"\\n            curr = curr.next\\n        stack = [(root, f\"{root.val}-\")]\\n        while stack:\\n            (node, curr_path) = stack.pop()\\n            if pattern in curr_path:\\n                return True\\n            if node.left:\\n                stack.append((node.left, curr_path+f\"{node.left.val}-\"))\\n            if node.right:\\n                stack.append((node.right, curr_path+f\"{node.right.val}-\"))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499304,
                "title": "c-solution-using-dfs-dfs-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(ListNode* head, TreeNode* root)\\n    {\\n        if(head!=nullptr&&root==nullptr)\\n         return false;\\n        if(head->val==root->val&&head->next==nullptr)/*the entire Linked List has been traversed and is present in Binary                                                             tree */\\n            return true;\\n        if(head->val==root->val)\\n        {\\n       return compare(head->next,root->left)||compare(head->next,root->right);//we are moving to the next node\\n        }\\n        return false;        \\n    }\\n bool dfs(ListNode* head, TreeNode* root)\\n {\\n     if(head!=nullptr&&root==nullptr)\\n         return false;//The entire tree has been traversed and no value equal to the head node has been found\\n     if(compare(head,root))\\n         return true;\\n    return dfs(head,root->left)||dfs(head,root->right);//DFS traversal\\n  \\n }\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return dfs(head,root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(ListNode* head, TreeNode* root)\\n    {\\n        if(head!=nullptr&&root==nullptr)\\n         return false;\\n        if(head->val==root->val&&head->next==nullptr)/*the entire Linked List has been traversed and is present in Binary                                                             tree */\\n            return true;\\n        if(head->val==root->val)\\n        {\\n       return compare(head->next,root->left)||compare(head->next,root->right);//we are moving to the next node\\n        }\\n        return false;        \\n    }\\n bool dfs(ListNode* head, TreeNode* root)\\n {\\n     if(head!=nullptr&&root==nullptr)\\n         return false;//The entire tree has been traversed and no value equal to the head node has been found\\n     if(compare(head,root))\\n         return true;\\n    return dfs(head,root->left)||dfs(head,root->right);//DFS traversal\\n  \\n }\\n    bool isSubPath(ListNode* head, TreeNode* root) {      \\n        return dfs(head,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393919,
                "title": "java-simple-recursion",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return rec(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean rec(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (rec(head.next, root.left) || rec(head.next, root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return rec(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n\\n    private boolean rec(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (rec(head.next, root.left) || rec(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179155,
                "title": "c-simple-recursive-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // check whether it is possible to get the linked list from the current tree node\\n    // dfs based recursive function\\n    bool startsWith(ListNode *head, TreeNode *root) {\\n        // base case: you reached the end of the linked list\\n        if(!head)\\n            return true;\\n        // root becomes null and linked list is not fully traversed || value of the current node doesnt match with linked list\\n        if(head && !root || head->val != root->val)\\n            return false;\\n        // recursive calls\\n        return startsWith(head->next, root->left) || startsWith(head->next, root->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        // base case\\n        if(!root)\\n            return false;\\n        // check for the linked list to start with root node\\n        if(startsWith(head, root))\\n            return true;\\n        // recursive calls: check for linked list to start with child nodes\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // check whether it is possible to get the linked list from the current tree node\\n    // dfs based recursive function\\n    bool startsWith(ListNode *head, TreeNode *root) {\\n        // base case: you reached the end of the linked list\\n        if(!head)\\n            return true;\\n        // root becomes null and linked list is not fully traversed || value of the current node doesnt match with linked list\\n        if(head && !root || head->val != root->val)\\n            return false;\\n        // recursive calls\\n        return startsWith(head->next, root->left) || startsWith(head->next, root->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        // base case\\n        if(!root)\\n            return false;\\n        // check for the linked list to start with root node\\n        if(startsWith(head, root))\\n            return true;\\n        // recursive calls: check for linked list to start with child nodes\\n        return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847652,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public static boolean checking(ListNode head,TreeNode root)\\n    {\\n        if(head==null)\\n            return true;\\n        if(root==null)\\n            return false;            \\n        if(root.val!=head.val)\\n            return false;\\n        return(checking(head.next,root.left)||checking(head.next,root.right));\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root==null || head==null)\\n            return false;\\n        if(root.val==head.val && checking(head,root))\\n            return true;\\n        return (isSubPath(head,root.left)||isSubPath(head,root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static boolean checking(ListNode head,TreeNode root)\\n    {\\n        if(head==null)\\n            return true;\\n        if(root==null)\\n            return false;            \\n        if(root.val!=head.val)\\n            return false;\\n        return(checking(head.next,root.left)||checking(head.next,root.right));\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root==null || head==null)\\n            return false;\\n        if(root.val==head.val && checking(head,root))\\n            return true;\\n        return (isSubPath(head,root.left)||isSubPath(head,root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695058,
                "title": "python-dfs-beats-99",
                "content": "class Solution:\\n\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        target = \"\"\\n        while head:\\n            target = target + str(head.val)\\n            head = head.next\\n            \\n        \\n        def dfs(root, path):\\n            if target in path:\\n                return True\\n                \\n            if root.left:\\n                ans =  dfs(root.left, path + str(root.left.val))\\n                if ans == True:\\n                    return True\\n                    \\n            if root.right:\\n                ans  = dfs(root.right, path + str(root.right.val))\\n                if ans == True:\\n                    return True\\n            \\n            return False\\n            \\n                \\n        return dfs(root, str(root.val))",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        target = \"\"\\n        while head:\\n            target = target + str(head.val)\\n            head = head.next\\n            \\n        \\n        def dfs(root, path):\\n            if target in path:\\n                return True\\n                \\n            if root.left:\\n                ans =  dfs(root.left, path + str(root.left.val))\\n                if ans == True:\\n                    return True\\n                    \\n            if root.right:\\n                ans  = dfs(root.right, path + str(root.right.val))\\n                if ans == True:\\n                    return True\\n            \\n            return False\\n            \\n                \\n        return dfs(root, str(root.val))",
                "codeTag": "Java"
            },
            {
                "id": 525912,
                "title": "javascript-bfs-then-dfs-with-explanation",
                "content": "* traverse tree BFS\\n* for each node, call dfs and verify if true:\\n\\t* if node is equal to linked list node:\\n\\t\\t* if no next node in list, then we found a sequence!\\n\\t\\t* else, gotta keep going. Recursively call for left and right with next node in list\\n* if all nodes explored and none have a path, then return false\\n\\n\\n```javascript\\nconst isSubPath = (head, root) => {\\n    const queue = [root];\\n    \\n    while(queue.length > 0) {\\n        const curr = queue.pop();\\n        \\n        if(helper(curr, head)) return true;\\n        \\n        if(curr.left) queue.unshift(curr.left);\\n        if(curr.right) queue.unshift(curr.right);\\n    }\\n    \\n    return false;\\n    \\n};\\n\\nconst helper = (treeNode, listNode) => {\\n    if(!treeNode) return false;\\n    \\n    if(treeNode.val !== listNode.val) return false;\\n    \\n    if(!listNode.next) return true;\\n    \\n    listNode = listNode.next;\\n    \\n    const leftResult = helper(treeNode.left, listNode);\\n    const rightResult = helper(treeNode.right, listNode);\\n    \\n    return leftResult || rightResult;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst isSubPath = (head, root) => {\\n    const queue = [root];\\n    \\n    while(queue.length > 0) {\\n        const curr = queue.pop();\\n        \\n        if(helper(curr, head)) return true;\\n        \\n        if(curr.left) queue.unshift(curr.left);\\n        if(curr.right) queue.unshift(curr.right);\\n    }\\n    \\n    return false;\\n    \\n};\\n\\nconst helper = (treeNode, listNode) => {\\n    if(!treeNode) return false;\\n    \\n    if(treeNode.val !== listNode.val) return false;\\n    \\n    if(!listNode.next) return true;\\n    \\n    listNode = listNode.next;\\n    \\n    const leftResult = helper(treeNode.left, listNode);\\n    const rightResult = helper(treeNode.right, listNode);\\n    \\n    return leftResult || rightResult;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525123,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSubPath = function(head, root) {\\n    if(!root) return false\\n    if(dfs(head, root)) return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction dfs(head, node) {\\n    if(!head) return true\\n    if(!node) return false\\n    if(node.val !== head.val) return false\\n    return dfs(head.next, node.left) || dfs(head.next, node.right)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSubPath = function(head, root) {\\n    if(!root) return false\\n    if(dfs(head, root)) return true\\n    return isSubPath(head, root.left) || isSubPath(head, root.right)\\n};\\n\\nfunction dfs(head, node) {\\n    if(!head) return true\\n    if(!node) return false\\n    if(node.val !== head.val) return false\\n    return dfs(head.next, node.left) || dfs(head.next, node.right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797505,
                "title": "python-3-bfs-dfs-combination",
                "content": "### Time complexity: \\n`O(N) * min(O(H), O(L))`\\nwhere N - tree size,  H - tree height, L - list length\\n```python3 []\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)\\n\\n        queue = deque([root])\\n        while queue:\\n            for _ in range(len(queue)):\\n                cur = queue.popleft()\\n                if cur.val == head.val and isEqual(cur, head):\\n                    return True\\n                if cur.left: queue.append(cur.left)\\n                if cur.right: queue.append(cur.right)\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def isEqual(treeNode, listNode):\\n            if not listNode: return True\\n            if not treeNode or treeNode.val != listNode.val: return False\\n            return isEqual(treeNode.left, listNode.next) or isEqual(treeNode.right, listNode.next)\\n\\n        queue = deque([root])\\n        while queue:\\n            for _ in range(len(queue)):\\n                cur = queue.popleft()\\n                if cur.val == head.val and isEqual(cur, head):\\n                    return True\\n                if cur.left: queue.append(cur.left)\\n                if cur.right: queue.append(cur.right)\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578405,
                "title": "i-have-try-to-explain-you-in-the-most-easiest-way-have-a-look-and-if-you-have-doubt-you-can-ask-me",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool helper(ListNode* head, TreeNode* root){\\n       if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr || head->val!=root->val) { \\n            //bec we are checking link also so we have to do  this. Basically here all the root we come through isSubPath function and if we are able to find first element of head in root than we wil check weathere there is link or not\\n\\n            return false; \\n        }\\n\\n   return helper(head->next,root->left)|| helper(head->next,root->right);\\n   // see here we are passing head->next also so that it we check if head->next and root->left  or right is link or not \\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr) {\\n            return false; // Reached the end of the tree\\n        }\\n\\n        //now we will check if there is some path int the tree or not \\n        if(helper(head,root)){\\n            return true;\\n        } // if it doesn\\'t return true means we are not able to find the link in root now we wil call on left and right side to check link available or not\\n\\n\\n        \\n        // here we are doing mistake is that we are only finding the element of linklist but not checking weathere the link is also prest or not \\n\\n        // if (root->val == head->val) { \\n        //     // Check if the current head value matches the root value\\n        //     // Make recursive calls to the left and right subtrees\\n        //     return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        // } \\n\\n\\n\\n        // If the values don\\'t match, make recursive calls to the left and right subtrees independently\\n        return isSubPath(head, root->left) || isSubPath(head, root->right) ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Binary Search",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool helper(ListNode* head, TreeNode* root){\\n       if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr || head->val!=root->val) { \\n            //bec we are checking link also so we have to do  this. Basically here all the root we come through isSubPath function and if we are able to find first element of head in root than we wil check weathere there is link or not\\n\\n            return false; \\n        }\\n\\n   return helper(head->next,root->left)|| helper(head->next,root->right);\\n   // see here we are passing head->next also so that it we check if head->next and root->left  or right is link or not \\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (head == nullptr) {\\n            return true; // Reached the end of the linked list\\n        }\\n        if (root == nullptr) {\\n            return false; // Reached the end of the tree\\n        }\\n\\n        //now we will check if there is some path int the tree or not \\n        if(helper(head,root)){\\n            return true;\\n        } // if it doesn\\'t return true means we are not able to find the link in root now we wil call on left and right side to check link available or not\\n\\n\\n        \\n        // here we are doing mistake is that we are only finding the element of linklist but not checking weathere the link is also prest or not \\n\\n        // if (root->val == head->val) { \\n        //     // Check if the current head value matches the root value\\n        //     // Make recursive calls to the left and right subtrees\\n        //     return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        // } \\n\\n\\n\\n        // If the values don\\'t match, make recursive calls to the left and right subtrees independently\\n        return isSubPath(head, root->left) || isSubPath(head, root->right) ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109347,
                "title": "the-easiest-solution",
                "content": "# Approach\\nOrdinary DFS traversal is used. Each node of tree is checked to be part of the list - as easy as possible.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ in most usual cases, $$O(n^2)$$ in the worst case, when the tree and list contain the same value but list is larger then tree height.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        return self.traverseDFS(head, root)\\n    \\n\\n    def traverseDFS(self, head, treeNode):\\n        if not treeNode:\\n            return False\\n        \\n        ret = self.checkDFS(head, treeNode)\\n        if ret:\\n            return ret\\n\\n        ret = self.traverseDFS(head, treeNode.left)\\n        if ret:\\n            return ret\\n        \\n        return self.traverseDFS(head, treeNode.right)\\n\\n\\n    def checkDFS(self, listNode, treeNode):\\n        if listNode == None:\\n            return True\\n        elif treeNode == None:\\n            return False\\n        elif treeNode.val == listNode.val:\\n            ret = self.checkDFS(listNode.next, treeNode.left)\\n            if ret:\\n                return ret\\n\\n            return self.checkDFS(listNode.next, treeNode.right)\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Tree"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        return self.traverseDFS(head, root)\\n    \\n\\n    def traverseDFS(self, head, treeNode):\\n        if not treeNode:\\n            return False\\n        \\n        ret = self.checkDFS(head, treeNode)\\n        if ret:\\n            return ret\\n\\n        ret = self.traverseDFS(head, treeNode.left)\\n        if ret:\\n            return ret\\n        \\n        return self.traverseDFS(head, treeNode.right)\\n\\n\\n    def checkDFS(self, listNode, treeNode):\\n        if listNode == None:\\n            return True\\n        elif treeNode == None:\\n            return False\\n        elif treeNode.val == listNode.val:\\n            ret = self.checkDFS(listNode.next, treeNode.left)\\n            if ret:\\n                return ret\\n\\n            return self.checkDFS(listNode.next, treeNode.right)\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044011,
                "title": "c-recursion-binary-tree",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root, ListNode* curr, ListNode* head) {\\n        if(!curr) return true;\\n        if(!root) return false;\\n\\n        bool ans = false;\\n        \\n        ListNode *temp = curr;\\n        if(temp -> val == root -> val) {\\n            temp = curr -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }else{\\n            temp = head;\\n            if(head -> val == root -> val) temp = head -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }\\n\\n        return ans;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(root, head, head) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root, ListNode* curr, ListNode* head) {\\n        if(!curr) return true;\\n        if(!root) return false;\\n\\n        bool ans = false;\\n        \\n        ListNode *temp = curr;\\n        if(temp -> val == root -> val) {\\n            temp = curr -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }else{\\n            temp = head;\\n            if(head -> val == root -> val) temp = head -> next;\\n            ans |= check(root->left, temp, head);\\n            ans |= check(root->right, temp, head);\\n        }\\n\\n        return ans;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(root, head, head) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436467,
                "title": "simple-and-easy-to-understand-c-solution-using-recursion",
                "content": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n    \\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL)\\n            return false;\\n        if(match(head, root))\\n            return true;\\n        return dfs(head, root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool match(ListNode* head, TreeNode* root){\\n        if(head== NULL)\\n            return true;\\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return match(head->next,root->left) || match(head->next,root->right);\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n    \\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL)\\n            return false;\\n        if(match(head, root))\\n            return true;\\n        return dfs(head, root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool match(ListNode* head, TreeNode* root){\\n        if(head== NULL)\\n            return true;\\n        if(root == NULL || head->val != root->val)\\n            return false;\\n        \\n        return match(head->next,root->left) || match(head->next,root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2358081,
                "title": "c-brute-force-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool func(ListNode *head,TreeNode *root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val == root->val) return func(head->next,root->left) or func(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(func(head,root)) return true;\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/d813140d-dfa0-4566-96f9-5b88034f3eef_1659241756.820241.png)\\n**Please Upvote this post if you get any help from it.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(ListNode *head,TreeNode *root){\\n        if(!head) return true;\\n        if(!root) return false;\\n        if(head->val == root->val) return func(head->next,root->left) or func(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        if(func(head,root)) return true;\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355262,
                "title": "python-97-faster-recursive-approach-easy-and-clean-solution",
                "content": "***Please do upvote if found it helpful !!!!!!***\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkNextNode(self,head,root):\\n        checkLeft, checkRight = False, False\\n        if not head:\\n            return True\\n        if root.left and root.left.val == head.val:\\n            checkLeft = self.checkNextNode(head.next,root.left)\\n        if root.right and root.right.val == head.val:\\n            checkRight = self.checkNextNode(head.next,root.right)\\n        \\n        return checkLeft or checkRight\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.checkNextNode(head.next,root):\\n                return True\\n            \\n        checkLeft = self.isSubPath(head,root.left)\\n        checkRight = self.isSubPath(head,root.right)\\n            \\n        return checkLeft or checkRight\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkNextNode(self,head,root):\\n        checkLeft, checkRight = False, False\\n        if not head:\\n            return True\\n        if root.left and root.left.val == head.val:\\n            checkLeft = self.checkNextNode(head.next,root.left)\\n        if root.right and root.right.val == head.val:\\n            checkRight = self.checkNextNode(head.next,root.right)\\n        \\n        return checkLeft or checkRight\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.checkNextNode(head.next,root):\\n                return True\\n            \\n        checkLeft = self.isSubPath(head,root.left)\\n        checkRight = self.isSubPath(head,root.right)\\n            \\n        return checkLeft or checkRight\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219454,
                "title": "c-very-concise-code-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(!root) return (head==NULL);\\n         if(!head) return true;\\n        if(root->val!=head->val) return false;\\n            return check(head->next,root->left)|| check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(head,root)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(!root) return (head==NULL);\\n         if(!head) return true;\\n        if(root->val!=head->val) return false;\\n            return check(head->next,root->left)|| check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return check(head,root)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192635,
                "title": "java-dfs-faster-than-100-speed-optimised",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.val == head.val && check(head, root)) {\\n            return true;\\n        }\\n        \\n        if (isSubPath(head, root.left) || isSubPath(head, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if (head == null) {\\n            return true;\\n        }    \\n        \\n        if (root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        if (check(head.next, root.left) || check(head.next, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.val == head.val && check(head, root)) {\\n            return true;\\n        }\\n        \\n        if (isSubPath(head, root.left) || isSubPath(head, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if (head == null) {\\n            return true;\\n        }    \\n        \\n        if (root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        if (check(head.next, root.left) || check(head.next, root.right)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105593,
                "title": "c-short-beauty-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if (head == NULL) return true;\\n        if (root == NULL) return false;\\n        if (head->val != root->val) return false;\\n        return isPath(head->next, root->left) || isPath(head->next, root->right); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        return isPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool isPath(ListNode* head, TreeNode* root) {\\n        if (head == NULL) return true;\\n        if (root == NULL) return false;\\n        if (head->val != root->val) return false;\\n        return isPath(head->next, root->left) || isPath(head->next, root->right); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089608,
                "title": "python3-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def match(self,head,root):\\n        if(head == None): \\n            return True\\n        \\n        if(root == None):\\n            return False\\n        \\n        if(head.val != root.val):\\n            return False\\n        \\n        return self.match(head.next, root.left) or self.match(head.next, root.right)\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if(head == None): \\n            return True\\n        if(root == None):\\n            return False\\n                \\n        if(head.val == root.val):\\n            if(self.match(head, root)):\\n                return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def match(self,head,root):\\n        if(head == None): \\n            return True\\n        \\n        if(root == None):\\n            return False\\n        \\n        if(head.val != root.val):\\n            return False\\n        \\n        return self.match(head.next, root.left) or self.match(head.next, root.right)\\n    \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if(head == None): \\n            return True\\n        if(root == None):\\n            return False\\n                \\n        if(head.val == root.val):\\n            if(self.match(head, root)):\\n                return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088162,
                "title": "java-easy-dfs-approach",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(head == null) return true;\\n        return dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n        //The above line is to check the root.val and root.left.val and root.right.val , if anyone is true should be checked , then the dfs function will enable searching the depth of the tree\\n    }\\n    public boolean dfs(ListNode head, TreeNode root){\\n        //Depth first search\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val && (dfs(head.next,root.left) || dfs(head.next,root.right)); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        if(head == null) return true;\\n        return dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n        //The above line is to check the root.val and root.left.val and root.right.val , if anyone is true should be checked , then the dfs function will enable searching the depth of the tree\\n    }\\n    public boolean dfs(ListNode head, TreeNode root){\\n        //Depth first search\\n        if(head == null) return true;\\n        if(root == null) return false;\\n        return head.val == root.val && (dfs(head.next,root.left) || dfs(head.next,root.right)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900313,
                "title": "c-dfs-bfs-reursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode *root,ListNode * head)\\n    {\\n        if(!head)\\n            return true;\\n        if(!root||root->val!=head->val)\\n        {\\n            return false;\\n        }\\n         if(dfs(root->right,head->next))\\n             return true;\\n        if(dfs(root->left,head->next))\\n            return true;\\n        \\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                TreeNode *temp=q.front();\\n                q.pop();\\n                bool cnt=0;\\n                if(temp->val==head->val)\\n                {\\n                     cnt=dfs(temp,head);\\n\\n                }\\n                if(cnt)\\n                {\\n                    return true;\\n                }\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n                \\n                \\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(TreeNode *root,ListNode * head)\\n    {\\n        if(!head)\\n            return true;\\n        if(!root||root->val!=head->val)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1855468,
                "title": "simple-and-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        if (isPath(head, root)) return true;\\n        \\n        if (root == null || head == null) return false;\\n        \\n        return isSubPath(head, root.left) || \\n                isSubPath(head, root.right);\\n    }\\n    \\n    public boolean isPath(ListNode head, TreeNode root) {  \\n        if (head == null) return true;\\n        if (root == null) return false;\\n        \\n        if (head.val == root.val) {\\n            return isPath(head.next, root.left) || \\n                isPath(head.next, root.right);\\n        }\\n            \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        if (isPath(head, root)) return true;\\n        \\n        if (root == null || head == null) return false;\\n        \\n        return isSubPath(head, root.left) || \\n                isSubPath(head, root.right);\\n    }\\n    \\n    public boolean isPath(ListNode head, TreeNode root) {  \\n        if (head == null) return true;\\n        if (root == null) return false;\\n        \\n        if (head.val == root.val) {\\n            return isPath(head.next, root.left) || \\n                isPath(head.next, root.right);\\n        }\\n            \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795540,
                "title": "java-100-faster-dfs",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null || root == null) return false;\\n        \\n        //if the starting value is same then only we can try solving further\\n        if(root.val == head.val){\\n            \\n            /*\\n                Since java follows pass by reference by default,\\n                we need to store head and root in a separate variable and then pass it\\n                otherwise we will end by changing the value of head and root for the \\n                next possible iteration\\n            */\\n            TreeNode temproot = root;\\n            ListNode temphead = head;\\n            \\n            //now if our function returns true, then we stop here\\n            if(solve(temphead, temproot)) return true;\\n        }\\n        \\n        //otherwise keep on exploring for equal starting point\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    public boolean solve(ListNode head, TreeNode root){\\n        //if head == null, that means we have successfully traversed our list\\n        if(head == null) return true;\\n        \\n        //if root == null that means we have a few elements in list, but\\n        //not sufficient elements to compare with\\n        if(root == null) return false;\\n        \\n        /*\\n            if current values of both match then,\\n            try with left and right children now\\n        */\\n        if(head.val == root.val) \\n            return solve(head.next, root.left) || solve(head.next, root.right);\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null || root == null) return false;\\n        \\n        //if the starting value is same then only we can try solving further\\n        if(root.val == head.val){\\n            \\n            /*\\n                Since java follows pass by reference by default,\\n                we need to store head and root in a separate variable and then pass it\\n                otherwise we will end by changing the value of head and root for the \\n                next possible iteration\\n            */\\n            TreeNode temproot = root;\\n            ListNode temphead = head;\\n            \\n            //now if our function returns true, then we stop here\\n            if(solve(temphead, temproot)) return true;\\n        }\\n        \\n        //otherwise keep on exploring for equal starting point\\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    public boolean solve(ListNode head, TreeNode root){\\n        //if head == null, that means we have successfully traversed our list\\n        if(head == null) return true;\\n        \\n        //if root == null that means we have a few elements in list, but\\n        //not sufficient elements to compare with\\n        if(root == null) return false;\\n        \\n        /*\\n            if current values of both match then,\\n            try with left and right children now\\n        */\\n        if(head.val == root.val) \\n            return solve(head.next, root.left) || solve(head.next, root.right);\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793183,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(ListNode* head, TreeNode* root){\\n        if(head==NULL) return true;//complete\\n        if(root==NULL) return false;\\n        if(head->val != root->val) return false;\\n        return helper(head->next, root->left) || helper(head->next, root->right);\\n    }\\n    \\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return true;\\n        if(root==NULL) return false;\\n        return helper(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(ListNode* head, TreeNode* root){\\n        if(head==NULL) return true;//complete\\n        if(root==NULL) return false;\\n        if(head->val != root->val) return false;\\n        return helper(head->next, root->left) || helper(head->next, root->right);\\n    }\\n    \\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(head==NULL) return true;\\n        if(root==NULL) return false;\\n        return helper(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721625,
                "title": "simple-explaination-with-dfs-optimal-approach",
                "content": "# Recursive Approach:-\\n> Here the main point is to catch the idea that we will have to use DFS and will  have to define 2 recursion function .\\n> Since Linked List can start from any node so will have to make a single function which will check -- that linked list   start from this given head so for that we do this as :--\\n```\\n  bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n```\\nthat is simply check for current node and return if this note is starting point of linked list \\n\\n>Now actuall function will go for every node of tree in dfs manner hence we do it as:\\n```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) ||  isSubPath(head,root->right);\\n    }\\n  \\n```\\n\\n# Hence complete code will go like this :-\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n   \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n  };\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n```\n```\\n  bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) ||  isSubPath(head,root->right);\\n    }\\n  \\n```\n```\\nclass Solution {\\npublic:\\n   \\n    bool findPath(ListNode* head, TreeNode* root) {\\n        if(head == NULL){return true;}\\n        if(root == NULL){return false;} \\n    \\n        if(root->val==head->val){\\n            return ( findPath(head->next,root->left) || \\n                         ( findPath(head->next,root->right) ) );\\n        }\\n        else{ return false; }\\n    }\\n   \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root == NULL){ return false; }\\n    \\n        return findPath(head,root) || isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n  };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440858,
                "title": "c-2-approaches-dfs-dfs-and-dfs-bfs",
                "content": "## 1. DFS + DFS \\n```\\n// DFS + DFS\\nclass Solution {\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(dfs2(head,root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool dfs2(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(head->val!=root->val) return false;\\n        return dfs2(head->next,root->left) || dfs2(head->next,root->right); \\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }  \\n};\\n```\\n\\n\\n## 2. DFS + BFS \\n```\\n// DFS + BFS\\n class Solution {\\n     bool dfs(ListNode* head, TreeNode* root){\\n         if(root == NULL) return false;\\n         bool ans=false;\\n         if(head->val == root->val){\\n             ans = bfs(head,root);\\n         }\\n         bool left = dfs(head,root->left);\\n         bool right = dfs(head,root->right);\\n         return left || right || ans;\\n     }\\n    \\n     bool bfs(ListNode* head, TreeNode* root){\\n         queue<TreeNode*> q;\\n         q.push(root);\\n         ListNode* temp=head->next;\\n         while(!q.empty()){\\n             int size = q.size();\\n             for(int i=0;i<size;i++){\\n                 TreeNode* node=q.front();\\n                 q.pop();\\n                \\n                 if(node->left && temp && node->left->val == temp->val){\\n                     q.push(node->left);\\n                 }\\n                 if(node->right && temp && node->right->val == temp->val){\\n                     q.push(node->right);\\n                 }\\n             }  \\n             if(!q.empty()) temp=temp->next;\\n         }\\n         return temp==NULL;\\n     }\\n public:\\n     bool isSubPath(ListNode* head, TreeNode* root) {\\n         return dfs(head,root);\\n     }\\n };\\n```\\n",
                "solutionTags": [],
                "code": "```\\n// DFS + DFS\\nclass Solution {\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(dfs2(head,root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    \\n    bool dfs2(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL) return false;\\n        if(head->val!=root->val) return false;\\n        return dfs2(head->next,root->left) || dfs2(head->next,root->right); \\n    }\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }  \\n};\\n```\n```\\n// DFS + BFS\\n class Solution {\\n     bool dfs(ListNode* head, TreeNode* root){\\n         if(root == NULL) return false;\\n         bool ans=false;\\n         if(head->val == root->val){\\n             ans = bfs(head,root);\\n         }\\n         bool left = dfs(head,root->left);\\n         bool right = dfs(head,root->right);\\n         return left || right || ans;\\n     }\\n    \\n     bool bfs(ListNode* head, TreeNode* root){\\n         queue<TreeNode*> q;\\n         q.push(root);\\n         ListNode* temp=head->next;\\n         while(!q.empty()){\\n             int size = q.size();\\n             for(int i=0;i<size;i++){\\n                 TreeNode* node=q.front();\\n                 q.pop();\\n                \\n                 if(node->left && temp && node->left->val == temp->val){\\n                     q.push(node->left);\\n                 }\\n                 if(node->right && temp && node->right->val == temp->val){\\n                     q.push(node->right);\\n                 }\\n             }  \\n             if(!q.empty()) temp=temp->next;\\n         }\\n         return temp==NULL;\\n     }\\n public:\\n     bool isSubPath(ListNode* head, TreeNode* root) {\\n         return dfs(head,root);\\n     }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331966,
                "title": "python3-recursion-easy-to-understand",
                "content": "```\\n\\n# o(n*k)\\n\\nclass Solution:\\n    \\n    def isEmptyHead(self, head, root):\\n         \\n        # o(k)\\n        if not head: return True \\n        \\n        if not root: return False\\n        \\n        if head.val != root.val: return False\\n        \\n        if head:\\n            head = head.next \\n        \\n        left = self.isEmptyHead(head, root.left)\\n        right = self.isEmptyHead(head, root.right)\\n                \\n        return left or right \\n    \\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        # o(n)\\n        if root is None or head is None: return False \\n        \\n        if self.isEmptyHead(head, root): return True\\n        \\n        left = self.isSubPath(head, root.left)\\n        right = self.isSubPath(head, root.right)\\n        \\n        return left or right\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n# o(n*k)\\n\\nclass Solution:\\n    \\n    def isEmptyHead(self, head, root):\\n         \\n        # o(k)\\n        if not head: return True \\n        \\n        if not root: return False\\n        \\n        if head.val != root.val: return False\\n        \\n        if head:\\n            head = head.next \\n        \\n        left = self.isEmptyHead(head, root.left)\\n        right = self.isEmptyHead(head, root.right)\\n                \\n        return left or right \\n    \\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        # o(n)\\n        if root is None or head is None: return False \\n        \\n        if self.isEmptyHead(head, root): return True\\n        \\n        left = self.isSubPath(head, root.left)\\n        right = self.isSubPath(head, root.right)\\n        \\n        return left or right\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306639,
                "title": "traverse-the-tree-and-recursively-check-with-the-list-90-speed",
                "content": "Runtime: 96 ms, faster than 90.37% of Python3 online submissions for Linked List in Binary Tree.\\nMemory Usage: 14.8 MB, less than 96.67% of Python3 online submissions for Linked List in Binary Tree.\\n\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\n        def compare_values(l_node: ListNode, t_node: TreeNode):\\n            if not l_node:\\n                return True\\n            if t_node and l_node.val == t_node.val:\\n                return (compare_values(l_node.next, t_node.left) or\\n                        compare_values(l_node.next, t_node.right))\\n            return False\\n\\n        row = {root}\\n        while row:\\n            next_row = set()\\n            for node in row:\\n                if node.val == head.val and compare_values(head, node):\\n                    return True\\n                if node.left:\\n                    next_row.add(node.left)\\n                if node.right:\\n                    next_row.add(node.right)\\n            row = next_row\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n\\n        def compare_values(l_node: ListNode, t_node: TreeNode):\\n            if not l_node:\\n                return True\\n            if t_node and l_node.val == t_node.val:\\n                return (compare_values(l_node.next, t_node.left) or\\n                        compare_values(l_node.next, t_node.right))\\n            return False\\n\\n        row = {root}\\n        while row:\\n            next_row = set()\\n            for node in row:\\n                if node.val == head.val and compare_values(head, node):\\n                    return True\\n                if node.left:\\n                    next_row.add(node.left)\\n                if node.right:\\n                    next_row.add(node.right)\\n            row = next_row\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215163,
                "title": "java-tree-linkedlist-beats-100-1ms-t-c-o-n-l-s-c-o-n",
                "content": "\\n    // O(N*L) O(N)\\n\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean self = isSubPathHelper(root, head);\\n\\t\\tif (self)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean left = isSubPath(head, root.left);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPath(head, root.right);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// O(L) O(L)\\n\\tpublic boolean isSubPathHelper(TreeNode root, ListNode head) {\\n\\n\\t\\tif (head == null)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (root == null || root.val != head.val)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean left = isSubPathHelper(root.left, head.next);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPathHelper(root.right, head.next);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(N*L) O(N)\\n\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean self = isSubPathHelper(root, head);\\n\\t\\tif (self)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean left = isSubPath(head, root.left);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPath(head, root.right);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// O(L) O(L)\\n\\tpublic boolean isSubPathHelper(TreeNode root, ListNode head) {\\n\\n\\t\\tif (head == null)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (root == null || root.val != head.val)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean left = isSubPathHelper(root.left, head.next);\\n\\t\\tif (left)\\n\\t\\t\\treturn true;\\n\\n\\t\\tboolean right = isSubPathHelper(root.right, head.next);\\n\\t\\tif (right)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1120893,
                "title": "java-dfs-beats-99",
                "content": "more details can be found here: [Leetcode 1367. Linked List in Binary Tree](https://www.tipeca.com/learning/leetcode-1367-linked-list-in-binary-tree/)\\n\\n```\\nclass Solution {\\n    List<Integer> target;\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        target = new ArrayList();\\n        while (head != null) {\\n            target.add(head.val);\\n            head = head.next;\\n        }\\n        return isSubPath(new ArrayList(), root);\\n    }\\n    \\n    private boolean isSubPath(List<Integer> path, TreeNode node) {\\n        if (node == null) return false;\\n        path.add(node.val);\\n        if (match(path)) return true;\\n        if (isSubPath(path, node.left)) return true;\\n        if (isSubPath(path, node.right)) return true;\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n    \\n    private boolean match(List<Integer> path) {\\n        if (path.size() < target.size()) return false;\\n        int pi = path.size() - 1, ti = target.size() - 1;\\n        while (ti >= 0) {\\n            if (path.get(pi) != target.get(ti)) return false;\\n            pi--;\\n            ti--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> target;\\n    \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        target = new ArrayList();\\n        while (head != null) {\\n            target.add(head.val);\\n            head = head.next;\\n        }\\n        return isSubPath(new ArrayList(), root);\\n    }\\n    \\n    private boolean isSubPath(List<Integer> path, TreeNode node) {\\n        if (node == null) return false;\\n        path.add(node.val);\\n        if (match(path)) return true;\\n        if (isSubPath(path, node.left)) return true;\\n        if (isSubPath(path, node.right)) return true;\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n    \\n    private boolean match(List<Integer> path) {\\n        if (path.size() < target.size()) return false;\\n        int pi = path.size() - 1, ti = target.size() - 1;\\n        while (ti >= 0) {\\n            if (path.get(pi) != target.get(ti)) return false;\\n            pi--;\\n            ti--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056364,
                "title": "java-using-dfs-1ms-match-with-each-tree-node-as-starting-point",
                "content": "```\\nclass Solution {\\n    // Call Match the List with Tree on each tree node as starting point\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root){\\n        \\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        boolean flag = isSubPathRoot(head, root);\\n        flag = flag || dfs(head, root.left) || dfs(head, root.right);\\n        return flag;\\n        \\n    }\\n    \\n    boolean isSubPathRoot(ListNode head, TreeNode root){\\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        if(head.val == root.val){\\n            return isSubPathRoot(head.next, root.left) || isSubPathRoot(head.next, root.right);\\n        }else{\\n            return false;\\n        }\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Call Match the List with Tree on each tree node as starting point\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root){\\n        \\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        boolean flag = isSubPathRoot(head, root);\\n        flag = flag || dfs(head, root.left) || dfs(head, root.right);\\n        return flag;\\n        \\n    }\\n    \\n    boolean isSubPathRoot(ListNode head, TreeNode root){\\n        if(head == null) { return true; }\\n        if(root == null) { return false; }\\n        if(head.val == root.val){\\n            return isSubPathRoot(head.next, root.left) || isSubPathRoot(head.next, root.right);\\n        }else{\\n            return false;\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026181,
                "title": "simple-java-easy-understanding-recusrion",
                "content": "```\\n\\nclass Solution {\\n    boolean isCheckPath=false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        boolean isCheckPath = checkForSubPath(head, root);\\n        if (root!=null && !isCheckPath)\\n            return  isSubPath(head, root.left)||isSubPath(head, root.right);\\n        return isCheckPath;\\n    }\\n    \\n    public boolean checkForSubPath(ListNode head, TreeNode root){\\n        \\n        if (head==null)\\n            return true;\\n        \\n        if (root==null)\\n            return false;\\n        \\n        if (head.val==root.val)\\n            return checkForSubPath(head.next, root.left) || checkForSubPath(head.next, root.right);\\n        \\n        return isCheckPath;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    boolean isCheckPath=false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {        \\n        boolean isCheckPath = checkForSubPath(head, root);\\n        if (root!=null && !isCheckPath)\\n            return  isSubPath(head, root.left)||isSubPath(head, root.right);\\n        return isCheckPath;\\n    }\\n    \\n    public boolean checkForSubPath(ListNode head, TreeNode root){\\n        \\n        if (head==null)\\n            return true;\\n        \\n        if (root==null)\\n            return false;\\n        \\n        if (head.val==root.val)\\n            return checkForSubPath(head.next, root.left) || checkForSubPath(head.next, root.right);\\n        \\n        return isCheckPath;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954918,
                "title": "python-dp",
                "content": "I\\'ve read Lee\\'s post, but it took me a very long time to understand his DP solution, so I\\'m posting mine, with one key observation:\\n\\n`dp[i]` contains the length of the longest prefix of `A` that is also a suffix of `A[1:i]`.\\nTo understand the while loop one can observe that a suffix of a suffix of `A` is also a suffix of `A`.\\n\\nHeres the code:\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        A = []\\n        while head:\\n            A += [head.val]\\n            head = head.next\\n        dp = [0,0]\\n        i = 0\\n        for c in A[1:]:\\n            while i and c != A[i]:\\n                i = dp[i-1]\\n            i += c == A[i]\\n            dp += [i]\\n        def dfs(node,i):\\n            if not node:\\n                return False \\n            \\n            c = node.val\\n            while i and c != A[i]:\\n                i = dp[i]\\n            i += c == A[i]\\n            return i == len(A) or dfs(node.left,i) or dfs(node.right,i)\\n        \\n        return dfs(root,0)\\n            \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        A = []\\n        while head:\\n            A += [head.val]\\n            head = head.next\\n        dp = [0,0]\\n        i = 0\\n        for c in A[1:]:\\n            while i and c != A[i]:\\n                i = dp[i-1]\\n            i += c == A[i]\\n            dp += [i]\\n        def dfs(node,i):\\n            if not node:\\n                return False \\n            \\n            c = node.val\\n            while i and c != A[i]:\\n                i = dp[i]\\n            i += c == A[i]\\n            return i == len(A) or dfs(node.left,i) or dfs(node.right,i)\\n        \\n        return dfs(root,0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 947631,
                "title": "c-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(TreeNode*root,ListNode*head)\\n    {\\n        if(head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return (root->val==head->val)&&(find(root->left,head->next)||find(root->right,head->next));\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {    \\n        if(root==NULL&&head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return find(root,head)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(TreeNode*root,ListNode*head)\\n    {\\n        if(head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return (root->val==head->val)&&(find(root->left,head->next)||find(root->right,head->next));\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {    \\n        if(root==NULL&&head==NULL)\\n        {\\n            return true;\\n        }\\n        if(root==NULL)\\n        {\\n            return false;\\n        }\\n        return find(root,head)||isSubPath(head,root->left)||isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825022,
                "title": "can-someone-please-help-what-is-wrong-with-my-code-its-passing-59-61-test-cases",
                "content": "\\'\\'\\'\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(root==NULL && head!=NULL)\\n        {\\n            return false;\\n        }\\n        if(head==NULL)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            if(root->val==head->val)\\n            {\\n                head=head->next;\\n            }\\n            if(isSubPath(head,root->left) || isSubPath(head,root->right))\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(root==NULL && head!=NULL)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 810533,
                "title": "c-greedily-dfs-search",
                "content": "```csharp\\npublic class Solution {\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        return (root != null) && (Find(head, root) || IsSubPath(head, root.left) || IsSubPath(head, root.right));\\n    }\\n    \\n    private bool Find(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (root.val == head.val) && (Find(head.next, root.left) || Find(head.next, root.right));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        return (root != null) && (Find(head, root) || IsSubPath(head, root.left) || IsSubPath(head, root.right));\\n    }\\n    \\n    private bool Find(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return (root.val == head.val) && (Find(head.next, root.left) || Find(head.next, root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809839,
                "title": "recursive-solution-beats-98-95-in-time-and-97-61-in-space-c",
                "content": "* ### 40 ms runtime\\n* ### 31.9 MB space\\n```\\nclass Solution\\n{\\npublic:\\n    \\n    bool containsList(ListNode* head, TreeNode* root)\\n    {\\n        if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        return (head->val == root->val) && (containsList(head->next, root->left) || containsList(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root) return false;\\n        if(containsList(head, root)) return true;\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```\\n#### If you like the solution, do give it an upvote. In case of queries, feel free to leave them in the comment.\\n#### LeetCode and Chill !!!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool containsList(ListNode* head, TreeNode* root)\\n    {\\n        if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        return (head->val == root->val) && (containsList(head->next, root->left) || containsList(head->next, root->right));\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root) return false;\\n        if(containsList(head, root)) return true;\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794913,
                "title": "my-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> storingList = new ArrayList();\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        storeToList(head, root);\\n        for (TreeNode element: storingList){\\n            if (checkSubPath(head, element))\\n                return true;\\n        }\\n        return false;\\n    }\\n    public void storeToList(ListNode head, TreeNode node){\\n        if (head == null || node == null)\\n            return;\\n        if (head.val == node.val)\\n            storingList.add(node);\\n        storeToList(head, node.left);\\n        storeToList(head, node.right);\\n    }\\n    public boolean checkSubPath(ListNode head, TreeNode node){\\n        if (head == null)\\n            return true;\\n        if (node == null)\\n            return false;\\n        if (head.val == node.val)\\n            return (checkSubPath(head.next, node.left) || checkSubPath(head.next, node.right));\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> storingList = new ArrayList();\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        storeToList(head, root);\\n        for (TreeNode element: storingList){\\n            if (checkSubPath(head, element))\\n                return true;\\n        }\\n        return false;\\n    }\\n    public void storeToList(ListNode head, TreeNode node){\\n        if (head == null || node == null)\\n            return;\\n        if (head.val == node.val)\\n            storingList.add(node);\\n        storeToList(head, node.left);\\n        storeToList(head, node.right);\\n    }\\n    public boolean checkSubPath(ListNode head, TreeNode node){\\n        if (head == null)\\n            return true;\\n        if (node == null)\\n            return false;\\n        if (head.val == node.val)\\n            return (checkSubPath(head.next, node.left) || checkSubPath(head.next, node.right));\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739090,
                "title": "cpp-simple-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode* head, TreeNode* root){\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return false;\\n        return check(head->next,root->left)||check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        else{\\n            return check(head->next,root->left)||\\n                   check(head->next,root->right)||\\n                   isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode* head, TreeNode* root){\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return false;\\n        return check(head->next,root->left)||check(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head)\\n            return true;\\n        if(!root)\\n            return false;\\n        if(root->val!=head->val)\\n            return isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        else{\\n            return check(head->next,root->left)||\\n                   check(head->next,root->right)||\\n                   isSubPath(head,root->left)||\\n                   isSubPath(head,root->right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710322,
                "title": "c-recursive-solution",
                "content": "```\\nbool dfs(ListNode *head, TreeNode *root){\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\tif(root->val != head->val)\\n\\t\\treturn false;\\n\\treturn dfs(head->next,root->left) || dfs(head->next,root->right);\\n}\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\n\\treturn dfs(head,root) || isSubPath(head,root->left) ||isSubPath(head,root->right);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool dfs(ListNode *head, TreeNode *root){\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\tif(root->val != head->val)\\n\\t\\treturn false;\\n\\treturn dfs(head->next,root->left) || dfs(head->next,root->right);\\n}\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n\\tif(!head)\\n\\t\\treturn true;\\n\\tif(!root)\\n\\t\\treturn false;\\n\\n\\treturn dfs(head,root) || isSubPath(head,root->left) ||isSubPath(head,root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670466,
                "title": "java-bfs-dfs",
                "content": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        // idea is to start a dfs whenever we find a matching head\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            \\n            if(node.val == head.val && dfs(head, node))   return true;\\n            \\n            if(node.left!=null)   q.offer(node.left);\\n            if(node.right!=null)  q.offer(node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean isSubPath(ListNode head, TreeNode root) {\\n        // idea is to start a dfs whenever we find a matching head\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            \\n            if(node.val == head.val && dfs(head, node))   return true;\\n            \\n            if(node.left!=null)   q.offer(node.left);\\n            if(node.right!=null)  q.offer(node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(ListNode head, TreeNode root) {\\n        if (head == null) return true;\\n        if (root == null) return false;\\n        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 603775,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return head == null;\\n        }\\n        \\n        return dfs(head, root) || isSubPath(head, root.right) || isSubPath(head, root.left);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        } \\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        return dfs(head.next, root.left) || dfs(head.next, root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return head == null;\\n        }\\n        \\n        return dfs(head, root) || isSubPath(head, root.right) || isSubPath(head, root.left);\\n    }\\n    \\n    boolean dfs(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        } \\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        return dfs(head.next, root.left) || dfs(head.next, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589982,
                "title": "recursion-solution-using-kmp-time-beat-100-space-beat-100",
                "content": "Inspired by the KMP solution [here](https://leetcode.com/problems/implement-strstr/discuss/589972/Implement-of-KMP-with-python-(in-line-explanation)), we can easily solve this challenge by using the same approach, which is always used to solve pattern matching problems.\\n\\nM = length(pattern)    N = size(tree)    L = logN   (tree hight)\\nTime: O(N)\\nSpace: O(M + L)\\n\\n```\\n\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        global pattern, nxt\\n        \\n\\t\\t# transform the pattern into array list\\n        def LinkedListToArray(head):\\n            ans = []\\n            while(head):\\n                ans.append(head.val)\\n                head = head.next\\n            return ans\\n        \\n\\t\\t# to generate a index array, which is the core part of the KMP\\n        def createLPS(pattern, len):\\n            ans = [0] * len\\n            i, j = 0, 1\\n            while(j < len):\\n                if pattern[i] == pattern[j]:\\n                    i += 1\\n                    ans[j] = i\\n                    j += 1\\n                else:\\n                    if i != 0:\\n                        i = ans[i-1]\\n                    else:\\n                        ans[j] = i\\n                        j += 1\\n            return ans\\n        \\n\\t\\t# recursion part\\n        def dfs(root, i):\\n            if i == len(pattern): return True\\n            if root is None: return False\\n            \\n            global pattern, nxt\\n            \\n            if root.val == pattern[i]:\\n                return dfs(root.left, i + 1) or dfs(root.right, i + 1)\\n            if i > 0:\\n                i = nxt[i - 1]\\n                return dfs(root, i)\\n            else:\\n                return dfs(root.left, i) or dfs(root.right, i)\\n                \\n        global pattern, nxt\\n        pattern = LinkedListToArray(head)\\n        M = len(pattern)\\n        nxt = createLPS(pattern, M)\\n        if M == 0:\\n            return True\\n        return dfs(root, 0)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        global pattern, nxt\\n        \\n\\t\\t# transform the pattern into array list\\n        def LinkedListToArray(head):\\n            ans = []\\n            while(head):\\n                ans.append(head.val)\\n                head = head.next\\n            return ans\\n        \\n\\t\\t# to generate a index array, which is the core part of the KMP\\n        def createLPS(pattern, len):\\n            ans = [0] * len\\n            i, j = 0, 1\\n            while(j < len):\\n                if pattern[i] == pattern[j]:\\n                    i += 1\\n                    ans[j] = i\\n                    j += 1\\n                else:\\n                    if i != 0:\\n                        i = ans[i-1]\\n                    else:\\n                        ans[j] = i\\n                        j += 1\\n            return ans\\n        \\n\\t\\t# recursion part\\n        def dfs(root, i):\\n            if i == len(pattern): return True\\n            if root is None: return False\\n            \\n            global pattern, nxt\\n            \\n            if root.val == pattern[i]:\\n                return dfs(root.left, i + 1) or dfs(root.right, i + 1)\\n            if i > 0:\\n                i = nxt[i - 1]\\n                return dfs(root, i)\\n            else:\\n                return dfs(root.left, i) or dfs(root.right, i)\\n                \\n        global pattern, nxt\\n        pattern = LinkedListToArray(head)\\n        M = len(pattern)\\n        nxt = createLPS(pattern, M)\\n        if M == 0:\\n            return True\\n        return dfs(root, 0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 589556,
                "title": "sharing-my-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(null == head)\\n        {\\n            return true;\\n        }\\n        if(null == root)\\n        {\\n            return false;\\n        }\\n        \\n        if(root.val == head.val)\\n        {\\n             if(path(root, head))\\n             {\\n                 return true;\\n             }\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    private boolean path(TreeNode node, ListNode head)\\n    {\\n        if(head == null)\\n        {\\n            return true;\\n        }\\n        \\n        if(node == null)\\n        {\\n            return false;\\n        }\\n        \\n        if(node.val != head.val)\\n        {\\n            return false; \\n        }\\n        \\n        return path(node.left, head.next) || path(node.right, head.next);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(null == head)\\n        {\\n            return true;\\n        }\\n        if(null == root)\\n        {\\n            return false;\\n        }\\n        \\n        if(root.val == head.val)\\n        {\\n             if(path(root, head))\\n             {\\n                 return true;\\n             }\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    private boolean path(TreeNode node, ListNode head)\\n    {\\n        if(head == null)\\n        {\\n            return true;\\n        }\\n        \\n        if(node == null)\\n        {\\n            return false;\\n        }\\n        \\n        if(node.val != head.val)\\n        {\\n            return false; \\n        }\\n        \\n        return path(node.left, head.next) || path(node.right, head.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577567,
                "title": "java-dfs-100-faster-and-space-efficient-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(isIdentical(head,root)){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn isSubPath(head,root.left) || isSubPath(head,root.right);\\n\\t\\t}\\n\\n\\t\\tprivate boolean isIdentical(ListNode head, TreeNode root){\\n\\t\\t\\tif(head == null)\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif(root == null || root.val != head.val)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn isIdentical(head.next, root.left) || isIdentical(head.next, root.right);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(isIdentical(head,root)){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 573030,
                "title": "please-find-out-the-error-in-this-solution-c",
                "content": "**class Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root)return false;if(!head)return true;\\n        if(root->val==head->val)\\n            return(isSubPath(head->next,root->left)||isSubPath(head->next,root->right));\\n        \\n        return(isSubPath(head,root->left)||isSubPath(head,root->right));\\n    \\n    }\\n};**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root)return false;if(!head)return true;\\n        if(root->val==head->val)\\n            return(isSubPath(head->next,root->left)||isSubPath(head->next,root->right));\\n        \\n        return(isSubPath(head,root->left)||isSubPath(head,root->right));\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 538905,
                "title": "c-find-the-first-node-and-recursion",
                "content": "```\\n// it\\'s a little bit complex but might be clearer to read and hopefully reduce some calculation\\n\\nclass Solution {\\n    void findFirstMatch(ListNode* head, TreeNode* node, vector<TreeNode*>& total) {\\n\\t\\t// find the TreeNodes that matches the head ListNode, in order to reduce calculation\\n        if(!node || !head)\\n            return;\\n        if(node->val == head->val)\\n            total.push_back(node);\\n        findFirstMatch(head, node->left, total);\\n        findFirstMatch(head, node->right, total);\\n    }\\npublic:\\n    bool helper(ListNode* node_list, TreeNode* node_tree) {\\n        if(!node_list)\\n            return true;\\n        else if(!node_tree)\\n            return false;\\n        if(node_list->val != node_tree->val)\\n            return false;\\n        return helper(node_list->next, node_tree->left) || helper(node_list->next, node_tree->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> total;\\n        findFirstMatch(head, root, total);\\n        if(total.size() == 0)\\n            return false;\\n        for(auto node: total) {\\n            if(helper(head, node))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// it\\'s a little bit complex but might be clearer to read and hopefully reduce some calculation\\n\\nclass Solution {\\n    void findFirstMatch(ListNode* head, TreeNode* node, vector<TreeNode*>& total) {\\n\\t\\t// find the TreeNodes that matches the head ListNode, in order to reduce calculation\\n        if(!node || !head)\\n            return;\\n        if(node->val == head->val)\\n            total.push_back(node);\\n        findFirstMatch(head, node->left, total);\\n        findFirstMatch(head, node->right, total);\\n    }\\npublic:\\n    bool helper(ListNode* node_list, TreeNode* node_tree) {\\n        if(!node_list)\\n            return true;\\n        else if(!node_tree)\\n            return false;\\n        if(node_list->val != node_tree->val)\\n            return false;\\n        return helper(node_list->next, node_tree->left) || helper(node_list->next, node_tree->right);\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> total;\\n        findFirstMatch(head, root, total);\\n        if(total.size() == 0)\\n            return false;\\n        for(auto node: total) {\\n            if(helper(head, node))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532841,
                "title": "c-fastest-matching-using-kmp-dfa",
                "content": "I see a lot of brute force recursions, but I used KMP (Knuth-Morris-Pratt) with a simple DFA which is easy and matches faster.\\n\\nThe key observations related to having a tree as input source:\\n\\n1. The sequencing splits every time you descend left/right. So state restoration by \"backing up\" the source with all this branching isn\\'t easy ... or even possible for some algorithms.\\n2. Match state should ideally be self-contained per recursive frame as a simple index or tag. So that merely returning back up the call chain suffices to back up processing on failures.\\n3. Preprocessing the pattern which can be used at all call levels by simply knowing the right state index you are at in it works great. The linked list is just noise that you only need until you have the DFA which is what you actually use.\\n4. The ideal is to only pass through a given node ONCE and never have to backtrack to it and re-descend. For example, you want to avoid separate visitations from overall node traversal vs. path existence checking. This does that.\\n\\nHence KMP.\\n\\n[Note: Obviously building the DFA is some overhead that might dominate a trivially small example but is a drop in the ocean on large ones. Try a few maxed examples.]\\n\\n```\\npublic class Solution\\n{\\n\\tconst int MAX_PAT = 100;\\n\\n\\tpublic bool IsSubPath(ListNode pattern, TreeNode root)\\n\\t{\\n\\t\\tif (pattern == null || root == null) return false;\\n\\t\\tbyte[,] dfa = MakeDfa(pattern);\\n\\t\\tDumpDfa(dfa);\\n\\t\\treturn IsSubPath(root, 0, dfa);\\n\\t}\\n\\n\\tbool IsSubPath(TreeNode tn, byte dfaState, byte[,] dfa/*, int depth=0*/)\\n\\t{\\n\\t\\t//Console.WriteLine($\"{\"\".PadLeft(depth*2)} Node: {(tn==null?\"\":tn.val.ToString())} state={dfaState}\");\\n\\t\\tif (dfaState == dfa.GetLength(1)) return true; // bingo! since GetLength(1) is the pattern length we reached the final state\\n\\t\\tif (tn == null) return false; // ran out of tree data\\n\\n\\t\\t// Assume 0 for any char value higher then what the pattern has to save rows in the dfa.\\n\\t\\tbyte nextState = tn.val >= dfa.GetLength(0) ? (byte)0 : dfa[tn.val, dfaState];\\n\\t\\treturn IsSubPath(tn.left, nextState, dfa/*, depth+1*/) || IsSubPath(tn.right, nextState, dfa/*, depth+1*/);\\n\\t}\\n\\n\\t// Use KMP dfa table since it doesn\\'t need to back up in the tree,\\n\\t// and just sets the proper state (pattern position) for whatever the current tree node val is\\n\\tbyte[,] MakeDfa(ListNode listPattern)\\n\\t{\\n\\t\\t// Use a temp pattern[] for ease; we don\\'t need it or the linked list version after we build our dfa anyhow\\n\\t\\tList<byte> pat = new List<byte>(MAX_PAT);\\n\\t\\tint patMaxVal = 0;\\n\\t\\tfor (ListNode ln = listPattern; ln != null; ln = ln.next)\\n\\t\\t{\\n\\t\\t\\tif (ln.val > patMaxVal) patMaxVal = ln.val; // highest pattern value seen\\n\\t\\t\\tpat.Add((byte)ln.val);\\n\\t\\t}\\n\\n\\t\\t// The dfa that will drive the mismatch handling.\\n\\t\\t// Determines which pattern position we check against the next input value:\\n\\t\\t// - back up to some previous pattern position on mismatches\\n\\t\\t// - +1 for matches\\n\\t\\t// Note: The input form the tree recursion always moves forward\\n\\t\\t// which is important since the input is from recursively iterating a tree\\n\\t\\t// that would not be trivial to \"back up\".\\n\\t\\t// This is why we use the KMP dfa mechanism as opposed to, say, Boyer-Moore or Rabin-Karp.\\n\\t\\tbyte[,] dfa = new byte[patMaxVal+1, pat.Count];\\n\\t\\tdfa[pat[0], 0] = 1;\\n\\t\\tfor (byte x = 0, j = 1; j < pat.Count; j++)\\n\\t\\t{\\n\\t\\t\\tfor (byte ch = 1; ch <= patMaxVal; ch++)\\n\\t\\t\\t\\tdfa[ch, j] = dfa[ch, x];\\n\\t\\t\\tdfa[pat[j], j] = (byte)(j + 1);\\n\\t\\t\\tx = dfa[pat[j], x];\\n\\t\\t}\\n\\t\\tpat = null;\\n\\t\\treturn dfa;\\n\\t}\\n\\n\\t[Conditional(\"DEBUG\")]\\n\\tvoid DumpDfa(byte[,] dfa)\\n\\t{\\n\\t\\tConsole.WriteLine($\"DFA: {dfa.GetLength(0)} x {dfa.GetLength(1)}\");\\n\\t\\tConsole.Write(\"    \");\\n\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\tConsole.Write($\"{j,4}\");\\n\\t\\tConsole.WriteLine();\\n\\t\\tfor (int i = 0; i < dfa.GetLength(0); i++)\\n\\t\\t{\\n\\t\\t\\tConsole.Write($\"{i,4}\");\\n\\t\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\t\\tConsole.Write($\"{dfa[i,j],4}\");\\n\\t\\t\\tConsole.WriteLine();\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n\\tconst int MAX_PAT = 100;\\n\\n\\tpublic bool IsSubPath(ListNode pattern, TreeNode root)\\n\\t{\\n\\t\\tif (pattern == null || root == null) return false;\\n\\t\\tbyte[,] dfa = MakeDfa(pattern);\\n\\t\\tDumpDfa(dfa);\\n\\t\\treturn IsSubPath(root, 0, dfa);\\n\\t}\\n\\n\\tbool IsSubPath(TreeNode tn, byte dfaState, byte[,] dfa/*, int depth=0*/)\\n\\t{\\n\\t\\t//Console.WriteLine($\"{\"\".PadLeft(depth*2)} Node: {(tn==null?\"\":tn.val.ToString())} state={dfaState}\");\\n\\t\\tif (dfaState == dfa.GetLength(1)) return true; // bingo! since GetLength(1) is the pattern length we reached the final state\\n\\t\\tif (tn == null) return false; // ran out of tree data\\n\\n\\t\\t// Assume 0 for any char value higher then what the pattern has to save rows in the dfa.\\n\\t\\tbyte nextState = tn.val >= dfa.GetLength(0) ? (byte)0 : dfa[tn.val, dfaState];\\n\\t\\treturn IsSubPath(tn.left, nextState, dfa/*, depth+1*/) || IsSubPath(tn.right, nextState, dfa/*, depth+1*/);\\n\\t}\\n\\n\\t// Use KMP dfa table since it doesn\\'t need to back up in the tree,\\n\\t// and just sets the proper state (pattern position) for whatever the current tree node val is\\n\\tbyte[,] MakeDfa(ListNode listPattern)\\n\\t{\\n\\t\\t// Use a temp pattern[] for ease; we don\\'t need it or the linked list version after we build our dfa anyhow\\n\\t\\tList<byte> pat = new List<byte>(MAX_PAT);\\n\\t\\tint patMaxVal = 0;\\n\\t\\tfor (ListNode ln = listPattern; ln != null; ln = ln.next)\\n\\t\\t{\\n\\t\\t\\tif (ln.val > patMaxVal) patMaxVal = ln.val; // highest pattern value seen\\n\\t\\t\\tpat.Add((byte)ln.val);\\n\\t\\t}\\n\\n\\t\\t// The dfa that will drive the mismatch handling.\\n\\t\\t// Determines which pattern position we check against the next input value:\\n\\t\\t// - back up to some previous pattern position on mismatches\\n\\t\\t// - +1 for matches\\n\\t\\t// Note: The input form the tree recursion always moves forward\\n\\t\\t// which is important since the input is from recursively iterating a tree\\n\\t\\t// that would not be trivial to \"back up\".\\n\\t\\t// This is why we use the KMP dfa mechanism as opposed to, say, Boyer-Moore or Rabin-Karp.\\n\\t\\tbyte[,] dfa = new byte[patMaxVal+1, pat.Count];\\n\\t\\tdfa[pat[0], 0] = 1;\\n\\t\\tfor (byte x = 0, j = 1; j < pat.Count; j++)\\n\\t\\t{\\n\\t\\t\\tfor (byte ch = 1; ch <= patMaxVal; ch++)\\n\\t\\t\\t\\tdfa[ch, j] = dfa[ch, x];\\n\\t\\t\\tdfa[pat[j], j] = (byte)(j + 1);\\n\\t\\t\\tx = dfa[pat[j], x];\\n\\t\\t}\\n\\t\\tpat = null;\\n\\t\\treturn dfa;\\n\\t}\\n\\n\\t[Conditional(\"DEBUG\")]\\n\\tvoid DumpDfa(byte[,] dfa)\\n\\t{\\n\\t\\tConsole.WriteLine($\"DFA: {dfa.GetLength(0)} x {dfa.GetLength(1)}\");\\n\\t\\tConsole.Write(\"    \");\\n\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\tConsole.Write($\"{j,4}\");\\n\\t\\tConsole.WriteLine();\\n\\t\\tfor (int i = 0; i < dfa.GetLength(0); i++)\\n\\t\\t{\\n\\t\\t\\tConsole.Write($\"{i,4}\");\\n\\t\\t\\tfor (int j = 0; j < dfa.GetLength(1); j++)\\n\\t\\t\\t\\tConsole.Write($\"{dfa[i,j],4}\");\\n\\t\\t\\tConsole.WriteLine();\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526365,
                "title": "readable-recursive-solution-using-only-one-method-c",
                "content": "```\\n public bool IsSubPath(ListNode head, TreeNode root, bool mustHaveEqualValues = false)\\n        {\\n            if (head == null)\\n                return true;\\n            if (root == null)\\n                return false;\\n\\n            if (head.val == root.val && (IsSubPath(head.next, root.left, true) || IsSubPath(head.next, root.right, true)))\\n                return true;\\n            if (mustHaveEqualValues)\\n                return false;\\n\\n            return IsSubPath(head, root.left) || IsSubPath(head, root.right);\\n        }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n public bool IsSubPath(ListNode head, TreeNode root, bool mustHaveEqualValues = false)\\n        {\\n            if (head == null)\\n                return true;\\n            if (root == null)\\n                return false;\\n\\n            if (head.val == root.val && (IsSubPath(head.next, root.left, true) || IsSubPath(head.next, root.right, true)))\\n                return true;\\n            if (mustHaveEqualValues)\\n                return false;\\n\\n            return IsSubPath(head, root.left) || IsSubPath(head, root.right);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525814,
                "title": "python3-a-naive-dp-approach",
                "content": "Algorithm: \\nThis approached is insired by the discussion in this [thread](https://leetcode.com/problems/linked-list-in-binary-tree/discuss/525208/Help-Can-somebody-Help-why-this-is-TLE). \\n\\nImplementation (152ms): \\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(node, root): \\n            if not node: return True \\n            if not root: return False \\n            \\n            if root.val == node.val: \\n                return fn(node.next, root.left) or fn(node.next, root.right) or fn(head, root.left) or fn(head, root.right)\\n            else: \\n                return fn(head, root.left) or fn(head, root.right)\\n                    \\n        return fn(head, root)\\n```\\n\\nAnalysis:\\nTime complexity `O(MN)`\\nSpace complexity `O(MN)`\\n\\nUpdated with KMP algorithm per @lee215\\n\\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        #build longest prefix-suffix array\\n        pattern, lps = [head.val], [0] #longest prefix-suffix array\\n        j = 0\\n        while head.next: \\n            head = head.next \\n            pattern.append(head.val)\\n            \\n            while j and head.val != pattern[j]: j = lps[j-1]\\n            if head.val == pattern[j]: j += 1\\n            lps.append(j)\\n            \\n        def dfs(root, i): \\n            \"\"\"Return True of tree rooted at \"root\" match pattern\"\"\"\\n            if i == len(pattern): return True\\n            if not root: return False \\n            \\n            while i > 0 and root.val != pattern[i]: i = lps[i-1]\\n            if root.val == pattern[i]: i += 1\\n            return dfs(root.left, i) or dfs(root.right, i)\\n        \\n        return dfs(root, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(node, root): \\n            if not node: return True \\n            if not root: return False \\n            \\n            if root.val == node.val: \\n                return fn(node.next, root.left) or fn(node.next, root.right) or fn(head, root.left) or fn(head, root.right)\\n            else: \\n                return fn(head, root.left) or fn(head, root.right)\\n                    \\n        return fn(head, root)\\n```\n```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        #build longest prefix-suffix array\\n        pattern, lps = [head.val], [0] #longest prefix-suffix array\\n        j = 0\\n        while head.next: \\n            head = head.next \\n            pattern.append(head.val)\\n            \\n            while j and head.val != pattern[j]: j = lps[j-1]\\n            if head.val == pattern[j]: j += 1\\n            lps.append(j)\\n            \\n        def dfs(root, i): \\n            \"\"\"Return True of tree rooted at \"root\" match pattern\"\"\"\\n            if i == len(pattern): return True\\n            if not root: return False \\n            \\n            while i > 0 and root.val != pattern[i]: i = lps[i-1]\\n            if root.val == pattern[i]: i += 1\\n            return dfs(root.left, i) or dfs(root.right, i)\\n        \\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524987,
                "title": "java-solution",
                "content": "```Java\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        if(path(head, root)){\\n            return true;\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean path(ListNode head, TreeNode node){\\n        if(head == null) return true;\\n        if(node == null) return false;\\n        \\n        if(node.val == head.val){\\n            return path(head.next, node.left) || path(head.next, node.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) return false;\\n        \\n        if(path(head, root)){\\n            return true;\\n        }\\n        \\n        return isSubPath(head, root.left) || isSubPath(head, root.right);\\n    }\\n    \\n    \\n    private boolean path(ListNode head, TreeNode node){\\n        if(head == null) return true;\\n        if(node == null) return false;\\n        \\n        if(node.val == head.val){\\n            return path(head.next, node.left) || path(head.next, node.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524953,
                "title": "c-python3-recursion",
                "content": "Check if a linked list exists as a path in a binary tree.\\n\\n# Explanation\\n\\nDFS through the tree. For each node, record the places in the linked list that can be ends of paths in the tree. Then check if the path can extend to the child nodes.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\n    bool ans = false;\\n    \\n    ListNode* head;\\n    \\n    void checkSubPath(TreeNode* root, vector<ListNode*> ps) {\\n        if (root == NULL) return;\\n        if (ans) return;\\n        vector<ListNode*> newPs;\\n        for (auto p: ps) {\\n            if (p->val == root->val) {\\n                if (p->next == NULL) {\\n                    ans = true;\\n                    return;\\n                }\\n                newPs.push_back(p->next);\\n            }\\n        }\\n        newPs.push_back(head);\\n        checkSubPath(root->left, newPs);\\n        checkSubPath(root->right, newPs);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        this->head = head;\\n        checkSubPath(root, {head});\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python3 Solution\\n\\nWhy must `ans` be a class variable?\\n\\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        self.ans = False\\n        \\n        def checkSubPath(root: TreeNode, ps: List[ListNode]):\\n            if root is None: return\\n            if self.ans: return\\n            newPs = []\\n            for p in ps:\\n                if p.val == root.val:\\n                    if p.next is None:\\n                        self.ans = True\\n                        return\\n                    newPs.append(p.next)\\n            newPs.append(head)\\n            checkSubPath(root.left, newPs)\\n            checkSubPath(root.right, newPs)\\n        \\n        checkSubPath(root, [head])\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    bool ans = false;\\n    \\n    ListNode* head;\\n    \\n    void checkSubPath(TreeNode* root, vector<ListNode*> ps) {\\n        if (root == NULL) return;\\n        if (ans) return;\\n        vector<ListNode*> newPs;\\n        for (auto p: ps) {\\n            if (p->val == root->val) {\\n                if (p->next == NULL) {\\n                    ans = true;\\n                    return;\\n                }\\n                newPs.push_back(p->next);\\n            }\\n        }\\n        newPs.push_back(head);\\n        checkSubPath(root->left, newPs);\\n        checkSubPath(root->right, newPs);\\n    }\\n    \\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        this->head = head;\\n        checkSubPath(root, {head});\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        self.ans = False\\n        \\n        def checkSubPath(root: TreeNode, ps: List[ListNode]):\\n            if root is None: return\\n            if self.ans: return\\n            newPs = []\\n            for p in ps:\\n                if p.val == root.val:\\n                    if p.next is None:\\n                        self.ans = True\\n                        return\\n                    newPs.append(p.next)\\n            newPs.append(head)\\n            checkSubPath(root.left, newPs)\\n            checkSubPath(root.right, newPs)\\n        \\n        checkSubPath(root, [head])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524900,
                "title": "python-o-n-kmp-solution",
                "content": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        nums, dfa = self.prepare(head)\\n        return self.dfs(root, nums, dfa, 0)\\n    \\n    def prepare(self, head: ListNode) -> (List[int], List[int]):\\n        nums = []\\n        while head is not None:\\n            nums.append(head.val)\\n            head = head.next\\n        dfa = [0]\\n        j = 0\\n        for i, n in enumerate(nums[1:]):\\n            while j > 0 and nums[i] != nums[j]:\\n                j = dfa[j-1]\\n            if nums[i] == nums[j]:\\n                j += 1\\n            dfa.append(j)\\n        return nums, dfa\\n\\n    def dfs(self, treenode, nums, dfa, j) -> bool:\\n        if treenode == None:\\n            return False\\n        while j > 0 and treenode.val != nums[j]:\\n            j = dfa[j-1]\\n        if treenode.val == nums[j]:\\n            j += 1\\n        if j == len(nums):\\n            return True\\n        return self.dfs(treenode.left, nums, dfa, j) or self.dfs(treenode.right, nums, dfa, j)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\\n        nums, dfa = self.prepare(head)\\n        return self.dfs(root, nums, dfa, 0)\\n    \\n    def prepare(self, head: ListNode) -> (List[int], List[int]):\\n        nums = []\\n        while head is not None:\\n            nums.append(head.val)\\n            head = head.next\\n        dfa = [0]\\n        j = 0\\n        for i, n in enumerate(nums[1:]):\\n            while j > 0 and nums[i] != nums[j]:\\n                j = dfa[j-1]\\n            if nums[i] == nums[j]:\\n                j += 1\\n            dfa.append(j)\\n        return nums, dfa\\n\\n    def dfs(self, treenode, nums, dfa, j) -> bool:\\n        if treenode == None:\\n            return False\\n        while j > 0 and treenode.val != nums[j]:\\n            j = dfa[j-1]\\n        if treenode.val == nums[j]:\\n            j += 1\\n        if j == len(nums):\\n            return True\\n        return self.dfs(treenode.left, nums, dfa, j) or self.dfs(treenode.right, nums, dfa, j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029522,
                "title": "python3-very-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        self.graph = collections.defaultdict(list)\\n        self.lst = []\\n        tmp = head\\n        while tmp != None:\\n            self.lst.append(tmp)\\n            tmp = tmp.next\\n\\n        def helper(root, parent):\\n            if not root: return\\n            if parent != None:\\n                self.graph[parent].append(root)\\n                self.graph[root].append(parent)\\n\\n            helper(root.left, root)\\n            helper(root.right, root)\\n        \\n        helper(root, None)\\n\\n        self.ans = False\\n        self.seen = set()\\n\\n\\n        def dfs(root, depth):\\n            if depth==len(self.lst):\\n                self.ans = True\\n                return\\n            for v in self.graph[root]:\\n                if v in self.seen: continue\\n                if v.val == self.lst[depth].val:\\n                    self.seen.add(v)\\n                    dfs(v, depth+1)\\n                    self.seen.remove(v)\\n        \\n        def dfs2(root):\\n            if not root:\\n                return\\n            \\n            if root.val==head.val:\\n                self.seen.add(root)\\n                dfs(root, 1)\\n                self.seen.remove(root)\\n            \\n            dfs2(root.left)\\n            dfs2(root.right)\\n\\n        dfs2(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        self.graph = collections.defaultdict(list)\\n        self.lst = []\\n        tmp = head\\n        while tmp != None:\\n            self.lst.append(tmp)\\n            tmp = tmp.next\\n\\n        def helper(root, parent):\\n            if not root: return\\n            if parent != None:\\n                self.graph[parent].append(root)\\n                self.graph[root].append(parent)\\n\\n            helper(root.left, root)\\n            helper(root.right, root)\\n        \\n        helper(root, None)\\n\\n        self.ans = False\\n        self.seen = set()\\n\\n\\n        def dfs(root, depth):\\n            if depth==len(self.lst):\\n                self.ans = True\\n                return\\n            for v in self.graph[root]:\\n                if v in self.seen: continue\\n                if v.val == self.lst[depth].val:\\n                    self.seen.add(v)\\n                    dfs(v, depth+1)\\n                    self.seen.remove(v)\\n        \\n        def dfs2(root):\\n            if not root:\\n                return\\n            \\n            if root.val==head.val:\\n                self.seen.add(root)\\n                dfs(root, 1)\\n                self.seen.remove(root)\\n            \\n            dfs2(root.left)\\n            dfs2(root.right)\\n\\n        dfs2(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778191,
                "title": "python-fastest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726315,
                "title": "dp-on-trees",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(l*t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(l*t) (l=size of linked list ,t=size of tree );\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nunordered_map<ListNode *,unordered_map<TreeNode *,int>> mp;\\n      bool solve(ListNode *head,TreeNode *root,ListNode * &orih,TreeNode * &orit) {\\n           if(head==NULL)\\n        return true;\\n        if(root==NULL)\\n        return false;\\n\\n        if(mp[head].find(root)!=mp[head].end())\\n      return  mp[head][root];\\n\\n        if(head->val==root->val){\\n              return  mp[head][root]=solve(head->next,root->left,orih,orit)|solve(head->next,root->right,orih,orit)|solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n        else{\\n              return mp[head][root]= solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n\\n      }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n\\n        return solve(head,root,head,root);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nunordered_map<ListNode *,unordered_map<TreeNode *,int>> mp;\\n      bool solve(ListNode *head,TreeNode *root,ListNode * &orih,TreeNode * &orit) {\\n           if(head==NULL)\\n        return true;\\n        if(root==NULL)\\n        return false;\\n\\n        if(mp[head].find(root)!=mp[head].end())\\n      return  mp[head][root];\\n\\n        if(head->val==root->val){\\n              return  mp[head][root]=solve(head->next,root->left,orih,orit)|solve(head->next,root->right,orih,orit)|solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n        else{\\n              return mp[head][root]= solve(orih,root->left,orih,orit)|solve(orih,root->right,orih,orit);\\n        }\\n\\n      }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n\\n        return solve(head,root,head,root);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670399,
                "title": "our-straight-forward-dfs-with-self-explanatory-intuitive-comments-clean-code",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey There! Its Easy Just Take A Look At The Code And Comments Within It, You\\'ll Get It.\\n\\nNOTE : Start Reading From Main Method\\n\\nStill Got Doubts! Feel Free To Comment, I Will Definately Reply.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Our Easy Depth First Search \\uD83D\\uDE0B\\n\\n# Complexity\\n- Time complexity: O(N*M) - Where N let be the total number of nodes of the tree and M let be the length of the list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) - Where H let be the height of the tree used in the implicit stack space while recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Program to verify is all the elements of the linked list starting from the head correspond to some downward path in the binary tree or not ~ coded by Hiren\\n#include <iostream>\\nusing namespace std;\\n\\n// List template\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n\\n    // Init constructor\\n    ListNode(int val, ListNode* next) : val(val), next(next) {}; \\n\\n    // Init destructor\\n    ~ListNode() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Tree template\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left; TreeNode* right;\\n\\n    // Init constructors\\n    TreeNode(int val) : val(val), left(nullptr), right(nullptr) {};\\n    TreeNode(int val, TreeNode* left, TreeNode* right) : val(val), left(left), right(right) {};\\n\\n    // Init destructor\\n    ~TreeNode() {\\n        if(left) {\\n            delete left;\\n        }\\n        if(right) {\\n             delete right;\\n        }\\n    }\\n};\\n\\n// Method to print list using recursion\\nvoid printList(ListNode* head) {\\n    if(head) {\\n        cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Method to print tree using preOrder traversal\\nvoid printTree(TreeNode* root) {\\n    if(root) {\\n        cout<<root->val<<\\' \\';\\n        printTree(root->left);\\n        printTree(root->right);\\n    }\\n}\\n\\n// Method helper\\nbool checkForPath(TreeNode* root, ListNode* head) {\\n    // Edge case : When the list is empty, it means the path has been matched successfully\\n    if(!head)\\n        return true;\\n\\n    // When the tree node doesn\\'t exist or it exist but its value is not equal to the corrosponding list node\\n    if(!root || root->val != head->val)\\n        return false;\\n\\n    // Recursively check for the list path in the left and right subtree\\n    return checkForPath(root->left, head->next) || checkForPath(root->right, head->next);\\n}\\n\\n// Method to verify is the linked list exist in the binary tree or not - O(N*M) & O(H) : Where N let be the total number of nodes of the tree and M let be the length of the list\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n    // Edge case : When the list is empty, it means an empty path exists in the tree\\n    if(!head)\\n        return true;\\n\\n    // Edge case : When the tree is empty, it means the path cannot exist\\n    if(!root)\\n        return false;\\n\\n    // If the tree node contains the list as a path\\n    if(checkForPath(root, head))\\n        return true;\\n\\n    // Recursively check from each node of the tree\\n    return isSubPath(head, root->left) || isSubPath(head, root->right);\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating list, connecting nodes and initializing their data\\n    ListNode* head = new ListNode(4, new ListNode(5, new ListNode(8, nullptr)));\\n\\n    // Creating tree, connecting nodes and initializing their data\\n    TreeNode* c5 = new TreeNode(8);\\n    TreeNode* c4 = new TreeNode(5, nullptr, c5);\\n    TreeNode* c3 = new TreeNode(4, nullptr, c4);\\n    TreeNode* c2 = new TreeNode(3);\\n    TreeNode* c1 = new TreeNode(2, nullptr, c2);\\n    TreeNode* rt = new TreeNode(1, c1, c3);\\n\\n    // Print list\\n    printList(head); cout<<\\'\\\\n\\';\\n\\n    // Print tree\\n    printTree(rt); cout<<\\'\\\\n\\';\\n\\n    // Verification call\\n    if(isSubPath(head, rt))\\n        cout<<\"The linked list exist as a path in the binary tree!\";\\n    else\\n        cout<<\"The linked list does not exist as a path in the binary tree!\";\\n\\n    // Delete the head node (and recursively the entire list)\\n    delete head;\\n\\n    // Delete the root node (and recursively the entire tree)\\n    delete rt;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-in-binary-tree/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Program to verify is all the elements of the linked list starting from the head correspond to some downward path in the binary tree or not ~ coded by Hiren\\n#include <iostream>\\nusing namespace std;\\n\\n// List template\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n\\n    // Init constructor\\n    ListNode(int val, ListNode* next) : val(val), next(next) {}; \\n\\n    // Init destructor\\n    ~ListNode() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Tree template\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left; TreeNode* right;\\n\\n    // Init constructors\\n    TreeNode(int val) : val(val), left(nullptr), right(nullptr) {};\\n    TreeNode(int val, TreeNode* left, TreeNode* right) : val(val), left(left), right(right) {};\\n\\n    // Init destructor\\n    ~TreeNode() {\\n        if(left) {\\n            delete left;\\n        }\\n        if(right) {\\n             delete right;\\n        }\\n    }\\n};\\n\\n// Method to print list using recursion\\nvoid printList(ListNode* head) {\\n    if(head) {\\n        cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Method to print tree using preOrder traversal\\nvoid printTree(TreeNode* root) {\\n    if(root) {\\n        cout<<root->val<<\\' \\';\\n        printTree(root->left);\\n        printTree(root->right);\\n    }\\n}\\n\\n// Method helper\\nbool checkForPath(TreeNode* root, ListNode* head) {\\n    // Edge case : When the list is empty, it means the path has been matched successfully\\n    if(!head)\\n        return true;\\n\\n    // When the tree node doesn\\'t exist or it exist but its value is not equal to the corrosponding list node\\n    if(!root || root->val != head->val)\\n        return false;\\n\\n    // Recursively check for the list path in the left and right subtree\\n    return checkForPath(root->left, head->next) || checkForPath(root->right, head->next);\\n}\\n\\n// Method to verify is the linked list exist in the binary tree or not - O(N*M) & O(H) : Where N let be the total number of nodes of the tree and M let be the length of the list\\nbool isSubPath(ListNode* head, TreeNode* root) {\\n    // Edge case : When the list is empty, it means an empty path exists in the tree\\n    if(!head)\\n        return true;\\n\\n    // Edge case : When the tree is empty, it means the path cannot exist\\n    if(!root)\\n        return false;\\n\\n    // If the tree node contains the list as a path\\n    if(checkForPath(root, head))\\n        return true;\\n\\n    // Recursively check from each node of the tree\\n    return isSubPath(head, root->left) || isSubPath(head, root->right);\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating list, connecting nodes and initializing their data\\n    ListNode* head = new ListNode(4, new ListNode(5, new ListNode(8, nullptr)));\\n\\n    // Creating tree, connecting nodes and initializing their data\\n    TreeNode* c5 = new TreeNode(8);\\n    TreeNode* c4 = new TreeNode(5, nullptr, c5);\\n    TreeNode* c3 = new TreeNode(4, nullptr, c4);\\n    TreeNode* c2 = new TreeNode(3);\\n    TreeNode* c1 = new TreeNode(2, nullptr, c2);\\n    TreeNode* rt = new TreeNode(1, c1, c3);\\n\\n    // Print list\\n    printList(head); cout<<\\'\\\\n\\';\\n\\n    // Print tree\\n    printTree(rt); cout<<\\'\\\\n\\';\\n\\n    // Verification call\\n    if(isSubPath(head, rt))\\n        cout<<\"The linked list exist as a path in the binary tree!\";\\n    else\\n        cout<<\"The linked list does not exist as a path in the binary tree!\";\\n\\n    // Delete the head node (and recursively the entire list)\\n    delete head;\\n\\n    // Delete the root node (and recursively the entire tree)\\n    delete rt;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-in-binary-tree/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3223402,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\n\\npublic class Solution {\\n    public bool found;\\n    public void tryConnecting(ListNode head,TreeNode root){\\n        if(head==null){\\n            found=true;\\n            return;\\n        }\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head.next,root.left);\\n                tryConnecting(head.next,root.right);\\n            }\\n        }\\n    }\\n    public void dfs(ListNode head,TreeNode root){\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head,root);\\n            }\\n            dfs(head,root.left);\\n            dfs(head,root.right);\\n        }\\n    }\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        found=false;\\n        dfs(head,root);\\n        return found;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public bool found;\\n    public void tryConnecting(ListNode head,TreeNode root){\\n        if(head==null){\\n            found=true;\\n            return;\\n        }\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head.next,root.left);\\n                tryConnecting(head.next,root.right);\\n            }\\n        }\\n    }\\n    public void dfs(ListNode head,TreeNode root){\\n        if(root!=null){\\n            if(root.val==head.val){\\n                tryConnecting(head,root);\\n            }\\n            dfs(head,root.left);\\n            dfs(head,root.right);\\n        }\\n    }\\n    public bool IsSubPath(ListNode head, TreeNode root) {\\n        found=false;\\n        dfs(head,root);\\n        return found;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992629,
                "title": "linked-list-in-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool flag = false ;\\n    void path(ListNode* head , TreeNode* root) {\\n        if(head == NULL) {\\n            flag = true ;\\n            return ;\\n        }\\n        \\n        if(root == NULL) return ;\\n\\n        if(head->val != root->val) {\\n            return ;\\n        }\\n\\n        path(head->next , root->left) ;\\n        path(head->next , root->right) ;\\n    }\\n\\n    void solve(ListNode* head , TreeNode* root) {\\n        if(root == NULL) return ;\\n\\n        if(head->val == root->val) {\\n            path(head , root) ;\\n        }\\n        \\n        solve(head , root->left) ;\\n        solve(head , root->right) ;\\n    }\\n\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        solve(head , root) ;\\n        return flag ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool flag = false ;\\n    void path(ListNode* head , TreeNode* root) {\\n        if(head == NULL) {\\n            flag = true ;\\n            return ;\\n        }\\n        \\n        if(root == NULL) return ;\\n\\n        if(head->val != root->val) {\\n            return ;\\n        }\\n\\n        path(head->next , root->left) ;\\n        path(head->next , root->right) ;\\n    }\\n\\n    void solve(ListNode* head , TreeNode* root) {\\n        if(root == NULL) return ;\\n\\n        if(head->val == root->val) {\\n            path(head , root) ;\\n        }\\n        \\n        solve(head , root->left) ;\\n        solve(head , root->right) ;\\n    }\\n\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        solve(head , root) ;\\n        return flag ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578267,
                "title": "100-faster-1-ms-simple-java-solution",
                "content": "```\\nclass Solution {\\n    Boolean result = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        traverse(head, root);\\n        return result;\\n    }\\n    \\n    private void traverse(ListNode head, TreeNode root) {\\n        if(head != null && root != null) {\\n            if(head.val == root.val) {\\n                validate(head, root);\\n            } \\n            if(result)\\n                return;\\n            else {\\n                traverse(head, root.left);\\n                traverse(head, root.right);\\n\\n            }\\n        } \\n    }\\n    \\n    private void validate(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            result = true;\\n            return;\\n        } else {\\n            if(head == null || root == null)\\n                return;\\n            if(head.val == root.val) {\\n                validate(head.next, root.left);\\n                validate(head.next, root.right);\\n            } else {\\n                return;\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Boolean result = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        traverse(head, root);\\n        return result;\\n    }\\n    \\n    private void traverse(ListNode head, TreeNode root) {\\n        if(head != null && root != null) {\\n            if(head.val == root.val) {\\n                validate(head, root);\\n            } \\n            if(result)\\n                return;\\n            else {\\n                traverse(head, root.left);\\n                traverse(head, root.right);\\n\\n            }\\n        } \\n    }\\n    \\n    private void validate(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            result = true;\\n            return;\\n        } else {\\n            if(head == null || root == null)\\n                return;\\n            if(head.val == root.val) {\\n                validate(head.next, root.left);\\n                validate(head.next, root.right);\\n            } else {\\n                return;\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548434,
                "title": "c-recursion-and-inorder-traversal",
                "content": "~~~\\nclass Solution {\\npublic:\\n    bool ret = false;\\n    bool helper(ListNode* tmp_head, TreeNode* tmp_root){\\n        if(!tmp_head)\\n            return true;\\n        if(!tmp_root || (tmp_head->val != tmp_root->val))\\n            return false;\\n        return (helper(tmp_head->next, tmp_root->left) || helper(tmp_head->next, tmp_root->right));\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n                    \\n        if(!root)\\n            return false;\\n        isSubPath(head, root->left);\\n\\n        if(root->val == head->val){\\n            ret = ret || helper(head, root);\\n        }\\n        isSubPath(head, root->right);\\n        return ret;\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool ret = false;\\n    bool helper(ListNode* tmp_head, TreeNode* tmp_root){\\n        if(!tmp_head)\\n            return true;\\n        if(!tmp_root || (tmp_head->val != tmp_root->val))\\n            return false;\\n        return (helper(tmp_head->next, tmp_root->left) || helper(tmp_head->next, tmp_root->right));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2547793,
                "title": "js-linked-list-in-binary-tree",
                "content": "```\\nconst compareNodeTree=(node,tree)=>{\\n    if (!tree) return true;\\n     if (!node) return false;\\n    \\n    if(node.val!=tree.val)return false\\n    return compareNodeTree(node.left,tree.next) ||compareNodeTree(node.right,tree.next)\\n    \\n}\\nvar isSubPath = function(head, root) {\\n     const bst=(node)=>{\\n     if(!node)return false\\n     if(compareNodeTree(node,head))return true        \\n        return bst(node.right)||bst(node.left)\\n }\\n   return bst(root)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst compareNodeTree=(node,tree)=>{\\n    if (!tree) return true;\\n     if (!node) return false;\\n    \\n    if(node.val!=tree.val)return false\\n    return compareNodeTree(node.left,tree.next) ||compareNodeTree(node.right,tree.next)\\n    \\n}\\nvar isSubPath = function(head, root) {\\n     const bst=(node)=>{\\n     if(!node)return false\\n     if(compareNodeTree(node,head))return true        \\n        return bst(node.right)||bst(node.left)\\n }\\n   return bst(root)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522543,
                "title": "basic-practice-path-matching-traversal-python",
                "content": "1- Code\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        # 1. helper fn\\n        def helper(head, node):\\n            \"\"\"\\n            check if there is a matching starting from node\\n            \"\"\"\\n            if not head:\\n                return True\\n            if not node:\\n                return False\\n            if node.val != head.val:\\n                return False\\n            return helper(head.next, node.left) or helper(head.next, node.right)\\n        \\n        # 2. do traversal / DFS iterative format\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if helper(head, node):\\n                return True\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        return False\\n```\\n\\n2- Video Explanation: [Click Here](https://youtu.be/gkRZDUz7XSA;)\\n\\n3- Analysis\\n\\n\"\"\"\\nMethod: traversal\\n\\n\\nProcedure:\\n\\n - First write a helper fn f(head, node) to check if there is a continuous downward-path starting from thr node that matches the linked list\\n \\n - Do traversal, for example DFS, of the tree to check if we could find a matching path on\\n each subtree.\\n \\n \\n This way of writing the solution contains some redundancy, but for presentation purpose,\\n the logic is clearer and code is cleaner. As the length of linked list is bounded by 100, this is ok in the problem setting here. One could devise slightly complex solution to elimate the redundancy.\\n \\n\"\"\"",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        # 1. helper fn\\n        def helper(head, node):\\n            \"\"\"\\n            check if there is a matching starting from node\\n            \"\"\"\\n            if not head:\\n                return True\\n            if not node:\\n                return False\\n            if node.val != head.val:\\n                return False\\n            return helper(head.next, node.left) or helper(head.next, node.right)\\n        \\n        # 2. do traversal / DFS iterative format\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if helper(head, node):\\n                return True\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394905,
                "title": "simplest-solution-easiest-to-understand-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n        \\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        \\n        if(root==null)\\n            return false;\\n        \\n        if(match(head,root))\\n            return true;\\n        \\n        return dfs(head,root.left) || dfs(head,root.right);\\n        \\n    }\\n    \\n    public boolean match(ListNode head, TreeNode root) {\\n    \\n        if(head==null)\\n            return true;\\n        \\n        if(root==null || root.val!=head.val)\\n            return false;\\n        \\n        return match(head.next,root.left) || match(head.next,root.right);\\n    \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        \\n        return dfs(head,root);\\n        \\n    }\\n    \\n    public boolean dfs(ListNode head, TreeNode root) {\\n        \\n        if(root==null)\\n            return false;\\n        \\n        if(match(head,root))\\n            return true;\\n        \\n        return dfs(head,root.left) || dfs(head,root.right);\\n        \\n    }\\n    \\n    public boolean match(ListNode head, TreeNode root) {\\n    \\n        if(head==null)\\n            return true;\\n        \\n        if(root==null || root.val!=head.val)\\n            return false;\\n        \\n        return match(head.next,root.left) || match(head.next,root.right);\\n    \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355762,
                "title": "simple-java-solution-1ms-faster-than-100-easy-to-understand",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return false;\\n        }\\n        \\n        if(head.val == root.val) {\\n            ListNode thead = head;\\n            boolean ans = check(thead, root);\\n            if(ans) {\\n                return true;\\n            }\\n        }\\n        \\n        boolean left = isSubPath(head, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = isSubPath(head, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        }\\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        boolean left = check(head.next, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = check(head.next, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(root == null) {\\n            return false;\\n        }\\n        \\n        if(head.val == root.val) {\\n            ListNode thead = head;\\n            boolean ans = check(thead, root);\\n            if(ans) {\\n                return true;\\n            }\\n        }\\n        \\n        boolean left = isSubPath(head, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = isSubPath(head, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean check(ListNode head, TreeNode root) {\\n        if(head == null) {\\n            return true;\\n        }\\n        \\n        if(root == null || head.val != root.val) {\\n            return false;\\n        }\\n        \\n        boolean left = check(head.next, root.left);\\n        if(left) {\\n            return true;\\n        }\\n        \\n        boolean right = check(head.next, root.right);\\n        if(right) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342078,
                "title": "2-ms-faster-than-68-52-of-java-online-submissions-for-linked-list-in-binary-tree",
                "content": "Here in this problem only one catch is if **(head==null) return true;** since after leaf nodes you will get **root=null so** it must return **true.**  and all other things are similar to **Subtree of Another Tree** problem.But there you need to go with **and** case since you want **subtree** here. You need to go with **or** case since there is possiblity linkedlist will be either one of the sides.\\n\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n      \\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        \\n        else if(isSameList(head,root)){\\n            return true;\\n        }\\n        else{\\n            return isSubPath(head,root.left) ||isSubPath(head,root.right);\\n        }\\n    }\\n    public boolean isSameList(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        else if(root.val==head.val){\\n            return isSameList(head.next,root.left) || isSameList(head.next,root.right);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n      \\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        \\n        else if(isSameList(head,root)){\\n            return true;\\n        }\\n        else{\\n            return isSubPath(head,root.left) ||isSubPath(head,root.right);\\n        }\\n    }\\n    public boolean isSameList(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        else if(root.val==head.val){\\n            return isSameList(head.next,root.left) || isSameList(head.next,root.right);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339217,
                "title": "python-solution-will-leetcode-bug",
                "content": "```\\nclass Solution:\\n    flag=False\\n    flag2=False\\n    temp1=None\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if Solution.flag2==False:\\n            Solution.temp1=head\\n            Solution.flag2=True\\n        if head==None and Solution.flag==True:\\n            return True\\n        elif root==None:\\n            return False\\n        if head.val==root.val:\\n            head=head.next\\n            Solution.flag=True\\n        else:\\n            head=Solution.temp1\\n            Solution.flag=False\\n        return self.isSubPath(head,root.left) or self.isSubPath(head,root.right)\\n```\\n\\nThis code returns True for the test case \\n```\\n[3]\\n[1,5,3,null,4,null,3]\\n```\\nwhen I run it manually in console\\nbut when I submit the code it returns False\\nThis is a major issue\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    flag=False\\n    flag2=False\\n    temp1=None\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if Solution.flag2==False:\\n            Solution.temp1=head\\n            Solution.flag2=True\\n        if head==None and Solution.flag==True:\\n            return True\\n        elif root==None:\\n            return False\\n        if head.val==root.val:\\n            head=head.next\\n            Solution.flag=True\\n        else:\\n            head=Solution.temp1\\n            Solution.flag=False\\n        return self.isSubPath(head,root.left) or self.isSubPath(head,root.right)\\n```\n```\\n[3]\\n[1,5,3,null,4,null,3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333427,
                "title": "python-simple-maths",
                "content": "\\n    def isSubPath(self, head, root):\\n        paths = []\\n        \\n        def dfs(node, path):\\n            if not node:\\n                return\\n            \\n            path += str(node.val)\\n            \\n            if not node.left and not node.right:\\n                paths.append(path)\\n            else:\\n                dfs(node.left, path)\\n                dfs(node.right, path)\\n                \\n                \\n        dfs(root, \"\")\\n            \\n        cur, str1 = head, \"\"\\n        \\n        while cur:\\n            str1 += str(cur.val)\\n            cur = cur.next\\n            \\n        return any([str1 in i for i in paths])",
                "solutionTags": [],
                "code": "\\n    def isSubPath(self, head, root):\\n        paths = []\\n        \\n        def dfs(node, path):\\n            if not node:\\n                return\\n            \\n            path += str(node.val)\\n            \\n            if not node.left and not node.right:\\n                paths.append(path)\\n            else:\\n                dfs(node.left, path)\\n                dfs(node.right, path)\\n                \\n                \\n        dfs(root, \"\")\\n            \\n        cur, str1 = head, \"\"\\n        \\n        while cur:\\n            str1 += str(cur.val)\\n            cur = cur.next\\n            \\n        return any([str1 in i for i in paths])",
                "codeTag": "Python3"
            },
            {
                "id": 2263393,
                "title": "c-dfs",
                "content": "```\\nbool eachNode(ListNode *head, TreeNode *root){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root){\\n            if(root->val==head->val){\\n                return eachNode(head->next,root->left)||eachNode(head->next,root->right);\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(head==NULL){\\n                return true;\\n            }\\n\\t\\t\\t// checking is there any subpaths exist from root node\\n            if(eachNode(head,root)){\\n                return true;\\n            }\\n            else{\\n\\t\\t\\t// checking the subpath from left and right childs\\n                return isSubPath(head,root->left)||isSubPath(head,root->right);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nbool eachNode(ListNode *head, TreeNode *root){\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root){\\n            if(root->val==head->val){\\n                return eachNode(head->next,root->left)||eachNode(head->next,root->right);\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root){\\n            if(head==NULL){\\n                return true;\\n            }\\n\\t\\t\\t// checking is there any subpaths exist from root node\\n            if(eachNode(head,root)){\\n                return true;\\n            }\\n            else{\\n\\t\\t\\t// checking the subpath from left and right childs\\n                return isSubPath(head,root->left)||isSubPath(head,root->right);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2225117,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void trav(TreeNode *root, vector<TreeNode*> &v, int target)\\n    {\\n        if(root == NULL) return;\\n        \\n        if(root->val == target) v.push_back(root);\\n        trav(root->left, v, target);\\n        trav(root->right, v, target);\\n    }\\n    \\n    void check(ListNode* head, TreeNode* root, int* x, bool *flag, int size)\\n    {\\n        if(*x == size) *flag = true;\\n        if(head == NULL) return;\\n        if(root == NULL) return;\\n        if(root->val != head->val)\\n        {\\n            return;\\n        }\\n        \\n        *x += 1;\\n        cout << *x << \"-\" << root->val << \" \"; \\n        \\n        check(head->next, root->left, x, flag, size);\\n        check(head->next, root->right, x, flag, size);\\n        *x -= 1;\\n\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        if(head == NULL || root == NULL)\\n        {\\n            return false;\\n        }\\n        \\n        vector<TreeNode*> v;\\n        trav(root, v, head->val);\\n        \\n        bool x = false;\\n        int count = 0, size = 0;\\n        ListNode* trav = head;\\n        \\n       while(trav != NULL)\\n       {\\n           size += 1;\\n           trav = trav->next;\\n       }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            // x = true;\\n            count = 0;\\n            check(head, v[i], &count, &x, size);\\n            if(x == true)\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void trav(TreeNode *root, vector<TreeNode*> &v, int target)\\n    {\\n        if(root == NULL) return;\\n        \\n        if(root->val == target) v.push_back(root);\\n        trav(root->left, v, target);\\n        trav(root->right, v, target);\\n    }\\n    \\n    void check(ListNode* head, TreeNode* root, int* x, bool *flag, int size)\\n    {\\n        if(*x == size) *flag = true;\\n        if(head == NULL) return;\\n        if(root == NULL) return;\\n        if(root->val != head->val)\\n        {\\n            return;\\n        }\\n        \\n        *x += 1;\\n        cout << *x << \"-\" << root->val << \" \"; \\n        \\n        check(head->next, root->left, x, flag, size);\\n        check(head->next, root->right, x, flag, size);\\n        *x -= 1;\\n\\n    }\\n    \\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        if(head == NULL || root == NULL)\\n        {\\n            return false;\\n        }\\n        \\n        vector<TreeNode*> v;\\n        trav(root, v, head->val);\\n        \\n        bool x = false;\\n        int count = 0, size = 0;\\n        ListNode* trav = head;\\n        \\n       while(trav != NULL)\\n       {\\n           size += 1;\\n           trav = trav->next;\\n       }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            // x = true;\\n            count = 0;\\n            check(head, v[i], &count, &x, size);\\n            if(x == true)\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2205230,
                "title": "javascript-dfs",
                "content": "```\\nvar isSubPath = function(head, root) {\\n  return dfs(root, head)\\n};\\n\\nfunction dfs(root, head){\\n  if(!root) return false\\n  if(search(root, head)) return true\\n  return dfs(root.left, head) || dfs(root.right, head)\\n}\\n\\nfunction search(root, head){\\n  if(!root && head) return false\\n  if(!head) return true\\n  if(root.val !== head.val) return false  \\n  return search(root.left, head.next) || search(root.right, head.next)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar isSubPath = function(head, root) {\\n  return dfs(root, head)\\n};\\n\\nfunction dfs(root, head){\\n  if(!root) return false\\n  if(search(root, head)) return true\\n  return dfs(root.left, head) || dfs(root.right, head)\\n}\\n\\nfunction search(root, head){\\n  if(!root && head) return false\\n  if(!head) return true\\n  if(root.val !== head.val) return false  \\n  return search(root.left, head.next) || search(root.right, head.next)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195209,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isequal(ListNode* ll, TreeNode* bt) {\\n        if (bt == NULL and ll != NULL) return false;\\n        if (ll == NULL) return true;\\n        if (bt -> val != ll -> val) {\\n            return false;\\n        }\\n        return isequal(ll -> next, bt -> left) || isequal(ll -> next, bt -> right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        if (root -> val == head -> val) {\\n            if (isequal (head, root)) {\\n                return true;\\n            }\\n        }\\n        return   isSubPath(head, root -> left) || isSubPath(head, root -> right) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isequal(ListNode* ll, TreeNode* bt) {\\n        if (bt == NULL and ll != NULL) return false;\\n        if (ll == NULL) return true;\\n        if (bt -> val != ll -> val) {\\n            return false;\\n        }\\n        return isequal(ll -> next, bt -> left) || isequal(ll -> next, bt -> right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (root == NULL) return false;\\n        if (root -> val == head -> val) {\\n            if (isequal (head, root)) {\\n                return true;\\n            }\\n        }\\n        return   isSubPath(head, root -> left) || isSubPath(head, root -> right) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173810,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> A;\\n    bool check(TreeNode* root, ListNode* head){\\n        if(!head) return true;\\n        if(!root || root -> val != head -> val) return false;\\n        return check(root -> left, head -> next) || check(root -> right, head -> next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        helper(root, head -> val);\\n        for(auto& a: A)\\n            if(check(a, head)) return true;\\n        return false;\\n    }\\n    void helper(TreeNode* root, int& a){\\n        if(!root) return;\\n        if(root -> val == a)\\n            A.push_back(root);\\n        helper(root -> left, a);\\n        helper(root -> right, a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> A;\\n    bool check(TreeNode* root, ListNode* head){\\n        if(!head) return true;\\n        if(!root || root -> val != head -> val) return false;\\n        return check(root -> left, head -> next) || check(root -> right, head -> next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        helper(root, head -> val);\\n        for(auto& a: A)\\n            if(check(a, head)) return true;\\n        return false;\\n    }\\n    void helper(TreeNode* root, int& a){\\n        if(!root) return;\\n        if(root -> val == a)\\n            A.push_back(root);\\n        helper(root -> left, a);\\n        helper(root -> right, a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128218,
                "title": "damnn-simpleee-recursive-solution",
                "content": "bool path_from_root(TreeNode* root,ListNode* head)\\n    {\\n         if(!head)\\n            return true;\\n         if(!root)\\n             return false;\\n        \\n         if(root->val!=head->val)\\n            return false;\\n        \\n    return path_from_root(root->left,head->next) or path_from_root(root->right,head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n       if(!head)   //linklist ke last tk phuch gye \\n            return true;\\n        \\n       if(!root)\\n           return false;\\n        \\nreturn path_from_root(root,head) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n\\n    }",
                "solutionTags": [],
                "code": "bool path_from_root(TreeNode* root,ListNode* head)\\n    {\\n         if(!head)\\n            return true;\\n         if(!root)\\n             return false;\\n        \\n         if(root->val!=head->val)\\n            return false;\\n        \\n    return path_from_root(root->left,head->next) or path_from_root(root->right,head->next);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n       if(!head)   //linklist ke last tk phuch gye \\n            return true;\\n        \\n       if(!root)\\n           return false;\\n        \\nreturn path_from_root(root,head) or isSubPath(head,root->left) or isSubPath(head,root->right);\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2090799,
                "title": "java-easy-dfs-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\t\\tif(root == null) return false;\\n\\t\\t\\tif(head == null) return true;\\n\\t\\t\\treturn dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n\\t\\t}\\n\\n\\t\\tboolean dfs(ListNode head,TreeNode root){\\n\\t\\t\\tif(head==null) return true;\\n\\t\\t\\tif(root==null) return false;\\n\\t\\t\\treturn (head.val == root.val) && (dfs(head.next,root.left) || dfs(head.next,root.right));\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\t\\tif(root == null) return false;\\n\\t\\t\\tif(head == null) return true;\\n\\t\\t\\treturn dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2080171,
                "title": "inorder-recursion-c-easy",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL && root==NULL)\\n            return true;\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        return head->val==root->val && (check(head->next,root->left) || check(head->next,root->right));\\n    }\\nvoid inorder(ListNode *head,vector<TreeNode*> &harsh,TreeNode *root)\\n{\\n    if( !root)\\n        return ;\\n    inorder(head,harsh,root->left);\\n    if(head->val==root->val)\\n    {\\n        harsh.push_back(root);\\n    }\\n    inorder(head,harsh,root->right);\\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n      // its actually a very tough question .......\\n        vector<TreeNode*> harsh;\\n        inorder(head,harsh,root);\\n        for(TreeNode *tmp:harsh){\\n            if(check(head,tmp)==true)\\n                return true;\\n        }\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL && root==NULL)\\n            return true;\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        return head->val==root->val && (check(head->next,root->left) || check(head->next,root->right));\\n    }\\nvoid inorder(ListNode *head,vector<TreeNode*> &harsh,TreeNode *root)\\n{\\n    if( !root)\\n        return ;\\n    inorder(head,harsh,root->left);\\n    if(head->val==root->val)\\n    {\\n        harsh.push_back(root);\\n    }\\n    inorder(head,harsh,root->right);\\n}\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n      // its actually a very tough question .......\\n        vector<TreeNode*> harsh;\\n        inorder(head,harsh,root);\\n        for(TreeNode *tmp:harsh){\\n            if(check(head,tmp)==true)\\n                return true;\\n        }\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051190,
                "title": "simple-preorder-technique-in-java",
                "content": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean check(ListNode head, TreeNode root)\\n    {\\n        if(root ==null) return false;\\n        if(root.val!=head.val) return false;\\n        if(head.next==null) return true;\\n        return check(head.next,root.left) || check(head.next,root.right);\\n    }\\n    public void  f(ListNode head, TreeNode root)\\n    {\\n        if(root==null) return;\\n        if(check(head,root)) flag=true;\\n        f(head,root.left);\\n        f(head,root.right);\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        f(head,root);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean check(ListNode head, TreeNode root)\\n    {\\n        if(root ==null) return false;\\n        if(root.val!=head.val) return false;\\n        if(head.next==null) return true;\\n        return check(head.next,root.left) || check(head.next,root.right);\\n    }\\n    public void  f(ListNode head, TreeNode root)\\n    {\\n        if(root==null) return;\\n        if(check(head,root)) flag=true;\\n        f(head,root.left);\\n        f(head,root.right);\\n        \\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        f(head,root);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022374,
                "title": "easy-python-solution-with-recursion",
                "content": "**For any doubt please comment , will be happy to help you :)**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def helper(self,head ,root):\\n        if head is None:\\n            return True\\n        \\n        leftCheck = False\\n        if root.left and head.val == root.left.val:\\n            leftCheck = self.helper(head.next,root.left)\\n        \\n        rightCheck = False\\n        if root.right and head.val == root.right.val:\\n            rightCheck = self.helper(head.next,root.right)\\n        \\n        return leftCheck or rightCheck\\n        \\n        \\n            \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if root is None:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.helper(head.next,root):\\n                return True\\n        \\n        leftCheck = self.isSubPath(head,root.left)\\n        rightCheck = self.isSubPath(head,root.right)\\n        \\n        return leftCheck or rightCheck\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def helper(self,head ,root):\\n        if head is None:\\n            return True\\n        \\n        leftCheck = False\\n        if root.left and head.val == root.left.val:\\n            leftCheck = self.helper(head.next,root.left)\\n        \\n        rightCheck = False\\n        if root.right and head.val == root.right.val:\\n            rightCheck = self.helper(head.next,root.right)\\n        \\n        return leftCheck or rightCheck\\n        \\n        \\n            \\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        if root is None:\\n            return False\\n        \\n        if root.val == head.val:\\n            if self.helper(head.next,root):\\n                return True\\n        \\n        leftCheck = self.isSubPath(head,root.left)\\n        rightCheck = self.isSubPath(head,root.right)\\n        \\n        return leftCheck or rightCheck\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991832,
                "title": "java-100-faster-solution-with-comments-for-better-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       return dfs(head,root);\\n    }\\n    private boolean dfs(ListNode head,TreeNode root){\\n        if(root==null)return false;\\n        if(match(head,root))return true;//check that value match or not;\\n        return dfs(head,root.left) || dfs(head,root.right);//traverse on tree \\n        \\n    }\\n    private boolean match(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null || root.val!=head.val)return false;\\n        return match(head.next,root.left) || match(head.next,root.right);  //check that value match or not\\n    }\\n}\\n```\\nif it is helpful upvote please",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       return dfs(head,root);\\n    }\\n    private boolean dfs(ListNode head,TreeNode root){\\n        if(root==null)return false;\\n        if(match(head,root))return true;//check that value match or not;\\n        return dfs(head,root.left) || dfs(head,root.right);//traverse on tree \\n        \\n    }\\n    private boolean match(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null || root.val!=head.val)return false;\\n        return match(head.next,root.left) || match(head.next,root.right);  //check that value match or not\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975238,
                "title": "c-easy-recursion-sol",
                "content": "if you liked it please vote up :)\\n```\\nbool check(struct ListNode* head, struct TreeNode* root);\\nbool isSubPath(struct ListNode* head, struct TreeNode* root)\\n{\\n    bool flag;\\n    if(!root)\\n    {\\n        return false;\\n    }\\n    \\n    flag=check(head,root);\\n    \\n    \\n    return flag|| isSubPath(head,root->left)||isSubPath(head,root->right);  \\n    \\n}\\nbool check(struct ListNode* head, struct TreeNode* root)\\n{\\n    \\n  if(!root)\\n  {\\n      return false;\\n  }\\n  if(!head->next)\\n  {\\n      return head->val==root->val;\\n  }\\n    \\n return head->val==root->val&&(check(head->next,root->left)||check(head->next,root->right)); \\n}",
                "solutionTags": [],
                "code": "if you liked it please vote up :)\\n```\\nbool check(struct ListNode* head, struct TreeNode* root);\\nbool isSubPath(struct ListNode* head, struct TreeNode* root)\\n{\\n    bool flag;\\n    if(!root)\\n    {\\n        return false;\\n    }\\n    \\n    flag=check(head,root);\\n    \\n    \\n    return flag|| isSubPath(head,root->left)||isSubPath(head,root->right);  \\n    \\n}\\nbool check(struct ListNode* head, struct TreeNode* root)\\n{\\n    \\n  if(!root)\\n  {\\n      return false;\\n  }\\n  if(!head->next)\\n  {\\n      return head->val==root->val;\\n  }\\n    \\n return head->val==root->val&&(check(head->next,root->left)||check(head->next,root->right)); \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1970008,
                "title": "c-easy-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948979,
                "title": "simple-java-recurrsive-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.val == head.val){\\n          if(isList(head.next, root.left) || isList(head.next, root.right)){\\n              return true;\\n          }else{\\n              return isSubPath(head, root.left) || isSubPath(head,root.right); \\n          }\\n        }else{\\n          return isSubPath(head, root.left) || isSubPath(head,root.right);  \\n        }\\n    }\\n    \\n    public boolean isList(ListNode head, TreeNode root){\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(head.val == root.val){\\n            return isList(head.next,root.left) || isList(head.next,root.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.val == head.val){\\n          if(isList(head.next, root.left) || isList(head.next, root.right)){\\n              return true;\\n          }else{\\n              return isSubPath(head, root.left) || isSubPath(head,root.right); \\n          }\\n        }else{\\n          return isSubPath(head, root.left) || isSubPath(head,root.right);  \\n        }\\n    }\\n    \\n    public boolean isList(ListNode head, TreeNode root){\\n        if(head == null){\\n            return true;\\n        }\\n        if(root == null){\\n            return false;\\n        }\\n        if(head.val == root.val){\\n            return isList(head.next,root.left) || isList(head.next,root.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938923,
                "title": "linked-list-in-binary-tree",
                "content": "```\\n# You just need to think like this \\n# If head matches with root value we will go check at right and left \\n# if not then we wil check both left and right.\\n# If any side will traversal path is able to give me right list \\n# we will return true\\n# You have to just think how traversal can be done and base cases\\n```\\n```\\nclass Solution \\n{\\npublic:\\n      bool inpath(ListNode* head, TreeNode* root)\\n      {\\n        if(root==NULL && head!=NULL)\\n            return false;  \\n        if(head==NULL)\\n            return true;\\n        if(head->val!=root->val)\\n            return false;\\n        return inpath(head->next,root->left)||inpath(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {     \\n        if(root==NULL)\\n            return false;\\n        else if(head==NULL)\\n            return true;\\n        else if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n# You just need to think like this \\n# If head matches with root value we will go check at right and left \\n# if not then we wil check both left and right.\\n# If any side will traversal path is able to give me right list \\n# we will return true\\n# You have to just think how traversal can be done and base cases\\n```\n```\\nclass Solution \\n{\\npublic:\\n      bool inpath(ListNode* head, TreeNode* root)\\n      {\\n        if(root==NULL && head!=NULL)\\n            return false;  \\n        if(head==NULL)\\n            return true;\\n        if(head->val!=root->val)\\n            return false;\\n        return inpath(head->next,root->left)||inpath(head->next,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {     \\n        if(root==NULL)\\n            return false;\\n        else if(head==NULL)\\n            return true;\\n        else if(root->val == head->val)\\n        {\\n            if(inpath(head,root))\\n                return true;\\n        }\\n        return isSubPath(head,root->left)||isSubPath(head,root->right);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928165,
                "title": "java-recursive-solution-100-beat",
                "content": "![image](https://assets.leetcode.com/users/images/2a689bc0-e15d-4b1f-8f89-2380d22e9674_1649432742.9112298.png)\\n```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<TreeNode> treeList = new ArrayList<>();\\n        storeTreeAsList(treeList, head, root);\\n        for(TreeNode treeNode: treeList) {\\n            if(checkPath(head, treeNode)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void storeTreeAsList(List<TreeNode> tree, ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null || treeNode == null) {\\n            return;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            tree.add(treeNode);\\n        }\\n        storeTreeAsList(tree, listNode, treeNode.left);\\n        storeTreeAsList(tree, listNode, treeNode.right);\\n    }\\n    \\n    public boolean checkPath(ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null) {\\n            return true;\\n        }\\n        if(treeNode == null) {\\n            return false;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            return checkPath(listNode.next, treeNode.left) || checkPath(listNode.next, treeNode.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        List<TreeNode> treeList = new ArrayList<>();\\n        storeTreeAsList(treeList, head, root);\\n        for(TreeNode treeNode: treeList) {\\n            if(checkPath(head, treeNode)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void storeTreeAsList(List<TreeNode> tree, ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null || treeNode == null) {\\n            return;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            tree.add(treeNode);\\n        }\\n        storeTreeAsList(tree, listNode, treeNode.left);\\n        storeTreeAsList(tree, listNode, treeNode.right);\\n    }\\n    \\n    public boolean checkPath(ListNode listNode, TreeNode treeNode) {\\n        if(listNode == null) {\\n            return true;\\n        }\\n        if(treeNode == null) {\\n            return false;\\n        }\\n        if(listNode.val == treeNode.val) {\\n            return checkPath(listNode.next, treeNode.left) || checkPath(listNode.next, treeNode.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923025,
                "title": "c-simple-recursion-dfs",
                "content": "```\\n\\t void search(TreeNode* root,int target,vector<TreeNode*> &hits ){\\n        if(root==NULL)\\n            return;\\n        search(root->left,target,hits);\\n        if(root->val==target)\\n            hits.push_back(root);\\n        search(root->right,target,hits);\\n    }\\n    bool solve(TreeNode* root,ListNode* head){\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        if(root->val == head->val){\\n            return (solve(root->left,head->next) || solve(root->right,head->next));\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> hits;\\n        search(root,head->val,hits);\\n        for(auto x:hits){\\n            if(solve(x,head))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\t void search(TreeNode* root,int target,vector<TreeNode*> &hits ){\\n        if(root==NULL)\\n            return;\\n        search(root->left,target,hits);\\n        if(root->val==target)\\n            hits.push_back(root);\\n        search(root->right,target,hits);\\n    }\\n    bool solve(TreeNode* root,ListNode* head){\\n        if(head==NULL)\\n            return true;\\n        if(root==NULL)\\n            return false;\\n        if(root->val == head->val){\\n            return (solve(root->left,head->next) || solve(root->right,head->next));\\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        vector<TreeNode*> hits;\\n        search(root,head->val,hits);\\n        for(auto x:hits){\\n            if(solve(x,head))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916045,
                "title": "simple-and-clean-code-using-simple-recursion-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        boolean linkedListStartsFromMe=false;\\n        if(root.val==head.val){\\n            linkedListStartsFromMe = \\n                checkLinkedListFromRoot(head.next,root.left) \\n                || checkLinkedListFromRoot(head.next,root.right);\\n        }\\n        if(linkedListStartsFromMe)return true;\\n        \\n        return isSubPath(head,root.left) || isSubPath(head,root.right);\\n        \\n    }\\n\\t/**\\n\\t* method to check if the LL at head is found in Tree at root beginning from the root\\n\\t*/\\n    private boolean checkLinkedListFromRoot(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        if(root.val!=head.val)return false;\\n        return checkLinkedListFromRoot(head.next,root.left)\\n\\t\\t|| checkLinkedListFromRoot(head.next,root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        \\n        boolean linkedListStartsFromMe=false;\\n        if(root.val==head.val){\\n            linkedListStartsFromMe = \\n                checkLinkedListFromRoot(head.next,root.left) \\n                || checkLinkedListFromRoot(head.next,root.right);\\n        }\\n        if(linkedListStartsFromMe)return true;\\n        \\n        return isSubPath(head,root.left) || isSubPath(head,root.right);\\n        \\n    }\\n\\t/**\\n\\t* method to check if the LL at head is found in Tree at root beginning from the root\\n\\t*/\\n    private boolean checkLinkedListFromRoot(ListNode head,TreeNode root){\\n        if(head==null)return true;\\n        if(root==null)return false;\\n        if(root.val!=head.val)return false;\\n        return checkLinkedListFromRoot(head.next,root.left)\\n\\t\\t|| checkLinkedListFromRoot(head.next,root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913230,
                "title": "c-dfs-code",
                "content": "```\\nclass Solution {\\npublic:\\n    public:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head || !root)\\n            return 0;\\n        \\n        return help(head,root) || isSubPath(head,root->right) || isSubPath(head,root->left);\\n    }\\n    bool help(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL)\\n            return 1;\\n        if(root==NULL)\\n            return 0;\\n        if(head->val!=root->val)\\n            return 0;\\n        \\n        return help(head->next,root->left) || help(head->next,root->right);\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    public:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head || !root)\\n            return 0;\\n        \\n        return help(head,root) || isSubPath(head,root->right) || isSubPath(head,root->left);\\n    }\\n    bool help(ListNode *head,TreeNode *root)\\n    {\\n        if(head==NULL)\\n            return 1;\\n        if(root==NULL)\\n            return 0;\\n        if(head->val!=root->val)\\n            return 0;\\n        \\n        return help(head->next,root->left) || help(head->next,root->right);\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902258,
                "title": "python-very-easy-iterative-solution",
                "content": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        newls = []\\n        while head != None:\\n            newls.append(head.val)\\n            head = head.next\\n        newstr = \"\".join(map(str, newls))\\n        rootls = [[root, str(root.val)]]\\n        while len(rootls) != 0:\\n            root, rootstring = rootls.pop()\\n            if root != None:\\n                toadd = rootstring + str(root.val)\\n                if newstr in toadd:\\n                    return True\\n                rootls.append([root.left, toadd])\\n                rootls.append([root.right, toadd])\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        newls = []\\n        while head != None:\\n            newls.append(head.val)\\n            head = head.next\\n        newstr = \"\".join(map(str, newls))\\n        rootls = [[root, str(root.val)]]\\n        while len(rootls) != 0:\\n            root, rootstring = rootls.pop()\\n            if root != None:\\n                toadd = rootstring + str(root.val)\\n                if newstr in toadd:\\n                    return True\\n                rootls.append([root.left, toadd])\\n                rootls.append([root.right, toadd])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890531,
                "title": "simple-pre-order-traversal",
                "content": "```\\n  boolean _isSubPath(TreeNode root,String str, StringBuilder sb1){\\n        if(root==null){\\n          return str.contains(sb1.toString());   \\n        }\\n        str=str+root.val;\\n        return _isSubPath(root.left,str,sb1)|| _isSubPath(root.right,str,sb1);\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        StringBuilder sb=new StringBuilder();\\n        StringBuilder sb1=new StringBuilder();\\n        while(head!=null){\\n            sb1.append(head.val);\\n            head=head.next;\\n        }\\n        return _isSubPath(root,\"\",sb1);        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  boolean _isSubPath(TreeNode root,String str, StringBuilder sb1){\\n        if(root==null){\\n          return str.contains(sb1.toString());   \\n        }\\n        str=str+root.val;\\n        return _isSubPath(root.left,str,sb1)|| _isSubPath(root.right,str,sb1);\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        StringBuilder sb=new StringBuilder();\\n        StringBuilder sb1=new StringBuilder();\\n        while(head!=null){\\n            sb1.append(head.val);\\n            head=head.next;\\n        }\\n        return _isSubPath(root,\"\",sb1);        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869850,
                "title": "c-recursion",
                "content": "bool checkif(ListNode* head,TreeNode* root){\\n        if(head==NULL ) return true;\\n        if(root==NULL && head !=NULL) return false;\\n        \\n        if(head->val ==root->val) \\n            return checkif(head->next,root->left) || checkif(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n       if(checkif(head,root)) return true;;\\n       return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "bool checkif(ListNode* head,TreeNode* root){\\n        if(head==NULL ) return true;\\n        if(root==NULL && head !=NULL) return false;\\n        \\n        if(head->val ==root->val) \\n            return checkif(head->next,root->left) || checkif(head->next,root->right);\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n       if(checkif(head,root)) return true;;\\n       return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1867112,
                "title": "c-easy-recursive-code",
                "content": "```\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n```\\n**guys if you got the concept then please give and upvote for me.**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n    bool match(ListNode* head, TreeNode* root){\\n        if(head == NULL) return true;\\n        if(root == NULL || root->val != head->val) return false;\\n        return match(head->next, root->left) || match(head->next, root->right);\\n    }\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root == NULL) return false;\\n        if(match(head, root)) return true;\\n        return dfs(head,root->left) || dfs(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        return dfs(head,root);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858358,
                "title": "python-solution-for-beginners-recursion-with-comments-dfs",
                "content": "\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def isConnected(root,head): ##checks if linked list is in the tree\\n            if head is None: #when linked list ends, it is there! \\n                return True\\n            \\n            if root is None: #when root ends\\n                return root == head\\n            \\n            if root.val != head.val: #value not equal \\n                return False\\n            \\n            # check left and right subtree\\n            return isConnected(root.left,head.next) or isConnected(root.right,head.next)\\n        \\n        \\n        def helper(root):\\n            if not root:\\n                return False\\n            \\n            if root.val == head.val: ##if a values matches, check down the path\\n                if isConnected(root,head):\\n                    return True\\n                    \\n            # go through left and right subtree\\n            return helper(root.left) or helper(root.right)\\n        \\n        \\n        return helper(root)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        \\n        def isConnected(root,head): ##checks if linked list is in the tree\\n            if head is None: #when linked list ends, it is there! \\n                return True\\n            \\n            if root is None: #when root ends\\n                return root == head\\n            \\n            if root.val != head.val: #value not equal \\n                return False\\n            \\n            # check left and right subtree\\n            return isConnected(root.left,head.next) or isConnected(root.right,head.next)\\n        \\n        \\n        def helper(root):\\n            if not root:\\n                return False\\n            \\n            if root.val == head.val: ##if a values matches, check down the path\\n                if isConnected(root,head):\\n                    return True\\n                    \\n            # go through left and right subtree\\n            return helper(root.left) or helper(root.right)\\n        \\n        \\n        return helper(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856809,
                "title": "go-contiguous-path",
                "content": "```\\nfunc isSubPath(h *ListNode, r *TreeNode) bool {\\n    var isContiguous func(h *ListNode, r *TreeNode) bool\\n    isContiguous = func(h *ListNode, r *TreeNode) bool {\\n        if h == nil { return true }\\n        if r == nil { return false }\\n        if h.Val == r.Val {\\n            return isContiguous(h.Next, r.Left) ||\\n                    isContiguous(h.Next, r.Right)\\n        }\\n        return false\\n    }\\n    \\n    if h == nil { return true }\\n    if r == nil { return false }\\n    if h.Val == r.Val && isContiguous(h,r) { return true }\\n    return isSubPath(h, r.Left) || isSubPath(h, r.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isSubPath(h *ListNode, r *TreeNode) bool {\\n    var isContiguous func(h *ListNode, r *TreeNode) bool\\n    isContiguous = func(h *ListNode, r *TreeNode) bool {\\n        if h == nil { return true }\\n        if r == nil { return false }\\n        if h.Val == r.Val {\\n            return isContiguous(h.Next, r.Left) ||\\n                    isContiguous(h.Next, r.Right)\\n        }\\n        return false\\n    }\\n    \\n    if h == nil { return true }\\n    if r == nil { return false }\\n    if h.Val == r.Val && isContiguous(h,r) { return true }\\n    return isSubPath(h, r.Left) || isSubPath(h, r.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1856785,
                "title": "python-contiguous-path",
                "content": "Need to make sure that the path is contiguous\\n```\\nclass Solution:\\n    \\n    def isContiguousPath(self, h:Optional[ListNode], r:Optional[TreeNode]) ->bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val:\\n            return self.isContiguousPath(h.next, r.left) or \\\\\\n                    self.isContiguousPath(h.next, r.right)\\n            \\n        return False\\n\\n\\n    def isSubPath(self, h: Optional[ListNode], r: Optional[TreeNode]) -> bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val and self.isContiguousPath(h, r): return True\\n                \\n        return self.isSubPath(h, r.left) or \\\\\\n                self.isSubPath(h, r.right)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def isContiguousPath(self, h:Optional[ListNode], r:Optional[TreeNode]) ->bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val:\\n            return self.isContiguousPath(h.next, r.left) or \\\\\\n                    self.isContiguousPath(h.next, r.right)\\n            \\n        return False\\n\\n\\n    def isSubPath(self, h: Optional[ListNode], r: Optional[TreeNode]) -> bool:\\n        if not h: return True\\n        if not r: return False\\n        if h.val == r.val and self.isContiguousPath(h, r): return True\\n                \\n        return self.isSubPath(h, r.left) or \\\\\\n                self.isSubPath(h, r.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849959,
                "title": "python-traversal-and-search",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        list_ele,itr=\"\",head\\n        while itr:\\n            list_ele+=str(itr.val)\\n            itr=itr.next\\n        ans=[]\\n        def helper(root,list_ele,string):\\n            if root.left is None and root.right is None:\\n                string+=str(root.val)\\n                if list_ele in string:\\n                    ans.append(string)\\n                return\\n            string+=str(root.val)\\n            if root.left:helper(root.left,list_ele,string)\\n            if root.right:helper(root.right,list_ele,string)\\n        helper(root,list_ele,\"\")\\n        return True if len(ans)!=0 else False\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        list_ele,itr=\"\",head\\n        while itr:\\n            list_ele+=str(itr.val)\\n            itr=itr.next\\n        ans=[]\\n        def helper(root,list_ele,string):\\n            if root.left is None and root.right is None:\\n                string+=str(root.val)\\n                if list_ele in string:\\n                    ans.append(string)\\n                return\\n            string+=str(root.val)\\n            if root.left:helper(root.left,list_ele,string)\\n            if root.right:helper(root.right,list_ele,string)\\n        helper(root,list_ele,\"\")\\n        return True if len(ans)!=0 else False\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836302,
                "title": "java-100-faster-self-explainatory-easy",
                "content": "```\\nclass Solution {\\n    boolean flag = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(flag) return true;\\n        if(root == null) return false;\\n        if(root.val == head.val) check(root,head.next);\\n        boolean left = isSubPath(head,root.left);\\n        boolean right = isSubPath(head,root.right);\\n        return left || right;\\n    }\\n    public void check(TreeNode root,ListNode head){\\n        if(flag) return; \\n        if(head == null){\\n            flag = true;\\n            return;\\n        }\\n        if(root.left != null && root.left.val == head.val) check(root.left,head.next);\\n        if(root.right != null && root.right.val == head.val) check(root.right,head.next);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean flag = false;\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(flag) return true;\\n        if(root == null) return false;\\n        if(root.val == head.val) check(root,head.next);\\n        boolean left = isSubPath(head,root.left);\\n        boolean right = isSubPath(head,root.right);\\n        return left || right;\\n    }\\n    public void check(TreeNode root,ListNode head){\\n        if(flag) return; \\n        if(head == null){\\n            flag = true;\\n            return;\\n        }\\n        if(root.left != null && root.left.val == head.val) check(root.left,head.next);\\n        if(root.right != null && root.right.val == head.val) check(root.right,head.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607068,
                "title": "python-iterative-bfs-beats-97",
                "content": "**Steps**\\n1. Convert the linked list to a regular list\\n```      \\nself.path = []\\nwhile head:\\n\\tself.path.append(head.val)\\n\\thead = head.next\\n```\\n2. Perform a BFS starting at the root, keeping track of the last n visited nodes where n is the length of the linked list\\n```\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n```\\n\\n3. If the last n visted nodes == the linked list path, return true\\n```\\nif path == self.path: return True\\n```\\n\\n**Complete Code:**\\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        self.path = []\\n        while head:\\n            self.path.append(head.val)\\n            head = head.next\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if path == self.path: return True\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n            bfsList = nextList\\n            count += 1\\n        return False\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```      \\nself.path = []\\nwhile head:\\n\\tself.path.append(head.val)\\n\\thead = head.next\\n```\n```\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n```\n```\\nif path == self.path: return True\\n```\n```\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        self.path = []\\n        while head:\\n            self.path.append(head.val)\\n            head = head.next\\n        n = len(self.path)\\n        bfsList = [(root,[root.val])]\\n        count = 0\\n        while bfsList:\\n            nextList = deque()\\n            for i, path in bfsList:\\n                if count < n - 1:\\n                    if i.left:\\n                        nextList.append((i.left,path+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path+[i.right.val]))\\n                else:\\n                    if path == self.path: return True\\n                    if i.left:\\n                        nextList.append((i.left,path[1:]+[i.left.val]))\\n                    if i.right:\\n                        nextList.append((i.right,path[1:]+[i.right.val]))\\n            bfsList = nextList\\n            count += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601422,
                "title": "what-s-wrong-with-this-simple-solution-in-python",
                "content": "I tried this simple solution which works for a majority of the test cases but fails on some specific large output. Can somebody tell me what the flaw in the logic is? \\n\\n```\\ndef isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(head, root):\\n            if head == None:\\n                return True\\n            if root == None:\\n                return False\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.left)\\n            else:\\n                ret = dfs(head, root.left)\\n            if ret:\\n                return True\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.right)\\n            else:\\n                ret = dfs(head, root.right)\\n            return ret\\n        \\n        t = dfs(head, root)\\n        return t",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "I tried this simple solution which works for a majority of the test cases but fails on some specific large output. Can somebody tell me what the flaw in the logic is? \\n\\n```\\ndef isSubPath(self, head, root):\\n        \"\"\"\\n        :type head: ListNode\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(head, root):\\n            if head == None:\\n                return True\\n            if root == None:\\n                return False\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.left)\\n            else:\\n                ret = dfs(head, root.left)\\n            if ret:\\n                return True\\n            if root.val == head.val:\\n                ret = dfs(head.next, root.right)\\n            else:\\n                ret = dfs(head, root.right)\\n            return ret\\n        \\n        t = dfs(head, root)\\n        return t",
                "codeTag": "Python3"
            },
            {
                "id": 1588730,
                "title": "c-non-recursive-solution-share-for-fun-very-complicate",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        vector<int> values;\\n        while ( head )\\n        {\\n            values.push_back( head->val );\\n            head = head->next;\\n        }\\n\\n        stack<TreeNode*> node_stack;\\n        node_stack.push( root );\\n\\n        stack<TreeNode*> candidates;\\n        while ( !node_stack.empty() )\\n        {\\n            TreeNode* node = node_stack.top();\\n            if ( node->val == values[0] ) candidates.push(node);\\n            node_stack.pop();\\n            if ( node->right ) node_stack.push( node->right );\\n            if ( node->left  ) node_stack.push( node->left  );\\n        }\\n\\n        unordered_map<TreeNode*, bool> skip_nodes;\\n        while ( !candidates.empty() )\\n        {\\n            node_stack.push( candidates.top() );\\n            candidates.pop();\\n            int index = 0;\\n            skip_nodes.clear();\\n            while ( !node_stack.empty() )\\n            {\\n                TreeNode* candidate = node_stack.top();\\n                \\n                bool const chk = ( candidate->val == values[index] );\\n                if ( chk && index == values.size()-1 ) return true;\\n                if ( chk )\\n                {\\n                    if (  (nullptr == candidate->left && nullptr == candidate->right)\\n                       || (   skip_nodes.end() != skip_nodes.find(candidate->left) \\n                           && skip_nodes.end() != skip_nodes.find(candidate->right)     ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 2 >= index ) index = 0;\\n                            else index-=2;\\n                            node_stack.pop();\\n                        }\\n                    }\\n                    else if (  (   nullptr == candidate->left \\n                                && skip_nodes.end() != skip_nodes.find(candidate->right ) \\n                            || (   nullptr == candidate->right\\n                                && skip_nodes.end() != skip_nodes.find(candidate->left  ) ) ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (   ( node_stack.top()->left \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->left ) )\\n                            || ( node_stack.top()->right \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->right) ) )\\n                        {}\\n                        else\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                        \\n                    }\\n                    else\\n                    {\\n                        if ( candidate->right && skip_nodes.end() == skip_nodes.find(candidate->right) ) \\n                            node_stack.push( candidate->right);\\n                        if ( candidate->left && skip_nodes.end() == skip_nodes.find(candidate->left) )  \\n                            node_stack.push( candidate->left );\\n                        index++;\\n                    }\\n                }\\n                else\\n                {\\n                    node_stack.pop();\\n                    if ( node_stack.empty() ) break;\\n                    skip_nodes[candidate] = true;\\n                    if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        vector<int> values;\\n        while ( head )\\n        {\\n            values.push_back( head->val );\\n            head = head->next;\\n        }\\n\\n        stack<TreeNode*> node_stack;\\n        node_stack.push( root );\\n\\n        stack<TreeNode*> candidates;\\n        while ( !node_stack.empty() )\\n        {\\n            TreeNode* node = node_stack.top();\\n            if ( node->val == values[0] ) candidates.push(node);\\n            node_stack.pop();\\n            if ( node->right ) node_stack.push( node->right );\\n            if ( node->left  ) node_stack.push( node->left  );\\n        }\\n\\n        unordered_map<TreeNode*, bool> skip_nodes;\\n        while ( !candidates.empty() )\\n        {\\n            node_stack.push( candidates.top() );\\n            candidates.pop();\\n            int index = 0;\\n            skip_nodes.clear();\\n            while ( !node_stack.empty() )\\n            {\\n                TreeNode* candidate = node_stack.top();\\n                \\n                bool const chk = ( candidate->val == values[index] );\\n                if ( chk && index == values.size()-1 ) return true;\\n                if ( chk )\\n                {\\n                    if (  (nullptr == candidate->left && nullptr == candidate->right)\\n                       || (   skip_nodes.end() != skip_nodes.find(candidate->left) \\n                           && skip_nodes.end() != skip_nodes.find(candidate->right)     ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 2 >= index ) index = 0;\\n                            else index-=2;\\n                            node_stack.pop();\\n                        }\\n                    }\\n                    else if (  (   nullptr == candidate->left \\n                                && skip_nodes.end() != skip_nodes.find(candidate->right ) \\n                            || (   nullptr == candidate->right\\n                                && skip_nodes.end() != skip_nodes.find(candidate->left  ) ) ) )\\n                    {\\n                        node_stack.pop();\\n                        if ( node_stack.empty() ) break;\\n                        skip_nodes[candidate] = true;\\n                        if (   ( node_stack.top()->left \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->left ) )\\n                            || ( node_stack.top()->right \\n                                && skip_nodes.end() == skip_nodes.find(node_stack.top()->right) ) )\\n                        {}\\n                        else\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                        \\n                    }\\n                    else\\n                    {\\n                        if ( candidate->right && skip_nodes.end() == skip_nodes.find(candidate->right) ) \\n                            node_stack.push( candidate->right);\\n                        if ( candidate->left && skip_nodes.end() == skip_nodes.find(candidate->left) )  \\n                            node_stack.push( candidate->left );\\n                        index++;\\n                    }\\n                }\\n                else\\n                {\\n                    node_stack.pop();\\n                    if ( node_stack.empty() ) break;\\n                    skip_nodes[candidate] = true;\\n                    if (  (    nullptr == node_stack.top()->left \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->left) )\\n                           && (    nullptr == node_stack.top()->right \\n                                || skip_nodes.end() != skip_nodes.find(node_stack.top()->right) ) )\\n                        {\\n                            if ( 1 >= index ) index = 0;\\n                            else index--;\\n                        }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554242,
                "title": "java-clean-and-concise-dfs",
                "content": "```\\nclass Solution {\\n  \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       if(root == null)\\n           return false;\\n       /*check if there is a path which contains same data as the linked list from the current node*/\\n       if(helper(root,head))\\n           return true;\\n       /*if there isnt a path in the particular node then start checking from its left and right child*/ \\n       return isSubPath(head,root.left) || isSubPath(head,root.right); \\n    }\\n    \\n    boolean helper(TreeNode tNode,ListNode lNode) {\\n        /* checking every node is a valid path in the tree */\\n        /*if the lNode is null obviously it is the end of the linked list\\n          which means we found a path in the tree that has the same datas as the linked list*/\\n        if(lNode == null)\\n            return true;\\n        if(tNode == null) \\n            return false;\\n        /*if the tree\\'s current data and list\\'s data doesnt match it will lead to no path\\n        so we just return false*/\\n        if(tNode.val != lNode.val)\\n            return false;\\n        \\n        /*there are two possoibilities we might get a path either from the left or right,\\n        so if one of them is true definitely we found a path*/\\n        return helper(tNode.left,lNode.next) || helper(tNode.right,lNode.next);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n  \\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n       if(root == null)\\n           return false;\\n       /*check if there is a path which contains same data as the linked list from the current node*/\\n       if(helper(root,head))\\n           return true;\\n       /*if there isnt a path in the particular node then start checking from its left and right child*/ \\n       return isSubPath(head,root.left) || isSubPath(head,root.right); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1449945,
                "title": "java-solution",
                "content": "travel in the main function if root == null and head is not null then return false\\n - if the above statement is not true then use a helper function to find a find from the current node.\\n - along with the above step look for the path in the left and right side in the main function!\\n\\n```\\nclass Solution {\\n    public boolean helper(ListNode head,TreeNode root)\\n    {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        if(head.val == root.val)\\n            return helper(head.next,root.left) || helper(head.next,root.right);\\n        return false;\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        // with helper function we are checking whether we can form a path from the current node\\n        // repeat the same process for the left and right side of the current node\\n        return helper(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean helper(ListNode head,TreeNode root)\\n    {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        if(head.val == root.val)\\n            return helper(head.next,root.left) || helper(head.next,root.right);\\n        return false;\\n    }\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        if(head == null)\\n            return true;\\n        if(root == null)\\n            return false;\\n        // with helper function we are checking whether we can form a path from the current node\\n        // repeat the same process for the left and right side of the current node\\n        return helper(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426231,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(ListNode* head, TreeNode* root){\\n        if(head==NULL||root==NULL)return ;\\n        if(head->val!=root->val)return ;\\n        if(head->next==NULL){     //if we reach the end of list, that means list exists!! :)\\n            if(head->val==root->val){\\n                ans=1;\\n                return;\\n            }\\n        }\\n        helper(head->next,root->left);\\n        helper(head->next,root->right);\\n    }\\n    void doit(ListNode* head, TreeNode* root){\\n        if(!root)return ;\\n        if(head->val==root->val){\\n            helper(head,root);      //once we find values matching in list and tree, then from there, \\n\\t\\t\\t                       //we chek weather the complete list exist in tree or not!!!\\n        }\\n        doit(head,root->left);\\n        doit(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        doit(head,root);\\n        return ans;\\n    }\\n};\\n```\\npl upvote if u find it useful ;)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(ListNode* head, TreeNode* root){\\n        if(head==NULL||root==NULL)return ;\\n        if(head->val!=root->val)return ;\\n        if(head->next==NULL){     //if we reach the end of list, that means list exists!! :)\\n            if(head->val==root->val){\\n                ans=1;\\n                return;\\n            }\\n        }\\n        helper(head->next,root->left);\\n        helper(head->next,root->right);\\n    }\\n    void doit(ListNode* head, TreeNode* root){\\n        if(!root)return ;\\n        if(head->val==root->val){\\n            helper(head,root);      //once we find values matching in list and tree, then from there, \\n\\t\\t\\t                       //we chek weather the complete list exist in tree or not!!!\\n        }\\n        doit(head,root->left);\\n        doit(head,root->right);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        doit(head,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368564,
                "title": "dfs-6-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return dfs(root,head) || isSubPath(head, root->right) || isSubPath(head, root->left) ;\\n    }\\n    \\n    bool dfs(TreeNode* root, ListNode* head){\\n        if(!head) return true;        \\n        if(!root) return false;        \\n        if(root->val != head->val) return false;           \\n        return dfs(root->left,head->next) || dfs(root->right,head->next);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root) return false;\\n        return dfs(root,head) || isSubPath(head, root->right) || isSubPath(head, root->left) ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1368026,
                "title": "python-dfs-o-mn-solution",
                "content": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head:\\n                return True\\n            if not root or root.val != head.val:\\n                return False\\n            \\n            return dfs(head.next, root.left) or dfs(head.next, root.right)\\n        \\n        \\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if dfs(head, root):\\n            return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSubPath(self, head, root):\\n        def dfs(head, root):\\n            if not head:\\n                return True\\n            if not root or root.val != head.val:\\n                return False\\n            \\n            return dfs(head.next, root.left) or dfs(head.next, root.right)\\n        \\n        \\n        if not head:\\n            return True\\n        if not root:\\n            return False\\n        if dfs(head, root):\\n            return True\\n        \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362665,
                "title": "java-simple-solution-using-bfs-for-traversal-and-recursion-for-search",
                "content": "```\\nclass Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode temp = q.poll();\\n            \\n            if(temp.val==head.val && verify(head.next, temp))\\n                return true;\\n            \\n            if(temp.left!=null)\\n                q.offer(temp.left);\\n            if(temp.right!=null)\\n                q.offer(temp.right);\\n        }\\n        return false;\\n    }\\n    \\n    public boolean verify(ListNode head, TreeNode root) {\\n        if(head == null)\\n            return true;\\n        \\n        if(root==null || head.val!=root.val)\\n            return false;\\n            \\n        return verify(head.next, root.right) || verify(head.next, root.left);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public boolean isSubPath(ListNode head, TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty()) {\\n            TreeNode temp = q.poll();\\n            \\n            if(temp.val==head.val && verify(head.next, temp))\\n                return true;\\n            \\n            if(temp.left!=null)\\n                q.offer(temp.left);\\n            if(temp.right!=null)\\n                q.offer(temp.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1346569,
                "title": "java-solution-100-faster-dfs",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isMatched(ListNode head, TreeNode root) {\\n\\t\\t\\tif(head == null)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(root == null || head.val != root.val)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn (isMatched(head.next, root.left) || isMatched(head.next, root.right));\\n\\t\\t}\\n\\t\\tpublic boolean isSubPath(ListNode head, TreeNode root) {\\n\\t\\t   if(head == null) \\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif(root == null) \\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(isMatched(head, root))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\treturn (isSubPath(head, root.left) || isSubPath(head, root.right));\\n\\t\\t}  \\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isMatched(ListNode head, TreeNode root) {\\n\\t\\t\\tif(head == null)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(root == null || head.val != root.val)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn (isMatched(head.next, root.left) || isMatched(head.next, root.right));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1326734,
                "title": "c-very-easy-find-string-method",
                "content": "```class Solution {\\npublic:\\n    bool ans;\\n    void preorder(TreeNode* root,string temp,string s) {\\n        if(root==NULL) return;\\n        \\n        temp+=(root->val);\\n        if(temp.find(s)!=string::npos) {\\n            ans=true;\\n            return;\\n        }\\n        preorder(root->left,temp,s);\\n        preorder(root->right,temp,s);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        string s=\"\";\\n        ListNode* curr=head;\\n        while(curr!=NULL) {\\n            s+=(curr->val);\\n            curr=curr->next;\\n        }\\n        ans=false;\\n        preorder(root,\"\",s);\\n        return ans;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool ans;\\n    void preorder(TreeNode* root,string temp,string s) {\\n        if(root==NULL) return;\\n        \\n        temp+=(root->val);\\n        if(temp.find(s)!=string::npos) {\\n            ans=true;\\n            return;\\n        }\\n        preorder(root->left,temp,s);\\n        preorder(root->right,temp,s);\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        \\n        string s=\"\";\\n        ListNode* curr=head;\\n        while(curr!=NULL) {\\n            s+=(curr->val);\\n            curr=curr->next;\\n        }\\n        ans=false;\\n        preorder(root,\"\",s);\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1326135,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ans=false;\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL && head!=NULL)return false;\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root->val!=head->val) return false;\\n        return dfs(head->next,root->left) || dfs(head->next,root->right); \\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n        if(ans==true) return true;\\n        if(head->val==root->val){\\n           if(dfs(head,root)){\\n               ans=true;\\n               return true;\\n           }\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ans=false;\\n    bool dfs(ListNode* head, TreeNode* root){\\n        if(root==NULL && head!=NULL)return false;\\n        if(head==NULL){\\n            return true;\\n        }\\n        if(root->val!=head->val) return false;\\n        return dfs(head->next,root->left) || dfs(head->next,root->right); \\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(root==NULL) return false;\\n        if(ans==true) return true;\\n        if(head->val==root->val){\\n           if(dfs(head,root)){\\n               ans=true;\\n               return true;\\n           }\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318763,
                "title": "c-recursion",
                "content": "```\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n\\t\\t// For each treenode, start a new search\\n        return search(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool search(ListNode * head, TreeNode * root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n        if (head->val == root->val) {\\n            return search(head->next, root->left) || search(head->next, root->right);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n\\t\\t// For each treenode, start a new search\\n        return search(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n    \\n    bool search(ListNode * head, TreeNode * root) {\\n        if (!head) {\\n            return true;\\n        } else if (!root) {\\n            return false;\\n        }\\n        \\n        if (head->val == root->val) {\\n            return search(head->next, root->left) || search(head->next, root->right);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311174,
                "title": "c-solution-easy-to-understand",
                "content": "bool isIdentical(ListNode* head,TreeNode* root)\\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL) return true;\\n        if(root == NULL && head != NULL) return false;\\n        if(root->val == head->val)\\n        {\\n            return isIdentical(head->next,root->left) || isIdentical(head->next,root->right);         \\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL || root == NULL) return false;\\n        if(isIdentical(head,root))\\n        {\\n            return true;\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};",
                "solutionTags": [],
                "code": "bool isIdentical(ListNode* head,TreeNode* root)\\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL) return true;\\n        if(root == NULL && head != NULL) return false;\\n        if(root->val == head->val)\\n        {\\n            return isIdentical(head->next,root->left) || isIdentical(head->next,root->right);         \\n        }\\n        return false;\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) \\n    {\\n        if(head == NULL &&  root == NULL) return true;\\n        if(head == NULL || root == NULL) return false;\\n        if(isIdentical(head,root))\\n        {\\n            return true;\\n        }\\n        return isSubPath(head,root->left) || isSubPath(head,root->right);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1283736,
                "title": "faster-then-90-concise-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool help(ListNode* head, TreeNode* root){\\n       //base case\\n        if(!head){return true;} //if list is complete return true\\n        if(head and !root){return false;}//tree ended before list return false\\n        if(head->val==root->val){//if head value equals root value \\n            bool left=help(head->next,root->left); //check left subtree for rest of the list\\n            bool right=help(head->next,root->right);//check right subtree for rest of the list\\n            return left or right;//return true if any side of the tree has the complete list\\n        }\\n        return false;//if head val is not equal root val return false\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root){return false;}\\n        if(root->val==head->val){\\n            bool ans=help(head,root);\\n            if(ans){return true;}\\n        }\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool help(ListNode* head, TreeNode* root){\\n       //base case\\n        if(!head){return true;} //if list is complete return true\\n        if(head and !root){return false;}//tree ended before list return false\\n        if(head->val==root->val){//if head value equals root value \\n            bool left=help(head->next,root->left); //check left subtree for rest of the list\\n            bool right=help(head->next,root->right);//check right subtree for rest of the list\\n            return left or right;//return true if any side of the tree has the complete list\\n        }\\n        return false;//if head val is not equal root val return false\\n    }\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!root){return false;}\\n        if(root->val==head->val){\\n            bool ans=help(head,root);\\n            if(ans){return true;}\\n        }\\n        return isSubPath(head,root->left) or isSubPath(head,root->right); \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1868917,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1763819,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 2044202,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1876924,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1751735,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            },
            {
                "id": 1675335,
                "content": [
                    {
                        "username": "jagdish_45",
                        "content": "I don\\'t know where it\\'s going wrong:\\n\\n```from typing import Optional\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def f(root:Optional[TreeNode],head:Optional[ListNode]):\\n            if head==None: return True\\n            if root==None: return False\\n            if root.val == head.val:\\n                return f(root.left,head.next) or f(root.right,head.next)\\n            return f(root.left,head) or f(root.right,head)\\n        return f(root,head)\\n```\\nCan anyone suggest me where I am doing wrong"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@vineethbhat](/vineethbhat) thanks I did same mistake"
                    },
                    {
                        "username": "vineethbhat",
                        "content": "head =\n[4, 1]\n\nroot =\n[1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n\ntry this -> your code gives True when the answer is False\n\nit's like your code returns True for detecting [4,1] in the sequence [4, x, 1] as it can skip a node."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I am getting TLE on last 6 test cases. Can any one suggest an optimization: \\n\\n```\\nclass Solution {\\npublic:\\n    bool isSubPath(ListNode* head, TreeNode* root) {\\n        if(!head) return true; \\n        if(!root) return false; \\n        bool t1 = isSubPath(head->next, root->left) || isSubPath(head->next, root->right),\\n        t2 = isSubPath(head, root->left) || isSubPath(head, root->right); \\n\\n        if(root->val == head->val) return t1 || t2; \\n\\n        return t2;\\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "siddhantsar",
                        "content": "```class Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n        def dfs(t_node, l_node):\\n            if not l_node:\\n                return True\\n            \\n            left_check, right_check = False, False\\n\\n            if t_node.left and t_node.left.val == l_node.val:\\n                left_check = dfs(t_node.left, l_node.next)\\n            \\n            if t_node.right and t_node.right.val == l_node.val:\\n                right_check = dfs(t_node.right, l_node.next)\\n\\n            return left_check or right_check\\n\\n        if not root:\\n            return False\\n\\n        if root.val == head.val:\\n            if dfs(root, head.next):\\n                return True\\n        \\n        left_res = dfs(root.left, head)\\n        right_res = dfs(root.right, head)\\n\\n        return left_res or right_res\\n```\\n\\nWhy this code isn\\'t working? Can anyone help! "
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "// I\\'m getting 6 cases incorrect any sort of help would be appreciated\\n\\n    bool isSubPath(ListNode* head, TreeNode* root)\\n    {\\n        if(!root and head) return false;\\n         if(!head && !root) return true;\\n        if(head && !root) return false;\\n        if(!head && root) return true;\\n        if (head->val == root->val)  return isSubPath(head->next, root->left) || isSubPath(head->next, root->right);\\n        else\\n            return isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }\\n"
                    },
                    {
                        "username": "shrinidhi_14",
                        "content": "Because you didn\\'t took the case into account that the consecutive nodes should match , and not any node in the downward path.\\nIts like you have to find the matching substring but you are finding the matching subsequence.\\nAs in the subsequence the elements may or may not be consecutive or we can say like it can contain breaks.\\nI hope you understood my explanation :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Pooja](/poojaaa_r) Even I did same mistake, This code will return true even if the linked list is present in tree with a break. For some scenarios you need to check that we dont return true for (head->next, root->left/right) in the whole subtree, but from the immediate child nodes itself. Otherwise it will return true even if the remaining linked list continues somewhere deep down and not immediately."
                    },
                    {
                        "username": "Ganes123",
                        "content": "I have a doubt that is ,\\nDo we need to match the linked list with the tree with reference to the value  being provided or the addresses that they are associated with it"
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "You have to first check all the values are present int binary tree or not and then check whether there is path associated with it or not..... Basically we have to check the value is equal or not.\\n"
                    }
                ]
            }
        ]
    }
]