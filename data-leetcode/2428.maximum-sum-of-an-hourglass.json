[
    {
        "title": "Maximum Sum of an Hourglass",
        "question_content": "You are given an m x n integer matrix grid.\nWe define an hourglass as a part of the matrix with the following form:\nReturn the maximum sum of the elements of an hourglass.\nNote that an hourglass cannot be rotated and must be entirely contained within the matrix.\n&nbsp;\nExample 1:\n\nInput: grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\nOutput: 30\nExplanation: The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.\n\nExample 2:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 35\nExplanation: There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t3 <= m, n <= 150\n\t0 <= grid[i][j] <= 106",
        "solutions": [
            {
                "id": 2648676,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n = mat.size(), m = mat[0].size();\\n\\t\\t\\tint res = INT_MIN;\\n\\t\\t\\tfor (int i=0; i<n-2; i++){\\n\\t\\t\\t\\tfor (int j=0; j<m-2; j++){\\n\\t\\t\\t\\t\\tint sum = mat[i][j]+mat[i][j+1]+mat[i][j+2]+\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmat[i+1][j+1]+\\n\\t\\t\\t\\t\\t\\t\\t  mat[i+2][j]+mat[i+2][j+1]+mat[i+2][j+2];\\n\\t\\t\\t\\t\\tres = max(res, sum);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n = mat.size(), m = mat[0].size();\\n\\t\\t\\tint res = INT_MIN;\\n\\t\\t\\tfor (int i=0; i<n-2; i++){\\n\\t\\t\\t\\tfor (int j=0; j<m-2; j++){\\n\\t\\t\\t\\t\\tint sum = mat[i][j]+mat[i][j+1]+mat[i][j+2]+\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmat[i+1][j+1]+\\n\\t\\t\\t\\t\\t\\t\\t  mat[i+2][j]+mat[i+2][j+1]+mat[i+2][j+2];\\n\\t\\t\\t\\t\\tres = max(res, sum);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2648936,
                "title": "brute-force",
                "content": "**C++**\\n```cpp\\nint maxSum(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    for (int i = 0; i < m - 2; ++i) {\\n        for (int j = 0; j < n - 2; ++j)\\n            res = max(res, \\n                g[i + 0][j] + g[i + 0][j + 1] + g[i + 0][j + 2] +\\n                              g[i + 1][j + 1] +\\n                g[i + 2][j] + g[i + 2][j + 1] + g[i + 2][j + 2]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maxSum(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    for (int i = 0; i < m - 2; ++i) {\\n        for (int j = 0; j < n - 2; ++j)\\n            res = max(res, \\n                g[i + 0][j] + g[i + 0][j + 1] + g[i + 0][j + 2] +\\n                              g[i + 1][j + 1] +\\n                g[i + 2][j] + g[i + 2][j + 1] + g[i + 2][j + 2]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648733,
                "title": "c-simple-approach",
                "content": "**Please upvote if it helps :)**\\n```\\nclass Solution \\n{\\npublic:\\n    int maxSum(vector<vector<int>>& grid) \\n    {\\n        int maxi = 0;\\n        int m=grid.size(), n=grid[0].size();\\n        int sum=0;\\n        \\n        for(int i=0; i<=m-3; i++)\\n        {\\n            for(int j=0; j<=n-3; j++)\\n            {\\n                sum=0;\\n                for(int c=j; c<j+3; c++) //for adding 3 values from column to make hourglass\\n                {\\n                    sum += grid[i][c]; //add 1st row to make hourglass\\n                    sum += grid[i+2][c]; //add 3rd row to make hourglass\\n                }\\n                sum += grid[i+1][j+1]; //add middle of 3x3 grid to make hourglass \\n                maxi = max(maxi, sum); //find max. value\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxSum(vector<vector<int>>& grid) \\n    {\\n        int maxi = 0;\\n        int m=grid.size(), n=grid[0].size();\\n        int sum=0;\\n        \\n        for(int i=0; i<=m-3; i++)\\n        {\\n            for(int j=0; j<=n-3; j++)\\n            {\\n                sum=0;\\n                for(int c=j; c<j+3; c++) //for adding 3 values from column to make hourglass\\n                {\\n                    sum += grid[i][c]; //add 1st row to make hourglass\\n                    sum += grid[i+2][c]; //add 3rd row to make hourglass\\n                }\\n                sum += grid[i+1][j+1]; //add middle of 3x3 grid to make hourglass \\n                maxi = max(maxi, sum); //find max. value\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649018,
                "title": "easy-python-code-with-comments",
                "content": "Easy Python Code with Comments\\n\\n```\\nclass Solution:\\n    def maxSum(self, x: List[List[int]]) -> int:\\n        \\n        # initialize max to 0\\n        mx = 0\\n        \\n        m = len(x)\\n        n = len(x[0])\\n        \\n        # traverse through \\n        # rows: m-3 times\\n        # columns: n-3 times for each row\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                \\n                # add top horizontal items\\n                mSum =0\\n                for k in range(j, j+3):\\n                    mSum +=x[i][k]\\n                \\n                # add bottom horizontal items\\n                for k in range(j, j+3):\\n                    mSum +=x[i+2][k]\\n                \\n                # add middle element of the hourglass\\n                mSum += x[i+1][j+1]\\n                \\n                # update max if we get new maximum\\n                if mx < mSum:\\n                    mx = mSum\\n        return mx\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, x: List[List[int]]) -> int:\\n        \\n        # initialize max to 0\\n        mx = 0\\n        \\n        m = len(x)\\n        n = len(x[0])\\n        \\n        # traverse through \\n        # rows: m-3 times\\n        # columns: n-3 times for each row\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                \\n                # add top horizontal items\\n                mSum =0\\n                for k in range(j, j+3):\\n                    mSum +=x[i][k]\\n                \\n                # add bottom horizontal items\\n                for k in range(j, j+3):\\n                    mSum +=x[i+2][k]\\n                \\n                # add middle element of the hourglass\\n                mSum += x[i+1][j+1]\\n                \\n                # update max if we get new maximum\\n                if mx < mSum:\\n                    mx = mSum\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651388,
                "title": "applying-mask-hourglass",
                "content": "# Intuition\\nWe need to find sum of a particular mask: shape lile an hourglass.\\nSo we would select a point on the hourglass and make a function that calculates the sum the mask in referece to the point selected.\\nNow we iterate to every possive point where the mask can be put on.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n![image.png](https://assets.leetcode.com/users/images/ee2bebca-07d5-4845-a728-110da2eaf1cc_1664723430.768872.png)\\n\\nTo apply the mask we select the point **D** in the hourglass\\nso respectively\\n\\n**A** = `grid[i - 1][j - 1]`\\n**B** = `grid[i - 1][j]`\\n**C** = `grid[i - 1][j + 1]`\\n**D** = `grid[i][j]`\\n**E** = `grid[i + 1][j - 1]`\\n**F** = `grid[i + 1][j]`\\n**G** = `grid[i + 1][j + 1]`\\n\\nWe apply the brute force approach where we put mask on evey possible point:\\n- `i` *`(0, n)`*\\n- `j` *`(0, m)`*\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n * m)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gethour(vector<vector<int>>& grid, int i, int j) {\\n        return  grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + \\n                grid[i][j] + \\n                grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1];\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = INT_MIN;\\n        for(int i = 1; i < n - 1; i++)\\n            for(int j = 1; j < m - 1; j++)\\n                res = max(res, gethour(grid, i, j));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gethour(vector<vector<int>>& grid, int i, int j) {\\n        return  grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + \\n                grid[i][j] + \\n                grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1];\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = INT_MIN;\\n        for(int i = 1; i < n - 1; i++)\\n            for(int j = 1; j < m - 1; j++)\\n                res = max(res, gethour(grid, i, j));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648895,
                "title": "easy-java-solution-matrix",
                "content": "# Maximum Sum of an Hourglass\\n**Easy Java Solution**\\n\\n**Approach:**\\n1.) Running the for loop for row-2 times\\n2.) Running the inner for loop col-2 times\\n3.) Calculating the sum and updating the ans\\n\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            //Running the for loop for the row-2  times\\n            for(int j=0;j<grid[0].length-2;j++){\\n                //Running the inner for loop for the col-2  times\\n                int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                ans=Math.max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            //Running the for loop for the row-2  times\\n            for(int j=0;j<grid[0].length-2;j++){\\n                //Running the inner for loop for the col-2  times\\n                int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                ans=Math.max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648757,
                "title": "c-must-check-this-solution-brute-force",
                "content": "\\n```\\nEASY TO UNDERSTAND: \\n\\n```int maxSum(vector<vector<int>>& grid) {\\n      vector<int>allsum; \\n      int x = 0;\\n      while (x <= grid.size() - 3) {\\n        int y = 0;\\n        while (y <= grid[0].size() - 3) {\\n          int count = 0;\\n          int sum = 0;\\n          for (int i = x; i < x + 3; i++) {\\n            for (int j = y; j < y + 3; j++) {\\n              count++;\\n              if (count == 4 or count == 6) {\\n                continue;\\n              }\\n              sum += grid[i][j];\\n            }\\n          }\\n          allsum.push_back(sum);\\n          y++;\\n        }\\n        x++;\\n      }\\n      int maxi = INT_MIN;\\n      for (int i = 0; i < allsum.size(); i++) {\\n        maxi = max(maxi, allsum[i]);\\n      }\\n      return maxi;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nEASY TO UNDERSTAND: \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2655721,
                "title": "python-3-2428-maximum-sum-of-an-hourglass-t-m-90-60",
                "content": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n\\n        ans = 0\\n\\n        for i in range(1, len(grid)-1):\\n            for j in range(1, len(grid[0])-1):\\n\\n                sm = ( grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]\\n                                      + grid[i  ][j] +\\n                       grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1] )\\n\\n                if sm > ans: ans = sm\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/814238892/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n\\n        ans = 0\\n\\n        for i in range(1, len(grid)-1):\\n            for j in range(1, len(grid[0])-1):\\n\\n                sm = ( grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]\\n                                      + grid[i  ][j] +\\n                       grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1] )\\n\\n                if sm > ans: ans = sm\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648997,
                "title": "c-easy-understanding-simple-approach-matrix-traversal-no-extra-space",
                "content": "### **Upvote if it helps :)**\\n```\\nclass Solution {\\npublic:\\n    \\n    long long int maxSum(vector<vector<int>>& g) {\\n        \\n        long long int row=g.size();  // gives number of rows of matrix\\n        long long int col=g[0].size();  // gives number of cols of matrix\\n        \\n\\t\\t\\n\\t\\t// most small case when row and col both are 3\\n\\t\\t// according to problem constraints row size and col size can not be less than 3\\n        if(row == col and row == 3){\\n            return (g[0][0] + g[0][1] + g[0][2] + g[1][1] + g[2][0] + g[2][1] + g[2][2]);\\n        }\\n\\t\\t\\n       // general case when row size and col size greater than 3\\n        long long int currSum=INT_MIN;  // currsum keeps track of sum of current traversal\\n        long long int maxSum=INT_MIN;  // maxsum keeps track of max sum traversed till now\\n        \\n            // traversing in matrix and updating maxsum when currsum becomes more than maxsum\\n\\t\\t\\t\\n            for( int i=0 ; i+2<row ; i++){   // traversing till i+2 because hour-glass is made up of 3 rows\\n                for ( int j=0; j+2<col ; j++){   // traversing till j+2 because hour-glass is made up of 3 rows\\n\\t\\t\\t\\t\\n                    long long int x = (g[i][j]+g[i][j+1]+g[i][j+2]);   // keeps sum of topmost row of hour-glass\\n                    long long int y = (g[i+1][j+1]) ;  // keeps sum of middle row of hour-glass\\n                    long long int z = (g[i+2][j]+g[i+2][j+1]+g[i+2][j+2]);  // keeps sum of bottom row of hour-glass\\n                    \\n\\t\\t\\t\\t\\t// now  sum of (x+y+z) will be sum of current hour glass we\\'ll compare it with max-sum of hour glass    and update accordingly\\n\\t\\t\\t\\t\\t\\n                    currSum=(x+y+z);\\n                    maxSum = max(currSum,maxSum);\\n                }\\n            }\\n        \\n        \\n        return maxSum;\\n    }\\n};\\n```\\n**Comment for any queries :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long int maxSum(vector<vector<int>>& g) {\\n        \\n        long long int row=g.size();  // gives number of rows of matrix\\n        long long int col=g[0].size();  // gives number of cols of matrix\\n        \\n\\t\\t\\n\\t\\t// most small case when row and col both are 3\\n\\t\\t// according to problem constraints row size and col size can not be less than 3\\n        if(row == col and row == 3){\\n            return (g[0][0] + g[0][1] + g[0][2] + g[1][1] + g[2][0] + g[2][1] + g[2][2]);\\n        }\\n\\t\\t\\n       // general case when row size and col size greater than 3\\n        long long int currSum=INT_MIN;  // currsum keeps track of sum of current traversal\\n        long long int maxSum=INT_MIN;  // maxsum keeps track of max sum traversed till now\\n        \\n            // traversing in matrix and updating maxsum when currsum becomes more than maxsum\\n\\t\\t\\t\\n            for( int i=0 ; i+2<row ; i++){   // traversing till i+2 because hour-glass is made up of 3 rows\\n                for ( int j=0; j+2<col ; j++){   // traversing till j+2 because hour-glass is made up of 3 rows\\n\\t\\t\\t\\t\\n                    long long int x = (g[i][j]+g[i][j+1]+g[i][j+2]);   // keeps sum of topmost row of hour-glass\\n                    long long int y = (g[i+1][j+1]) ;  // keeps sum of middle row of hour-glass\\n                    long long int z = (g[i+2][j]+g[i+2][j+1]+g[i+2][j+2]);  // keeps sum of bottom row of hour-glass\\n                    \\n\\t\\t\\t\\t\\t// now  sum of (x+y+z) will be sum of current hour glass we\\'ll compare it with max-sum of hour glass    and update accordingly\\n\\t\\t\\t\\t\\t\\n                    currSum=(x+y+z);\\n                    maxSum = max(currSum,maxSum);\\n                }\\n            }\\n        \\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648856,
                "title": "c",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j>0 && j<m-1 && i<n-2){\\n                    int sum=grid[i][j-1]+grid[i][j]+grid[i][j+1]+grid[i+1][j]+grid[i+2][j-1]+grid[i+2][j]+grid[i+2][j+1];\\n                    ans=max(ans,sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j>0 && j<m-1 && i<n-2){\\n                    int sum=grid[i][j-1]+grid[i][j]+grid[i][j+1]+grid[i+1][j]+grid[i+2][j-1]+grid[i+2][j]+grid[i+2][j+1];\\n                    ans=max(ans,sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509356,
                "title": "maximum-sum-of-an-hourglass-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int i, j, sum=0, max=0;\\n        for(i=0 ; i<grid.size()-2 ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size()-2 ; j++)\\n            {\\n                sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max)\\n                {\\n                    max = sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/5f4c8e3a-f9ec-484c-86a8-fab6f5c5cbac_1683734985.6923223.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int i, j, sum=0, max=0;\\n        for(i=0 ; i<grid.size()-2 ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size()-2 ; j++)\\n            {\\n                sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max)\\n                {\\n                    max = sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649418,
                "title": "java-brute-force-easiest-matrix",
                "content": "**Hi Family,**\\n\\nI put the comment in the code for you proper understanding\\n\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        \\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i=0;i<m-2;i++){\\n            res = 0;\\n            for (int j=0;j<n-2;j++){\\n                \\n                                                      \\n                res = grid[i][j] + grid[i][j+1] + grid[i][j+2];             //  upper part\\n                res += grid[i+1][j+1];                                      // mid part\\n                res += grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];      // lower part\\n                \\n                if (res > max) max = res;\\n            }\\n            \\n        }\\n       \\n        return max;\\n    }\\n}\\n```\\n\\nIf you Liked the code, Please Please Please Upvote it\\n**Thanks!!!**",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        \\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i=0;i<m-2;i++){\\n            res = 0;\\n            for (int j=0;j<n-2;j++){\\n                \\n                                                      \\n                res = grid[i][j] + grid[i][j+1] + grid[i][j+2];             //  upper part\\n                res += grid[i+1][j+1];                                      // mid part\\n                res += grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];      // lower part\\n                \\n                if (res > max) max = res;\\n            }\\n            \\n        }\\n       \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131889,
                "title": "easy-python-solution-matrix",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        def solve(grid, row, col):\\n            return (grid[row][col] + grid[row-1][col] + grid[row-1][col-1] + grid[row-1][col+1] + grid[row+1][col] + grid[row+1][col-1] + grid[row+1][col+1])\\n        currSum = float(\"-inf\")\\n        for i in range(1, len(grid)-1):\\n            for j in range(1, len(grid[0])-1):\\n                temp = solve(grid, i, j)\\n                if currSum < temp:\\n                    currSum = temp\\n        return currSum\\n\\n\\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        def solve(grid, row, col):\\n            return (grid[row][col] + grid[row-1][col] + grid[row-1][col-1] + grid[row-1][col+1] + grid[row+1][col] + grid[row+1][col-1] + grid[row+1][col+1])\\n        currSum = float(\"-inf\")\\n        for i in range(1, len(grid)-1):\\n            for j in range(1, len(grid[0])-1):\\n                temp = solve(grid, i, j)\\n                if currSum < temp:\\n                    currSum = temp\\n        return currSum\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671513,
                "title": "c-simpler-solution-easily-explained-simple-matrix-traversal",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem , we are simply traversing the 2-D vector and we are travrsing till **row-2**  where row is the number of rows and traversing all the columns. \\nSince at each row we are adding the elements of first hourglass starting from first column and then we are only shifting our hourglass to right by 1 index modifying the elemnts according to the need.\\nLet\\'s take an example\\nConsider a matrix as \\n\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nThe first hourglass will be:\\n**1 2 3** 4\\n5 **6** 7 8\\n**9 10 11** 12\\nElements will be -  1+9 +2+6+10 + 3+11\\nAfter shifting the hourglass to right by 1 position, new hourglass will look like:\\n1 **2 3 4**\\n5 6 **7** 8\\n9 **10 11 12**\\nElements will be -  2+10 +4+7+11 + 4+12\\n\\nChanges observed-\\nShifting the middle row element and removing the starting elements and adding new ending elements.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we traversing the matrix so time complexity will be O(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int currsum=0;\\n        int r=grid.size();\\n        int c=grid[0].size();\\n\\n        for(int i=0;i<r-2;i++){\\n            int temp=0;\\n            temp+= (grid[i][0]+grid[i][1]+grid[i][2]);\\n            temp+= grid[i+1][1];\\n            temp+= (grid[i+2][0]+grid[i+2][1]+grid[i+2][2]);\\n            currsum=max(currsum,temp);\\n            for(int j=3;j<c;j++){\\n                temp-= grid[i][j-3];\\n                temp+=grid[i][j];\\n                temp-=grid[i+1][j-2];\\n                temp+=grid[i+1][j-1];\\n                temp-=grid[i+2][j-3];\\n                temp+=grid[i+2][j];\\n                currsum=max(currsum,temp);\\n            }\\n        }\\n        return currsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int currsum=0;\\n        int r=grid.size();\\n        int c=grid[0].size();\\n\\n        for(int i=0;i<r-2;i++){\\n            int temp=0;\\n            temp+= (grid[i][0]+grid[i][1]+grid[i][2]);\\n            temp+= grid[i+1][1];\\n            temp+= (grid[i+2][0]+grid[i+2][1]+grid[i+2][2]);\\n            currsum=max(currsum,temp);\\n            for(int j=3;j<c;j++){\\n                temp-= grid[i][j-3];\\n                temp+=grid[i][j];\\n                temp-=grid[i+1][j-2];\\n                temp+=grid[i+1][j-1];\\n                temp-=grid[i+2][j-3];\\n                temp+=grid[i+2][j];\\n                currsum=max(currsum,temp);\\n            }\\n        }\\n        return currsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663220,
                "title": "python-c-java-beginner-level-simple-short-solution-easytounderstand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2428. Maximum Sum of an Hourglass***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def maxSum(self, g: List[List[int]]) -> int:\\n        ans = 0\\n        for i in range(1, len(g)-1):\\n            for j in range(1, len(g[0])-1):\\n                res = (g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i][j]+g[i+1][j-1]+g[i+1][j] +g[i+1][j+1] )\\n                if res > ans: \\n\\t\\t\\t\\t\\tans = res\\n        return ans\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int maxSum(int[][] g) {\\n        \\n        int res=0, m=g.length, n=g[0].length,sum=0;\\n        for(int i=1;i<m-1;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                sum=g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i][j]+g[i+1][j-1]+g[i+1][j]+g[i+1][j+1];\\n                \\n            res=Math.max(res,sum);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int res= INT_MIN;\\n        int m=g.size(), n=g[0].size();\\n        int sum=0;\\n        for(int i=1;i<m-1;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                sum=g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i][j]+g[i+1][j-1]+g[i+1][j]+g[i+1][j+1];\\n            res=max(res,sum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, g: List[List[int]]) -> int:\\n        ans = 0\\n        for i in range(1, len(g)-1):\\n            for j in range(1, len(g[0])-1):\\n                res = (g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i][j]+g[i+1][j-1]+g[i+1][j] +g[i+1][j+1] )\\n                if res > ans: \\n\\t\\t\\t\\t\\tans = res\\n        return ans\\n```\n```\\nclass Solution {\\n    public int maxSum(int[][] g) {\\n        \\n        int res=0, m=g.length, n=g[0].length,sum=0;\\n        for(int i=1;i<m-1;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                sum=g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i][j]+g[i+1][j-1]+g[i+1][j]+g[i+1][j+1];\\n                \\n            res=Math.max(res,sum);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int res= INT_MIN;\\n        int m=g.size(), n=g[0].size();\\n        int sum=0;\\n        for(int i=1;i<m-1;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                sum=g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i][j]+g[i+1][j-1]+g[i+1][j]+g[i+1][j+1];\\n            res=max(res,sum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648937,
                "title": "python-explained",
                "content": "# Approach :\\n- Here the size of an Hourglass is fixed so we can make a window of Hourglass size and just traverse through the matrix while updating our final `ans`.\\n- To cover edge cases where `m == n == 3`, we run the loop one extra step and to stay inside the matrix we just check `if row+2 <= rows and col+1 <= cols`.\\n\\n# Complexity :\\n- Time complexity: O(n2)\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        max_sum = float(\"-inf\")\\n        \\n        for row in range(rows-3+1): # +1 step for edge case\\n            for col in range(1, cols-2+1): # +1 step for edge case\\n                if row+2 <= rows and col+1 <= cols:\\n                    ur = grid[row][col-1] + grid[row][col] + grid[row][col+1] #upper row\\n                    mc = grid[row+1][col] #mid column\\n                    lr = grid[row+2][col-1] + grid[row+2][col] + grid[row+2][col+1] #lower row\\n                    curr_sum = ur+mc+lr\\n                    max_sum = max(max_sum, curr_sum)\\n        \\n        return max_sum\\n                \\n                \\n```\\n\\n\\n\\n----------------------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        max_sum = float(\"-inf\")\\n        \\n        for row in range(rows-3+1): # +1 step for edge case\\n            for col in range(1, cols-2+1): # +1 step for edge case\\n                if row+2 <= rows and col+1 <= cols:\\n                    ur = grid[row][col-1] + grid[row][col] + grid[row][col+1] #upper row\\n                    mc = grid[row+1][col] #mid column\\n                    lr = grid[row+2][col-1] + grid[row+2][col] + grid[row+2][col+1] #lower row\\n                    curr_sum = ur+mc+lr\\n                    max_sum = max(max_sum, curr_sum)\\n        \\n        return max_sum\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784776,
                "title": "python-3-simple-brute-force-beats-89",
                "content": "```python3 []\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                sm = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + \\\\\\n                grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                res = max(res, sm)\\n        return res\\n```\\n![Screenshot 2023-07-18 at 22.36.08.png](https://assets.leetcode.com/users/images/032540b4-767c-407c-b633-b8222e0c7c26_1689709024.707344.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                sm = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + \\\\\\n                grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                res = max(res, sm)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748604,
                "title": "98-beats-in-runtime-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        for(int i = 0; i < n-2; i++) {\\n            for(int j = 0; j < m-2; j++) {\\n                int sum = 0;\\n                for(int z = j; z < j+3; z++) {\\n                    sum += grid[i][z];\\n                }\\n                sum += grid[i+1][j+1];\\n                 for(int z = j; z < j+3; z++) {\\n                    sum += grid[i+2][z];\\n                }\\n                max = Math.max(sum, max);\\n\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        for(int i = 0; i < n-2; i++) {\\n            for(int j = 0; j < m-2; j++) {\\n                int sum = 0;\\n                for(int z = j; z < j+3; z++) {\\n                    sum += grid[i][z];\\n                }\\n                sum += grid[i+1][j+1];\\n                 for(int z = j; z < j+3; z++) {\\n                    sum += grid[i+2][z];\\n                }\\n                max = Math.max(sum, max);\\n\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200871,
                "title": "python3-greedy-solution-easy-to-understand",
                "content": "# Intuition\\nFind all the sum of exist hour glass in matrix\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfind all possible hour glass\\'s top left position. It should be at coordinate (i, j) where i < m - 2 and j < n - 2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        for i in range(m - 2):\\n            for j in range(n - 2):\\n                hour_glass = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] \\\\\\n                            + grid[i + 1][j + 1] \\\\\\n                            + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]\\n                res = max(res, hour_glass)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        for i in range(m - 2):\\n            for j in range(n - 2):\\n                hour_glass = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] \\\\\\n                            + grid[i + 1][j + 1] \\\\\\n                            + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]\\n                res = max(res, hour_glass)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740980,
                "title": "java-easy-straight-forward-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n       int ans = 0;\\n       for(int i = 0; i < grid.length - 2; i ++) {\\n           for(int j = 0; j < grid[0].length - 2; j ++) {\\n               int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];\\n                ans = Math.max(ans, sum);\\n           } \\n       }\\n       return ans; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n       int ans = 0;\\n       for(int i = 0; i < grid.length - 2; i ++) {\\n           for(int j = 0; j < grid[0].length - 2; j ++) {\\n               int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];\\n                ans = Math.max(ans, sum);\\n           } \\n       }\\n       return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705967,
                "title": "java-solution-for-beginners-easy-to-understand",
                "content": "**Java solution for beginners **\\n\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int sum = 0;\\n        int max = 0;\\n        for(int i = 0;i<grid.length-2;i++){\\n            sum = 0;\\n            for(int j = 0;j<grid[0].length-2;j++){\\n                 sum = grid[i][j+0] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] +                    grid[i+2][j+0] + grid[i+2][j+1] + grid[i+2][j+2];\\n                max = Math.max(sum,max);\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxSum(int[][] grid) {\\n        int sum = 0;\\n        int max = 0;\\n        for(int i = 0;i<grid.length-2;i++){\\n            sum = 0;\\n            for(int j = 0;j<grid[0].length-2;j++){\\n                 sum = grid[i][j+0] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] +                    grid[i+2][j+0] + grid[i+2][j+1] + grid[i+2][j+2];\\n                max = Math.max(sum,max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2697919,
                "title": "unique-solution-faster-than-99-9-prefix-sum-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Since there are many repeated calculations, we can use prefix sum array to minimise our calculations\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust calculate prefix sum for each row and apply suitable transformations (refer code).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(MxN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(MxN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        int mSum = 0;\\n        int prefix[m][n];\\n        // calculating prefix sum array for each row\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0){\\n                    prefix[i][j] = grid[i][j];\\n                }\\n                else{\\n                    prefix[i][j] = prefix[i][j-1] + grid[i][j];\\n                }\\n            }\\n        }\\n// refer to example number 1 and dry run this part of loop for better understanding.\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                int curSum = 0;\\n                curSum += (prefix[i][j+2] + prefix[i+1][j+1]-prefix[i+1][j]+prefix[i+2][j+2]);\\n                \\n    // important case: we must subtract prefix sum upto j-1 column for both i and i+2 row fromour current sum.\\n                if(j>=1){\\n                    curSum -= (prefix[i][j-1] + prefix[i+2][j-1]);\\n                }\\n                mSum = max(curSum, mSum);\\n            }\\n        }\\n        return mSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        int mSum = 0;\\n        int prefix[m][n];\\n        // calculating prefix sum array for each row\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0){\\n                    prefix[i][j] = grid[i][j];\\n                }\\n                else{\\n                    prefix[i][j] = prefix[i][j-1] + grid[i][j];\\n                }\\n            }\\n        }\\n// refer to example number 1 and dry run this part of loop for better understanding.\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                int curSum = 0;\\n                curSum += (prefix[i][j+2] + prefix[i+1][j+1]-prefix[i+1][j]+prefix[i+2][j+2]);\\n                \\n    // important case: we must subtract prefix sum upto j-1 column for both i and i+2 row fromour current sum.\\n                if(j>=1){\\n                    curSum -= (prefix[i][j-1] + prefix[i+2][j-1]);\\n                }\\n                mSum = max(curSum, mSum);\\n            }\\n        }\\n        return mSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678195,
                "title": "python-elegant-short",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*m)\\n    Memory: O(n*m)\\n    \"\"\"\\n\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n        return max(\\n            self.get_hourglass(grid, i, j)\\n            for i in range(1, n - 1)\\n            for j in range(1, m - 1)\\n        )\\n\\n    @staticmethod\\n    def get_hourglass(grid: List[List[int]], i: int, j: int) -> int:\\n        return grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + \\\\\\n                                    grid[i][j] + \\\\\\n               grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*m)\\n    Memory: O(n*m)\\n    \"\"\"\\n\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n        return max(\\n            self.get_hourglass(grid, i, j)\\n            for i in range(1, n - 1)\\n            for j in range(1, m - 1)\\n        )\\n\\n    @staticmethod\\n    def get_hourglass(grid: List[List[int]], i: int, j: int) -> int:\\n        return grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + \\\\\\n                                    grid[i][j] + \\\\\\n               grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670555,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int sum = 0, max = 0;\\n        for(int i=0; i<grid.length-2; i++){\\n            for(int j = 0; j<grid[0].length-2; j++){\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                max = Math.max(max, sum);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar maxSum = function(grid) {\\n    let sum = max = 0\\n    for(let i=0; i<grid.length-2; i++){\\n        for(let j = 0; j<grid[0].length-2; j++){\\n            sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n            max = Math.max(max, sum)\\n        }\\n    }\\n    return max\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        sm = mx = 0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                sm = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                mx = max(mx, sm)\\n        return mx\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int sum = 0, max = 0;\\n        for(int i=0; i<grid.length-2; i++){\\n            for(int j = 0; j<grid[0].length-2; j++){\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                max = Math.max(max, sum);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nvar maxSum = function(grid) {\\n    let sum = max = 0\\n    for(let i=0; i<grid.length-2; i++){\\n        for(let j = 0; j<grid[0].length-2; j++){\\n            sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n            max = Math.max(max, sum)\\n        }\\n    }\\n    return max\\n};\\n```\n```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        sm = mx = 0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                sm = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                mx = max(mx, sm)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670275,
                "title": "c-easy-approach-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                int res=0;\\n                for(int c=j;c<j+3;c++)\\n                {\\n                    res+=grid[i][c]; // first row \\n                    res+=grid[i+2][c]; // 3rd row\\n                }\\n                res+=grid[i+1][j+1];\\n                ans=max(ans,res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution 2**\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                ans=max(ans,grid[i][j]+grid[i][j+1]+grid[i][j+2]+\\n                       grid[i+1][j+1]+\\n                       grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]); // three elements of first row added then mid element of second row then three elements of third row added \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                int res=0;\\n                for(int c=j;c<j+3;c++)\\n                {\\n                    res+=grid[i][c]; // first row \\n                    res+=grid[i+2][c]; // 3rd row\\n                }\\n                res+=grid[i+1][j+1];\\n                ans=max(ans,res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                ans=max(ans,grid[i][j]+grid[i][j+1]+grid[i][j+2]+\\n                       grid[i+1][j+1]+\\n                       grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]); // three elements of first row added then mid element of second row then three elements of third row added \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663569,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> col(n,vector<int>(m,0));\\n        \\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=0 ; j<m ; ++j){\\n                if(j == 0) col[i][j] = grid[i][j];\\n                else col[i][j] = col[i][j-1] + grid[i][j];\\n            }\\n        }\\n        \\n       \\n        int mx = 0;       \\n        for(int i=0 ; i<=n-3 ; ++i){\\n            for(int j=0 ; j<=m-3 ; ++j){\\n                int f = col[i][j+2] + grid[i+1][j+1] + col[i+2][j+2];\\n                if(j-1 >= 0) f -= col[i][j-1] + col[i+2][j-1];\\n                mx = max(mx,f);\\n            }\\n        }\\n        return mx;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> col(n,vector<int>(m,0));\\n        \\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=0 ; j<m ; ++j){\\n                if(j == 0) col[i][j] = grid[i][j];\\n                else col[i][j] = col[i][j-1] + grid[i][j];\\n            }\\n        }\\n        \\n       \\n        int mx = 0;       \\n        for(int i=0 ; i<=n-3 ; ++i){\\n            for(int j=0 ; j<=m-3 ; ++j){\\n                int f = col[i][j+2] + grid[i+1][j+1] + col[i+2][j+2];\\n                if(j-1 >= 0) f -= col[i][j-1] + col[i+2][j-1];\\n                mx = max(mx,f);\\n            }\\n        }\\n        return mx;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651340,
                "title": "javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar maxSum = function (grid) {\\n    let max = 0\\n\\t\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 1; j < grid[i].length - 1; j++) {\\n            let hourglassSum = 0\\n            hourglassSum += grid[i][j - 1]\\n            hourglassSum += grid[i][j]\\n            hourglassSum += grid[i][j + 1]\\n            hourglassSum += grid[i + 1][j]\\n            hourglassSum += grid[i + 2][j - 1]\\n            hourglassSum += grid[i + 2][j]\\n            hourglassSum += grid[i + 2][j + 1]\\n            if(hourglassSum > max) max = hourglassSum\\n        }\\n    }\\n\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSum = function (grid) {\\n    let max = 0\\n\\t\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 1; j < grid[i].length - 1; j++) {\\n            let hourglassSum = 0\\n            hourglassSum += grid[i][j - 1]\\n            hourglassSum += grid[i][j]\\n            hourglassSum += grid[i][j + 1]\\n            hourglassSum += grid[i + 1][j]\\n            hourglassSum += grid[i + 2][j - 1]\\n            hourglassSum += grid[i + 2][j]\\n            hourglassSum += grid[i + 2][j + 1]\\n            if(hourglassSum > max) max = hourglassSum\\n        }\\n    }\\n\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651221,
                "title": "java-easy-to-understand-code",
                "content": "Just a **check function** to check where we *can traverse the following index as an hourGlass or Not* \\nif Yes **traverse the first and last row and then the mid value return the Answer** . EASY\\n\\n```class Solution {\\n    public boolean checkGrid(int[][]grid,int i,int j){\\n        if(i+2>grid.length-1||j+2>grid[0].length-1)return false;\\n        return true;\\n    }\\n    public int cal(int [][]grid,int i,int j){\\n        int ans=0;\\n        for(int col=j;col<=j+2;col++){\\n            ans+=grid[i][col];\\n            ans+=grid[i+2][col];\\n        }\\n        ans+=grid[i+1][j+1];\\n        return ans;\\n    }\\n    public int maxSum(int[][] grid) {\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(checkGrid(grid,i,j)) maxi=Math.max(maxi,cal(grid,i,j));\\n            }\\n        }\\n        return maxi;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```class Solution {\\n    public boolean checkGrid(int[][]grid,int i,int j){\\n        if(i+2>grid.length-1||j+2>grid[0].length-1)return false;\\n        return true;\\n    }\\n    public int cal(int [][]grid,int i,int j){\\n        int ans=0;\\n        for(int col=j;col<=j+2;col++){\\n            ans+=grid[i][col];\\n            ans+=grid[i+2][col];\\n        }\\n        ans+=grid[i+1][j+1];\\n        return ans;\\n    }\\n    public int maxSum(int[][] grid) {\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(checkGrid(grid,i,j)) maxi=Math.max(maxi,cal(grid,i,j));\\n            }\\n        }\\n        return maxi;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2650413,
                "title": "beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        r, c = len(grid), len(grid[0])\\n        a = 0\\n        for i in range(1, r-1):\\n            for j in range(1, c-1):\\n                a = max(a, grid[i][j]+grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1])\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        r, c = len(grid), len(grid[0])\\n        a = 0\\n        for i in range(1, r-1):\\n            for j in range(1, c-1):\\n                a = max(a, grid[i][j]+grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1])\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649756,
                "title": "c-easy-explanation-pictorial-representation-beginner-friendly",
                "content": "HELLO EVERYONE,\\nBefore attempting this question, we should have a clear idea of what an hour glass looks like. It looks something like this.\\n![image](https://assets.leetcode.com/users/images/e85c1602-ede9-46dd-9d7c-651aed646acb_1664692296.9200292.png)\\nNow we have to visualize this in a matrix. that\\'s it. In a matrix form, we can visualize an hour glass as \\n![image](https://assets.leetcode.com/users/images/67198116-ccb2-4727-bf55-cd3a61edd17a_1664692424.6655364.png)\\nIn the first look we can deduce that it is having 3 columns in the first and third row and one column at the centre in the middle or second row. \\n\\nTHE QUESTION IS TO FIND THE MAXIMUM SUM OF AN HOUR GLASS THAT CAN BE FORMED IN THE GIVEN N X M MATRIX.\\n\\n**APPROACH** - first of all we will look for all possible hour glasses in the given grid or matrix and pass that into a sum function which will give us the sum of the elements or numbers forming the hour glass.\\n\\nsuppose i\\'m having a grid like this :\\n![image](https://assets.leetcode.com/users/images/efadbcf0-8cfb-4afc-8272-9c5bd518f7db_1664692716.5666692.png)\\n\\n**then all the possible hour glass in this grid are :** \\n![image](https://assets.leetcode.com/users/images/41d6ab28-966d-476e-8175-8007192f72d1_1664692846.947106.png)   ![image](https://assets.leetcode.com/users/images/2aee6fb0-7651-46d3-b391-8ad384bccc25_1664692863.5555732.png)  ![image](https://assets.leetcode.com/users/images/9120e31c-cf64-48d8-9e6d-99cd3a5b6643_1664692888.9721456.png) ![image](https://assets.leetcode.com/users/images/1b7f835a-f5e3-421a-8879-47245a517bd7_1664692902.6232417.png)  ![image](https://assets.leetcode.com/users/images/98292ca8-a541-437a-8873-2b05ae96a103_1664692943.1971846.png)  ![image](https://assets.leetcode.com/users/images/d305bdab-9621-4b5e-a944-90465dd4d409_1664692968.0279331.png) ![image](https://assets.leetcode.com/users/images/01a7a651-742c-4a56-b045-14f633eb8400_1664692984.2679076.png) ![image](https://assets.leetcode.com/users/images/89a03796-d328-4887-b567-8d1bddc73b6c_1664692999.5437603.png) ![image](https://assets.leetcode.com/users/images/83ff55ac-70a6-44c5-9e1e-68e41cc15cd2_1664693012.6499867.png)\\n\\n**Now one by one we will pass these hour glasses in our sum function and get the max sum and return it.**\\n\\n**But how do we pass the hour glass in the sum function?** \\nIts very simple, we just have to pass the **top left index** of the hour glass and since we already know that we have to traverse 3 times in the first and last row and once in the middle row we can get all the numbers and add them.\\n\\nfor eg in the first hour glass, the top left index is (0,0), for the second one it is (0,1) and so on.\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    int SumOfHourGlass(vector<vector<int>>& grid, int i, int j)\\n    {\\n        int summ=0;\\n\\t\\t//one way of calculatng the sum of the elements of hour glass is iterating ove them and adding them.\\n\\t\\t\\n\\t\\t// i and j represent the row and col of the top left index so we have to traverse\\n\\t\\t// 3 times in the i th row and i+2 th row and after that add the value at grid[i+1][j+1] which is the centre element\\n        \\n\\t\\t// for(int it=0; it<3; it++)\\n        // {\\n        //     summ+=grid[i][j+it];\\n        //     summ+=grid[i+2][j+it];\\n        // }\\n        // summ+=grid[i+1][j+1];\\n\\t\\t\\n\\t\\t//second way is just adding the specific indices of the elements directly since we know them already\\n    \\n        summ=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n        return summ;\\n    }\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int sum=0;\\n        int n=grid.size();       //row size\\n        int m=grid[0].size();  //column size\\n        for(int i=0; i<=n-3; i++)   // we can only have the top left index upto n-3 places because after that 3 elements won\\'t be left in the row so an hour glass can\\'t be formed\\n        {\\n            for(int j=0; j<=m-3; j++)\\n            {\\n                sum=max(sum,SumOfHourGlass(grid, i, j));    // for every hour glass the sum funciton will return the sum of its elements and will will store it if it is greater than the previous sum.\\n            }\\n        }\\n        return sum;           //at last we will be having the maximum sum and return it.\\n    }\\n};\\n```\\n\\nif you found this helpful, please upvote.\\uD83D\\uDE42",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int SumOfHourGlass(vector<vector<int>>& grid, int i, int j)\\n    {\\n        int summ=0;\\n\\t\\t//one way of calculatng the sum of the elements of hour glass is iterating ove them and adding them.\\n\\t\\t\\n\\t\\t// i and j represent the row and col of the top left index so we have to traverse\\n\\t\\t// 3 times in the i th row and i+2 th row and after that add the value at grid[i+1][j+1] which is the centre element\\n        \\n\\t\\t// for(int it=0; it<3; it++)\\n        // {\\n        //     summ+=grid[i][j+it];\\n        //     summ+=grid[i+2][j+it];\\n        // }\\n        // summ+=grid[i+1][j+1];\\n\\t\\t\\n\\t\\t//second way is just adding the specific indices of the elements directly since we know them already\\n    \\n        summ=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n        return summ;\\n    }\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int sum=0;\\n        int n=grid.size();       //row size\\n        int m=grid[0].size();  //column size\\n        for(int i=0; i<=n-3; i++)   // we can only have the top left index upto n-3 places because after that 3 elements won\\'t be left in the row so an hour glass can\\'t be formed\\n        {\\n            for(int j=0; j<=m-3; j++)\\n            {\\n                sum=max(sum,SumOfHourGlass(grid, i, j));    // for every hour glass the sum funciton will return the sum of its elements and will will store it if it is greater than the previous sum.\\n            }\\n        }\\n        return sum;           //at last we will be having the maximum sum and return it.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649565,
                "title": "java-easy-to-understand-intuitive-approach",
                "content": "```\\n//TC : O(r * c * k) , where r = grid.length - 3 and int c = grid[0].length - 3, where k = 3 * 3,  as helper function is having TC of O(3 * 3) = O(k)\\n//SC : O(1)\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        if(grid.length < 3 && grid[0].length < 3) return 0; //edge case\\n        \\n        int r = grid.length - 3; //no of times we have to run for loop for i variable\\n        int c = grid[0].length - 3;  //no of times we have to run for loop for j variable\\n        \\n        int ans = 0;\\n        for(int i = 0; i <= r; ++i){\\n            for(int j = 0; j <= c; ++j){\\n                ans = Math.max(ans, helper(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int helper(int r, int c, int[][] grid){\\n        int sum = 0;\\n        if(r + 3 <= grid.length && c + 3 <= grid[0].length){\\n            for(int i = r; i < r + 3; ++i){\\n                for(int j = c; j < c + 3; ++j){\\n                    sum += grid[i][j];\\n                }\\n            }\\n            return sum - grid[r + 1][c] - grid[r + 1][c + 3 - 1]; //subtract two cells value that are not needed to make hourglass\\n        }else{\\n            return 0; //otherwise return 0\\n        }\\n    }\\n}\\n```\\n**If it was helpful to you please do UPVOTE, as it will increase my morale to contribute more to the LeetCode community. Thank You.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//TC : O(r * c * k) , where r = grid.length - 3 and int c = grid[0].length - 3, where k = 3 * 3,  as helper function is having TC of O(3 * 3) = O(k)\\n//SC : O(1)\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        if(grid.length < 3 && grid[0].length < 3) return 0; //edge case\\n        \\n        int r = grid.length - 3; //no of times we have to run for loop for i variable\\n        int c = grid[0].length - 3;  //no of times we have to run for loop for j variable\\n        \\n        int ans = 0;\\n        for(int i = 0; i <= r; ++i){\\n            for(int j = 0; j <= c; ++j){\\n                ans = Math.max(ans, helper(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int helper(int r, int c, int[][] grid){\\n        int sum = 0;\\n        if(r + 3 <= grid.length && c + 3 <= grid[0].length){\\n            for(int i = r; i < r + 3; ++i){\\n                for(int j = c; j < c + 3; ++j){\\n                    sum += grid[i][j];\\n                }\\n            }\\n            return sum - grid[r + 1][c] - grid[r + 1][c + 3 - 1]; //subtract two cells value that are not needed to make hourglass\\n        }else{\\n            return 0; //otherwise return 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649388,
                "title": "simple-c-solution-easy",
                "content": "```\\n    int maxSum(vector<vector<int>>& grid) {\\n            \\n        int ans = 0;\\n        int n = grid.size() , m = grid[0].size();\\n       \\n        for(int i = 0 ; i < n - 2; i++){\\n            for(int j = 0 ; j < m - 2; j++){\\n                int sum = ( grid[i][j] + grid[i][j + 1] + grid[i][j + 2] )  + grid[i+1][j+1];  + (grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] );\\n              ans = max(sum , ans);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\n    int maxSum(vector<vector<int>>& grid) {\\n            \\n        int ans = 0;\\n        int n = grid.size() , m = grid[0].size();\\n       \\n        for(int i = 0 ; i < n - 2; i++){\\n            for(int j = 0 ; j < m - 2; j++){\\n                int sum = ( grid[i][j] + grid[i][j + 1] + grid[i][j + 2] )  + grid[i+1][j+1];  + (grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] );\\n              ans = max(sum , ans);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2649301,
                "title": "c-easy-and-beginner-friendly-code",
                "content": "```\\n#define f(i, a, b) for(int i = a ; i < b ; i++)\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n      int mxsum = 0;\\n      f(i, 1, grid.size()-1)\\n      {\\n        f(j, 1, grid[0].size()-1)\\n        {\\n          int hourglass = (grid[i][j]+ grid[i-1][j]+grid[i-1][j-1]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]);\\n          mxsum = max(mxsum, hourglass);\\n          hourglass = 0;\\n        }\\n      }\\n      return mxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n#define f(i, a, b) for(int i = a ; i < b ; i++)\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n      int mxsum = 0;\\n      f(i, 1, grid.size()-1)\\n      {\\n        f(j, 1, grid[0].size()-1)\\n        {\\n          int hourglass = (grid[i][j]+ grid[i-1][j]+grid[i-1][j-1]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]);\\n          mxsum = max(mxsum, hourglass);\\n          hourglass = 0;\\n        }\\n      }\\n      return mxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649233,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxResult = Integer.MIN_VALUE;\\n        for (int i = 1; i < grid.length - 1; i++) {\\n            for (int j = 1; j < grid[0].length - 1; j++) {\\n                maxResult = Math.max(maxResult, sum(grid, i, j));\\n            }\\n        }\\n        return maxResult;\\n    }\\n    public int sum(int[][] grid, int row, int col) {\\n        return grid[row-1][col-1] + grid[row-1][col] + grid[row-1][col + 1] + grid[row][col] + grid[row + 1][col - 1] + grid[row + 1][col] + grid[row + 1][col + 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxResult = Integer.MIN_VALUE;\\n        for (int i = 1; i < grid.length - 1; i++) {\\n            for (int j = 1; j < grid[0].length - 1; j++) {\\n                maxResult = Math.max(maxResult, sum(grid, i, j));\\n            }\\n        }\\n        return maxResult;\\n    }\\n    public int sum(int[][] grid, int row, int col) {\\n        return grid[row-1][col-1] + grid[row-1][col] + grid[row-1][col + 1] + grid[row][col] + grid[row + 1][col - 1] + grid[row + 1][col] + grid[row + 1][col + 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649045,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& arr) {\\n        int maxi=0;\\n        int m = arr.size();\\n        int n=arr[0].size();\\n        for(int i=1;i<m-1;i++){\\n            for(int j=1;j<n-1;j++){\\n                int temp= arr[i][j]+arr[i-1][j-1]+arr[i-1][j]+arr[i-1][j+1]+arr[i+1][j-1]+arr[i+1][j]+arr[i+1][j+1];\\n                \\n                    maxi=max(maxi,temp);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& arr) {\\n        int maxi=0;\\n        int m = arr.size();\\n        int n=arr[0].size();\\n        for(int i=1;i<m-1;i++){\\n            for(int j=1;j<n-1;j++){\\n                int temp= arr[i][j]+arr[i-1][j-1]+arr[i-1][j]+arr[i-1][j+1]+arr[i+1][j-1]+arr[i+1][j]+arr[i+1][j+1];\\n                \\n                    maxi=max(maxi,temp);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648827,
                "title": "simple-c-solution-bruteforce",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) \\n    {\\n       int n = g.size();\\n        \\n       int m = g[0].size();\\n        int ans=0;\\n       for(int i=1;i<(n-1);i++)\\n       {\\n           for(int j=1;j<(m-1);j++)\\n           {\\n               int sum = g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i+1][j-1]+g[i+1][j]+g[i+1][j+1]+g[i][j];\\n               \\n               ans = max(ans,sum);\\n           }\\n       }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) \\n    {\\n       int n = g.size();\\n        \\n       int m = g[0].size();\\n        int ans=0;\\n       for(int i=1;i<(n-1);i++)\\n       {\\n           for(int j=1;j<(m-1);j++)\\n           {\\n               int sum = g[i-1][j-1]+g[i-1][j]+g[i-1][j+1]+g[i+1][j-1]+g[i+1][j]+g[i+1][j+1]+g[i][j];\\n               \\n               ans = max(ans,sum);\\n           }\\n       }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648800,
                "title": "rust-windows-with-comments",
                "content": "This is my unrevised submission for the 2022-10-02 Weekly Contest 313. Precompute the sums of windows of three for each row (tops and bottoms), and the middle element of windows of three (middles). Then loop over all possible \"hourglasses\" (one top, one middle and one bottom), and compute the max of the sums.\\n\\nComment: I am thinking now that the middles are just row[1..row.len()-1], but it was fast to do a copy-paste during the contest. And windows could have been sliding, i.e. adding one element and subtracting another. A bit messy, but nothing that couldn\\'t be solved by `cargo fmt`. Otherwise happy with the functional-style solution.\\n\\n```\\nimpl Solution {\\n    pub fn max_sum(grid: Vec<Vec<i32>>) -> i32 {\\n        let ends: Vec<Vec<i32>> = grid.iter().map(|row| row.windows(3).map(|e| e.iter().sum()).collect()).collect();\\n        let middles: Vec<Vec<i32>> = grid.iter().map(|row| row.windows(3).map(|e| e[1]).collect()).collect();\\n        ends.iter().zip(middles.iter().skip(1)).zip(ends.iter().skip(2))\\n            .flat_map(|((top,middle), bottom)| \\n            top.iter().zip(middle.iter()).zip(bottom.iter()).map(|((t,m), b)| *t + *m + *b)\\n        ).max().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_sum(grid: Vec<Vec<i32>>) -> i32 {\\n        let ends: Vec<Vec<i32>> = grid.iter().map(|row| row.windows(3).map(|e| e.iter().sum()).collect()).collect();\\n        let middles: Vec<Vec<i32>> = grid.iter().map(|row| row.windows(3).map(|e| e[1]).collect()).collect();\\n        ends.iter().zip(middles.iter().skip(1)).zip(ends.iter().skip(2))\\n            .flat_map(|((top,middle), bottom)| \\n            top.iter().zip(middle.iter()).zip(bottom.iter()).map(|((t,m), b)| *t + *m + *b)\\n        ).max().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648778,
                "title": "c-easy-explaination-single-pass",
                "content": "**Please Upvote if it helps! ^_^**\\n```\\n\\nint maxSum(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size() ;        \\n        if( row<3 ) return 0 ;\\n        \\n        int maxSum = INT_MIN ;\\n        for( int i=0 ; i<row-2 ; i++ ){\\n            \\n            int col = grid[i].size() ;\\n            if( col < 3 ) return 0 ;\\n            for( int j=0 ; j<col-2 ; j++ ){\\n                \\n                int sum = ( grid[i][j]+grid[i][j+1]+grid[i][j+2] ) + grid[i+1][j+1] + ( grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2] );\\n                maxSum = max( sum, maxSum );\\n            }\\n        }\\n        \\n        return maxSum ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint maxSum(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size() ;        \\n        if( row<3 ) return 0 ;\\n        \\n        int maxSum = INT_MIN ;\\n        for( int i=0 ; i<row-2 ; i++ ){\\n            \\n            int col = grid[i].size() ;\\n            if( col < 3 ) return 0 ;\\n            for( int j=0 ; j<col-2 ; j++ ){\\n                \\n                int sum = ( grid[i][j]+grid[i][j+1]+grid[i][j+2] ) + grid[i+1][j+1] + ( grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2] );\\n                maxSum = max( sum, maxSum );\\n            }\\n        }\\n        \\n        return maxSum ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326159,
                "title": "c-brute-force-easy-to-understand",
                "content": "# Intuition\\nSeeing question, we find that we have to find sum of all elements of possible hourglasses. Now, we search for total numbers of hourglasses that is (m-2)(n-2) where m,n>=3. Thus, a matrix of 5\\xD75 will have (5-2)\\xD7(5-2)=9 hourglasses.\\n# Approach\\nSince we will be checking sum of all elements of possible hourglasses, we are going through all possible cases for the problem. Thus, we use the **Brute Force** approach.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int sum, maxm=0;\\n        for(int i=0;i<grid.size()-2;i++) //traversing rows\\n        {\\n            for(int j=0;j<grid[0].size()-2;j++) //traversing columns\\n            { \\n                //sum of elements of each hourglass     \\n                sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]\\n                              +grid[i+1][j+1]+\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]; \\n                maxm=max(maxm,sum); // finding maximum sum \\n            }\\n        }\\n        return maxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int sum, maxm=0;\\n        for(int i=0;i<grid.size()-2;i++) //traversing rows\\n        {\\n            for(int j=0;j<grid[0].size()-2;j++) //traversing columns\\n            { \\n                //sum of elements of each hourglass     \\n                sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]\\n                              +grid[i+1][j+1]+\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]; \\n                maxm=max(maxm,sum); // finding maximum sum \\n            }\\n        }\\n        return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114903,
                "title": "c-straight-forward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ma=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j-1<0||j+1>=m||i+2>=n)\\n                continue;\\n                int val=grid[i][j-1]+grid[i][j]+grid[i][j+1]+grid[i+1][j]+grid[i+2][j-1]+grid[i+2][j]+grid[i+2][j+1];\\n                ma=max(ma,val);\\n            }\\n\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ma=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j-1<0||j+1>=m||i+2>=n)\\n                continue;\\n                int val=grid[i][j-1]+grid[i][j]+grid[i][j+1]+grid[i+1][j]+grid[i+2][j-1]+grid[i+2][j]+grid[i+2][j+1];\\n                ma=max(ma,val);\\n            }\\n\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095364,
                "title": "c-simple-and-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int max_sum = 0;\\n        for(int i = 0;i<grid.size()-2;i++)\\n        {\\n            for(int j = 0;j<grid[0].size()-2;j++)\\n            {\\n                int sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max_sum)\\n                    max_sum = sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int max_sum = 0;\\n        for(int i = 0;i<grid.size()-2;i++)\\n        {\\n            for(int j = 0;j<grid[0].size()-2;j++)\\n            {\\n                int sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max_sum)\\n                    max_sum = sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078265,
                "title": "simple-approach-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are given a fixed shape of hourglass, most of our problem is solved already ^^\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is simple brute force, for every iteration we are taking the total sum and managing the maximum value globally.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxSum = function(grid) {\\n    var n = grid.length\\n    var m = grid[0].length\\n\\n    if(n < 3 || m < 3) return 0\\n\\n    var max = 0\\n\\n    for(var i = 0; i<n-2; i++){\\n        for(var j = 0; j<m-1; j++){\\n            var sum = 0\\n            sum += grid[i][j]\\n            sum += grid[i][j+1]\\n            sum += grid[i][j+2]\\n            sum += grid[i+1][j+1]\\n            sum += grid[i+2][j+1]\\n            sum += grid[i+2][j]\\n            sum += grid[i+2][j+2]\\n            if(sum > max) max = sum\\n        }\\n    }\\n\\n    return max\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxSum = function(grid) {\\n    var n = grid.length\\n    var m = grid[0].length\\n\\n    if(n < 3 || m < 3) return 0\\n\\n    var max = 0\\n\\n    for(var i = 0; i<n-2; i++){\\n        for(var j = 0; j<m-1; j++){\\n            var sum = 0\\n            sum += grid[i][j]\\n            sum += grid[i][j+1]\\n            sum += grid[i][j+2]\\n            sum += grid[i+1][j+1]\\n            sum += grid[i+2][j+1]\\n            sum += grid[i+2][j]\\n            sum += grid[i+2][j+2]\\n            if(sum > max) max = sum\\n        }\\n    }\\n\\n    return max\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989022,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for(int r=0; r<grid.length-2; r++){\\n            int sum = 0, prevMid = 0;\\n            for(int c=0; c<grid[0].length; c++){\\n                sum += grid[r][c] + grid[r+2][c];\\n                if(c >= 2){\\n                    sum += grid[r+1][c-1] - prevMid;\\n                    prevMid = grid[r+1][c-1];\\n                    maxSum = Math.max(sum, maxSum);\\n                    sum -= grid[r][c-2] + grid[r+2][c-2];\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for(int r=0; r<grid.length-2; r++){\\n            int sum = 0, prevMid = 0;\\n            for(int c=0; c<grid[0].length; c++){\\n                sum += grid[r][c] + grid[r+2][c];\\n                if(c >= 2){\\n                    sum += grid[r+1][c-1] - prevMid;\\n                    prevMid = grid[r+1][c-1];\\n                    maxSum = Math.max(sum, maxSum);\\n                    sum -= grid[r][c-2] + grid[r+2][c-2];\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822038,
                "title": "c-java-simple-solution-mathematics-o-n-2",
                "content": "# // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxSum=-1;\\n        \\n        for(int i=1;i<=grid.length-2;i++)\\n        {\\n            for(int j=1;j<=grid[0].length-2;j++)\\n            {\\n                int sum=grid[i][j] + grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1];\\n                maxSum=Math.max(maxSum, sum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxSum=-1;\\n        \\n        for(int i=1;i<=grid.length-2;i++)\\n        {\\n            for(int j=1;j<=grid[0].length-2;j++)\\n            {\\n                int sum=grid[i][j] + grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1];\\n                maxSum=Math.max(maxSum, sum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710775,
                "title": "c-easy-to-understand-brute-force-soln",
                "content": "```\\nint maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int maxi = 0, currmax = 0;\\n        for(int i=0;i<=n-3;i++){\\n            for(int j=0;j<=m-3;j++){\\n                currmax=(grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]);\\n                maxi=max(maxi,currmax);\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int maxi = 0, currmax = 0;\\n        for(int i=0;i<=n-3;i++){\\n            for(int j=0;j<=m-3;j++){\\n                currmax=(grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]);\\n                maxi=max(maxi,currmax);\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693377,
                "title": "c-simple-implementation-code-short-code",
                "content": "![image](https://assets.leetcode.com/users/images/9d678d99-cf0b-4c9c-8e13-5391089f0f2e_1665557236.3768625.png)\\n\\n**T->O(mn) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxSum(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tint m=grid.size();\\n\\t\\t\\t\\tint n=grid[0].size();\\n\\t\\t\\t\\tint maxi=-1;\\n\\t\\t\\t\\tfor(int i=0;i<m-2;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<n-2;j++){\\n\\t\\t\\t\\t\\t\\tint sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n\\t\\t\\t\\t\\t\\tmaxi=max(maxi,sum);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn maxi;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxSum(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tint m=grid.size();\\n\\t\\t\\t\\tint n=grid[0].size();\\n\\t\\t\\t\\tint maxi=-1;\\n\\t\\t\\t\\tfor(int i=0;i<m-2;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<n-2;j++){\\n\\t\\t\\t\\t\\t\\tint sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n\\t\\t\\t\\t\\t\\tmaxi=max(maxi,sum);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2681803,
                "title": "java-straighforward-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = -1, m = grid.length, n = grid[0].length;\\n        for (int row = 0; row < m - 2; row++) {\\n            for (int col = 0; col < n - 2; col++) {\\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n                temp += grid[row + 1][col + 1];\\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n                if (max < temp) {\\n                    max = temp;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = -1, m = grid.length, n = grid[0].length;\\n        for (int row = 0; row < m - 2; row++) {\\n            for (int col = 0; col < n - 2; col++) {\\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n                temp += grid[row + 1][col + 1];\\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n                if (max < temp) {\\n                    max = temp;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677741,
                "title": "simple-python-solution-o-mxn-beats-83-88",
                "content": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        res=0\\n        cur=0\\n        \\n        for i in range(len(grid)-2):\\n            for j in range(1,len(grid[0])-1):\\n               \\n                cur=sum(grid[i][j-1:j+2]) +grid[i+1][j] + sum(grid[i+2][j-1:j+2])\\n                res = max(res,cur)\\n                                                     \\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        res=0\\n        cur=0\\n        \\n        for i in range(len(grid)-2):\\n            for j in range(1,len(grid[0])-1):\\n               \\n                cur=sum(grid[i][j-1:j+2]) +grid[i+1][j] + sum(grid[i+2][j-1:j+2])\\n                res = max(res,cur)\\n                                                     \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663485,
                "title": "brutal",
                "content": "##### Java\\n```java\\npublic int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for (int i = 0; i < grid.length - 2; ++i) {\\n            for (int j = 0; j < grid[0].length - 2; ++j) {\\n                int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] +\\n                        grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];\\n\\n                maxSum = Math.max(sum, maxSum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int maxSum = 0;\\n        for (int i = 0; i < grid.size() - 2; ++i) {\\n            for (int j = 0; j < grid[0].size() - 2; ++j) {\\n                int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] +\\n                          grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];\\n\\n                maxSum = max(sum, maxSum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for (int i = 0; i < grid.length - 2; ++i) {\\n            for (int j = 0; j < grid[0].length - 2; ++j) {\\n                int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] +\\n                        grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];\\n\\n                maxSum = Math.max(sum, maxSum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n```\n```c++\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int maxSum = 0;\\n        for (int i = 0; i < grid.size() - 2; ++i) {\\n            for (int j = 0; j < grid[0].size() - 2; ++j) {\\n                int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] +\\n                          grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];\\n\\n                maxSum = max(sum, maxSum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658631,
                "title": "easy-c-solution",
                "content": "```\\nint maxSum(vector<vector<int>>& grid) {\\n        int mx = 0;\\n        int sum = 0;\\n        for (int row = 0; row <= grid.size()-3; row++) {       \\n            for (int col = 0; col <= grid[0].size()-3; col++) { \\n                sum = grid[row][col] +grid[row][col+1] +grid[row][col+2] +grid[row+1][col+1] +grid[row+2][col] +grid[row+2][col+1] +grid[row+2][col+2];\\n                mx = max(sum, mx); \\n        }\\n    }\\n    \\n    return mx;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxSum(vector<vector<int>>& grid) {\\n        int mx = 0;\\n        int sum = 0;\\n        for (int row = 0; row <= grid.size()-3; row++) {       \\n            for (int col = 0; col <= grid[0].size()-3; col++) { \\n                sum = grid[row][col] +grid[row][col+1] +grid[row][col+2] +grid[row+1][col+1] +grid[row+2][col] +grid[row+2][col+1] +grid[row+2][col+2];\\n                mx = max(sum, mx); \\n        }\\n    }\\n    \\n    return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2655852,
                "title": "python-solution-with-2d-prefix-sum",
                "content": "# Intuition\\nforget about the hourgalss, we essentially want sum of every 9 cells, to fast calculate sum of any rectangle area in grid, we should use prefix sum\\n\\n# Approach\\n\\n1. calculate prefix sum\\n2. for each square (of 9 cells), we can minus 2 cells from it to gain the sum for current hourgass\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n\\nIt\\'s actually gonna be same as brutal force since even though we save time by not recalculating sum of each 9 cells again, since 9 is constant, so we don\\'t gain much...\\n\\n- Space complexity:\\nO(n * m)\\n\\nbecause we need a 2D array to store prefix sum\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        # ps is our 2D array to store prefix sum\\n        ps = [[0] * (n + 1) for _ in range(m + 1)]\\n        ps[1][1] = grid[0][0]\\n\\n        # prepare prefix sum\\n        for i in range(2, n + 1):\\n            ps[1][i] = grid[0][i - 1] + ps[1][i - 1]\\n        for i in range(2, m + 1):\\n            ps[i][1] = grid[i - 1][0] + ps[i - 1][1]\\n        for i in range(2, m + 1):\\n            for j in range(2, n + 1):\\n                ps[i][j] = ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1] + grid[i - 1][j - 1]\\n\\n        # go through each square of (9 cells)\\n        res = 0\\n        for i in range(3, m + 1):\\n            for j in range(3, n + 1):\\n                curr = ps[i][j] - grid[i - 2][j - 3] - grid[i - 2][j - 1]\\n                curr = curr - ps[i][j - 3] - ps[i - 3][j] + ps[i - 3][j - 3]\\n                res = max(res, curr)\\n                # print(ps[i][j])\\n        return res\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        # ps is our 2D array to store prefix sum\\n        ps = [[0] * (n + 1) for _ in range(m + 1)]\\n        ps[1][1] = grid[0][0]\\n\\n        # prepare prefix sum\\n        for i in range(2, n + 1):\\n            ps[1][i] = grid[0][i - 1] + ps[1][i - 1]\\n        for i in range(2, m + 1):\\n            ps[i][1] = grid[i - 1][0] + ps[i - 1][1]\\n        for i in range(2, m + 1):\\n            for j in range(2, n + 1):\\n                ps[i][j] = ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1] + grid[i - 1][j - 1]\\n\\n        # go through each square of (9 cells)\\n        res = 0\\n        for i in range(3, m + 1):\\n            for j in range(3, n + 1):\\n                curr = ps[i][j] - grid[i - 2][j - 3] - grid[i - 2][j - 1]\\n                curr = curr - ps[i][j - 3] - ps[i - 3][j] + ps[i - 3][j - 3]\\n                res = max(res, curr)\\n                # print(ps[i][j])\\n        return res\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654072,
                "title": "very-very-very-easy-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<grid.size()-2;i++){\\n            for(int j=0;j<grid[0].size()-2;j++){\\n                sum=grid[i][j]+grid[i][j+1]+grid[i][j+2] // first row of hourglass\\n                    +grid[i+1][j+1]+                      // diagonal row of hourglass\\n                    grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];  //last row of hourglass\\n                 ans=max(ans,sum);\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<grid.size()-2;i++){\\n            for(int j=0;j<grid[0].size()-2;j++){\\n                sum=grid[i][j]+grid[i][j+1]+grid[i][j+2] // first row of hourglass\\n                    +grid[i+1][j+1]+                      // diagonal row of hourglass\\n                    grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];  //last row of hourglass\\n                 ans=max(ans,sum);\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652587,
                "title": "rust-0-ms-functional-style-matrix-traversal-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/813744932/) employs a functional-style approach to perform matrix traversal. It demonstrated **0 ms runtime (100.00%)** and used **2.4 MB memory (100.00%)**. Time complexity is linear in each dimension: **O(m\\\\*n)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn max_sum(grid: Vec<Vec<i32>>) -> i32 \\n    {\\n        // [0] pattern indices\\n        let idx: Vec<(usize, usize)> = vec![(0,0),(0,1),(0,2),(1,1),(2,0),(2,1),(2,2)];\\n        \\n        let m: usize = grid.len();\\n        let n: usize = grid[0].len();\\n        \\n        // [1] a function (more precisely, a closure) that computes sum \\n        //     for the cells in the hourglass pattern given a corner cell\\n        let hourglass_sum = |i: usize, j: usize| -> i32\\n        {\\n            idx.iter().fold(0, |sum: i32, (ii, jj)| sum + grid[i+ii][j+jj])\\n        };\\n        \\n        // [2] cycle across all hourglasses and compute max sum\\n        (0..m-2).map(|i| (0..n-2).map(move |j| hourglass_sum(i, j)))\\n                .flatten()\\n                .max()\\n                .unwrap()\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn max_sum(grid: Vec<Vec<i32>>) -> i32 \\n    {\\n        // [0] pattern indices\\n        let idx: Vec<(usize, usize)> = vec![(0,0),(0,1),(0,2),(1,1),(2,0),(2,1),(2,2)];\\n        \\n        let m: usize = grid.len();\\n        let n: usize = grid[0].len();\\n        \\n        // [1] a function (more precisely, a closure) that computes sum \\n        //     for the cells in the hourglass pattern given a corner cell\\n        let hourglass_sum = |i: usize, j: usize| -> i32\\n        {\\n            idx.iter().fold(0, |sum: i32, (ii, jj)| sum + grid[i+ii][j+jj])\\n        };\\n        \\n        // [2] cycle across all hourglasses and compute max sum\\n        (0..m-2).map(|i| (0..n-2).map(move |j| hourglass_sum(i, j)))\\n                .flatten()\\n                .max()\\n                .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651521,
                "title": "java-solution-prefix-sum-easy-solution-o-m-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=1;j<grid[0].length;j++){\\n                grid[i][j]+=grid[i][j-1];\\n            }\\n        }\\n        \\n        int max,i,j;\\n        max=i=j=0;\\n        while(i<grid.length-2)\\n        {\\n            int sum=0;\\n            if(j==0)\\n                sum=grid[i][j+2]+grid[i+1][j+1]-grid[i+1][j]+grid[i+2][j+2];\\n            else\\n                sum=grid[i][j+2]-grid[i][j-1]+grid[i+1][j+1]-grid[i+1][j]+grid[i+2][j+2]-grid[i+2][j-1];\\n            j++;\\n            if(sum>max)\\n                max=sum;\\n            if(j==grid[0].length-2){\\n                j=0;\\n                i++;\\n            } \\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSum(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=1;j<grid[0].length;j++){\\n                grid[i][j]+=grid[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2651442,
                "title": "python-solution-numpy-the-easiest-way",
                "content": "```\\nimport numpy as np\\nclass Solution:\\n    def maxSum(self, grid) -> int:\\n        l, r, m, n = 0, 0, len(grid), len(grid[0])\\n        arr = np.array(grid)\\n        max_sum = 0\\n        while l < m - 2:\\n            while r < n - 2:\\n                current_sum = np.sum(arr[l:l + 3, r:r + 3]) - (arr[l + 1, r] + arr[l + 1, r + 2])  # summing 3x3 matrix and subtracting 2 values\\n                max_sum = max(max_sum, current_sum)\\n                r += 1\\n            l += 1\\n            r = 0\\n        return max_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def maxSum(self, grid) -> int:\\n        l, r, m, n = 0, 0, len(grid), len(grid[0])\\n        arr = np.array(grid)\\n        max_sum = 0\\n        while l < m - 2:\\n            while r < n - 2:\\n                current_sum = np.sum(arr[l:l + 3, r:r + 3]) - (arr[l + 1, r] + arr[l + 1, r + 2])  # summing 3x3 matrix and subtracting 2 values\\n                max_sum = max(max_sum, current_sum)\\n                r += 1\\n            l += 1\\n            r = 0\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651312,
                "title": "c-easy-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = INT_MIN;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            for(int j=0; j<m-2; j++)\\n            {\\n                // sum of every hourglass (3x3 sub matrix) in grid\\n                int sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                maxi = max(maxi, sum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = INT_MIN;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            for(int j=0; j<m-2; j++)\\n            {\\n                // sum of every hourglass (3x3 sub matrix) in grid\\n                int sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                maxi = max(maxi, sum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650528,
                "title": "simple-brute-force-java-solution",
                "content": "```\\npublic int maxSum(int[][] grid) {\\n        int ans = 0 ;\\n        for(int i = 0 ; i <= grid[0].length-3 ; i++){\\n            for(int j = 0 ; j <= grid.length-3 ; j++){\\n                int sum = grid[j][i] + grid[j][i+1] + grid[j][i+2] + grid[j+1][i+1]+grid[j+2][i]+grid[j+2][i+1]+grid[j+2][i+2];\\n                ans = Math.max(ans,sum);\\n                sum = 0 ;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSum(int[][] grid) {\\n        int ans = 0 ;\\n        for(int i = 0 ; i <= grid[0].length-3 ; i++){\\n            for(int j = 0 ; j <= grid.length-3 ; j++){\\n                int sum = grid[j][i] + grid[j][i+1] + grid[j][i+2] + grid[j+1][i+1]+grid[j+2][i]+grid[j+2][i+1]+grid[j+2][i+2];\\n                ans = Math.max(ans,sum);\\n                sum = 0 ;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650498,
                "title": "swift-brute-force-solution-o-n-m",
                "content": "```\\nclass Solution {\\n    func maxSum(_ grid: [[Int]]) -> Int {\\n        var res = 0\\n        for y in 1..<grid.count - 1 {\\n            for x in 1..<grid[0].count - 1 {\\n                let sum = grid[y][x]\\n                + grid[y - 1][x - 1] + grid[y - 1][x] + grid[y - 1][x + 1]\\n                + grid[y + 1][x - 1] + grid[y + 1][x] + grid[y + 1][x + 1]\\n                res = max(res, sum)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSum(_ grid: [[Int]]) -> Int {\\n        var res = 0\\n        for y in 1..<grid.count - 1 {\\n            for x in 1..<grid[0].count - 1 {\\n                let sum = grid[y][x]\\n                + grid[y - 1][x - 1] + grid[y - 1][x] + grid[y - 1][x + 1]\\n                + grid[y + 1][x - 1] + grid[y + 1][x] + grid[y + 1][x + 1]\\n                res = max(res, sum)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650194,
                "title": "java-solution-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max=0,sum=0;\\n        for(int i=0;i<grid.length-2;i++){   // moving in row \\n            for(int j=0;j<grid[i].length-2;j++){   //moving in column  \\n               sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n\\t\\t\\t    // Adding values of matrix \\n                max=Math.max(sum,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\nDo upvote if you like my solution",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max=0,sum=0;\\n        for(int i=0;i<grid.length-2;i++){   // moving in row \\n            for(int j=0;j<grid[i].length-2;j++){   //moving in column  \\n               sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n\\t\\t\\t    // Adding values of matrix \\n                max=Math.max(sum,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650144,
                "title": "java-solution-pictorial-explanation-easy-d",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\nThe constraint **```3 <= m, n <= 150```** lets us go for the brute force approach.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ab4a5681-abf0-41d4-92cf-0b722253e34f_1664699871.8791232.png)\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < row - 2; i++) {\\n            for (int j = 0; j < col - 2; j++) {\\n                int currSum = \\n                    grid[i][j] + grid[i][j + 1] + grid[i][j + 2] +                  // top of the hourglass\\n                    grid[i + 1][j + 1] +                                            // middle of the hourglass\\n                    grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];       // base of the hourglass\\n                \\n                maxSum = Math.max(currSum, maxSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n**```Time Complexity:``` O(m * n)**\\n**```Space Complexity:``` O(1)**",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```3 <= m, n <= 150```\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < row - 2; i++) {\\n            for (int j = 0; j < col - 2; j++) {\\n                int currSum = \\n                    grid[i][j] + grid[i][j + 1] + grid[i][j + 2] +                  // top of the hourglass\\n                    grid[i + 1][j + 1] +                                            // middle of the hourglass\\n                    grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];       // base of the hourglass\\n                \\n                maxSum = Math.max(currSum, maxSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```Time Complexity:```\n```Space Complexity:```",
                "codeTag": "Java"
            },
            {
                "id": 2650067,
                "title": "standard-approach-for-similar-questions-c-easy-to-understand",
                "content": "```\\n int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int temp=0;\\n            for(int j=0;j<m-2;j++){\\n                temp+=accumulate(grid[i].begin()+j,grid[i].begin()+j+3,0);\\n                temp+=accumulate(grid[i+2].begin()+j,grid[i+2].begin()+j+3,0);\\n                temp+=(grid[i+1][j+1]);\\n                ans=max(ans,temp);\\n                temp=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int temp=0;\\n            for(int j=0;j<m-2;j++){\\n                temp+=accumulate(grid[i].begin()+j,grid[i].begin()+j+3,0);\\n                temp+=accumulate(grid[i+2].begin()+j,grid[i+2].begin()+j+3,0);\\n                temp+=(grid[i+1][j+1]);\\n                ans=max(ans,temp);\\n                temp=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2649974,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    \\n   \\n \\n    int maxSum(vector<vector<int>>& grid) {\\n        \\n          int max= INT_MIN;\\n    int i,j;\\n    for(i=0;i<grid.size()-2;i++){\\n        for(j=0;j<grid[i].size()-2;j++){\\n          int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n          \\n           if(sum>=max){\\n               max=sum;\\n           }\\n        }\\n    }\\n    return max;\\n  }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n   \\n \\n    int maxSum(vector<vector<int>>& grid) {\\n        \\n          int max= INT_MIN;\\n    int i,j;\\n    for(i=0;i<grid.size()-2;i++){\\n        for(j=0;j<grid[i].size()-2;j++){\\n          int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n          \\n           if(sum>=max){\\n               max=sum;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2649827,
                "title": "java-direction-array",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {1, 1}, {1, 0}, {1, -1}, {0, 0}};\\n    public int maxSum(int[][] grid) {\\n        int answer = 0;\\n        for (int i = 1; i < grid.length - 1; i++) {\\n            for (int j = 1; j < grid[0].length - 1; j++) {\\n                int currHourGlass = 0;\\n                for (int[] d : dirs) {\\n                    currHourGlass += grid[i + d[0]][j + d[1]];\\n                }\\n                answer = Math.max(answer, currHourGlass);\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[][] dirs = new int[][]{{-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 2649814,
                "title": "c-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649604,
                "title": "java-easy-understanding-solution-using-brute-force",
                "content": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                int sum = grid[i][j] + grid[i][j+1] + grid[i][j + 2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                maxSum = Math.max(sum, maxSum);\\n                // System.out.println(sum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                int sum = grid[i][j] + grid[i][j+1] + grid[i][j + 2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                maxSum = Math.max(sum, maxSum);\\n                // System.out.println(sum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649259,
                "title": "easy-iterative-c-solution",
                "content": "class Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 0;\\n        for(int i = 0; i< n-2; i++){\\n            for(int j =0; j< m-2; j++){\\n                int check = grid[i][j]+grid[i][j+1]+grid[i][j+2]\\n                    +grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(check>res){\\n                    res = check;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 0;\\n        for(int i = 0; i< n-2; i++){\\n            for(int j =0; j< m-2; j++){\\n                int check = grid[i][j]+grid[i][j+1]+grid[i][j+2]\\n                    +grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(check>res){\\n                    res = check;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2649227,
                "title": "o-n-2-using-sliding-window-for-finding-houg-glass-matrix-3x3",
                "content": "**Main Idea**:\\n+ Processing 3x3 by sliding window\\n\\n**Code**:\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                vsum = 0\\n                for k in range(3):\\n                    for t in range(3):\\n                        # print(grid[i+k][j+t], end = \" \")\\n                        if k==0 or k==2 or (k==1 and t==1):\\n                            vsum = vsum + grid[i+k][j+t]\\n                    # print()\\n                ans = max(ans, vsum)\\n                # print(\"--\")\\n        # print(\"=\" * 20)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                vsum = 0\\n                for k in range(3):\\n                    for t in range(3):\\n                        # print(grid[i+k][j+t], end = \" \")\\n                        if k==0 or k==2 or (k==1 and t==1):\\n                            vsum = vsum + grid[i+k][j+t]\\n                    # print()\\n                ans = max(ans, vsum)\\n                # print(\"--\")\\n        # print(\"=\" * 20)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649217,
                "title": "python-simple-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        maxy = -100000000000\\n        m, n = len(grid),len(grid[0])\\n        for i in range(0, m-2):\\n            for j in range(0, n-2):\\n                sums = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                if sums > maxy:\\n                    maxy = sums\\n                else:\\n                    continue\\n        return maxy\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        maxy = -100000000000\\n        m, n = len(grid),len(grid[0])\\n        for i in range(0, m-2):\\n            for j in range(0, n-2):\\n                sums = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                if sums > maxy:\\n                    maxy = sums\\n                else:\\n                    continue\\n        return maxy\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649196,
                "title": "easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Brute Force***\\n\\n* ***Time Complexity :- O(N * N * Constant)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            for(int j = 0; j < m - 2; j++)\\n            {\\n                // find sum\\n                \\n                int sum = 0;\\n                \\n                for(int k = j; k <= j + 2; k++)\\n                {\\n                    sum += grid[i][k];\\n                }\\n                \\n                for(int k = j; k <= j + 2; k++)\\n                {\\n                    sum += grid[i + 2][k];\\n                }\\n                \\n                sum += grid[i + 1][j + 1];\\n                \\n                // update maxi\\n                \\n                maxi = max(maxi, sum);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            for(int j = 0; j < m - 2; j++)\\n            {\\n                // find sum\\n                \\n                int sum = 0;\\n                \\n                for(int k = j; k <= j + 2; k++)\\n                {\\n                    sum += grid[i][k];\\n                }\\n                \\n                for(int k = j; k <= j + 2; k++)\\n                {\\n                    sum += grid[i + 2][k];\\n                }\\n                \\n                sum += grid[i + 1][j + 1];\\n                \\n                // update maxi\\n                \\n                maxi = max(maxi, sum);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648980,
                "title": "simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSum(vector<vector<int>>& grid) {\\n        int res=0;\\n        int n = grid.size(),m = grid[0].size();\\n        for(int i= 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                int sum = 0;\\n                bool flag = false;\\n                if(j>0 and i>0 and j<m-1 and i<n-1){\\n                    sum+=grid[i][j];\\n                    sum+=grid[i-1][j] + grid[i-1][j-1] + grid[i-1][j+1];\\n                    sum+=grid[i+1][j] + grid[i+1][j-1] + grid[i+1][j+1];\\n                    flag = true;\\n                }\\n                if(flag)res = max(res,sum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSum(vector<vector<int>>& grid) {\\n        int res=0;\\n        int n = grid.size(),m = grid[0].size();\\n        for(int i= 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                int sum = 0;\\n                bool flag = false;\\n                if(j>0 and i>0 and j<m-1 and i<n-1){\\n                    sum+=grid[i][j];\\n                    sum+=grid[i-1][j] + grid[i-1][j-1] + grid[i-1][j+1];\\n                    sum+=grid[i+1][j] + grid[i+1][j-1] + grid[i+1][j+1];\\n                    flag = true;\\n                }\\n                if(flag)res = max(res,sum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648826,
                "title": "java-efficient-solution-with-explanation-3ms-beats-100",
                "content": "For every row and column find the sum and compare with existing maxSum.\\n\\n```\\n    public int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for(int row = 0; row < grid.length; row++){\\n            for(int col = 0; col < grid[0].length; col++){\\n                maxSum = Math.max(maxSum, findSum(grid, row, col));\\n            }\\n        }\\n        return maxSum;\\n    }\\n\\n    private int findSum(int[][] grid, int row, int col){\\n        if ((row+2 < grid.length) && (col+2 < grid[0].length)){\\n            return grid[row][col] + grid[row][col+1] + grid[row][col+2] \\n                    + grid[row+1][col+1] \\n                    + grid[row+2][col] + grid[row+2][col+1]+ grid[row+2][col+2];\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int maxSum(int[][] grid) {\\n        int maxSum = 0;\\n        for(int row = 0; row < grid.length; row++){\\n            for(int col = 0; col < grid[0].length; col++){\\n                maxSum = Math.max(maxSum, findSum(grid, row, col));\\n            }\\n        }\\n        return maxSum;\\n    }\\n\\n    private int findSum(int[][] grid, int row, int col){\\n        if ((row+2 < grid.length) && (col+2 < grid[0].length)){\\n            return grid[row][col] + grid[row][col+1] + grid[row][col+2] \\n                    + grid[row+1][col+1] \\n                    + grid[row+2][col] + grid[row+2][col+1]+ grid[row+2][col+2];\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648793,
                "title": "c-explanation-with-comments-sliding-window",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n       int i,j,n=grid.size(),m=grid[0].size();\\n\\t   \\n\\t   //calculate the initial window\\n       long long int ans1=grid[0][1]+grid[0][0]+grid[0][2];\\n       long long int ans2=grid[1][1];\\n       long long int ans3=grid[2][1]+grid[2][0]+grid[2][2];\\n       long long int ans=ans1+ans2+ans3;\\n\\t   \\n       long long int mx=ans;\\n\\t   \\n        for(i=0;i<n-2;i++){\\n\\t\\t\\n\\t\\t//for each new row calculate the ans\\n            ans1=grid[i+0][1]+grid[i+0][0]+grid[i+0][2];\\n            ans2=grid[i+1][1];\\n            ans3=grid[i+2][1]+grid[i+2][0]+grid[i+2][2];\\n            ans=ans1+ans2+ans3;\\n\\t\\t\\t\\n\\t\\t\\t//update the max\\n            mx=max(mx,ans);\\n\\t\\t\\t\\n            for(j=1;j<m-2;j++){\\n\\t\\t\\t\\n\\t\\t\\t//slide the ans subtract the old value and add new one\\n                ans1=ans1-grid[i][j-1]+grid[i][j+2];\\n                ans2+=grid[i+1][j+1]-grid[i+1][j];\\n                ans3+=grid[i+2][j+2]-grid[i+2][j-1];\\n\\t\\t\\t\\t\\n                cout<<ans<<\" \";\\n                ans=ans1+ans2+ans3;\\n\\t\\t\\t\\t\\n                //update the max value\\n                mx=max(mx,ans);\\n                cout<<ans<<\" \"<<mx<<\" \";\\n            }\\n        }\\n        return mx;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n       int i,j,n=grid.size(),m=grid[0].size();\\n\\t   \\n\\t   //calculate the initial window\\n       long long int ans1=grid[0][1]+grid[0][0]+grid[0][2];\\n       long long int ans2=grid[1][1];\\n       long long int ans3=grid[2][1]+grid[2][0]+grid[2][2];\\n       long long int ans=ans1+ans2+ans3;\\n\\t   \\n       long long int mx=ans;\\n\\t   \\n        for(i=0;i<n-2;i++){\\n\\t\\t\\n\\t\\t//for each new row calculate the ans\\n            ans1=grid[i+0][1]+grid[i+0][0]+grid[i+0][2];\\n            ans2=grid[i+1][1];\\n            ans3=grid[i+2][1]+grid[i+2][0]+grid[i+2][2];\\n            ans=ans1+ans2+ans3;\\n\\t\\t\\t\\n\\t\\t\\t//update the max\\n            mx=max(mx,ans);\\n\\t\\t\\t\\n            for(j=1;j<m-2;j++){\\n\\t\\t\\t\\n\\t\\t\\t//slide the ans subtract the old value and add new one\\n                ans1=ans1-grid[i][j-1]+grid[i][j+2];\\n                ans2+=grid[i+1][j+1]-grid[i+1][j];\\n                ans3+=grid[i+2][j+2]-grid[i+2][j-1];\\n\\t\\t\\t\\t\\n                cout<<ans<<\" \";\\n                ans=ans1+ans2+ans3;\\n\\t\\t\\t\\t\\n                //update the max value\\n                mx=max(mx,ans);\\n                cout<<ans<<\" \"<<mx<<\" \";\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2648770,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\ntypedef long long ll;\\npublic:\\n    int maxSum(vector<vector<int>>&v) {\\n        ll m=v.size(), n=v[0].size();\\n        ll ans=0;\\n        for(ll i=0;i<m;++i){\\n            for(ll j=0;j<n;++j){\\n                if(j+2>=n || i+2>=m){\\n                    continue;\\n                }\\n                ll res=v[i][j]+v[i][j+1]+v[i][j+2]+v[i+1][j+1]+v[i+2][j]+v[i+2][j+1]+v[i+2][j+2];\\n                ans=max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution{\\ntypedef long long ll;\\npublic:\\n    int maxSum(vector<vector<int>>&v) {\\n        ll m=v.size(), n=v[0].size();\\n        ll ans=0;\\n        for(ll i=0;i<m;++i){\\n            for(ll j=0;j<n;++j){\\n                if(j+2>=n || i+2>=m){\\n                    continue;\\n                }\\n                ll res=v[i][j]+v[i][j+1]+v[i][j+2]+v[i+1][j+1]+v[i+2][j]+v[i+2][j+1]+v[i+2][j+2];\\n                ans=max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648735,
                "title": "java-explained-with-intution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        \\n        // as we can only traverse till -2 position in the matrix \\n        // consider the example 1 ---\\n        // if I am standing on 6, I\\'m 3 blocks away from boundary\\n        // if I am standing on 2 I\\'m 2 blocks away\\n        // If I am on 1, then I\\'m 1 block away !! Trigger, as at this block I cannot form a hourglass\\n        \\n        // Similar to this you can see in column\\n        // Hence, we have to do length-2 on both, so that it does not go our of bounds\\n        \\n        int sum = 0;\\n        \\n        for(int i=0;i<grid.length-2;i++)\\n        {\\n            for(int j=0;j<grid[i].length-2;j++)\\n            {\\n                // find sum - simply by considering exmaple 2 in respect to i and j\\n                sum = Math.max(sum, grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        \\n        // as we can only traverse till -2 position in the matrix \\n        // consider the example 1 ---\\n        // if I am standing on 6, I\\'m 3 blocks away from boundary\\n        // if I am standing on 2 I\\'m 2 blocks away\\n        // If I am on 1, then I\\'m 1 block away !! Trigger, as at this block I cannot form a hourglass\\n        \\n        // Similar to this you can see in column\\n        // Hence, we have to do length-2 on both, so that it does not go our of bounds\\n        \\n        int sum = 0;\\n        \\n        for(int i=0;i<grid.length-2;i++)\\n        {\\n            for(int j=0;j<grid[i].length-2;j++)\\n            {\\n                // find sum - simply by considering exmaple 2 in respect to i and j\\n                sum = Math.max(sum, grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648718,
                "title": "java-simple-and-easy-with-explanation",
                "content": "Explanation\\n\\n* Find sum for each cell as long as it forms a hourglass within the boundries of grid\\n* For eah cell, we can see this pattern as - sum= grid[row][col]+ grid[row][col+1]+ grid[row][col+2]+ grid[row+1][col+1]+ grid[row+2][col+1]+ grid[row+2][col+2]\\n* Then take max of max so far and current sum\\n\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n      int maxSum =0;\\n      for(int i=0; i<grid.length; i++){\\n        for(int j=0; j<grid[0].length; j++){\\n          maxSum = Math.max(maxSum, findSum(grid, i, j));\\n        }\\n      }\\n      return maxSum;\\n    }\\n  \\n  private int findSum(int[][] grid, int row, int col){\\n    int sum=0;\\n    if (row+2 < grid.length   &&  col+2 < grid[0].length){\\n      sum = grid[row][col]+ grid[row][col+1]+ grid[row][col+2]+ grid[row+1][col+1]+ grid[row+2][col]+ grid[row+2][col+1]+ grid[row+2][col+2];\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n      int maxSum =0;\\n      for(int i=0; i<grid.length; i++){\\n        for(int j=0; j<grid[0].length; j++){\\n          maxSum = Math.max(maxSum, findSum(grid, i, j));\\n        }\\n      }\\n      return maxSum;\\n    }\\n  \\n  private int findSum(int[][] grid, int row, int col){\\n    int sum=0;\\n    if (row+2 < grid.length   &&  col+2 < grid[0].length){\\n      sum = grid[row][col]+ grid[row][col+1]+ grid[row][col+2]+ grid[row+1][col+1]+ grid[row+2][col]+ grid[row+2][col+1]+ grid[row+2][col+2];\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648716,
                "title": "c-sum-in-a-window-of-3-easy-approach",
                "content": "**Logic** we\\'ll traverse row(i) wise in a window of 3 and column(j) wise in a window of 3 \\nWe\\'ll add the hour glass of the current window\\n\\n```\\n  int maxSum(vector<vector<int>>& grid)\\n  {\\n      int maxSum = 0;\\n      for (int i = 0; i < grid.size() - 2; i++) //row wise traversing \\n      {\\n          for (int j = 0; j < grid[0].size() - 2; j++) //column wise traversing\\n          {\\n              //made it in shape of hourglass for easier to understand! \\n              int currSum = grid[i][j] + grid[i][j+1] + grid[i][j+2] +\\n                                         grid[i+1][j+1]+\\n                          grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n              maxSum = max(maxSum, currSum);\\n          }\\n      }\\n      return maxSum;\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n  int maxSum(vector<vector<int>>& grid)\\n  {\\n      int maxSum = 0;\\n      for (int i = 0; i < grid.size() - 2; i++) //row wise traversing \\n      {\\n          for (int j = 0; j < grid[0].size() - 2; j++) //column wise traversing\\n          {\\n              //made it in shape of hourglass for easier to understand! \\n              int currSum = grid[i][j] + grid[i][j+1] + grid[i][j+2] +\\n                                         grid[i+1][j+1]+\\n                          grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n              maxSum = max(maxSum, currSum);\\n          }\\n      }\\n      return maxSum;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648669,
                "title": "c-very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum(int i, int j, vector<vector<int>>& arr){\\n        if(i-1> = 0 and i+1 < arr.size() and j-1 >= 0 and j+1 < arr[0].size()){\\n            return arr[i][j] + arr[i-1][j] + arr[i+1][j] + arr[i-1][j-1] + arr[i-1][j+1] + arr[i+1][j-1] + arr[i+1][j+1];\\n        }\\n        return 0;\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i =0; i < grid.size(); i++)\\n            for(int j =0 ; j < grid[0].size(); j++)\\n                ans = max(ans,sum(i,j,grid));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(int i, int j, vector<vector<int>>& arr){\\n        if(i-1> = 0 and i+1 < arr.size() and j-1 >= 0 and j+1 < arr[0].size()){\\n            return arr[i][j] + arr[i-1][j] + arr[i+1][j] + arr[i-1][j-1] + arr[i-1][j+1] + arr[i+1][j-1] + arr[i+1][j+1];\\n        }\\n        return 0;\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i =0; i < grid.size(); i++)\\n            for(int j =0 ; j < grid[0].size(); j++)\\n                ans = max(ans,sum(i,j,grid));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090462,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        arr = []\\n        \\n        def findSum(row, col):\\n            values = [(row - 1, col - 1),\\n            (row - 1, col), \\n            (row - 1, col + 1), \\n            (row, col), \\n            (row + 1, col - 1), \\n            (row + 1, col), \\n            (row + 1, col + 1)]\\n\\n            ans = 0\\n\\n            for i in values:\\n                ans = ans + grid[i[0]][i[1]]\\n            \\n            return ans\\n\\n        for i in range(1, len(grid) - 1):\\n            for j in range(1, len(grid[i]) - 1):\\n                arr.append(findSum(i, j))\\n\\n        return max(arr)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        arr = []\\n        \\n        def findSum(row, col):\\n            values = [(row - 1, col - 1),\\n            (row - 1, col), \\n            (row - 1, col + 1), \\n            (row, col), \\n            (row + 1, col - 1), \\n            (row + 1, col), \\n            (row + 1, col + 1)]\\n\\n            ans = 0\\n\\n            for i in values:\\n                ans = ans + grid[i[0]][i[1]]\\n            \\n            return ans\\n\\n        for i in range(1, len(grid) - 1):\\n            for j in range(1, len(grid[i]) - 1):\\n                arr.append(findSum(i, j))\\n\\n        return max(arr)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064906,
                "title": "simple-c-solution-beats-88-brute-force",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int max = 0;\\n        for(int i=0;i<grid.size()-2;i++){\\n            for(int j=0;j<grid[i].size()-2;j++){\\n                int sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(max<sum) max=sum;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int max = 0;\\n        for(int i=0;i<grid.size()-2;i++){\\n            for(int j=0;j<grid[i].size()-2;j++){\\n                int sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(max<sum) max=sum;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050153,
                "title": "short-and-easy-solution-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& nums) {\\n       int ans  = 0;\\n        int n= nums.size(),m = nums[0].size();\\n        for(int i =0;i<n-2;i++)\\n        {\\n            for(int j = 0;j<m-2;j++)\\n            {\\n                int sum = 0;\\n                sum = nums[i][j]+nums[i][j+1]+nums[i][j+2]+nums[i+2][j]+nums[i+2][j+1]+nums[i+2][j+2]+nums[i+1][j+1];\\n                ans = max(sum,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUPVOTE PLEASE;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& nums) {\\n       int ans  = 0;\\n        int n= nums.size(),m = nums[0].size();\\n        for(int i =0;i<n-2;i++)\\n        {\\n            for(int j = 0;j<m-2;j++)\\n            {\\n                int sum = 0;\\n                sum = nums[i][j]+nums[i][j+1]+nums[i][j+2]+nums[i+2][j]+nums[i+2][j+1]+nums[i+2][j+2]+nums[i+1][j+1];\\n                ans = max(sum,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013868,
                "title": "91-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size(),res=0;\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                res=max(res,g[i][j]+g[i][j+1]+g[i][j+2]\\n                + g[i+1][j+1]\\n                +g[i+2][j]+g[i+2][j+1]+g[i+2][j+2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size(),res=0;\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                res=max(res,g[i][j]+g[i][j+1]+g[i][j+2]\\n                + g[i+1][j+1]\\n                +g[i+2][j]+g[i+2][j+1]+g[i+2][j+2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995458,
                "title": "5ms-beats-73-51",
                "content": "\\n\\n# Code\\n```\\n// 5ms Beats 73.51%\\n\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        // keep track of upper left corner of the hourglass using (i, j)\\n        // use sliding windows to keep track of sum for each of the three rows of hourglass\\n\\n        int maxSum = 0;  // what we\\'ll return\\n        int curSum = 0;\\n\\n        for (int i = 0; i < m - 2; ++i) {  // rows\\n            // calculate sum for first hourglass in row (upper left corner is at (i, 0) )\\n            curSum = grid[i][0] + grid[i][1] + grid[i][2] + grid[i + 1][1] + grid[i + 2][0] + grid[i + 2][1] + grid[i + 2][2];\\n            maxSum = (maxSum > curSum) ? maxSum : curSum;\\n\\n            for (int j = 1; j < n - 2; ++j) {  // cols\\n                // compute change in curSum\\n                curSum -= grid[i][j - 1] + grid[i + 1][j] + grid[i + 2][j - 1];\\n                curSum += grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j + 2];\\n                maxSum = (maxSum > curSum) ? maxSum : curSum;\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 5ms Beats 73.51%\\n\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        // keep track of upper left corner of the hourglass using (i, j)\\n        // use sliding windows to keep track of sum for each of the three rows of hourglass\\n\\n        int maxSum = 0;  // what we\\'ll return\\n        int curSum = 0;\\n\\n        for (int i = 0; i < m - 2; ++i) {  // rows\\n            // calculate sum for first hourglass in row (upper left corner is at (i, 0) )\\n            curSum = grid[i][0] + grid[i][1] + grid[i][2] + grid[i + 1][1] + grid[i + 2][0] + grid[i + 2][1] + grid[i + 2][2];\\n            maxSum = (maxSum > curSum) ? maxSum : curSum;\\n\\n            for (int j = 1; j < n - 2; ++j) {  // cols\\n                // compute change in curSum\\n                curSum -= grid[i][j - 1] + grid[i + 1][j] + grid[i + 2][j - 1];\\n                curSum += grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j + 2];\\n                maxSum = (maxSum > curSum) ? maxSum : curSum;\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989281,
                "title": "iterative-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        ans=0\\n        for i in range(1,len(grid)-1):\\n            for j in range(1,len(grid[0])-1):\\n                c = grid[i][j]+grid[i-1][j]+grid[i-1][j-1]+grid[i-1][j+1]+grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j-1]\\n                ans = max(ans,c)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        ans=0\\n        for i in range(1,len(grid)-1):\\n            for j in range(1,len(grid[0])-1):\\n                c = grid[i][j]+grid[i-1][j]+grid[i-1][j-1]+grid[i-1][j+1]+grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j-1]\\n                ans = max(ans,c)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987380,
                "title": "shortest-and-easiest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>&g){\\n        int mx=0;\\n        for(int i=1; i<g.size()-1; i++){\\n            for(int j=1; j<g[0].size()-1; j++){\\n                int sum=g[i][j]+g[i-1][j-1]+g[i+1][j+1]+g[i-1][j+1]+g[i+1][j-1]+g[i-1][j]+g[i+1][j];;\\n                mx=max(mx,sum);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>&g){\\n        int mx=0;\\n        for(int i=1; i<g.size()-1; i++){\\n            for(int j=1; j<g[0].size()-1; j++){\\n                int sum=g[i][j]+g[i-1][j-1]+g[i+1][j+1]+g[i-1][j+1]+g[i+1][j-1]+g[i-1][j]+g[i+1][j];;\\n                mx=max(mx,sum);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987214,
                "title": "c-solution-explanation-simple",
                "content": "# EXPLANATION\\nHere we just calculated the sum of first form top-left hourglass shape that is mention, then traversed through the whole matrix and simultaneoulsy found the max value possible.\\nWe need to add and subtract on every step for the answer. \\nFinally returned the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int ans=0;\\n        int m=g.size(),n=g[0].size();\\n        for(int i=0;i<m-2;i++){\\n            int l1=g[i][0]+g[i][1]+g[i][2];\\n            int l2=g[i+1][1];\\n            int l3=g[i+2][0]+g[i+2][1]+g[i+2][2];\\n            int s=l1+l2+l3;\\n            ans=max(ans,s);\\n            for(int j=1;j<n-2;j++){\\n                s-=g[i][j-1];\\n                s-=g[i+1][j];\\n                s-=g[i+2][j-1];\\n                s+=g[i][j+2];\\n                s+=g[i+1][j+1];\\n                s+=g[i+2][j+2];\\n                ans=max(ans,s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int ans=0;\\n        int m=g.size(),n=g[0].size();\\n        for(int i=0;i<m-2;i++){\\n            int l1=g[i][0]+g[i][1]+g[i][2];\\n            int l2=g[i+1][1];\\n            int l3=g[i+2][0]+g[i+2][1]+g[i+2][2];\\n            int s=l1+l2+l3;\\n            ans=max(ans,s);\\n            for(int j=1;j<n-2;j++){\\n                s-=g[i][j-1];\\n                s-=g[i+1][j];\\n                s-=g[i+2][j-1];\\n                s+=g[i][j+2];\\n                s+=g[i+1][j+1];\\n                s+=g[i+2][j+2];\\n                ans=max(ans,s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976855,
                "title": "100-beats-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int n = grid.length-3+1;\\n        int m = grid[0].length-3+1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                max=Math.max(max,getAns(grid,i,j));\\n            }\\n        }\\n        return max;\\n    }\\n    public int getAns(int[][] mat , int rowS,int colS){\\n        int ans=0;\\n        int col=1;\\n        int rowE=rowS+2;\\n        int colE=colS+2;\\n        for(int i=rowS;i<=rowE;i++){\\n            for(int j=colS;j<=colE;j++){\\n                if(col==2){\\n                    ans+=mat[i][j+1];\\n                    break;\\n                }\\n                else{\\n                    ans+=mat[i][j];\\n                }\\n                \\n            } \\n            col++;  \\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int n = grid.length-3+1;\\n        int m = grid[0].length-3+1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                max=Math.max(max,getAns(grid,i,j));\\n            }\\n        }\\n        return max;\\n    }\\n    public int getAns(int[][] mat , int rowS,int colS){\\n        int ans=0;\\n        int col=1;\\n        int rowE=rowS+2;\\n        int colE=colS+2;\\n        for(int i=rowS;i<=rowE;i++){\\n            for(int j=colS;j<=colE;j++){\\n                if(col==2){\\n                    ans+=mat[i][j+1];\\n                    break;\\n                }\\n                else{\\n                    ans+=mat[i][j];\\n                }\\n                \\n            } \\n            col++;  \\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976523,
                "title": "prefixsum-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply prefixSum calculations on each row that have the conditions applied and here we don\\'t need to perserve the values we only need to find the maximum that is why we just calculate the sum from one node to another\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        for(int i=0; i+2<grid.length; i++){\\n            int sum =    grid[i][0]   + grid[i][1]   + grid[i][2]\\n                                      + grid[i+1][1]\\n                        +grid[i+2][0] + grid[i+2][1] + grid[i+2][2];\\n            if(sum > max)\\n                    max = sum;\\n\\n            for(int j=1; j+2<grid[0].length; j++){\\n                sum -= grid[i][j-1];\\n                sum += grid[i][j+2];\\n                sum -= grid[i+1][j];\\n                sum += grid[i+1][j+1];\\n                sum -= grid[i+2][j-1];\\n                sum += grid[i+2][j+2];\\n                if(sum > max)\\n                    max = sum;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        for(int i=0; i+2<grid.length; i++){\\n            int sum =    grid[i][0]   + grid[i][1]   + grid[i][2]\\n                                      + grid[i+1][1]\\n                        +grid[i+2][0] + grid[i+2][1] + grid[i+2][2];\\n            if(sum > max)\\n                    max = sum;\\n\\n            for(int j=1; j+2<grid[0].length; j++){\\n                sum -= grid[i][j-1];\\n                sum += grid[i][j+2];\\n                sum -= grid[i+1][j];\\n                sum += grid[i+1][j+1];\\n                sum -= grid[i+2][j-1];\\n                sum += grid[i+2][j+2];\\n                if(sum > max)\\n                    max = sum;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965725,
                "title": "python-simple-beginers",
                "content": "# simple python matrix solution \\n**locate boundaries and centralize elements .track element by i,j values**\\n\\n```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m = len(grid)\\n        n = len(grid[0])\\n        sum1  = float(\\'-inf\\')\\n        for i in range(1,m-1):\\n            for j in range(1,n-1):\\n                val = grid[i][j] + grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1] \\n                if val > sum1:\\n                    sum1 = val\\n        return sum1\\n                \\n        \\n```\\n# please upvote\\n![image](https://assets.leetcode.com/users/images/773b5eb7-2d69-49b4-9d6e-fcd50f764139_1693115651.2384439.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m = len(grid)\\n        n = len(grid[0])\\n        sum1  = float(\\'-inf\\')\\n        for i in range(1,m-1):\\n            for j in range(1,n-1):\\n                val = grid[i][j] + grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1] \\n                if val > sum1:\\n                    sum1 = val\\n        return sum1\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964316,
                "title": "sliding-window",
                "content": "# Approach\\n    Slide our oclock from the start of the matrix to the end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$o(M*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), max_sum = INT_MIN;\\n        for(int i = 0; i < (m - 2); i++) {\\n            int sum = (grid[i][0] + grid[i][1] + grid[i][2])\\n                            + grid[i+1][1]\\n                       + (grid[i+2][0] + grid[i+2][1] + grid[i+2][2]);\\n            if(max_sum < sum)\\n                    max_sum = sum;\\n            for(int j = 3; j < n; j++) {\\n                sum += (grid[i][j] + grid[i+1][j-1] + grid[i+2][j])\\n                    - (grid[i][j-3] + grid[i+1][j-2] + grid[i+2][j-3]);\\n                \\n                if(max_sum < sum)\\n                    max_sum = sum;\\n            }\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), max_sum = INT_MIN;\\n        for(int i = 0; i < (m - 2); i++) {\\n            int sum = (grid[i][0] + grid[i][1] + grid[i][2])\\n                            + grid[i+1][1]\\n                       + (grid[i+2][0] + grid[i+2][1] + grid[i+2][2]);\\n            if(max_sum < sum)\\n                    max_sum = sum;\\n            for(int j = 3; j < n; j++) {\\n                sum += (grid[i][j] + grid[i+1][j-1] + grid[i+2][j])\\n                    - (grid[i][j-3] + grid[i+1][j-2] + grid[i+2][j-3]);\\n                \\n                if(max_sum < sum)\\n                    max_sum = sum;\\n            }\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946605,
                "title": "easy-code-but-runs-in-7ms",
                "content": "# Intuition\\nThis sum is asked in my placement training today, in which i came up this solution and i wondered the problem to be in leetcode and tried to solve it my own logic its seem to be same but runs in more time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst,Find out the no.of Hours glasses in the given matrix. for example if you take 6*6 matrix, it may consists up to 16hours glass positions and calculate the sum of the each housrglass and find out the maximum sum of the hourglass in the given matrix.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                maxi=Math.max(maxi,sum);\\n            }\\n        }   \\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=0;j<m-2;j++)\\n            {\\n                int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                maxi=Math.max(maxi,sum);\\n            }\\n        }   \\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940950,
                "title": "bruteforce-solution-easy-python-o-n-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        #bruteforce \\n        sums = []\\n        def hourglass3x3(matrix, a, b):\\n            sum = 0\\n            for i in range(3):\\n                for j in range(3):\\n                    if i == 1 and (j == 0 or j == 2):\\n                        continue\\n                    else:\\n                        sum += matrix[i+a][j+b]\\n            return sum\\n    \\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        x = n - 2 \\n        y = m - 2\\n\\n        for a in range(y):\\n            for b in range(x):\\n                sums.append(hourglass3x3(grid, a, b))\\n        \\n        return max(sums)\\n\\n\\n                \\n    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        #bruteforce \\n        sums = []\\n        def hourglass3x3(matrix, a, b):\\n            sum = 0\\n            for i in range(3):\\n                for j in range(3):\\n                    if i == 1 and (j == 0 or j == 2):\\n                        continue\\n                    else:\\n                        sum += matrix[i+a][j+b]\\n            return sum\\n    \\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        x = n - 2 \\n        y = m - 2\\n\\n        for a in range(y):\\n            for b in range(x):\\n                sums.append(hourglass3x3(grid, a, b))\\n        \\n        return max(sums)\\n\\n\\n                \\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938106,
                "title": "c-98-4-faster-86-less-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                int sum=0;\\n                sum+=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                int sum=0;\\n                sum+=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                ans=max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925269,
                "title": "simple-matrix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n          \\n          int ms=0,r=grid.size(),c=grid[0].size();\\n          for(int i=0;i<r-2;++i)\\n           {\\n               for(int j=0;j<c-2;j++)\\n                {\\n                   int s= getSum(grid,i,j,r,c);\\n                    ms=max(s,ms);\\n                }\\n           }\\n           return ms;\\n    }\\n    int getSum(vector<vector<int>>&grid,int i,int j,int r,int c)\\n     {\\n         int sum=0;\\n         for(int cc=j;cc<j+3;cc++)\\n            {\\n                sum+=grid[i][cc];\\n            }\\n            r=i+2;\\n            for(int cc=j;cc<j+3;cc++)\\n                sum+=grid[r][cc];\\n            sum+=grid[i+1][j+1];\\n            return sum;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n          \\n          int ms=0,r=grid.size(),c=grid[0].size();\\n          for(int i=0;i<r-2;++i)\\n           {\\n               for(int j=0;j<c-2;j++)\\n                {\\n                   int s= getSum(grid,i,j,r,c);\\n                    ms=max(s,ms);\\n                }\\n           }\\n           return ms;\\n    }\\n    int getSum(vector<vector<int>>&grid,int i,int j,int r,int c)\\n     {\\n         int sum=0;\\n         for(int cc=j;cc<j+3;cc++)\\n            {\\n                sum+=grid[i][cc];\\n            }\\n            r=i+2;\\n            for(int cc=j;cc<j+3;cc++)\\n                sum+=grid[r][cc];\\n            sum+=grid[i+1][j+1];\\n            return sum;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922338,
                "title": "swift-easy-solution-100-time-and-100-space",
                "content": "```\\nclass Solution {\\n    func maxSum(_ grid: [[Int]]) -> Int {\\n        var maxRow = grid.count - 3\\n        var maxColumn = grid[0].count - 3\\n        var max = 0\\n        \\n        for i in 0...maxRow {\\n            for j in 0...maxColumn {\\n                let val = sumOfHourGlass(i,j,grid)\\n                max = val > max ? val : max\\n            }\\n        }\\n        \\n        return max\\n    }\\n    \\n    private func sumOfHourGlass(_ i: Int,_ j: Int,_ matrix: [[Int]]) -> Int {\\n        let val = matrix[i][j] + matrix[i][j+1] + matrix[i][j+2] +\\n                  matrix[i+1][j+1] +\\n                  matrix[i+2][j] + matrix[i+2][j+1] + matrix[i+2][j+2]\\n        return val\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    func maxSum(_ grid: [[Int]]) -> Int {\\n        var maxRow = grid.count - 3\\n        var maxColumn = grid[0].count - 3\\n        var max = 0\\n        \\n        for i in 0...maxRow {\\n            for j in 0...maxColumn {\\n                let val = sumOfHourGlass(i,j,grid)\\n                max = val > max ? val : max\\n            }\\n        }\\n        \\n        return max\\n    }\\n    \\n    private func sumOfHourGlass(_ i: Int,_ j: Int,_ matrix: [[Int]]) -> Int {\\n        let val = matrix[i][j] + matrix[i][j+1] + matrix[i][j+2] +\\n                  matrix[i+1][j+1] +\\n                  matrix[i+2][j] + matrix[i+2][j+1] + matrix[i+2][j+2]\\n        return val\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922236,
                "title": "prefix-sum-of-each-row-in-the-grid",
                "content": "# Intuition\\nFor each row in the grid, convert it into a prefix sum array.\\nThen you just iterate over that grid and greedily get the hour glass sum and set it as max if its max.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        \\n        ROWS,COLS = len(grid), len(grid[0])\\n\\n        #generate prefix sum for each row in the grid\\n        for y in range(ROWS):\\n            for x in range(1,COLS):                            \\n                grid[y][x] = grid[y][x] + grid[y][x-1]\\n            \\n        #answer\\n        total = 0\\n\\n        #iterate over elgible indexes\\n        for y in range(ROWS-2):\\n            for x  in range(COLS-2):\\n                #top row\\n                tr = grid[y][x+2]\\n                #bottom row\\n                br = grid[y+2][x+2]\\n                #if x is not 0 index\\n                if x:                \\n                    tr -= grid[y][x-1]             \\n                    br -= grid[y+2][x-1]             \\n                                    \\n                #middle cell\\n                m = grid[y+1][x+1] - grid[y+1][x]\\n\\n                total = max(total, m + br + tr)\\n\\n        return total\\n\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        \\n        ROWS,COLS = len(grid), len(grid[0])\\n\\n        #generate prefix sum for each row in the grid\\n        for y in range(ROWS):\\n            for x in range(1,COLS):                            \\n                grid[y][x] = grid[y][x] + grid[y][x-1]\\n            \\n        #answer\\n        total = 0\\n\\n        #iterate over elgible indexes\\n        for y in range(ROWS-2):\\n            for x  in range(COLS-2):\\n                #top row\\n                tr = grid[y][x+2]\\n                #bottom row\\n                br = grid[y+2][x+2]\\n                #if x is not 0 index\\n                if x:                \\n                    tr -= grid[y][x-1]             \\n                    br -= grid[y+2][x-1]             \\n                                    \\n                #middle cell\\n                m = grid[y+1][x+1] - grid[y+1][x]\\n\\n                total = max(total, m + br + tr)\\n\\n        return total\\n\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862707,
                "title": "simple-understandable",
                "content": "Beginners can refer..\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int max = 0;\\n\\n        for(int i = 0; i < m-2; i++){\\n            for(int j = 0; j < n -2; j++){\\n                int sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max)max=sum;\\n            }\\n        }\\n        return max;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int max = 0;\\n\\n        for(int i = 0; i < m-2; i++){\\n            for(int j = 0; j < n -2; j++){\\n                int sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max)max=sum;\\n            }\\n        }\\n        return max;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849851,
                "title": "python3-solution-with-sum-caching-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple brute force solution will work here. But, in a very big grid, we can see that sum of same 3 elements can be calculated 2 times - once when the three elements make the top part of the hourglass and once when the 3 elements make the bottom part of the hourglass. Can we optimize it?\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a `sum_3_matrix` which contains the sum of 3 elements in a row so that we don\\'t have to duplicate the calculation of the sum. The size of `sum_3_matrix` will be `m*n` where `m = len(grid)-2` and `n=len(grid[0])-2`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of calculating `sum_3_matrix` is `O(x)*O(y)` where `x`,`y` are the dimentions of the `grid`. The time complexity of finding the max sum is `O(x)*O(y)` as well. Hence, the overall complexity is `O(x)*O(y)`.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe size of `sum_3_matrix` is `O(x)*O(y)`, where `x`,`y` are the dimentions of the `grid`.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m = len(grid) - 2\\n        n = len(grid[0]) - 2\\n        if n <= 0 or m <= 0:\\n            return 0\\n        \\n        # Matrix containing sum of 3 consecutive elements in a row.\\n        sum_3_matrix = [[0]*n for _ in range(len(grid))]\\n\\n        for i in range(len(grid)):\\n            for j in range(n):\\n                sum_3_matrix[i][j] = sum(grid[i][j:j+3])\\n\\n        result = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # Take the sum of following elements:\\n                # * sum_3_matrix[i][j] -> Top 3 elements of hourglass\\n                # * grid[i+1][j+1] -> Middle element of hourglass\\n                # * sum_3_matrix[i+2][j] -> Bottom 3 elements of hourglass\\n                temp_sum = sum_3_matrix[i][j] + grid[i+1][j+1] + sum_3_matrix[i+2][j]\\n                if temp_sum > result:\\n                    result = temp_sum\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m = len(grid) - 2\\n        n = len(grid[0]) - 2\\n        if n <= 0 or m <= 0:\\n            return 0\\n        \\n        # Matrix containing sum of 3 consecutive elements in a row.\\n        sum_3_matrix = [[0]*n for _ in range(len(grid))]\\n\\n        for i in range(len(grid)):\\n            for j in range(n):\\n                sum_3_matrix[i][j] = sum(grid[i][j:j+3])\\n\\n        result = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # Take the sum of following elements:\\n                # * sum_3_matrix[i][j] -> Top 3 elements of hourglass\\n                # * grid[i+1][j+1] -> Middle element of hourglass\\n                # * sum_3_matrix[i+2][j] -> Bottom 3 elements of hourglass\\n                temp_sum = sum_3_matrix[i][j] + grid[i+1][j+1] + sum_3_matrix[i+2][j]\\n                if temp_sum > result:\\n                    result = temp_sum\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849737,
                "title": "intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe algorithm aims to find the maximum sum of values in any hourglass pattern in a 2D grid. An hourglass pattern is formed by selecting 7 elements in the grid: the center element and the 6 surrounding elements. The algorithm iterates through the grid, calculating the sum of each hourglass pattern, and keeps track of the maximum sum encountered.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n The algorithm uses two functions: HourGlassSum calculates the sum of an hourglass pattern at a given position, and maxSum iterates through the grid, finding the maximum sum by calling HourGlassSum for each hourglass position. The algorithm explores all possible hourglass patterns, comparing their sums, and returns the maximum sum found.\\n# Complexity\\n- Time complexity:  O(R * C)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int HourGlassSum(vector<vector<int>> &grid, int row, int column){\\n        return grid[row][column] + grid[row-1][column] + grid[row-1][column-1] + grid[row-1][column + 1] + grid[row+1][column] + grid[row+1][column - 1] + grid[row + 1][column + 1];\\n    };\\n    int maxSum(vector<vector<int>>& grid) {\\n        int MaxSum = 0;\\n        for(int r = 1; r < grid.size() - 1; r++){\\n            for(int c = 1 ; c < grid[0].size() - 1; c++){\\n                int curr_hourglass_sum = HourGlassSum(grid, r, c);\\n                MaxSum = max(MaxSum ,curr_hourglass_sum );\\n            }\\n        } \\n\\n        return MaxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int HourGlassSum(vector<vector<int>> &grid, int row, int column){\\n        return grid[row][column] + grid[row-1][column] + grid[row-1][column-1] + grid[row-1][column + 1] + grid[row+1][column] + grid[row+1][column - 1] + grid[row + 1][column + 1];\\n    };\\n    int maxSum(vector<vector<int>>& grid) {\\n        int MaxSum = 0;\\n        for(int r = 1; r < grid.size() - 1; r++){\\n            for(int c = 1 ; c < grid[0].size() - 1; c++){\\n                int curr_hourglass_sum = HourGlassSum(grid, r, c);\\n                MaxSum = max(MaxSum ,curr_hourglass_sum );\\n            }\\n        } \\n\\n        return MaxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845100,
                "title": "java-simple-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Simple approach to calculate sum\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length-2;i++)\\n        {\\n            for(int j=0;j<grid[0].length-2;j++)\\n            {\\nint sum=(grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]);\\nans =Math.max(ans,sum);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length-2;i++)\\n        {\\n            for(int j=0;j<grid[0].length-2;j++)\\n            {\\nint sum=(grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]);\\nans =Math.max(ans,sum);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844244,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    /* rsingh2003 */\\n\\n    int maxSum(vector<vector<int>>& arr) {\\n        int n = (int)arr.size();\\n        int m = (int)arr[0].size();\\n        int res = 0;\\n        for(int i = 0; i < n-2; i++)\\n        {\\n            for(int j = 0; j < m-2; j++)\\n            {\\n                int ans = 0;\\n                ans += (arr[i][j] + arr[i][j+1] + arr[i][j+2]);\\n                ans += arr[i+1][j+1];\\n                ans += (arr[i+2][j] + arr[i+2][j+1] + arr[i+2][j+2]);\\n                res =  max(res,ans);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    /* rsingh2003 */\\n\\n    int maxSum(vector<vector<int>>& arr) {\\n        int n = (int)arr.size();\\n        int m = (int)arr[0].size();\\n        int res = 0;\\n        for(int i = 0; i < n-2; i++)\\n        {\\n            for(int j = 0; j < m-2; j++)\\n            {\\n                int ans = 0;\\n                ans += (arr[i][j] + arr[i][j+1] + arr[i][j+2]);\\n                ans += arr[i+1][j+1];\\n                ans += (arr[i+2][j] + arr[i+2][j+1] + arr[i+2][j+2]);\\n                res =  max(res,ans);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837167,
                "title": "simple-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int maxSum =Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<rows-2; i++){\\n            for(int j=0; j<cols-2; j++){\\n                int sum = (grid[i][j] +grid[i][j+1]+ grid[i][j+2] ) + //1st Row\\n                           ( grid[i+1][j+1]) +  //2nd Row\\n                       (grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]);    //3rd Row\\n                maxSum = Math.max(maxSum,sum);\\n            }\\n        }\\n        return maxSum; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int maxSum =Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<rows-2; i++){\\n            for(int j=0; j<cols-2; j++){\\n                int sum = (grid[i][j] +grid[i][j+1]+ grid[i][j+2] ) + //1st Row\\n                           ( grid[i+1][j+1]) +  //2nd Row\\n                       (grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]);    //3rd Row\\n                maxSum = Math.max(maxSum,sum);\\n            }\\n        }\\n        return maxSum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831768,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max=0;\\n        int sum=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[i].length-2;j++){\\n                sum = grid[i][j]+grid[i+2][j]+grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]+grid[i][j+2]+grid[i+2][j+2];\\n                if(sum>max){\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max=0;\\n        int sum=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[i].length-2;j++){\\n                sum = grid[i][j]+grid[i+2][j]+grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]+grid[i][j+2]+grid[i+2][j+2];\\n                if(sum>max){\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830691,
                "title": "brute-force",
                "content": "# Intuition\\nwe can brute force it as it has to be 3*3 matrix maybe we can just brute force it\\n\\n# Approach\\nAs the HourGlass has to be contained in matrix we can be sure it will always be i-2(row) and j-2(column).\\nand after that we just add the sum and compare with result.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n       int result=0;\\n\\n       for(int i=0;i<grid.length-2;i++)\\n       {   \\n           \\n           for(int j=0;j<grid[i].length-2;j++)\\n           {\\n               int sum=0;\\n               //For the upper \\n               sum+=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n               //For the mid\\n               sum+=grid[i+1][j+1];\\n               //For the lower\\n               sum+=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n\\n               result=Math.max(result,sum);\\n           }\\n\\n       }\\n       return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n       int result=0;\\n\\n       for(int i=0;i<grid.length-2;i++)\\n       {   \\n           \\n           for(int j=0;j<grid[i].length-2;j++)\\n           {\\n               int sum=0;\\n               //For the upper \\n               sum+=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n               //For the mid\\n               sum+=grid[i+1][j+1];\\n               //For the lower\\n               sum+=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n\\n               result=Math.max(result,sum);\\n           }\\n\\n       }\\n       return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829653,
                "title": "rust-solution-dp-100-fast-with-explaination",
                "content": "# Intuition\\nSince we have to calculate the summation of a hourglass, and the shape is fixed, we can simply record the summation of each part within the hourglass.\\n\\n# Approach\\nI used two vectors, `sum3` and `center` to keep track of the summation of each part. The former stands for the summation of continuous 3 integers, and the latter stands for the summation of the center of the hourglass plus the corresponding upper part. Therefore, we can simply know the summation of the hourglass when reaching the lower right corner.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_sum(grid: Vec<Vec<i32>>) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut sum3: Vec<Vec<i32>> = vec![vec![0; n]; m];\\n        let mut center: Vec<Vec<i32>> = vec![vec![0; n]; m];\\n        let mut ans: i32 = 0;\\n        for j in 2..n {\\n            sum3[0][j] = grid[0][j] + grid[0][j - 1] + grid[0][j - 2];\\n        }\\n        for i in 1..m {\\n            for j in 1..n {\\n                if i>0 && j>=1 && j<=n-2{\\n                    center[i][j] = sum3[i-1][j+1] + grid[i][j];\\n                }\\n                if j >= 2 {\\n                    sum3[i][j] = grid[i][j] + grid[i][j - 1] + grid[i][j - 2];\\n                    if i >= 2 {\\n                        ans = ans.max(sum3[i][j] + center[i-1][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_sum(grid: Vec<Vec<i32>>) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut sum3: Vec<Vec<i32>> = vec![vec![0; n]; m];\\n        let mut center: Vec<Vec<i32>> = vec![vec![0; n]; m];\\n        let mut ans: i32 = 0;\\n        for j in 2..n {\\n            sum3[0][j] = grid[0][j] + grid[0][j - 1] + grid[0][j - 2];\\n        }\\n        for i in 1..m {\\n            for j in 1..n {\\n                if i>0 && j>=1 && j<=n-2{\\n                    center[i][j] = sum3[i-1][j+1] + grid[i][j];\\n                }\\n                if j >= 2 {\\n                    sum3[i][j] = grid[i][j] + grid[i][j - 1] + grid[i][j - 2];\\n                    if i >= 2 {\\n                        ans = ans.max(sum3[i][j] + center[i-1][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825911,
                "title": "python-prefix-sum",
                "content": "1: Calculate prefix matrix\\n2: For every prefix matrix sum pf[i][j] fetch only 3*3 matrix sum and compare with previous answer.\\n\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        pf = self.prefix_mat(grid)\\n        r, c = len(grid), len(grid[0])\\n        res = float(\\'-inf\\')\\n        for row in range(r):\\n            for col in range(c):\\n                if row >= 2 and col >= 2:\\n                    hg = pf[row][col] - grid[row - 1][col] - grid[row - 1][col - 2]\\n                    x,y = False, False\\n                    if row - 3 >= 0:\\n                        x = True\\n                        hg -=  pf[row - 3][col]\\n                    if col - 3 >= 0:\\n                        y = True\\n                        hg -= pf[row][col - 3]\\n\\n                    if x and y:\\n                        hg += pf[row - 3][col - 3]\\n                    res = max(hg, res)\\n\\n        return res\\n\\n    def prefix_mat(self, mat):\\n        r, c = len(mat), len(mat[0])\\n        grid = [[0 for i in range(c)] for j in range(r)]\\n\\n        for j in range(c):\\n            if j > 0:\\n                grid[0][j] = mat[0][j] + grid[0][j - 1]\\n            else:\\n                grid[0][0] = mat[0][j]\\n\\n        for i in range(r):\\n            if i > 0:\\n                grid[i][0] = mat[i][0] + grid[i - 1][0]\\n            else:\\n                grid[i][0] = mat[i][0]\\n\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                grid[i][j] = mat[i][j] + grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]\\n\\n        return grid\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        pf = self.prefix_mat(grid)\\n        r, c = len(grid), len(grid[0])\\n        res = float(\\'-inf\\')\\n        for row in range(r):\\n            for col in range(c):\\n                if row >= 2 and col >= 2:\\n                    hg = pf[row][col] - grid[row - 1][col] - grid[row - 1][col - 2]\\n                    x,y = False, False\\n                    if row - 3 >= 0:\\n                        x = True\\n                        hg -=  pf[row - 3][col]\\n                    if col - 3 >= 0:\\n                        y = True\\n                        hg -= pf[row][col - 3]\\n\\n                    if x and y:\\n                        hg += pf[row - 3][col - 3]\\n                    res = max(hg, res)\\n\\n        return res\\n\\n    def prefix_mat(self, mat):\\n        r, c = len(mat), len(mat[0])\\n        grid = [[0 for i in range(c)] for j in range(r)]\\n\\n        for j in range(c):\\n            if j > 0:\\n                grid[0][j] = mat[0][j] + grid[0][j - 1]\\n            else:\\n                grid[0][0] = mat[0][j]\\n\\n        for i in range(r):\\n            if i > 0:\\n                grid[i][0] = mat[i][0] + grid[i - 1][0]\\n            else:\\n                grid[i][0] = mat[i][0]\\n\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                grid[i][j] = mat[i][j] + grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]\\n\\n        return grid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824352,
                "title": "java-solution-easy-to-understand-beats-95-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ngo on Every block and find the pattern sum and take max from the ans. because the size of array is small thats why its ok\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        int n = grid[0].length;\\n        int m = grid.length;\\n\\n\\n         // run array till n-3 and m-3 only\\n        for(int i=0; i<=m-3; i++) {\\n            for(int j=0; j<=n-3; j++) max = Math.max(sum(i,j,grid),max);\\n        }\\n\\n        return max;\\n    }\\n\\n\\n\\n\\n\\n \\n   // Function to check the pattern sum //\\n    public static int sum(int row, int col, int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int sum = 0;\\n \\n        for(int i=col; i<(col+3); i++) sum += grid[row][i];\\n        sum += grid[row+1][col+1];\\n        for(int i=col; i<(col+3); i++)  sum += grid[row+2][i];\\n        \\n        return sum;\\n    }\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        int n = grid[0].length;\\n        int m = grid.length;\\n\\n\\n         // run array till n-3 and m-3 only\\n        for(int i=0; i<=m-3; i++) {\\n            for(int j=0; j<=n-3; j++) max = Math.max(sum(i,j,grid),max);\\n        }\\n\\n        return max;\\n    }\\n\\n\\n\\n\\n\\n \\n   // Function to check the pattern sum //\\n    public static int sum(int row, int col, int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int sum = 0;\\n \\n        for(int i=col; i<(col+3); i++) sum += grid[row][i];\\n        sum += grid[row+1][col+1];\\n        for(int i=col; i<(col+3); i++)  sum += grid[row+2][i];\\n        \\n        return sum;\\n    }\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806813,
                "title": "python-solution-using-fft-based-convolution",
                "content": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        import numpy as np\\n        import scipy\\n        import scipy.signal\\n        from scipy.signal import fftconvolve\\n\\n        kernel = [[1, 1, 1], [0, 1, 0], [1, 1, 1]]\\n        res = fftconvolve(grid, kernel, mode = \\'valid\\').flat\\n        res = np.array(res)\\n        res = res.round()\\n        res = res.astype(int)\\n        return res.max()\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        import numpy as np\\n        import scipy\\n        import scipy.signal\\n        from scipy.signal import fftconvolve\\n\\n        kernel = [[1, 1, 1], [0, 1, 0], [1, 1, 1]]\\n        res = fftconvolve(grid, kernel, mode = \\'valid\\').flat\\n        res = np.array(res)\\n        res = res.round()\\n        res = res.astype(int)\\n        return res.max()\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805346,
                "title": "ek-number-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n            int m = grid.length;\\n    int n = grid[0].length;\\n    int ans = Integer.MIN_VALUE;\\n    for(int i =0;i<m;i++){\\n      for(int j =0;j<n;j++){\\n        if(i>=1 && i<=m-2 && j>=1 && j<=n-2){\\n          int mastSum = grid[i][j] +grid[i][j-1] +grid[i][j+1] + grid[i-1][j] + grid[i-1][j-1] + grid[i-1][j+1] +  grid[i+1][j] + grid[i+1][j-1] + grid[i+1][j+1];\\n                  ans = Math.max(ans , Math.max(mastSum-grid[i][j-1] -grid[i][j+1] , -47748484));\\n        }\\n      }\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n            int m = grid.length;\\n    int n = grid[0].length;\\n    int ans = Integer.MIN_VALUE;\\n    for(int i =0;i<m;i++){\\n      for(int j =0;j<n;j++){\\n        if(i>=1 && i<=m-2 && j>=1 && j<=n-2){\\n          int mastSum = grid[i][j] +grid[i][j-1] +grid[i][j+1] + grid[i-1][j] + grid[i-1][j-1] + grid[i-1][j+1] +  grid[i+1][j] + grid[i+1][j-1] + grid[i+1][j+1];\\n                  ans = Math.max(ans , Math.max(mastSum-grid[i][j-1] -grid[i][j+1] , -47748484));\\n        }\\n      }\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738623,
                "title": "typescript-solution-beats-speed-100-memory-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^4)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfunction maxSum(grid: number[][]): number {\\n    let rows: number = grid.length;\\n    let columns: number = grid[0].length;\\n    let hourGlass: number[][] = [[1,1,1],[0,1,0],[1,1,1]];\\n    let rowsHourGlass: number = hourGlass.length;\\n    let colsHourGlass: number = hourGlass[0].length;\\n\\n    let maxResult: number = 0;\\n    for(let i=0; i<rows; i++) {\\n        if (i + rowsHourGlass > rows) \\n            break;\\n        for(let j=0; j<columns; j++) {\\n            if (j + colsHourGlass > columns)\\n                break; \\n            let sum: number = 0;\\n            for(let u: number =0; u < 3; u++) {\\n                for(let v: number=0; v< 3; v++) {\\n                    sum += grid[i+u][j+v] * hourGlass[u][v]\\n                }\\n            }\\n            maxResult = Math.max(maxResult, sum);            \\n        }\\n    }\\n    return maxResult;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxSum(grid: number[][]): number {\\n    let rows: number = grid.length;\\n    let columns: number = grid[0].length;\\n    let hourGlass: number[][] = [[1,1,1],[0,1,0],[1,1,1]];\\n    let rowsHourGlass: number = hourGlass.length;\\n    let colsHourGlass: number = hourGlass[0].length;\\n\\n    let maxResult: number = 0;\\n    for(let i=0; i<rows; i++) {\\n        if (i + rowsHourGlass > rows) \\n            break;\\n        for(let j=0; j<columns; j++) {\\n            if (j + colsHourGlass > columns)\\n                break; \\n            let sum: number = 0;\\n            for(let u: number =0; u < 3; u++) {\\n                for(let v: number=0; v< 3; v++) {\\n                    sum += grid[i+u][j+v] * hourGlass[u][v]\\n                }\\n            }\\n            maxResult = Math.max(maxResult, sum);            \\n        }\\n    }\\n    return maxResult;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728393,
                "title": "simple-solution-memo-246ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we try work with a special row and col layout, we can precalculate the overlaying rows to simplify the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst memorize the sum of [i, j, k], naive approaches may recalculate them multiple times. This could be probably be done even more optimal when just adding the next and substrating the first value of the triplet.\\n\\nOnce that\\'s done just loop through the grid, use the memorized values to check the current sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2mn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2mn)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) < 3 or (len(grid[0]) < 3):\\n            return 0\\n        \\n        cache: List[List[int]] = []\\n        for i in range(len(grid)):\\n            row = []\\n            for j in range(2, len(grid[0])):\\n                # could also make this a bit more optimal\\n                val = sum([grid[i][j-2], grid[i][j-1],grid[i][j]])\\n                row.append(val)\\n            cache.append(row)\\n\\n        ans = 0\\n        for i in range(1, len(grid)-1):\\n            for j in range(1, len(grid[i]) - 1):\\n                tmp = grid[i][j] + cache[i-1][j-1] + cache[i+1][j-1]\\n                if tmp > ans:\\n                    ans = tmp\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) < 3 or (len(grid[0]) < 3):\\n            return 0\\n        \\n        cache: List[List[int]] = []\\n        for i in range(len(grid)):\\n            row = []\\n            for j in range(2, len(grid[0])):\\n                # could also make this a bit more optimal\\n                val = sum([grid[i][j-2], grid[i][j-1],grid[i][j]])\\n                row.append(val)\\n            cache.append(row)\\n\\n        ans = 0\\n        for i in range(1, len(grid)-1):\\n            for j in range(1, len(grid[i]) - 1):\\n                tmp = grid[i][j] + cache[i-1][j-1] + cache[i+1][j-1]\\n                if tmp > ans:\\n                    ans = tmp\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726455,
                "title": "python-reuse-row-sum-beats-100-submission",
                "content": "# Intuition\\nGenerate a grid of hourglass to find the maximum value. And try to optimize the bruteforce. \\n\\n# Approach\\nSince all 3 values in row $0^{th}$ and row $2^{nd}$ are included in the hourglass pattern, we can calculate the sum of each 3 continuous value in a row, and store them in another list to reuse when constructing the hourglass grid.\\nCode explanation:\\n- `row_sum` is the list of sum of 3 continuous value. `row_sum[i][j]` = `grid[i][j-1]` + `grid[i][j]` + `grid[i][j+1]`\\n- in the second for loop, `total` is the sum of the hourglass, where index `i`, `j` denote the center of the hourglass in the grid\\n\\n# Complexity\\n- Time complexity:\\nO(mxn)\\n\\n- Space complexity:\\nO(mxn)\\n\\n# Code\\n```\\n# Solution by Long Truong\\n\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        row_sum = []\\n        for i in range(m):\\n            row = []\\n            for j in range(1,n-1):\\n                total = grid[i][j-1] + grid[i][j] + grid[i][j+1]\\n                row.append(total)\\n            row_sum.append(row)\\n        \\n        result = -1\\n        for i in range(1,m-1):\\n            for j in range(1,n-1):\\n                total = row_sum[i-1][j-1] + row_sum[i+1][j-1] + grid[i][j]\\n                if total > result:\\n                    result = total\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Solution by Long Truong\\n\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        row_sum = []\\n        for i in range(m):\\n            row = []\\n            for j in range(1,n-1):\\n                total = grid[i][j-1] + grid[i][j] + grid[i][j+1]\\n                row.append(total)\\n            row_sum.append(row)\\n        \\n        result = -1\\n        for i in range(1,m-1):\\n            for j in range(1,n-1):\\n                total = row_sum[i-1][j-1] + row_sum[i+1][j-1] + grid[i][j]\\n                if total > result:\\n                    result = total\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722281,
                "title": "simple-brute-force-implementation-low-constraints",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxcurrSum(vector<vector<int>>& g) {\\n        int m = g.size(), n = g[0].size();\\n        int currSum = 0, maxcurrSum = INT_MIN;\\n        for(int i=0; i+2<m; i++)\\n        {\\n            currSum = 0;\\n            for(int j=0; j+2<n; j++)\\n            { //currSum represents sum of a hourglass\\n               currSum = g[i][j]   + g[i][j+1]   + g[i][j+2]\\n                                   + g[i+1][j+1]\\n                       + g[i+2][j] + g[i+2][j+1] + g[i+2][j+2];\\n            maxcurrSum = max(maxcurrSum,currSum); //keep track of maximum hourglass sum\\n            }\\n        }\\n        return maxcurrSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxcurrSum(vector<vector<int>>& g) {\\n        int m = g.size(), n = g[0].size();\\n        int currSum = 0, maxcurrSum = INT_MIN;\\n        for(int i=0; i+2<m; i++)\\n        {\\n            currSum = 0;\\n            for(int j=0; j+2<n; j++)\\n            { //currSum represents sum of a hourglass\\n               currSum = g[i][j]   + g[i][j+1]   + g[i][j+2]\\n                                   + g[i+1][j+1]\\n                       + g[i+2][j] + g[i+2][j+1] + g[i+2][j+2];\\n            maxcurrSum = max(maxcurrSum,currSum); //keep track of maximum hourglass sum\\n            }\\n        }\\n        return maxcurrSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720343,
                "title": "easiest-c-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=0;j<m-2;j++){\\n                ans=max(ans,(grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=0;j<m-2;j++){\\n                ans=max(ans,(grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716559,
                "title": "c-easy-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        long long int mx=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2<m && j+2<n)\\n                {\\n                    long long int s=0;\\n                    for(int x=i;x<i+3;x++)\\n                    for(int y=j;y<j+3;y++)\\n                     s+=g[x][y];\\n\\n                     s=s-g[i+1][j]-g[i+1][j+2];\\n                     mx=max(mx,s);\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        long long int mx=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2<m && j+2<n)\\n                {\\n                    long long int s=0;\\n                    for(int x=i;x<i+3;x++)\\n                    for(int y=j;y<j+3;y++)\\n                     s+=g[x][y];\\n\\n                     s=s-g[i+1][j]-g[i+1][j+2];\\n                     mx=max(mx,s);\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714025,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int maxi = -1e9;\\n        for (int i=0 ; i<m-2 ; i++){\\n            for (int j=0 ; j<n-2 ; j++){\\n                int sum = 0;\\n                for (int k=0 ; k<3 ; k++){\\n                    sum += grid[i][j+k];\\n                    sum += grid[i+2][j+k];\\n                }\\n                sum += grid[i+1][j+1];\\n                maxi = max(maxi , sum);\\n            }\\n        }    \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int maxi = -1e9;\\n        for (int i=0 ; i<m-2 ; i++){\\n            for (int j=0 ; j<n-2 ; j++){\\n                int sum = 0;\\n                for (int k=0 ; k<3 ; k++){\\n                    sum += grid[i][j+k];\\n                    sum += grid[i+2][j+k];\\n                }\\n                sum += grid[i+1][j+1];\\n                maxi = max(maxi , sum);\\n            }\\n        }    \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669101,
                "title": "python3-brute-force-horizontal-optimization",
                "content": "```\\nimport gc\\ngc.disable()\\n\\nclass Solution:\\n  # brute force\\n  def maxSum(self, grid: List[List[int]]) -> int:\\n    max_sum = float(\"-inf\")\\n    for m in range(len(grid) - 2):\\n      for n in range(len(grid[0]) - 2):\\n        curr_sum = sum([*grid[m][n:n+3], grid[m+1][n+1], *grid[m+2][n:n+3]])\\n        max_sum = max(max_sum, curr_sum)\\n    return max_sum\\n\\n  # horizontal sliding optimization\\n  def maxSum(self, grid: List[List[int]]) -> int:\\n    max_sum = float(\"-inf\")\\n    prev_sum = None\\n    prev_start_row = 0\\n\\n    for m in range(len(grid) - 2):\\n      for n in range(len(grid[0]) - 2):\\n        if prev_sum:\\n          if prev_start_row == m:\\n            # remove elements outside of the current mask position\\n            curr_sum = prev_sum - grid[m][n-1]\\n            curr_sum -= grid[m+1][n]\\n            curr_sum -= grid[m+2][n-1]\\n            # add new elements that underneath the mask\\n            curr_sum += grid[m][n+2]\\n            curr_sum += grid[m+1][n+1]\\n            curr_sum += grid[m+2][n+2]\\n          else:\\n            curr_sum = sum([*grid[m][n:n+3], grid[m+1][n+1], *grid[m+2][n:n+3]])\\n            prev_start_row = m\\n        else:\\n          curr_sum = sum([*grid[m][n:n+3], grid[m+1][n+1], *grid[m+2][n:n+3]])\\n        prev_sum = curr_sum\\n        max_sum = max(max_sum, curr_sum)\\n    return max_sum\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nimport gc\\ngc.disable()\\n\\nclass Solution:\\n  # brute force\\n  def maxSum(self, grid: List[List[int]]) -> int:\\n    max_sum = float(\"-inf\")\\n    for m in range(len(grid) - 2):\\n      for n in range(len(grid[0]) - 2):\\n        curr_sum = sum([*grid[m][n:n+3], grid[m+1][n+1], *grid[m+2][n:n+3]])\\n        max_sum = max(max_sum, curr_sum)\\n    return max_sum\\n\\n  # horizontal sliding optimization\\n  def maxSum(self, grid: List[List[int]]) -> int:\\n    max_sum = float(\"-inf\")\\n    prev_sum = None\\n    prev_start_row = 0\\n\\n    for m in range(len(grid) - 2):\\n      for n in range(len(grid[0]) - 2):\\n        if prev_sum:\\n          if prev_start_row == m:\\n            # remove elements outside of the current mask position\\n            curr_sum = prev_sum - grid[m][n-1]\\n            curr_sum -= grid[m+1][n]\\n            curr_sum -= grid[m+2][n-1]\\n            # add new elements that underneath the mask\\n            curr_sum += grid[m][n+2]\\n            curr_sum += grid[m+1][n+1]\\n            curr_sum += grid[m+2][n+2]\\n          else:\\n            curr_sum = sum([*grid[m][n:n+3], grid[m+1][n+1], *grid[m+2][n:n+3]])\\n            prev_start_row = m\\n        else:\\n          curr_sum = sum([*grid[m][n:n+3], grid[m+1][n+1], *grid[m+2][n:n+3]])\\n        prev_sum = curr_sum\\n        max_sum = max(max_sum, curr_sum)\\n    return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668547,
                "title": "c-sliding-window",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 1; i < grid.size() - 1; i++) {\\n            int sum = 0;\\n            for(int i1 = i-1; i1 <= i+1; i1++) {\\n                for(int j1 = 0; j1 < 3; j1++) {\\n                    sum += grid[i1][j1];\\n                }\\n            }\\n            ans = max(ans, sum - grid[i][0] - grid[i][2]);\\n            for(int j = 3; j < grid[0].size(); j++) {\\n                sum -= grid[i-1][j-3] + grid[i][j-3] + grid[i+1][j-3];\\n                sum += grid[i-1][j] + grid[i][j] + grid[i+1][j];\\n                ans = max(ans, sum - grid[i][j-2] - grid[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 1; i < grid.size() - 1; i++) {\\n            int sum = 0;\\n            for(int i1 = i-1; i1 <= i+1; i1++) {\\n                for(int j1 = 0; j1 < 3; j1++) {\\n                    sum += grid[i1][j1];\\n                }\\n            }\\n            ans = max(ans, sum - grid[i][0] - grid[i][2]);\\n            for(int j = 3; j < grid[0].size(); j++) {\\n                sum -= grid[i-1][j-3] + grid[i][j-3] + grid[i+1][j-3];\\n                sum += grid[i-1][j] + grid[i][j] + grid[i+1][j];\\n                ans = max(ans, sum - grid[i][j-2] - grid[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658212,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n\\n        ans = 0\\n\\n        def calc(i, j):\\n            if not(0 <= i - 1 < M and 0 <= i + 1 < M and 0 <= j + 1 < N and 0 <= j - 1 < N):\\n                return 0\\n                \\n            return (grid[i][j] + grid[i - 1][j] + \\ngrid[i + 1][j] + grid[i + 1][j + 1] + grid[i - 1][j - 1] + grid[i - 1][j + 1] + grid[i + 1][j - 1])\\n\\n\\n\\n\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                ans = max(ans, calc(i, j))\\n\\n        return ans\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n\\n        ans = 0\\n\\n        def calc(i, j):\\n            if not(0 <= i - 1 < M and 0 <= i + 1 < M and 0 <= j + 1 < N and 0 <= j - 1 < N):\\n                return 0\\n                \\n            return (grid[i][j] + grid[i - 1][j] + \\ngrid[i + 1][j] + grid[i + 1][j + 1] + grid[i - 1][j - 1] + grid[i - 1][j + 1] + grid[i + 1][j - 1])\\n\\n\\n\\n\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                ans = max(ans, calc(i, j))\\n\\n        return ans\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657909,
                "title": "go-iteration-over-all-elements",
                "content": "# Code\\n```\\nfunc hourglassOrDefault(grid [][]int, ai, aj int, dflt int) int {\\n\\tif ai+2 >= len(grid) || aj+2 >= len(grid[ai]) {\\n\\t\\treturn dflt\\n\\t}\\n\\n\\treturn grid[ai][aj] + grid[ai][aj+1] + grid[ai][aj+2] + grid[ai+1][aj+1] + grid[ai+2][aj] + grid[ai+2][aj+1] + grid[ai+2][aj+2]\\n}\\n\\nfunc maxSum(grid [][]int) int {\\n\\tma := math.MinInt\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[i]); j++ {\\n\\t\\t\\tsum := hourglassOrDefault(grid, i, j, math.MinInt)\\n\\t\\t\\tif sum > ma {\\n\\t\\t\\t\\tma = sum\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ma\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hourglassOrDefault(grid [][]int, ai, aj int, dflt int) int {\\n\\tif ai+2 >= len(grid) || aj+2 >= len(grid[ai]) {\\n\\t\\treturn dflt\\n\\t}\\n\\n\\treturn grid[ai][aj] + grid[ai][aj+1] + grid[ai][aj+2] + grid[ai+1][aj+1] + grid[ai+2][aj] + grid[ai+2][aj+1] + grid[ai+2][aj+2]\\n}\\n\\nfunc maxSum(grid [][]int) int {\\n\\tma := math.MinInt\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[i]); j++ {\\n\\t\\t\\tsum := hourglassOrDefault(grid, i, j, math.MinInt)\\n\\t\\t\\tif sum > ma {\\n\\t\\t\\t\\tma = sum\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ma\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657908,
                "title": "go-iteration-over-all-elements",
                "content": "# Code\\n```\\nfunc hourglassOrDefault(grid [][]int, ai, aj int, dflt int) int {\\n\\tif ai+2 >= len(grid) || aj+2 >= len(grid[ai]) {\\n\\t\\treturn dflt\\n\\t}\\n\\n\\treturn grid[ai][aj] + grid[ai][aj+1] + grid[ai][aj+2] + grid[ai+1][aj+1] + grid[ai+2][aj] + grid[ai+2][aj+1] + grid[ai+2][aj+2]\\n}\\n\\nfunc maxSum(grid [][]int) int {\\n\\tma := math.MinInt\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[i]); j++ {\\n\\t\\t\\tsum := hourglassOrDefault(grid, i, j, math.MinInt)\\n\\t\\t\\tif sum > ma {\\n\\t\\t\\t\\tma = sum\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ma\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hourglassOrDefault(grid [][]int, ai, aj int, dflt int) int {\\n\\tif ai+2 >= len(grid) || aj+2 >= len(grid[ai]) {\\n\\t\\treturn dflt\\n\\t}\\n\\n\\treturn grid[ai][aj] + grid[ai][aj+1] + grid[ai][aj+2] + grid[ai+1][aj+1] + grid[ai+2][aj] + grid[ai+2][aj+1] + grid[ai+2][aj+2]\\n}\\n\\nfunc maxSum(grid [][]int) int {\\n\\tma := math.MinInt\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[i]); j++ {\\n\\t\\t\\tsum := hourglassOrDefault(grid, i, j, math.MinInt)\\n\\t\\t\\tif sum > ma {\\n\\t\\t\\t\\tma = sum\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ma\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3654971,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        int r1=0,r2=0;\\n        int d=grid[i+1][j+1];\\n        for(int k=0;k<3;k++){\\n            r1=r1+grid[i][j+k];\\n            r2=r2+grid[i+2][j+k];\\n        }\\n        return d+r1+r2;\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if((i+3)<=n&&(j+3)<=m){\\n                    ans=max(ans,solve(grid,i,j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        int r1=0,r2=0;\\n        int d=grid[i+1][j+1];\\n        for(int k=0;k<3;k++){\\n            r1=r1+grid[i][j+k];\\n            r2=r2+grid[i+2][j+k];\\n        }\\n        return d+r1+r2;\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if((i+3)<=n&&(j+3)<=m){\\n                    ans=max(ans,solve(grid,i,j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653371,
                "title": "maximum-sum-of-an-hourglass",
                "content": "SIMPLE APPROACH\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        \\n       int r=grid.size();\\n       int c=grid[0].size();\\n       int sum=0,ans=INT_MIN;\\n       for(int i=0;i<r;i++)\\n       {\\n           if(i==r-2)\\n           break;\\n           for(int j=0;j<c;j++)\\n           {\\n               sum=0;\\n               if(i+2<r && j+2<c)\\n               {\\n                   sum=sum+grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1] +grid[i+2][j+2];\\n                   ans=max(ans,sum);\\n               }\\n               else\\n               break;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        \\n       int r=grid.size();\\n       int c=grid[0].size();\\n       int sum=0,ans=INT_MIN;\\n       for(int i=0;i<r;i++)\\n       {\\n           if(i==r-2)\\n           break;\\n           for(int j=0;j<c;j++)\\n           {\\n               sum=0;\\n               if(i+2<r && j+2<c)\\n               {\\n                   sum=sum+grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1] +grid[i+2][j+2];\\n                   ans=max(ans,sum);\\n               }\\n               else\\n               break;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646900,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*7)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        for(int i=0; i<grid.length-2; i++){\\n            for(int j=0; j<grid[0].length-2; j++){\\n                int sum = 0;\\n                sum+=grid[i][j];\\n                sum+=grid[i][j+1];\\n                sum+=grid[i][j+2];\\n                sum+=grid[i+1][j+1];\\n                sum+=grid[i+2][j];\\n                sum+=grid[i+2][j+1];\\n                sum+=grid[i+2][j+2];\\n                max = Math.max(max,sum);\\n            }\\n        }       \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        for(int i=0; i<grid.length-2; i++){\\n            for(int j=0; j<grid[0].length-2; j++){\\n                int sum = 0;\\n                sum+=grid[i][j];\\n                sum+=grid[i][j+1];\\n                sum+=grid[i][j+2];\\n                sum+=grid[i+1][j+1];\\n                sum+=grid[i+2][j];\\n                sum+=grid[i+2][j+1];\\n                sum+=grid[i+2][j+2];\\n                max = Math.max(max,sum);\\n            }\\n        }       \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640268,
                "title": "c-simple-and-efficient-using-for-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans=0;\\n         int max=INT_MIN;\\n\\n        for(int i=0;i<grid.size()-2;i++){\\n            for(int j=0;j<grid[0].size()-2;j++){\\n                ans+=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                ans+=grid[i+1][j+1];\\n                ans+=grid[i+2][j]+grid[i+2][j+1]+ grid[i+2][j+2];\\n                if(ans>max){\\n                    max=ans;\\n                }\\n                ans=0;\\n        }\\n        \\n        }\\n    \\n        return max;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans=0;\\n         int max=INT_MIN;\\n\\n        for(int i=0;i<grid.size()-2;i++){\\n            for(int j=0;j<grid[0].size()-2;j++){\\n                ans+=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                ans+=grid[i+1][j+1];\\n                ans+=grid[i+2][j]+grid[i+2][j+1]+ grid[i+2][j+2];\\n                if(ans>max){\\n                    max=ans;\\n                }\\n                ans=0;\\n        }\\n        \\n        }\\n    \\n        return max;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632510,
                "title": "easy-c-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int sum, maxi=0;\\n        for(int i=0;i<grid.size()-2;i++)  // traverse the rows\\n        {\\n            for(int j=0;j<grid[0].size()-2;j++) //traverse columns\\n            { \\n                // finding equivalent sum  \\n                sum=grid[i][j]+grid[i][j+1]+grid[i][j+2] +grid[i+1][j+1]+\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]; \\n                // maximum sum\\n                maxi=max(maxi,sum); \\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int sum, maxi=0;\\n        for(int i=0;i<grid.size()-2;i++)  // traverse the rows\\n        {\\n            for(int j=0;j<grid[0].size()-2;j++) //traverse columns\\n            { \\n                // finding equivalent sum  \\n                sum=grid[i][j]+grid[i][j+1]+grid[i][j+2] +grid[i+1][j+1]+\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]; \\n                // maximum sum\\n                maxi=max(maxi,sum); \\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585106,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max=0;\\n        for(int i=0; i<grid.length-2; i++) {\\n            for(int j=0; j<grid[i].length-2; j++) {\\n                int tmp=0;\\n                tmp+=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                tmp+=grid[i+1][j+1];\\n                tmp+=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(tmp>max) max=tmp;\\n            }    \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max=0;\\n        for(int i=0; i<grid.length-2; i++) {\\n            for(int j=0; j<grid[i].length-2; j++) {\\n                int tmp=0;\\n                tmp+=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                tmp+=grid[i+1][j+1];\\n                tmp+=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(tmp>max) max=tmp;\\n            }    \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568429,
                "title": "c-using-for-loop",
                "content": "# Code\\n```\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n\\nclass Solution final\\n{\\npublic:\\n\\tauto maxSum(std::vector<std::vector<int>> const& grid) const noexcept -> int\\n\\t{\\n\\t\\tauto const row_count = std::size(grid);\\n\\t\\tauto const col_count = std::size(grid.front());\\n\\n\\t\\tauto result = 0;\\n\\t\\tfor (size_t r = 0; r < row_count - 2; ++r) {\\n\\t\\t\\tfor (size_t c = 0; c < col_count - 2; ++c) {\\n\\t\\t\\t\\tauto const sum = grid[r + 0][c] + grid[r + 0][c + 1] + grid[r + 0][c + 2] +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\t  grid[r + 1][c + 1] +\\n\\t\\t\\t\\t\\t\\t   \\t\\t grid[r + 2][c] + grid[r + 2][c + 1] + grid[r + 2][c + 2];\\n\\t\\t\\t\\tresult = std::max(result, sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n\\nclass Solution final\\n{\\npublic:\\n\\tauto maxSum(std::vector<std::vector<int>> const& grid) const noexcept -> int\\n\\t{\\n\\t\\tauto const row_count = std::size(grid);\\n\\t\\tauto const col_count = std::size(grid.front());\\n\\n\\t\\tauto result = 0;\\n\\t\\tfor (size_t r = 0; r < row_count - 2; ++r) {\\n\\t\\t\\tfor (size_t c = 0; c < col_count - 2; ++c) {\\n\\t\\t\\t\\tauto const sum = grid[r + 0][c] + grid[r + 0][c + 1] + grid[r + 0][c + 2] +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\t  grid[r + 1][c + 1] +\\n\\t\\t\\t\\t\\t\\t   \\t\\t grid[r + 2][c] + grid[r + 2][c + 1] + grid[r + 2][c + 2];\\n\\t\\t\\t\\tresult = std::max(result, sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3568428,
                "title": "c-using-for-loop",
                "content": "# Code\\n```\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n\\nclass Solution final\\n{\\npublic:\\n\\tauto maxSum(std::vector<std::vector<int>> const& grid) const noexcept -> int\\n\\t{\\n\\t\\tauto const row_count = std::size(grid);\\n\\t\\tauto const col_count = std::size(grid.front());\\n\\n\\t\\tauto result = 0;\\n\\t\\tfor (size_t r = 0; r < row_count - 2; ++r) {\\n\\t\\t\\tfor (size_t c = 0; c < col_count - 2; ++c) {\\n\\t\\t\\t\\tauto const sum = grid[r + 0][c] + grid[r + 0][c + 1] + grid[r + 0][c + 2] +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\t  grid[r + 1][c + 1] +\\n\\t\\t\\t\\t\\t\\t   \\t\\t grid[r + 2][c] + grid[r + 2][c + 1] + grid[r + 2][c + 2];\\n\\t\\t\\t\\tresult = std::max(result, sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n\\nclass Solution final\\n{\\npublic:\\n\\tauto maxSum(std::vector<std::vector<int>> const& grid) const noexcept -> int\\n\\t{\\n\\t\\tauto const row_count = std::size(grid);\\n\\t\\tauto const col_count = std::size(grid.front());\\n\\n\\t\\tauto result = 0;\\n\\t\\tfor (size_t r = 0; r < row_count - 2; ++r) {\\n\\t\\t\\tfor (size_t c = 0; c < col_count - 2; ++c) {\\n\\t\\t\\t\\tauto const sum = grid[r + 0][c] + grid[r + 0][c + 1] + grid[r + 0][c + 2] +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\t  grid[r + 1][c + 1] +\\n\\t\\t\\t\\t\\t\\t   \\t\\t grid[r + 2][c] + grid[r + 2][c + 1] + grid[r + 2][c + 2];\\n\\t\\t\\t\\tresult = std::max(result, sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3559366,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int i, j, sum=0, max=0;\\n        for(i=0 ; i<grid.size()-2 ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size()-2 ; j++)\\n            {\\n                sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max)\\n                {\\n                    max = sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int i, j, sum=0, max=0;\\n        for(i=0 ; i<grid.size()-2 ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size()-2 ; j++)\\n            {\\n                sum = grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                if(sum>max)\\n                {\\n                    max = sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525436,
                "title": "simple-python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        res=0\\n        for i in range(1,len(grid)-1):\\n            for j in range(1,len(grid[i])-1):\\n                if grid[i][j]+grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]>res:\\n                    res=grid[i][j]+grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        res=0\\n        for i in range(1,len(grid)-1):\\n            for j in range(1,len(grid[i])-1):\\n                if grid[i][j]+grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]>res:\\n                    res=grid[i][j]+grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517871,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for (int i = 0; i < m - 2; i++) {\\n            for (int j = 0; j < n - 2; j++) {\\n                int a = grid[i][j];\\n                int b = grid[i][j + 1];\\n                int c = grid[i][j + 2];\\n\\n                int mid = grid[i + 1][j + 1];\\n                int d = grid[i + 2][j];\\n                int e = grid[i + 2][j + 1];\\n                int f = grid[i + 2][j + 2];\\n\\n                int tot = a + b + c + mid + d + e + f;\\n                ans = Math.max(ans, tot);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for (int i = 0; i < m - 2; i++) {\\n            for (int j = 0; j < n - 2; j++) {\\n                int a = grid[i][j];\\n                int b = grid[i][j + 1];\\n                int c = grid[i][j + 2];\\n\\n                int mid = grid[i + 1][j + 1];\\n                int d = grid[i + 2][j];\\n                int e = grid[i + 2][j + 1];\\n                int f = grid[i + 2][j + 2];\\n\\n                int tot = a + b + c + mid + d + e + f;\\n                ans = Math.max(ans, tot);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509850,
                "title": "cpp-solution-brute-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int maxi=INT_MIN;\\n        for(int i=1;i<m-1;i++){\\n            for(int j=1;j<n-1;j++){\\n                maxi=max(maxi,grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i][j]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int maxi=INT_MIN;\\n        for(int i=1;i<m-1;i++){\\n            for(int j=1;j<n-1;j++){\\n                maxi=max(maxi,grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1]+grid[i][j]+grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506834,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        for(int i = 1; i < n-1;i++){\\n            for(int j = 1; j < m-1;j++){\\n                int sum = 0;\\n                \\n                sum += grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1];\\n                sum += grid[i][j];\\n                sum += grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1];\\n                \\n                ans = Math.max(sum,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        for(int i = 1; i < n-1;i++){\\n            for(int j = 1; j < m-1;j++){\\n                int sum = 0;\\n                \\n                sum += grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1];\\n                sum += grid[i][j];\\n                sum += grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1];\\n                \\n                ans = Math.max(sum,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504466,
                "title": "easy-to-understand-beats-97-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n\\n        \\n        int max=0;\\n        \\n        int sum;\\n        if(grid.length==3&&grid[0].length==3){\\n            sum=0;\\n            for(int i=0;i<3;i++){\\n                sum+=grid[0][i];\\n                sum+=grid[2][i];\\n            }\\n            sum+=grid[1][1];\\n            return sum;\\n        }\\n        \\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[i].length-1;j++){\\n                sum=0;\\n                for(int h=j;h<j+3&&h<grid[i].length;h++){\\n                    sum+=grid[i][h];\\n                    sum+=grid[i+2][h];\\n                }\\n                sum+=grid[i+1][j+1];\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n\\n        \\n        int max=0;\\n        \\n        int sum;\\n        if(grid.length==3&&grid[0].length==3){\\n            sum=0;\\n            for(int i=0;i<3;i++){\\n                sum+=grid[0][i];\\n                sum+=grid[2][i];\\n            }\\n            sum+=grid[1][1];\\n            return sum;\\n        }\\n        \\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[i].length-1;j++){\\n                sum=0;\\n                for(int h=j;h<j+3&&h<grid[i].length;h++){\\n                    sum+=grid[i][h];\\n                    sum+=grid[i+2][h];\\n                }\\n                sum+=grid[i+1][j+1];\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495336,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int sum = 0;\\n        // calculate the first sum.\\n//        sum = grid[0][0] + grid[0][1] + grid[0][2] + grid[1][0] + grid[1][1] + grid[1][2] + grid[1][1];\\n        int maxSum = sum;\\n        // slide the window\\n        for (int i = 0; i < grid.length - 2; i++){\\n            for (int j = 0; j < grid[i].length - 2; j++) {\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] + grid[i+1][j+1];\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int sum = 0;\\n        // calculate the first sum.\\n//        sum = grid[0][0] + grid[0][1] + grid[0][2] + grid[1][0] + grid[1][1] + grid[1][2] + grid[1][1];\\n        int maxSum = sum;\\n        // slide the window\\n        for (int i = 0; i < grid.length - 2; i++){\\n            for (int j = 0; j < grid[i].length - 2; j++) {\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] + grid[i+1][j+1];\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493734,
                "title": "simple-java-solution-beats-90",
                "content": "# Code\\n```\\nclass Solution \\n{\\n    public int maxSum(int[][] grid) \\n    {\\n        int max = -1, sum = 0;\\n        for(int i = 0; i < grid.length-2; i++)\\n            for(int j = 0; j < grid[0].length-2; j++)\\n            {\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                max = sum > max ? sum : max;\\n            }    \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maxSum(int[][] grid) \\n    {\\n        int max = -1, sum = 0;\\n        for(int i = 0; i < grid.length-2; i++)\\n            for(int j = 0; j < grid[0].length-2; j++)\\n            {\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n                max = sum > max ? sum : max;\\n            }    \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490480,
                "title": "best-beginner-friendly-c-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->sum() function returns the sum of all elements in our 3*3 small grid excluding 2 unwanted elements.\\nOur actual loops are just iterating and checking for maximum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum(vector<vector<int>>& grid, int m, int n){\\n        int sum=0;\\n        for(int i=m-2; i<=m; i++){\\n            for(int j=n-2; j<=n; j++){\\n                sum+=grid[i][j];\\n            }\\n        }\\n        return sum-grid[m-1][n]-grid[m-1][n-2];\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int max=0;\\n        for(int i=2; i<grid.size(); i++){\\n            for(int j=2; j<grid[i].size(); j++){\\n                if(max< sum(grid,i,j) ){\\n                    max=sum(grid,i,j);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(vector<vector<int>>& grid, int m, int n){\\n        int sum=0;\\n        for(int i=m-2; i<=m; i++){\\n            for(int j=n-2; j<=n; j++){\\n                sum+=grid[i][j];\\n            }\\n        }\\n        return sum-grid[m-1][n]-grid[m-1][n-2];\\n    }\\n    int maxSum(vector<vector<int>>& grid) {\\n        int max=0;\\n        for(int i=2; i<grid.size(); i++){\\n            for(int j=2; j<grid[i].size(); j++){\\n                if(max< sum(grid,i,j) ){\\n                    max=sum(grid,i,j);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490319,
                "title": "maximum-sum-of-an-hourglass-c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = INT_MIN;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            for(int j=0; j<m-2; j++)\\n            {\\n              \\n        int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                maxi = max(maxi, sum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = INT_MIN;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            for(int j=0; j<m-2; j++)\\n            {\\n              \\n        int sum=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                maxi = max(maxi, sum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479884,
                "title": "python-prefix-sum-is-what-we-need-explained",
                "content": "The idea is finding out all the hourglass in the matrix and calculate their sum.\\n\\nTo calculate the sum of a hourglass, we can use prefix sum, and this is what we need.\\n\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        # prefix sum\\n        m, n = len(grid), len(grid[0])\\n        \\n        ps_grid = []\\n        for i in range(m):\\n            t_ps, t_rs = [], 0\\n            for j in range(n):\\n                t_rs += grid[i][j]\\n                t_ps.append(t_rs)\\n            ps_grid.append(t_ps)\\n        \\n        ans = 0\\n        for i in range(0, m - 2):\\n            for j in range(0, n - 2):\\n                hourglass_sum = ps_grid[i][j + 2] - ps_grid[i][j] + grid[i][j] + grid[i + 1][j + 1] + ps_grid[i + 2][j + 2] - ps_grid[i + 2][j] + grid[i + 2][j]\\n                ans = max(ans, hourglass_sum)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        # prefix sum\\n        m, n = len(grid), len(grid[0])\\n        \\n        ps_grid = []\\n        for i in range(m):\\n            t_ps, t_rs = [], 0\\n            for j in range(n):\\n                t_rs += grid[i][j]\\n                t_ps.append(t_rs)\\n            ps_grid.append(t_ps)\\n        \\n        ans = 0\\n        for i in range(0, m - 2):\\n            for j in range(0, n - 2):\\n                hourglass_sum = ps_grid[i][j + 2] - ps_grid[i][j] + grid[i][j] + grid[i + 1][j + 1] + ps_grid[i + 2][j + 2] - ps_grid[i + 2][j] + grid[i + 2][j]\\n                ans = max(ans, hourglass_sum)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479096,
                "title": "elixir-my-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 619ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 68.9MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec max_sum(grid :: [[integer]]) :: integer\\n  def max_sum(grid) do\\n    len_row = Enum.count(grid)\\n    len_col = Enum.count(Enum.at(grid, 0))\\n    Enum.reduce(grid, {nil, 0, 0}, fn row, {_, i, res} ->\\n      if i < len_row - 2 do\\n        {:cont, i + 1, max(res,\\n        Enum.reduce(row, {nil, 0, res}, fn _, {_, j, res} ->\\n          if j < len_col - 2 do\\n            {:cont, j + 1, max(res,\\n                  Enum.at(Enum.at(grid, i), j) + Enum.at(Enum.at(grid, i), j + 1) + Enum.at(Enum.at(grid, i), j + 2) \\\\\\n                + Enum.at(Enum.at(grid, i + 1), j + 1) \\\\\\n                + Enum.at(Enum.at(grid, i + 2), j) + Enum.at(Enum.at(grid, i + 2), j + 1) + Enum.at(Enum.at(grid, i + 2), j + 2)\\n              )\\n            }\\n          else\\n            {:halt, j + 1, res}\\n          end\\n        end)) |> elem(2)\\n        }\\n      else\\n        {:halt, i + 1, res}\\n      end\\n    end) |> elem(2)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_sum(grid :: [[integer]]) :: integer\\n  def max_sum(grid) do\\n    len_row = Enum.count(grid)\\n    len_col = Enum.count(Enum.at(grid, 0))\\n    Enum.reduce(grid, {nil, 0, 0}, fn row, {_, i, res} ->\\n      if i < len_row - 2 do\\n        {:cont, i + 1, max(res,\\n        Enum.reduce(row, {nil, 0, res}, fn _, {_, j, res} ->\\n          if j < len_col - 2 do\\n            {:cont, j + 1, max(res,\\n                  Enum.at(Enum.at(grid, i), j) + Enum.at(Enum.at(grid, i), j + 1) + Enum.at(Enum.at(grid, i), j + 2) \\\\\\n                + Enum.at(Enum.at(grid, i + 1), j + 1) \\\\\\n                + Enum.at(Enum.at(grid, i + 2), j) + Enum.at(Enum.at(grid, i + 2), j + 1) + Enum.at(Enum.at(grid, i + 2), j + 2)\\n              )\\n            }\\n          else\\n            {:halt, j + 1, res}\\n          end\\n        end)) |> elem(2)\\n        }\\n      else\\n        {:halt, i + 1, res}\\n      end\\n    end) |> elem(2)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3469473,
                "title": "c-simple-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int maxi=0;  \\n        int m=g.size();\\n        int n=g[0].size();\\n        \\n        for(int i=1;i<=m-2;i++)\\n        {\\n            for(int j=1;j<=n-2;j++)\\n            {\\n                int tempSum=(g[i][j]+g[i-1][j]+g[i+1][j]+g[i-1][j-1]+g[i+1][j+1]+g[i-1][j+1]+g[i+1][j-1]);\\n                maxi=max(maxi, tempSum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& g) {\\n        int maxi=0;  \\n        int m=g.size();\\n        int n=g[0].size();\\n        \\n        for(int i=1;i<=m-2;i++)\\n        {\\n            for(int j=1;j<=n-2;j++)\\n            {\\n                int tempSum=(g[i][j]+g[i-1][j]+g[i+1][j]+g[i-1][j-1]+g[i+1][j+1]+g[i-1][j+1]+g[i+1][j-1]);\\n                maxi=max(maxi, tempSum);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461949,
                "title": "c-faster-than-65-brute-force",
                "content": "# Intuition\\nUse brute force to calcutare result.\\n\\n# Approach\\nUse brute force - calculate results for all hourglass\\' top-left corners.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is the numbers of items in grid.\\n\\n- Space complexity:\\n$$O(len(grid[0]))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxSum(int[][] grid) {\\n        var rs = -1;\\n        for (int i = 0; i < grid.Length - 2; i++)\\n        {\\n            var aux = new int[grid[0].Length - 2];\\n            aux[0] = grid[i][0] + grid[i][1] + grid[i][2] + grid[i + 1][1] + grid[i + 2][0] + grid[i + 2][1] + grid[i + 2][2];\\n            rs = Math.Max(rs, aux[0]);\\n            for (int j = 1; j < aux.Length; j++)\\n            {\\n                aux[j] = aux[j - 1] - grid[i][j - 1] + grid[i][j + 2] - grid[i + 1][j] + grid[i + 1][j + 1] - grid[i + 2][j - 1] + grid[i + 2][j + 2];\\n                rs = Math.Max(rs, aux[j]);\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxSum(int[][] grid) {\\n        var rs = -1;\\n        for (int i = 0; i < grid.Length - 2; i++)\\n        {\\n            var aux = new int[grid[0].Length - 2];\\n            aux[0] = grid[i][0] + grid[i][1] + grid[i][2] + grid[i + 1][1] + grid[i + 2][0] + grid[i + 2][1] + grid[i + 2][2];\\n            rs = Math.Max(rs, aux[0]);\\n            for (int j = 1; j < aux.Length; j++)\\n            {\\n                aux[j] = aux[j - 1] - grid[i][j - 1] + grid[i][j + 2] - grid[i + 1][j] + grid[i + 1][j + 1] - grid[i + 2][j - 1] + grid[i + 2][j + 2];\\n                rs = Math.Max(rs, aux[j]);\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432064,
                "title": "easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++){\\n            int temp=0;\\n            int[] arr=grid[i];\\n            \\n            for(int j=2;j<arr.length;j++){\\n                temp+=arr[j];\\n                temp+=arr[j-1];\\n                temp+=arr[j-2];\\n                if(i+2<grid.length){\\n                temp+=grid[i+1][j-1];\\n                \\n            \\n                temp+=grid[i+2][j];\\n                \\n            \\n                temp+=grid[i+2][j-1];\\n                \\n            \\n                temp+=grid[i+2][j-2];\\n                \\n                ans=Math.max(temp,ans);\\n                temp=0;\\n\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++){\\n            int temp=0;\\n            int[] arr=grid[i];\\n            \\n            for(int j=2;j<arr.length;j++){\\n                temp+=arr[j];\\n                temp+=arr[j-1];\\n                temp+=arr[j-2];\\n                if(i+2<grid.length){\\n                temp+=grid[i+1][j-1];\\n                \\n            \\n                temp+=grid[i+2][j];\\n                \\n            \\n                temp+=grid[i+2][j-1];\\n                \\n            \\n                temp+=grid[i+2][j-2];\\n                \\n                ans=Math.max(temp,ans);\\n                temp=0;\\n\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415051,
                "title": "o-n-2-solution-in-cpp",
                "content": "# Complexity\\n- Time complexity: ``O(n^2)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size(), m = grid[0].size(), sum;\\n        for(int i = 0; i < n - 2; i++){\\n          for(int j = 0; j < m - 2; j++){\\n            sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] \\n                + grid[i+1][j+1]\\n                + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n              ans = max(ans ,sum);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size(), m = grid[0].size(), sum;\\n        for(int i = 0; i < n - 2; i++){\\n          for(int j = 0; j < m - 2; j++){\\n            sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] \\n                + grid[i+1][j+1]\\n                + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n              ans = max(ans ,sum);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391115,
                "title": "java-simple-solution-using-brute-force-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int ans = 0;\\n        for(int i=1;i<m-1;i++) {\\n            for(int j=1;j<n-1;j++) {\\n                int sum = grid[i][j] + (grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]) + (grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]);\\n                ans = Math.max(ans, sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int ans = 0;\\n        for(int i=1;i<m-1;i++) {\\n            for(int j=1;j<n-1;j++) {\\n                int sum = grid[i][j] + (grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]) + (grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]);\\n                ans = Math.max(ans, sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389216,
                "title": "brute-force-beats-99",
                "content": "\\n# Code\\n```\\nvar maxSum = function(grid) {\\n    const m = grid.length, n = grid[0].length;\\n    let maxSum = 0;\\n\\n    for (let i = 1; i < m - 1; i++) {\\n        for (let j = 1; j < n - 1; j++) {\\n            maxSum = Math.max(maxSum, \\n                grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]\\n                               + grid[ i ][j] +\\n                grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]\\n            );\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nvar maxSum = function(grid) {\\n    const m = grid.length, n = grid[0].length;\\n    let maxSum = 0;\\n\\n    for (let i = 1; i < m - 1; i++) {\\n        for (let j = 1; j < n - 1; j++) {\\n            maxSum = Math.max(maxSum, \\n                grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]\\n                               + grid[ i ][j] +\\n                grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]\\n            );\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3388801,
                "title": "java-brute-force-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] g) {\\n        int max=0;\\n        int m=g.length;\\n        int n=g[0].length;\\n        for(int i=0;i<m-2;i++)\\n        {\\n            for(int j=0;j<n-2;j++)\\n            {\\n              int s=g[i][j]+g[i][j+1]+g[i][j+2]+g[i+1][j+1]+g[i+2][j]+g[i+2][j+1]+g[i+2][j+2];\\n              max=Math.max(s,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSum(int[][] g) {\\n        int max=0;\\n        int m=g.length;\\n        int n=g[0].length;\\n        for(int i=0;i<m-2;i++)\\n        {\\n            for(int j=0;j<n-2;j++)\\n            {\\n              int s=g[i][j]+g[i][j+1]+g[i][j+2]+g[i+1][j+1]+g[i+2][j]+g[i+2][j+1]+g[i+2][j+2];\\n              max=Math.max(s,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387809,
                "title": "python-add-all-the-hourglass-values-than-check-max",
                "content": "Since the hour glass cannot be rotated that simplifys the problem and we can just iterate up to m - 2 and n - 2 to avoid going out of bounds but also allowing for us to simply manually add the indexs and check max.\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        \\n        m,n = len(grid), len(grid[0])\\n        res = 0\\n        \\n        for i in range(m-2):\\n            for j in range(n-2):\\n                #calculate hourglass\\n                top = grid[i][j] + grid[i][j+1] + grid[i][j+2]\\n                mid = grid[i+1][j+1]\\n                bot = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                \\n                res = max(res, top + mid + bot)\\n                \\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "Since the hour glass cannot be rotated that simplifys the problem and we can just iterate up to m - 2 and n - 2 to avoid going out of bounds but also allowing for us to simply manually add the indexs and check max.\\n```\\nclass Solution:\\n    def maxSum(self, grid: List[List[int]]) -> int:\\n        \\n        m,n = len(grid), len(grid[0])\\n        res = 0\\n        \\n        for i in range(m-2):\\n            for j in range(n-2):\\n                #calculate hourglass\\n                top = grid[i][j] + grid[i][j+1] + grid[i][j+2]\\n                mid = grid[i+1][j+1]\\n                bot = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                \\n                res = max(res, top + mid + bot)\\n                \\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3381757,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun maxSum(grid: Array<IntArray>): Int {\\n        val (m, n) = Pair(grid.size, grid[0].size)\\n        var (result, sum) = Pair(Int.MIN_VALUE, 0)\\n\\n        for (i in 0..m-3) {\\n            for (j in 0..n-3) {\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                result = maxOf(result, sum)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxSum(grid: Array<IntArray>): Int {\\n        val (m, n) = Pair(grid.size, grid[0].size)\\n        var (result, sum) = Pair(Int.MIN_VALUE, 0)\\n\\n        for (i in 0..m-3) {\\n            for (j in 0..n-3) {\\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                result = maxOf(result, sum)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377063,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int i,j,er=0,k=0,c=0,y;\\n\\n        vector<int>res;\\n        for(i=0;i<grid.size()-2;i++)\\n        {\\n            k=1;\\n            y=c;\\n\\n            for(j=0;j<grid[0].size()-2;j++){\\n                // cout<<grid[i][j]<<\"  \"<<grid[i][j+1]<<\"  \"<<grid[i][j+2]<<\"  \"<<                grid[i+1][k++]<<\"  \"<<grid[i+2][y]<<\"   \"<<grid[i+2][y+1]<<\"   \"<<grid[i+2][y+2]<<\"  \";\\n                er+=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][k++]+grid[i+2][y]+\\n                grid[i+2][y+1]+grid[i+2][y+2];\\n               \\n                res.push_back(er);\\n                er=0;\\n                c++;\\n                y=c;\\n            }\\n            c=0;\\n            // c=y;\\n            cout<<endl;\\n        }\\n        sort(res.begin(),res.end());\\n        // cout<<res.size();\\n        return res[res.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int i,j,er=0,k=0,c=0,y;\\n\\n        vector<int>res;\\n        for(i=0;i<grid.size()-2;i++)\\n        {\\n            k=1;\\n            y=c;\\n\\n            for(j=0;j<grid[0].size()-2;j++){\\n                // cout<<grid[i][j]<<\"  \"<<grid[i][j+1]<<\"  \"<<grid[i][j+2]<<\"  \"<<                grid[i+1][k++]<<\"  \"<<grid[i+2][y]<<\"   \"<<grid[i+2][y+1]<<\"   \"<<grid[i+2][y+2]<<\"  \";\\n                er+=grid[i][j]+grid[i][j+1]+grid[i][j+2]+grid[i+1][k++]+grid[i+2][y]+\\n                grid[i+2][y+1]+grid[i+2][y+2];\\n               \\n                res.push_back(er);\\n                er=0;\\n                c++;\\n                y=c;\\n            }\\n            c=0;\\n            // c=y;\\n            cout<<endl;\\n        }\\n        sort(res.begin(),res.end());\\n        // cout<<res.size();\\n        return res[res.size()-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1627621,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1829420,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1811204,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1629657,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1990797,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1791041,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1632175,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1626960,
                "content": [
                    {
                        "username": "bytchenko",
                        "content": "Why it\\'s a medium difficulty problem? Simple brute force approach has been accepted. "
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s absolutely an easy question"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why it\\'s tagged prefix sum? and why it is medium?"
                    },
                    {
                        "username": "zbay",
                        "content": "Weirdly feels like there\\'s a dp solution to this."
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Does this question only have brute force solution? as i think even if we do prefix sum still we will have to brute force it? or am i missing something?\\n"
                    },
                    {
                        "username": "siddharth-s",
                        "content": "This should not be medium"
                    },
                    {
                        "username": "akriart",
                        "content": "Btw this question was actually there in hackerrank for quite a long time \\nhttps://www.hackerrank.com/challenges/java-2d-array/problem"
                    },
                    {
                        "username": "ethanrao",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = 0; j < m - 2; j++) {\\n                res = max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    }
]