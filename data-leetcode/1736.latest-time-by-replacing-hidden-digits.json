[
    {
        "title": "3Sum With Multiplicity",
        "question_content": "Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.\nAs the answer can be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: arr = [1,1,2,2,3,3,4,4,5,5], target = 8\nOutput: 20\nExplanation: \nEnumerating by the values (arr[i], arr[j], arr[k]):\n(1, 2, 5) occurs 8 times;\n(1, 3, 4) occurs 8 times;\n(2, 2, 4) occurs 2 times;\n(2, 3, 3) occurs 2 times.\n\nExample 2:\n\nInput: arr = [1,1,2,2,2,2], target = 5\nOutput: 12\nExplanation: \narr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:\nWe choose one 1 from [1,1] in 2 ways,\nand two 2s from [2,2,2,2] in 6 ways.\n\nExample 3:\n\nInput: arr = [2,1,3], target = 6\nOutput: 1\nExplanation: (1, 2, 3) occured one time in the array so we return 1.\n\n&nbsp;\nConstraints:\n\n\t3 <= arr.length <= 3000\n\t0 <= arr[i] <= 100\n\t0 <= target <= 300",
        "solutions": [
            {
                "id": 181131,
                "title": "c-java-python-o-n-101-101",
                "content": "Count the occurrence of each number.\\nusing hashmap or array up to you.\\n\\nLoop `i` on all numbers,\\nloop `j` on all numbers,\\ncheck if `k = target - i - j` is valid.\\n\\nAdd the number of this combination to result.\\n3 cases covers all possible combination:\\n1. `i == j == k` \\n2. ` i == j != k`\\n3. `i < k && j < k`\\n\\n**Time Complexity**:\\n`3 <= A.length <= 3000`, so N = 3000\\nBut `0 <= A[i] <= 100`\\nSo my solution is `O(N + 101 * 101)`\\n\\n**C++:**\\n```\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\n```\\n**Python:**\\n```\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\n```\n```\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\n```\n```\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 181128,
                "title": "10-lines-super-super-easy-java-solution",
                "content": "## Think Outside of The Box! \\nIntuitively, you will try to solve it based on the solution of 3Sum.\\nBut... Build a map for counting different sums of two numbers. The rest of things are straightfoward.\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < A.length; i++) {\\n            res = (res + map.getOrDefault(target - A[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = A[i] + A[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < A.length; i++) {\\n            res = (res + map.getOrDefault(target - A[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = A[i] + A[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123612,
                "title": "c-super-simple-7-line-solution-without-sorting",
                "content": "Use a map to count all sums of two numbers.\\nThen, if target - arr[i] is in map, it means we have a three-sum, so we add it to the result.\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918718,
                "title": "python-3sum-approach-with-explanation",
                "content": "### Introduction\\n\\nGiven an array of integers `arr`, determine how many tuples `(i, j, k)` exist such that `0 <= i < j < k < len(arr)` and `arr[i] + arr[j] + arr[k] == target`.\\n\\nThis problem is similar to [15. 3Sum](https://leetcode.com/problems/3sum/), except it differs in one major way: where the similar problem requires all unique tuples, this problem requires the number of all tuples (which need not be unique).\\n\\n---\\n\\n### Base Approach\\n\\nTo begin, let\\'s understand how the 3-sum algorithm works. First, ensure that the array is sorted in ascending order (descending order works too, but we\\'ll stick to ascending).\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\t# the rest of the code here\\n```\\n\\nNext, we want a for-loop that will iterate through the array.\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tfor i in range(len(arr)-2):\\n\\t\\t\\t# do something\\n\\t\\t\\tpass\\n\\t\\t# the rest of the code here\\n````\\n\\nNotice that we leave the last two indexes of the array untouched. This is because this for-loop will **serve as a pointer to the lowest value in the resulting tuple**; i.e., this pointer tries to find `i` in `(i, j, k)`. This also means that the resulting right end of the array (i.e., `arr[i+1:]`) will contain our remaining two pointers `j` and `k`.\\n\\nNotice now that we have simplified the problem from a 3-sum to a 2-sum; i.e., instead of finding `(i, j, k)` in `arr` where `arr[i] + arr[j] + arr[k] == target`, we now only need to find `(j, k)` in `arr[i+1:]` where `arr[j] + arr[k] == target - arr[i]`. The implementation that follows should then be similar to [1. Two Sum](https://leetcode.com/problems/two-sum/).\\n\\nIn case you are not familiar with the 2-sum algorithm: in a sorted ascending array, we have 2 pointers `j` and `k` pointing to the two ends of the array. Then, in binary-search fashion, **if `arr[j] + arr[k] < target`, we increment `j` to increase the value of `arr[j]`; if `arr[j] + arr[k] > target`, we decrement `k` to decrease the value of `arr[k]`; we continue doing this until we have found a suitable `(j, k)` or `j >= k`**.\\n\\nPutting it all together, we have:\\n\\n```python\\nclass Solution(object):\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tres, l = 0, len(arr)\\n        for i in range(l-2):\\n\\t\\t\\t# Initialise the 2-sum pointers\\n            j, k = i+1, l-1\\n            while j < k:\\n                if arr[j]+arr[k] < target-arr[i]:  # arr[j] is too small\\n                    j += 1\\n                elif arr[j]+arr[k] > target-arr[i]:  # arr[k] is too large\\n                    k -= 1\\n\\t\\t\\t\\telse:  # arr[i]+arr[j]+arr[k] == target\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t# Shift both pointers by 1\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tk -= 1\\n\\t\\treturn res%1000000007\\n```\\n\\n---\\n\\n### Tweaking the Algorithm\\n\\nIf you tried running the code above, it would give you the wrong answer. Let\\'s use the testcase as an example:\\n\\n```text\\ntarget = 8\\narr: 1 1 2 2 3 3 4 4 5 5\\n     i   j             k  -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n\\t i     j         k    -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n```\\n\\nThe problem comes when there are multiple instances of the same number. In the above example, after finding that `j=2, k=9` satisfies the equation, we simply shift the pointers and continue, **without realising that `j=3, k=9` and `j=2, k=8` are both valid tuples as well**. Hence, we end up missing some possible tuples if we shift the pointers. But how do we know when to shift the pointers and when not to?\\n\\nThe trick in this case is to **reconsider the way that we are counting the number of valid tuples**. In the above code, we simply increment the counter by 1 (`res += 1`), but we can do this more efficiently if we had the number of instances of `arr[j]` and `arr[k]` respectively. Of course, we will need to take into account different cases whereby `arr[i]`, `arr[j]`, and/or `arr[k]` may not be fully unqiue. Since `arr[i] <= arr[j] <= arr[k]`, we have the following cases:\\n\\n```text\\nCases                               Result (note: count() is an arbitrary function)\\n1) arr[i] != arr[j] != arr[k]  -->  res += count(arr[i]) * count(arr[j]) * count(arr[k])\\n2) arr[i] == arr[j] != arr[k]  -->  res += math.comb(count(arr[i]), 2) * count(arr[k])\\n3) arr[i] != arr[j] == arr[k]  -->  res += count(arr[i]) * math.comb(count(arr[j]), 2)\\n4) arr[i] == arr[j] == arr[k]  -->  res += math.comb(count(arr[i]), 3)\\n\\nRelevant mathematical equations\\nmath.comb(count(arr[i]), 2) = count(arr[i]) * (count(arr[i]) - 1) // 2\\nmath.comb(count(arr[i]), 3) = count(arr[i]) * (count(arr[i]) - 1) * (count(arr[i]) - 2) // 6\\n```\\n\\nTo incorporate this into our code, we then have to make sure that we do not check the same number twice. To do so, we can simply **shift our pointers by the number of instances of the number**, instead of incrementing or decrementing by 1 each time.\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        cnt = Counter(arr)  # obtain the number of instances of each number\\n        res, i, l = 0, 0, len(arr)\\n        while i < l:  # in replacement of the for-loop, so that we can increment i by more than 1\\n            j, k = i, l-1  # j should be the leftmost index, hence j=i instead of j=i+1\\n            while j < k:  # i <= j < k; arr[i] <= arr[j] <= arr[k]\\n                if arr[i]+arr[j]+arr[k] < target:\\n                    j += cnt[arr[j]]\\n                elif arr[i]+arr[j]+arr[k] > target:\\n                    k -= cnt[arr[k]]\\n                else:  # arr[i]+arr[j]+arr[k] == target\\n                    if arr[i] != arr[j] != arr[k]:  # Case 1: All the numbers are different\\n                        res += cnt[arr[i]]*cnt[arr[j]]*cnt[arr[k]]\\n                    elif arr[i] == arr[j] != arr[k]:  # Case 2: The smaller two numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*cnt[arr[k]]//2  # math.comb(cnt[arr[i]], 2)*cnt[arr[k]]\\n                    elif arr[i] != arr[j] == arr[k]:  # Case 3: The larger two numbers are the same\\n                        res += cnt[arr[i]]*cnt[arr[j]]*(cnt[arr[j]]-1)//2  # math.comb(cnt[arr[j]], 2)*cnt[arr[i]]\\n                    else:  # Case 4: All the numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*(cnt[arr[i]]-2)//6  # math.comb(cnt[arr[i]], 3)\\n\\t\\t\\t\\t\\t# Shift pointers by the number of instances of the number\\n                    j += cnt[arr[j]]\\n                    k -= cnt[arr[k]]\\n            i += cnt[arr[i]]  # Shift pointer by the number of instances of the number\\n        return res%1000000007\\n```\\n\\n**TC: O(n<sup>2</sup>)**, where `n` is the length of `arr`, due to the nested while loop.\\n**SC: O(n)**, due to the Counter object.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\t# the rest of the code here\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tfor i in range(len(arr)-2):\\n\\t\\t\\t# do something\\n\\t\\t\\tpass\\n\\t\\t# the rest of the code here\\n```\n```python\\nclass Solution(object):\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n\\t\\tres, l = 0, len(arr)\\n        for i in range(l-2):\\n\\t\\t\\t# Initialise the 2-sum pointers\\n            j, k = i+1, l-1\\n            while j < k:\\n                if arr[j]+arr[k] < target-arr[i]:  # arr[j] is too small\\n                    j += 1\\n                elif arr[j]+arr[k] > target-arr[i]:  # arr[k] is too large\\n                    k -= 1\\n\\t\\t\\t\\telse:  # arr[i]+arr[j]+arr[k] == target\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t# Shift both pointers by 1\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tk -= 1\\n\\t\\treturn res%1000000007\\n```\n```text\\ntarget = 8\\narr: 1 1 2 2 3 3 4 4 5 5\\n     i   j             k  -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n\\t i     j         k    -->  arr[i] + arr[j] + arr[k] == target; j += 1, k -= 1.\\n```\n```text\\nCases                               Result (note: count() is an arbitrary function)\\n1) arr[i] != arr[j] != arr[k]  -->  res += count(arr[i]) * count(arr[j]) * count(arr[k])\\n2) arr[i] == arr[j] != arr[k]  -->  res += math.comb(count(arr[i]), 2) * count(arr[k])\\n3) arr[i] != arr[j] == arr[k]  -->  res += count(arr[i]) * math.comb(count(arr[j]), 2)\\n4) arr[i] == arr[j] == arr[k]  -->  res += math.comb(count(arr[i]), 3)\\n\\nRelevant mathematical equations\\nmath.comb(count(arr[i]), 2) = count(arr[i]) * (count(arr[i]) - 1) // 2\\nmath.comb(count(arr[i]), 3) = count(arr[i]) * (count(arr[i]) - 1) * (count(arr[i]) - 2) // 6\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        cnt = Counter(arr)  # obtain the number of instances of each number\\n        res, i, l = 0, 0, len(arr)\\n        while i < l:  # in replacement of the for-loop, so that we can increment i by more than 1\\n            j, k = i, l-1  # j should be the leftmost index, hence j=i instead of j=i+1\\n            while j < k:  # i <= j < k; arr[i] <= arr[j] <= arr[k]\\n                if arr[i]+arr[j]+arr[k] < target:\\n                    j += cnt[arr[j]]\\n                elif arr[i]+arr[j]+arr[k] > target:\\n                    k -= cnt[arr[k]]\\n                else:  # arr[i]+arr[j]+arr[k] == target\\n                    if arr[i] != arr[j] != arr[k]:  # Case 1: All the numbers are different\\n                        res += cnt[arr[i]]*cnt[arr[j]]*cnt[arr[k]]\\n                    elif arr[i] == arr[j] != arr[k]:  # Case 2: The smaller two numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*cnt[arr[k]]//2  # math.comb(cnt[arr[i]], 2)*cnt[arr[k]]\\n                    elif arr[i] != arr[j] == arr[k]:  # Case 3: The larger two numbers are the same\\n                        res += cnt[arr[i]]*cnt[arr[j]]*(cnt[arr[j]]-1)//2  # math.comb(cnt[arr[j]], 2)*cnt[arr[i]]\\n                    else:  # Case 4: All the numbers are the same\\n                        res += cnt[arr[i]]*(cnt[arr[i]]-1)*(cnt[arr[i]]-2)//6  # math.comb(cnt[arr[i]], 3)\\n\\t\\t\\t\\t\\t# Shift pointers by the number of instances of the number\\n                    j += cnt[arr[j]]\\n                    k -= cnt[arr[k]]\\n            i += cnt[arr[i]]  # Shift pointer by the number of instances of the number\\n        return res%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918457,
                "title": "c-simplest-solution-w-easy-explanation-intuitive",
                "content": "**APPROACH :**\\n \\n* We traverse the array using 2 loops & compute the sums of all possible pairs. \\n\\n* We store the sums of pairs in an ```unordered_map``` along with their frequency.\\n\\n* While traversing, we also check if the ```target - current element``` is present in the map. If so, we add it\\'s frequency to the result.\\n\\n* Finally we return the result.\\n\\n**Time Complexity :** O(n^2)\\n\\n**Space Complexity :** O(n^2)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X) {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<n; i++) {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if you like my solution & explanation :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```unordered_map```\n```target - current element```\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X) {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<n; i++) {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181098,
                "title": "java-python-3-o-n-2-and-o-n-101-2-codes-w-brief-anslysis",
                "content": "**Q & A**\\n\\nQ1: When we find the three array element values, x, y, and z; how do we make sure their corresponding index values meet the requirement where indexes are i < j < k? More precisely, in the if and elif statements, we compare the array element values, but not the array index values. If the LeetCode problem itself say the array is sorted, then it makes more sense. But it doesn\\'t say if the array is sorted or not. \\nA1: The problems states: ...`return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.`...\\nThe above actually means **return the number of tuples of 3 elements with a sum of target**.\\n`i < j < k` in this problem actually means `i, j` and `k` are `3` different indices.\\n\\n**End of Q & A**\\n\\n----\\n\\n**Method 1**\\n\\n**Java**\\nSimilar to 3 sum.\\n```java\\n    public int threeSumMulti(int[] A, int target) {\\n        Arrays.sort(A);\\n        long res = 0;\\n        for (int i = 0; i < A.length - 2; ++i) {\\n            int j = i + 1;\\n            int k = A.length - 1;\\n            while (j < k) {\\n                if (A[j] + A[k] < target - A[i]) { \\n                    ++j;\\n                }else if (A[j] + A[k] > target - A[i]) {\\n                    --k;\\n                }else {\\n                    int l = 1, r = 1;\\n                    while (j + l < k && A[j + l] == A[j]) { ++l; } // l: number of elements equal to A[j].\\n                    while (j + l <= k - r && A[k - r] == A[k]) { ++r; } // r: number of elements equal to A[k].\\n                    // If A[j...k] are all equal, then there are C(k - j + 1, 2) cases\\n                    // that meet the requirement;\\n                    // Otherwise, there are l * r cases that meet the requirement.\\n                    res += A[j] == A[k] ? (k - j + 1) * (k - j) / 2 : l * r ;\\n                    j += l; // forward j by l steps.\\n                    k -= r; // backward k by r steps.\\n                }\\n            }\\n        }\\n        return (int)(res % 1_000_000_007);\\n    }\\n```\\n**Python 3**\\n```python\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        ans = 0\\n        for i in range(2, len(arr)):\\n            j, k = 0, i - 1\\n            while j < k:\\n                sm = arr[i] + arr[j] + arr[k]\\n                if sm < target:\\n                    j += 1\\n                elif sm > target:\\n                    k -= 1\\n                else:\\n                    l = r = 1\\n                    while j + l < k and arr[j] == arr[j + l]:\\n                        l += 1\\n                    while j + l <= k - r and arr[k] == arr[k - r]:\\n                        r += 1\\n                    ans += (l + r) * (l + r - 1) // 2 if arr[j] == arr[k] else l * r\\n                    j += l;\\n                    k -= r;\\n        return ans % (10 ** 9 + 7)\\n```\\n**Analysis:**\\n\\nArrays.sort() cost time O(nlogn), which is a minor part; for each i, all while loops totally cost time O(n), therefore we have:\\n\\nTime: O(n ^ 2).\\n\\n----\\n\\n**Method 2**\\n\\n*Intuition*\\nThere are `3` cases for `i + j + k == target`, in which `i, j, k` are `3` elements from input `A`:\\n1. `i, j, k` are all equal; That is, `i == j && j == k`, assume there are `cnt` `i`s in `A`,  then we have `C(cnt, 3) = cnt * (cnt - 1) * (cnt - 2) / 6` possible combinations;\\n2. `i == j`, but `k` is different from them; assume there are `cnt` `i`s in `A`,  then we have `C(cnt, 2) = cnt * (cnt - 1) / 2` possible combinations of `i` and `j`, and times the frequency of `j`, `cnt3`, then we have `cnt * (cnt - 1) / 2 * cnt3`; \\n3. `i, j, k` are all distinct; we just choose each element from `cnt` `i`s, `cnt2` `j`s, and `cnt3` `k`s, respectively; There are `cnt * cnt2 * cnt3` combinations.\\n\\n**Java**\\n```java\\n    private static final int mod = 1_000_000_007;\\n    public int threeSumMulti(int[] A, int target) {\\n        long ans = 0;\\n        final Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, 1 + count.getOrDefault(a, 0)); \\n        for (int i : count.keySet()) {\\n            for (int j : count.keySet()) {\\n                int k = target - i - j;\\n                if (count.containsKey(k)) {\\n                    long cnt = count.get(i), cnt2 = count.get(j), cnt3 = count.get(k);\\n                    if (i == j && j == k) {\\n                        ans += cnt * (cnt - 1) * (cnt - 2) / 6;\\n                    }else if (i == j) {\\n                        ans += cnt * (cnt - 1) / 2 * cnt3;\\n                    }else if (i < j && j < k) {\\n                        ans += cnt * cnt2 * cnt3;\\n                    }\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n```\\n\\n**Python 3**\\n```python\\n    def threeSumMulti(self, A: List[int], target: int) -> int:\\n        cnt, ans = collections.Counter(A), 0\\n        for i in cnt:\\n            for j in cnt:\\n                k = target - i - j\\n                if i == j == k:\\n                    ans += cnt[i] * (cnt[i] - 1) * (cnt[i] - 2) // 6\\n                elif i == j:\\n                    ans += cnt[i] * (cnt[i] - 1) // 2 * cnt[k]\\n                elif i < j < k:\\n                    ans += cnt[i] * cnt[j] * cnt[k]\\n        return ans % (10**9 + 7)\\n```\\nTime: O(n + 101 ^ 2), space: O(101).",
                "solutionTags": [],
                "code": "```java\\n    public int threeSumMulti(int[] A, int target) {\\n        Arrays.sort(A);\\n        long res = 0;\\n        for (int i = 0; i < A.length - 2; ++i) {\\n            int j = i + 1;\\n            int k = A.length - 1;\\n            while (j < k) {\\n                if (A[j] + A[k] < target - A[i]) { \\n                    ++j;\\n                }else if (A[j] + A[k] > target - A[i]) {\\n                    --k;\\n                }else {\\n                    int l = 1, r = 1;\\n                    while (j + l < k && A[j + l] == A[j]) { ++l; } // l: number of elements equal to A[j].\\n                    while (j + l <= k - r && A[k - r] == A[k]) { ++r; } // r: number of elements equal to A[k].\\n                    // If A[j...k] are all equal, then there are C(k - j + 1, 2) cases\\n                    // that meet the requirement;\\n                    // Otherwise, there are l * r cases that meet the requirement.\\n                    res += A[j] == A[k] ? (k - j + 1) * (k - j) / 2 : l * r ;\\n                    j += l; // forward j by l steps.\\n                    k -= r; // backward k by r steps.\\n                }\\n            }\\n        }\\n        return (int)(res % 1_000_000_007);\\n    }\\n```\n```python\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        ans = 0\\n        for i in range(2, len(arr)):\\n            j, k = 0, i - 1\\n            while j < k:\\n                sm = arr[i] + arr[j] + arr[k]\\n                if sm < target:\\n                    j += 1\\n                elif sm > target:\\n                    k -= 1\\n                else:\\n                    l = r = 1\\n                    while j + l < k and arr[j] == arr[j + l]:\\n                        l += 1\\n                    while j + l <= k - r and arr[k] == arr[k - r]:\\n                        r += 1\\n                    ans += (l + r) * (l + r - 1) // 2 if arr[j] == arr[k] else l * r\\n                    j += l;\\n                    k -= r;\\n        return ans % (10 ** 9 + 7)\\n```\n```java\\n    private static final int mod = 1_000_000_007;\\n    public int threeSumMulti(int[] A, int target) {\\n        long ans = 0;\\n        final Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, 1 + count.getOrDefault(a, 0)); \\n        for (int i : count.keySet()) {\\n            for (int j : count.keySet()) {\\n                int k = target - i - j;\\n                if (count.containsKey(k)) {\\n                    long cnt = count.get(i), cnt2 = count.get(j), cnt3 = count.get(k);\\n                    if (i == j && j == k) {\\n                        ans += cnt * (cnt - 1) * (cnt - 2) / 6;\\n                    }else if (i == j) {\\n                        ans += cnt * (cnt - 1) / 2 * cnt3;\\n                    }else if (i < j && j < k) {\\n                        ans += cnt * cnt2 * cnt3;\\n                    }\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n```\n```python\\n    def threeSumMulti(self, A: List[int], target: int) -> int:\\n        cnt, ans = collections.Counter(A), 0\\n        for i in cnt:\\n            for j in cnt:\\n                k = target - i - j\\n                if i == j == k:\\n                    ans += cnt[i] * (cnt[i] - 1) * (cnt[i] - 2) // 6\\n                elif i == j:\\n                    ans += cnt[i] * (cnt[i] - 1) // 2 * cnt[k]\\n                elif i < j < k:\\n                    ans += cnt[i] * cnt[j] * cnt[k]\\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1918415,
                "title": "simple-hashmap-solution-faster-than-80",
                "content": "**Please upvote if you like the solution**\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181125,
                "title": "knapsack-o-n-target-or-straightforward-o-n-2",
                "content": "`dp[i][j][k]` represents number of combinations using `k` numbers within `A[0] ... A[i]` with the sum of `j`.\\nThen `dp[n][target][3]` is the result. O(n * target)\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][][] dp = new int[n + 1][target + 1][4];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= target; j++) {\\n                for (int k = 1; k <= 3; k++) {\\n                    dp[i + 1][j][k] = dp[i][j][k];\\n                    dp[i + 1][j][k] %= M;\\n                    if (j >= A[i]) {\\n                        dp[i + 1][j][k] += dp[i][j - A[i]][k - 1];\\n                        dp[i + 1][j][k] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][target][3];\\n    }\\n}\\n```\\n\\nO(target) space:\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][] dp = new int[target + 1][4];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = target; j >= A[i]; j--) {\\n                for (int k = 3; k >= 1; k--) {\\n                    dp[j][k] += dp[j - A[i]][k - 1];\\n                    dp[j][k] %= M;\\n                }\\n            }\\n        }\\n        return dp[target][3];\\n    }\\n}\\n```\\n\\nO(n^2) Straightforward:\\nGuarantee `a <= b <= c`\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0l) + 1);\\n        }\\n        long result = 0;\\n        int M = (int)1e9 + 7;\\n        for (int a : map.keySet()) {\\n            for (int b : map.keySet()) {\\n                if (b < a || a == b && map.get(a) == 1) {\\n                    continue;\\n                }\\n                int c = target - a - b;\\n                if (c < b || !map.containsKey(c)) {\\n                    continue;\\n                }\\n                if (a == b && b == c) {\\n                    if (map.get(a) == 2) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(a), 3);\\n                } else if (a == b) {\\n                    result += nCk(map.get(a), 2) * map.get(c);\\n                } else if (b == c) {\\n                    if (map.get(b) == 1) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(b), 2) * map.get(a);\\n                } else {\\n                    result += (map.get(a) * map.get(b) * map.get(c));\\n                }\\n                result %= M;\\n            }\\n        }\\n        return (int)result;\\n    }\\n    private long nCk(long n, int k) {\\n        if (k == 3) {\\n            return (n * (n - 1) * (n - 2)) / 6;\\n        } else {\\n            return n * (n - 1) / 2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][][] dp = new int[n + 1][target + 1][4];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= target; j++) {\\n                for (int k = 1; k <= 3; k++) {\\n                    dp[i + 1][j][k] = dp[i][j][k];\\n                    dp[i + 1][j][k] %= M;\\n                    if (j >= A[i]) {\\n                        dp[i + 1][j][k] += dp[i][j - A[i]][k - 1];\\n                        dp[i + 1][j][k] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][target][3];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int n = A.length, M = (int)1e9 + 7;\\n        int[][] dp = new int[target + 1][4];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = target; j >= A[i]; j--) {\\n                for (int k = 3; k >= 1; k--) {\\n                    dp[j][k] += dp[j - A[i]][k - 1];\\n                    dp[j][k] %= M;\\n                }\\n            }\\n        }\\n        return dp[target][3];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0l) + 1);\\n        }\\n        long result = 0;\\n        int M = (int)1e9 + 7;\\n        for (int a : map.keySet()) {\\n            for (int b : map.keySet()) {\\n                if (b < a || a == b && map.get(a) == 1) {\\n                    continue;\\n                }\\n                int c = target - a - b;\\n                if (c < b || !map.containsKey(c)) {\\n                    continue;\\n                }\\n                if (a == b && b == c) {\\n                    if (map.get(a) == 2) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(a), 3);\\n                } else if (a == b) {\\n                    result += nCk(map.get(a), 2) * map.get(c);\\n                } else if (b == c) {\\n                    if (map.get(b) == 1) {\\n                        continue;\\n                    }\\n                    result += nCk(map.get(b), 2) * map.get(a);\\n                } else {\\n                    result += (map.get(a) * map.get(b) * map.get(c));\\n                }\\n                result %= M;\\n            }\\n        }\\n        return (int)result;\\n    }\\n    private long nCk(long n, int k) {\\n        if (k == 3) {\\n            return (n * (n - 1) * (n - 2)) / 6;\\n        } else {\\n            return n * (n - 1) / 2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123894,
                "title": "3sum-with-multiplicity-short-easy-w-explanation-beats-100",
                "content": "***Solution - I***\\n\\nWe can **sort the array and use a two pointer technique** on the sorted array. For each `i` in the sorted array, find two indices `j` and `k` (i < j < k) using 2-pointer such that `arr[j] + arr[k] = target - arr[i]`. Now, in a sorted array, duplicated `arr[j]` and `arr[k]` would appear consecutively. \\n\\nFor eg. Suppose we have target=4 and we are searching for `j` and `k` in subarray `[1,1,2,2,2,3,3,3]`. We find j can be 1st index and k can be last index. We pick up all elements equal to `arr[j]` (l=2) and `arr[k]` (r=3). A total of `l*r` will be added to the final count.\\n\\nWe also need to take care when `arr[j]` and `arr[k]` are the same element. In this case, a total of `(k-i) * (k-i+1)/2` has to be added. For eg. if we had a subarray `[2,2,2]` and needed to find such that `arr[j] + arr[k] = 4`, we would have 3 total pairs (`{0,1},{0,2},{1,2}`).\\n\\n**Note :** Sorting won\\'t affect our final answer. We just need to make sure that we choose 3 distinct elements from the array and the pair (i,j,k) is counted just once. Check for some array without and with sort and you would get the idea.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time Complexity :** **`O(N^2)`**, \\n**Space Complexity :** **`O(sort)`**, only extra space needed is the implict space used in sort.\\n\\n![image](https://assets.leetcode.com/users/images/0a7c2041-597f-4e63-ae63-dd71293423ce_1616512183.3679485.png)\\n\\n\\n---------\\n---------\\n\\n***Solution - II***\\n\\nWe can notice that elements of the array can be at max `100`. We can use this to optimise the solution further.\\n\\nInstead of choosing one index and finding the other two indices using two-pointer as done in previous approach, we can choose each number from `0 to 100` and if it exists in array, find other two numbers.\\n\\nWe need to maintain a frequency array to do this efficiently. We will have following cases (here i,j,k denote value of array we are checking, not indices) - \\n\\n* `i = j = k` : Add `freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6` which is nothing but formula of number of ways to choose three distinct elements from n. \\n* `i = j != k` : Add `freq[k] + (freq[i] * (freq[i] - 1))/2` which denotes that number of `k`s and ways to choose 2 distinct elements from freq[i]\\n* `i != j = k` : Similar to above\\n* `i != j != k` : Just multiply all frequency to get the number of triplet possible.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time complexity :** `O(N + MAX^2)`, where `N` is the number of elemetns in `arr` and `MAX` is the maximum element of array.\\n**Space complexity :** `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/78e7c8d4-3227-43a4-a4be-4407041b7a42_1616509984.6405087.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181156,
                "title": "c-6-lines-4-ms-o-distinct-n-2",
                "content": "Since the numbers are in [0..100], we can use bucket sort instead of hash map. The first solution is demonstrating calculation for 4 cases:\\n- 3 * i = target\\n- 2 * i + j = target\\n- i + 2 * j = target\\n- i + j + k = target\\n```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i) {\\n        if (i * 3 == target) res += m[i] * (m[i] - 1) * (m[i] - 2) / 6;\\n        for (auto j = i + 1, k = target - i - j; j < 101; ++j, --k) {\\n            if (i * 2 + j == target) res += m[i] * m[j] * (m[i] - 1) / 2;\\n            if (i + j * 2 == target) res += m[i] * m[j] * (m[j] - 1) / 2;\\n            if (k > j && k < 101) res += m[i] * m[j] * m[k];\\n        }\\n    }\\n    return res % 1000000007;\\n}\\n```\\nIf we analyze these calculation, we can generalize them into one and get a shorter solution. \\n```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i)\\n        for (auto j = i, k = target - i - j; j < 101; ++j, --k)\\n            if (k >= j && k < 101) res += m[i] * (m[j] - (i == j)) * (m[k] - (k == j) * ((i == j) + 1)) /\\n                (((k == j && i == j) * 2 + 1) * ((k == j || i == j) + 1));\\n    return res % 1000000007;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i) {\\n        if (i * 3 == target) res += m[i] * (m[i] - 1) * (m[i] - 2) / 6;\\n        for (auto j = i + 1, k = target - i - j; j < 101; ++j, --k) {\\n            if (i * 2 + j == target) res += m[i] * m[j] * (m[i] - 1) / 2;\\n            if (i + j * 2 == target) res += m[i] * m[j] * (m[j] - 1) / 2;\\n            if (k > j && k < 101) res += m[i] * m[j] * m[k];\\n        }\\n    }\\n    return res % 1000000007;\\n}\\n```\n```\\nint threeSumMulti(vector<int>& nums, int target) {\\n    long m[101] = {}, res = 0;\\n    for (auto n : nums) ++m[n];\\n    for (auto i = 0; i < 101; ++i)\\n        for (auto j = i, k = target - i - j; j < 101; ++j, --k)\\n            if (k >= j && k < 101) res += m[i] * (m[j] - (i == j)) * (m[k] - (k == j) * ((i == j) + 1)) /\\n                (((k == j && i == j) * 2 + 1) * ((k == j || i == j) + 1));\\n    return res % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767824,
                "title": "two-pointer-solution-c",
                "content": "The idea is same with 3Sum, but need to care about combination of duplicates. Firstly sort `A`, then say we fix `i` as first number, and we want to find all possibilities of `A[lo] + A[hi] == target - A[i]`:\\nCase1: `A[lo] != A[hi]`. Count the number of duplicates of `A[lo]` and `A[hi]`, as `cntlo` and `cnthi`, then for `i`, there are `cnthi*cntlo` possibilities\\nCase2: `A[lo] == A[hi]`. Now all number between `lo` and `hi` are same. Say the number of duplicates is n, any two of n can meet `A[lo] + A[hi] == target - A[i]`, that is n*(n-1)/2.\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int ans = 0; \\n        int mod = 1e9+7;\\n        for (int i=0; i<n-2; ++i) {\\n            int lo = i+1, hi = n-1;\\n            while (lo < hi) {\\n                if (A[i] + A[lo] + A[hi] == target) {\\n                    int cntlo=1, cnthi=1;\\n                    while (lo < hi && A[lo] == A[lo+1]) {cntlo++; lo++;}\\n                    while (lo < hi && A[hi] == A[hi-1]) {cnthi++; hi--;}\\n\\t\\t\\t\\t\\t// A[lo]==A[hi]\\n                    if (lo == hi) ans =(ans+cntlo*(cntlo-1)/2)%mod;\\n\\t\\t\\t\\t\\t// A[lo]!=A[hi]\\n                    else ans = (ans+cntlo*cnthi)%mod;\\n                    lo++; hi--; \\n                } else if (A[i] + A[lo] + A[hi] > target) {\\n                    hi--;\\n                } else {\\n                    lo++;\\n                }\\n            }\\n            //cout << ans << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int ans = 0; \\n        int mod = 1e9+7;\\n        for (int i=0; i<n-2; ++i) {\\n            int lo = i+1, hi = n-1;\\n            while (lo < hi) {\\n                if (A[i] + A[lo] + A[hi] == target) {\\n                    int cntlo=1, cnthi=1;\\n                    while (lo < hi && A[lo] == A[lo+1]) {cntlo++; lo++;}\\n                    while (lo < hi && A[hi] == A[hi-1]) {cnthi++; hi--;}\\n\\t\\t\\t\\t\\t// A[lo]==A[hi]\\n                    if (lo == hi) ans =(ans+cntlo*(cntlo-1)/2)%mod;\\n\\t\\t\\t\\t\\t// A[lo]!=A[hi]\\n                    else ans = (ans+cntlo*cnthi)%mod;\\n                    lo++; hi--; \\n                } else if (A[i] + A[lo] + A[hi] > target) {\\n                    hi--;\\n                } else {\\n                    lo++;\\n                }\\n            }\\n            //cout << ans << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1123498,
                "title": "python-combinatorics-solution-explained",
                "content": "Let us calculate `Counter(arr)`, that is how what is frequency of each number and then check `3` cases:\\n1. All numbers `i < j < k` ar different: then we can check all possible permutations for numbers `i` and `j` and then check that for `k = target - i - j` we have `i < j < k`.\\n2. For numbers `i, j, k` we have `i = j != k`. Then we have `c[i]*(c[i]-1)*c[target - 2*i]//2` number of options. Why? Because we need to choose `i` element twice, this is number of combinations with `2` elements from `c[i]` elements. Note, that I did not specify which of three indexes here is smaller and which is bigger, so here we cover all cases where exactly `2` indexes are equal.\\n3. For numers `i, j, k` we have `i = j = k`. Here answer is `c[i]*(c[i]-1)*(c[i]-2)//6`: number of combinations with `3` elements from `c[i]` elements.\\n\\n**Complexity**: time complexity is `O(n^2)`, where `n` is length of `arr`, because on first iteration we did `O(n^2)` and on second and third we did `O(n)`. Space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def threeSumMulti(self, arr, target):\\n        c = Counter(arr)\\n        ans, M = 0, 10**9 + 7\\n        for i, j in permutations(c, 2):\\n            if i < j < target - i - j:\\n                ans += c[i]*c[j]*c[target - i - j]\\n\\n        for i in c:\\n            if 3*i != target:\\n                ans += c[i]*(c[i]-1)*c[target - 2*i]//2\\n            else:\\n                ans += c[i]*(c[i]-1)*(c[i]-2)//6\\n                \\n        return ans % M\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr, target):\\n        c = Counter(arr)\\n        ans, M = 0, 10**9 + 7\\n        for i, j in permutations(c, 2):\\n            if i < j < target - i - j:\\n                ans += c[i]*c[j]*c[target - i - j]\\n\\n        for i in c:\\n            if 3*i != target:\\n                ans += c[i]*(c[i]-1)*c[target - 2*i]//2\\n            else:\\n                ans += c[i]*(c[i]-1)*(c[i]-2)//6\\n                \\n        return ans % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123830,
                "title": "js-python-java-c-efficient-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to attempt all permutations, but that would run up to **2.7e10** attempts. The first important thing to notice is that the range of numbers is very small at **[0,100]**. With that few number options, any large input array (**A**) will have many duplicates, which means we\\'re looking at a **combinatorics** solution.\\n\\nIn order to use the combinatorics shortcut, however, we\\'ll first have to make a **frequency map** of the numbers in **A**. We could always use a standard map for this, but since the range of numbers is so small and **0-indexed**, it makes more sense to use an **array** instead.\\n\\nAfter we\\'ve iterated through **A** and filled our number map (**nmap**) with the number frequencies, we can get down to the real work. The normal approach here would be to figure out the distinct numbers available and use nested loops to attempt every possible permutation. But rather than doing this, which would require many array calls, we can again take advantage of the fact that the number range is so small.\\n\\nWe can iterate through every possible permutation from **[0,100]**, regardless of wheter the numbers are in **A**. Since we\\'ve made a frequency map, those numbers will be represented as **0**\\'s, which will handily prevent anything from being added to our answer (**ans**) for permutations that we can\\'t make, and by using simple math instead of many array calls, we can actually be more performant.\\n\\nStill, there are ways to streamline this process. The basic approach will be to use a **2-pointer system** to find two of our values and then mathematically figure the third, before applying the proper permutation formula to the values.\\n\\nIt should be apparent that our largest value (**k**) can never go above the target (**T**), nor can it obviously go above the max value of **100**, so we can start it out at **min(T, 100)** and decrement from there. Also, since it will always represents the largest of the three values, it can never go below **T / 3**, because then the two smaller numbers would never be able to bring it up to **T**.\\n\\nMoving down to the next value (**j**), we can see that it can never be larger than **k** by definition, nor can it be larger than the remaining amount of space (**rem**) left to **T**, so we should start it at **min(rem, k)**. Similar to **k**, **j** can also never go below **rem / 2**.\\n\\nOnce we have two of the three values, we can check for their frequencies. If any of them are **0**\\'s, then it will automatically make the result of its permutation check a **0** as well. We can also potentially save some processing by checking for **0**\\'s and **continuing** before applying the combinatorics formulas.\\n\\nIf **i == k**, then we know that **i == j == k** because **j** has to be between **i** and **k**, so we\\'ll have to use the **n choose 3** formula. We should also check if any two other values are the same, then we should use **(n choose 2) * (n choose 1)**. Otherwise, we can just use the simple combinations formula.\\n\\nThen it\\'s important to remember to apply the **modulo** before **returning**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript was actually faster with an approach that featured isolating the actual distinct elements, sorting them, and then running efficiently through the combinations, but the code was much longer and more complex. This method is much easier and nearly as fast. In either case, we should use a typed array here for the arraymap.\\n\\nJava was oddly slower at the iteration shortcuts and actually ran faster without the added processes.\\n\\nJava and C++ should use **long** for their **ans** (prior to returning it, at least), and even for **nmap**, otherwise we\\'ll have to cast those values to **long** each time anyway.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 80%).\\n```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **60ms / 14.2MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.3MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.2MB** (beats 99% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123400,
                "title": "python-dp",
                "content": "We can solve using dynamic programming and a hash table. \\n \\n The hash table is called `level2`. Suppose that we are at index `i` such that `i>2`. We consider all possible sums ending at `i` (a repeating pattern in many problems). `level2[x]` is the number of distinct pairs that sum to `x`. How do we get the distinct pairs? Consider all pairs ending at index `j` such that `0 <= j < i`. One trick is, we can find all pairs ending at index `i-1` when we are looping for `i`. This eliminates looping from the beginning each time, and everything can be done with two nested loops.\\n \\n Time: `O(N^2)`\\n Space: `O(N)`\\n\\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, t):\\n        ans = 0\\n        n = len(A)\\n        level2 = collections.defaultdict(int)\\n        for i in range(2, n):\\n            for j in range(i-1):\\n                level2[A[j] + A[i-1]] += 1\\n            ans = ans + level2[t - A[i]]\\n            ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumMulti(self, A, t):\\n        ans = 0\\n        n = len(A)\\n        level2 = collections.defaultdict(int)\\n        for i in range(2, n):\\n            for j in range(i-1):\\n                level2[A[j] + A[i-1]] += 1\\n            ans = ans + level2[t - A[i]]\\n            ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181089,
                "title": "dp-python",
                "content": "* Let `d1` track the count of single elements seen so far\n* Let `d2` track the count of the sum of any two elements seen so far\n* Given a new value `n`, the number of 3-sums equal to target is `d2[target-n]`\n* update `d2`, then `d1`\n```\n class Solution(object):\n     def threeSumMulti(self, A, target):\n         \"\"\"\n         :type A: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         d1=collections.defaultdict(int)\n         d2=collections.defaultdict(int)\n\n         N=len(A)\n         MOD=10**9+7\n         cnt = 0\n         for i in range(N-1,-1,-1):\n             n=A[i]\n             cnt+=d2[target-n]\n             cnt%=MOD\n             for (nn, nncnt) in d1.iteritems():\n                 d2[nn+n]+=nncnt\n\n             d1[n]+=1\n\n         return cnt\n```\n",
                "solutionTags": [],
                "code": "```\n class Solution(object):\n     def threeSumMulti(self, A, target):\n         \"\"\"\n         :type A: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         d1=collections.defaultdict(int)\n         d2=collections.defaultdict(int)\n\n         N=len(A)\n         MOD=10**9+7\n         cnt = 0\n         for i in range(N-1,-1,-1):\n             n=A[i]\n             cnt+=d2[target-n]\n             cnt%=MOD\n             for (nn, nncnt) in d1.iteritems():\n                 d2[nn+n]+=nncnt\n\n             d1[n]+=1\n\n         return cnt\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918476,
                "title": "c-2-pointer-simple-implementation-approach-similar-to-3-sum-problem",
                "content": "\\n```\\n int threeSumMulti(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        // two pointer approach \\n\\t\\t\\n        long long mod=1e9+7;\\n\\t\\t\\n        int n=nums.size();\\n\\t\\t\\n        int ans=0;\\n\\t\\t\\n        long long sum;\\n\\t\\t\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int l=i+1;\\n\\t\\t\\t\\n            int r=n-1;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[i]+nums[r];\\n             \\n                if(sum==target)\\n                {\\n                      int count1=1;\\n                      int count2=1;\\n                    while(l<r && nums[l]==nums[l+1])\\n                    {\\n                        l++;\\n                        count1++;\\n                    }\\n                    \\n                    while(l<r && nums[r]==nums[r-1])\\n                    {\\n                        r--;\\n                        count2++;\\n                    }\\n                                           \\n                    if(l==r)         \\n                    {                                  \\n                        ans = (ans%mod + (count1%mod *(count1-1)%mod)/2)%mod;\\n                    }\\n                    \\n                    if(l!=r)\\n                    {\\n                        ans = (ans%mod + (count1%mod* count2%mod)%mod)%mod;\\t \\n                    }**\\n                    \\n                    l++;\\n                    r--;\\n                }\\n                else\\n                {\\n                    if(sum>target)\\n                    {\\n                        r--;\\n                    }\\n                    else\\n                    {\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n int threeSumMulti(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        // two pointer approach \\n\\t\\t\\n        long long mod=1e9+7;\\n\\t\\t\\n        int n=nums.size();\\n\\t\\t\\n        int ans=0;\\n\\t\\t\\n        long long sum;\\n\\t\\t\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int l=i+1;\\n\\t\\t\\t\\n            int r=n-1;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[i]+nums[r];\\n             \\n                if(sum==target)\\n                {\\n                      int count1=1;\\n                      int count2=1;\\n                    while(l<r && nums[l]==nums[l+1])\\n                    {\\n                        l++;\\n                        count1++;\\n                    }\\n                    \\n                    while(l<r && nums[r]==nums[r-1])\\n                    {\\n                        r--;\\n                        count2++;\\n                    }\\n                                           \\n                    if(l==r)         \\n                    {                                  \\n                        ans = (ans%mod + (count1%mod *(count1-1)%mod)/2)%mod;\\n                    }\\n                    \\n                    if(l!=r)\\n                    {\\n                        ans = (ans%mod + (count1%mod* count2%mod)%mod)%mod;\\t \\n                    }**\\n                    \\n                    l++;\\n                    r--;\\n                }\\n                else\\n                {\\n                    if(sum>target)\\n                    {\\n                        r--;\\n                    }\\n                    else\\n                    {\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181080,
                "title": "java-sorting-solution-o-n-2",
                "content": "The solution is similar to 3Sum problem (https://leetcode.com/submissions/detail/128547721/).\\nThe key is how to skip duplicate numbers:\\nCase 1: ```A[l] == A[r]```, the total possible answer is ```num * (num-1) / 2```, where ```num = r-l+1```.\\nCase 2: ```A[l] != A[r]```, find how many duplicates in the left-hand side (which is ```cntL```) and how many duplicates in the right-hand side (which is ```cntR```). Then, search for the next possible answers.\\n\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int mod = 1000000007;\\n        int ans = 0;\\n        Arrays.sort(A);\\n        for(int i = 0; i < A.length-2; i++) {\\n            long cnt = 0;\\n            int l = i+1, r = A.length-1;\\n            while(l < r) {\\n                if(A[i] + A[l] + A[r] > target) r--;\\n                else if(A[i] + A[l] + A[r] < target) l++;\\n                else {\\n                    if(A[l] != A[r]) {\\n                        long cntL = 1, cntR = 1;\\n                        while(l+1 < r && A[l] == A[l+1]) { cntL++; l++; }\\n                        while(l < r-1 && A[r] == A[r-1]) { cntR++; r--; }\\n                        cnt += (cntL * cntR) % mod;\\n                        l++;\\n                        r--;\\n                    } else {\\n                        long n = r-l+1;\\n                        cnt += (n * (n-1) / 2) % mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans = (int) (ans + cnt) % mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime complexity: ```O(N^2)```\\nSpace complexity: ```O(1)```",
                "solutionTags": [],
                "code": "```A[l] == A[r]```\n```num * (num-1) / 2```\n```num = r-l+1```\n```A[l] != A[r]```\n```cntL```\n```cntR```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n        int mod = 1000000007;\\n        int ans = 0;\\n        Arrays.sort(A);\\n        for(int i = 0; i < A.length-2; i++) {\\n            long cnt = 0;\\n            int l = i+1, r = A.length-1;\\n            while(l < r) {\\n                if(A[i] + A[l] + A[r] > target) r--;\\n                else if(A[i] + A[l] + A[r] < target) l++;\\n                else {\\n                    if(A[l] != A[r]) {\\n                        long cntL = 1, cntR = 1;\\n                        while(l+1 < r && A[l] == A[l+1]) { cntL++; l++; }\\n                        while(l < r-1 && A[r] == A[r-1]) { cntR++; r--; }\\n                        cnt += (cntL * cntR) % mod;\\n                        l++;\\n                        r--;\\n                    } else {\\n                        long n = r-l+1;\\n                        cnt += (n * (n-1) / 2) % mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans = (int) (ans + cnt) % mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```O(N^2)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1918886,
                "title": "simple-java-solution-tc-o-n-2-6-lines-of-code-logic-extension-of-3-sum-problem-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        long count = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < n; i++) {\\n            //similar to two sum problem solution\\n            int new_target = target - arr[i];\\n            int start = i + 1;\\n            int end = n;\\n            HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n            \\n            for(int j = start; j < end; j++) {\\n                if(hm.get(new_target - arr[j]) != null) \\n                    count += hm.get(new_target - arr[j]);\\n                if(hm.get(arr[j]) != null)\\n                    hm.put(arr[j], hm.get(arr[j])+1);\\n                else\\n                    hm.put(arr[j], 1);\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        long count = 0;\\n        long mod = 1000000007;\\n        for(int i = 0; i < n; i++) {\\n            //similar to two sum problem solution\\n            int new_target = target - arr[i];\\n            int start = i + 1;\\n            int end = n;\\n            HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n            \\n            for(int j = start; j < end; j++) {\\n                if(hm.get(new_target - arr[j]) != null) \\n                    count += hm.get(new_target - arr[j]);\\n                if(hm.get(arr[j]) != null)\\n                    hm.put(arr[j], hm.get(arr[j])+1);\\n                else\\n                    hm.put(arr[j], 1);\\n            }\\n        }\\n        return (int)(count % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918460,
                "title": "easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Unordered map***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                int need = target - arr[i] - arr[j];\\n                \\n                count += mp[need];\\n            }\\n            \\n            count %= mod;\\n            \\n            mp[arr[i]]++;\\n        }\\n        \\n        return count % mod;\\n    }\\n```\\n\\n* ***Approach 2 : Using Sorting***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i <= n - 3; i++)\\n        {\\n            int low = i + 1;\\n            \\n            int high = n - 1;\\n            \\n            int need = target - arr[i];\\n            \\n            while(low < high)\\n            {\\n                if(arr[low] + arr[high] < need)\\n                {\\n                    low++;\\n                }\\n                \\n                else if(arr[low] + arr[high] > need)\\n                {\\n                    high--;\\n                }\\n                \\n                else\\n                {\\n                    if(arr[low] != arr[high])\\n                    {\\n                        int left_count = 1;\\n                        \\n                        int right_count = 1;\\n                        \\n                        while(low < high && arr[low] == arr[low + 1])\\n                        {\\n                            left_count++;\\n                            \\n                            low++;\\n                        }\\n                        \\n                        while(high > low && arr[high] == arr[high - 1])\\n                        {\\n                            right_count++;\\n                            \\n                            high--; \\n                        }\\n                        \\n                        count = (count % mod + left_count % mod * right_count % mod) % mod;\\n                        \\n                        low++;\\n                        \\n                        high--;\\n                    }\\n                    \\n                    else\\n                    {\\n                        int total_duplicate = (high - low + 1);\\n                        \\n                        count = (count % mod + (total_duplicate % mod * (total_duplicate - 1) % mod) / 2) % mod;\\n                        \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                int need = target - arr[i] - arr[j];\\n                \\n                count += mp[need];\\n            }\\n            \\n            count %= mod;\\n            \\n            mp[arr[i]]++;\\n        }\\n        \\n        return count % mod;\\n    }\\n```\n```\\n    long long mod = 1e9 + 7;\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i <= n - 3; i++)\\n        {\\n            int low = i + 1;\\n            \\n            int high = n - 1;\\n            \\n            int need = target - arr[i];\\n            \\n            while(low < high)\\n            {\\n                if(arr[low] + arr[high] < need)\\n                {\\n                    low++;\\n                }\\n                \\n                else if(arr[low] + arr[high] > need)\\n                {\\n                    high--;\\n                }\\n                \\n                else\\n                {\\n                    if(arr[low] != arr[high])\\n                    {\\n                        int left_count = 1;\\n                        \\n                        int right_count = 1;\\n                        \\n                        while(low < high && arr[low] == arr[low + 1])\\n                        {\\n                            left_count++;\\n                            \\n                            low++;\\n                        }\\n                        \\n                        while(high > low && arr[high] == arr[high - 1])\\n                        {\\n                            right_count++;\\n                            \\n                            high--; \\n                        }\\n                        \\n                        count = (count % mod + left_count % mod * right_count % mod) % mod;\\n                        \\n                        low++;\\n                        \\n                        high--;\\n                    }\\n                    \\n                    else\\n                    {\\n                        int total_duplicate = (high - low + 1);\\n                        \\n                        count = (count % mod + (total_duplicate % mod * (total_duplicate - 1) % mod) / 2) % mod;\\n                        \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497109,
                "title": "python-hashmap-solution-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: HashMap**\\n```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        n, MOD = len(arr), 10**9+7\\n        ans = 0\\n        seen = defaultdict(int)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                complement = target - arr[i] - arr[j]\\n                if complement in seen:\\n                    ans = (ans + seen[complement]) % MOD\\n            seen[arr[i]] += 1\\n        \\n        return ans\\n```\\nComplexity:\\n- Time: `O(N^2)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        n, MOD = len(arr), 10**9+7\\n        ans = 0\\n        seen = defaultdict(int)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                complement = target - arr[i] - arr[j]\\n                if complement in seen:\\n                    ans = (ans + seen[complement]) % MOD\\n            seen[arr[i]] += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123891,
                "title": "short-easy-w-explanation-o-n-2-o-n-m-2-beats-100",
                "content": "***Solution - I***\\n\\nWe can **sort the array and use a two pointer technique** on the sorted array. For each `i` in the sorted array, find two indices `j` and `k` (i < j < k) using 2-pointer such that `arr[j] + arr[k] = target - arr[i]`. Now, in a sorted array, duplicated `arr[j]` and `arr[k]` would appear consecutively. \\n\\nFor eg. Suppose we have target=4 and we are searching for `j` and `k` in subarray `[1,1,2,2,2,3,3,3]`. We find j can be 1st index and k can be last index. We pick up all elements equal to `arr[j]` (l=2) and `arr[k]` (r=3). A total of `l*r` will be added to the final count.\\n\\nWe also need to take care when `arr[j]` and `arr[k]` are the same element. In this case, a total of `(k-i) * (k-i+1)/2` has to be added. For eg. if we had a subarray `[2,2,2]` and needed to find such that `arr[j] + arr[k] = 4`, we would have 3 total pairs (`{0,1},{0,2},{1,2}`).\\n\\n**Note :** Sorting won\\'t affect our final answer. We just need to make sure that we choose 3 distinct elements from the array and the pair (i,j,k) is counted just once. Check for some array without and with sort and you would get the idea.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time Complexity :** **`O(N^2)`**, \\n**Space Complexity :** **`O(sort)`**, only extra space needed is the implict space used in sort.\\n\\n---------\\n---------\\n\\n***Solution - II***\\n\\nWe can notice that elements of the array can be at max `100`. We can use this to optimise the solution further.\\n\\nInstead of choosing one index and finding the other two indices using two-pointer as done in previous approach, we can choose each number from `0 to 100` and if it exists in array, find other two numbers.\\n\\nWe need to maintain a frequency array to do this efficiently. We will have following cases (here i,j,k denote value of array we are checking, not indices) - \\n\\n* `i = j = k` : Add `freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6` which is nothing but formula of number of ways to choose three distinct elements from n. \\n* `i = j != k` : Add `freq[k] + (freq[i] * (freq[i] - 1))/2` which denotes that number of `k`s and ways to choose 2 distinct elements from freq[i]\\n* `i != j = k` : Similar to above\\n* `i != j != k` : Just multiply all frequency to get the number of triplet possible.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time complexity :** `O(N + MAX^2)`, where `N` is the number of elemetns in `arr` and `MAX` is the maximum element of array.\\n**Space complexity :** `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/78e7c8d4-3227-43a4-a4be-4407041b7a42_1616509984.6405087.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123835,
                "title": "3sum-with-multiplicity-js-python-java-c-efficient-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to attempt all permutations, but that would run up to **2.7e10** attempts. The first important thing to notice is that the range of numbers is very small at **[0,100]**. With that few number options, any large input array (**A**) will have many duplicates, which means we\\'re looking at a **combinatorics** solution.\\n\\nIn order to use the combinatorics shortcut, however, we\\'ll first have to make a **frequency map** of the numbers in **A**. We could always use a standard map for this, but since the range of numbers is so small and **0-indexed**, it makes more sense to use an **array** instead.\\n\\nAfter we\\'ve iterated through **A** and filled our number map (**nmap**) with the number frequencies, we can get down to the real work. The normal approach here would be to figure out the distinct numbers available and use nested loops to attempt every possible permutation. But rather than doing this, which would require many array calls, we can again take advantage of the fact that the number range is so small.\\n\\nWe can iterate through every possible permutation from **[0,100]**, regardless of wheter the numbers are in **A**. Since we\\'ve made a frequency map, those numbers will be represented as **0**\\'s, which will handily prevent anything from being added to our answer (**ans**) for permutations that we can\\'t make, and by using simple math instead of many array calls, we can actually be more performant.\\n\\nStill, there are ways to streamline this process. The basic approach will be to use a **2-pointer system** to find two of our values and then mathematically figure the third, before applying the proper permutation formula to the values.\\n\\nIt should be apparent that our largest value (**k**) can never go above the target (**T**), nor can it obviously go above the max value of **100**, so we can start it out at **min(T, 100)** and decrement from there. Also, since it will always represents the largest of the three values, it can never go below **T / 3**, because then the two smaller numbers would never be able to bring it up to **T**.\\n\\nMoving down to the next value (**j**), we can see that it can never be larger than **k** by definition, nor can it be larger than the remaining amount of space (**rem**) left to **T**, so we should start it at **min(rem, k)**. Similar to **k**, **j** can also never go below **rem / 2**.\\n\\nOnce we have two of the three values, we can check for their frequencies. If any of them are **0**\\'s, then it will automatically make the result of its permutation check a **0** as well. We can also potentially save some processing by checking for **0**\\'s and **continuing** before applying the combinatorics formulas.\\n\\nIf **i == k**, then we know that **i == j == k** because **j** has to be between **i** and **k**, so we\\'ll have to use the **n choose 3** formula. We should also check if any two other values are the same, then we should use **(n choose 2) * (n choose 1)**. Otherwise, we can just use the simple combinations formula.\\n\\nThen it\\'s important to remember to apply the **modulo** before **returning**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript was actually faster with an approach that featured isolating the actual distinct elements, sorting them, and then running efficiently through the combinations, but the code was much longer and more complex. This method is much easier and nearly as fast. In either case, we should use a typed array here for the arraymap.\\n\\nJava was oddly slower at the iteration shortcuts and actually ran faster without the added processes.\\n\\nJava and C++ should use **long** for their **ans** (prior to returning it, at least), and even for **nmap**, otherwise we\\'ll have to cast those values to **long** each time anyway.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 80%).\\n```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **60ms / 14.2MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.3MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.2MB** (beats 99% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921963,
                "title": "2pointer-hashmap-solution-with-explanations-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Hashmap.***\\n- Here we\\u2019ll put all the possible combinations of pair sum into our hashmap.\\n- We\\u2019ll search for the number of pairs available that form up the target.\\n- Here **Target = arr[i] + sum of 2 numbers in hashmap.**\\n- In count, we\\u2019ll add all the pairs available of our new target (*after reducing current element from the target).*\\n- After adding the pairs to our answer variable count, we\\u2019ll put all the possible combinations of sum in our hashmap.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- Using ***Two pointers approach.***\\n- For this first, we\\u2019ve to sort the array.\\n- After sorting we\\u2019ll fix an index ***i*** and use 2pointers from [start=***i+1***] ******to [end=***n-1***]***.***\\n- While finding the target there could be 3 possible cases:\\n    1. ***The Sum of 2pointers is greater than our new target:*** `arr[start] + arr[end] > temp`\\n        - In this case, we\\u2019ll simply decrement our end pointer.\\n    2. ***The Sum of 2pointers is smaller than our new target:*** `arr[start] + arr[end] < temp`\\n        - In this case, we\\u2019ll simply increment our start pointer.\\n    3. ***The Sum of 2pointers is equal to our new target:*** `arr[start] + arr[end] == temp`\\n        - Here we\\u2019ve to find if any more element is equal to our start or end elements.\\n        - Take 2 variables: start count ***sc*** & end count ***ec.***\\n        - If `arr[start] == arr[start+1]`, we\\u2019ll increment ***sc*** & if `arr[end] == arr[end-1]`, we\\u2019ll increment ***ec.***\\n        - After getting the count for start and end variables if start & end became the same that means every element is similar. In this case, we\\u2019ll do ***nC2.*** 2 elements from n combinations, where n is the count of ***start*** or ***end*** (sc/ec).\\n        - Else, when start and end do not indicate the same element then we\\u2019ll multiply both start and end count and add it to our ans.\\n- **Time complexity:** O(n^2 + nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), mod = 1e9+7, count = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++){\\n            count = (count + mp[target - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++){\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int start, end, ans = 0, mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int temp = target - arr[i];\\n            start = i+1; \\n            end = n-1;\\n            \\n            while(start < end){\\n                if(arr[start] + arr[end] == temp){\\n                    long long sc = 1, ec = 1;\\n                    while(start < end && arr[start] == arr[start+1]){\\n                        start++;\\n                        sc++;\\n                    }\\n                    while(start < end && arr[end] == arr[end-1]){\\n                        end--;\\n                        ec++;\\n                    }\\n                    if(start == end){\\n                        long long temp = (sc*(sc-1))/2; //nC2\\n                        ans = (ans + temp) % mod;\\n                    }\\n                    else{\\n                        ans = ans + (sc*ec) % mod;\\n                    }\\n                    start++;\\n                    end--;\\n                } \\n                else if(arr[start] + arr[end] > temp) end--;\\n                else if(arr[start] + arr[end] < temp) start++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), mod = 1e9+7, count = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++){\\n            count = (count + mp[target - arr[i]]) % mod;\\n            \\n            for(int j=0; j<i; j++){\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int start, end, ans = 0, mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int temp = target - arr[i];\\n            start = i+1; \\n            end = n-1;\\n            \\n            while(start < end){\\n                if(arr[start] + arr[end] == temp){\\n                    long long sc = 1, ec = 1;\\n                    while(start < end && arr[start] == arr[start+1]){\\n                        start++;\\n                        sc++;\\n                    }\\n                    while(start < end && arr[end] == arr[end-1]){\\n                        end--;\\n                        ec++;\\n                    }\\n                    if(start == end){\\n                        long long temp = (sc*(sc-1))/2; //nC2\\n                        ans = (ans + temp) % mod;\\n                    }\\n                    else{\\n                        ans = ans + (sc*ec) % mod;\\n                    }\\n                    start++;\\n                    end--;\\n                } \\n                else if(arr[start] + arr[end] > temp) end--;\\n                else if(arr[start] + arr[end] < temp) start++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918580,
                "title": "easy-to-understand-with-explanation",
                "content": "\\narr[i] + arr[j] + arr[k] = target\\n(arr[i] + arr[j]) = (target - arr[k])\\nusing this formula we can easly understand \\nonly firslty we store the sum in the map and after we find the   (target - arr[k]) in the map \\nif find than answer +.\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\nif(isHelpfull)\\n(upvote);",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919422,
                "title": "c-solution-hashmap",
                "content": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                ans += mp[target-arr[i]-arr[j]];\\n            }\\n            ans =ans%1000000007;\\n            mp[arr[i]]++;\\n        }\\n        return ans%1000000007;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                ans += mp[target-arr[i]-arr[j]];\\n            }\\n            ans =ans%1000000007;\\n            mp[arr[i]]++;\\n        }\\n        return ans%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919126,
                "title": "c-100-simple-solution-o-1000",
                "content": "```\\n#define M (1e9 + 7)\\n\\nint threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0};\\n\\n    for (int i = 0; i < arrSize; i++)\\n        hash[arr[i]]++;\\n\\n    for (int i = 0; i <= 100; i++) {\\n        for (int j = i; j <= 100; j++) {\\n            int k = target - i - j;\\n            if (k < 0 || k > 100) \\n                continue;\\n            if (i < j && j < k)\\n                c += hash[i] * hash[j] * hash[k];\\n            else if (i == j && j == k)\\n                c += hash[i] * (hash[i] - 1) * (hash[i] - 2) / 6;\\n            else if (i == j && i != k)\\n                c += hash[i] * (hash[i] - 1) / 2 * hash[k];\\n        }\\n    }\\n    return (int)(c % (int)M);\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define M (1e9 + 7)\\n\\nint threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0};\\n\\n    for (int i = 0; i < arrSize; i++)\\n        hash[arr[i]]++;\\n\\n    for (int i = 0; i <= 100; i++) {\\n        for (int j = i; j <= 100; j++) {\\n            int k = target - i - j;\\n            if (k < 0 || k > 100) \\n                continue;\\n            if (i < j && j < k)\\n                c += hash[i] * hash[j] * hash[k];\\n            else if (i == j && j == k)\\n                c += hash[i] * (hash[i] - 1) * (hash[i] - 2) / 6;\\n            else if (i == j && i != k)\\n                c += hash[i] * (hash[i] - 1) / 2 * hash[k];\\n        }\\n    }\\n    return (int)(c % (int)M);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123543,
                "title": "python-3-steps-o-n-w",
                "content": "# Idea\\nThe idea is to keep counting the number of elements we have seen so far and keep `ones` and `twos` counters, which correspond to the number of ways given values can be constructed (as a sum) using one and two array elements respectively. So, we iterate over an array and do the following three steps as a pipeline:\\n1. Update the total count by looking up the number of two-sums (`twos`) that if you add current value to would give you `target`.\\n2. Update the number of twosums (`twos`) by looking at the numbers that have appeared before (`ones`).\\n3. Update the counts of numbers that have appeared before (`ones`).\\n\\n# Complexity\\nTime: O(NW), where N is the length of the array and W the number of unique numbers in our array (<= 100 in problem definition).\\nMemory: O(W^2) because of twosum dictionary\\n```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n\\ttotal = 0\\n\\tmod = 10 ** 9 + 7\\n\\n\\tones = defaultdict(int)\\n\\ttwos = defaultdict(int)\\n\\n\\tfor t, v in enumerate(arr):  # O(N)\\n\\t\\ttotal = (total + twos[target - v]) % mod\\n\\t\\tfor k, c in ones.items():  # O(W)\\n\\t\\t\\ttwos[k+v] += c\\n\\t\\tones[v] += 1\\n\\n\\treturn total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n\\ttotal = 0\\n\\tmod = 10 ** 9 + 7\\n\\n\\tones = defaultdict(int)\\n\\ttwos = defaultdict(int)\\n\\n\\tfor t, v in enumerate(arr):  # O(N)\\n\\t\\ttotal = (total + twos[target - v]) % mod\\n\\t\\tfor k, c in ones.items():  # O(W)\\n\\t\\t\\ttwos[k+v] += c\\n\\t\\tones[v] += 1\\n\\n\\treturn total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1919905,
                "title": "java-with-full-code-explanation-3-pointers",
                "content": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        //mod number\\n        int mod = 1000000007;\\n        \\n        //stores the result count\\n        int count = 0;\\n        \\n        //sorting the array\\n        Arrays.sort(arr);\\n        \\n        //outer loop for first element\\n        for (int index = 0; index < arr.length - 2; index++) {\\n            \\n            //second element\\n            int start = index + 1;\\n            \\n            //third element\\n            int end = arr.length - 1;\\n            \\n            //two pointer approach to find a sum\\n            while (start < end) {\\n                \\n                //if target is found\\n                if (arr[start] + arr[end] + arr[index] == target) {\\n                    \\n                    //special case when we are at the ends of the same number\\n                    // Ex: [...1,2,2,2,2,2]\\n                    //           ^       ^\\n                    //for this we calculate the number of all possible combinations we can make to pick 2 elements i.e. nC2\\n                    if (arr[start] == arr[end]) {\\n                        count += nCr(end - start + 1);\\n                        count %= mod;\\n                        \\n                        //we have already evaluated all combinations for this index\\n                        break;\\n                    }\\n                    \\n                    //general case \\n                    // Ex: [...1,2,2,2,3,4,4]\\n                    //           ^         ^\\n                    // we have to find out all possible 2\\'s and 4\\'s we can make \\n                    // we store them as i and j for start and end pointers respectively\\n                    // for above ex, i=3 and j=2\\n                    // hence total combinations are i*j = 6\\n                    int i = 1, j = 1;\\n                    while (start + 1 < end && arr[start] == arr[start + 1]) {\\n                        start++;\\n                        i++;\\n                    }\\n                    while (start + 1 < end && arr[end] == arr[end - 1]) {\\n                        end--;\\n                        j++;\\n                    }\\n                    count += (i * j);\\n                    count %= mod;\\n                    \\n                    //general condition for 2Sum when target is found\\n                    start++;end--;                  \\n                } else if (arr[start] + arr[end] + arr[index] > target) end--;\\n                else start++;\\n            }\\n        }\\n        return count % mod;\\n    }\\n    \\n    // function to return nC2\\n    private static int nCr(int n) {\\n        return n * (n - 1) / 2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        //mod number\\n        int mod = 1000000007;\\n        \\n        //stores the result count\\n        int count = 0;\\n        \\n        //sorting the array\\n        Arrays.sort(arr);\\n        \\n        //outer loop for first element\\n        for (int index = 0; index < arr.length - 2; index++) {\\n            \\n            //second element\\n            int start = index + 1;\\n            \\n            //third element\\n            int end = arr.length - 1;\\n            \\n            //two pointer approach to find a sum\\n            while (start < end) {\\n                \\n                //if target is found\\n                if (arr[start] + arr[end] + arr[index] == target) {\\n                    \\n                    //special case when we are at the ends of the same number\\n                    // Ex: [...1,2,2,2,2,2]\\n                    //           ^       ^\\n                    //for this we calculate the number of all possible combinations we can make to pick 2 elements i.e. nC2\\n                    if (arr[start] == arr[end]) {\\n                        count += nCr(end - start + 1);\\n                        count %= mod;\\n                        \\n                        //we have already evaluated all combinations for this index\\n                        break;\\n                    }\\n                    \\n                    //general case \\n                    // Ex: [...1,2,2,2,3,4,4]\\n                    //           ^         ^\\n                    // we have to find out all possible 2\\'s and 4\\'s we can make \\n                    // we store them as i and j for start and end pointers respectively\\n                    // for above ex, i=3 and j=2\\n                    // hence total combinations are i*j = 6\\n                    int i = 1, j = 1;\\n                    while (start + 1 < end && arr[start] == arr[start + 1]) {\\n                        start++;\\n                        i++;\\n                    }\\n                    while (start + 1 < end && arr[end] == arr[end - 1]) {\\n                        end--;\\n                        j++;\\n                    }\\n                    count += (i * j);\\n                    count %= mod;\\n                    \\n                    //general condition for 2Sum when target is found\\n                    start++;end--;                  \\n                } else if (arr[start] + arr[end] + arr[index] > target) end--;\\n                else start++;\\n            }\\n        }\\n        return count % mod;\\n    }\\n    \\n    // function to return nC2\\n    private static int nCr(int n) {\\n        return n * (n - 1) / 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1919461,
                "title": "python-3-solution-golang-solution-hashmap-3sum-approach",
                "content": "### Python\\n```py\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        mp, res = {}, 0\\n        for i in range(len(arr)-1):\\n            for j in range(i+1, len(arr)):\\n                diff = target - (arr[i] + arr[j])\\n                res += mp[diff] if diff in mp else 0\\n            \\n            mp[arr[i]] = mp.get(arr[i], 0) + 1\\n            \\n        return res % int(1e9 + 7)\\n```\\n\\n### GoLang [Faster than 93%]\\n```go\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    var mp map[int]int = map[int]int{0: 0}\\n    var res int\\n    \\n    for i := 0; i < len(arr)-1; i++ {\\n        for j := i+1; j < len(arr); j++ {\\n            diff := target - (arr[i] + arr[j])\\n            res += mp[diff]\\n        }\\n        mp[arr[i]]++\\n    }\\n    return res % int(1e9 + 7)\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```py\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        mp, res = {}, 0\\n        for i in range(len(arr)-1):\\n            for j in range(i+1, len(arr)):\\n                diff = target - (arr[i] + arr[j])\\n                res += mp[diff] if diff in mp else 0\\n            \\n            mp[arr[i]] = mp.get(arr[i], 0) + 1\\n            \\n        return res % int(1e9 + 7)\\n```\n```go\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    var mp map[int]int = map[int]int{0: 0}\\n    var res int\\n    \\n    for i := 0; i < len(arr)-1; i++ {\\n        for j := i+1; j < len(arr); j++ {\\n            diff := target - (arr[i] + arr[j])\\n            res += mp[diff]\\n        }\\n        mp[arr[i]]++\\n    }\\n    return res % int(1e9 + 7)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129130,
                "title": "c-identical-to-3-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD=1e9+7;\\n        unordered_map<int,int> um;\\n        long ans=0;\\n        int n=arr.size();\\n        \\n        //Storing frequency in hashtable\\n        for(int i=0;i<n;i++){\\n            um[arr[i]]++;\\n        }\\n        \\n        //Sorting as order won\\'t matter (Think deeply)\\n        sort(arr.begin(),arr.end());\\n        \\n        int i=0;\\n        \\n        while(i<n){ //Will increment i inside loop\\n            int low=i+1,high=n-1;\\n            \\n            while(low<high){\\n                \\n                //Three elements are arr[i] , arr[low] and arr[high]\\n                int sum=arr[i]+arr[low]+arr[high];\\n                \\n                if(sum==target){\\n                   \\n                    //Case 1 : All three elements are same\\n                    if(arr[i]==arr[low] && arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=(count)*(count-1)*(count-2)/6;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 2 : Any two elements are same \\n                    else if(arr[i]==arr[low]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[low]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[low]==arr[high]){\\n                        long count=um[arr[low]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[i]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 3: All elements are unique\\n                    else{\\n                        long count=((um[arr[i]]*um[arr[low]])%MOD * um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Incrementing low in tricky way to avoid duplication\\n                    low=low+1;\\n                    while(low<high && arr[low]==arr[low-1]){\\n                        low++;\\n                    }\\n                }\\n                else if(sum<target){\\n                    low++;\\n                }\\n                else{\\n                    high--;\\n                }\\n            }\\n\\t\\t\\t\\n            int j=i+1;           //Increment i accordingly\\n            while(j<n && arr[j]==arr[i]){\\n                j++;\\n            }\\n            \\n            i=j;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(n^2)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD=1e9+7;\\n        unordered_map<int,int> um;\\n        long ans=0;\\n        int n=arr.size();\\n        \\n        //Storing frequency in hashtable\\n        for(int i=0;i<n;i++){\\n            um[arr[i]]++;\\n        }\\n        \\n        //Sorting as order won\\'t matter (Think deeply)\\n        sort(arr.begin(),arr.end());\\n        \\n        int i=0;\\n        \\n        while(i<n){ //Will increment i inside loop\\n            int low=i+1,high=n-1;\\n            \\n            while(low<high){\\n                \\n                //Three elements are arr[i] , arr[low] and arr[high]\\n                int sum=arr[i]+arr[low]+arr[high];\\n                \\n                if(sum==target){\\n                   \\n                    //Case 1 : All three elements are same\\n                    if(arr[i]==arr[low] && arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=(count)*(count-1)*(count-2)/6;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 2 : Any two elements are same \\n                    else if(arr[i]==arr[low]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[i]==arr[high]){\\n                        long count=um[arr[i]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[low]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    else if(arr[low]==arr[high]){\\n                        long count=um[arr[low]];\\n                        count=((count)*(count-1))%MOD/2;\\n                        count=(count*um[arr[i]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Case 3: All elements are unique\\n                    else{\\n                        long count=((um[arr[i]]*um[arr[low]])%MOD * um[arr[high]])%MOD;\\n                        ans=(ans+count)%MOD;\\n                    }\\n                    \\n                    //Incrementing low in tricky way to avoid duplication\\n                    low=low+1;\\n                    while(low<high && arr[low]==arr[low-1]){\\n                        low++;\\n                    }\\n                }\\n                else if(sum<target){\\n                    low++;\\n                }\\n                else{\\n                    high--;\\n                }\\n            }\\n\\t\\t\\t\\n            int j=i+1;           //Increment i accordingly\\n            while(j<n && arr[j]==arr[i]){\\n                j++;\\n            }\\n            \\n            i=j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123718,
                "title": "c-solution-base-on-3-sum-and-2-sum-approach",
                "content": "For each element we run the two sum approach for remaining elements.\\nTwo sum approach -\\nThe basic idea is to maintain a hash table for each element num in nums, using num as key and its number of times it appear as value. For each num, search for target - num in the hash table. If it is found we add it to the answer.\\n\\nThe code is as follows. Note that each time before we add count of a number to m, we search for target - num first and if it is >=0 then add it to the answer.\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long ans=0;\\n        int n = arr.size();\\n        vector<int> m(305,0);\\n        for(int i=0;i<n;i++){\\n            for(int i=0;i<305;i++) m[i]=0;\\n            for(int j=i+1;j<n;j++){\\n                long req = target - arr[i]-arr[j];\\n                if(req>=0) ans+=m[req];\\n                m[arr[j]]++;\\n            }\\n        }\\n        return (int)(ans%(1000000007));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long ans=0;\\n        int n = arr.size();\\n        vector<int> m(305,0);\\n        for(int i=0;i<n;i++){\\n            for(int i=0;i<305;i++) m[i]=0;\\n            for(int j=i+1;j<n;j++){\\n                long req = target - arr[i]-arr[j];\\n                if(req>=0) ans+=m[req];\\n                m[arr[j]]++;\\n            }\\n        }\\n        return (int)(ans%(1000000007));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920150,
                "title": "python-a-general-solution-dynamic-programming",
                "content": "Given an integer array`arr`, and an integer`target`, return the number of tuples`i, j, k`such that`i < j < k`and`arr[i] + arr[j] + arr[k] == target`.\\n\\nAs the answer can be very large, return it **modulo** `10^9 + 7`.\\n\\n## Violent Solution\\n\\n```python\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nfor i in range(n - 2):\\n    if arr[i] > target:\\n        continue\\n    for j in range(i + 1, n - 1):\\n        if arr[j] + arr[i] > target:\\n            continue\\n        for k in range(j + 1, n):\\n            if arr[i] + arr[j] + arr[k] == target:\\n                output += 1\\n                \\n    output %= mode\\n    \\nreturn int(output)\\n```\\n\\nViolent solution is the simplest, but the running time exceeds the limit.\\n\\n## Math Solution\\n\\nThe answer of this question is the number of combinations, we can solve it by sampling.\\n\\nFirst, group the array `arr` and sorted.\\n\\n```python\\nfrom collections import Counter\\n\\ngroups = Counter(arr)\\n\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n```\\n\\nThen, get all possible combinations.\\n\\n```python\\nn = len(sorted_group)\\n\\ncombinations = []\\n\\nfor i in range(n):\\n    for j in range(n):\\n        for k in range(n):\\n            if i + j + k == target:\\n                combinations.append((i, j, k))\\n```\\n\\nFinally, get the final result. There are three situations should be considered.\\n\\nSuppose `a`, `b`, `c` is a combination in `combinations`. Suppose `x`, `y`, `z` are corresponding times. We can get:\\n1. if `a == b == c`, we can get $C_{x}^{3}$ tuples;\\n2. if `a == b != c` or `a == c != b` or `b == c != a`, we can get $C_{x}^{2} \\\\cdot z$ or $C_{x}^{2} \\\\cdot y$ or $C_{y}^{2} \\\\cdot x$ tuples;\\n3. if `a != b != c`, we can get $x \\\\cdot y \\\\cdot z$ tuples.\\n\\n```python\\ndef get_solution_num(a, b, c, x, y, z):\\n    # The input has been sorted: a <= b <= c\\n    if a == b:\\n        if b == c:\\n            return x * (x - 1) * (x - 2) / 6\\n        else:\\n            return x * (x - 1) / 2 * z\\n    elif b == c:\\n        return x * y * y / 2\\n    else:\\n        return x * y * z\\n```\\n\\nThe full code of this solution:\\n```python\\nfrom collections import Counter\\n\\nmode = 1e9 + 7\\noutput = 0\\n\\ngroups = Counter(arr)\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n\\nn = len(sorted_group)\\nfor i in range(n):\\n    for j in range(i, n):\\n        sum2 = sorted_group[i][0] + sorted_group[j][0]\\n        remain = target - sum2\\n        for k in range(j, n):\\n            if sorted_group[k][0] == remain:\\n                if i == j:\\n                    if j == k:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * (sorted_group[i][1] - 2) / 6\\n                    else:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * sorted_group[k][1] / 2\\n                else:\\n                    if j == k:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * (sorted_group[j][1] - 1) / 2\\n                    else:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * sorted_group[k][1]\\n                            \\nreturn int(output % mode)\\n```\\n\\n## General Solution: Dynamic Programming\\n\\nWe can solve this problem in 3 steps.\\n\\n### First - 2Sum - Fixed `a`\\n\\nWe first solve a 2Sum problem. Given a number `a` and target `m`, try to find the frequence of `b` in an array `arr`, which satisfies `a + b = m`.\\n\\nThe solution of this problem is simple:\\n```python\\nb = m - a\\noutput = 0\\n\\nfor i in range(n):\\n    if arr[i] == b:\\n        output += 1\\n        \\nreturn output\\n```\\n\\n### Second - 2Sum - Dynamic `a`\\n\\nThe second problem is: given an array `arr` and target `m`, try to find the number of combinations `(a, b)`, which satisfies `a + b = m`.\\n\\nSuppose the frequence of `a` is `x` when the index is `i`. If the value of index `i + 1` is `b` and `a+b=m`, the number of tuple `(a, b)` is `x` for the array `arr[:i+1]`\\n\\nSo, the solution of this problem can be:\\n```python\\nfrom collections import defaultdict\\n\\ntemp = defaultdict(int)\\noutput = 0\\n\\ntemp[arr[0]] = 1\\nfor i in range(1, n):\\n    for j in temp:\\n        if arr[i] + j == m:\\n            output += temp[j]\\n            break\\n    temp[arr[i]] += 1\\n    \\nreturn output\\n```\\n\\n### Third - 3Sum -Dynamic `a` and `b`\\n\\nFirst, suppose the frequence of `d` is `x` when the index is `i`. If the value of index `i+1` is `c` and `d + c = m`, the number of tuple `(d, c)` is `x` for the array `arr[:i+1]`.\\n\\nThen, the problem become a 2Sum problem: given an array `arr[:i]` and target `d`, try to find the number of tuples `(a, b)`, which satisfies `a + b = d`.\\n\\nSo, the solution of this problem can be:\\n\\n```python\\nfrom collections import defaultdict\\n\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nl1 = defaultdict(int)\\nl2 = defaultdict(int)\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n\\n    for z in l2:\\n        if x + z == target:\\n            output += l2[z]\\n            output %= mode\\n\\n    for y in l1:\\n        if x + y > target:\\n            continue\\n\\n        l2[x + y] += l1[y]\\n\\n    l1[x] += 1\\n\\nreturn int(output)\\n```\\n\\n### Extention: n-Sum\\n\\nWe can extend this problem to nSum: Given an integer array `arr` and the `target`, return the number of tuples `a1, a2, ..., an`, such that `a1 + a2 + \\u2026 + an = target` and `a1 < a2 < ... < an`.\\n\\nThe solution can be:\\n```python\\nfrom collections import defaultdict\\n\\ntotal = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nlevels = [defaultdict(int) for _ in range(n - 1)]\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n        \\n    for i in range(n - 2, 0, -1):\\n        if i == n - 2:\\n            for j in levels[i]:\\n                if x + j == target:\\n                    output += levels[i][j]\\n                    output %= mode\\n        else:\\n            for j in levels[i]:\\n                if x + j > target:\\n                    continue\\n                levels[i + 1][x + j] += levels[i][j]\\n                \\n    levels[0][x] += 1\\n    \\nreturn int(output)\\n```\\n\\nWhen `n=3`, it is also the solution of problem 923 in LeetCode.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nfor i in range(n - 2):\\n    if arr[i] > target:\\n        continue\\n    for j in range(i + 1, n - 1):\\n        if arr[j] + arr[i] > target:\\n            continue\\n        for k in range(j + 1, n):\\n            if arr[i] + arr[j] + arr[k] == target:\\n                output += 1\\n                \\n    output %= mode\\n    \\nreturn int(output)\\n```\n```python\\nfrom collections import Counter\\n\\ngroups = Counter(arr)\\n\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n```\n```python\\nn = len(sorted_group)\\n\\ncombinations = []\\n\\nfor i in range(n):\\n    for j in range(n):\\n        for k in range(n):\\n            if i + j + k == target:\\n                combinations.append((i, j, k))\\n```\n```python\\ndef get_solution_num(a, b, c, x, y, z):\\n    # The input has been sorted: a <= b <= c\\n    if a == b:\\n        if b == c:\\n            return x * (x - 1) * (x - 2) / 6\\n        else:\\n            return x * (x - 1) / 2 * z\\n    elif b == c:\\n        return x * y * y / 2\\n    else:\\n        return x * y * z\\n```\n```python\\nfrom collections import Counter\\n\\nmode = 1e9 + 7\\noutput = 0\\n\\ngroups = Counter(arr)\\nsorted_group = sorted(groups.items(), key=lambda x: x[0])\\n\\nn = len(sorted_group)\\nfor i in range(n):\\n    for j in range(i, n):\\n        sum2 = sorted_group[i][0] + sorted_group[j][0]\\n        remain = target - sum2\\n        for k in range(j, n):\\n            if sorted_group[k][0] == remain:\\n                if i == j:\\n                    if j == k:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * (sorted_group[i][1] - 2) / 6\\n                    else:\\n                        output += sorted_group[i][1] * (sorted_group[i][1] - 1) * sorted_group[k][1] / 2\\n                else:\\n                    if j == k:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * (sorted_group[j][1] - 1) / 2\\n                    else:\\n                        output += sorted_group[i][1] * sorted_group[j][1] * sorted_group[k][1]\\n                            \\nreturn int(output % mode)\\n```\n```python\\nb = m - a\\noutput = 0\\n\\nfor i in range(n):\\n    if arr[i] == b:\\n        output += 1\\n        \\nreturn output\\n```\n```python\\nfrom collections import defaultdict\\n\\ntemp = defaultdict(int)\\noutput = 0\\n\\ntemp[arr[0]] = 1\\nfor i in range(1, n):\\n    for j in temp:\\n        if arr[i] + j == m:\\n            output += temp[j]\\n            break\\n    temp[arr[i]] += 1\\n    \\nreturn output\\n```\n```python\\nfrom collections import defaultdict\\n\\nn = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nl1 = defaultdict(int)\\nl2 = defaultdict(int)\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n\\n    for z in l2:\\n        if x + z == target:\\n            output += l2[z]\\n            output %= mode\\n\\n    for y in l1:\\n        if x + y > target:\\n            continue\\n\\n        l2[x + y] += l1[y]\\n\\n    l1[x] += 1\\n\\nreturn int(output)\\n```\n```python\\nfrom collections import defaultdict\\n\\ntotal = len(arr)\\nmode = 1e9 + 7\\noutput = 0\\n\\nlevels = [defaultdict(int) for _ in range(n - 1)]\\n\\nfor x in arr:\\n    if x > target:\\n        continue\\n        \\n    for i in range(n - 2, 0, -1):\\n        if i == n - 2:\\n            for j in levels[i]:\\n                if x + j == target:\\n                    output += levels[i][j]\\n                    output %= mode\\n        else:\\n            for j in levels[i]:\\n                if x + j > target:\\n                    continue\\n                levels[i + 1][x + j] += levels[i][j]\\n                \\n    levels[0][x] += 1\\n    \\nreturn int(output)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1919678,
                "title": "java-3-pointers-explained",
                "content": "**Idea:**\\n* Find frequency of each num in arr\\n* Create an array of unique nums in arr and sort this array\\n* Now use the same 3 pointers technique used in [LC 15. 3Sum](https://leetcode.com/problems/3sum/discuss/339850/Java-or-Two-pointers-or-Time-beats-100-or-Memory-beats-93)\\n* You\\'ll also need to used the following combinatorial logic for counting the triplets\\n\\n![image](https://assets.leetcode.com/users/images/5475e97e-9af2-4c6e-ac61-fc9a9a78fe3e_1649247866.065716.png)\\n\\n>**T/S:** O(n + w\\xB2)/O(w), where n = size(arr), w = max(arr)\\n```\\nprivate static final int MOD = (int) (1e9 + 7);\\n\\npublic int threeSumMulti(int[] arr, int target) {\\n\\tvar count = getNumToFrequency(arr);\\n\\tvar nums = getUnique(count);\\n\\tvar triplets = 0L;\\n\\n\\tfor (int i = 0, n = nums.length; i < n; i++)\\n\\t\\tfor (int j = i, k = n - 1; j <= k; ) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\tif (i == j && j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * (count.get(nums[k]) - 2) / 6;\\n\\t\\t\\t\\telse if (i == j || j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * count.get(nums[k]) / 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * count.get(nums[j]) * count.get(nums[k]);\\n\\n\\t\\t\\t\\ttriplets %= MOD;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn (int) triplets;\\n}\\n\\nprivate Map<Integer, Integer> getNumToFrequency(int[] arr) {\\n\\tvar numToFrequency = new HashMap<Integer, Integer>();\\n\\tfor (var num : arr)\\n\\t\\tnumToFrequency.compute(num, (k, v) -> v == null ? 1 : ++v);\\n\\treturn numToFrequency;\\n}\\n\\nprivate Integer[] getUnique(Map<Integer, Integer> count) {\\n\\tvar nums = count.keySet().toArray(new Integer[0]);\\n\\tArrays.sort(nums);\\n\\treturn nums;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final int MOD = (int) (1e9 + 7);\\n\\npublic int threeSumMulti(int[] arr, int target) {\\n\\tvar count = getNumToFrequency(arr);\\n\\tvar nums = getUnique(count);\\n\\tvar triplets = 0L;\\n\\n\\tfor (int i = 0, n = nums.length; i < n; i++)\\n\\t\\tfor (int j = i, k = n - 1; j <= k; ) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\tif (i == j && j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * (count.get(nums[k]) - 2) / 6;\\n\\t\\t\\t\\telse if (i == j || j == k)\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * (count.get(nums[j]) - 1) * count.get(nums[k]) / 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttriplets += (long) count.get(nums[i]) * count.get(nums[j]) * count.get(nums[k]);\\n\\n\\t\\t\\t\\ttriplets %= MOD;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn (int) triplets;\\n}\\n\\nprivate Map<Integer, Integer> getNumToFrequency(int[] arr) {\\n\\tvar numToFrequency = new HashMap<Integer, Integer>();\\n\\tfor (var num : arr)\\n\\t\\tnumToFrequency.compute(num, (k, v) -> v == null ? 1 : ++v);\\n\\treturn numToFrequency;\\n}\\n\\nprivate Integer[] getUnique(Map<Integer, Integer> count) {\\n\\tvar nums = count.keySet().toArray(new Integer[0]);\\n\\tArrays.sort(nums);\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919448,
                "title": "c-simple-dynamic-programming-approach",
                "content": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\npublic:\\n    int dp[3002][4][302];\\n    int rec(vector<int>& arr,int idx,int cnt,int target){\\n        if(cnt == 0)    return target == 0;\\n        else if(idx >= arr.size())  return 0;\\n        else if(target < 0) return 0;\\n        else if(dp[idx][cnt][target] != -1) return dp[idx][cnt][target];\\n        \\n        int pick = rec(arr,idx+1,cnt-1,target-arr[idx]);\\n        int notPick = rec(arr,idx+1,cnt,target);\\n        \\n        return dp[idx][cnt][target] = (pick%mod + notPick%mod)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(arr,0,3,target);\\n    }\\n};\\n```\\n\\nTime Complexity Would be : O(n*target*4)\\nSpace Complexity Would be : O(n*target*4)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\npublic:\\n    int dp[3002][4][302];\\n    int rec(vector<int>& arr,int idx,int cnt,int target){\\n        if(cnt == 0)    return target == 0;\\n        else if(idx >= arr.size())  return 0;\\n        else if(target < 0) return 0;\\n        else if(dp[idx][cnt][target] != -1) return dp[idx][cnt][target];\\n        \\n        int pick = rec(arr,idx+1,cnt-1,target-arr[idx]);\\n        int notPick = rec(arr,idx+1,cnt,target);\\n        \\n        return dp[idx][cnt][target] = (pick%mod + notPick%mod)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(arr,0,3,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919227,
                "title": "all-3sum-problems-solved-with-the-same-code-with-slight-modification",
                "content": "All 3sum problems on Leetcode:\\n* [3sum](https://leetcode.com/problems/3sum/)\\n* [3sum with multiplicity](https://leetcode.com/problems/3sum-with-multiplicity)\\n* [3sum closest](https://leetcode.com/problems/3sum-closest/)\\n* [3sum smaller](https://leetcode.com/problems/3sum-smaller/) [\\uD83D\\uDCB2subscription needed!] \\n\\nThis article has solutions to the above first 3 problems, all of which can be solved using **[Two Pointers](https://leetcode.com/tag/two-pointers/)** approach, with just few modifications.\\n\\n<br>\\n\\n**C++ solutions:**\\n\\n**1. 3sum**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return {};\\n        \\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for (int i = 0; i < n-2; i++) {\\n            \\n            /* MODIFICATION 1:\\n            Here we add some conditions just to\\n            reduce the time required to search \\n            otherwise you\\'ll get solution, but it\\'s TLE! */\\n            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {\\n            \\n                int T = 0 - nums[i];\\n                int j = i+1, k = n-1;\\n\\n                while (j < k) {\\n                    if (nums[j] + nums[k] < T)\\n                        j++;\\n                    else if (nums[j] + nums[k] == T) {\\n                        ans.emplace_back(vector<int>{nums[i], nums[j], nums[k]});\\n\\n                        /* MODIFICATION 2:\\n                        Take care of duplicates: */\\n                        while (j < k && nums[j] == nums[j+1]) j++;\\n                        while (j < k && nums[k] == nums[k-1]) k--;\\n\\n                        j++, k--;\\n\\n                    } else if (nums[j] + nums[k] > T)\\n                        k--;\\n                }\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**2. 3sum closest**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        int closest_sum = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\n            int T = target - nums[i];\\n            int j = i+1, k = n-1;\\n            \\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Keep track of the sum every time,\\n                because we need to find the closest sum\\n                */\\n                int curr_sum = nums[i] + nums[j] + nums[k];\\n                int curr_diff = abs(curr_sum - target);\\n                if (curr_diff < min_diff) {\\n                    closest_sum = curr_sum;\\n                    min_diff = curr_diff;\\n                }\\n                \\n                if (nums[j] + nums[k] < T)\\n                    j++;\\n                else if (nums[j] + nums[k] > T)\\n                    k--;\\n                else if (nums[j] + nums[k] == T) {\\n                    closest_sum = nums[i] + nums[j] + nums[k];\\n                    return closest_sum;\\n                }\\n            }\\n        }\\n        \\n        return closest_sum;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**3. 3sum with multiplicity**\\n\\nSolution with explanation can be found [here](https://leetcode.com/problems/3sum-with-multiplicity/discuss/1918974/Comprehensive-explanation-in-comments-C++-Two-pointer-approach)\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Here we need to handle additional cases\\n                where there are duplicates.\\n                Also, a small modification is that we need\\n                to store the answer as answer%10^9 + 7\\n                */\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\\n\\n<br>\\n\\nFor all the above solutions:\\nTime complexity: **O(n<sup>2</sup>)**\\nSpace complexity: **O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return {};\\n        \\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for (int i = 0; i < n-2; i++) {\\n            \\n            /* MODIFICATION 1:\\n            Here we add some conditions just to\\n            reduce the time required to search \\n            otherwise you\\'ll get solution, but it\\'s TLE! */\\n            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {\\n            \\n                int T = 0 - nums[i];\\n                int j = i+1, k = n-1;\\n\\n                while (j < k) {\\n                    if (nums[j] + nums[k] < T)\\n                        j++;\\n                    else if (nums[j] + nums[k] == T) {\\n                        ans.emplace_back(vector<int>{nums[i], nums[j], nums[k]});\\n\\n                        /* MODIFICATION 2:\\n                        Take care of duplicates: */\\n                        while (j < k && nums[j] == nums[j+1]) j++;\\n                        while (j < k && nums[k] == nums[k-1]) k--;\\n\\n                        j++, k--;\\n\\n                    } else if (nums[j] + nums[k] > T)\\n                        k--;\\n                }\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        if (n <= 2) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        int closest_sum = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\n            int T = target - nums[i];\\n            int j = i+1, k = n-1;\\n            \\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Keep track of the sum every time,\\n                because we need to find the closest sum\\n                */\\n                int curr_sum = nums[i] + nums[j] + nums[k];\\n                int curr_diff = abs(curr_sum - target);\\n                if (curr_diff < min_diff) {\\n                    closest_sum = curr_sum;\\n                    min_diff = curr_diff;\\n                }\\n                \\n                if (nums[j] + nums[k] < T)\\n                    j++;\\n                else if (nums[j] + nums[k] > T)\\n                    k--;\\n                else if (nums[j] + nums[k] == T) {\\n                    closest_sum = nums[i] + nums[j] + nums[k];\\n                    return closest_sum;\\n                }\\n            }\\n        }\\n        \\n        return closest_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                \\n                /* MODIFICATION: \\n                Here we need to handle additional cases\\n                where there are duplicates.\\n                Also, a small modification is that we need\\n                to store the answer as answer%10^9 + 7\\n                */\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919075,
                "title": "short-easy-to-read-solution-inspired-in-two-sum",
                "content": "# The idea\\nIn <a href=\"https://leetcode.com/problems/two-sum/\">1. Two Sum</a> we used a hash map to keep track of what numbers we had seen before. For each `i`, we we asked if `target - nums[i]` was a key of that hash map. In that problem we used the hash map to keep track of the indices of the numbers we had seen. This time we\\'ll use it to keep track of how many times we\\'ve seen that value before.\\n\\nWe tried an approach that does not require sorting the list `arr`, which resulted in a solution that takes **O(n<sup>2</sup>)** time.\\n\\n# The algorithm\\nWe have a hash map that counts the ocurrences of each different value in `arr`. The keys of this hash map will represent the numbers `arr[i]` in the sums `arr[i] + arr[j] + arr[k]`. \\n\\nWe initialize our hash map as\\n```\\n        nums = Counter(arr[:1])\\n```\\nso at first it only considers `arr[0]`.\\n\\nFor each `j` in `[1, n - 2]` and for each `k` in `[j + 1, n - 1]` we check if `target - arr[k] - arr[j]` is a key on our hash map. If it is, we add its frequency to our answer (since this frequency tells us how many sums of the form `key + arr[j] + arr[k]` are equal to `target`). Then we update the count of `arr[j]` in our hash map and move on to the next `j`.\\n# The code\\n```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        toReturn = 0\\n        \\n        nums = Counter(arr[:1])\\n        for j in range(1, n - 1):\\n            for k in range(j + 1, n):\\n                toReturn = (toReturn + nums[target - arr[k] - arr[j]]) % 1000000007  \\n            nums[arr[j]] += 1\\n\\n        return toReturn\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        nums = Counter(arr[:1])\\n```\n```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        toReturn = 0\\n        \\n        nums = Counter(arr[:1])\\n        for j in range(1, n - 1):\\n            for k in range(j + 1, n):\\n                toReturn = (toReturn + nums[target - arr[k] - arr[j]]) % 1000000007  \\n            nums[arr[j]] += 1\\n\\n        return toReturn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125684,
                "title": "simple-solution-with-explanation-o-nxn-hashing-c",
                "content": "**Brute Force Approach:**\\nWe will iterate through 3 loops and find all the triplets satsfying the equation, but this will surely give TLE as O(n^3) solution.\\n```\\n//Pseudocode \\n\\t\\tint ans = 0, n = arr.size(), i,j,k;\\n        for(i = 0; i<n; ++i){\\n            for(j = i+1; j<n; ++j){\\n                for(k = j +1; k<n; ++k){\\n                    if(arr[i] + arr[j] + arr[k] == target)\\n                        ans++;\\n                }\\n            }\\n        }\\n```\\n**Final Sollution Approah O(n^2):**\\nWe can think in a manner like we have to find all the triplets where, \\narr[k] = target - arr[i] - arr[j], by doing we can can minimize the tine complexity to O(n^2).This can be achived using the hashmap.\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        ll i,j,k,n = arr.size();\\n        unordered_map<ll, ll> freq;\\n        ll ans = 0;\\n        for(i = 0; i<n; ++i){\\n            \\n            for(j = i+1; j<n; ++j){\\n                ans+= freq[target - arr[i] - arr[j]];\\n            } \\n            freq[arr[i]]++;\\n        }\\n        \\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```\\n\\nWe will add the arr[i] to hashMap after the inner loop ends, as we have to keep in mind that i<j<k.\\n\\nPlease upvote if this helped you, any suggestion is appreciated :-).",
                "solutionTags": [],
                "code": "```\\n//Pseudocode \\n\\t\\tint ans = 0, n = arr.size(), i,j,k;\\n        for(i = 0; i<n; ++i){\\n            for(j = i+1; j<n; ++j){\\n                for(k = j +1; k<n; ++k){\\n                    if(arr[i] + arr[j] + arr[k] == target)\\n                        ans++;\\n                }\\n            }\\n        }\\n```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        ll i,j,k,n = arr.size();\\n        unordered_map<ll, ll> freq;\\n        ll ans = 0;\\n        for(i = 0; i<n; ++i){\\n            \\n            for(j = i+1; j<n; ++j){\\n                ans+= freq[target - arr[i] - arr[j]];\\n            } \\n            freq[arr[i]]++;\\n        }\\n        \\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124355,
                "title": "slow-but-easy-n-2-js-ts-solution",
                "content": "Explanation\\n* Make a map with all pair sums.\\n* If ***target - arr[i]*** in map, add count of pair sum.\\n\\n```\\n// JS\\nvar threeSumMulti = function (arr, target) {\\n  const map = new Map();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n};\\n```\\n\\n```\\n// TS\\nfunction threeSumMulti(arr: number[], target: number): number {\\n  const map = new Map<number, number>();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// JS\\nvar threeSumMulti = function (arr, target) {\\n  const map = new Map();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n};\\n```\n```\\n// TS\\nfunction threeSumMulti(arr: number[], target: number): number {\\n  const map = new Map<number, number>();\\n  const mod = 1000000007;\\n  let res = 0;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    res = (res + (map.get(target - arr[i]) || 0)) % mod;\\n\\n    for (let j = 0; j < i; j++) {\\n      let temp = arr[i] + arr[j];\\n      map.set(temp, (map.get(temp) || 0) + 1);\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124268,
                "title": "c-solution-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        int sum = 0;\\n        int ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum = target-arr[i];\\n            \\n            int left = i+1;\\n            int right = n-1;\\n            \\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] < sum)\\n                    left++;\\n                else if(arr[left]+arr[right] > sum)\\n                    right--;\\n                else\\n                {\\n                    int j = left;\\n                    int k = right;\\n                    int count1 = 0, count2 = 0;\\n                    \\n                    while(j <= right && arr[j] == arr[left])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    if(j > right)\\n                    {\\n                        int ans_here = (count1*(count1-1))/2;\\n                        ans = (ans+ans_here)%MOD;\\n                    }\\n                    else\\n                    {\\n                        while(k >= j && arr[k] == arr[right])\\n                        {\\n                            count2++;\\n                            k--;\\n                        }\\n                        ans = (ans+(count1*count2)%MOD)%MOD;\\n                    }\\n                    left = j;\\n                right = k;\\n               }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        int sum = 0;\\n        int ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum = target-arr[i];\\n            \\n            int left = i+1;\\n            int right = n-1;\\n            \\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] < sum)\\n                    left++;\\n                else if(arr[left]+arr[right] > sum)\\n                    right--;\\n                else\\n                {\\n                    int j = left;\\n                    int k = right;\\n                    int count1 = 0, count2 = 0;\\n                    \\n                    while(j <= right && arr[j] == arr[left])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    if(j > right)\\n                    {\\n                        int ans_here = (count1*(count1-1))/2;\\n                        ans = (ans+ans_here)%MOD;\\n                    }\\n                    else\\n                    {\\n                        while(k >= j && arr[k] == arr[right])\\n                        {\\n                            count2++;\\n                            k--;\\n                        }\\n                        ans = (ans+(count1*count2)%MOD)%MOD;\\n                    }\\n                    left = j;\\n                right = k;\\n               }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123865,
                "title": "rust-counting-with-cases-solution",
                "content": "```rust\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn three_sum_multi(arr: Vec<i32>, target: i32) -> i32 {\\n        let mut counts = vec![0_i64; 101];\\n        arr.iter().for_each(|&n| counts[n as usize] += 1);\\n        let mut answer = 0;\\n        for i in 0..=100 {\\n            for j in i..=100 {\\n                let k = target - i - j;\\n                if (j..=100).contains(&k) {\\n                    let (ci, cj, ck) = (counts[i as usize], counts[j as usize], counts[k as usize]);\\n                    answer += match (i == j, j == k) {\\n                        (false, false) => ci * cj * ck,\\n                        (false, true) => ci * cj * (cj - 1) / 2,\\n                        (true, false) => ci * (ci - 1) / 2 * ck,\\n                        (true, true) => ci * (ci - 1) * (ci - 2) / 6,\\n                    };\\n                    answer %= MOD;\\n                }\\n            }\\n        }\\n        answer as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn three_sum_multi(arr: Vec<i32>, target: i32) -> i32 {\\n        let mut counts = vec![0_i64; 101];\\n        arr.iter().for_each(|&n| counts[n as usize] += 1);\\n        let mut answer = 0;\\n        for i in 0..=100 {\\n            for j in i..=100 {\\n                let k = target - i - j;\\n                if (j..=100).contains(&k) {\\n                    let (ci, cj, ck) = (counts[i as usize], counts[j as usize], counts[k as usize]);\\n                    answer += match (i == j, j == k) {\\n                        (false, false) => ci * cj * ck,\\n                        (false, true) => ci * cj * (cj - 1) / 2,\\n                        (true, false) => ci * (ci - 1) / 2 * ck,\\n                        (true, true) => ci * (ci - 1) * (ci - 2) / 6,\\n                    };\\n                    answer %= MOD;\\n                }\\n            }\\n        }\\n        answer as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212882,
                "title": "c-dp-10-line",
                "content": "```\\n    int threeSumMulti(vector<int>& A, int target) {\\n       const long long mod = 1e9 + 7;\\n       vector<vector<long long>> dp(3, vector<long long>(target + 1, 0));\\n       for (auto x : A) {\\n          if(x>target) continue;\\n          for (int i = target - x; i >= 0; i--) {\\n             dp[2][i + x] += dp[1][i]; dp[2][i + x] %= mod;\\n             dp[1][i + x] += dp[0][i]; dp[1][i + x] %= mod;\\n          }\\n          dp[0][x]++;\\n       }\\n       return dp[2][target];\\n    }",
                "solutionTags": [],
                "code": "```\\n    int threeSumMulti(vector<int>& A, int target) {\\n       const long long mod = 1e9 + 7;\\n       vector<vector<long long>> dp(3, vector<long long>(target + 1, 0));\\n       for (auto x : A) {\\n          if(x>target) continue;\\n          for (int i = target - x; i >= 0; i--) {\\n             dp[2][i + x] += dp[1][i]; dp[2][i + x] %= mod;\\n             dp[1][i + x] += dp[0][i]; dp[1][i + x] %= mod;\\n          }\\n          dp[0][x]++;\\n       }\\n       return dp[2][target];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 182417,
                "title": "c-dynamic-programming-is-quick-and-easy-once-you-master-it",
                "content": "Oct. 22, 2018\\nIt is the medium level algorithm in the weekly contest 106. In order to improve the contest performance, I like to learn a few ways to solve the algorithm after the contest. The dynamic programming solution is easy to write and it is quick and fast, I also wrote down my understanding as well. \\n\\nHow to think about the dynamic programming solution?\\nGo over each element in the array, for each sum from 0 to target, consider if current element is counted or not. If it is not counted, then the ways should be previous one, the same value; if it is counted, then the ways should be added by the value of smaller value ```(sum - currentValue)```. \\n\\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// dp[i][j][k] represents number of combinations using k numbers within \\n        /// A[0] ... A[i] with the sum of j.\\n        /// Then dp[n][target][3] is the result. \\n        /// Time complexity: O(n * target)\\n        /// three dimension array, first dimension there is n options, n <= 3000\\n        /// second option, target <= 300, 301 option. \\n        /// \\n        /// The idea is from \\n        /// https://leetcode.com/problems/3sum-with-multiplicity/discuss/181125/Knapsack-O(n-*-target)-or-Straightforward-O(n2)\\n        /// How to think about the dynamic programming solution?\\n        /// Go over each element in the array, for each sum from 0 to target, \\n        /// consider if current element is counted or not. If it is not counted, then the ways \\n        /// should be previous one, the same value; if it is counted, then the ways should be added by the value\\n        /// of smaller value (sum - currentValue). \\n        /// </summary>\\n        /// <param name=\"numbers\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <returns></returns>\\n        public int ThreeSumMulti(int[] numbers, int target)\\n        {\\n            int n = numbers.Length; \\n            int maximum = (int)1e9 + 7;\\n\\n            var dp = new int[n + 1, target + 1, 4]; // n+1, target + 1, 4\\n\\n            for (int i = 0; i <= n; i++) {\\n                dp[i, 0, 0] = 1;  // why?\\n            }\\n\\n            for (int i = 1; i < n + 1; i++) \\n            {\\n                for (int sum = 0; sum <= target; sum++) \\n                {\\n                    for (int k = 1; k <= 3; k++) \\n                    {\\n                        dp[i, sum, k]  = dp[i - 1, sum, k]; // based on the same sum \\n                        dp[i, sum, k] %= maximum;\\n\\n                        var current = numbers[i - 1];\\n\\n                        if (sum >= current)\\n                        {\\n                            var smallerSum = sum - current; // based on the smaller sum\\n\\n                            dp[i, sum, k] += dp[i - 1, smallerSum, k - 1];  // increment the value \\n                            dp[i, sum, k] %= maximum;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return dp[n, target, 3];\\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```(sum - currentValue)```\n```\\npublic class Solution {\\n    /// <summary>\\n        /// dp[i][j][k] represents number of combinations using k numbers within \\n        /// A[0] ... A[i] with the sum of j.\\n        /// Then dp[n][target][3] is the result. \\n        /// Time complexity: O(n * target)\\n        /// three dimension array, first dimension there is n options, n <= 3000\\n        /// second option, target <= 300, 301 option. \\n        /// \\n        /// The idea is from \\n        /// https://leetcode.com/problems/3sum-with-multiplicity/discuss/181125/Knapsack-O(n-*-target)-or-Straightforward-O(n2)\\n        /// How to think about the dynamic programming solution?\\n        /// Go over each element in the array, for each sum from 0 to target, \\n        /// consider if current element is counted or not. If it is not counted, then the ways \\n        /// should be previous one, the same value; if it is counted, then the ways should be added by the value\\n        /// of smaller value (sum - currentValue). \\n        /// </summary>\\n        /// <param name=\"numbers\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <returns></returns>\\n        public int ThreeSumMulti(int[] numbers, int target)\\n        {\\n            int n = numbers.Length; \\n            int maximum = (int)1e9 + 7;\\n\\n            var dp = new int[n + 1, target + 1, 4]; // n+1, target + 1, 4\\n\\n            for (int i = 0; i <= n; i++) {\\n                dp[i, 0, 0] = 1;  // why?\\n            }\\n\\n            for (int i = 1; i < n + 1; i++) \\n            {\\n                for (int sum = 0; sum <= target; sum++) \\n                {\\n                    for (int k = 1; k <= 3; k++) \\n                    {\\n                        dp[i, sum, k]  = dp[i - 1, sum, k]; // based on the same sum \\n                        dp[i, sum, k] %= maximum;\\n\\n                        var current = numbers[i - 1];\\n\\n                        if (sum >= current)\\n                        {\\n                            var smallerSum = sum - current; // based on the smaller sum\\n\\n                            dp[i, sum, k] += dp[i - 1, smallerSum, k - 1];  // increment the value \\n                            dp[i, sum, k] %= maximum;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return dp[n, target, 3];\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907659,
                "title": "java-sorting-two-pointers-no-extra-space",
                "content": "# Please Upvote :D\\n---\\n``` java []\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            int sum = target - arr[i];\\n            int l = i + 1, r = n - 1;\\n\\n            while (l < r) {\\n                if (arr[l] + arr[r] < sum) l++;\\n                else if (arr[l] + arr[r] > sum) r--;\\n                else {\\n                    int count1 = 1, count2 = 1;\\n\\n                    if (arr[l] == arr[r]) {\\n                        int len = r - l + 1;\\n                        ans += (len * (len - 1) / 2);\\n                        break;\\n                    }\\n\\n                    while (l < r && arr[l] == arr[l + 1]) {\\n                        count1++;\\n                        l++;\\n                    }\\n\\n                    while (r > l && arr[r] == arr[r - 1]) {\\n                        count2++;\\n                        r--;\\n                    }\\n\\n                    ans += (count1 * count2);\\n                    l++; r--;\\n                }\\n            }\\n        }\\n\\n        return (int) (ans % 1000000007);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 2) ~ O(n ^ 2)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            int sum = target - arr[i];\\n            int l = i + 1, r = n - 1;\\n\\n            while (l < r) {\\n                if (arr[l] + arr[r] < sum) l++;\\n                else if (arr[l] + arr[r] > sum) r--;\\n                else {\\n                    int count1 = 1, count2 = 1;\\n\\n                    if (arr[l] == arr[r]) {\\n                        int len = r - l + 1;\\n                        ans += (len * (len - 1) / 2);\\n                        break;\\n                    }\\n\\n                    while (l < r && arr[l] == arr[l + 1]) {\\n                        count1++;\\n                        l++;\\n                    }\\n\\n                    while (r > l && arr[r] == arr[r - 1]) {\\n                        count2++;\\n                        r--;\\n                    }\\n\\n                    ans += (count1 * count2);\\n                    l++; r--;\\n                }\\n            }\\n        }\\n\\n        return (int) (ans % 1000000007);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 2) ~ O(n ^ 2)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920634,
                "title": "using-binary-search-3-sum-approach",
                "content": "```\\nint threeSumMulti(vector<int>& arr, int t) \\n    {\\n        \\n        sort(arr.begin() , arr.end());\\n    int n = arr.size();\\n    int count=0;\\n       int mod = 1e9 +7;\\n    \\n\\tfor(int i=0;i<=n-3;i++)\\n         {\\n             int l=i+1 , r= n-1;\\n             \\n             int sm = t-arr[i];\\n             while(l<r)\\n             {\\n                 if(arr[l] + arr[r] == sm)\\n                 {\\n                       int cnt1=1, cnt2=1;\\n                    while (l < r && arr[l] == arr[l+1]) {cnt1++; l++;}\\n                    while (l < r && arr[r] == arr[r-1]) {cnt2++; r--;}\\n                     \\n                      if (l == r) count =(count+cnt1*(cnt1-1)/2)%mod;    // possiblities\\n\\t\\t\\t\\t\\t\\n                    else count = (count +cnt1*cnt2)%mod;\\n                    l++; r--;   \\n                 }\\n                 else if(arr[l] + arr[r] >sm)r--;\\n                 else l++;\\n             }\\n         }\\n    \\n    return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int t) \\n    {\\n        \\n        sort(arr.begin() , arr.end());\\n    int n = arr.size();\\n    int count=0;\\n       int mod = 1e9 +7;\\n    \\n\\tfor(int i=0;i<=n-3;i++)\\n         {\\n             int l=i+1 , r= n-1;\\n             \\n             int sm = t-arr[i];\\n             while(l<r)\\n             {\\n                 if(arr[l] + arr[r] == sm)\\n                 {\\n                       int cnt1=1, cnt2=1;\\n                    while (l < r && arr[l] == arr[l+1]) {cnt1++; l++;}\\n                    while (l < r && arr[r] == arr[r-1]) {cnt2++; r--;}\\n                     \\n                      if (l == r) count =(count+cnt1*(cnt1-1)/2)%mod;    // possiblities\\n\\t\\t\\t\\t\\t\\n                    else count = (count +cnt1*cnt2)%mod;\\n                    l++; r--;   \\n                 }\\n                 else if(arr[l] + arr[r] >sm)r--;\\n                 else l++;\\n             }\\n         }\\n    \\n    return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1920129,
                "title": "java-two-solution-100-faster-easy-understanding",
                "content": "**First solution**\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        long[] count = new long[101];\\n        long result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            count[arr[i]]++;\\n        }\\n        \\n        // when i != j and j != k and i != k\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i + 1; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (j < k && k <= 100) {\\n                    result += count[i] * count[j] * count[k];\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n        \\n        // x == y == z\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i <= 100) {\\n                result += count[i] * (count[i] - 1) * (count[i] - 2) / 6;\\n                result %= modulo;\\n            }\\n        }\\n            \\n        // x == y != z\\n        for (int i = 0; i <= 100; i++) {\\n            int k = target - 2 * i;\\n            if (i < k && k <= 100) {\\n                result += count[i] * (count[i] - 1) / 2 * count[k];\\n                result %= modulo;\\n            }\\n        }\\n\\n        // x != y == z\\n        for (int i = 0; i <= 100; i++) {\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j <= 100) {\\n                    result += count[i] * count[j] * (count[j] - 1) / 2;\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n\\n        return (int) result;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/0ed6c476-a432-430f-914d-9d6f371c2952_1649259950.9620552.png)\\n\\n\\n\\n**Second solution**\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        int result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            \\n            int j = i + 1;\\n            int k = arrLen - 1;\\n            int tmp = target - arr[i];\\n            \\n            while (j < k) {\\n                int sum = arr[j] + arr[k];\\n                \\n                if (sum < tmp) {\\n                    j++;\\n                } else if (sum > tmp) {\\n                    k--;\\n                } else {\\n                    if (arr[j] != arr[k]) {\\n                        int left = 1;\\n                        int right = 1;\\n                        \\n                        while (j + 1 < k && arr[j] == arr[j + 1]) {\\n                            left++;\\n                            j++;\\n                        }\\n                        \\n                        while (k - 1 > j && arr[k] == arr[k - 1]) {\\n                            right++;\\n                            k--;\\n                        }\\n                        \\n                        result += left * right;\\n                        result %= modulo;\\n                        j++;\\n                        k--;\\n                    } else {\\n                        result += (k - j + 1) * (k - j) / 2;\\n                        result %= modulo;\\n                        break;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return result;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/c7636eff-d41b-4479-8e29-0e98e4a9763b_1649251756.2134578.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        long[] count = new long[101];\\n        long result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            count[arr[i]]++;\\n        }\\n        \\n        // when i != j and j != k and i != k\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i + 1; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (j < k && k <= 100) {\\n                    result += count[i] * count[j] * count[k];\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n        \\n        // x == y == z\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i <= 100) {\\n                result += count[i] * (count[i] - 1) * (count[i] - 2) / 6;\\n                result %= modulo;\\n            }\\n        }\\n            \\n        // x == y != z\\n        for (int i = 0; i <= 100; i++) {\\n            int k = target - 2 * i;\\n            if (i < k && k <= 100) {\\n                result += count[i] * (count[i] - 1) / 2 * count[k];\\n                result %= modulo;\\n            }\\n        }\\n\\n        // x != y == z\\n        for (int i = 0; i <= 100; i++) {\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j <= 100) {\\n                    result += count[i] * count[j] * (count[j] - 1) / 2;\\n                    result %= modulo;\\n                }\\n            }\\n        }\\n\\n        return (int) result;\\n    }\\n```\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int arrLen = arr.length;\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        int result = 0;\\n        \\n        for (int i = 0; i < arrLen; i++) {\\n            \\n            int j = i + 1;\\n            int k = arrLen - 1;\\n            int tmp = target - arr[i];\\n            \\n            while (j < k) {\\n                int sum = arr[j] + arr[k];\\n                \\n                if (sum < tmp) {\\n                    j++;\\n                } else if (sum > tmp) {\\n                    k--;\\n                } else {\\n                    if (arr[j] != arr[k]) {\\n                        int left = 1;\\n                        int right = 1;\\n                        \\n                        while (j + 1 < k && arr[j] == arr[j + 1]) {\\n                            left++;\\n                            j++;\\n                        }\\n                        \\n                        while (k - 1 > j && arr[k] == arr[k - 1]) {\\n                            right++;\\n                            k--;\\n                        }\\n                        \\n                        result += left * right;\\n                        result %= modulo;\\n                        j++;\\n                        k--;\\n                    } else {\\n                        result += (k - j + 1) * (k - j) / 2;\\n                        result %= modulo;\\n                        break;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919797,
                "title": "simple-approach-using-two-pointer-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n    \\n     int solve(vector<int>& arr ,int target ,int i ,vector<int> v,vector<int>& mp){\\n         long long int m = 1e9 + 7 , res = 0;\\n         \\n         for(;i<arr.size();i++){\\n             v[arr[i]]++;\\n             int curr = target - arr[i];\\n             if(curr <= 100 && curr>=0) res = res%m + (mp[curr] - v[curr])%m;\\n         }\\n         \\n         return (int)res%m;\\n     }\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        long long int m = 1e9 + 7 , res = 0;\\n        \\n        vector<int> v(101,0) , mp(101,0);\\n        \\n        for(int i=0;i<arr.size();i++) mp[arr[i]]++;\\n        \\n        for(int i=0;i<n;i++){\\n            v[arr[i]]++;\\n            res = res%m + solve(arr ,target - arr[i] , i+1 ,v,mp) % m;\\n        }\\n        \\n        return (int)res%m;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    \\n     int solve(vector<int>& arr ,int target ,int i ,vector<int> v,vector<int>& mp){\\n         long long int m = 1e9 + 7 , res = 0;\\n         \\n         for(;i<arr.size();i++){\\n             v[arr[i]]++;\\n             int curr = target - arr[i];\\n             if(curr <= 100 && curr>=0) res = res%m + (mp[curr] - v[curr])%m;\\n         }\\n         \\n         return (int)res%m;\\n     }\\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        long long int m = 1e9 + 7 , res = 0;\\n        \\n        vector<int> v(101,0) , mp(101,0);\\n        \\n        for(int i=0;i<arr.size();i++) mp[arr[i]]++;\\n        \\n        for(int i=0;i<n;i++){\\n            v[arr[i]]++;\\n            res = res%m + solve(arr ,target - arr[i] , i+1 ,v,mp) % m;\\n        }\\n        \\n        return (int)res%m;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919198,
                "title": "c-3-sum-approach-easy-sort-daily-leetcoding-challenge-april-day-6",
                "content": "**Do Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        // for stroing the frequency of sum pairs \\n        map<int,int> mp;\\n        \\n        // initializing the modulo and result \\n        int mod = 1e9 + 7;\\n        int res = 0;\\n        \\n        // for taking the the 1st vaule out of 3\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // if (target-arr[i]) is available in my map\\n            // it means we are having a pair that is equal to our target\\n            // so just add the combinations to the result\\n            // arr[i] + arr[j] + arr[k] = target => (arr[i] + arr[j]) = (target - arr[k])\\n            res = (res + mp[target - arr[i]]) % mod;\\n            \\n            // storing all the pair for given value \\n            for(int j=0;j<i;j++)\\n            {\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        \\n        // returning the final result\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        // for stroing the frequency of sum pairs \\n        map<int,int> mp;\\n        \\n        // initializing the modulo and result \\n        int mod = 1e9 + 7;\\n        int res = 0;\\n        \\n        // for taking the the 1st vaule out of 3\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // if (target-arr[i]) is available in my map\\n            // it means we are having a pair that is equal to our target\\n            // so just add the combinations to the result\\n            // arr[i] + arr[j] + arr[k] = target => (arr[i] + arr[j]) = (target - arr[k])\\n            res = (res + mp[target - arr[i]]) % mod;\\n            \\n            // storing all the pair for given value \\n            for(int j=0;j<i;j++)\\n            {\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        \\n        // returning the final result\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918781,
                "title": "dp-pick-or-notpick-approach-c",
                "content": "```\\n\\tint mod= 1e9+7;\\n    int dp[3001][301][4];\\n    int solve(int i, int count, vector<int> &arr, int target){\\n      if(count==0 && target==0) return 1;\\n      if(i>=arr.size()) return 0;\\n      if(count==0 | target<0) return 0;\\n      \\n      if(dp[i][target][count]!=-1) return dp[i][target][count];\\n      \\n      int pick=0, notPick= 0;\\n      notPick= solve(i+1, count, arr, target);\\n      pick= arr[i]<=target ? solve(i+1, count-1, arr, target-arr[i]) : 0;\\n      \\n      return dp[i][target][count]=(pick+notPick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 3, arr, target);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint mod= 1e9+7;\\n    int dp[3001][301][4];\\n    int solve(int i, int count, vector<int> &arr, int target){\\n      if(count==0 && target==0) return 1;\\n      if(i>=arr.size()) return 0;\\n      if(count==0 | target<0) return 0;\\n      \\n      if(dp[i][target][count]!=-1) return dp[i][target][count];\\n      \\n      int pick=0, notPick= 0;\\n      notPick= solve(i+1, count, arr, target);\\n      pick= arr[i]<=target ? solve(i+1, count-1, arr, target-arr[i]) : 0;\\n      \\n      return dp[i][target][count]=(pick+notPick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 3, arr, target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918550,
                "title": "java-combination-1ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long[] counts = new long[101];\\n        int kMod = 1_000_000_007;\\n        int max = 0;\\n        for (int num: arr) {\\n            counts[num]++;\\n            max = Math.max(max, num);\\n        }\\n        long total = 0;\\n        for(int i = 0; i <= max; i++) {\\n            for(int j = i; j <= max; j++) {\\n                int k = target - i - j;\\n                if (k >= j && k <= max) {\\n                    if (counts[i]== 0 || counts[j] == 0 || counts[k] == 0) continue;\\n                    if (i == j && i == k) {\\n                        total += combination(counts[i], 3);\\n                    } else if (i == j && j != k) {\\n                        total += combination(counts[i], 2) * counts[k];\\n                    } else if (i != j && j == k) {\\n                        total += combination(counts[j], 2) * counts[i];\\n                    } else {\\n                        total += counts[i] * counts[j] * counts[k];\\n                    }\\n                }\\n            }\\n        }\\n        return (int)(total % kMod);\\n    }\\n    private long combination(long x, long y) {\\n        if(x < y) return 0;\\n        if(x == y) return 1;\\n        if(y == 2) return (x * (x - 1) >> 1);            \\n        else return (x * (x - 1) >> 1) * (x - 2) / 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long[] counts = new long[101];\\n        int kMod = 1_000_000_007;\\n        int max = 0;\\n        for (int num: arr) {\\n            counts[num]++;\\n            max = Math.max(max, num);\\n        }\\n        long total = 0;\\n        for(int i = 0; i <= max; i++) {\\n            for(int j = i; j <= max; j++) {\\n                int k = target - i - j;\\n                if (k >= j && k <= max) {\\n                    if (counts[i]== 0 || counts[j] == 0 || counts[k] == 0) continue;\\n                    if (i == j && i == k) {\\n                        total += combination(counts[i], 3);\\n                    } else if (i == j && j != k) {\\n                        total += combination(counts[i], 2) * counts[k];\\n                    } else if (i != j && j == k) {\\n                        total += combination(counts[j], 2) * counts[i];\\n                    } else {\\n                        total += counts[i] * counts[j] * counts[k];\\n                    }\\n                }\\n            }\\n        }\\n        return (int)(total % kMod);\\n    }\\n    private long combination(long x, long y) {\\n        if(x < y) return 0;\\n        if(x == y) return 1;\\n        if(y == 2) return (x * (x - 1) >> 1);            \\n        else return (x * (x - 1) >> 1) * (x - 2) / 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918473,
                "title": "java-solution-easy-approach",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        HashMap<Integer, Integer> hm=new HashMap<>();\\n        int mod=(int)(1e9+7);\\n        hm.put(arr[0], 1);\\n        int ans=0;\\n        for(int i=1;i<arr.length;i++) {\\n            for(int j=i+1;j<arr.length;j++) {\\n                if(arr[i]+arr[j]>target) \\n                    continue;\\n                else {\\n                    int re=target-(arr[i]+arr[j]);\\n                    if(hm.containsKey(re)) \\n                        ans=(ans%mod+hm.get(re)%mod)%mod;\\n                }\\n            }\\n            if(hm.containsKey(arr[i])) \\n                hm.put(arr[i], hm.get(arr[i])+1);\\n            \\n            else \\n                hm.put(arr[i], 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        HashMap<Integer, Integer> hm=new HashMap<>();\\n        int mod=(int)(1e9+7);\\n        hm.put(arr[0], 1);\\n        int ans=0;\\n        for(int i=1;i<arr.length;i++) {\\n            for(int j=i+1;j<arr.length;j++) {\\n                if(arr[i]+arr[j]>target) \\n                    continue;\\n                else {\\n                    int re=target-(arr[i]+arr[j]);\\n                    if(hm.containsKey(re)) \\n                        ans=(ans%mod+hm.get(re)%mod)%mod;\\n                }\\n            }\\n            if(hm.containsKey(arr[i])) \\n                hm.put(arr[i], hm.get(arr[i])+1);\\n            \\n            else \\n                hm.put(arr[i], 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125653,
                "title": "java-simple-and-easy-to-understand-solution-2-ms-faster-than-97-14-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        long tupleCount = 0;\\n        \\n        long[] counts = new long[101];\\n        for(int num : arr){\\n            counts[num]++;\\n        }\\n        \\n        \\n        //All different, x != y != z\\n        for(int x = 0; x <= 100; x++){\\n            for(int y = x + 1; y <= 100; y++){\\n                int z = target - x - y;\\n                if(z > y && z <= 100){\\n                    tupleCount += (counts[x] * counts[y] * counts[z]);\\n                    tupleCount %= MOD;\\n                }\\n            }\\n        }\\n        \\n        //x == y != z\\n        for(int x = 0; x <= 100; x++){\\n            int z = target - 2 * x;\\n            if(z > x && z <= 100){\\n\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                tupleCount += ((counts[x] * (counts[x] - 1) / 2) * counts[z]);\\n                tupleCount %= MOD;\\n            }\\n        }\\n        \\n\\t\\t\\n        //x != (y == z)\\n\\t\\tfor(int x = 0; x <= 100; x++){\\n            int yz = target - x;\\n            if(yz % 2 == 0){\\n                int y = yz / 2;\\n                if(y > x && y <= 100){\\n\\t\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                    tupleCount += (counts[x] * (counts[y] * (counts[y] - 1) / 2) );\\n                    tupleCount %= MOD;\\n                } \\n                \\n            }\\n        }\\n        \\n        \\n        //x == y == z\\n\\t\\t\\n        if(target % 3 == 0){\\n            int x = target / 3;\\n\\t\\t\\t//selective 3 items items when there is counts[x] identical items\\n            tupleCount += (counts[x] * (counts[x] - 1) * (counts[x] - 2)) / 6;\\n            tupleCount %= MOD;\\n        }\\n        \\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        long tupleCount = 0;\\n        \\n        long[] counts = new long[101];\\n        for(int num : arr){\\n            counts[num]++;\\n        }\\n        \\n        \\n        //All different, x != y != z\\n        for(int x = 0; x <= 100; x++){\\n            for(int y = x + 1; y <= 100; y++){\\n                int z = target - x - y;\\n                if(z > y && z <= 100){\\n                    tupleCount += (counts[x] * counts[y] * counts[z]);\\n                    tupleCount %= MOD;\\n                }\\n            }\\n        }\\n        \\n        //x == y != z\\n        for(int x = 0; x <= 100; x++){\\n            int z = target - 2 * x;\\n            if(z > x && z <= 100){\\n\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                tupleCount += ((counts[x] * (counts[x] - 1) / 2) * counts[z]);\\n                tupleCount %= MOD;\\n            }\\n        }\\n        \\n\\t\\t\\n        //x != (y == z)\\n\\t\\tfor(int x = 0; x <= 100; x++){\\n            int yz = target - x;\\n            if(yz % 2 == 0){\\n                int y = yz / 2;\\n                if(y > x && y <= 100){\\n\\t\\t\\t\\t\\t//selecting two items when there is  counts[y] identical items\\n                    tupleCount += (counts[x] * (counts[y] * (counts[y] - 1) / 2) );\\n                    tupleCount %= MOD;\\n                } \\n                \\n            }\\n        }\\n        \\n        \\n        //x == y == z\\n\\t\\t\\n        if(target % 3 == 0){\\n            int x = target / 3;\\n\\t\\t\\t//selective 3 items items when there is counts[x] identical items\\n            tupleCount += (counts[x] * (counts[x] - 1) * (counts[x] - 2)) / 6;\\n            tupleCount %= MOD;\\n        }\\n        \\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125330,
                "title": "c-frequency-table-based-solution-explained-100-time-95-memory",
                "content": "This is an interesting problem that mixes combinatorics and the need to build a frequency map in order to keep things doable; the basic idea is that once you have verified that, say, `ni`, `nj` and `nk` sum up to `target`, there is no need to compute that again, over and over.\\n\\nThere are a few compilications when one or all of those numbers are the same, but that is about it, really!\\n\\nIn order to solve this problem, we will first of all declare externally a `static constexpr` our modulo upper limit, `rem`, as demanded in the specs.\\n\\nIn our main function, we will then declare a few more support variables:\\n* `uniques` is going to store all our unique values in the `0 - 100` range (hence the size of `101`);\\n* `uPos` is both a pointer on where to write in `uniques` next and the number of the currently found unique values;\\n* `freqs` stores the frequencies of each number found, initially all set to `0`;\\n* `res` is our usual accumulator variable for the result, initialised to `0`;\\n* `tmp` is, as the name implies, a temporary variable where we will store the value of each combination we find.\\n\\nNext, time to parse our initial input once and for all, in order to store its information in a more convenient way, so, for each number `n` in `arr`, we will:\\n* `continue` is that number is just too big to be used to reach `target` (I might optimise checking the 2 smallest values first, but not sure it would be convenient);\\n* store it in `uniques` while also increasing `uPos` if it is the first time we encountered it;\\n* increase its matching cell in `freqs`.\\n\\nOnce done, for convenience we will sort all the unique values that we found in order to just explore all the possible combinations that are with a non-decreasing triplet of numbers; sorting now should be relatively cheap, handling at most `101` different elements.\\n\\nThe bigger part of the works comes here and we will start with an external loop, going with `i` from `0` up to `uPos` (excluded) and:\\n* assign the current unique pointed by `i` to `ni`;\\n* compute `ti` as `target - 2 * ni`;\\n* `break` out of the loop if `ni` is too big;\\n* start a nested loop with `j` going from either `i` or `i + 1`, depending on whether or not `freqs[ni] < 2`, still up to `uPos` excluded and:\\n\\t* assign the current unique pointed by `j` to `nj`;\\n\\t* compute `nk` (the missing bit) as `target - ni - nj`;\\n\\t* `break` out of the loop if `nj > nk`, since we again want only combinations in non-decreasing order to avoid repetitions;\\n\\t* `continue` if `nk` is too big (ie: `> 100`, hoping to get a smaller value later, with a bigger `nj`;\\n\\t* provided `nk` exists at least once (ie: `freqs[nk]`), we will then have 3 cases to consider to compute `tmp`:\\n\\t\\t* all 3 numbers are equal, so `tmp` is going to be their frequency choose `3`: `freqs[ni] * (freqs[ni] - 1) * (freqs[ni] - 2) / 6`;\\n\\t\\t* 2 numbers are equal, trickier case, so we:\\n\\t\\t\\t* identify the equal values in `eq` and the different one in `diff`;\\n\\t\\t\\t* compute `tmp` as the product of `freqs[eq]` choose `2` and `freqs[diff]`;\\n\\t\\t* all numbers are different, so we just multiply their respective frequencies to compute `tmp`\\n\\t* finally, we will add `tmp` to `res`.\\n\\nOnce done, we can just return `res % modCut` and be done :)\\n\\nThe code:\\n\\n```cpp\\nstatic constexpr int modCut = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int uniques[101], uPos = 0;\\n        long freqs[101] = {}, res = 0, tmp;\\n        // populating freq\\n        for (int n: arr) {\\n            // ignoring too large numbers\\n            if (n > target) continue;\\n            // storing n if it is the first time we encounter it\\n            if (!freqs[n]) uniques[uPos++] = n;\\n            // increasing its frequency\\n            freqs[n]++;\\n        }\\n        sort(uniques, uniques + uPos);\\n        // computing all the possible combos\\n        for (int i = 0, ni, ti; i < uPos; i++) {\\n            ni = uniques[i];\\n            ti = target - 2 * ni;\\n            // skipping if it is too big\\n            if (ni > ti) break;\\n            for (int j = i + (freqs[ni] < 2), nj, nk, eq, diff; j < uPos; j++) {\\n                nj = uniques[j];\\n                nk = target - nj - ni;\\n                // stopping if it is too big\\n                if (nj > nk) break;\\n                // skipping if it is too big\\n                if (nk > 100) continue;\\n                if (freqs[nk]) {\\n                    if (ni == nj && nj == nk) tmp = freqs[ni] * (freqs[ni] - 1) * (freqs[ni] - 2) / 6;\\n                    else if (ni == nj || ni == nk || nj == nk) {\\n                        eq = ni == nj || ni == nk ? ni : nk;\\n                        diff = ni != nj ? (nj != nk ? nj : ni) : nk;\\n                        tmp = freqs[eq] * (freqs[eq] - 1) / 2 * freqs[diff];\\n                    }\\n                    else tmp = freqs[ni] * freqs[nj] * freqs[nk];\\n                    res += tmp;\\n                }\\n            }\\n        }\\n        return res %= modCut;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics"
                ],
                "code": "```cpp\\nstatic constexpr int modCut = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int uniques[101], uPos = 0;\\n        long freqs[101] = {}, res = 0, tmp;\\n        // populating freq\\n        for (int n: arr) {\\n            // ignoring too large numbers\\n            if (n > target) continue;\\n            // storing n if it is the first time we encounter it\\n            if (!freqs[n]) uniques[uPos++] = n;\\n            // increasing its frequency\\n            freqs[n]++;\\n        }\\n        sort(uniques, uniques + uPos);\\n        // computing all the possible combos\\n        for (int i = 0, ni, ti; i < uPos; i++) {\\n            ni = uniques[i];\\n            ti = target - 2 * ni;\\n            // skipping if it is too big\\n            if (ni > ti) break;\\n            for (int j = i + (freqs[ni] < 2), nj, nk, eq, diff; j < uPos; j++) {\\n                nj = uniques[j];\\n                nk = target - nj - ni;\\n                // stopping if it is too big\\n                if (nj > nk) break;\\n                // skipping if it is too big\\n                if (nk > 100) continue;\\n                if (freqs[nk]) {\\n                    if (ni == nj && nj == nk) tmp = freqs[ni] * (freqs[ni] - 1) * (freqs[ni] - 2) / 6;\\n                    else if (ni == nj || ni == nk || nj == nk) {\\n                        eq = ni == nj || ni == nk ? ni : nk;\\n                        diff = ni != nj ? (nj != nk ? nj : ni) : nk;\\n                        tmp = freqs[eq] * (freqs[eq] - 1) / 2 * freqs[diff];\\n                    }\\n                    else tmp = freqs[ni] * freqs[nj] * freqs[nk];\\n                    res += tmp;\\n                }\\n            }\\n        }\\n        return res %= modCut;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068859,
                "title": "guaranteed-easy-solution-you-can-understand",
                "content": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    static final int module = 1_000_000_007;\\n\\n    public int threeSumMulti(int[] nums, int target) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        // count frequent of all numbers\\n        for(int n: nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        // remove duplicates and sort\\n        int[] a = map.keySet().stream().mapToInt(i -> i).toArray();\\n        Arrays.sort(a);\\n\\n        Long ans = 0L;\\n        int len = a.length;\\n\\n        for (int first = 0; first < len; first++) {\\n            if(a[first] > target) break;\\n\\n            int remain = target - a[first];\\n            int second = first;\\n            int third = len - 1;\\n\\n            while (second <= third){\\n                if(a[second] + a[third] == remain){\\n\\n                    // three numbers are equal\\n                    if(first == second && second == third) ans += nChooseK(map.get(a[first]), 3);\\n\\n                    // first two numbers are equal\\n                    else if(first == second) ans += nChooseK(map.get(a[first]), 2) * map.get(a[third]);\\n\\n                    // last two numbers are equal\\n                    else if(second == third) ans += map.get(a[first]) * nChooseK(map.get(a[second]), 2);\\n\\n                    //  three numbers are different\\n                    else ans += map.get(a[first]) * map.get(a[second]) * map.get(a[third]);\\n\\n                    if(ans > module) ans %= module;\\n\\n                    second++;\\n                    third--;\\n                }\\n                else if(a[second] + a[third] < remain){\\n                    second++;\\n                }\\n                else {\\n                    third--;\\n                }\\n            }\\n        }\\n        return ans.intValue();\\n    }\\n\\n    private static long nChooseK(long n, long k) {\\n        long numserator = 1;\\n        long denominator = 1;\\n\\n        for (long i = n; i >= (n - k + 1); i--) {\\n            numserator *= i;\\n        }\\n\\n        for (long i = k; i >= 1; i--) {\\n            denominator *= i;\\n        }\\n\\n        return (numserator / denominator);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    static final int module = 1_000_000_007;\\n\\n    public int threeSumMulti(int[] nums, int target) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        // count frequent of all numbers\\n        for(int n: nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        // remove duplicates and sort\\n        int[] a = map.keySet().stream().mapToInt(i -> i).toArray();\\n        Arrays.sort(a);\\n\\n        Long ans = 0L;\\n        int len = a.length;\\n\\n        for (int first = 0; first < len; first++) {\\n            if(a[first] > target) break;\\n\\n            int remain = target - a[first];\\n            int second = first;\\n            int third = len - 1;\\n\\n            while (second <= third){\\n                if(a[second] + a[third] == remain){\\n\\n                    // three numbers are equal\\n                    if(first == second && second == third) ans += nChooseK(map.get(a[first]), 3);\\n\\n                    // first two numbers are equal\\n                    else if(first == second) ans += nChooseK(map.get(a[first]), 2) * map.get(a[third]);\\n\\n                    // last two numbers are equal\\n                    else if(second == third) ans += map.get(a[first]) * nChooseK(map.get(a[second]), 2);\\n\\n                    //  three numbers are different\\n                    else ans += map.get(a[first]) * map.get(a[second]) * map.get(a[third]);\\n\\n                    if(ans > module) ans %= module;\\n\\n                    second++;\\n                    third--;\\n                }\\n                else if(a[second] + a[third] < remain){\\n                    second++;\\n                }\\n                else {\\n                    third--;\\n                }\\n            }\\n        }\\n        return ans.intValue();\\n    }\\n\\n    private static long nChooseK(long n, long k) {\\n        long numserator = 1;\\n        long denominator = 1;\\n\\n        for (long i = n; i >= (n - k + 1); i--) {\\n            numserator *= i;\\n        }\\n\\n        for (long i = k; i >= 1; i--) {\\n            denominator *= i;\\n        }\\n\\n        return (numserator / denominator);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394422,
                "title": "javascript-time-o-n-2-space-o-u-where-u-unique-values",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @param {number} target\\n * @return {number}\\n */\\n// Time: O(n^2)\\n// Space: O(n)\\nvar threeSumMulti = function(A, target) {\\n    const seen = {};\\n    let tuples = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = i + 1; j < A.length; j++) {\\n            const total = A[i] + A[j];\\n\\n            if (seen[target - total]) tuples += seen[target - total];\\n        }\\n\\n        if (!seen[A[i]]) seen[A[i]] = 0;\\n\\n        seen[A[i]]++;\\n    }\\n\\n    return tuples % (Math.pow(10, 9) + 7);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number} target\\n * @return {number}\\n */\\n// Time: O(n^2)\\n// Space: O(n)\\nvar threeSumMulti = function(A, target) {\\n    const seen = {};\\n    let tuples = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = i + 1; j < A.length; j++) {\\n            const total = A[i] + A[j];\\n\\n            if (seen[target - total]) tuples += seen[target - total];\\n        }\\n\\n        if (!seen[A[i]]) seen[A[i]] = 0;\\n\\n        seen[A[i]]++;\\n    }\\n\\n    return tuples % (Math.pow(10, 9) + 7);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222517,
                "title": "python-solution",
                "content": "We want to mimic the LC 15. 3Sum algorithm in some way, but here we need to consider all triples together with their multiplicities, so simply using the solutions there is incorrect. For example, consider `A = [1,2,2,2,2]`, `target = 5`. If we initialize three pointers `i = 0, j = 1, k = 4`. Since `A[0] + A[1] + A[4] == 5`, it is a valid triple, we increment the counter by `1`. But then when we do `j += 1` and `k -= 1`, we missed a lot of the duplicate triples, so in total we only count `[1, 2, 2]` twice, whereas in fact the multiplicity of the triple `[1,2,2]` should be `6`. Furthermore, sorting an array with multiplitices could be very inefficient, so that we can first create a counter of the array, and then sort the distinct elements of the array by sorting the keys of the counter.\\n\\nTo address the above problems, we propose the following algorithm:\\n1. We initialize the result `res = 0`, which counts the total number of valid triples with multiplicity. We create a counter `dic` of the array, which maps an element in the array to its number of appearances.\\n2. sort `dic` according its keys. Denote by `A` the list of sorted `key`, `val` pairs in `dic`.\\n3. Let `i` be a pointer iterating in `range(len(A))`, and for each iteration, initialize two pointers `j = i`, `k = len(A)-1`. Now we search for pairs of indices `k >= j >= i`, such that `A[j][0] + A[k][0] == target - A[i][0]`. To do this, while `j <= k`, if `A[j][0]+A[k][0] < target - A[i][0]`, we increment `j` by `1`; Else if `A[j][0]+A[k][0] > target - A[i][0]`, we decrement `k` by `1`; Else when `A[j][0]+A[k][0] == target - A[i][0]`, we count the multiplicity of the triple `(A[i][0], A[j][0], A[k][0])`, and increment the total counter `res` by the multiplicity. Finally, after iterating over `i`, we return `res`.\\n\\nThe multiplicity of the triple `(A[i][0], A[j][0], A[k][0])` depends on if there are duplicate numbers in the triple. If all elements are distinct, then the multiplicity is just `A[i][1]*A[j][1]*A[k][1]`, E.g., if `A = [(1, 2), (2, 4), (3, 3)]` (corresponding to the input list `[1,1,2,2,2,2,3,3,3]`), then the multiplicity of the triple `(1,2,3)` is `2*4*3 = 24`; Else if there are two distinct elements in the triple, WLOG, assume `A[j][0] == A[k][0]`, then the multiplicity is `(A[j][1]*(A[j][1]-1) // 2) * A[i][1]`, E.g., consider the same `A = [(1,2), (2,4), (3,3)]` as in the previous case, the multiplicity of the triple `(1,2,2)` is `(4*3) // 2 * 2 = 12`, because the number of pairs of `(2,2)` that one can get in `[2,2,2,2]` is `4 choose 2 = 4*3 // 2 = 6`; Else if all three numbers in the triple are equal, i.e., `A[i][0] == A[j][0] and A[j][0] == A[k][0]`, then the multiplicity is `A[i][1]*(A[i][1]-1)*(A[i][1]-2) // 6`, E.g., consider the same `A = [(1,2), (2,4), (3,3)]` as in the previous case, the multiplicity of the triple `(2,2,2)` is `4 choose 3 = (4*3*2) // 6 = 4`.\\n\\nTime complexity: `O(n + m**2)`, space complexity: `O(m)`, where `n` is the length of the input array, and `m` is the number of distinct elements in the input array.\\n\\n```\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        bound = 1000000007\\n        dic = collections.Counter(A)\\n        A = sorted(dic.items(), key = lambda x: x[0])\\n        res = 0\\n        for i in range(len(A)):\\n            j = i\\n            k = len(A)-1\\n            new_target = target - A[i][0]\\n            while j <= k:\\n                if A[j][0]+A[k][0] < new_target:\\n                    j += 1\\n                elif A[j][0]+A[k][0] > new_target:\\n                    k -= 1\\n                else:\\n                    if A[i][0] == A[k][0]:\\n                        res = (res + A[i][1]*(A[i][1]-1)*(A[i][1]-2) // 6) % bound\\n                    elif A[i][0] == A[j][0]:\\n                        res = (res + A[k][1]*A[i][1]*(A[i][1]-1)//2) % bound\\n                    elif A[j][0] == A[k][0]:\\n                        res = (res + A[i][1]*A[j][1]*(A[j][1]-1)//2) % bound\\n                    else:\\n                        res = (res + A[i][1]*A[j][1]*A[k][1]) % bound\\n                    j += 1\\n                    k -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        bound = 1000000007\\n        dic = collections.Counter(A)\\n        A = sorted(dic.items(), key = lambda x: x[0])\\n        res = 0\\n        for i in range(len(A)):\\n            j = i\\n            k = len(A)-1\\n            new_target = target - A[i][0]\\n            while j <= k:\\n                if A[j][0]+A[k][0] < new_target:\\n                    j += 1\\n                elif A[j][0]+A[k][0] > new_target:\\n                    k -= 1\\n                else:\\n                    if A[i][0] == A[k][0]:\\n                        res = (res + A[i][1]*(A[i][1]-1)*(A[i][1]-2) // 6) % bound\\n                    elif A[i][0] == A[j][0]:\\n                        res = (res + A[k][1]*A[i][1]*(A[i][1]-1)//2) % bound\\n                    elif A[j][0] == A[k][0]:\\n                        res = (res + A[i][1]*A[j][1]*(A[j][1]-1)//2) % bound\\n                    else:\\n                        res = (res + A[i][1]*A[j][1]*A[k][1]) % bound\\n                    j += 1\\n                    k -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181285,
                "title": "javascript-use-hashmap-divide-possibilities-into-4-situations",
                "content": "### Three Steps\\n1. Store `A` using an array `uni` and a hashmap `count`; `uni` is used to store its value, and `count` is used to store the occurences of the value. (In fact, you can use a hashmap with key `0~100` to store `A`, it will be easier);\\n2. Sort `uni`. (If in the 1st step you used a hashmap with key `0~100`, you can skip this step);\\n3. Calculate the number of permutations of four situations and accumulate the result.\\n\\n--------\\n### Four situations\\n* [left, mid, right];\\n* [left, mid, mid];\\n* [mid, mid, right];\\n* [mid, mid, mid];\\n\\n----------\\n\\n### The math\\nIf `mid` occurs once, then it is easy:\\n```\\nres += count[left] * count[mid] * count[right]\\n```\\nIf `mid` occurs twice, then we divide the result by `2` (`2` is the number of permutations of two `mid`, ie `2!`)(make sure `count[mid]>=2`):\\n```\\nres += count[mid] * (count[mid]-1) * count[left/right] / 2\\n```\\nIf `mid` occurs three times, then we divide the result by `6` (`6` is the number of permutations of three `mid`, ie `3!`)(make sure `count[mid]>=3`):\\n```\\nres += count[mid] * (count[mid-1) * (count[mid]-2) / 6\\n```\\nIf you are still confused, see [Permutations of multisets](https://en.wikipedia.org/wiki/Permutation#Permutations_of_multisets) on Wikipedia. \\n\\n--------\\n\\n### The Code\\n```\\nvar threeSumMulti = function(A, target) {\\n\\tlet mod=1e9+7, res=0;\\n\\tlet count={}, uni=[];\\n\\tfor(let a of A){\\n\\t\\tif(!count[a]){\\n\\t\\t\\tcount[a]=0;\\n\\t\\t\\tuni.push(a);\\n\\t\\t}\\n\\t\\tcount[a]++;\\n\\t}\\n\\tuni.sort((a,b)=>a-b);\\n\\tfor(let i=0; i<uni.length; i++){\\n\\t\\tlet mid=uni[i];\\n\\t\\tif(target-mid-uni[0]<mid) break;\\n\\t\\tfor(let j=0; j<i; j++){\\n\\t\\t\\tlet left=uni[j];\\n\\t\\t\\tif(target-mid-left<mid) break;\\n\\t\\t\\tlet right=target-left-mid;\\n\\t\\t\\tif(right===mid){\\n\\t\\t\\t\\t// situation 1: [left mid mid]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*(count[mid]-1)/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(count[right]){\\n\\t\\t\\t\\t// situation 2: [left mid right]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*count[right])%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(count[mid]>1){\\n\\t\\t\\tlet right=target-2*mid;\\n\\t\\t\\tif(right>mid && count[right]>0){\\n\\t\\t\\t\\t// situation 3: [mid mid right]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*count[right]/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(right===mid && count[mid]>=3){\\n\\t\\t\\t\\t// situation 4: [mid mid mid]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*(count[mid]-2)/6)%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nres += count[left] * count[mid] * count[right]\\n```\n```\\nres += count[mid] * (count[mid]-1) * count[left/right] / 2\\n```\n```\\nres += count[mid] * (count[mid-1) * (count[mid]-2) / 6\\n```\n```\\nvar threeSumMulti = function(A, target) {\\n\\tlet mod=1e9+7, res=0;\\n\\tlet count={}, uni=[];\\n\\tfor(let a of A){\\n\\t\\tif(!count[a]){\\n\\t\\t\\tcount[a]=0;\\n\\t\\t\\tuni.push(a);\\n\\t\\t}\\n\\t\\tcount[a]++;\\n\\t}\\n\\tuni.sort((a,b)=>a-b);\\n\\tfor(let i=0; i<uni.length; i++){\\n\\t\\tlet mid=uni[i];\\n\\t\\tif(target-mid-uni[0]<mid) break;\\n\\t\\tfor(let j=0; j<i; j++){\\n\\t\\t\\tlet left=uni[j];\\n\\t\\t\\tif(target-mid-left<mid) break;\\n\\t\\t\\tlet right=target-left-mid;\\n\\t\\t\\tif(right===mid){\\n\\t\\t\\t\\t// situation 1: [left mid mid]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*(count[mid]-1)/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(count[right]){\\n\\t\\t\\t\\t// situation 2: [left mid right]\\n\\t\\t\\t\\tres=(res+count[left]*count[mid]*count[right])%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(count[mid]>1){\\n\\t\\t\\tlet right=target-2*mid;\\n\\t\\t\\tif(right>mid && count[right]>0){\\n\\t\\t\\t\\t// situation 3: [mid mid right]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*count[right]/2)%mod;\\n\\t\\t\\t}\\n\\t\\t\\telse if(right===mid && count[mid]>=3){\\n\\t\\t\\t\\t// situation 4: [mid mid mid]\\n\\t\\t\\t\\tres=(res+count[mid]*(count[mid]-1)*(count[mid]-2)/6)%mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1920537,
                "title": "c-use-map-to-count-tuples-dlc-april-6",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, long> mpp;\\n        int mod = 1e9+7;\\n        \\n        //store frequencies\\n        for(auto it: arr) mpp[it]++;\\n        \\n        //count touples\\n        long count = 0;\\n        for(auto it1: mpp){\\n            for(auto it2: mpp){\\n                int i= it1.first, j= it2.first;\\n                auto k = target- i- j;\\n                \\n                if(!mpp.count(k)) continue;\\n                if(i < j && j < k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += (mpp[i]*mpp[j]*mpp[k]);\\n                }\\n                    \\n                \\n                else if(i == j && j!=k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1)/ 2 * mpp[k];\\n                }\\n                    \\n                \\n                else if(i==j && j==k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1) * (mpp[k]-2) /6;  \\n                }\\n                    \\n                \\n            }\\n        }\\n        \\n        return count % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, long> mpp;\\n        int mod = 1e9+7;\\n        \\n        //store frequencies\\n        for(auto it: arr) mpp[it]++;\\n        \\n        //count touples\\n        long count = 0;\\n        for(auto it1: mpp){\\n            for(auto it2: mpp){\\n                int i= it1.first, j= it2.first;\\n                auto k = target- i- j;\\n                \\n                if(!mpp.count(k)) continue;\\n                if(i < j && j < k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += (mpp[i]*mpp[j]*mpp[k]);\\n                }\\n                    \\n                \\n                else if(i == j && j!=k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1)/ 2 * mpp[k];\\n                }\\n                    \\n                \\n                else if(i==j && j==k){\\n                    // cout<<i <<\"\\\\t\"<<j <<\"\\\\t\" <<k <<endl;\\n                    count += mpp[i]* (mpp[j]-1) * (mpp[k]-2) /6;  \\n                }\\n                    \\n                \\n            }\\n        }\\n        \\n        return count % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1920186,
                "title": "java-maps-commented",
                "content": "TLE solution\\n```\\nclass Solution {\\n    private int m = 1000000007; //modulo\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        long ans = 0; // last test case won\\'t run because ans is int\\n        for(int i = 0; i < len; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int tar = target - arr[i];\\n            for(int j = i+1; j < len; j++) {\\n                if(map.containsKey(tar-arr[j])) {\\n                    ans = ans%m;\\n                    ans = (ans + map.get(tar-arr[j]))%m; //here value after addition can be greater than int range it type should be long\\n                }\\n                map.put(arr[j], map.getOrDefault(arr[j], 0)+1);\\n            }\\n        }\\n        return (int)(ans%m);\\n    }\\n}\\n```\\n\\nTwo pointer AC\\n\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        int m = 1_000_000_007;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            int new_target = target-arr[i];\\n            int j = i+1, k = len-1;\\n            while(j < k) {\\n                if(arr[j]+arr[k] > new_target) {\\n                    k--;\\n                } else if(arr[j]+arr[k] < new_target) {\\n                    j++;\\n                } else if(arr[j] == arr[k]) {\\n                    ans += ((k-j+1)*(k-j))/2;\\n                    ans = ans%m;\\n                    break;\\n                } else {\\n                    int left = 1, right = 1;\\n                    while(j+1<k && arr[j]==arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    while(k-1>j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    ans += (left*right);\\n                    ans = ans%m;\\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    private int m = 1000000007; //modulo\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        long ans = 0; // last test case won\\'t run because ans is int\\n        for(int i = 0; i < len; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int tar = target - arr[i];\\n            for(int j = i+1; j < len; j++) {\\n                if(map.containsKey(tar-arr[j])) {\\n                    ans = ans%m;\\n                    ans = (ans + map.get(tar-arr[j]))%m; //here value after addition can be greater than int range it type should be long\\n                }\\n                map.put(arr[j], map.getOrDefault(arr[j], 0)+1);\\n            }\\n        }\\n        return (int)(ans%m);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int len = arr.length;\\n        int m = 1_000_000_007;\\n        Arrays.sort(arr);\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            int new_target = target-arr[i];\\n            int j = i+1, k = len-1;\\n            while(j < k) {\\n                if(arr[j]+arr[k] > new_target) {\\n                    k--;\\n                } else if(arr[j]+arr[k] < new_target) {\\n                    j++;\\n                } else if(arr[j] == arr[k]) {\\n                    ans += ((k-j+1)*(k-j))/2;\\n                    ans = ans%m;\\n                    break;\\n                } else {\\n                    int left = 1, right = 1;\\n                    while(j+1<k && arr[j]==arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    while(k-1>j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    ans += (left*right);\\n                    ans = ans%m;\\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919810,
                "title": "90-ms-runtime-beginner-friendly-extend-two-sum-approach-python3",
                "content": "Before delving into the actual working of the algorithm, let\\'s get some basics of combinations for the scope of this answer out of the way.\\n\\n---\\nIf `n` elements are given and we have to select `i` elements from them, then the possible number of ways this could be achieved is in <sup>n</sup>C<sub>i</sub> ways.\\n\\nAnd <sup>n</sup>C<sub>i</sub> = `factorial(n) / (factorial(n-i)*factorial(i))`\\nThis formula could further be simplified into <sup>n</sup>C<sub>i</sub> = `n*(n-1)*(n-2)....*(n-i+1) / factorial(i)`\\n\\nSo, if we had to select 2 elements from 4 values, the possible number of ways is:\\n<sup>4</sup>C<sub>2</sub> = `4 * 3 / 2 * 1` = `6`\\n\\nWith that understood now let\\'s talk about the algo to solve the question.\\n\\n---\\n**Implementation of algorithm**\\n---\\nLet\\'s recall how we used to solve the Two Sum problem. We could have done it by making a hash map or by using two pointers initially referencing the first and last element of the array.\\n\\nCode for two-pointers approach:\\n```\\ngiven target;\\ngiven arr[n]; # sorted array\\n\\ni = 0;\\nj = n-1;\\nans = 0;\\nwhile i<j:\\n\\tvalue1 = arr[i];\\n\\tvalue2 = arr[j];\\n\\tsum = value1 + value2\\n\\tif sum < target:\\n\\t\\t# we need to shift a pointer to next greater element\\n\\t\\ti++;\\n\\telse if sum > target:\\n\\t\\t# we need to shift a pointer to a lower element\\n\\t\\tj--;\\n\\telse:\\n\\t\\t# for the case that sum==target\\n\\t\\tans++\\n\\t\\ti++\\n\\t\\tj--\\n\\nreturn ans\\n```\\n\\n\\nTo solve Three Sum problem, we\\'ll combine the two approaches. We would first store each distinct value with its count in the array in a dictionary.\\n```\\ncount = {}\\nfor x in arr:\\n    if x in count:\\n        count[x] += 1\\n    else:\\n        count[x] = 1\\n        \\nkeys = sorted(count.keys())\\n```\\nThen we\\'ll maintain three pointers `i`,`j` and `k` to correspond with the three values that we want.\\nNow if the sum of values at these three indices is less than the target sum, then we need to shift a pointer to a greater element, and to a lesser element if the sum turns out to be less than target.\\n```\\n\\t\\tans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n```\\n\\nIf we manage to find the values being referenced by the three pointers to be equal to the target sum, then we\\'ll compare the positions of the pointers themselves, to determine if they point to distinct values or the same ones.\\n\\nAccordingly, we\\'ll use the concept of combinations mentioned earlier to find out the possible ways to make the target sum from the three values.\\n```\\nif val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n```\\n\\n---\\n**Complete Python code:**\\n```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        MOD = 10**9 + 7\\n        count = {}\\n        for x in arr:\\n            if x in count:\\n                count[x] += 1\\n            else:\\n                count[x] = 1\\n        \\n        keys = sorted(count.keys())\\n        \\n        ans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n                    \\n                    j += 1\\n                    k -= 1\\n        \\n        return ans % MOD\\n```\\n\\n**Time Complexity: O(nlogn) for sorting, O(n<sup>2</sup>) for comparing and finding values**\\n**Space Complexity: O(n)**\\n\\n***Please share your learnings if you find a better or more optimised approach to solving this problem. Do upvote if you found the explanation deserving enough. Thanks for reading***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ngiven target;\\ngiven arr[n]; # sorted array\\n\\ni = 0;\\nj = n-1;\\nans = 0;\\nwhile i<j:\\n\\tvalue1 = arr[i];\\n\\tvalue2 = arr[j];\\n\\tsum = value1 + value2\\n\\tif sum < target:\\n\\t\\t# we need to shift a pointer to next greater element\\n\\t\\ti++;\\n\\telse if sum > target:\\n\\t\\t# we need to shift a pointer to a lower element\\n\\t\\tj--;\\n\\telse:\\n\\t\\t# for the case that sum==target\\n\\t\\tans++\\n\\t\\ti++\\n\\t\\tj--\\n\\nreturn ans\\n```\n```\\ncount = {}\\nfor x in arr:\\n    if x in count:\\n        count[x] += 1\\n    else:\\n        count[x] = 1\\n        \\nkeys = sorted(count.keys())\\n```\n```\\n\\t\\tans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n```\n```\\nif val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n```\n```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        MOD = 10**9 + 7\\n        count = {}\\n        for x in arr:\\n            if x in count:\\n                count[x] += 1\\n            else:\\n                count[x] = 1\\n        \\n        keys = sorted(count.keys())\\n        \\n        ans = 0\\n        for i, val0 in enumerate(keys):\\n            sum2 = target - val0\\n            j,k = i, len(keys)-1\\n            while j<=k:\\n                val1, val2 = keys[j], keys[k]\\n                if val1 + val2 < sum2:\\n                    j += 1\\n                elif val1+val2 > sum2:\\n                    k -= 1\\n                else:\\n                    # val0 + val1 + val2 == target\\n                    # Now checking if our pointers correspond to counts of keys counted earlier\\n                    if i<j<k:\\n                        # select 1 of each distinct value\\n                        ans += count[val0]*count[val1]*count[val2]\\n                    elif i==j<k:\\n                        # Select 2 of one (nC2) and 1(nC1) of other distinct value\\n                        ans += (count[val0] * (count[val0]-1))//2 * count[val2]\\n                    elif i<j==k:\\n                        # Select 1 of one(nC1) and 2(nC2) of other distinct value\\n                        ans += count[val0] * (count[val1] * (count[val1] - 1))//2\\n                    else:\\n                        # for the case when i=j=k\\n                        \\n                        # This implies that we select 3 of one distinct value\\n                        # to make up for target\\n                        n = count[val0]\\n                        ans += (n * (n-1) * (n-2))//6\\n                    \\n                    j += 1\\n                    k -= 1\\n        \\n        return ans % MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1919684,
                "title": "c-10-lines-solution-90-faster",
                "content": "Time Complexity: O(n^2)\\n```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int>mp;\\n        const unsigned int M = 1000000007;\\n        int n=arr.size(), count=0;\\n        for(int i=2; i<n ; i++){\\n            for(int j=0 ; j<=i-2 ; j++){\\n                mp[arr[j]+arr[i-1]]++;\\n            }\\n            if(mp.count(target-arr[i])==1){\\n                count=count%M;\\n                mp[target-arr[i]]=(mp[target-arr[i]])%M;\\n                count=(((count+mp[target-arr[i]])%M)+ M)%M;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Time Complexity: O(n^2)\\n```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int>mp;\\n        const unsigned int M = 1000000007;\\n        int n=arr.size(), count=0;\\n        for(int i=2; i<n ; i++){\\n            for(int j=0 ; j<=i-2 ; j++){\\n                mp[arr[j]+arr[i-1]]++;\\n            }\\n            if(mp.count(target-arr[i])==1){\\n                count=count%M;\\n                mp[target-arr[i]]=(mp[target-arr[i]])%M;\\n                count=(((count+mp[target-arr[i]])%M)+ M)%M;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1919417,
                "title": "c-easy-solution",
                "content": "Upvote, if you find it helpful\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = 1e9+7, ans = 0;\\n        int map[101] = {};\\n        \\n        for(auto n: arr)\\n            map[n]++;\\n        \\n        for(int i = 0; i <= 100; i++){\\n            \\n            for( int j = i+1; j <= 100; j++ ){\\n                \\n                for( int k = j+1; k <= 100; k++ ){\\n                    \\n                    if( i+k+j == target && map[i] && map[j] && map[k] ){\\n                        int val = ( map[i] * map[j] * map[k]);\\n                        ans = ( ans + val ) % mod;\\n                    }\\n                    \\n                }\\n                \\n                if( i+i+j == target && map[i] > 1 && map[j] ){  // Consider case : [1,1,1,1,2,2,2,2] and target = 3\\n                    int val = (map[i] * (map[i]-1)) / 2;\\n                    ans =  ( ans + val * map[j] ) % mod;\\n                }\\n                if( i+j+j == target && map[i] && map[j] > 1 ){ // Consider case : [1,1,2,2,2,2] and target = 5\\n                    int val = (map[j] * (map[j]-1)) / 2;\\n                    ans =  ( ans + map[i] * val ) % mod;\\n                }\\n                \\n            }\\n            \\n            if( i*3 == target && map[i] > 2 ) {   // Consider case : [2,2,2,2,2,2] and target = 6\\n                long long int val = map[i] * (map[i]-1);\\n                val = ( val * (map[i]-2)/6 ) % mod;\\n                ans = ( ans + val ) % mod;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = 1e9+7, ans = 0;\\n        int map[101] = {};\\n        \\n        for(auto n: arr)\\n            map[n]++;\\n        \\n        for(int i = 0; i <= 100; i++){\\n            \\n            for( int j = i+1; j <= 100; j++ ){\\n                \\n                for( int k = j+1; k <= 100; k++ ){\\n                    \\n                    if( i+k+j == target && map[i] && map[j] && map[k] ){\\n                        int val = ( map[i] * map[j] * map[k]);\\n                        ans = ( ans + val ) % mod;\\n                    }\\n                    \\n                }\\n                \\n                if( i+i+j == target && map[i] > 1 && map[j] ){  // Consider case : [1,1,1,1,2,2,2,2] and target = 3\\n                    int val = (map[i] * (map[i]-1)) / 2;\\n                    ans =  ( ans + val * map[j] ) % mod;\\n                }\\n                if( i+j+j == target && map[i] && map[j] > 1 ){ // Consider case : [1,1,2,2,2,2] and target = 5\\n                    int val = (map[j] * (map[j]-1)) / 2;\\n                    ans =  ( ans + map[i] * val ) % mod;\\n                }\\n                \\n            }\\n            \\n            if( i*3 == target && map[i] > 2 ) {   // Consider case : [2,2,2,2,2,2] and target = 6\\n                long long int val = map[i] * (map[i]-1);\\n                val = ( val * (map[i]-2)/6 ) % mod;\\n                ans = ( ans + val ) % mod;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919197,
                "title": "c-o-n-2-solution-2-approaches-hashmap-3-pointers-approach",
                "content": "**Approach-1 :** Use hashmap \\n**TC: O(N^2), SC: O(N)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        int count = 0, n = arr.size(), modu = 1e9+7;\\n        //store sum and their frequency\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            //if (target-arr[i]) found in map we add its frequency into the count\\n            count = (count + (mp[target-arr[i]])) % modu;\\n            \\n            //iterate from 0 to i-1 and store the frequency of sum\\n            for(int j=0; j<i; j++)\\n            {\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n\\n**Approach-2 :** Use 3 pointers approach \\n**TC: O(N^2), SC: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n int threeSumMulti(vector<int>& nums, int target) \\n {\\n     sort(nums.begin(), nums.end());\\n     int n=nums.size();\\n     int ans=0, modu=1e9+7;\\n     long long sum;\\n     \\n     for(int i=0; i<n; i++)\\n     {\\n         int s = i+1;\\n         int e = n-1;\\n         \\n         while(s<e)\\n         {\\n             sum = nums[i]+nums[s]+nums[e];\\n             \\n             if(sum == target)\\n             {\\n                \\n                 int count1 = 1; //count same values for start pointer\\n                 int count2 = 1; //count same values for end pointer\\n                 \\n                 //if value of current and next start pointers are equal, we increase count1\\n                 while(s<e && nums[s]==nums[s+1])\\n                 {\\n                     count1++;\\n                     s++;\\n                 }\\n                 \\n                 //if value of current and next end pointers are equal, we increase count2\\n                 while(s<e && nums[e]==nums[e-1])\\n                 {\\n                     count2++;\\n                     e--;\\n                 }\\n                 \\n                 //we use combination formula to find possible tuples\\n                 //if s and e pointers are at same index we use\\n                 // (n*(n-1))/2\\n                 if(s==e)\\n                 {\\n                     ans = (ans + ((count1%modu)*((count1-1)%modu))/2)%modu;\\n                 }\\n                 \\n                 //if s and e pointers are not at same index we use\\n                 // (n*m)\\n                 if(s!=e)\\n                 {\\n                     ans = (ans + (count1%modu)*(count2%modu))%modu;\\n                 }\\n                 \\n                 s++;\\n                 e--;\\n             }\\n             \\n             else if(sum < target)\\n                 s++;\\n             else\\n                 e--;\\n         }\\n     }\\n     return ans;\\n }      \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        int count = 0, n = arr.size(), modu = 1e9+7;\\n        //store sum and their frequency\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            //if (target-arr[i]) found in map we add its frequency into the count\\n            count = (count + (mp[target-arr[i]])) % modu;\\n            \\n            //iterate from 0 to i-1 and store the frequency of sum\\n            for(int j=0; j<i; j++)\\n            {\\n                mp[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n int threeSumMulti(vector<int>& nums, int target) \\n {\\n     sort(nums.begin(), nums.end());\\n     int n=nums.size();\\n     int ans=0, modu=1e9+7;\\n     long long sum;\\n     \\n     for(int i=0; i<n; i++)\\n     {\\n         int s = i+1;\\n         int e = n-1;\\n         \\n         while(s<e)\\n         {\\n             sum = nums[i]+nums[s]+nums[e];\\n             \\n             if(sum == target)\\n             {\\n                \\n                 int count1 = 1; //count same values for start pointer\\n                 int count2 = 1; //count same values for end pointer\\n                 \\n                 //if value of current and next start pointers are equal, we increase count1\\n                 while(s<e && nums[s]==nums[s+1])\\n                 {\\n                     count1++;\\n                     s++;\\n                 }\\n                 \\n                 //if value of current and next end pointers are equal, we increase count2\\n                 while(s<e && nums[e]==nums[e-1])\\n                 {\\n                     count2++;\\n                     e--;\\n                 }\\n                 \\n                 //we use combination formula to find possible tuples\\n                 //if s and e pointers are at same index we use\\n                 // (n*(n-1))/2\\n                 if(s==e)\\n                 {\\n                     ans = (ans + ((count1%modu)*((count1-1)%modu))/2)%modu;\\n                 }\\n                 \\n                 //if s and e pointers are not at same index we use\\n                 // (n*m)\\n                 if(s!=e)\\n                 {\\n                     ans = (ans + (count1%modu)*(count2%modu))%modu;\\n                 }\\n                 \\n                 s++;\\n                 e--;\\n             }\\n             \\n             else if(sum < target)\\n                 s++;\\n             else\\n                 e--;\\n         }\\n     }\\n     return ans;\\n }      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919180,
                "title": "c-two-pointers-and-hash-map-o-n-n",
                "content": "**Divide the problem in 3 separate parts-**\\n* Count the number of triplets that are distinct.\\n* Count the number of triplets in which 2 integers are same and 1 is different.\\n* Count the number of triplets such that all 3 integers are same\\n\\n**Then our answer will be sum of the three cases.**\\nUsing HashMap we will store the key and frequency. Key is the distinct integer and frequency is the frequency of the key.\\n\\n1. We will construct a new Array which consists of unique integers from the given array. We will use 3 sum (Two Pointers Approach) to count the number of distinct integers.\\n2. We will then have all pairs that are distinct and check for these cases.\\n3. We will then calculate for the third case, if the frequency of the key is greater than equal to 3 and 3key==target then we will count it which is f(f-1)(f-2)/6 where f is frequency of the key. This formula is calculated using fC3 which is number of ways to pick 3 elements from a given set of elements (Combinations in Maths).\\n\\n**COMPLEXITY ANALYSIS:**\\n**TIME: O(N*N)**\\n**SPACE: O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    long func(int num1, int num2, long f1, long f2, int target){\\n        if(f1==1)\\n            return 0;\\n        \\n        if(2*num1+num2!=target)\\n            return 0;\\n        \\n        return (f1*(f1-1)*f2/2)%1000000007;        \\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int res=0;\\n        int mod=1e9+7;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        vector<int> nums;\\n        for(auto it:mp){\\n            nums.push_back(it.first);\\n        }\\n        \\n        n=nums.size();\\n        \\n        //counting 3 distint integers\\n        for(int i=0;i<n-2;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                long sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    res=(res+(mp[nums[i]]*mp[nums[l]]*mp[nums[r]])%mod)%mod;\\n                    l++;\\n                    r--;\\n                }else if(sum>target){\\n                    r--;\\n                }else{\\n                    l++;\\n                }\\n            }\\n        }\\n        \\n        //counting 2 same and 1 distinct integers\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int a=func(nums[i],nums[j],mp[nums[i]],mp[nums[j]],target);\\n                int b=func(nums[j],nums[i],mp[nums[j]],mp[nums[i]],target);\\n                res+=(a+b)%mod;\\n            }\\n        }\\n        \\n        //counting 3 same integers\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>=3 and 3*nums[i]==target){\\n                long long f=mp[nums[i]];\\n                long long cnt=(f*(f-1)*(f-2)/6)%mod;\\n                res+=(cnt)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long func(int num1, int num2, long f1, long f2, int target){\\n        if(f1==1)\\n            return 0;\\n        \\n        if(2*num1+num2!=target)\\n            return 0;\\n        \\n        return (f1*(f1-1)*f2/2)%1000000007;        \\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int res=0;\\n        int mod=1e9+7;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        vector<int> nums;\\n        for(auto it:mp){\\n            nums.push_back(it.first);\\n        }\\n        \\n        n=nums.size();\\n        \\n        //counting 3 distint integers\\n        for(int i=0;i<n-2;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                long sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    res=(res+(mp[nums[i]]*mp[nums[l]]*mp[nums[r]])%mod)%mod;\\n                    l++;\\n                    r--;\\n                }else if(sum>target){\\n                    r--;\\n                }else{\\n                    l++;\\n                }\\n            }\\n        }\\n        \\n        //counting 2 same and 1 distinct integers\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int a=func(nums[i],nums[j],mp[nums[i]],mp[nums[j]],target);\\n                int b=func(nums[j],nums[i],mp[nums[j]],mp[nums[i]],target);\\n                res+=(a+b)%mod;\\n            }\\n        }\\n        \\n        //counting 3 same integers\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>=3 and 3*nums[i]==target){\\n                long long f=mp[nums[i]];\\n                long long cnt=(f*(f-1)*(f-2)/6)%mod;\\n                res+=(cnt)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919141,
                "title": "cpp-easy-hashing",
                "content": "```\\n//if u understand then upvote\\nint threeSumMulti(vector<int>& arr, int target) {\\n        int count=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<arr.size();++i)\\n            mp[arr[i]]++;\\n    \\n        for(int i=0;i<arr.size()-2;++i)\\n        {\\n            int s=i+1;\\n            int e=arr.size()-1;\\n            mp[arr[i]]--;\\n            int tar=target-arr[i];\\n            while(s<e)\\n            {\\n                if(arr[s]+arr[e]==tar)\\n                {\\n                    if(arr[s]!=arr[e])\\n                        count+=(mp[arr[s]]*mp[arr[e]])%1000000007;\\n                    else\\n                    {\\n                        int p=(mp[arr[s]])%1000000007;\\n                        count+=(p*(p-1)/2)%1000000007;\\n                    }\\n                    int k=arr[s];\\n                    while(s<e && arr[s]==k)\\n                    {\\n                        s++;\\n                    }\\n                    k=arr[e];\\n                    while(s<e && arr[e]==k)\\n                    {\\n                            e--;\\n                    }\\n                    \\n                }\\n                else if(arr[s]+arr[e]<tar)\\n                    s++;\\n                else\\n                    e--;\\n            }\\n            count=count%1000000007;\\n        }\\n        \\n        return count%1000000007;\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n//if u understand then upvote\\nint threeSumMulti(vector<int>& arr, int target) {\\n        int count=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<arr.size();++i)\\n            mp[arr[i]]++;\\n    \\n        for(int i=0;i<arr.size()-2;++i)\\n        {\\n            int s=i+1;\\n            int e=arr.size()-1;\\n            mp[arr[i]]--;\\n            int tar=target-arr[i];\\n            while(s<e)\\n            {\\n                if(arr[s]+arr[e]==tar)\\n                {\\n                    if(arr[s]!=arr[e])\\n                        count+=(mp[arr[s]]*mp[arr[e]])%1000000007;\\n                    else\\n                    {\\n                        int p=(mp[arr[s]])%1000000007;\\n                        count+=(p*(p-1)/2)%1000000007;\\n                    }\\n                    int k=arr[s];\\n                    while(s<e && arr[s]==k)\\n                    {\\n                        s++;\\n                    }\\n                    k=arr[e];\\n                    while(s<e && arr[e]==k)\\n                    {\\n                            e--;\\n                    }\\n                    \\n                }\\n                else if(arr[s]+arr[e]<tar)\\n                    s++;\\n                else\\n                    e--;\\n            }\\n            count=count%1000000007;\\n        }\\n        \\n        return count%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918998,
                "title": "easy-c-based-on-twosum",
                "content": "```\\n public int ThreeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        \\n        for(int i=0; i<arr.Length-2; i++)\\n        {\\n            var newTarget = target - arr[i];\\n            result += TwoSum(arr, newTarget, i+1);\\n            result %= (int)Math.Pow(10, 9) + 7;\\n        }\\n        \\n        return (int)result;\\n    }\\n    \\n    private int TwoSum(int[] arr, int target, int startIdx)\\n    {\\n        var visited = new Dictionary<int,int>();\\n        int res = 0;\\n        \\n        for(int i=startIdx; i<arr.Length; i++)\\n        {\\n            var curTarget = target - arr[i];\\n            \\n            if(visited.ContainsKey(curTarget))\\n                res+= visited[curTarget];\\n            \\n            if(!visited.ContainsKey(arr[i]))\\n                visited.Add(arr[i], 0);\\n            \\n            visited[arr[i]]++;\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nThe solution is O(n2) time complexity / O(n2) space complexity, so not very optimized",
                "solutionTags": [],
                "code": "```\\n public int ThreeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        \\n        for(int i=0; i<arr.Length-2; i++)\\n        {\\n            var newTarget = target - arr[i];\\n            result += TwoSum(arr, newTarget, i+1);\\n            result %= (int)Math.Pow(10, 9) + 7;\\n        }\\n        \\n        return (int)result;\\n    }\\n    \\n    private int TwoSum(int[] arr, int target, int startIdx)\\n    {\\n        var visited = new Dictionary<int,int>();\\n        int res = 0;\\n        \\n        for(int i=startIdx; i<arr.Length; i++)\\n        {\\n            var curTarget = target - arr[i];\\n            \\n            if(visited.ContainsKey(curTarget))\\n                res+= visited[curTarget];\\n            \\n            if(!visited.ContainsKey(arr[i]))\\n                visited.Add(arr[i], 0);\\n            \\n            visited[arr[i]]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918959,
                "title": "java-solution-with-two-pointer",
                "content": "\\n\\n```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long count=0;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            \\n            Arrays.sort(arr);\\n            int start = i+1;\\n            int end = arr.length-1;\\n            while(start<end)\\n            {\\n                if(arr[i]+arr[start]+arr[end] == target  && arr[start]!=arr[end]){\\n                    int y=1, x=1;\\n                    int j = start+1, k=end-1;\\n                    while(j < end && arr[start] == arr[j]){\\n                        x++;\\n                        j++;\\n                    }\\n                    while(k > start && arr[end] == arr[k])\\n                    {\\n                        y++;\\n                        k--;\\n                    }\\n                    start = j;\\n                    end = k;\\n                    count += x*y;\\n                }\\n                else if(arr[i]+arr[start]+arr[end] < target)\\n                    start++;\\n                else if(arr[i]+arr[start]+arr[end] > target)\\n                    end--;\\n                else\\n                {\\n                    count += (-start+end+1)*(-start+end)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        // count = count+x;\\n        int ans = (int)(count%(1000000000+7));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long count=0;\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            \\n            Arrays.sort(arr);\\n            int start = i+1;\\n            int end = arr.length-1;\\n            while(start<end)\\n            {\\n                if(arr[i]+arr[start]+arr[end] == target  && arr[start]!=arr[end]){\\n                    int y=1, x=1;\\n                    int j = start+1, k=end-1;\\n                    while(j < end && arr[start] == arr[j]){\\n                        x++;\\n                        j++;\\n                    }\\n                    while(k > start && arr[end] == arr[k])\\n                    {\\n                        y++;\\n                        k--;\\n                    }\\n                    start = j;\\n                    end = k;\\n                    count += x*y;\\n                }\\n                else if(arr[i]+arr[start]+arr[end] < target)\\n                    start++;\\n                else if(arr[i]+arr[start]+arr[end] > target)\\n                    end--;\\n                else\\n                {\\n                    count += (-start+end+1)*(-start+end)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        // count = count+x;\\n        int ans = (int)(count%(1000000000+7));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918731,
                "title": "c",
                "content": "```public class Solution {\\n     private const int MODULO = 1000000007;\\n\\n        public int ThreeSumMulti(int[] nums, int target)\\n        {\\n            checked\\n            {\\n                IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n                foreach (var num in nums)\\n                {\\n                    if (!val2Count.ContainsKey(num))\\n                    {\\n                        val2Count[num] = 0;\\n                    }\\n\\n                    val2Count[num]++;\\n                }\\n\\n                var tuples = val2Count.Select(p => p).ToArray();\\n                Array.Sort(tuples, (t1, t2) => t1.Key.CompareTo(t2.Key));\\n                ulong res = 0;\\n\\n                //distinct numbers\\n                for (int i = 0; i < tuples.Length - 2; i++)\\n                {\\n                    int j = i + 1;\\n                    int k = tuples.Length - 1;\\n\\n                    while (j < k)\\n                    {\\n                        int sum = tuples[i].Key + tuples[j].Key + tuples[k].Key;\\n                        if (sum < target)\\n                        {\\n                            j++;\\n                            continue;\\n                        }\\n\\n                        if (sum > target)\\n                        {\\n                            k--;\\n                            continue;\\n                        }\\n\\n                        res += ((ulong)tuples[i].Value * (ulong)tuples[j].Value * (ulong)tuples[k].Value);\\n                        res = res % MODULO;\\n                        j++;\\n                    }\\n                }\\n\\n\\n                //check duplicates\\n                for (int i = 0; i < tuples.Length; i++)\\n                {\\n                    var num = tuples[i].Key;\\n                    int count = tuples[i].Value;\\n\\n                    if (count < 2)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int third = target - num * 2;\\n                    if (val2Count.ContainsKey(third) && third != num)\\n                    {\\n                        ulong duplicatesCount = ((ulong)(count - 1) * (ulong)count / 2);\\n                        res += (duplicatesCount * (ulong)val2Count[third]);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n\\n\\n                //check triple\\n                if (target % 3 == 0)\\n                {\\n                    int target3 = target / 3;\\n\\n                    if (val2Count.ContainsKey(target3) && val2Count[target3] >= 3)\\n                    {\\n                        int count = val2Count[target3];\\n                        res += ((ulong)(count - 2) * (ulong)(count - 1) * (ulong)count / 6);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return (int)res;\\n            }\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```public class Solution {\\n     private const int MODULO = 1000000007;\\n\\n        public int ThreeSumMulti(int[] nums, int target)\\n        {\\n            checked\\n            {\\n                IDictionary<int, int> val2Count = new Dictionary<int, int>();\\n                foreach (var num in nums)\\n                {\\n                    if (!val2Count.ContainsKey(num))\\n                    {\\n                        val2Count[num] = 0;\\n                    }\\n\\n                    val2Count[num]++;\\n                }\\n\\n                var tuples = val2Count.Select(p => p).ToArray();\\n                Array.Sort(tuples, (t1, t2) => t1.Key.CompareTo(t2.Key));\\n                ulong res = 0;\\n\\n                //distinct numbers\\n                for (int i = 0; i < tuples.Length - 2; i++)\\n                {\\n                    int j = i + 1;\\n                    int k = tuples.Length - 1;\\n\\n                    while (j < k)\\n                    {\\n                        int sum = tuples[i].Key + tuples[j].Key + tuples[k].Key;\\n                        if (sum < target)\\n                        {\\n                            j++;\\n                            continue;\\n                        }\\n\\n                        if (sum > target)\\n                        {\\n                            k--;\\n                            continue;\\n                        }\\n\\n                        res += ((ulong)tuples[i].Value * (ulong)tuples[j].Value * (ulong)tuples[k].Value);\\n                        res = res % MODULO;\\n                        j++;\\n                    }\\n                }\\n\\n\\n                //check duplicates\\n                for (int i = 0; i < tuples.Length; i++)\\n                {\\n                    var num = tuples[i].Key;\\n                    int count = tuples[i].Value;\\n\\n                    if (count < 2)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int third = target - num * 2;\\n                    if (val2Count.ContainsKey(third) && third != num)\\n                    {\\n                        ulong duplicatesCount = ((ulong)(count - 1) * (ulong)count / 2);\\n                        res += (duplicatesCount * (ulong)val2Count[third]);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n\\n\\n                //check triple\\n                if (target % 3 == 0)\\n                {\\n                    int target3 = target / 3;\\n\\n                    if (val2Count.ContainsKey(target3) && val2Count[target3] >= 3)\\n                    {\\n                        int count = val2Count[target3];\\n                        res += ((ulong)(count - 2) * (ulong)(count - 1) * (ulong)count / 6);\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return (int)res;\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918717,
                "title": "cpp-two-pointers-unordered-map-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = pow(10,9)+7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, long long> map;\\n        \\n        for(auto x: arr) map[x]++;\\n                \\n        int k = 0;\\n        \\n        long long res = 0;\\n        \\n        while(k<arr.size()){\\n            \\n            int tbf = target - arr[k];\\n            \\n            int i = k+1, j = arr.size()-1;\\n            \\n            while(i<j){\\n                int sum = arr[i] + arr[j];\\n                if(sum == tbf){\\n                    if(arr[k] == arr[i] && arr[i] == arr[j]){\\n                        long long temp = map[arr[i]];\\n                        long long tba = (temp*(temp-1)*(temp-2))/6;\\n                        res = (res + tba)%mod;\\n                    }\\n                    else if(arr[k] == arr[i]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[j]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else if(arr[i] == arr[j]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[k]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else {\\n                        res = (res + (map[arr[k]]*map[arr[i]]*map[arr[j]])%mod)%mod;\\n                    }\\n                    \\n                    //cout << arr[k] << \" \" << arr[i] << \" \" << arr[j] << \" \" << res << endl; \\n                    \\n                    int tempa = arr[i];\\n                    int tempb = arr[j];\\n                    while(i<j && arr[i] == tempa) i++;\\n                    while(i<j && arr[j] == tempb) j--;\\n                }\\n                else if(sum < tbf) i++;\\n                else j--;\\n            }\\n            \\n            int tempc = arr[k];\\n            while(k < arr.size() && arr[k] == tempc) k++;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int mod = pow(10,9)+7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, long long> map;\\n        \\n        for(auto x: arr) map[x]++;\\n                \\n        int k = 0;\\n        \\n        long long res = 0;\\n        \\n        while(k<arr.size()){\\n            \\n            int tbf = target - arr[k];\\n            \\n            int i = k+1, j = arr.size()-1;\\n            \\n            while(i<j){\\n                int sum = arr[i] + arr[j];\\n                if(sum == tbf){\\n                    if(arr[k] == arr[i] && arr[i] == arr[j]){\\n                        long long temp = map[arr[i]];\\n                        long long tba = (temp*(temp-1)*(temp-2))/6;\\n                        res = (res + tba)%mod;\\n                    }\\n                    else if(arr[k] == arr[i]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[j]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else if(arr[i] == arr[j]){\\n                        long long temp = (map[arr[i]]*(map[arr[i]]-1))/2;\\n                        temp = (temp*map[arr[k]])%mod;\\n                        res += temp%mod;\\n                    }\\n                    else {\\n                        res = (res + (map[arr[k]]*map[arr[i]]*map[arr[j]])%mod)%mod;\\n                    }\\n                    \\n                    //cout << arr[k] << \" \" << arr[i] << \" \" << arr[j] << \" \" << res << endl; \\n                    \\n                    int tempa = arr[i];\\n                    int tempb = arr[j];\\n                    while(i<j && arr[i] == tempa) i++;\\n                    while(i<j && arr[j] == tempb) j--;\\n                }\\n                else if(sum < tbf) i++;\\n                else j--;\\n            }\\n            \\n            int tempc = arr[k];\\n            while(k < arr.size() && arr[k] == tempc) k++;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1918552,
                "title": "easy-explanation-intuitive-explained-100-2-ways-java-cpp-python",
                "content": "\\n\\n```**(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, please upvote this post.)\\n\\nIdea:\\nThe naive approach here would be to attempt all permutations, but that would run up to 2.7e10 attempts. The first important thing to notice is that the range of numbers is very small at [0,100]. With that few number options, any large input array (A) will have many duplicates, which means we\\'re looking at a combinatorics solution.\\n\\nIn order to use the combinatorics shortcut, however, we\\'ll first have to make a frequency map of the numbers in A. We could always use a standard map for this, but since the range of numbers is so small and 0-indexed, it makes more sense to use an array instead.\\n\\nAfter we\\'ve iterated through A and filled our number map (nmap) with the number frequencies, we can get down to the real work. The normal approach here would be to figure out the distinct numbers available and use nested loops to attempt every possible permutation. But rather than doing this, which would require many array calls, we can again take advantage of the fact that the number range is so small.\\n\\nWe can iterate through every possible permutation from [0,100], regardless of wheter the numbers are in A. Since we\\'ve made a frequency map, those numbers will be represented as 0\\'s, which will handily prevent anything from being added to our answer (ans) for permutations that we can\\'t make, and by using simple math instead of many array calls, we can actually be more performant.\\n\\nStill, there are ways to streamline this process. The basic approach will be to use a 2-pointer system to find two of our values and then mathematically figure the third, before applying the proper permutation formula to the values.\\n\\nIt should be apparent that our largest value (k) can never go above the target (T), nor can it obviously go above the max value of 100, so we can start it out at min(T, 100) and decrement from there. Also, since it will always represents the largest of the three values, it can never go below T / 3, because then the two smaller numbers would never be able to bring it up to T.\\n\\nMoving down to the next value (j), we can see that it can never be larger than k by definition, nor can it be larger than the remaining amount of space (rem) left to T, so we should start it at min(rem, k). Similar to k, j can also never go below rem / 2.\\n\\nOnce we have two of the three values, we can check for their frequencies. If any of them are 0\\'s, then it will automatically make the result of its permutation check a 0 as well. We can also potentially save some processing by checking for 0\\'s and continuing before applying the combinatorics formulas.\\n\\nIf i == k, then we know that i == j == k because j has to be between i and k, so we\\'ll have to use the n choose 3 formula. We should also check if any two other values are the same, then we should use (n choose 2) * (n choose 1). Otherwise, we can just use the simple combinations formula.\\n\\nThen it\\'s important to remember to apply the modulo before returning.\\n\\nImplementation:\\nJavascript was actually faster with an approach that featured isolating the actual distinct elements, sorting them, and then running efficiently through the combinations, but the code was much longer and more complex. This method is much easier and nearly as fast. In either case, we should use a typed array here for the arraymap.\\n\\nJava was oddly slower at the iteration shortcuts and actually ran faster without the added processes.\\n\\nJava and C++ should use long for their ans (prior to returning it, at least), and even for nmap, otherwise we\\'ll have to cast those values to long each time anyway.\\n\\nJavascript Code:\\nThe best result for the code below is 68ms / 40.5MB (beats 100% / 80%).\\n\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\nPython Code:\\nThe best result for the code below is 60ms / 14.2MB (beats 100% / 92%).\\n\\n**class Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\nJava Code:\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < arr.length; i++) {\\n            res = (res + map.getOrDefault(target - arr[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = arr[i] + arr[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n\\n// 2nd method \\n\\nclass Solution {\\n    public int threeSumMulti(int[] A, int target) {\\n       int mod=1_000_000_007;\\n        long[] count=new long[101];\\n        int uniq=0;\\n        for(var v:A){\\n            count[v]++;\\n            if(count[v]==1)uniq++;\\n        }\\n        int key[]=new int[uniq];\\n        int t=0;\\n        for(int i=0;i<=100;i++)\\n            if(count[i]>0)key[t++]=i;\\n        long ans=0;\\n        for(int i=0;i<key.length;i++){\\n            int x=key[i];\\n            int T=target-x;\\n            int j=i,k=key.length-1;\\n            while(j<=k){\\n                int y=key[j],z=key[k];\\n                if(y+z<T)j++;\\n                else if(y+z>T)k--;\\n                else{\\n                    if(i<j&&j<k) ans+=count[x]*count[y]*count[z];\\n                    else if(i==j&&j<k) ans+=count[x]*(count[x]-1)/2*count[z];\\n                    else  if(i<j&&j==k)ans+=count[x]*count[y]*(count[y]-1)/2;\\n                    else ans+=count[x]*(count[x]-1)*(count[x]-2)/6;\\n                     ans%=mod;\\n                j++;\\n                k--;\\n                }\\n            }\\n        } return (int) ans;\\n    }\\n}\\n\\n\\n\\n**class Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n\\n\\nC++ Code:\\nThe best result for the code below is 4ms / 10.2MB (beats 99% / 100%).\\n\\n**class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};**\\n\\nReference link provided by my fans in comments... Thankyou :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "class Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\nJava Code:\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int res = 0;\\n        int mod = 1000000007;\\n        for (int i = 0; i < arr.length; i++) {\\n            res = (res + map.getOrDefault(target - arr[i], 0)) % mod;\\n            \\n            for (int j = 0; j < i; j++) {\\n                int temp = arr[i] + arr[j];\\n                map.put(temp, map.getOrDefault(temp, 0) + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1918451,
                "title": "solution-o-n-faster-than-90-and-less-memory-than-75-of-memory-of-c-codes",
                "content": "```\\nclass Solution {\\nprivate:\\n    const int MOD = 1e9 + 7;\\n    // combination 3  nC3\\n    long long c3(long long n) {\\n        return n*(n-1)*(n-2)/6;\\n    }\\n    // combination 2  nC2\\n    long long c2(long long n) {\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> nums;\\n        // convert the array to numbers with its frequancy\\n        for (int &i: arr) {\\n            if (!nums.count(i))\\n                nums[i] = 0;\\n            nums[i]++;\\n        }\\n        // get all unique numbers\\n        vector<int> it;\\n        for (auto i : nums) {\\n            it.push_back(i.first);\\n        }\\n        long long ans = 0;\\n        // iterate on all possible solutions\\n        for (int i = 0; i < it.size() ; i++) {\\n            for (int j = i+1; j < it.size() ; j++) {\\n                int needed = target-it[i]-it[j];\\n                if (nums.count(needed)) {\\n                    // make sure it is unique\\n                    if (needed != it[i] && needed != it[j]) {\\n                        ans = (ans + nums[needed]*nums[it[i]]*nums[it[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        // to remove repeation cause the loop may count the same thing 3 times\\n        ans /= 3;\\n        // get all solution when they are two or more are the same number\\n        for (int & i : it) {\\n            int needed = target - i*2;\\n            if (nums.count(needed)) {\\n                // it 3 of them are the same\\n                if (needed == i) {\\n                    ans = (ans + c3(nums[i]))%MOD;\\n                } else { // if there are only two the same\\n                    ans = (ans + nums[needed]*c2(nums[i]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int MOD = 1e9 + 7;\\n    // combination 3  nC3\\n    long long c3(long long n) {\\n        return n*(n-1)*(n-2)/6;\\n    }\\n    // combination 2  nC2\\n    long long c2(long long n) {\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> nums;\\n        // convert the array to numbers with its frequancy\\n        for (int &i: arr) {\\n            if (!nums.count(i))\\n                nums[i] = 0;\\n            nums[i]++;\\n        }\\n        // get all unique numbers\\n        vector<int> it;\\n        for (auto i : nums) {\\n            it.push_back(i.first);\\n        }\\n        long long ans = 0;\\n        // iterate on all possible solutions\\n        for (int i = 0; i < it.size() ; i++) {\\n            for (int j = i+1; j < it.size() ; j++) {\\n                int needed = target-it[i]-it[j];\\n                if (nums.count(needed)) {\\n                    // make sure it is unique\\n                    if (needed != it[i] && needed != it[j]) {\\n                        ans = (ans + nums[needed]*nums[it[i]]*nums[it[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        // to remove repeation cause the loop may count the same thing 3 times\\n        ans /= 3;\\n        // get all solution when they are two or more are the same number\\n        for (int & i : it) {\\n            int needed = target - i*2;\\n            if (nums.count(needed)) {\\n                // it 3 of them are the same\\n                if (needed == i) {\\n                    ans = (ans + c3(nums[i]))%MOD;\\n                } else { // if there are only two the same\\n                    ans = (ans + nums[needed]*c2(nums[i]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918443,
                "title": "c-simple-approach-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int mod = 1e9+7;\\n        int count = 0;\\n        unordered_map<int,int> m;\\n        for(int i=0; i<arr.size(); i++) {\\n            count = (count + m[target-arr[i]])%mod;\\n            for(int j=0; j<i; j++) {\\n                m[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int mod = 1e9+7;\\n        int count = 0;\\n        unordered_map<int,int> m;\\n        for(int i=0; i<arr.size(); i++) {\\n            count = (count + m[target-arr[i]])%mod;\\n            for(int j=0; j<i; j++) {\\n                m[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800296,
                "title": "only-few-lines-of-code-c-simple",
                "content": "\\t   inline int threeSumMulti(vector<int>& arr, int target)\\n\\t\\t{\\n        int res=0;\\n        int n=arr.size();\\n        \\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {   \\n            for(int j=i+1;j<n;j++)\\n                    res+=hash[target-arr[i]-arr[j]];\\n         \\n            hash[arr[i]]++; \\n         \\n          res%=int(1e9+7);\\n        }      \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\t   inline int threeSumMulti(vector<int>& arr, int target)\\n\\t\\t{\\n        int res=0;\\n        int n=arr.size();\\n        \\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {   \\n            for(int j=i+1;j<n;j++)\\n                    res+=hash[target-arr[i]-arr[j]];\\n         \\n            hash[arr[i]]++; \\n         \\n          res%=int(1e9+7);\\n        }      \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1650007,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }\\n        long ans=0l;\\n        for(int e1: map.keySet()){\\n            for(int e2: map.keySet()){\\n                int e3 = target-e1-e2;\\n                if(map.containsKey(e3)){\\n                    long freq1 = map.get(e1);\\n                    long freq2 = map.get(e2);\\n                    long freq3 = map.get(e3);\\n                    if(e1==e2 && e2==e3)\\n                    ans+=((freq1)*(freq2-1)*(freq3-2))/6;\\n                else if(e1==e2 && e1!=e3)\\n                    ans+=((freq1)*(freq2-1))/2*freq3;\\n                else if(e1<e2 && e2<e3)\\n                    ans+=freq1*freq2*freq3;\\n               \\n                }\\n               ans = ans%1000000007; \\n                \\n            }\\n             \\n        }\\n           return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }\\n        long ans=0l;\\n        for(int e1: map.keySet()){\\n            for(int e2: map.keySet()){\\n                int e3 = target-e1-e2;\\n                if(map.containsKey(e3)){\\n                    long freq1 = map.get(e1);\\n                    long freq2 = map.get(e2);\\n                    long freq3 = map.get(e3);\\n                    if(e1==e2 && e2==e3)\\n                    ans+=((freq1)*(freq2-1)*(freq3-2))/6;\\n                else if(e1==e2 && e1!=e3)\\n                    ans+=((freq1)*(freq2-1))/2*freq3;\\n                else if(e1<e2 && e2<e3)\\n                    ans+=freq1*freq2*freq3;\\n               \\n                }\\n               ans = ans%1000000007; \\n                \\n            }\\n             \\n        }\\n           return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638822,
                "title": "c-easy-to-understand-brute-force-and-optimized",
                "content": "**Brute force approach**\\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n     \\n      long long c=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          vector<int> count(101,0);\\n          \\n          for(int j=i+1;j<n;j++)\\n          {\\n              int k=target-arr[i]-arr[j];\\n              if(k>=0&&k<=100&&count[k]>0)\\n              {\\n                  c+=count[k];\\n                  c%=mod;\\n              }\\n              count[arr[j]]++;\\n          }\\n      }\\n        return (int)c;\\n    }\\n};\\n```\\n**Optimized approach**\\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n      vector<long long> c(101,0);\\n        for(int i=0;i<n;i++)\\n        c[arr[i]]++;\\n        long long int result=0;\\n        for(int i = 0; i <= 100; i++) {\\n            for(int j = i; j <= 100; j++) {\\n                int k = target-i-j;\\n                if(k<0 || k >100) continue;\\n                if(i == j && j==k) {\\n                    result+= (c[i] * (c[i]-1) * (c[i]-2) /6);\\n                }\\n                else if(i == j && j != k) {\\n                    result += ((c[i] * (c[i]-1) /2 ) * c[k]);\\n                }\\n                else if(i < j && j < k) {\\n                    result += (c[i] * c[j] * c[k]);\\n                }\\n            }\\n        }\\n        return (int)(result%mod);\\n    }\\n};\\n```\\n**Another optimized approach using map**\\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int,long> mp;\\n        for(int &x:arr)\\n        {\\n            mp[x]++;\\n        }\\n        long long int ans=0;\\n        for(auto &pr:mp)\\n        {\\n            int i=pr.first;\\n            for(auto &pr2:mp)\\n            {\\n                int j=pr2.first;\\n                int k=target-i-j;\\n                if(k<0||k>100||mp.find(k)==mp.end())\\n                continue;\\n                if(i==j&&j==k)\\n                {\\n                    ans+=mp[i]*(mp[i]-1)*(mp[i]-2)/6;\\n                }\\n                else if(i==j&&j!=k)\\n                {\\n                    ans+=mp[k]*mp[i]*(mp[i]-1)/2;\\n                }\\n                else if(i<j&&j<k)\\n                {\\n                    ans+=mp[i]*mp[j]*mp[k];\\n                }\\n            }\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n     \\n      long long c=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          vector<int> count(101,0);\\n          \\n          for(int j=i+1;j<n;j++)\\n          {\\n              int k=target-arr[i]-arr[j];\\n              if(k>=0&&k<=100&&count[k]>0)\\n              {\\n                  c+=count[k];\\n                  c%=mod;\\n              }\\n              count[arr[j]]++;\\n          }\\n      }\\n        return (int)c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n      int n=arr.size();\\n      vector<long long> c(101,0);\\n        for(int i=0;i<n;i++)\\n        c[arr[i]]++;\\n        long long int result=0;\\n        for(int i = 0; i <= 100; i++) {\\n            for(int j = i; j <= 100; j++) {\\n                int k = target-i-j;\\n                if(k<0 || k >100) continue;\\n                if(i == j && j==k) {\\n                    result+= (c[i] * (c[i]-1) * (c[i]-2) /6);\\n                }\\n                else if(i == j && j != k) {\\n                    result += ((c[i] * (c[i]-1) /2 ) * c[k]);\\n                }\\n                else if(i < j && j < k) {\\n                    result += (c[i] * c[j] * c[k]);\\n                }\\n            }\\n        }\\n        return (int)(result%mod);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int,long> mp;\\n        for(int &x:arr)\\n        {\\n            mp[x]++;\\n        }\\n        long long int ans=0;\\n        for(auto &pr:mp)\\n        {\\n            int i=pr.first;\\n            for(auto &pr2:mp)\\n            {\\n                int j=pr2.first;\\n                int k=target-i-j;\\n                if(k<0||k>100||mp.find(k)==mp.end())\\n                continue;\\n                if(i==j&&j==k)\\n                {\\n                    ans+=mp[i]*(mp[i]-1)*(mp[i]-2)/6;\\n                }\\n                else if(i==j&&j!=k)\\n                {\\n                    ans+=mp[k]*mp[i]*(mp[i]-1)/2;\\n                }\\n                else if(i<j&&j<k)\\n                {\\n                    ans+=mp[i]*mp[j]*mp[k];\\n                }\\n            }\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215507,
                "title": "c-casewise",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    int X;\\n    ll unq(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<99;i++)\\n        {\\n            int j=i+1,k=100;\\n            while(j<k)\\n            {\\n                int sum=i+j+k;\\n                if(sum==X)\\n                {\\n                    res=(res+count[i]*count[j]*count[k])%mod;\\n                    j++;\\n                    k--;\\n                }\\n                else if(sum<X)\\n                    j++;\\n                else\\n                    k--;\\n            }\\n        }\\n        return res;\\n    }\\n    ll same2(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<=100;i++)\\n        {\\n            int req=X-2*i;\\n            if(req>=0 && req!=i && req<=100)\\n                res=(res+count[i]*(count[i]-1)/2*count[req])%mod;\\n        }\\n        return res;\\n    }\\n    ll same3(vector<ll>&count)\\n    {\\n        ll res=0;\\n        if(X%3==0)\\n        {\\n            int x=X/3;\\n            ll n=count[x];\\n            res=(n*(n-1)*(n-2))/6;\\n        }\\n        return res%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        X=target;\\n        vector<ll>count(101,0);\\n        for(auto x:arr)\\n            count[x]++;\\n        ll unique=unq(count);\\n        ll twosame=same2(count);\\n        ll allsame=same3(count);\\n        return (unique+twosame+allsame)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    int X;\\n    ll unq(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<99;i++)\\n        {\\n            int j=i+1,k=100;\\n            while(j<k)\\n            {\\n                int sum=i+j+k;\\n                if(sum==X)\\n                {\\n                    res=(res+count[i]*count[j]*count[k])%mod;\\n                    j++;\\n                    k--;\\n                }\\n                else if(sum<X)\\n                    j++;\\n                else\\n                    k--;\\n            }\\n        }\\n        return res;\\n    }\\n    ll same2(vector<ll>&count)\\n    {\\n        ll res=0;\\n        for(int i=0;i<=100;i++)\\n        {\\n            int req=X-2*i;\\n            if(req>=0 && req!=i && req<=100)\\n                res=(res+count[i]*(count[i]-1)/2*count[req])%mod;\\n        }\\n        return res;\\n    }\\n    ll same3(vector<ll>&count)\\n    {\\n        ll res=0;\\n        if(X%3==0)\\n        {\\n            int x=X/3;\\n            ll n=count[x];\\n            res=(n*(n-1)*(n-2))/6;\\n        }\\n        return res%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        X=target;\\n        vector<ll>count(101,0);\\n        for(auto x:arr)\\n            count[x]++;\\n        ll unique=unq(count);\\n        ll twosame=same2(count);\\n        ll allsame=same3(count);\\n        return (unique+twosame+allsame)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124713,
                "title": "java-simple-and-easy-to-understand-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        \\n        long tupleCount = 0;\\n        \\n        \\n        for(int i = 0; i < arr.length; i++){\\n            tupleCount += getCountPairsTwoSum(arr, i + 1, target - arr[i]);\\n            tupleCount %= MOD;\\n        }\\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    private int getCountPairsTwoSum(int[] arr, int startIndex, int target){\\n        int l = startIndex;\\n        int r = arr.length - 1;\\n        \\n        long pairsCount = 0;\\n        \\n        while(l < r){\\n            \\n            \\n            if(arr[l] + arr[r] < target){\\n                l++;\\n            }else if(arr[l] + arr[r] > target){\\n                r--;\\n            }else if(arr[l] != arr[r]){\\n            \\n                int left = 1;\\n                while(l + 1 < r && arr[l] == arr[l + 1]){\\n                    left++;\\n                    l++;\\n                }\\n                \\n                int right = 1;\\n                while(r - 1 > l && arr[r] == arr[r - 1]){\\n                    right++;\\n                    r--;\\n                }\\n                \\n                pairsCount += (left * right);\\n                pairsCount %= MOD;\\n                \\n                l++;\\n                r--;\\n                \\n            }else if(arr[l] == arr[r]){\\n                \\n                int numCount = r - l + 1;\\n                pairsCount += numCount * (numCount - 1) / 2; \\n                \\n                pairsCount %= MOD;\\n                \\n                break;\\n            }\\n            \\n            \\n        }\\n        \\n        return (int)pairsCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int MOD = 1_000_000_007; \\n    \\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        \\n        long tupleCount = 0;\\n        \\n        \\n        for(int i = 0; i < arr.length; i++){\\n            tupleCount += getCountPairsTwoSum(arr, i + 1, target - arr[i]);\\n            tupleCount %= MOD;\\n        }\\n        \\n        return (int) tupleCount;\\n    }\\n    \\n    private int getCountPairsTwoSum(int[] arr, int startIndex, int target){\\n        int l = startIndex;\\n        int r = arr.length - 1;\\n        \\n        long pairsCount = 0;\\n        \\n        while(l < r){\\n            \\n            \\n            if(arr[l] + arr[r] < target){\\n                l++;\\n            }else if(arr[l] + arr[r] > target){\\n                r--;\\n            }else if(arr[l] != arr[r]){\\n            \\n                int left = 1;\\n                while(l + 1 < r && arr[l] == arr[l + 1]){\\n                    left++;\\n                    l++;\\n                }\\n                \\n                int right = 1;\\n                while(r - 1 > l && arr[r] == arr[r - 1]){\\n                    right++;\\n                    r--;\\n                }\\n                \\n                pairsCount += (left * right);\\n                pairsCount %= MOD;\\n                \\n                l++;\\n                r--;\\n                \\n            }else if(arr[l] == arr[r]){\\n                \\n                int numCount = r - l + 1;\\n                pairsCount += numCount * (numCount - 1) / 2; \\n                \\n                pairsCount %= MOD;\\n                \\n                break;\\n            }\\n            \\n            \\n        }\\n        \\n        return (int)pairsCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123842,
                "title": "python-recursion-memoization",
                "content": "This question shares a lot of similarities with your 0/1 knapsack problem whereby we can think of the number of the number of ways as a sum of including and not including that particular index.  For such questions whereby the bottom up solution is not obvious writing a recursive solution might be more obvious.\\n\\nTime complexity: O(3NK), N is length of arr and K is target value --> we visit each state once so this is time complexity\\nSpace complexity: O(3NK) Since we cache previous results --> same complexity as time complexity\\n\\n```\\nclass Solution:\\n    def recurse(self,arr,index,target,capacity,memo):\\n        MOD = 10**9 + 7\\n        \\n        if capacity == 0:\\n            return 1 if target == 0 else 0\\n\\n        if index < 0:\\n            return 0\\n        \\n        if (index,target,capacity) in memo:\\n            return memo[(index,target,capacity)]\\n        \\n        take = self.recurse(arr,index-1,target-arr[index],capacity-1,memo) # take it\\n        dont_take = self.recurse(arr, index-1,target,capacity,memo )\\n        memo[(index,target,capacity)] = ( take + dont_take ) % MOD\\n        return memo[(index,target,capacity)]\\n        \\n    \\n    \\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        return self.recurse(arr,len(arr)-1,target,3,{})\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recurse(self,arr,index,target,capacity,memo):\\n        MOD = 10**9 + 7\\n        \\n        if capacity == 0:\\n            return 1 if target == 0 else 0\\n\\n        if index < 0:\\n            return 0\\n        \\n        if (index,target,capacity) in memo:\\n            return memo[(index,target,capacity)]\\n        \\n        take = self.recurse(arr,index-1,target-arr[index],capacity-1,memo) # take it\\n        dont_take = self.recurse(arr, index-1,target,capacity,memo )\\n        memo[(index,target,capacity)] = ( take + dont_take ) % MOD\\n        return memo[(index,target,capacity)]\\n        \\n    \\n    \\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        return self.recurse(arr,len(arr)-1,target,3,{})\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123664,
                "title": "python-go-o-n-based-on-3-sum-w-comment",
                "content": "Python O(n) based on 3 sum\\n\\n---\\n\\n**Implementation** based on 3 sum in Python\\n\\n```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        ## dictionary\\n        # key : distinct number\\n        # value : occurrence of distinct number\\n        counts = Counter(arr)\\n        \\n        # total method count, and modulo constant\\n        result, constant = 0, (10 ** 9 + 7)\\n        \\n        \\n        # find the method count where i + j + k = target\\n        # all numbers are bounded in interval [0, 100]\\n        \\n        for i in range(101):\\n            \\n            if counts[i] == 0:\\n                \\n                # number i doesn\\'t show up in input array\\n                continue\\n                \\n            j, k = i, 100\\n            \\n            # find j, k with two-pointers\\n            while j <= k:\\n                \\n                if j + k > target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too large, try to make it smaller\\n                    k -= 1\\n                    \\n                elif j + k < target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too small, try to make it larger\\n                    j += 1\\n                    \\n                else:\\n                    \\n                    # update result with different combination cases\\n                    \\n                    if i == j == k:\\n                        \\n                        # all repeated: (i, j, k) = (i, i, i)\\n                        result += counts[i] * (counts[i] - 1) * (counts[i] - 2) // 6\\n                        \\n                    elif i == j:\\n                        # i, j repeated: (i, j, k) = (i, i, k)\\n                        result += counts[i] * (counts[i] - 1) * counts[k] // 2\\n                        \\n                    elif j == k:\\n                        # i, k repeated: (i, j, k) = (i, j, j)\\n                        result += counts[i] * counts[j] * (counts[j] - 1) // 2\\n                        \\n                    else:\\n                        # all distinct: (i, j, k)\\n                        result += counts[i] * counts[j] * counts[k]\\n                    \\n                    \\n                    # update two pointers for j, k\\n                    j += 1\\n                    k -= 1\\n                    \\n        return result % constant\\n```\\n\\n---\\n\\n**Implementation** based on 3 sum in Go\\n\\n```\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    //// dictionary\\n    // key: distinct number\\n    // value: occurrence of distinct number\\n    counts := genDictionary( arr )\\n    \\n\\n    \\n    // total method count, and modulo constant\\n    result, constant := 0, int(math.Pow10(9)) + 7\\n    \\n    \\n    // find the method count where i + j + k = target\\n    // all numbers are bounded in interval [0, 100]\\n    \\n    for i := 0 ; i <= 100 ; i++{\\n        \\n        if counts[i] == 0{\\n            \\n            // number i doesn\\'t show up in input array\\n            continue\\n        }\\n        \\n        j, k := i, 100\\n        \\n        // find j, k with two-pointers\\n        for j <= k {\\n        \\n            \\n            if (j + k) > (target - i){\\n\\n                // j + k is too large, try to make it smaller\\n                k -= 1\\n\\n            }else if (j + k) < (target - i){\\n\\n                // j + k is too small, try to make it larger\\n                j += 1\\n\\n            }else{\\n                \\n                // update result with difference combination cases\\n                if (i == j) && (j == k) {\\n                         \\n                    // all repeated: (i, j, k) = (i, i, i)\\n                    result += counts[i] * (counts[i] - 1) * (counts[i] - 2) / 6\\n\\n                }else if (i == j){\\n\\n                    // i, j repeated: (i, j, k) = (i, i, k)\\n                    result += counts[i] * (counts[i] - 1) * (counts[k] ) / 2\\n\\n                }else if (j == k){\\n\\n                    // j, k repeated: (i, j, k) = (i, j, j)\\n                    result += counts[i] * (counts[j] ) * (counts[j] - 1) / 2\\n\\n                }else{\\n\\n                    // all distinct: (i, j, k)\\n                    result += counts[i] * counts[j] * counts[k]\\n                    \\n                }\\n                \\n                \\n                // update two-pointers for j, k\\n                j, k = j+1, k-1\\n            }\\n\\n        }\\n        //end of j <= k loop\\n        \\n    }\\n    //end of i loop\\n    \\n    \\n    \\n    return result % constant\\n}\\n\\nfunc genDictionary( arr []int)( number_occ_dict map[int]int) {\\n    \\n    number_occ_dict = make(map[int]int, 101)\\n    \\n    for _, number := range arr{\\n        number_occ_dict[number] += 1\\n    }\\n    return\\n}\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #15  3-Sum](https://leetcode.com/problems/3sum/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about Counter( ... ) ](https://docs.python.org/3/library/collections.html#collections.Counter)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Math",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        ## dictionary\\n        # key : distinct number\\n        # value : occurrence of distinct number\\n        counts = Counter(arr)\\n        \\n        # total method count, and modulo constant\\n        result, constant = 0, (10 ** 9 + 7)\\n        \\n        \\n        # find the method count where i + j + k = target\\n        # all numbers are bounded in interval [0, 100]\\n        \\n        for i in range(101):\\n            \\n            if counts[i] == 0:\\n                \\n                # number i doesn\\'t show up in input array\\n                continue\\n                \\n            j, k = i, 100\\n            \\n            # find j, k with two-pointers\\n            while j <= k:\\n                \\n                if j + k > target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too large, try to make it smaller\\n                    k -= 1\\n                    \\n                elif j + k < target - i:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# j + k is too small, try to make it larger\\n                    j += 1\\n                    \\n                else:\\n                    \\n                    # update result with different combination cases\\n                    \\n                    if i == j == k:\\n                        \\n                        # all repeated: (i, j, k) = (i, i, i)\\n                        result += counts[i] * (counts[i] - 1) * (counts[i] - 2) // 6\\n                        \\n                    elif i == j:\\n                        # i, j repeated: (i, j, k) = (i, i, k)\\n                        result += counts[i] * (counts[i] - 1) * counts[k] // 2\\n                        \\n                    elif j == k:\\n                        # i, k repeated: (i, j, k) = (i, j, j)\\n                        result += counts[i] * counts[j] * (counts[j] - 1) // 2\\n                        \\n                    else:\\n                        # all distinct: (i, j, k)\\n                        result += counts[i] * counts[j] * counts[k]\\n                    \\n                    \\n                    # update two pointers for j, k\\n                    j += 1\\n                    k -= 1\\n                    \\n        return result % constant\\n```\n```\\nfunc threeSumMulti(arr []int, target int) int {\\n    \\n    //// dictionary\\n    // key: distinct number\\n    // value: occurrence of distinct number\\n    counts := genDictionary( arr )\\n    \\n\\n    \\n    // total method count, and modulo constant\\n    result, constant := 0, int(math.Pow10(9)) + 7\\n    \\n    \\n    // find the method count where i + j + k = target\\n    // all numbers are bounded in interval [0, 100]\\n    \\n    for i := 0 ; i <= 100 ; i++{\\n        \\n        if counts[i] == 0{\\n            \\n            // number i doesn\\'t show up in input array\\n            continue\\n        }\\n        \\n        j, k := i, 100\\n        \\n        // find j, k with two-pointers\\n        for j <= k {\\n        \\n            \\n            if (j + k) > (target - i){\\n\\n                // j + k is too large, try to make it smaller\\n                k -= 1\\n\\n            }else if (j + k) < (target - i){\\n\\n                // j + k is too small, try to make it larger\\n                j += 1\\n\\n            }else{\\n                \\n                // update result with difference combination cases\\n                if (i == j) && (j == k) {\\n                         \\n                    // all repeated: (i, j, k) = (i, i, i)\\n                    result += counts[i] * (counts[i] - 1) * (counts[i] - 2) / 6\\n\\n                }else if (i == j){\\n\\n                    // i, j repeated: (i, j, k) = (i, i, k)\\n                    result += counts[i] * (counts[i] - 1) * (counts[k] ) / 2\\n\\n                }else if (j == k){\\n\\n                    // j, k repeated: (i, j, k) = (i, j, j)\\n                    result += counts[i] * (counts[j] ) * (counts[j] - 1) / 2\\n\\n                }else{\\n\\n                    // all distinct: (i, j, k)\\n                    result += counts[i] * counts[j] * counts[k]\\n                    \\n                }\\n                \\n                \\n                // update two-pointers for j, k\\n                j, k = j+1, k-1\\n            }\\n\\n        }\\n        //end of j <= k loop\\n        \\n    }\\n    //end of i loop\\n    \\n    \\n    \\n    return result % constant\\n}\\n\\nfunc genDictionary( arr []int)( number_occ_dict map[int]int) {\\n    \\n    number_occ_dict = make(map[int]int, 101)\\n    \\n    for _, number := range arr{\\n        number_occ_dict[number] += 1\\n    }\\n    return\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123455,
                "title": "3sum-with-multiplicity-c-easy-solution-short-and-simple-code-with-explanation",
                "content": "The intuition is pretty simple, there are many approaches to solve this problem, this may not be efficient but quite easy and enough to solve this one.\\nThe idea is we check whether there is two numbers such that their sum equal to `target-arr[i]`. And we store sum every possible pair `arr[i]+arr[j]` such that ` j<i` in a `unordered_map`. \\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n      int res = 0, mod = 1e9+7;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < arr.size(); i++) {\\n            res = (res + mp[target-arr[i]]) % mod;\\n            for(int j = 0; j < i; j++) mp[arr[i]+arr[j]]++;\\n        }\\n        return res;\\n    }\\n```\\n**Efficient one**:\\nthe idea is  we count the frequency of each number using a unordered_map. \\nwe check if k = target - a-b is possible or not. we need to take care of 3 cases,\\n-> a == b == k   \\n-> a == b != k   \\n-> a < b && b < k \\n\\n**Please upvote** if you find it helpful!!\\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n       unordered_map<int, long> m;\\n        for (int n : arr) m[n]++;\\n        long res = 0;\\n        for (auto it : m)\\n            for (auto it2 : m) {\\n                int a = it.first, b = it2.first;\\n                int k= target - a - b;\\n                if (m.find(k)!=m.end()){\\n                    if (a == b && b == k)\\n                        res += m[a] * (m[a] - 1) * (m[a] - 2) / 6;\\n                    else if (a == b && b != k)\\n                        res += m[a] * (m[a]- 1) / 2 * m[k];\\n                    else if (a < b && b < k)\\n                        res += m[a] * m[b] * m[k];\\n                }\\n            }\\n        return res % 1000000007;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n      int res = 0, mod = 1e9+7;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < arr.size(); i++) {\\n            res = (res + mp[target-arr[i]]) % mod;\\n            for(int j = 0; j < i; j++) mp[arr[i]+arr[j]]++;\\n        }\\n        return res;\\n    }\\n```\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n       unordered_map<int, long> m;\\n        for (int n : arr) m[n]++;\\n        long res = 0;\\n        for (auto it : m)\\n            for (auto it2 : m) {\\n                int a = it.first, b = it2.first;\\n                int k= target - a - b;\\n                if (m.find(k)!=m.end()){\\n                    if (a == b && b == k)\\n                        res += m[a] * (m[a] - 1) * (m[a] - 2) / 6;\\n                    else if (a == b && b != k)\\n                        res += m[a] * (m[a]- 1) / 2 * m[k];\\n                    else if (a < b && b < k)\\n                        res += m[a] * m[b] * m[k];\\n                }\\n            }\\n        return res % 1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 645510,
                "title": "simple-c-dp-solution-o-n-300-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int dp[4][305];\\n        int mod = 1000000007;\\n        memset(dp, 0, sizeof(dp));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int k = 3; k >= 1; k--) {\\n                for (int j = 300; j >= A[i]; j--) {\\n                    dp[k][j] = (dp[k][j] + dp[k - 1][j - A[i]]) % mod;\\n                }\\n            }\\n        }\\n        return dp[3][target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        int dp[4][305];\\n        int mod = 1000000007;\\n        memset(dp, 0, sizeof(dp));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int k = 3; k >= 1; k--) {\\n                for (int j = 300; j >= A[i]; j--) {\\n                    dp[k][j] = (dp[k][j] + dp[k - 1][j - A[i]]) % mod;\\n                }\\n            }\\n        }\\n        return dp[3][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547336,
                "title": "kotlin-beats-100-space-time-o-n-2",
                "content": "The short explanation: Math. The intuition behind the formulas is all basic combinatorics.\\n\\nThe long explanation:\\n1. Sort the numbers - **O(n log n)**.\\n2. Memoize the counts of each distinct integer - **O(n)**.\\n3. Solve number of solutions for i, j, k using derived formulas = `count(A[i], A[j], A[k])`- **O(log A[x])**. \\n4. Using a loop with binary search, iterate over all distinct integers from left to right, using our `count` function as we go - **O(n^2)**.\\n(*Note: Steps 1 and 2 could be done simultaneosly. An array of distinct values could then be constructed in place by shifting left for better performance on some inputs.*)\\n\\nNotice that after sorting, `A[i] <= A[j] <= A[k]`, which gives 4 possible cases when `A[i] + A[j] + A[k] == target`:\\n*(Note: We don\\'t need to compare A[i] and A[k] explicitly because of transitivity after sorting.)*\\n* `A[i] == A[j],  A[j] == A[k]`\\n* `A[i] == A[j], A[j] != A[k]`\\n* `A[i] != A[j], A[j] == A[k]`\\n* `A[i] != A[j], A[j] != A[k]`\\nFor each of these 4 situations, I\\'ve derived formulas (see comments in code). \\nThree of these are O(1) and one is O(# of A[i]). They use the memoized counts to compute solutions directly.\\n\\nFor our final loop (#4), we\\'ll prove bounds by considering the two extreme inputs, as any other cases hit our O(1) time formulas:\\n1. All numbers are the same and they sum to a solution - **O(log A[x])**\\nSounds the most difficult, but turns out to be the easiest in practice. Since we only consider distinct combinations, there is only 1 case and it can be solved directly.\\nThe bounds come from standard multiplication / division algorithms.\\nExample:\\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]\\ntarget: 0\\n\\n2. All numbers are unique and the maximum number of possible solutions exist as subsets - **O(n^2)**.\\n*(A mixture of cases 1 and 2 produces some O(1) situations and some O(n) solutions, so is also O(n)).*\\nThe maximum number of unique subsets sum to the target.\\nExample:\\n[0, 1, 74, 2, 3, 70, 4, 5, 66, 6, 7, 62, 8, 9, 58, 10, 11, 54, 12, 13, 50, 14, 15, 46, 16, 17, 42, 18, 19, 38, 20, 21, 34, 22, 23, 30, 24, 25, 26]\\ntarget: 75\\n\\nThis handmade problem instance has 94 unique solutions for only 39 unique numbers.\\nIn this case, memoization doesn\\'t help us, since there are no duplicates. \\nHowever, sorting does help, since we can use binary search to maintain our worst case O(n^2) bounds.\\nOverall, this algorithm does really well on the average. The number of iterations is usually much less than the size of our input.\\n\\n```\\nclass Solution {\\n    fun threeSumMulti(A: IntArray, target: Int): Int {\\n        A.sort()\\n        val memo = mutableMapOf<Int, Int>().apply { A.forEach { put(it, getOrDefault(it, 0) + 1) } }\\n\\n        // count the total number of solutions for the provided values of A[i], A[j], A[k]\\n        fun count(xi: Int, xj: Int, xk: Int): Long {\\n            val count_xi = memo[xi]!!\\n            var count = 0L\\n\\n            if (xi == xj && xj == xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 1, 1, 1\\n                // i  j  5\\n                //       j 4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //    i  j  4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //       i  j 3\\n                //             j  2\\n                //                j  1\\n                count += ((count_xi - 2L) * (count_xi - 1L) * count_xi) / 6L\\n            } else if (xi == xj && xj != xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 2, 2, 2\\n                // i  j        3\\n                //       j     3\\n                //          j  3\\n                //    i  j     3\\n                //          j  3\\n                //       i  j  3\\n                val count_xk = memo[xk]!!\\n                val sum = ((count_xi - 1L) * count_xi) / 2L\\n                count += sum * count_xk\\n            } else if (xi != xj && xj == xk) {\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 2\\n                // i        j  3\\n                //             j  2\\n                //                j  1\\n                //    i     j  3\\n                //             j  2\\n                //                j  1\\n                //       i  j  3\\n                //             j  2\\n                //                j  1\\n                val count_xj = memo[xj]!!\\n                val sum = ((count_xj - 1L) * count_xj) / 2L\\n                count += count_xi * sum\\n            } else { //if (xi != xj && xj != xk)\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 3, 3, 3, 3\\n                // i        j        4\\n                //             j     4\\n                //                j  4\\n                //    i     j        4\\n                //             j     4\\n                //                j  4\\n                //       i  j        4\\n                //             j     4\\n                //                j  4\\n                val count_xj = memo[xj]!!\\n                val count_xk = memo[xk]!!\\n                count += count_xi * count_xj * count_xk\\n            }\\n            \\n            return count\\n        }\\n        \\n        // find the next unique position in A from i\\n        fun nextIndex(i: Int): Int {\\n            val x = A[i]\\n            var ret = i + 1\\n            while (ret < A.size && A[ret] == A[i]) ++ret\\n            return ret\\n        }\\n        // binary search for missing value\\n        fun nextIndex(target: Int, from: Int): Int {\\n            val ret = A.binarySearch(target, from)\\n            return if (ret < 0 || A[ret] != target) A.size else ret\\n        }\\n        \\n        var total = 0L\\n        var i = 0\\n        var j = 1\\n        var k = 2\\n        while (i < A.size-2 && j < A.size-1 && k < A.size) {\\n            // add new solutions to total\\n            val xi = A[i]\\n            val xj = A[j]\\n            val xk = A[k]\\n            if (xi+xj+xk == target) {\\n                total += count(xi, xj, xk)\\n                j = nextIndex(j)\\n                k = j + 1\\n                if (j >= A.size || k >= A.size) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            } else {\\n                k = nextIndex(target - (xi+xj), k+1)\\n                if (k >= A.size) {\\n                    j = nextIndex(j)\\n                    k = j + 1\\n                }\\n                if (j >= A.size-1) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            }\\n        }\\n\\n        return (total % 1_000_000_007L).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Math",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun threeSumMulti(A: IntArray, target: Int): Int {\\n        A.sort()\\n        val memo = mutableMapOf<Int, Int>().apply { A.forEach { put(it, getOrDefault(it, 0) + 1) } }\\n\\n        // count the total number of solutions for the provided values of A[i], A[j], A[k]\\n        fun count(xi: Int, xj: Int, xk: Int): Long {\\n            val count_xi = memo[xi]!!\\n            var count = 0L\\n\\n            if (xi == xj && xj == xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 1, 1, 1\\n                // i  j  5\\n                //       j 4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //    i  j  4\\n                //          j 3\\n                //             j  2\\n                //                j  1\\n                //       i  j 3\\n                //             j  2\\n                //                j  1\\n                count += ((count_xi - 2L) * (count_xi - 1L) * count_xi) / 6L\\n            } else if (xi == xj && xj != xk) {\\n                // target: 3\\n                // 1, 1, 1, 1, 2, 2, 2\\n                // i  j        3\\n                //       j     3\\n                //          j  3\\n                //    i  j     3\\n                //          j  3\\n                //       i  j  3\\n                val count_xk = memo[xk]!!\\n                val sum = ((count_xi - 1L) * count_xi) / 2L\\n                count += sum * count_xk\\n            } else if (xi != xj && xj == xk) {\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 2\\n                // i        j  3\\n                //             j  2\\n                //                j  1\\n                //    i     j  3\\n                //             j  2\\n                //                j  1\\n                //       i  j  3\\n                //             j  2\\n                //                j  1\\n                val count_xj = memo[xj]!!\\n                val sum = ((count_xj - 1L) * count_xj) / 2L\\n                count += count_xi * sum\\n            } else { //if (xi != xj && xj != xk)\\n                // target: 5\\n                // 1, 1, 1, 2, 2, 2, 3, 3, 3, 3\\n                // i        j        4\\n                //             j     4\\n                //                j  4\\n                //    i     j        4\\n                //             j     4\\n                //                j  4\\n                //       i  j        4\\n                //             j     4\\n                //                j  4\\n                val count_xj = memo[xj]!!\\n                val count_xk = memo[xk]!!\\n                count += count_xi * count_xj * count_xk\\n            }\\n            \\n            return count\\n        }\\n        \\n        // find the next unique position in A from i\\n        fun nextIndex(i: Int): Int {\\n            val x = A[i]\\n            var ret = i + 1\\n            while (ret < A.size && A[ret] == A[i]) ++ret\\n            return ret\\n        }\\n        // binary search for missing value\\n        fun nextIndex(target: Int, from: Int): Int {\\n            val ret = A.binarySearch(target, from)\\n            return if (ret < 0 || A[ret] != target) A.size else ret\\n        }\\n        \\n        var total = 0L\\n        var i = 0\\n        var j = 1\\n        var k = 2\\n        while (i < A.size-2 && j < A.size-1 && k < A.size) {\\n            // add new solutions to total\\n            val xi = A[i]\\n            val xj = A[j]\\n            val xk = A[k]\\n            if (xi+xj+xk == target) {\\n                total += count(xi, xj, xk)\\n                j = nextIndex(j)\\n                k = j + 1\\n                if (j >= A.size || k >= A.size) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            } else {\\n                k = nextIndex(target - (xi+xj), k+1)\\n                if (k >= A.size) {\\n                    j = nextIndex(j)\\n                    k = j + 1\\n                }\\n                if (j >= A.size-1) {\\n                    i = nextIndex(i)\\n                    j = i + 1\\n                    k = j + 1\\n                }\\n            }\\n        }\\n\\n        return (total % 1_000_000_007L).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218864,
                "title": "need-help-combination-of-regular-3sums-and-combinatorics-fails-all-zeros-case",
                "content": "just added some codes to count the repetitve ones, fails all 1s and 0s cases. Shouldn\\'t we just need C(3000, 3) to get the answer? Thanks!\\n```\\nimport math\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        maps = {}\\n        for a in A:\\n            if a not in maps:\\n                maps[a] = 1\\n            else:\\n                maps[a] += 1\\n        print(maps)\\n        A.sort()\\n        result = []\\n        count = 0\\n        for i in range(len(A)-2):\\n            if i > 0 and A[i] == A[i-1]:continue\\n            l = i+1\\n            r = len(A) - 1\\n            if [A[i], A[l], A[r]] not in result:\\n                while l < r:\\n                    sum_value = A[i] + A[l] + A[r]\\n                    if sum_value == target:\\n                        result.append([A[i], A[l], A[r]])\\n                        print(count)\\n                        if A[l] == A[r] == A[i]:\\n                            count += math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 3)*6)\\n                        elif A[i] == A[l]:\\n                            count += maps[A[r]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[i]== A[r]:\\n                            count += maps[A[l]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[l] == A[r]:\\n                            count += maps[A[i]] * math.factorial(maps[A[l]])/(math.factorial(maps[A[l]] - 2)*2)\\n                        else:\\n                            count += maps[A[i]] * maps[A[l]] * maps[A[r]]\\n                        while l < r and A[l] == A[l+1]:\\n                            l += 1\\n                        while l < r and A[r] == A[r-1]:\\n                            r -= 1\\n                        l += 1\\n                        r -= 1\\n                    elif sum_value < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n                    \\n        return int(count)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def threeSumMulti(self, A, target):\\n        \"\"\"\\n        :type A: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        maps = {}\\n        for a in A:\\n            if a not in maps:\\n                maps[a] = 1\\n            else:\\n                maps[a] += 1\\n        print(maps)\\n        A.sort()\\n        result = []\\n        count = 0\\n        for i in range(len(A)-2):\\n            if i > 0 and A[i] == A[i-1]:continue\\n            l = i+1\\n            r = len(A) - 1\\n            if [A[i], A[l], A[r]] not in result:\\n                while l < r:\\n                    sum_value = A[i] + A[l] + A[r]\\n                    if sum_value == target:\\n                        result.append([A[i], A[l], A[r]])\\n                        print(count)\\n                        if A[l] == A[r] == A[i]:\\n                            count += math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 3)*6)\\n                        elif A[i] == A[l]:\\n                            count += maps[A[r]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[i]== A[r]:\\n                            count += maps[A[l]] * math.factorial(maps[A[i]])/(math.factorial(maps[A[i]] - 2)*2)\\n                        elif A[l] == A[r]:\\n                            count += maps[A[i]] * math.factorial(maps[A[l]])/(math.factorial(maps[A[l]] - 2)*2)\\n                        else:\\n                            count += maps[A[i]] * maps[A[l]] * maps[A[r]]\\n                        while l < r and A[l] == A[l+1]:\\n                            l += 1\\n                        while l < r and A[r] == A[r-1]:\\n                            r -= 1\\n                        l += 1\\n                        r -= 1\\n                    elif sum_value < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n                    \\n        return int(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519593,
                "title": "solution",
                "content": "```C++ []\\nstatic const int M = 1e9 + 7, N = 101;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& a, int target) {\\n        long ans = 0, cnt[N]{};\\n        for (int &x : a) ++cnt[x];\\n        for (int i = 0; i < N; ++i)\\n            for (int j = i + 1; j < N; ++j) {\\n                int k = target - i - j;\\n                if (j < k && k < N)\\n                    (ans += cnt[i] * cnt[j] * cnt[k]) %= M;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            int k = target - 2 * i;\\n            if (i < k && k < N) (ans += cnt[i] * (cnt[i] - 1) / 2 * cnt[k]) %= M;\\n        }\\n        for (int i = 0; i < N; ++i)\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j < N) (ans += cnt[i] * cnt[j] * (cnt[j] - 1) / 2) %= M;\\n            }\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i < N) (ans += (cnt[i] * (cnt[i] - 1) % M) * (cnt[i] - 2) / 6) %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        counts = Counter(arr)\\n        sorted_arr = sorted(set(arr))\\n        res = 0\\n        \\n        for i, num1 in enumerate(sorted_arr):\\n            k, j = i + 1, len(sorted_arr) - 1\\n            \\n            if counts[num1] > 1 and target - num1 * 2 in counts:\\n                if num1 * 3 == target:\\n                    res += math.comb(counts[num1], 3)\\n                else:\\n                    res += ((counts[num1] * (counts[num1] - 1)) // 2) * counts[target - num1 * 2]\\n                \\n            while k < j:\\n                num2, num3 = sorted_arr[k], sorted_arr[j]\\n                total = num1 + num2 + num3\\n                \\n                if total == target:\\n                    res += (counts[num1] * counts[num2] * counts[num3])\\n                    k += 1\\n                    j -= 1\\n                elif total < target:\\n                    k += 1\\n                else:\\n                    j -= 1\\n                    \\n        return res % (10**9 + 7)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic const int M = 1e9 + 7, N = 101;\\n\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& a, int target) {\\n        long ans = 0, cnt[N]{};\\n        for (int &x : a) ++cnt[x];\\n        for (int i = 0; i < N; ++i)\\n            for (int j = i + 1; j < N; ++j) {\\n                int k = target - i - j;\\n                if (j < k && k < N)\\n                    (ans += cnt[i] * cnt[j] * cnt[k]) %= M;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            int k = target - 2 * i;\\n            if (i < k && k < N) (ans += cnt[i] * (cnt[i] - 1) / 2 * cnt[k]) %= M;\\n        }\\n        for (int i = 0; i < N; ++i)\\n            if (target % 2 == i % 2) {\\n                int j = (target - i) / 2;\\n                if (i < j && j < N) (ans += cnt[i] * cnt[j] * (cnt[j] - 1) / 2) %= M;\\n            }\\n        if (target % 3 == 0) {\\n            int i = target / 3;\\n            if (0 <= i && i < N) (ans += (cnt[i] * (cnt[i] - 1) % M) * (cnt[i] - 2) / 6) %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        counts = Counter(arr)\\n        sorted_arr = sorted(set(arr))\\n        res = 0\\n        \\n        for i, num1 in enumerate(sorted_arr):\\n            k, j = i + 1, len(sorted_arr) - 1\\n            \\n            if counts[num1] > 1 and target - num1 * 2 in counts:\\n                if num1 * 3 == target:\\n                    res += math.comb(counts[num1], 3)\\n                else:\\n                    res += ((counts[num1] * (counts[num1] - 1)) // 2) * counts[target - num1 * 2]\\n                \\n            while k < j:\\n                num2, num3 = sorted_arr[k], sorted_arr[j]\\n                total = num1 + num2 + num3\\n                \\n                if total == target:\\n                    res += (counts[num1] * counts[num2] * counts[num3])\\n                    k += 1\\n                    j -= 1\\n                elif total < target:\\n                    k += 1\\n                else:\\n                    j -= 1\\n                    \\n        return res % (10**9 + 7)\\n```\n```Java []\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438894,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X)\\n     {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++) \\n        {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int X)\\n     {\\n        int n = arr.size(), mod = 1e9+7, ans = 0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++) \\n        {\\n            ans = (ans + m[X - arr[i]]) % mod;\\n            for(int j=0; j<i; j++) m[arr[i] + arr[j]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306878,
                "title": "javascript-923-3sum-with-multiplicity",
                "content": "====\\n\\n1. Two Sum\\nhttps://leetcode.com/problems/two-sum/solutions/3303105/javascript-1-two-sum/\\n167. Two Sum II - Input Array Is Sorted\\nhttps://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solutions/3303938/javascript-167-two-sum-ii-input-array-is-sorted/\\n15. 3Sum\\nhttps://leetcode.com/problems/3sum/solutions/3304382/javascript-15-3sum/\\n923. 3Sum With Multiplicity\\n(( See below ))\\n18. 4Sum\\nhttps://leetcode.com/problems/4sum/solutions/3305939/javascript-18-4sum/\\n\\n====\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nMultiplicity == With duplicates\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nlet MOD = 10 ** 9 + 7;\\nfunction lower_bound_eg(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction upper_bound_g(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] <= target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction equal_range_eg_g(arr, target, L = 0, R = arr.length) {\\n    const LB = lower_bound_eg(arr, target, L, R);\\n    const UB = upper_bound_g(arr, target, L, R);\\n    return [LB, UB];\\n}\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let L = i + 1; L < n; L++) {\\n            let search = t - (a[i] + a[L]);\\n\\n            let [R, R2] = equal_range_eg_g(a, search, L + 1, n);\\n            if (R !== -Infinity) {\\n                cc += R2 - R;\\n                cc = cc % MOD;\\n            }\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n2\\n```\\nlet MOD = 10 ** 9 + 7;\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        let search = t - a[i]; //  L + R = t -i\\n\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let search2 = a[L] + a[R]; // target;\\n\\n            if (search2 === search) {\\n                if (a[L] !== a[R]) {\\n                    let ccleft = 1, // count of equal on left\\n                        ccright = 1; // count of equal on right\\n                    while (L + 1 < R && a[L] == a[L + 1]) ccleft++, L++;\\n                    while (R - 1 > L && a[R] == a[R - 1]) ccright++, R--;\\n                    cc = cc + ccleft * ccright;\\n                    cc = cc % MOD;\\n                    L++;\\n                    R--;\\n                } else {\\n                    let count = R - L;\\n                    cc = cc + (count * (count + 1)) / 2; // pairs\\n                    cc = cc % MOD;\\n                    break;\\n                }\\n            } else if (search2 < search) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n\\n    return cc;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet MOD = 10 ** 9 + 7;\\nfunction lower_bound_eg(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction upper_bound_g(arr, target, L = 0, R = arr.length) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] <= target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n}\\nfunction equal_range_eg_g(arr, target, L = 0, R = arr.length) {\\n    const LB = lower_bound_eg(arr, target, L, R);\\n    const UB = upper_bound_g(arr, target, L, R);\\n    return [LB, UB];\\n}\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let L = i + 1; L < n; L++) {\\n            let search = t - (a[i] + a[L]);\\n\\n            let [R, R2] = equal_range_eg_g(a, search, L + 1, n);\\n            if (R !== -Infinity) {\\n                cc += R2 - R;\\n                cc = cc % MOD;\\n            }\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nlet MOD = 10 ** 9 + 7;\\nvar threeSumMulti = function (a, t) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    // i + L + R = t\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        let search = t - a[i]; //  L + R = t -i\\n\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let search2 = a[L] + a[R]; // target;\\n\\n            if (search2 === search) {\\n                if (a[L] !== a[R]) {\\n                    let ccleft = 1, // count of equal on left\\n                        ccright = 1; // count of equal on right\\n                    while (L + 1 < R && a[L] == a[L + 1]) ccleft++, L++;\\n                    while (R - 1 > L && a[R] == a[R - 1]) ccright++, R--;\\n                    cc = cc + ccleft * ccright;\\n                    cc = cc % MOD;\\n                    L++;\\n                    R--;\\n                } else {\\n                    let count = R - L;\\n                    cc = cc + (count * (count + 1)) / 2; // pairs\\n                    cc = cc % MOD;\\n                    break;\\n                }\\n            } else if (search2 < search) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n\\n    return cc;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2759830,
                "title": "c-fast-solution-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        int x,y,z;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            x=arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                y=arr[j];\\n                z=target-(x+y);\\n                ans=(ans+mp[z])%mod; \\n            }\\n            mp[x]++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int ans=0;\\n        unordered_map<int,int>mp;\\n        int x,y,z;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            x=arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                y=arr[j];\\n                z=target-(x+y);\\n                ans=(ans+mp[z])%mod; \\n            }\\n            mp[x]++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440714,
                "title": "java-o-n-2-with-hashmap-clean-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int n = arr.length;\\n        int res = 0;\\n        int MOD = 1000000007;\\n        for(int i = 0; i < n; i++){\\n            int goal = target - arr[i];\\n            int c = count.getOrDefault(goal, 0);\\n            res = (res % MOD + c % MOD) % MOD;\\n            for(int j = 0; j < i; j++){\\n                int s = arr[i] + arr[j];\\n                count.put(s, count.getOrDefault(s, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int n = arr.length;\\n        int res = 0;\\n        int MOD = 1000000007;\\n        for(int i = 0; i < n; i++){\\n            int goal = target - arr[i];\\n            int c = count.getOrDefault(goal, 0);\\n            res = (res % MOD + c % MOD) % MOD;\\n            for(int j = 0; j < i; j++){\\n                int s = arr[i] + arr[j];\\n                count.put(s, count.getOrDefault(s, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178528,
                "title": "simple-intuition-permutation-combination-c",
                "content": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        \\n        map<int,long long> m;\\n        long long ans=0;\\n        \\n        for(auto i:m)\\n            m[i]++;\\n                \\n        for(auto it1:m)\\n        {\\n            for(auto it2:m)\\n            {\\n                int i=it1.first,j=it2.first,k=target-i-j;\\n                \\n    //Case 1  all the three are equal--> (n*n-1*n-2)/3! as all the three are same\\n                if(i==j and j==k) \\n                    ans+= (m[i]*(m[i]-1)*(m[i]-2))/6;\\n                \\n     //Case 2  all the three are equal--> (n*n-1)/2! as two of them are same       \\n                else if(i==j and j!=k)\\n                     ans+=(m[i]*(m[i]-1)*m[k])/2;\\n       \\n        //Case 3 all distinct\\n                else if(i<j and j<k)\\n                    ans+=m[i]*m[j]*m[k];\\n            }\\n        }\\n        \\n        return ans%1000000007;\\n    }",
                "solutionTags": [],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        \\n        map<int,long long> m;\\n        long long ans=0;\\n        \\n        for(auto i:m)\\n            m[i]++;\\n                \\n        for(auto it1:m)\\n        {\\n            for(auto it2:m)\\n            {\\n                int i=it1.first,j=it2.first,k=target-i-j;\\n                \\n    //Case 1  all the three are equal--> (n*n-1*n-2)/3! as all the three are same\\n                if(i==j and j==k) \\n                    ans+= (m[i]*(m[i]-1)*(m[i]-2))/6;\\n                \\n     //Case 2  all the three are equal--> (n*n-1)/2! as two of them are same       \\n                else if(i==j and j!=k)\\n                     ans+=(m[i]*(m[i]-1)*m[k])/2;\\n       \\n        //Case 3 all distinct\\n                else if(i<j and j<k)\\n                    ans+=m[i]*m[j]*m[k];\\n            }\\n        }\\n        \\n        return ans%1000000007;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2178258,
                "title": "java-3sum-template",
                "content": "```\\nclass Solution \\n{\\n    public int threeSumMulti(int[] arr, int target) \\n    {\\n        int mod = (int)1e9+7;\\n        int count = 0;\\n        Arrays.sort(arr);\\n        for(int k = arr.length-1;k>=0;k--)\\n        {\\n            int v1 = arr[k];\\n            int i = 0;\\n            int j = k-1;\\n            \\n            while(i < j)\\n            {\\n                int v2 = arr[i];\\n                int v3 = arr[j];\\n                \\n                if(v1+v2+v3 == target)\\n                {\\n                    if(v2 == v3)\\n                    {\\n                        while(j > i)\\n                        {\\n                            count = (count + (j-i)%mod)%mod;\\n                            j--;\\n                        }\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        int c1 = 1;\\n                        int c2 = 1;\\n                        while(arr[j-1] == arr[j])\\n                        {\\n                            j--;\\n                            c1++;\\n                        }\\n                        while(arr[i+1] == arr[i])\\n                        {\\n                            i++;\\n                            c2++;\\n                        }\\n                        \\n                        count = (count +  ((c1*c2))%mod)%mod;\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                else if(v1+v2+v3 > target)\\n                {\\n                    j--;\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return count%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int threeSumMulti(int[] arr, int target) \\n    {\\n        int mod = (int)1e9+7;\\n        int count = 0;\\n        Arrays.sort(arr);\\n        for(int k = arr.length-1;k>=0;k--)\\n        {\\n            int v1 = arr[k];\\n            int i = 0;\\n            int j = k-1;\\n            \\n            while(i < j)\\n            {\\n                int v2 = arr[i];\\n                int v3 = arr[j];\\n                \\n                if(v1+v2+v3 == target)\\n                {\\n                    if(v2 == v3)\\n                    {\\n                        while(j > i)\\n                        {\\n                            count = (count + (j-i)%mod)%mod;\\n                            j--;\\n                        }\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        int c1 = 1;\\n                        int c2 = 1;\\n                        while(arr[j-1] == arr[j])\\n                        {\\n                            j--;\\n                            c1++;\\n                        }\\n                        while(arr[i+1] == arr[i])\\n                        {\\n                            i++;\\n                            c2++;\\n                        }\\n                        \\n                        count = (count +  ((c1*c2))%mod)%mod;\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                else if(v1+v2+v3 > target)\\n                {\\n                    j--;\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return count%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145248,
                "title": "python-two-sum-clean-code",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        result = 0\\n        arr.sort()\\n        \\n        for index in range(len(arr)):\\n            targetDiff = target - arr[index]\\n            \\n            left = index + 1\\n            right = len(arr) - 1\\n            \\n            while left < right:\\n                complement = arr[left] + arr[right]\\n                \\n                if complement > targetDiff:\\n                    right -= 1\\n                elif complement < targetDiff:\\n                    left += 1\\n                elif arr[left] != arr[right]:\\n                    leftCounter = 1\\n                    rightCounter = 1\\n                    \\n                    while left < right and arr[left] == arr[left + 1]:\\n                        leftCounter += 1\\n                        left += 1\\n                    \\n                    while right > left and arr[right] == arr[right - 1]:\\n                        rightCounter += 1\\n                        right -= 1\\n                        \\n                    result += leftCounter * rightCounter\\n                    result %= 10**9 + 7\\n                    \\n                    left += 1\\n                    right -= 1\\n                else:\\n                    result += (right - left + 1) * (right - left) // 2\\n                    result %= 10**9 + 7\\n                    break\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        result = 0\\n        arr.sort()\\n        \\n        for index in range(len(arr)):\\n            targetDiff = target - arr[index]\\n            \\n            left = index + 1\\n            right = len(arr) - 1\\n            \\n            while left < right:\\n                complement = arr[left] + arr[right]\\n                \\n                if complement > targetDiff:\\n                    right -= 1\\n                elif complement < targetDiff:\\n                    left += 1\\n                elif arr[left] != arr[right]:\\n                    leftCounter = 1\\n                    rightCounter = 1\\n                    \\n                    while left < right and arr[left] == arr[left + 1]:\\n                        leftCounter += 1\\n                        left += 1\\n                    \\n                    while right > left and arr[right] == arr[right - 1]:\\n                        rightCounter += 1\\n                        right -= 1\\n                        \\n                    result += leftCounter * rightCounter\\n                    result %= 10**9 + 7\\n                    \\n                    left += 1\\n                    right -= 1\\n                else:\\n                    result += (right - left + 1) * (right - left) // 2\\n                    result %= 10**9 + 7\\n                    break\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131256,
                "title": "python-sorting-hashmap-two-sum-approach-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(0, len(arr)-2):\\n            rem_sum = target - arr[i]\\n            hash_map = {}\\n            for j in range(i+1, len(arr)):\\n                if arr[j] > rem_sum:\\n                    break\\n                if rem_sum - arr[j] in hash_map:\\n                    count = count + hash_map[rem_sum-arr[j]]\\n                # update the hash_map\\n                hash_map[arr[j]] = hash_map.get(arr[j], 0) + 1\\n        return count % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(0, len(arr)-2):\\n            rem_sum = target - arr[i]\\n            hash_map = {}\\n            for j in range(i+1, len(arr)):\\n                if arr[j] > rem_sum:\\n                    break\\n                if rem_sum - arr[j] in hash_map:\\n                    count = count + hash_map[rem_sum-arr[j]]\\n                # update the hash_map\\n                hash_map[arr[j]] = hash_map.get(arr[j], 0) + 1\\n        return count % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085110,
                "title": "c-o-n-2-modified-3sum-approach-beats-97-time-complexity",
                "content": "![image](https://assets.leetcode.com/users/images/e6aef1c6-096f-4eba-9818-47141003f500_1653773309.2855682.png)\\nHere\\'s my easy solution using a *modified 3-SUM approach*:\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long ret=0;\\n        sort(arr.begin(), arr.end());\\n        vector<int> reducedarr;\\n        unordered_map<int,long long int> count;\\n        for(int i=0; i<arr.size(); i++){\\n            if(count.find(arr[i])==count.end()){\\n                reducedarr.push_back(arr[i]);\\n                count[arr[i]] = 1;\\n            }\\n            else count[arr[i]]++;\\n        }\\n        int m=reducedarr.size();\\n        for(int i=0; i<m; i++){\\n            int j=i, k=m-1;\\n            while(j<=k){\\n                int sum=reducedarr[i]+reducedarr[j]+reducedarr[k];\\n                if(sum==target){\\n                    int x=reducedarr[i], y=reducedarr[j], z=reducedarr[k];\\n                    if(x!=y and y!=z)\\n                        ret = (ret + count[x]*count[y]*count[z])%mod;\\n                    else if(x==y and y!=z)\\n                        ret = (ret + count[x]*(count[x]-1)/2*count[z])%mod;\\n                    else if(x!=y and y==z)\\n                        ret = (ret + count[x]*count[y]*(count[y]-1)/2)%mod;\\n                    else\\n                        ret = (ret + count[x]*(count[x]-1)*(count[x]-2)/6)%mod;\\n                    j++; k--;\\n                }\\n                else if(sum>target) k--;\\n                else j++;\\n            }\\n        }\\n        return (int)ret;\\n    }\\n};\\n```\\n\\nThanks \\uD83D\\uDE01\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long ret=0;\\n        sort(arr.begin(), arr.end());\\n        vector<int> reducedarr;\\n        unordered_map<int,long long int> count;\\n        for(int i=0; i<arr.size(); i++){\\n            if(count.find(arr[i])==count.end()){\\n                reducedarr.push_back(arr[i]);\\n                count[arr[i]] = 1;\\n            }\\n            else count[arr[i]]++;\\n        }\\n        int m=reducedarr.size();\\n        for(int i=0; i<m; i++){\\n            int j=i, k=m-1;\\n            while(j<=k){\\n                int sum=reducedarr[i]+reducedarr[j]+reducedarr[k];\\n                if(sum==target){\\n                    int x=reducedarr[i], y=reducedarr[j], z=reducedarr[k];\\n                    if(x!=y and y!=z)\\n                        ret = (ret + count[x]*count[y]*count[z])%mod;\\n                    else if(x==y and y!=z)\\n                        ret = (ret + count[x]*(count[x]-1)/2*count[z])%mod;\\n                    else if(x!=y and y==z)\\n                        ret = (ret + count[x]*count[y]*(count[y]-1)/2)%mod;\\n                    else\\n                        ret = (ret + count[x]*(count[x]-1)*(count[x]-2)/6)%mod;\\n                    j++; k--;\\n                }\\n                else if(sum>target) k--;\\n                else j++;\\n            }\\n        }\\n        return (int)ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026211,
                "title": "c-easy-intuitive-code-two-pointers",
                "content": "**Please do upvote if you liked my code ;)**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        long ans=0;\\n        sort(arr.begin(), arr.end());\\n        map<int, long> m, hash;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            m[arr[i]] = i, ++hash[arr[i]];\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(i > 0 and arr[i] == arr[i-1]) continue;\\n            \\n            for(int j=i+1; j<arr.size(); j++)\\n            {\\n                if(j != i+1 and arr[j] == arr[j-1]) continue;\\n                int idx = target-arr[i]-arr[j];\\n                \\n                if(m[idx] > j) \\n                {\\n                    if(arr[i] == arr[j] and arr[j] == idx) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1) * (hash[arr[i]]-2) / 6;\\n                    else if(arr[i] == arr[j]) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1)/2 * hash[idx];\\n                    else if(arr[j] == idx) \\n                        ans += hash[idx] * (hash[idx]-1)/2 * hash[arr[i]];\\n                    else \\n                        ans += hash[arr[j]] * hash[idx] * hash[arr[i]];\\n                    \\n                    ans %= 1000000007; \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        long ans=0;\\n        sort(arr.begin(), arr.end());\\n        map<int, long> m, hash;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            m[arr[i]] = i, ++hash[arr[i]];\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(i > 0 and arr[i] == arr[i-1]) continue;\\n            \\n            for(int j=i+1; j<arr.size(); j++)\\n            {\\n                if(j != i+1 and arr[j] == arr[j-1]) continue;\\n                int idx = target-arr[i]-arr[j];\\n                \\n                if(m[idx] > j) \\n                {\\n                    if(arr[i] == arr[j] and arr[j] == idx) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1) * (hash[arr[i]]-2) / 6;\\n                    else if(arr[i] == arr[j]) \\n                        ans += hash[arr[i]] * (hash[arr[i]]-1)/2 * hash[idx];\\n                    else if(arr[j] == idx) \\n                        ans += hash[idx] * (hash[idx]-1)/2 * hash[arr[i]];\\n                    else \\n                        ans += hash[arr[j]] * hash[idx] * hash[arr[i]];\\n                    \\n                    ans %= 1000000007; \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941649,
                "title": "3-sum-extension",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    #define mod 1e9+7\\n    unordered_map<int,long>mp;//esko long lena bohot zaruri tha\\n    \\n    int tuplecnt(vector<vector<int>>res)\\n    {\\n        int n=res.size();\\n       long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n                if(res[i][j]!=res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]]);\\n                    // cout<<(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]])<<endl;\\n                    \\n                }\\n           else if(res[i][j]!=res[i][j+1] &&res[i][j+1]==res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*((mp[res[i][j+1]])*(mp[res[i][j+1]]-1)/2));\\n               // cout<<mp[res[i][j]]*mp[res[i][j+1]]<<endl;\\n                    \\n                }\\n            else if(res[i][j]==res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                   sum+=(mp[res[i][j+2]]*((mp[res[i][j]])*(mp[res[i][j]]-1)/2));\\n                // cout<<mp[res[i][j]]*mp[res[i][j+2]]<<endl;\\n                    \\n                }\\n            else\\n            {\\n                // nC3 select  any 3 from n hence n!/r!(n-r)!\\n                sum+=((mp[res[i][j]]) * (mp[res[i][j]]-1)* (mp[res[i][j]]- 2)/ 6)%int(1e9+7);\\n            }\\n           \\n        }\\n      return  sum % int(1e9 + 7);//int (1e9+7) likna zaruri tha bcz 1e9+7 is in form of double\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>>res;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n       \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && arr[i-1]==arr[i])\\n            {\\n                continue;\\n            }\\n            \\n            int s=i+1;\\n            int e=n-1;\\n            \\n            while(s<e)\\n            {\\n                int sum=arr[s]+arr[e]+arr[i];\\n                \\n                if(sum>target)\\n                {\\n                    e--;\\n                }\\n                else if(sum<target)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                     res.push_back(vector<int> {arr[i], arr[s],arr[e]});\\n                    \\n                    while(s<e &&arr[s]==arr[s+1])\\n                    {\\n                        s++;\\n                    }\\n                    \\n                     while(s<e &&arr[e]==arr[e-1])\\n                    {\\n                        e--;\\n                    }\\n                    s++;\\n                    e--;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n   \\n        }\\n        \\n        //get all combination of 3 to get sum target\\n         for(int i=0;i<res.size();i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                cout<<res[i][j];\\n            }\\n             cout<<endl;\\n        }\\n        \\n        //fnnn to calculate all possibilities of that number to get\\n        int ans=tuplecnt(res);\\n        return ans;\\n\\n    }\\n    \\n    \\n    \\n};```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define mod 1e9+7\\n    unordered_map<int,long>mp;//esko long lena bohot zaruri tha\\n    \\n    int tuplecnt(vector<vector<int>>res)\\n    {\\n        int n=res.size();\\n       long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n                if(res[i][j]!=res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]]);\\n                    // cout<<(mp[res[i][j]]*mp[res[i][j+1]]*mp[res[i][j+2]])<<endl;\\n                    \\n                }\\n           else if(res[i][j]!=res[i][j+1] &&res[i][j+1]==res[i][j+2] )\\n                {\\n                  sum+=(mp[res[i][j]]*((mp[res[i][j+1]])*(mp[res[i][j+1]]-1)/2));\\n               // cout<<mp[res[i][j]]*mp[res[i][j+1]]<<endl;\\n                    \\n                }\\n            else if(res[i][j]==res[i][j+1] &&res[i][j+1]!=res[i][j+2] )\\n                {\\n                   sum+=(mp[res[i][j+2]]*((mp[res[i][j]])*(mp[res[i][j]]-1)/2));\\n                // cout<<mp[res[i][j]]*mp[res[i][j+2]]<<endl;\\n                    \\n                }\\n            else\\n            {\\n                // nC3 select  any 3 from n hence n!/r!(n-r)!\\n                sum+=((mp[res[i][j]]) * (mp[res[i][j]]-1)* (mp[res[i][j]]- 2)/ 6)%int(1e9+7);\\n            }\\n           \\n        }\\n      return  sum % int(1e9 + 7);//int (1e9+7) likna zaruri tha bcz 1e9+7 is in form of double\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>>res;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n       \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && arr[i-1]==arr[i])\\n            {\\n                continue;\\n            }\\n            \\n            int s=i+1;\\n            int e=n-1;\\n            \\n            while(s<e)\\n            {\\n                int sum=arr[s]+arr[e]+arr[i];\\n                \\n                if(sum>target)\\n                {\\n                    e--;\\n                }\\n                else if(sum<target)\\n                {\\n                    s++;\\n                }\\n                else\\n                {\\n                     res.push_back(vector<int> {arr[i], arr[s],arr[e]});\\n                    \\n                    while(s<e &&arr[s]==arr[s+1])\\n                    {\\n                        s++;\\n                    }\\n                    \\n                     while(s<e &&arr[e]==arr[e-1])\\n                    {\\n                        e--;\\n                    }\\n                    s++;\\n                    e--;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n   \\n        }\\n        \\n        //get all combination of 3 to get sum target\\n         for(int i=0;i<res.size();i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                cout<<res[i][j];\\n            }\\n             cout<<endl;\\n        }\\n        \\n        //fnnn to calculate all possibilities of that number to get\\n        int ans=tuplecnt(res);\\n        return ans;\\n\\n    }\\n    \\n    \\n    \\n};```",
                "codeTag": "C++"
            },
            {
                "id": 1932156,
                "title": "3-sum-with-multiplicitty-29-ms-and-10-9mb-mathematical-approach",
                "content": "# 3 Sum with Multiplicity\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size(),j,k,temp;\\n        unordered_map<int,int> hash ;\\n         for(int i=0; i<n; i++)\\n             hash[arr[i]]++;\\n         long long ans = 0 ,mod = 1e9+7;\\n        \\n        for(int i=0; i<n-2 ;i++ )\\n        {\\n            while(i>0 and  i<n-2 and arr[i-1]==arr[i]) i++; // skipping\\n             j=i+1; k=n-1;\\n                  while(j<k)\\n            {\\n                temp = arr[i]+arr[j]+arr[k];\\n                if(temp==target)\\n                {\\n                    if(arr[i]==arr[j] && arr[j]==arr[k])\\n                    {\\n                        long val=hash[arr[i]];\\n                       long long re=((val*(val-1))*(val-2))/6;\\n                        ans+=re;\\n                    }\\n                    else if(arr[i]==arr[j])\\n                    {\\n                        long val=hash[arr[i]];\\n                       long long re=(val*(val-1))/2;\\n                        ans+=(re*hash[arr[k]]);\\n                    }\\n                    else if(arr[j]==arr[k])\\n                    {\\n                        long val=hash[arr[j]];\\n                       long long re=(val*(val-1))/2;\\n                        ans+=(re*hash[arr[i]]);\\n                    }\\n                    else if(arr[i]!=arr[j] && arr[i]!=arr[k] && arr[j]!=arr[k])\\n                    ans += hash[arr[i]]*hash[arr[j]]*hash[arr[k]];\\n                    ans %= mod;\\n                    \\n                    while(j<k and arr[j+1]==arr[j]) j++;\\n                    while(j<k and arr[k-1]==arr[k]) k--;\\n                      j++; k--;\\n                }\\n                else if(temp > target) k--;\\n                else j++;           \\n            }    \\n        }\\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) \\n    {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size(),j,k,temp;\\n        unordered_map<int,int> hash ;\\n         for(int i=0; i<n; i++)\\n             hash[arr[i]]++;\\n         long long ans = 0 ,mod = 1e9+7;\\n        \\n        for(int i=0; i<n-2 ;i++ )\\n        {\\n            while(i>0 and  i<n-2 and arr[i-1]==arr[i]) i++; // skipping\\n             j=i+1; k=n-1;\\n                  while(j<k)\\n            {\\n                temp = arr[i]+arr[j]+arr[k];\\n                if(temp==target)\\n                {\\n                    if(arr[i]==arr[j] && arr[j]==arr[k])\\n                    {\\n                        long val=hash[arr[i]];\\n                       long long re=((val*(val-1))*(val-2))/6;\\n                        ans+=re;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1927632,
                "title": "best-approach-5-line-code-hindi-video",
                "content": "I made a video to explain this approach but that is in hindi .\\nIts an awesome video, I guaranteed you, Please dont forget to upvote this. This easy solution explanation you will not find so please dont forget to upvote this.\\nRemove space between . and com and copy paste url.\\nyoutube. com/watch?v=tdZwvbTXIUU\\n\\n```\\nunordered_map<int,int> mp;\\n        int ans=0;\\n        int mod=pow(10,9)+7;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            ans=(ans+mp[t-arr[i]])%mod;\\n            for(int j=0;j<i;j++){\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<int,int> mp;\\n        int ans=0;\\n        int mod=pow(10,9)+7;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            ans=(ans+mp[t-arr[i]])%mod;\\n            for(int j=0;j<i;j++){\\n                mp[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926743,
                "title": "c-two-pointer-approach",
                "content": "class Solution\\n{\\npublic:\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        long long mod = 1e9 + 7;\\n\\n        int count = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n\\n            int a = arr[i];\\n            int req = target - a;\\n\\n            while (l < r)\\n            {\\n\\n                int b = arr[l] + arr[r];\\n\\n                if (b < req)\\n                    l++;\\n                else if (b > req)\\n                    r--;\\n                else\\n                {\\n                    int leftcount = 1;\\n                    int rightcount = 1;\\n\\n                    while (l < r && arr[l] == arr[l + 1])\\n                    {\\n                        leftcount++;\\n                        l++;\\n                    }\\n\\n                    while (l < r && arr[r] == arr[r - 1])\\n                    {\\n                        rightcount++;\\n                        r--;\\n                    }\\n\\n                    if (l == r)\\n                    {\\n                        count = (count % mod + (leftcount % mod * (leftcount - 1) % mod) / 2) % mod; // number of ways of selecting 2 element from n elements\\n                    }\\n                    if (l != r)\\n                    {\\n                        count = (count % mod + (leftcount % mod * rightcount % mod) % mod) % mod;\\n                    }\\n\\n                    l++;\\n                    r--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        long long mod = 1e9 + 7;\\n\\n        int count = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n\\n            int a = arr[i];\\n            int req = target - a;\\n\\n            while (l < r)\\n            {\\n\\n                int b = arr[l] + arr[r];\\n\\n                if (b < req)\\n                    l++;\\n                else if (b > req)\\n                    r--;\\n                else\\n                {\\n                    int leftcount = 1;\\n                    int rightcount = 1;\\n\\n                    while (l < r && arr[l] == arr[l + 1])\\n                    {\\n                        leftcount++;\\n                        l++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1921542,
                "title": "simple-python-o-n2-approach",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        d=Counter(arr)\\n        dk=d.keys()\\n        ans=0\\n        for i in dk:\\n            for j in dk:\\n                el3=target-i-j\\n                if el3 in dk:\\n                    f1=d[i]\\n                    f2=d[j]\\n                    f3=d[el3]\\n                    if i==j==el3:\\n                        ans+=f1*(f1-1)*(f1-2)/6\\n                    elif i==j and i<el3:\\n                        ans+=f1*(f1-1)/2*f3\\n                    elif i<j and j==el3:\\n                        ans+=f1*f2*(f2-1)/2\\n                    elif i<j<el3:\\n                        ans+=f1*f2*f3\\n        return int(ans)%(10**9+7)\\n                        \\n                        \\n                        \\n        ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        d=Counter(arr)\\n        dk=d.keys()\\n        ans=0\\n        for i in dk:\\n            for j in dk:\\n                el3=target-i-j\\n                if el3 in dk:\\n                    f1=d[i]\\n                    f2=d[j]\\n                    f3=d[el3]\\n                    if i==j==el3:\\n                        ans+=f1*(f1-1)*(f1-2)/6\\n                    elif i==j and i<el3:\\n                        ans+=f1*(f1-1)/2*f3\\n                    elif i<j and j==el3:\\n                        ans+=f1*f2*(f2-1)/2\\n                    elif i<j<el3:\\n                        ans+=f1*f2*f3\\n        return int(ans)%(10**9+7)\\n                        \\n                        \\n                        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1920912,
                "title": "golang-o-n-2-time-o-n-space",
                "content": "```go\\nfunc threeSumMulti(arr []int, target int) (res int) {\\n    const mod = 1e9 + 7\\n    \\n    c := make(map[int]int)\\n    for _, num := range arr { c[num]++ }\\n    \\n    arr = arr[:0]\\n    for num := range c { arr = append(arr, num) }\\n    \\n    sort.Ints(arr)\\n    \\n    // search for arr[i] * 3 == target\\n    for _, num := range arr {\\n        if num*3 == target && c[num] >= 2 {\\n            res = (res + c[num] * (c[num]-1) * (c[num]-2) / 6) % mod\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[i]+arr[j] == target\\n    for i := 0; i < len(arr); i++ {\\n        if c[arr[i]] >= 2 {            \\n            for j := 0; j < len(arr); j++ {\\n                if j == i { continue }\\n                \\n                if arr[j] + arr[i]*2 == target {\\n                    res = (res + (c[arr[i]] * (c[arr[i]]-1) / 2) * c[arr[j]]) % mod\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[j]+arr[k] == target\\n    for i := 0; i < len(arr); i++ {\\n        target2 := target - arr[i]\\n        \\n        j, k := i+1, len(arr)-1\\n        for j < k {\\n            if arr[j] + arr[k] == target2 {\\n                res = (res + (c[arr[i]] * c[arr[j]] * c[arr[k]])) % mod\\n                j++; k--\\n            } else if arr[j] + arr[k] < target2 {\\n                j++\\n            } else {\\n                k--\\n            }\\n        }\\n    }\\n    \\n    return\\n}\\n\\n// C(n, 2) = n! / (2! * (n-2)!) = (n * (n-1)) / 2\\n// C(n, 3) = n! / (3! * (n-3)!) = (n * (n-1) * (n-2)) / 6\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc threeSumMulti(arr []int, target int) (res int) {\\n    const mod = 1e9 + 7\\n    \\n    c := make(map[int]int)\\n    for _, num := range arr { c[num]++ }\\n    \\n    arr = arr[:0]\\n    for num := range c { arr = append(arr, num) }\\n    \\n    sort.Ints(arr)\\n    \\n    // search for arr[i] * 3 == target\\n    for _, num := range arr {\\n        if num*3 == target && c[num] >= 2 {\\n            res = (res + c[num] * (c[num]-1) * (c[num]-2) / 6) % mod\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[i]+arr[j] == target\\n    for i := 0; i < len(arr); i++ {\\n        if c[arr[i]] >= 2 {            \\n            for j := 0; j < len(arr); j++ {\\n                if j == i { continue }\\n                \\n                if arr[j] + arr[i]*2 == target {\\n                    res = (res + (c[arr[i]] * (c[arr[i]]-1) / 2) * c[arr[j]]) % mod\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    // search for arr[i]+arr[j]+arr[k] == target\\n    for i := 0; i < len(arr); i++ {\\n        target2 := target - arr[i]\\n        \\n        j, k := i+1, len(arr)-1\\n        for j < k {\\n            if arr[j] + arr[k] == target2 {\\n                res = (res + (c[arr[i]] * c[arr[j]] * c[arr[k]])) % mod\\n                j++; k--\\n            } else if arr[j] + arr[k] < target2 {\\n                j++\\n            } else {\\n                k--\\n            }\\n        }\\n    }\\n    \\n    return\\n}\\n\\n// C(n, 2) = n! / (2! * (n-2)!) = (n * (n-1)) / 2\\n// C(n, 3) = n! / (3! * (n-3)!) = (n * (n-1) * (n-2)) / 6\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1920902,
                "title": "swift-all-combinations-o-n-101",
                "content": "- Maintain `counter` in which `counter[num][i]` represents the occurrences of `num` from index `0 --> i`.\\n- Let\\'s consider each number `b = arr[i]` from index `1 --> arr.count - 2` as the middle number corresponding to index `j`. \\n\\t- For every number `a` from `0-->100` corresponding to index `i`, we can get the occurences of `a` on the left side of `b` in constant time --> `left = counter[a][i - 1]`\\n\\t- Since we already know `a & b`, it\\'s simple to know `c = target - a - b`  coressponding to index `k` and also we\\'re able to get the occurences of `c` on the right side of `b` in constant time --> `right = counter[c][n - 1] - counter[c][i]` \\n\\t- Then increase the result accordingly `res += left * right`\\n\\n```swift\\nclass Solution {\\n  func threeSumMulti(_ arr: [Int], _ target: Int) -> Int {\\n    let n = arr.count\\n    var counter = Array(repeating: Array(repeating: 0, count: n), count: 101)\\n    for i in 0..<n {\\n      for num in 0...100 {\\n        let prev = i == 0 ? 0: counter[num][i - 1]\\n        counter[num][i] = prev\\n      }\\n      \\n      let num = arr[i]\\n      let prev = i == 0 ? 0 : counter[num][i - 1] \\n      counter[num][i] = prev + 1\\n    }\\n    \\n    let mod = 1_000_000_007\\n    var res = 0 \\n    for i in stride(from: 1, to: n - 1, by: 1) {\\n      let b = arr[i]\\n      for a in 0...100 {\\n        let c = target - a - b\\n        if c < 0 || c > 100 { \\n          continue\\n        }\\n        \\n        let left = counter[a][i - 1]\\n        let right = max(0, counter[c][n - 1] - counter[c][i])\\n        res += left * right\\n      }\\n    }\\n    \\n    return res % mod\\n  }\\n}\\n// Time complexity: O(n * 101) \\n// Space complexity: O(n * 101) to store counter\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```swift\\nclass Solution {\\n  func threeSumMulti(_ arr: [Int], _ target: Int) -> Int {\\n    let n = arr.count\\n    var counter = Array(repeating: Array(repeating: 0, count: n), count: 101)\\n    for i in 0..<n {\\n      for num in 0...100 {\\n        let prev = i == 0 ? 0: counter[num][i - 1]\\n        counter[num][i] = prev\\n      }\\n      \\n      let num = arr[i]\\n      let prev = i == 0 ? 0 : counter[num][i - 1] \\n      counter[num][i] = prev + 1\\n    }\\n    \\n    let mod = 1_000_000_007\\n    var res = 0 \\n    for i in stride(from: 1, to: n - 1, by: 1) {\\n      let b = arr[i]\\n      for a in 0...100 {\\n        let c = target - a - b\\n        if c < 0 || c > 100 { \\n          continue\\n        }\\n        \\n        let left = counter[a][i - 1]\\n        let right = max(0, counter[c][n - 1] - counter[c][i])\\n        res += left * right\\n      }\\n    }\\n    \\n    return res % mod\\n  }\\n}\\n// Time complexity: O(n * 101) \\n// Space complexity: O(n * 101) to store counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920759,
                "title": "python-time-o-n-2-with-counter-where-n-of-distinct-elements",
                "content": "# Idea\\nRecap high school math: total ways to choose 3 balls from total n balls is `n!/(3!(n-3)!)`, where `n!` is factorial of `n`.\\n\\nif we have a list of `11` elements with value `2`: [2,2,2, ..., 2], and target value is `6`, what is the 3Sum answer?\\nans = `11!/(3!(11-3)!)` = 165\\n\\nhow about array of [2, 2, 2, ..., 3, 3, 3, ...], target = 7, where there is total m of `2`, and n of `3`?\\nthe only possible 3sum pattern is `2 2 3`,\\nso the ans = `total ways to choose 2 elements from m elements` * `n` = `m!(2!(m-2)!)` *`n`\\nif the target is 8 instead, it is similar: ans = m * `total ways to choose 2 elements from n elements` = `m` * `n!(2!(n-2)!)`\\n\\nTime complixity: O(N^2) where N is the number of distinct numbers\\n\\n# Code\\n```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        # for calculating factorial\\n        factMem = dict()\\n        def fact(n):\\n            if n in factMem:\\n                return factMem[n]\\n            if n <= 1:\\n                factMem[n] = 1\\n                return 1\\n            ans = n * fact(n-1)\\n            factMem[n] = ans\\n            return ans\\n        fact3 = fact(3)\\n        fact2 = fact(2)\\n        \\n        # count the frequency of each element\\n        multiplicity = Counter(arr)\\n        \\n        # create list only contains distinct numbers\\n        nums = []\\n        visited = set()\\n        for n in arr:\\n            if n in visited:\\n                continue\\n            nums.append(n)\\n            visited.add(n)\\n        \\n        # create a postfix set to quickly lookup if a number appears in nums[i:]\\n        postfixNumsSet = []\\n        numsSet = set()\\n        for i in range(len(nums)-1, -1, -1):\\n            numsSet.add(nums[i])\\n            postfixNumsSet.append(numsSet.copy())\\n        postfixNumsSet.reverse()\\n        \\n        bound = 1e9 + 7\\n        ans = 0\\n        for i in range(len(nums)):\\n            freqI = multiplicity[nums[i]]\\n            \\n            # i i i\\n            if multiplicity[nums[i]] >= 3 and nums[i]*3 == target:\\n                count = fact(freqI) // (fact3 * fact(freqI - 3))\\n                ans = (ans + count%bound) % bound\\n            \\n            for j in range(i+1, len(nums)):\\n                freqJ = multiplicity[nums[j]]\\n                \\n                # i i j\\n                if freqI >= 2 and nums[i]*2 + nums[j] == target:\\n                    count = (fact(freqI) // (fact2 * fact(freqI - 2)) ) * freqJ\\n                    ans = (ans + count%bound) % bound\\n                \\n                # j j i\\n                if freqJ >= 2 and nums[i] + nums[j]*2 == target:\\n                    count = (fact(freqJ) // (fact2 * fact(freqJ - 2)) ) * freqI\\n                    ans = (ans + count%bound) % bound\\n                \\n                # i j k\\n                wantedK = target - nums[i] - nums[j]\\n                if j >= len(nums) - 1 or wantedK not in postfixNumsSet[j+1]:\\n                    continue\\n                count = multiplicity[wantedK] * multiplicity[nums[i]] * multiplicity[nums[j]]\\n                ans = (ans + count%bound) % bound\\n        return int(ans)\\n```\\n",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\n        # for calculating factorial\\n        factMem = dict()\\n        def fact(n):\\n            if n in factMem:\\n                return factMem[n]\\n            if n <= 1:\\n                factMem[n] = 1\\n                return 1\\n            ans = n * fact(n-1)\\n            factMem[n] = ans\\n            return ans\\n        fact3 = fact(3)\\n        fact2 = fact(2)\\n        \\n        # count the frequency of each element\\n        multiplicity = Counter(arr)\\n        \\n        # create list only contains distinct numbers\\n        nums = []\\n        visited = set()\\n        for n in arr:\\n            if n in visited:\\n                continue\\n            nums.append(n)\\n            visited.add(n)\\n        \\n        # create a postfix set to quickly lookup if a number appears in nums[i:]\\n        postfixNumsSet = []\\n        numsSet = set()\\n        for i in range(len(nums)-1, -1, -1):\\n            numsSet.add(nums[i])\\n            postfixNumsSet.append(numsSet.copy())\\n        postfixNumsSet.reverse()\\n        \\n        bound = 1e9 + 7\\n        ans = 0\\n        for i in range(len(nums)):\\n            freqI = multiplicity[nums[i]]\\n            \\n            # i i i\\n            if multiplicity[nums[i]] >= 3 and nums[i]*3 == target:\\n                count = fact(freqI) // (fact3 * fact(freqI - 3))\\n                ans = (ans + count%bound) % bound\\n            \\n            for j in range(i+1, len(nums)):\\n                freqJ = multiplicity[nums[j]]\\n                \\n                # i i j\\n                if freqI >= 2 and nums[i]*2 + nums[j] == target:\\n                    count = (fact(freqI) // (fact2 * fact(freqI - 2)) ) * freqJ\\n                    ans = (ans + count%bound) % bound\\n                \\n                # j j i\\n                if freqJ >= 2 and nums[i] + nums[j]*2 == target:\\n                    count = (fact(freqJ) // (fact2 * fact(freqJ - 2)) ) * freqI\\n                    ans = (ans + count%bound) % bound\\n                \\n                # i j k\\n                wantedK = target - nums[i] - nums[j]\\n                if j >= len(nums) - 1 or wantedK not in postfixNumsSet[j+1]:\\n                    continue\\n                count = multiplicity[wantedK] * multiplicity[nums[i]] * multiplicity[nums[j]]\\n                ans = (ans + count%bound) % bound\\n        return int(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920650,
                "title": "simple-js-solution-o-n-2-o-1-three-pointer-with-explaination",
                "content": "# Idea\\nFor each number in the array we need to find 2 more numbers which eaual to the sum. We can use 2 nested loops.\\n\\n1. Iterate through each number.\\n2. Inside the inner loop, low and high to keep track of the low and high val.\\n\\ti. sum should be equal to low + high\\n\\tii. If sum is greater we move the high pointer left \\n\\tiii. If sum is smaller we move the low pointer to the right\\n\\tiv. If sum is equal we again have 2 cases\\n\\t\\ta. One where arr[low] === arr[high]. In this case we total possible combinations are (n*n-1)/2;\\n\\t\\tb. Otherwise total combinations are count(high) * count(low)\\n\\nExplaination for arr[low] === arr[high] case\\n![image](https://assets.leetcode.com/users/images/ec9024fc-080b-404d-9377-13941580638a_1649272396.3804002.png)\\n\\n```\\n// For modulo\\nconst MOD = Math.pow(10, 9) + 7;\\n\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst threeSumMulti = function(arr, target) {\\n  // Step 1: Sort the number O(nlogn)\\n  arr.sort((a, b) => a - b);\\n  \\n  // Step 2: 3 Pointer approach O(n^2)\\n  let total = 0;\\n  for(let i = 0; i < arr.length; i += 1) {\\n    // The current value which is the first value\\n    const curVal = arr[i]; \\n    \\n    // Low and high to keep track of the low and high val\\n    // Idea is that sum should be equal to low + high\\n    // If sum is greater we move the high pointer left\\n    // If sum is smaller we move the low pointer to the right\\n    // If sum is equal we again have 2 cases\\n    // One where arr[low] === arr[high]. In this case we total possible combinations are (n*n-1)/2;\\n    // Otherwise total combinations are count(high) * count(low)\\n    let low = i + 1;\\n    let high = arr.length - 1;\\n    \\n    // Loop is run while low is smaller than high\\n    while(low < high) {\\n      const lowVal = arr[low];\\n      const highVal = arr[high];\\n      const sum = curVal + lowVal + highVal;\\n      \\n      if(sum > target) {\\n        high -= 1;\\n      } else if(sum < target) {\\n        low += 1;\\n      } else if(lowVal === highVal) {\\n        total = (total + ((high-low) * (high-low+1))/2) % MOD;\\n        break;\\n      } else {\\n        let lowCount = 0;\\n        let highCount = 0;\\n        while(arr[low] === lowVal) {\\n          low += 1;\\n          lowCount += 1;\\n        }\\n        while(arr[high] === highVal) {\\n          high -= 1;\\n          highCount += 1;\\n        }\\n        total = total + (lowCount * highCount) % MOD;\\n      }\\n    }\\n  }\\n  \\n  // Return the total\\n  return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// For modulo\\nconst MOD = Math.pow(10, 9) + 7;\\n\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst threeSumMulti = function(arr, target) {\\n  // Step 1: Sort the number O(nlogn)\\n  arr.sort((a, b) => a - b);\\n  \\n  // Step 2: 3 Pointer approach O(n^2)\\n  let total = 0;\\n  for(let i = 0; i < arr.length; i += 1) {\\n    // The current value which is the first value\\n    const curVal = arr[i]; \\n    \\n    // Low and high to keep track of the low and high val\\n    // Idea is that sum should be equal to low + high\\n    // If sum is greater we move the high pointer left\\n    // If sum is smaller we move the low pointer to the right\\n    // If sum is equal we again have 2 cases\\n    // One where arr[low] === arr[high]. In this case we total possible combinations are (n*n-1)/2;\\n    // Otherwise total combinations are count(high) * count(low)\\n    let low = i + 1;\\n    let high = arr.length - 1;\\n    \\n    // Loop is run while low is smaller than high\\n    while(low < high) {\\n      const lowVal = arr[low];\\n      const highVal = arr[high];\\n      const sum = curVal + lowVal + highVal;\\n      \\n      if(sum > target) {\\n        high -= 1;\\n      } else if(sum < target) {\\n        low += 1;\\n      } else if(lowVal === highVal) {\\n        total = (total + ((high-low) * (high-low+1))/2) % MOD;\\n        break;\\n      } else {\\n        let lowCount = 0;\\n        let highCount = 0;\\n        while(arr[low] === lowVal) {\\n          low += 1;\\n          lowCount += 1;\\n        }\\n        while(arr[high] === highVal) {\\n          high -= 1;\\n          highCount += 1;\\n        }\\n        total = total + (lowCount * highCount) % MOD;\\n      }\\n    }\\n  }\\n  \\n  // Return the total\\n  return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1920560,
                "title": "python-soln-100-faster-3sum-combinations-o-n-2-comments",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\'\\'\\'\\n        T.C := O(n^2)\\n        \\'\\'\\'\\n        freqs = Counter(arr)\\n\\n        #1. sorted unique nums\\n        nums = sorted(freqs)\\n        n = len(nums)\\n        res = 0 # total number of triplet possible (with repeatation allowed from diff pos)\\n        \\n        for i, n1 in enumerate(nums): # first elem := {n1}\\n            t = target - n1 # target for 2 sum\\n            # Find next 2 elem :- 2 Sum Problem\\n            l, r = i, n-1  # NOTE :- here {n1} can repeat in soln so consdering l = i\\n            while l <= r:\\n                n2, n3 = nums[l], nums[r]\\n                n23 = n2 + n3\\n                if n23 < t:\\n                    l += 1\\n                elif n23 > t:\\n                    r -= 1\\n                else: # Triplet May be possible for (i, l, r)   \\n                    # the only thing we need to check is Frequency of num available accordingly\\n                    f1, f2, f3 = freqs[n1], freqs[n2], freqs[n3]\\n\\n                    # 1. All 3 are unique num (ie n1, n2, n3)  (So no freq check require)\\n                    if i < l < r:\\n                        res += f1*f2*f3\\n                    # 2. 2 Uniques (n1, n1, n3) \\n                    elif (i == l) and (l < r):\\n                        # f1_C_2 * n3\\n                        res += (comb(f1, 2) * f3)\\n                    # 3. 2 Unique (n1, n2, n2)\\n                    elif (i < l) and (l == r):\\n                        # f2_C_2 * f1\\n                        res += (f1 * comb(f2, 2))\\n                    # 4. All 3 same (ie n1, n1, n1)\\n                    else:\\n                        res += comb(f1, 3)\\n\\n                    # Explore further Possibilities\\n                    l, r = l+1, r-1   # Eg 2, 3, 4, 5  & t = 7 -> (2,5) | (3,4)\\n        \\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        \\'\\'\\'\\n        T.C := O(n^2)\\n        \\'\\'\\'\\n        freqs = Counter(arr)\\n\\n        #1. sorted unique nums\\n        nums = sorted(freqs)\\n        n = len(nums)\\n        res = 0 # total number of triplet possible (with repeatation allowed from diff pos)\\n        \\n        for i, n1 in enumerate(nums): # first elem := {n1}\\n            t = target - n1 # target for 2 sum\\n            # Find next 2 elem :- 2 Sum Problem\\n            l, r = i, n-1  # NOTE :- here {n1} can repeat in soln so consdering l = i\\n            while l <= r:\\n                n2, n3 = nums[l], nums[r]\\n                n23 = n2 + n3\\n                if n23 < t:\\n                    l += 1\\n                elif n23 > t:\\n                    r -= 1\\n                else: # Triplet May be possible for (i, l, r)   \\n                    # the only thing we need to check is Frequency of num available accordingly\\n                    f1, f2, f3 = freqs[n1], freqs[n2], freqs[n3]\\n\\n                    # 1. All 3 are unique num (ie n1, n2, n3)  (So no freq check require)\\n                    if i < l < r:\\n                        res += f1*f2*f3\\n                    # 2. 2 Uniques (n1, n1, n3) \\n                    elif (i == l) and (l < r):\\n                        # f1_C_2 * n3\\n                        res += (comb(f1, 2) * f3)\\n                    # 3. 2 Unique (n1, n2, n2)\\n                    elif (i < l) and (l == r):\\n                        # f2_C_2 * f1\\n                        res += (f1 * comb(f2, 2))\\n                    # 4. All 3 same (ie n1, n1, n1)\\n                    else:\\n                        res += comb(f1, 3)\\n\\n                    # Explore further Possibilities\\n                    l, r = l+1, r-1   # Eg 2, 3, 4, 5  & t = 7 -> (2,5) | (3,4)\\n        \\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920555,
                "title": "c-sorting-map-two-pointers-o-n-2-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, int> mp;//num, freq\\n        \\n        int count = 0;\\n        int mod = 1000000007;\\n        \\n        for (int i=0; i<arr.size(); i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        for (int i=0; i<arr.size()-2; i++){\\n            \\n            int sum = target - arr[i];\\n            \\n            mp[arr[i]]--;\\n            \\n            int left = i+1;\\n            int right = arr.size()-1;\\n            \\n            while(left < right){\\n                \\n                int mysum = arr[left] + arr[right];\\n                \\n                if (mysum > sum) right -= mp[arr[right]];\\n                else if (mysum < sum) left += mp[arr[left]];\\n                else{\\n                    \\n                    if (arr[left] == arr[right]){\\n                        int n = right - left + 1;\\n                        count = (count + (n*(n-1))/2)%mod;\\n                        break;\\n                    }\\n                    \\n                    count = (count + mp[arr[left]]*mp[arr[right]])%mod;\\n                    left += mp[arr[left]];\\n                    right -= mp[arr[right]];  \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        unordered_map<int, int> mp;//num, freq\\n        \\n        int count = 0;\\n        int mod = 1000000007;\\n        \\n        for (int i=0; i<arr.size(); i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        for (int i=0; i<arr.size()-2; i++){\\n            \\n            int sum = target - arr[i];\\n            \\n            mp[arr[i]]--;\\n            \\n            int left = i+1;\\n            int right = arr.size()-1;\\n            \\n            while(left < right){\\n                \\n                int mysum = arr[left] + arr[right];\\n                \\n                if (mysum > sum) right -= mp[arr[right]];\\n                else if (mysum < sum) left += mp[arr[left]];\\n                else{\\n                    \\n                    if (arr[left] == arr[right]){\\n                        int n = right - left + 1;\\n                        count = (count + (n*(n-1))/2)%mod;\\n                        break;\\n                    }\\n                    \\n                    count = (count + mp[arr[left]]*mp[arr[right]])%mod;\\n                    left += mp[arr[left]];\\n                    right -= mp[arr[right]];  \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920307,
                "title": "hashmap-approach-time-o-n-2-and-space-o-n",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> freqMap = new HashMap<>();\\n        for(int element : arr) { // for all the elements in the array \\n            long freq = freqMap.getOrDefault(element, 0l); \\n            // calculating the frequency of all the elements\\n            freqMap.put(element, freq + 1l); \\n            // updating the frequency one higher than the previous one                       \\n        }\\n        long ans = 0;\\n        for(Integer el1 : freqMap.keySet()) {\\n            for(Integer el2 : freqMap.keySet()) {\\n                int el3 = target - el1 - el2;\\n                if(freqMap.containsKey(el3)) {\\n                    long freq1 = freqMap.get(el1);\\n                    long freq2 = freqMap.get(el2);\\n                    long freq3 = freqMap.get(el3);\\n                    if(el1 == el2 && el1 == el3) {\\n                        ans += (freq1 * (freq1 - 1) * (freq1 - 2)) / 6;\\n                    }\\n                    if(el1 == el2 && el1 != el3) {\\n                        ans += ((freq1 * (freq1 - 1)) / 2 * freq3);\\n                    }\\n                    if(el1 < el2 && el2 < el3) {\\n                        ans += (freq1 * freq2 * freq3);\\n                    }\\n                }\\n                ans = ans % 1000000007;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> freqMap = new HashMap<>();\\n        for(int element : arr) { // for all the elements in the array \\n            long freq = freqMap.getOrDefault(element, 0l); \\n            // calculating the frequency of all the elements\\n            freqMap.put(element, freq + 1l); \\n            // updating the frequency one higher than the previous one                       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1920256,
                "title": "approach-using-two-sum-o-n-2-time",
                "content": "\\n    int twosum(vector<int>& arr, int target, int s, int e){\\n        unordered_map<int,long long>m1;\\n        long long ans=0;\\n        for(int i=s;i<=e;i++){\\n            if(m1.find(target-arr[i])!=m1.end())\\n               { ans+=(m1[target-arr[i]])%1000000007;\\n                ans=ans%1000000007;}\\n             m1[arr[i]]++;\\n        }\\n       return ans;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n\\n        long long ans=0;\\n\\n        \\n        int e=arr.size()-1;\\n        for(int i=0;i<arr.size();i++){\\n            int newt=target-arr[i];\\n            ans+=twosum(arr, newt, i+1, e);\\n            ans=ans%1000000007;\\n        }\\n        return ans;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int twosum(vector<int>& arr, int target, int s, int e){\\n        unordered_map<int,long long>m1;\\n        long long ans=0;\\n        for(int i=s;i<=e;i++){\\n            if(m1.find(target-arr[i])!=m1.end())\\n               { ans+=(m1[target-arr[i]])%1000000007;\\n                ans=ans%1000000007;}\\n             m1[arr[i]]++;\\n        }\\n       return ans;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n\\n        long long ans=0;\\n\\n        \\n        int e=arr.size()-1;\\n        for(int i=0;i<arr.size();i++){\\n            int newt=target-arr[i];\\n            ans+=twosum(arr, newt, i+1, e);\\n            ans=ans%1000000007;\\n        }\\n        return ans;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1920202,
                "title": "c-simplest-solution-2-different-approach",
                "content": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n#         T.C. O(N^2) S.C. O(N)\\n\\t\\tlong long ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            ans+=m[target-arr[i]];\\n            ans%=(1000000007);\\n            for(int j=0;j<i;j++){\\n                m[arr[i]+arr[j]]++;\\n            }\\n        }\\n        return ans;\\n#         T.C. O(NLOGN) S.C. O(1) \\n        sort(arr.begin(),arr.end());\\n        long long ans=0;\\n        for(int i=0;i<arr.size();i++){\\n            int l=i+1,r=arr.size()-1;\\n            while(l<r){\\n                if(arr[i]+arr[l]+arr[r]==target){\\n                    int l_cnt=1,r_cnt=1;\\n                    while(l<r && arr[l]==arr[l+1]){\\n                        l_cnt++;\\n                        l++;\\n                    }\\n                     while(l<r && arr[r]==arr[r-1]){\\n                        r_cnt++;\\n                        r--;\\n                    }\\n                    if(r==l){\\n                        long long x=(l_cnt*(l_cnt-1))/2;\\n                        ans+=x;\\n                        ans%=1000000007;\\n                    }else{\\n                        long long x=(l_cnt*r_cnt);\\n                        ans+=(x%1000000007);\\n                        ans%=1000000007;\\n                            \\n                    }\\n                    r--;l++;\\n                    \\n                }\\n                else if(arr[i]+arr[l]+arr[r]>target){\\n                    r--;\\n                }\\n                else if(arr[i]+arr[l]+arr[r]<target){\\n                    l++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n#         T.C. O(N^2) S.C. O(N)\\n\\t\\tlong long ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            ans+=m[target-arr[i]];\\n            ans%=(1000000007);\\n            for(int j=0;j<i;j++){\\n                m[arr[i]+arr[j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1920126,
                "title": "very-easy-o-n-2-solution",
                "content": "Here is my code \\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n         int n = arr.size();\\n         int ans = 0;\\n         int mod = 1e9 + 7;\\n         int sz = 100 * (3000);\\n         sz++;\\n         vector<int> pref(sz , 0);\\n         for(int i=0;i<n;i++)\\n         {\\n             int val = target - (arr[i]);\\n             \\n             if(val >= 0)\\n             {\\n                 ans = (ans + pref[val])%mod;\\n             }\\n             \\n             for(int j=0;j<i;j++)\\n             {\\n                 pref[arr[i] + arr[j]]++;\\n             }\\n         }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n         int n = arr.size();\\n         int ans = 0;\\n         int mod = 1e9 + 7;\\n         int sz = 100 * (3000);\\n         sz++;\\n         vector<int> pref(sz , 0);\\n         for(int i=0;i<n;i++)\\n         {\\n             int val = target - (arr[i]);\\n             \\n             if(val >= 0)\\n             {\\n                 ans = (ans + pref[val])%mod;\\n             }\\n             \\n             for(int j=0;j<i;j++)\\n             {\\n                 pref[arr[i] + arr[j]]++;\\n             }\\n         }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920065,
                "title": "java-not-really-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int mod = (int)1e9 + 7;\\n        long[] count = new long[101];\\n        \\n        for (int a: arr) {\\n            count[a] ++;\\n        }\\n        \\n        long res =0;\\n        \\n        for (int i = 0; i < 101; i ++) {\\n            for (int j = i; j < 101; j++) {\\n                int f = target - i - j;\\n                \\n                if (f < j || f >= 101 || count[i] == 0 || count[j] == 0 || count[f] == 0) {\\n                    continue;\\n                }\\n                long fi = count[i];\\n                long fj = i == j ? count[i] - 1 : count[j];\\n                long ff = j == f ? i == f ? count[i] - 2 : count[j] - 1 : count[f];\\n\\t\\t\\t\\t// 3! == 6, 2! == 2, 1! == 1 :D\\n                int permutation = (j == f && j == i) ? 6 : (j == f || j == i) ? 2 : 1;\\n                if (fi <= 0 || fj <= 0 || ff <= 0) {\\n                    continue;\\n                }\\n                // i use the fomula of Combination with repetition in here\\n                res += (fi * fj * ff / permutation) ; \\n            }\\n        }\\n        \\n        return (int)(res % mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        int mod = (int)1e9 + 7;\\n        long[] count = new long[101];\\n        \\n        for (int a: arr) {\\n            count[a] ++;\\n        }\\n        \\n        long res =0;\\n        \\n        for (int i = 0; i < 101; i ++) {\\n            for (int j = i; j < 101; j++) {\\n                int f = target - i - j;\\n                \\n                if (f < j || f >= 101 || count[i] == 0 || count[j] == 0 || count[f] == 0) {\\n                    continue;\\n                }\\n                long fi = count[i];\\n                long fj = i == j ? count[i] - 1 : count[j];\\n                long ff = j == f ? i == f ? count[i] - 2 : count[j] - 1 : count[f];\\n\\t\\t\\t\\t// 3! == 6, 2! == 2, 1! == 1 :D\\n                int permutation = (j == f && j == i) ? 6 : (j == f || j == i) ? 2 : 1;\\n                if (fi <= 0 || fj <= 0 || ff <= 0) {\\n                    continue;\\n                }\\n                // i use the fomula of Combination with repetition in here\\n                res += (fi * fj * ff / permutation) ; \\n            }\\n        }\\n        \\n        return (int)(res % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919977,
                "title": "3-pointer-with-ncr-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long nCr(long long n, int r)\\n    {\\n        long long fecAns = 1;\\n        int dif = n - r + 1;\\n        for (int i = n; i >= dif; i--)\\n        {\\n            fecAns = (fecAns * i);\\n        }\\n        long long gT = 1;\\n        for (int i = r; i >= 2; i--)\\n        {\\n            gT = (gT * i);\\n        }\\n        return fecAns / gT;\\n    }\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n        vector<int> count(101, 0);\\n        for (auto i : arr)\\n            count[i]++;\\n        sort(arr.begin(), arr.end());\\n        long long ans = 0;\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            if (i > 0 && arr[i] == arr[i - 1])\\n                continue;\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (j > i + 1 && arr[j] == arr[j - 1])\\n                    continue;\\n                for (int k = j + 1; k < arr.size(); k++)\\n                {\\n                    if (k > j + 1 && arr[k] == arr[k - 1])\\n                        continue;\\n                    if (arr[i] + arr[j] + arr[k] == target)\\n                    {\\n                        if (arr[i] == arr[j] && arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[i]], 3);\\n                            ans += value;\\n                        }\\n                        else if (arr[i] == arr[j])\\n                        {\\n                            long long value = nCr(count[arr[i]], 2) * count[arr[k]];\\n                            ans += value;\\n                        }\\n                        else if (arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[k]], 2) * count[arr[i]];\\n                            ans += value;\\n                        }\\n                        else\\n                        {\\n                            int value = nCr(count[arr[i]], 1) * nCr(count[arr[j]], 1) * nCr(count[arr[k]], 1);\\n                            ans += value;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long nCr(long long n, int r)\\n    {\\n        long long fecAns = 1;\\n        int dif = n - r + 1;\\n        for (int i = n; i >= dif; i--)\\n        {\\n            fecAns = (fecAns * i);\\n        }\\n        long long gT = 1;\\n        for (int i = r; i >= 2; i--)\\n        {\\n            gT = (gT * i);\\n        }\\n        return fecAns / gT;\\n    }\\n    int threeSumMulti(vector<int> &arr, int target)\\n    {\\n        vector<int> count(101, 0);\\n        for (auto i : arr)\\n            count[i]++;\\n        sort(arr.begin(), arr.end());\\n        long long ans = 0;\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            if (i > 0 && arr[i] == arr[i - 1])\\n                continue;\\n            for (int j = i + 1; j < arr.size(); j++)\\n            {\\n                if (j > i + 1 && arr[j] == arr[j - 1])\\n                    continue;\\n                for (int k = j + 1; k < arr.size(); k++)\\n                {\\n                    if (k > j + 1 && arr[k] == arr[k - 1])\\n                        continue;\\n                    if (arr[i] + arr[j] + arr[k] == target)\\n                    {\\n                        if (arr[i] == arr[j] && arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[i]], 3);\\n                            ans += value;\\n                        }\\n                        else if (arr[i] == arr[j])\\n                        {\\n                            long long value = nCr(count[arr[i]], 2) * count[arr[k]];\\n                            ans += value;\\n                        }\\n                        else if (arr[j] == arr[k])\\n                        {\\n                            long long value = nCr(count[arr[k]], 2) * count[arr[i]];\\n                            ans += value;\\n                        }\\n                        else\\n                        {\\n                            int value = nCr(count[arr[i]], 1) * nCr(count[arr[j]], 1) * nCr(count[arr[k]], 1);\\n                            ans += value;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919857,
                "title": "two-pointers",
                "content": "\\nclass Solution {\\n  int mod = 1e9+7;\\npublic:\\n\\n\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n      sort(arr.begin(),arr.end());\\n      long long ans =  0;\\n      int n = arr.size();\\n      for(int i=0;i<n;i++)\\n      {\\n        int k = i+1;\\n        int j = n-1;\\n        int currsum = target-arr[i];\\n        while(k<j)\\n        {\\n          if((arr[k]+arr[j] )== currsum)\\n          {\\n            int l=1,r=1;\\n            while(k<j && arr[k] == arr[k+1])\\n            {\\n              k++;\\n              l++;\\n            } \\n            while(k<j && arr[j] == arr[j-1])\\n            {\\n              j--;\\n              r++;\\n            }\\n            \\n            if(k == j)\\n            {\\n              long long take = (l*(l-1))/2;\\n              ans = (ans+take)%mod;\\n            }else{\\n              ans = (ans + (l*r)%mod)%mod;\\n            }\\n            k++;\\n            j--;\\n          }else if(arr[k]+arr[j] > currsum)\\n          {\\n            j--;\\n          }else{\\n            k++;\\n          }\\n        }\\n      }\\n      return ans>mod ? mod : ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n  int mod = 1e9+7;\\npublic:\\n\\n\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        \\n      sort(arr.begin(),arr.end());\\n      long long ans =  0;\\n      int n = arr.size();\\n      for(int i=0;i<n;i++)\\n      {\\n        int k = i+1;\\n        int j = n-1;\\n        int currsum = target-arr[i];\\n        while(k<j)\\n        {\\n          if((arr[k]+arr[j] )== currsum)\\n          {\\n            int l=1,r=1;\\n            while(k<j && arr[k] == arr[k+1])\\n            {\\n              k++;\\n              l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919843,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long int ans = 0;\\n        int n = arr.size(), mx = *max_element(arr.begin(), arr.end()), mod = 1e9+7;\\n        vector <vector<int>> v(n+1, vector<int>(mx+1, 0));\\n        v[0][arr[0]] = 1;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<=mx; j++)\\n                v[i][j] = v[i-1][j];\\n            v[i][arr[i]] +=  1;\\n        }\\n        for(int i=1; i<n-1; i++){\\n            int l = 0, r = target-arr[i];\\n            while(r >= 0){\\n                if(l<=mx && r <= mx)\\n                    ans = (ans + v[i-1][l]*(v[n-1][r]-v[i][r]))%mod;\\n                l += 1;\\n                r -= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long long int ans = 0;\\n        int n = arr.size(), mx = *max_element(arr.begin(), arr.end()), mod = 1e9+7;\\n        vector <vector<int>> v(n+1, vector<int>(mx+1, 0));\\n        v[0][arr[0]] = 1;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<=mx; j++)\\n                v[i][j] = v[i-1][j];\\n            v[i][arr[i]] +=  1;\\n        }\\n        for(int i=1; i<n-1; i++){\\n            int l = 0, r = target-arr[i];\\n            while(r >= 0){\\n                if(l<=mx && r <= mx)\\n                    ans = (ans + v[i-1][l]*(v[n-1][r]-v[i][r]))%mod;\\n                l += 1;\\n                r -= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919762,
                "title": "best-solution-with-explanation-c-java-python",
                "content": "***Please Upvote if you Like it!***\\n\\nCount the occurrence of each number.\\nusing hashmap or array up to you.\\n\\nLoop i on all numbers,\\nloop j on all numbers,\\ncheck if k = target - i - j is valid.\\n\\nAdd the number of this combination to result.\\n3 cases covers all possible combination:\\n\\ni == j == k\\ni == j != k\\ni < k && j < k\\nTime Complexity:\\n3 <= A.length <= 3000, so N = 3000\\nBut 0 <= A[i] <= 100\\nSo my solution is O(N + 101 * 101)\\n\\nC++:\\n\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\nJava:\\n\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\nPython:\\n\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "***Please Upvote if you Like it!***\\n\\nCount the occurrence of each number.\\nusing hashmap or array up to you.\\n\\nLoop i on all numbers,\\nloop j on all numbers,\\ncheck if k = target - i - j is valid.\\n\\nAdd the number of this combination to result.\\n3 cases covers all possible combination:\\n\\ni == j == k\\ni == j != k\\ni < k && j < k\\nTime Complexity:\\n3 <= A.length <= 3000, so N = 3000\\nBut 0 <= A[i] <= 100\\nSo my solution is O(N + 101 * 101)\\n\\nC++:\\n\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\nJava:\\n\\n    public int threeSumMulti(int[] A, int target) {\\n        long[] c = new long[101];\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (int i = 0; i <= 100; i++)\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k > 100 || k < 0) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return (int)(res % (1e9 + 7));\\n    }\\nPython:\\n\\n    def threeSumMulti(self, A, target):\\n        c = collections.Counter(A)\\n        res = 0\\n        for i, j in itertools.combinations_with_replacement(c, 2):\\n            k = target - i - j\\n            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\\n            elif i == j != k: res += c[i] * (c[i] - 1) / 2 * c[k]\\n            elif k > i and k > j: res += c[i] * c[j] * c[k]\\n        return res % (10**9 + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 1919690,
                "title": "cpp-best-solution",
                "content": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }\\n        return res % int(1e9 + 7);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int target) {\\n        unordered_map<int, long> c;\\n        for (int a : A) c[a]++;\\n        long res = 0;\\n        for (auto it : c)\\n            for (auto it2 : c) {\\n                int i = it.first, j = it2.first, k = target - i - j;\\n                if (!c.count(k)) continue;\\n                if (i == j && j == k)\\n                    res += c[i] * (c[i] - 1) * (c[i] - 2) / 6;\\n                else if (i == j && j != k)\\n                    res += c[i] * (c[i] - 1) / 2 * c[k];\\n                else if (i < j && j < k)\\n                    res += c[i] * c[j] * c[k];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919657,
                "title": "dp-o-n-2-type-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        int n=arr.length;\\n        Set<Integer> keys = new HashSet<>();\\n        \\n        int dp[][] = new int[n+1][target+1];\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            keys.add(arr[i]);\\n        }\\n        \\n        for(int value:keys) {\\n            for(int i=arr.length-1;i>=0 && value<=target;i--) {\\n                int count = arr[i]==value?1:0;\\n                dp[i][value]=dp[i+1][value]+count;\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                int sum=arr[i]+arr[j];\\n                if(sum>target) {\\n                    continue;\\n                }else {\\n                    int delta = target-sum;\\n                    count=(count+dp[j+1][delta])%1000000007;                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        int n=arr.length;\\n        Set<Integer> keys = new HashSet<>();\\n        \\n        int dp[][] = new int[n+1][target+1];\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            keys.add(arr[i]);\\n        }\\n        \\n        for(int value:keys) {\\n            for(int i=arr.length-1;i>=0 && value<=target;i--) {\\n                int count = arr[i]==value?1:0;\\n                dp[i][value]=dp[i+1][value]+count;\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                int sum=arr[i]+arr[j];\\n                if(sum>target) {\\n                    continue;\\n                }else {\\n                    int delta = target-sum;\\n                    count=(count+dp[j+1][delta])%1000000007;                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919638,
                "title": "c-two-pointer-o-n-2-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++){\\n            int left=target-arr[i];\\n            if(left>=0){\\n                int s=i+1,e=arr.size()-1;\\n                while(s<e){\\n                    if((arr[s]+arr[e])==left){\\n                        int t1=0,t2=0,vals=arr[s],vale=arr[e];\\n                        int sk=s,ek=e;\\n                        if(vals==vale){\\n                            while(sk<=e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n                            res+=t1*(t1-1)/2;\\n                            s=sk;\\n                            \\n                        }\\n                        else{\\n                          while(sk<e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n\\n                          while(ek>s&&arr[ek]==vale)\\n                            {  t2++; ek--;}\\n\\n                            res+=t1*t2;\\n                            s=sk; e=ek;\\n                            \\n                        }\\n                        \\n                    }\\n                    else if(left<arr[e]+arr[s])\\n                        e--;\\n                    else if(left>arr[e]+arr[s]) s++;\\n                    \\n                }\\n            }\\n        }\\n        int mod=1000000007;\\n        int res2=res%mod;\\n        return res2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++){\\n            int left=target-arr[i];\\n            if(left>=0){\\n                int s=i+1,e=arr.size()-1;\\n                while(s<e){\\n                    if((arr[s]+arr[e])==left){\\n                        int t1=0,t2=0,vals=arr[s],vale=arr[e];\\n                        int sk=s,ek=e;\\n                        if(vals==vale){\\n                            while(sk<=e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n                            res+=t1*(t1-1)/2;\\n                            s=sk;\\n                            \\n                        }\\n                        else{\\n                          while(sk<e&&arr[sk]==vals)\\n                            { t1++;sk++;}\\n\\n                          while(ek>s&&arr[ek]==vale)\\n                            {  t2++; ek--;}\\n\\n                            res+=t1*t2;\\n                            s=sk; e=ek;\\n                            \\n                        }\\n                        \\n                    }\\n                    else if(left<arr[e]+arr[s])\\n                        e--;\\n                    else if(left>arr[e]+arr[s]) s++;\\n                    \\n                }\\n            }\\n        }\\n        int mod=1000000007;\\n        int res2=res%mod;\\n        return res2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919555,
                "title": "c-dynamic-programming-easy-pick-not-pick",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[3001][301][4];\\n    int F(vector<int>&arr,int target,int i,int n,int count){\\n        if(count == 0 and target == 0){\\n            return  1;\\n        }\\n        if(i == arr.size()){\\n            return 0;\\n        }\\n        if(count == 0 or target < 0){\\n            return 0;\\n        }\\n        if(dp[i][target][count] != -1){\\n            return dp[i][target][count];\\n        }\\n        int notPick = F(arr,target,i + 1,n,count);\\n        int Pick = arr[i] <= target ? F(arr,target - arr[i],i + 1,n,count - 1) : 0;\\n        return dp[i][target][count] = (notPick + Pick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return F(arr,target,0,arr.size(),3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[3001][301][4];\\n    int F(vector<int>&arr,int target,int i,int n,int count){\\n        if(count == 0 and target == 0){\\n            return  1;\\n        }\\n        if(i == arr.size()){\\n            return 0;\\n        }\\n        if(count == 0 or target < 0){\\n            return 0;\\n        }\\n        if(dp[i][target][count] != -1){\\n            return dp[i][target][count];\\n        }\\n        int notPick = F(arr,target,i + 1,n,count);\\n        int Pick = arr[i] <= target ? F(arr,target - arr[i],i + 1,n,count - 1) : 0;\\n        return dp[i][target][count] = (notPick + Pick)%mod;\\n    }\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return F(arr,target,0,arr.size(),3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919527,
                "title": "kotlin-hashmap-solution-100-100",
                "content": "```\\nclass Solution {\\n    fun threeSumMulti(arr: IntArray, target: Int): Int {\\n        val MOD = 1_000_000_007\\n        val map = mutableMapOf<Int, Long>()\\n        \\n        for (num in arr) {\\n            map.put(num, map.getOrDefault(num, 0) + 1)\\n        }\\n        \\n        var ans: Long = 0\\n\\n        for (i in map.keys) {\\n            for (j in map.keys) {\\n                val k = target - i - j\\n                if (map.containsKey(k)) {\\n                    val ci: Long = map[i]!!\\n                    val cj: Long = map[j]!!\\n                    val ck: Long = map[k]!!\\n                    \\n                    if (i == j && j == k) {\\n                        ans += ci * (ci - 1) * (ci - 2) / 6\\n                    } else if (i == j) {\\n                        ans += ci * (ci - 1) / 2 * ck;\\n                    } else if (i < j && j < k) {\\n                        ans += ci * cj * ck\\n                    }\\n                    ans %= MOD\\n                }\\n            }\\n        }\\n        \\n        return ans.toInt()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun threeSumMulti(arr: IntArray, target: Int): Int {\\n        val MOD = 1_000_000_007\\n        val map = mutableMapOf<Int, Long>()\\n        \\n        for (num in arr) {\\n            map.put(num, map.getOrDefault(num, 0) + 1)\\n        }\\n        \\n        var ans: Long = 0\\n\\n        for (i in map.keys) {\\n            for (j in map.keys) {\\n                val k = target - i - j\\n                if (map.containsKey(k)) {\\n                    val ci: Long = map[i]!!\\n                    val cj: Long = map[j]!!\\n                    val ck: Long = map[k]!!\\n                    \\n                    if (i == j && j == k) {\\n                        ans += ci * (ci - 1) * (ci - 2) / 6\\n                    } else if (i == j) {\\n                        ans += ci * (ci - 1) / 2 * ck;\\n                    } else if (i < j && j < k) {\\n                        ans += ci * cj * ck\\n                    }\\n                    ans %= MOD\\n                }\\n            }\\n        }\\n        \\n        return ans.toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919499,
                "title": "c-3-solutions-w-w-o-sort-w-w-o-map-o-n-2-time",
                "content": "**Approach #1**\\n\\n```\\n    int threeSumMulti(vector<int>& a, int t) {\\n\\t\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n            mp[a[i]]++;\\n        \\n        for(auto it1:mp)\\n        {\\n            if(it1.first>t)\\n                continue;\\n            \\n            for(auto it2:mp)\\n            {\\n                \\n                int x=it1.first;\\n                int y=it2.first;\\n                int z=t-x-y;\\n                \\n                if(mp.find(z)!=mp.end())\\n                {\\n                    if(x==y && y==z)\\n                        c+=mp[x]*(mp[x]-1)*(mp[x]-2)/6;\\n                    else if(x==y && y!=z)\\n                        c+=mp[x]*(mp[x]-1)/2*mp[z];\\n                    else if(x<y && y<z)\\n                        c+=mp[x]*mp[y]*mp[z];\\n                    \\n                    c=c%m;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```\\n\\n**Approach #2**\\n```\\n    int threeSumMulti(vector<int>& a, int t) \\n    {\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,j,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            c+=mp[t-a[i]];\\n            \\n            for(j=0;j<i;j++)\\n                mp[a[i]+a[j]]++;\\n        }\\n        \\n        return c%m;\\n    }\\n```\\n\\n**Approach #3**\\n```\\n    int threeSumMulti(vector<int>& a, int t)\\n    {\\n        int n=a.size();\\n        int i,j,k;\\n        int m=1e9+7;\\n        long c=0;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            if(a[i]>t)\\n                break;\\n            \\n            if(i>0 && a[i]==a[i-1])\\n                continue;\\n            \\n            j=i+1;\\n            k=n-1;\\n            \\n            while(j<k)\\n            {\\n                int s=a[i]+a[j]+a[k];\\n                \\n                if(s<t)\\n                    j++;\\n                else if(s>t)\\n                    k--;\\n                else\\n                {\\n                    long c1=1,c2=1,c3=1;\\n                    \\n                    int i1=i;\\n                    while(i1<n-1 && a[i1]==a[i1+1])\\n                    {\\n                        i1++;\\n                        c1++;\\n                    }\\n                    \\n                    while(j<n-1 && a[j]==a[j+1])\\n                    {\\n                        j++;\\n                        c2++;\\n                    }\\n                    \\n                    while(k>j && a[k]==a[k-1])\\n                    {\\n                        k--;\\n                        c3++;\\n                    }\\n                    \\n                    if(a[i]==a[j] && a[j]==a[k])\\n                        c+=c1*(c1-1)*(c1-2)/6;\\n                    else if(a[i]==a[j])\\n                        c+=c1*(c1-1)/2*c3;\\n                    else if(a[j]==a[k])\\n                        c+=c1*c2*(c2-1)/2;\\n                    else\\n                        c+=c1*c2*c3;\\n                    \\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return c%m;\\n    }\\n```\\n\\n**Do share your views && upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumMulti(vector<int>& a, int t) {\\n\\t\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n            mp[a[i]]++;\\n        \\n        for(auto it1:mp)\\n        {\\n            if(it1.first>t)\\n                continue;\\n            \\n            for(auto it2:mp)\\n            {\\n                \\n                int x=it1.first;\\n                int y=it2.first;\\n                int z=t-x-y;\\n                \\n                if(mp.find(z)!=mp.end())\\n                {\\n                    if(x==y && y==z)\\n                        c+=mp[x]*(mp[x]-1)*(mp[x]-2)/6;\\n                    else if(x==y && y!=z)\\n                        c+=mp[x]*(mp[x]-1)/2*mp[z];\\n                    else if(x<y && y<z)\\n                        c+=mp[x]*mp[y]*mp[z];\\n                    \\n                    c=c%m;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```\n```\\n    int threeSumMulti(vector<int>& a, int t) \\n    {\\n        int n=a.size();\\n        unordered_map<int,long> mp;\\n        int i,j,m=1e9+7;\\n        long c=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            c+=mp[t-a[i]];\\n            \\n            for(j=0;j<i;j++)\\n                mp[a[i]+a[j]]++;\\n        }\\n        \\n        return c%m;\\n    }\\n```\n```\\n    int threeSumMulti(vector<int>& a, int t)\\n    {\\n        int n=a.size();\\n        int i,j,k;\\n        int m=1e9+7;\\n        long c=0;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            if(a[i]>t)\\n                break;\\n            \\n            if(i>0 && a[i]==a[i-1])\\n                continue;\\n            \\n            j=i+1;\\n            k=n-1;\\n            \\n            while(j<k)\\n            {\\n                int s=a[i]+a[j]+a[k];\\n                \\n                if(s<t)\\n                    j++;\\n                else if(s>t)\\n                    k--;\\n                else\\n                {\\n                    long c1=1,c2=1,c3=1;\\n                    \\n                    int i1=i;\\n                    while(i1<n-1 && a[i1]==a[i1+1])\\n                    {\\n                        i1++;\\n                        c1++;\\n                    }\\n                    \\n                    while(j<n-1 && a[j]==a[j+1])\\n                    {\\n                        j++;\\n                        c2++;\\n                    }\\n                    \\n                    while(k>j && a[k]==a[k-1])\\n                    {\\n                        k--;\\n                        c3++;\\n                    }\\n                    \\n                    if(a[i]==a[j] && a[j]==a[k])\\n                        c+=c1*(c1-1)*(c1-2)/6;\\n                    else if(a[i]==a[j])\\n                        c+=c1*(c1-1)/2*c3;\\n                    else if(a[j]==a[k])\\n                        c+=c1*c2*(c2-1)/2;\\n                    else\\n                        c+=c1*c2*c3;\\n                    \\n                    j++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return c%m;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919447,
                "title": "c-solution-modification-of-3-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), cnt = 0, cnt1, cnt2, val, k, left, right;\\n        long mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        for(int i = 0; i < n; ++i)\\n        {\\n            val = arr[i], k = target-val;\\n            left = i+1,right = n-1;\\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] == k)\\n                {\\n                    cnt1 = 1, cnt2 = 1;\\n                    while(left < right && arr[left] == arr[left+1]) \\n                    {\\n                        left++;\\n                        cnt1++;\\n                    }\\n                    while(left < right && arr[right-1] == arr[right])\\n                    {\\n                        right--;\\n                        cnt2++;\\n                    } \\n                    if(left == right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*(cnt1-1)%mod)/2)%mod;\\n                    }\\n                    else if(left != right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*cnt2%mod)%mod)%mod;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n                else if(arr[left]+arr[right] > k) \\n                    right--;\\n                else if(arr[left]+arr[right] < k) \\n                    left++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size(), cnt = 0, cnt1, cnt2, val, k, left, right;\\n        long mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        for(int i = 0; i < n; ++i)\\n        {\\n            val = arr[i], k = target-val;\\n            left = i+1,right = n-1;\\n            while(left < right)\\n            {\\n                if(arr[left]+arr[right] == k)\\n                {\\n                    cnt1 = 1, cnt2 = 1;\\n                    while(left < right && arr[left] == arr[left+1]) \\n                    {\\n                        left++;\\n                        cnt1++;\\n                    }\\n                    while(left < right && arr[right-1] == arr[right])\\n                    {\\n                        right--;\\n                        cnt2++;\\n                    } \\n                    if(left == right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*(cnt1-1)%mod)/2)%mod;\\n                    }\\n                    else if(left != right)\\n                    {\\n                        cnt = (cnt%mod+(cnt1%mod*cnt2%mod)%mod)%mod;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n                else if(arr[left]+arr[right] > k) \\n                    right--;\\n                else if(arr[left]+arr[right] < k) \\n                    left++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919251,
                "title": "why-not-working-o-n-2logn",
                "content": "please! someone crack it...I shoud work on O(n^2logn)\\n```\\nclass Solution {\\npublic:\\n    int countGreater(vector<int>& arr, int n, int k){\\n        int l = 0;\\n        int r = n - 1;\\n        int leftGreater = n;\\n        while (l <= r) {\\n            int m = (r + l) / 2;\\n            if (arr[m] > k) {\\n                leftGreater = m;\\n                r = m - 1;\\n            }\\n            else\\n                l = m + 1;\\n        }\\n \\n        return (n - leftGreater);\\n    } \\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,vector<int>> d;\\n        for(int i=0;i<n;i++)\\n            d[arr[i]].push_back(i);\\n        int ans=0;\\n        for(int i=0;i<n-2;i++)\\n            for(int j=i+1;j<n-1;j++){\\n                int bal=target-arr[i]-arr[j];\\n                ans=(ans+countGreater(d[bal],d[bal].size(),j))%1000000007;\\n            }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int countGreater(vector<int>& arr, int n, int k){\\n        int l = 0;\\n        int r = n - 1;\\n        int leftGreater = n;\\n        while (l <= r) {\\n            int m = (r + l) / 2;\\n            if (arr[m] > k) {\\n                leftGreater = m;\\n                r = m - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1919191,
                "title": "simple-solution-no-sorting-no-combination-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int N = arr.size(), ans = 0, MOD = 1\\'000\\'000\\'007;\\n        unordered_map<int, int> m;\\n        for(int i = 0; i < N; ++i){\\n            for(int j = i + 1; j < N; ++j){\\n                int subtarget = target - (arr[i] + arr[j]);\\n                if(m.count(subtarget)){\\n                    ans = (ans + m[subtarget]) % MOD;\\n                }\\n            }\\n            ++m[arr[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int N = arr.size(), ans = 0, MOD = 1\\'000\\'000\\'007;\\n        unordered_map<int, int> m;\\n        for(int i = 0; i < N; ++i){\\n            for(int j = i + 1; j < N; ++j){\\n                int subtarget = target - (arr[i] + arr[j]);\\n                if(m.count(subtarget)){\\n                    ans = (ans + m[subtarget]) % MOD;\\n                }\\n            }\\n            ++m[arr[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919162,
                "title": "java-solution-highly-commented-easy-understanding",
                "content": "```\\n public int threeSumMulti(int[] arr, int target) {\\n       \\n    long[] freq = new long[101];  //This is freq array since number lies from [1,100]\\n        int max = 0;\\n        for (int a : arr) {\\n            freq[a]++;\\n            max = Math.max(max,a);\\n        }\\n        \\n        long ans = 0;\\n        for (int i = 0; i <= max; i++)\\n            for (int j = i; j <= max; j++) {\\n                \\n                int k = target - i - j;  //as (i+j+k==target)\\n                \\n                if(k<0 || k>100)  //to avoid index out of bound in freqArray\\n                    continue;\\n                \\n    /*nC3 (as all same numbers able to meet the target \\n\\tEx: arr [1,1,1,1,1,1,1] , target=3)  Case:{1,1,1} */\\n\\t\\n           if (i == j && j == k)  \\n    ans += freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6; \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t//after simplyfying nc3 you will get this \\n                \\n /*nC2 (as one number is different and 2 are same in contributing to achieve the \\n target Ex: [1,1,1,1,1,2,2,2,2], target = 5) Case:{1,2,2}*/\\n                \\n                else if (i == j && j != k)   \\n            ans += freq[i] * (freq[i] - 1) / 2 * freq[k];  \\n\\t\\t\\t\\n\\t//after simplfying nc2 you will get this * different ones freq have to multiply\\n                \\n/*nC1 (as all number are different in contributing to achieving the target \\nEx: [1,1,1,1,1,3,3,3,4,4,4,4], target=8)  Case:{1,3,4}\\nalso why i am writing this condition (i < j && j < k) because so that you don\\'t add \\nmore answers for cases like permuation of {2,3,4} -> {2,4,3} you just have \\nto add once only*/\\n\\n                else if (i<j && j < k)    \\n                    ans += freq[i] * freq[j] * freq[k];   //after simplfying nc1 you will get this\\n            }\\n        \\n        return (int)(ans % (1e9 + 7));  // taking modulo as mentioned in question\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n public int threeSumMulti(int[] arr, int target) {\\n       \\n    long[] freq = new long[101];  //This is freq array since number lies from [1,100]\\n        int max = 0;\\n        for (int a : arr) {\\n            freq[a]++;\\n            max = Math.max(max,a);\\n        }\\n        \\n        long ans = 0;\\n        for (int i = 0; i <= max; i++)\\n            for (int j = i; j <= max; j++) {\\n                \\n                int k = target - i - j;  //as (i+j+k==target)\\n                \\n                if(k<0 || k>100)  //to avoid index out of bound in freqArray\\n                    continue;\\n                \\n    /*nC3 (as all same numbers able to meet the target \\n\\tEx: arr [1,1,1,1,1,1,1] , target=3)  Case:{1,1,1} */\\n\\t\\n           if (i == j && j == k)  \\n    ans += freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6; \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t//after simplyfying nc3 you will get this \\n                \\n /*nC2 (as one number is different and 2 are same in contributing to achieve the \\n target Ex: [1,1,1,1,1,2,2,2,2], target = 5) Case:{1,2,2}*/\\n                \\n                else if (i == j && j != k)   \\n            ans += freq[i] * (freq[i] - 1) / 2 * freq[k];  \\n\\t\\t\\t\\n\\t//after simplfying nc2 you will get this * different ones freq have to multiply\\n                \\n/*nC1 (as all number are different in contributing to achieving the target \\nEx: [1,1,1,1,1,3,3,3,4,4,4,4], target=8)  Case:{1,3,4}\\nalso why i am writing this condition (i < j && j < k) because so that you don\\'t add \\nmore answers for cases like permuation of {2,3,4} -> {2,4,3} you just have \\nto add once only*/\\n\\n                else if (i<j && j < k)    \\n                    ans += freq[i] * freq[j] * freq[k];   //after simplfying nc1 you will get this\\n            }\\n        \\n        return (int)(ans % (1e9 + 7));  // taking modulo as mentioned in question\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919148,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>&A, int t) {\\n        int n = A.size();\\n        sort(A.begin(),A.end());\\n        int total = 0; \\n        int i = 0;\\n        int mod = 1e9 + 7;\\n        while(i < n - 2)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n            while(l < r)\\n            {\\n                int sum = A[i] + A[l] + A[r];\\n                if(sum == t)\\n                {\\n                    if(A[l] == A[r])\\n                    {\\n                        int n1 = r - l + 1;\\n                        total += ((n1) * (n1 - 1)) / 2;\\n                        total %= mod;\\n                        break;\\n                    }\\n                    l++;\\n                    r--;\\n                    int cl = 1;\\n                    int cr = 1;\\n                    \\n                    while(l <=  r and A[l] == A[l - 1])\\n                    {\\n                        l++;\\n                        cl++;\\n                    }\\n                    while(l <= r and A[r] == A[r + 1])\\n                    {\\n                        r--;\\n                        cr++;\\n                    } \\n                    total += cr * cl;\\n                    total %= mod;\\n                    \\n                }\\n                else if(sum > t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            i++;\\n        }\\n        return total;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>&A, int t) {\\n        int n = A.size();\\n        sort(A.begin(),A.end());\\n        int total = 0; \\n        int i = 0;\\n        int mod = 1e9 + 7;\\n        while(i < n - 2)\\n        {\\n            int l = i + 1;\\n            int r = n - 1;\\n            while(l < r)\\n            {\\n                int sum = A[i] + A[l] + A[r];\\n                if(sum == t)\\n                {\\n                    if(A[l] == A[r])\\n                    {\\n                        int n1 = r - l + 1;\\n                        total += ((n1) * (n1 - 1)) / 2;\\n                        total %= mod;\\n                        break;\\n                    }\\n                    l++;\\n                    r--;\\n                    int cl = 1;\\n                    int cr = 1;\\n                    \\n                    while(l <=  r and A[l] == A[l - 1])\\n                    {\\n                        l++;\\n                        cl++;\\n                    }\\n                    while(l <= r and A[r] == A[r + 1])\\n                    {\\n                        r--;\\n                        cr++;\\n                    } \\n                    total += cr * cl;\\n                    total %= mod;\\n                    \\n                }\\n                else if(sum > t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            i++;\\n        }\\n        return total;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919138,
                "title": "clean-simple-short-code-with-explanation-and-code-comments-o-n-2-tc-o-n-sc",
                "content": "**IDEA** : populate the hashmap with the `[number,frequency_of_number]` and in every loop we try to find `j` in the hashmap (`i` and `k` are pointed by the for loop pointers). Note that the loop direction is used as right to left to ensure the ordering of elements is i < j < k . \\n\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        Map<Integer,Integer>hm = new HashMap<>();\\n        long count=0;\\n\\t\\t// so if the code is at a position as shown - then we try to find `j` in map (which is = { {2:3} , {5:1} , {1:1} , {4:1})\\n                                              //           (i)                  (k)\\n        for(int k=arr.length-1;k>=0;k--){     // [ 1 ,2, 2, 3, 4, 5, 2, 1, 2, 2, 7, 3 , 4]\\n            hm.clear();\\n            for(int i=k-1;i>=0;i--){\\n                int toFind = target-arr[k]-arr[i];\\n                if(hm.containsKey(toFind))\\n                    count=(count + hm.get(toFind))%1000000007;\\n                hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            }\\n        }\\n        \\n        return (int)count;\\n}\\n\\t\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        \\n        Map<Integer,Integer>hm = new HashMap<>();\\n        long count=0;\\n\\t\\t// so if the code is at a position as shown - then we try to find `j` in map (which is = { {2:3} , {5:1} , {1:1} , {4:1})\\n                                              //           (i)                  (k)\\n        for(int k=arr.length-1;k>=0;k--){     // [ 1 ,2, 2, 3, 4, 5, 2, 1, 2, 2, 7, 3 , 4]\\n            hm.clear();\\n            for(int i=k-1;i>=0;i--){\\n                int toFind = target-arr[k]-arr[i];\\n                if(hm.containsKey(toFind))\\n                    count=(count + hm.get(toFind))%1000000007;\\n                hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            }\\n        }\\n        \\n        return (int)count;\\n}\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919098,
                "title": "three-pointer-approach-with-comments-for-understanding",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        //answer is long bcz we may cross beyond int value range limit\\n        long answer = 0;\\n        \\n        //mod is used here as per question to avoid answer overflow\\n        long mod = 1000000007;\\n        Arrays.sort(arr);\\n        \\n        //We are using 3 pointer technique here, take 1st element subtract with target and\\n        //do a two pointer approach to find the triplet with new target to find (target-arr[i]) \\n        \\n        for(int i=0;i<arr.length;i++){\\n            \\n            //value to find after subtracting\\n            int findValue = target - arr[i];\\n            \\n            //we started with i, so our range should start from i+1\\n            int j = i+1;\\n            int k = arr.length-1;\\n            \\n            while(j<k){\\n                \\n                //move pointers based on sum value\\n                if(arr[j]+arr[k]<findValue)\\n                    j++;\\n                \\n                else if(arr[j]+arr[k]>findValue)\\n                    k--;\\n                \\n                //if sum equals to target, check whether both values are same or not\\n                else if(arr[j]!=arr[k]){\\n                    \\n                    //if not, lets start counting whether there are duplicates of a[j] && a[k]\\n                    int leftNumCount = 1, rightNumCount=1;\\n                    \\n                    \\n                    //count leftNum a[j]\\n                    while(j+1<k && arr[j]==arr[j+1]){\\n                        leftNumCount++;\\n                        j++;\\n                    }\\n                    \\n                    ////count rightNum a[k]\\n                    while(k-1>j && arr[k]==arr[k-1]){\\n                        rightNumCount++;\\n                        k--;\\n                    }\\n                    \\n                    //calculate the answer and find mod of it as per question\\n                    answer = answer + (rightNumCount * leftNumCount);\\n                    answer = answer%mod;\\n                    \\n                    //move both pointers\\n                    j++;\\n                    k--;\\n                }\\n                \\n                //if both values are same, available combination should be\\n                // n*(n+1)/2\\n                // here n is (k-j)\\n                else\\n                {\\n                    answer = answer + (k-j)*(k-j+1)/2;\\n                    answer = answer%mod;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int) answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        \\n        //answer is long bcz we may cross beyond int value range limit\\n        long answer = 0;\\n        \\n        //mod is used here as per question to avoid answer overflow\\n        long mod = 1000000007;\\n        Arrays.sort(arr);\\n        \\n        //We are using 3 pointer technique here, take 1st element subtract with target and\\n        //do a two pointer approach to find the triplet with new target to find (target-arr[i]) \\n        \\n        for(int i=0;i<arr.length;i++){\\n            \\n            //value to find after subtracting\\n            int findValue = target - arr[i];\\n            \\n            //we started with i, so our range should start from i+1\\n            int j = i+1;\\n            int k = arr.length-1;\\n            \\n            while(j<k){\\n                \\n                //move pointers based on sum value\\n                if(arr[j]+arr[k]<findValue)\\n                    j++;\\n                \\n                else if(arr[j]+arr[k]>findValue)\\n                    k--;\\n                \\n                //if sum equals to target, check whether both values are same or not\\n                else if(arr[j]!=arr[k]){\\n                    \\n                    //if not, lets start counting whether there are duplicates of a[j] && a[k]\\n                    int leftNumCount = 1, rightNumCount=1;\\n                    \\n                    \\n                    //count leftNum a[j]\\n                    while(j+1<k && arr[j]==arr[j+1]){\\n                        leftNumCount++;\\n                        j++;\\n                    }\\n                    \\n                    ////count rightNum a[k]\\n                    while(k-1>j && arr[k]==arr[k-1]){\\n                        rightNumCount++;\\n                        k--;\\n                    }\\n                    \\n                    //calculate the answer and find mod of it as per question\\n                    answer = answer + (rightNumCount * leftNumCount);\\n                    answer = answer%mod;\\n                    \\n                    //move both pointers\\n                    j++;\\n                    k--;\\n                }\\n                \\n                //if both values are same, available combination should be\\n                // n*(n+1)/2\\n                // here n is (k-j)\\n                else\\n                {\\n                    answer = answer + (k-j)*(k-j+1)/2;\\n                    answer = answer%mod;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int) answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919044,
                "title": "easy-and-simple-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumMulti = function(arr, target) {\\n    let count=0\\n    arr.sort((a,b)=>a-b)\\n    for(let i=0;i<arr.length-2;i++){\\n        let j=i+1,k=arr.length-1\\n        while(j<k){\\n            let sum=arr[i]+arr[j]+arr[k]\\n            if(sum<target){\\n                j++\\n            }\\n            else if(sum>target){\\n                k--\\n            }\\n            else{\\n                if(arr[j]!==arr[k]){\\n                    let j1=j,k1=k\\n                    while(arr[j]===arr[j1]){\\n                        j1++\\n                    }\\n                    while(arr[k]===arr[k1]){\\n                        k1--\\n                    }\\n                    count+=((j1-j)*(k-k1))\\n                    j=j1\\n                    k=k1 \\n                }\\n                else{\\n                    for(let n=1;n<=k-j;n++){\\n                        count+=n\\n                    }\\n                    break\\n                }              \\n            }\\n        }\\n    }\\n    return count% (10**9 + 7)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumMulti = function(arr, target) {\\n    let count=0\\n    arr.sort((a,b)=>a-b)\\n    for(let i=0;i<arr.length-2;i++){\\n        let j=i+1,k=arr.length-1\\n        while(j<k){\\n            let sum=arr[i]+arr[j]+arr[k]\\n            if(sum<target){\\n                j++\\n            }\\n            else if(sum>target){\\n                k--\\n            }\\n            else{\\n                if(arr[j]!==arr[k]){\\n                    let j1=j,k1=k\\n                    while(arr[j]===arr[j1]){\\n                        j1++\\n                    }\\n                    while(arr[k]===arr[k1]){\\n                        k1--\\n                    }\\n                    count+=((j1-j)*(k-k1))\\n                    j=j1\\n                    k=k1 \\n                }\\n                else{\\n                    for(let n=1;n<=k-j;n++){\\n                        count+=n\\n                    }\\n                    break\\n                }              \\n            }\\n        }\\n    }\\n    return count% (10**9 + 7)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919004,
                "title": "java-easy-solution-in-o-n",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        long result = 0;\\n        long count[] = new long[101];\\n        long mod = 1000000007;\\n\\t\\t\\n\\t\\t//Couting the occurrence of each number\\n        for(int i: arr) count[i]++;\\n        \\n        for(int i=0;i<101;i++){\\n            for(int j=i;j<101;j++){\\n                int k = target - i -j;\\n                if(k<0 || k>100)\\n                    continue;\\n\\t\\t\\t\\t// if all number are same than use nC3\\n                if(i==j && j==k){\\n                    result += (count[i]*(count[i]-1)*(count[i]-2))/6;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if first two are same than use nC2 * occurence of k\\n                else if(i==j && j!=k){\\n                    result += ((count[i]*(count[i]-1))/2)*count[k];\\n                }\\n\\t\\t\\t\\t//Last condition if all number ar different\\n\\t\\t\\t\\telse if(i<j && j<k){\\n                    result += (count[i]*count[j]*count[k]);\\n                }\\n                result %= mod;\\n            }\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919002,
                "title": "python-3sum-tweak-o-1-space",
                "content": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(len(arr)-2):\\n            low = i+1\\n            high = len(arr)-1\\n            while(low<high):\\n                cur = arr[i] + arr[low] + arr[high]\\n                if(cur==target):\\n                    if(arr[low]!=arr[high]):\\n                        multi_i = 1\\n                        multi_j = 1\\n                        while(low+1<high and arr[low]==arr[low+1]):\\n                            multi_i += 1\\n                            low += 1\\n                        while(low<high-1 and arr[high]==arr[high-1]):\\n                            multi_j += 1\\n                            high -= 1\\n                        count += (multi_i*multi_j) \\n                    else:\\n                        rep = high-low\\n                        count += (rep*(rep+1))//2\\n                        break\\n                    low+=1\\n                    high-=1\\n                elif(cur<target):\\n                    low+=1\\n                else:\\n                    high-=1\\n        return count%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        count = 0\\n        for i in range(len(arr)-2):\\n            low = i+1\\n            high = len(arr)-1\\n            while(low<high):\\n                cur = arr[i] + arr[low] + arr[high]\\n                if(cur==target):\\n                    if(arr[low]!=arr[high]):\\n                        multi_i = 1\\n                        multi_j = 1\\n                        while(low+1<high and arr[low]==arr[low+1]):\\n                            multi_i += 1\\n                            low += 1\\n                        while(low<high-1 and arr[high]==arr[high-1]):\\n                            multi_j += 1\\n                            high -= 1\\n                        count += (multi_i*multi_j) \\n                    else:\\n                        rep = high-low\\n                        count += (rep*(rep+1))//2\\n                        break\\n                    low+=1\\n                    high-=1\\n                elif(cur<target):\\n                    low+=1\\n                else:\\n                    high-=1\\n        return count%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918988,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\npublic int threeSumMulti(int[] a, int t) {\\n        long b[]=new long[101];\\n        for(int k:a)\\n        {\\n            b[k]++;\\n        }\\n        long c=0,s=1000000007;\\n        for(int i=0;i<=100;i++)\\n        {\\n            for(int j=i;j<=100;j++)\\n            {\\n                int k=t-i-j;\\n                if(k<0||k>100)\\n                    continue;\\n                if(i==j&&j==k)\\n                {\\n                    c+=b[i]*(b[i]-1)*(b[i]-2)/6;\\n                }\\n                else if(i==j&&j!=k)\\n                {\\n                    c+=b[i]*(b[i]-1)/2*b[k];\\n                }\\n                else if(i<j&&j<k)\\n                {\\n                    c+=b[i]*b[j]*b[k];\\n                }\\n            }\\n        }\\n        return (int)(c%s);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "class Solution {\\npublic int threeSumMulti(int[] a, int t) {\\n        long b[]=new long[101];\\n        for(int k:a)\\n        {\\n            b[k]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1918974,
                "title": "comprehensive-explanation-in-comments-c-two-pointer-approach",
                "content": "Comments are sometimes the best way to understand a program, as they explain just what each line in the program does.\\n\\nHere, we use \\n* the [Two Pointers](https://leetcode.com/tag/two-pointers/) technique (used in [Two Sum problem](https://leetcode.com/problems/two-sum/)) \\n* to solve this Three Sum problem\\n* while taking care of duplicates!\\n\\n**C++ solution:**\\n\\n**1. With comments:**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n\\t\\t// Can\\'t make a 3-sum with less than two numbers \\uD83D\\uDE05 \\n        if (n <= 2) return -1;\\n        \\n        // A neat trick to write numbers with seperator\\n        // is to use a tick (\\') between digits\\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        \\n        // sort it, so that we can apply our \\n\\t\\t// binary-search inspired two-pointers technique\\n        sort(arr.begin(), arr.end());\\n        \\n        // Binary search works for 2-sum problems\\n        // So how do we handle 3-sum problem ?\\n        // the *third-sum* integer is basically hidden in the target\\n        // because the new target is target - c\\n        // given that target = a + b + c\\n        // Now we only need to find a and b to satisfy\\n        // a + b = target - c\\n        // So here we go\\n        for (int i = 0; i < n; i++) {\\n            \\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n            \\n            // once we find our target T\\n            // the problem has been reduced to 2-sum problem\\n            // But lookout for unique cases!\\n            // because this is not just a 3-sum problem, \\n            // it\\'s a 3-sum with multiplicity problem,\\n            // which means there are multiple numbers which can give a 3-sum\\n            // also the numbers could be repeated, so we gotta handle that too!\\n            // Don\\'t worry though, there are just 4 cases:\\n            while (j < k) {\\n                \\n                // CASE 1\\uFE0F\\u20E3:\\n                // a + b < target - c\\n                // --OR--\\n                // a + b < T\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                \\n                // CASE 2\\uFE0F\\u20E3:\\n                // a + b > target - c\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                \\n                // CASE 3\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray!)\\n                // BUT! a != b\\n                // Also, since duplicate numbers are present, \\n                // we need to count the duplicates a and b too\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    \\n                    // count duplicate \\'a\\'s\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    // count duplicate \\'b\\'s\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    // the total number of \\'a\\'s and \\'b\\'s which\\n                    // add up to \\'target-c\\' is equal to\\n                    // number_of_a * number_of_b\\n                    ans += left*right;\\n                    // MOD as per the question\\'s requirement\\n                    ans %= MOD;\\n                    j++;\\n                    k--;\\n                }\\n                \\n                // CASE 4\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray again!)\\n                // BUT! a = b\\n                // so we got to find how many times we can use\\n                // the duplicates a (or b) to get the sum \\'target-c\\'\\n                else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    \\n                    // break, because all combinations between j and k \\n                    // have been tried\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\\n\\n<br>\\n\\n**2. Without comments:**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\\n\\n<br>\\n\\nTime complexity: **O(n<sup>2</sup>)**\\nSpace complexity: **O(1)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n\\t\\t// Can\\'t make a 3-sum with less than two numbers \\uD83D\\uDE05 \\n        if (n <= 2) return -1;\\n        \\n        // A neat trick to write numbers with seperator\\n        // is to use a tick (\\') between digits\\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        \\n        // sort it, so that we can apply our \\n\\t\\t// binary-search inspired two-pointers technique\\n        sort(arr.begin(), arr.end());\\n        \\n        // Binary search works for 2-sum problems\\n        // So how do we handle 3-sum problem ?\\n        // the *third-sum* integer is basically hidden in the target\\n        // because the new target is target - c\\n        // given that target = a + b + c\\n        // Now we only need to find a and b to satisfy\\n        // a + b = target - c\\n        // So here we go\\n        for (int i = 0; i < n; i++) {\\n            \\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n            \\n            // once we find our target T\\n            // the problem has been reduced to 2-sum problem\\n            // But lookout for unique cases!\\n            // because this is not just a 3-sum problem, \\n            // it\\'s a 3-sum with multiplicity problem,\\n            // which means there are multiple numbers which can give a 3-sum\\n            // also the numbers could be repeated, so we gotta handle that too!\\n            // Don\\'t worry though, there are just 4 cases:\\n            while (j < k) {\\n                \\n                // CASE 1\\uFE0F\\u20E3:\\n                // a + b < target - c\\n                // --OR--\\n                // a + b < T\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                \\n                // CASE 2\\uFE0F\\u20E3:\\n                // a + b > target - c\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                \\n                // CASE 3\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray!)\\n                // BUT! a != b\\n                // Also, since duplicate numbers are present, \\n                // we need to count the duplicates a and b too\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    \\n                    // count duplicate \\'a\\'s\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    \\n                    // count duplicate \\'b\\'s\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    \\n                    // the total number of \\'a\\'s and \\'b\\'s which\\n                    // add up to \\'target-c\\' is equal to\\n                    // number_of_a * number_of_b\\n                    ans += left*right;\\n                    // MOD as per the question\\'s requirement\\n                    ans %= MOD;\\n                    j++;\\n                    k--;\\n                }\\n                \\n                // CASE 4\\uFE0F\\u20E3:\\n                // a + b = target - c (Hurray again!)\\n                // BUT! a = b\\n                // so we got to find how many times we can use\\n                // the duplicates a (or b) to get the sum \\'target-c\\'\\n                else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    \\n                    // break, because all combinations between j and k \\n                    // have been tried\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        if (n <= 2) return -1;\\n        \\n        int MOD = 1\\'000\\'000\\'007;\\n        long ans = 0;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            int T = target - arr[i];\\n            int j = i+1, k = n-1;\\n\\n            while (j < k) {\\n                if (arr[j] + arr[k] < T)\\n                    j++;\\n                else if (arr[j] + arr[k] > T)\\n                    k--;\\n                else if (arr[j] + arr[k] == T && arr[j] != arr[k]) {\\n                    \\n                    int left = 1, right = 1;\\n                    while (j+1 < k && arr[j] == arr[j+1]) {\\n                        left++;\\n                        j++;\\n                    }\\n                    while (k-1 > j && arr[k] == arr[k-1]) {\\n                        right++;\\n                        k--;\\n                    }\\n                    ans += left*right;\\n                    ans %= MOD;\\n                    j++, k--;\\n                } else if (arr[j] + arr[k] == T && arr[j] == arr[k]) {\\n                    \\n                    int M = (k-j+1) * (k-j) / 2;\\n                    ans += M;\\n                    ans %= MOD;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918954,
                "title": "simple-and-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD = 1e9+7;\\n        long ans = 0;\\n        vector<long> count(101, 0);\\n        for (int x : arr)    count[x]++;\\n\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k < 0 || k > 100)    continue;\\n                else if (i == j && j == k)        ans += (count[i] * (count[i] - 1) * (count[i] - 2) / 6);\\n                else if (i == j && j != k)   ans += ((count[i] * (count[i] - 1) / 2) * count[k]);\\n                else if (i < j && j < k)     ans += (count[i] * count[j] * count[k]);\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int MOD = 1e9+7;\\n        long ans = 0;\\n        vector<long> count(101, 0);\\n        for (int x : arr)    count[x]++;\\n\\n        for (int i = 0; i <= 100; i++) {\\n            for (int j = i; j <= 100; j++) {\\n                int k = target - i - j;\\n                if (k < 0 || k > 100)    continue;\\n                else if (i == j && j == k)        ans += (count[i] * (count[i] - 1) * (count[i] - 2) / 6);\\n                else if (i == j && j != k)   ans += ((count[i] * (count[i] - 1) / 2) * count[k]);\\n                else if (i < j && j < k)     ans += (count[i] * count[j] * count[k]);\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918944,
                "title": "why-getting-tle",
                "content": "I am experiencing this 4th time while problem solving that as per constraints my solution should pass but after submission it shows **TLE** for some cases.\\n\\nWeird thing is like it gives **TLE** on different cases after every new submission and on running code on those test cases in sample one it passes.\\n\\n**Plssss let me know if I am wrong in my observation of complexities of my soln.**\\n\\nBelow code for this problem :\\n\\n**Time Complexity (as per my inderstanding) : O(n^2*log(n))**\\n**and constraint is n <= 10^3**\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        // unordered_map<int,int> mp;\\n        int res = 0;\\n        int mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        // for(auto x : arr)\\n        //     mp[x]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int k = arr[i] + arr[j];\\n                int rq = target-k;\\n                \\n                int lb = lower_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                int ub = upper_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                \\n                if(lb == n)\\n                    continue;\\n                \\n                if(lb <= j)\\n                {\\n                    if(j < n-1 && arr[j+1] == rq)\\n                        lb = j+1;\\n                    else \\n                        continue;\\n                }\\n                \\n                res = (res%mod + (ub-lb)%mod)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        // unordered_map<int,int> mp;\\n        int res = 0;\\n        int mod = 1e9+7;\\n        sort(arr.begin(), arr.end());\\n        \\n        // for(auto x : arr)\\n        //     mp[x]++;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int k = arr[i] + arr[j];\\n                int rq = target-k;\\n                \\n                int lb = lower_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                int ub = upper_bound(arr.begin(), arr.end(), rq) - arr.begin();\\n                \\n                if(lb == n)\\n                    continue;\\n                \\n                if(lb <= j)\\n                {\\n                    if(j < n-1 && arr[j+1] == rq)\\n                        lb = j+1;\\n                    else \\n                        continue;\\n                }\\n                \\n                res = (res%mod + (ub-lb)%mod)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918917,
                "title": "java-o-n-2-solution",
                "content": "\\n\\n        \\n        int mod=1000000007;\\n        long ans=0;\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            int j=i+1,k=arr.length-1;\\n            while(j<k)\\n            {\\n                int tmp=arr[i]+arr[j]+arr[k];\\n                if(tmp==target)\\n                {\\n                    if(arr[j]==arr[k])\\n                    {\\n                        int n=k-j+1;\\n                        int m=n*(n-1);\\n                        m/=2;\\n                        ans+=m;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        int re=0,le=0,n=arr[j],m=arr[k];\\n                        while(j<=k &&arr[j]==n)\\n                        {\\n                            le++;\\n                            j++;\\n                        }\\n                        while(k>=j && m==arr[k])\\n                        {\\n                            re++;\\n                            k--;\\n                        }\\n                        int tmpans=re*le;\\n                        ans+=tmpans;\\n                    }\\n                }\\n                else if(tmp<target)\\n                {\\n                   j++; \\n                }\\n                else\\n                {\\n                    k--;\\n                }\\n            }\\n        }\\n        ans=ans%mod;\\n        return (int)ans;\\n \\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "\\n\\n        \\n        int mod=1000000007;\\n        long ans=0;\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length-2;i++)\\n        {\\n            int j=i+1,k=arr.length-1;\\n            while(j<k)\\n            {\\n                int tmp=arr[i]+arr[j]+arr[k];\\n                if(tmp==target)\\n                {\\n                    if(arr[j]==arr[k])\\n                    {\\n                        int n=k-j+1;\\n                        int m=n*(n-1);\\n                        m/=2;\\n                        ans+=m;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        int re=0,le=0,n=arr[j],m=arr[k];\\n                        while(j<=k &&arr[j]==n)\\n                        {\\n                            le++;\\n                            j++;\\n                        }\\n                        while(k>=j && m==arr[k])\\n                        {\\n                            re++;\\n                            k--;\\n                        }\\n                        int tmpans=re*le;\\n                        ans+=tmpans;\\n                    }\\n                }\\n                else if(tmp<target)\\n                {\\n                   j++; \\n                }\\n                else\\n                {\\n                    k--;\\n                }\\n            }\\n        }\\n        ans=ans%mod;\\n        return (int)ans;\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1918904,
                "title": "python-hashmap-traveersing",
                "content": "```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        count=0\\n        result=0\\n        mod=10**9+7\\n        for i in range(len(arr)):\\n            hashmap={}\\n            for j in range(i+1,len(arr)):\\n                k=target-(arr[i]+arr[j])\\n                if(k>=0 and k<=100 and k in hashmap ):\\n                    result+=hashmap[k]\\n                    result%=mod\\n                if(arr[j] not in hashmap):\\n                    hashmap[arr[j]]=0\\n                hashmap[arr[j]]+=1\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef threeSumMulti(self, arr: List[int], target: int) -> int:\\n        count=0\\n        result=0\\n        mod=10**9+7\\n        for i in range(len(arr)):\\n            hashmap={}\\n            for j in range(i+1,len(arr)):\\n                k=target-(arr[i]+arr[j])\\n                if(k>=0 and k<=100 and k in hashmap ):\\n                    result+=hashmap[k]\\n                    result%=mod\\n                if(arr[j] not in hashmap):\\n                    hashmap[arr[j]]=0\\n                hashmap[arr[j]]+=1\\n                    \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1918790,
                "title": "beginner-friendly-two-pointer-solution",
                "content": "Steps:\\n1) Sort the given array to use two pointer approach. We keep the first element fixed and then find the other two using two-pointer.\\n2) When we find the left and right pointer which matches our target requirement, there can be two cases: i) Both the left and right pointers are holding the same array values\\n          ii) Left and right hold unique values.\\n3) For case (i), we just need to count the number of same values and use the combination formula of nC2 to get the formula, (ctr*(ctr-1))/2\\n4) For case (ii), simply count the number of same left values going left to right, and same right values moving right to left. The product of those gives the number of possible combinations.\\n```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());//Sort the array to use the two pointer approach\\n        const int modulo = 1000000007;\\n        long long count = 0;\\n        for(int i = 0;i < arr.size()-2;i++){\\n            int current = arr[i]; //Pick a first value and then other 2 values using 2-pointer\\n            int left = i+1;\\n            int right = arr.size()-1;\\n            while(left<right){\\n                if((arr[left]+arr[right])>(target-current))\\n                    right--;\\n                else if((arr[left]+arr[right])<(target-current))\\n                    left++;\\n                else{\\n                    //There are two cases when we find the two values\\n                    if(arr[left]==arr[right]){//Considering both left and right arr values are same\\n                        int ctr = 0;\\n                        while(left<=right)\\n                            left++,ctr++;//Counting the total number of elements\\n                        long long ans = (ctr*(ctr-1))/2;//Derived formula from nC2-combinations\\n                        count+=(ans%modulo);\\n                    }\\n                    else{//Left and right values are unique here\\n                    int leftCounter = 1;//Count the same left values\\n                    int rightCounter = 1;//Count the same right values\\n                    while(left+1<right && arr[left+1]==arr[left])\\n                       { \\n                        leftCounter++;\\n                        left++;\\n                       }\\n                    while(right-1>left && arr[right-1]==arr[right])\\n                       {\\n                        rightCounter++;\\n                        right--;\\n                        }\\n                    count+=((leftCounter*rightCounter)%modulo);//Multiply left and right counters to get total\\n                    left++;                                     //combinations possible\\n                    }    \\n                 \\n                }\\n            }\\n        }\\n        return (int)(count%modulo);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());//Sort the array to use the two pointer approach\\n        const int modulo = 1000000007;\\n        long long count = 0;\\n        for(int i = 0;i < arr.size()-2;i++){\\n            int current = arr[i]; //Pick a first value and then other 2 values using 2-pointer\\n            int left = i+1;\\n            int right = arr.size()-1;\\n            while(left<right){\\n                if((arr[left]+arr[right])>(target-current))\\n                    right--;\\n                else if((arr[left]+arr[right])<(target-current))\\n                    left++;\\n                else{\\n                    //There are two cases when we find the two values\\n                    if(arr[left]==arr[right]){//Considering both left and right arr values are same\\n                        int ctr = 0;\\n                        while(left<=right)\\n                            left++,ctr++;//Counting the total number of elements\\n                        long long ans = (ctr*(ctr-1))/2;//Derived formula from nC2-combinations\\n                        count+=(ans%modulo);\\n                    }\\n                    else{//Left and right values are unique here\\n                    int leftCounter = 1;//Count the same left values\\n                    int rightCounter = 1;//Count the same right values\\n                    while(left+1<right && arr[left+1]==arr[left])\\n                       { \\n                        leftCounter++;\\n                        left++;\\n                       }\\n                    while(right-1>left && arr[right-1]==arr[right])\\n                       {\\n                        rightCounter++;\\n                        right--;\\n                        }\\n                    count+=((leftCounter*rightCounter)%modulo);//Multiply left and right counters to get total\\n                    left++;                                     //combinations possible\\n                    }    \\n                 \\n                }\\n            }\\n        }\\n        return (int)(count%modulo);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918739,
                "title": "lengthy-but-simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> st;\\n        unordered_map<int,int> mp;\\n        for(auto x: arr){\\n            mp[x]++;\\n        }\\n        getTriplets(st, arr, target);\\n        // for(auto x: st){\\n        //     cout<< x[0]<<\" \"<<x[1]<<\" \"<<x[2]<<endl;\\n        // }\\n        int ans = 0;\\n        for(auto x: st){\\n            int a = x[0];\\n            int b = x[1];\\n            int c = x[2];\\n            int temp;\\n            if(a==b and b==c ){\\n                temp = multiply(mp[a], mp[a]-1, mp[a]-2);\\n                \\n            }\\n            else if(a==b or b==c or a==c){\\n                if(a==b){\\n                    temp = multiply2(mp[a], mp[a]-1, mp[c]);\\n                    \\n                }\\n                else if(b==c){\\n                    temp = multiply2(mp[b], mp[b]-1, mp[a]);\\n                    \\n                }\\n                else{\\n                    temp = multiply2(mp[a], mp[a]-1, mp[b]);\\n                    \\n                }\\n            }\\n            else{\\n                temp = multiply3(mp[a], mp[b], mp[c]);\\n            }\\n            \\n            ans+=temp;\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n    \\n    void getTriplets(set<vector<int>> &st, vector<int> &arr, int target){\\n        int i = 0,j = 1,k = 2;\\n        int n = arr.size();\\n        while(i<=n-3){\\n            int val = arr[i];\\n            int newTarget = target - val;\\n            j = i+1;\\n            k = n-1;\\n            while(j<k){\\n                if(arr[k]+arr[j]==newTarget){\\n                    \\n                    st.insert({arr[i],arr[j],arr[k]});\\n                    skip_j(j, arr);\\n                    skip_k(k, arr);\\n                }\\n                else if(arr[k]+arr[j]<newTarget){\\n                    skip_j(j, arr);\\n                }\\n                else{\\n                    skip_k(k, arr);\\n                }\\n            }\\n            skip_j(i, arr);\\n        }\\n            \\n        \\n        \\n    }\\n    void skip_j(int &j, vector<int> &arr){\\n        int val = arr[j];\\n        int n = arr.size();\\n        while(j<n and arr[j]==val)j++;\\n    }\\n    void skip_k(int &k, vector<int> &arr){\\n        int val = arr[k];\\n        while(k>=0 and arr[k]==val)k--;\\n    }\\n    int multiply(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/6)%m;\\n    }\\n    int multiply2(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/2)%m;\\n    }int multiply3(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z))%m;\\n    }\\n    \\n   \\n};\\n```\\n\\n**Do upvote, it really helps !**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> st;\\n        unordered_map<int,int> mp;\\n        for(auto x: arr){\\n            mp[x]++;\\n        }\\n        getTriplets(st, arr, target);\\n        // for(auto x: st){\\n        //     cout<< x[0]<<\" \"<<x[1]<<\" \"<<x[2]<<endl;\\n        // }\\n        int ans = 0;\\n        for(auto x: st){\\n            int a = x[0];\\n            int b = x[1];\\n            int c = x[2];\\n            int temp;\\n            if(a==b and b==c ){\\n                temp = multiply(mp[a], mp[a]-1, mp[a]-2);\\n                \\n            }\\n            else if(a==b or b==c or a==c){\\n                if(a==b){\\n                    temp = multiply2(mp[a], mp[a]-1, mp[c]);\\n                    \\n                }\\n                else if(b==c){\\n                    temp = multiply2(mp[b], mp[b]-1, mp[a]);\\n                    \\n                }\\n                else{\\n                    temp = multiply2(mp[a], mp[a]-1, mp[b]);\\n                    \\n                }\\n            }\\n            else{\\n                temp = multiply3(mp[a], mp[b], mp[c]);\\n            }\\n            \\n            ans+=temp;\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n    \\n    void getTriplets(set<vector<int>> &st, vector<int> &arr, int target){\\n        int i = 0,j = 1,k = 2;\\n        int n = arr.size();\\n        while(i<=n-3){\\n            int val = arr[i];\\n            int newTarget = target - val;\\n            j = i+1;\\n            k = n-1;\\n            while(j<k){\\n                if(arr[k]+arr[j]==newTarget){\\n                    \\n                    st.insert({arr[i],arr[j],arr[k]});\\n                    skip_j(j, arr);\\n                    skip_k(k, arr);\\n                }\\n                else if(arr[k]+arr[j]<newTarget){\\n                    skip_j(j, arr);\\n                }\\n                else{\\n                    skip_k(k, arr);\\n                }\\n            }\\n            skip_j(i, arr);\\n        }\\n            \\n        \\n        \\n    }\\n    void skip_j(int &j, vector<int> &arr){\\n        int val = arr[j];\\n        int n = arr.size();\\n        while(j<n and arr[j]==val)j++;\\n    }\\n    void skip_k(int &k, vector<int> &arr){\\n        int val = arr[k];\\n        while(k>=0 and arr[k]==val)k--;\\n    }\\n    int multiply(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/6)%m;\\n    }\\n    int multiply2(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z)/2)%m;\\n    }int multiply3(int a, int b, int c){\\n        long long int x = a, y = b, z = c;\\n        \\n        return ((x*y*z))%m;\\n    }\\n    \\n   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1918734,
                "title": "remembering-class-11th-chapter-p-c-o-n-101-101",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        // TC - O(n + 101*101) SC - O(101)\\n        long ans = 0;\\n        int MOD = 1_000_000_007;\\n        long[] c = new long[101];\\n        for(int i : arr) c[i]++;  // count occurrences \\n        \\n        for(int i = 0; i < 101; i++) {\\n            for(int j = i; j < 101; j++) {\\n                int k = target - i - j;\\n                if(k < 0 || k > 100) continue;\\n                if(i == j && j == k) \\n                    ans += (c[i] * (c[i] - 1) * (c[i] - 2) / 6); // nC3\\n                else if(i == j && j != k)  \\n                    ans += (c[i] * (c[i] - 1) / 2) * c[k]; // (nC2)*(nC1)\\n                else if(i < j && j < k) \\n                    ans += (c[i] * c[j] * c[k]);    // (nC1)(nC1)(nC1)\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        // TC - O(n + 101*101) SC - O(101)\\n        long ans = 0;\\n        int MOD = 1_000_000_007;\\n        long[] c = new long[101];\\n        for(int i : arr) c[i]++;  // count occurrences \\n        \\n        for(int i = 0; i < 101; i++) {\\n            for(int j = i; j < 101; j++) {\\n                int k = target - i - j;\\n                if(k < 0 || k > 100) continue;\\n                if(i == j && j == k) \\n                    ans += (c[i] * (c[i] - 1) * (c[i] - 2) / 6); // nC3\\n                else if(i == j && j != k)  \\n                    ans += (c[i] * (c[i] - 1) / 2) * c[k]; // (nC2)*(nC1)\\n                else if(i < j && j < k) \\n                    ans += (c[i] * c[j] * c[k]);    // (nC1)(nC1)(nC1)\\n            }\\n        }\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918701,
                "title": "java-o-n-2",
                "content": "\\n```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        final int MAX = 1_000_000_007;\\n        int[] ijsum = new int[301];\\n        int ans = 0;\\n        \\n        for (int j = n - 2; j > 0; j--) {\\n            if (target >= arr[j + 1]) ijsum[target - arr[j + 1]]++;\\n            for (int i = 0; i < j; i++) {\\n                ans += ijsum[arr[i] + arr[j]];\\n                ans %= MAX;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int threeSumMulti(int[] arr, int target) {\\n        int n = arr.length;\\n        final int MAX = 1_000_000_007;\\n        int[] ijsum = new int[301];\\n        int ans = 0;\\n        \\n        for (int j = n - 2; j > 0; j--) {\\n            if (target >= arr[j + 1]) ijsum[target - arr[j + 1]]++;\\n            for (int i = 0; i < j; i++) {\\n                ans += ijsum[arr[i] + arr[j]];\\n                ans %= MAX;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918697,
                "title": "python-dfs-with-memoization",
                "content": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        @lru_cache(None)\\n        def dfs(i, k, t):\\n            if k == 0 and t == 0:\\n                    return 1\\n            if k == 0 and t != 0 or i == len(arr):\\n                return 0\\n            return (dfs(i+1, k, t) + (dfs(i+1, k-1, t-arr[i]) if t >= arr[i] else 0))%(10**9+7)\\n        return dfs(0, 3, target)\\n  ```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        @lru_cache(None)\\n        def dfs(i, k, t):\\n            if k == 0 and t == 0:\\n                    return 1\\n            if k == 0 and t != 0 or i == len(arr):\\n                return 0\\n            return (dfs(i+1, k, t) + (dfs(i+1, k-1, t-arr[i]) if t >= arr[i] else 0))%(10**9+7)\\n        return dfs(0, 3, target)\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1918661,
                "title": "c-less-memory-than-100-with-combination-solution",
                "content": "![image](https://assets.leetcode.com/users/images/6fe71f69-68a1-4e31-8d59-c1dc7da6b98b_1649218855.3043642.png)\\n\\n```\\nint countInArr(int *arr, int size, int n)\\n{\\n    int num = 0;\\n    for(int i = 0;i < size;i++)\\n    {\\n        if (arr[i] == n)\\n            num++;\\n    }\\n    return num;\\n}\\n\\nint threeSumMulti(int* arr, int arrSize, int target){\\n    long sum = 0;\\n    long a, b, c;\\n    \\n    for(int i = 0;i <= target;i++)\\n    {\\n        for(int j = i;j <= target;j++)\\n        {\\n            for(int k = j;k <= target;k++)\\n            {\\n                if (i + j + k == target)\\n                {\\n                    a = countInArr(arr, arrSize, i);\\n                    b = countInArr(arr, arrSize, j);\\n                    c = countInArr(arr, arrSize, k);\\n\\n                    if (a != 0 && b != 0 && c != 0)\\n                    {\\n                        if (i != j && i != k && j != k)\\n                            sum += a * b * c;\\n                        else if (i == j && j == k)\\n                            sum += (a * (a - 1) * (a - 2)) / 6;\\n\\n                        else if (i == j)\\n                            sum += ((a * (a - 1)) / 2) * c;\\n \\n                        else if (i == k)\\n                            sum += ((a * (a - 1)) / 2) * b;\\n\\n                        else if (j == k)\\n                            sum += ((b * (b - 1)) / 2) * a;\\n\\n                        sum = sum % 1000000007;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return (int)sum;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nint countInArr(int *arr, int size, int n)\\n{\\n    int num = 0;\\n    for(int i = 0;i < size;i++)\\n    {\\n        if (arr[i] == n)\\n            num++;\\n    }\\n    return num;\\n}\\n\\nint threeSumMulti(int* arr, int arrSize, int target){\\n    long sum = 0;\\n    long a, b, c;\\n    \\n    for(int i = 0;i <= target;i++)\\n    {\\n        for(int j = i;j <= target;j++)\\n        {\\n            for(int k = j;k <= target;k++)\\n            {\\n                if (i + j + k == target)\\n                {\\n                    a = countInArr(arr, arrSize, i);\\n                    b = countInArr(arr, arrSize, j);\\n                    c = countInArr(arr, arrSize, k);\\n\\n                    if (a != 0 && b != 0 && c != 0)\\n                    {\\n                        if (i != j && i != k && j != k)\\n                            sum += a * b * c;\\n                        else if (i == j && j == k)\\n                            sum += (a * (a - 1) * (a - 2)) / 6;\\n\\n                        else if (i == j)\\n                            sum += ((a * (a - 1)) / 2) * c;\\n \\n                        else if (i == k)\\n                            sum += ((a * (a - 1)) / 2) * b;\\n\\n                        else if (j == k)\\n                            sum += ((b * (b - 1)) / 2) * a;\\n\\n                        sum = sum % 1000000007;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return (int)sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918593,
                "title": "c-easy-understanding-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int result = 0;\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < arr.size() - 2; i++){\\n            \\n            int j = i + 1;\\n            int k = arr.size() - 1;\\n            \\n            while(j < k){\\n                \\n                if(arr[i] + arr[j] + arr[k] == target){\\n                    int j_num = 0;\\n                    int k_num = 0;\\n                    \\n                    if(arr[j] == arr[k]){\\n                        result = (result + (k - j)*(k + 1 - j)/2)%mod;\\n                        j = k;\\n                    }\\n                    \\n                    else{\\n                        while(arr[j] == arr[j + 1]){\\n                            j++;\\n                            j_num++;\\n                        }\\n                        j++;\\n                        j_num++;\\n                        \\n                        while(arr[k] == arr[k - 1]){\\n                            k--;\\n                            k_num++;\\n                        }\\n                        k--;\\n                        k_num++;\\n                        \\n                        result = (result + (j_num * k_num))%mod;\\n                    }\\n                }\\n                \\n                else if(arr[i] + arr[j] + arr[k] < target){\\n                    j++;\\n                }\\n                \\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        int result = 0;\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < arr.size() - 2; i++){\\n            \\n            int j = i + 1;\\n            int k = arr.size() - 1;\\n            \\n            while(j < k){\\n                \\n                if(arr[i] + arr[j] + arr[k] == target){\\n                    int j_num = 0;\\n                    int k_num = 0;\\n                    \\n                    if(arr[j] == arr[k]){\\n                        result = (result + (k - j)*(k + 1 - j)/2)%mod;\\n                        j = k;\\n                    }\\n                    \\n                    else{\\n                        while(arr[j] == arr[j + 1]){\\n                            j++;\\n                            j_num++;\\n                        }\\n                        j++;\\n                        j_num++;\\n                        \\n                        while(arr[k] == arr[k - 1]){\\n                            k--;\\n                            k_num++;\\n                        }\\n                        k--;\\n                        k_num++;\\n                        \\n                        result = (result + (j_num * k_num))%mod;\\n                    }\\n                }\\n                \\n                else if(arr[i] + arr[j] + arr[k] < target){\\n                    j++;\\n                }\\n                \\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918590,
                "title": "c-easy-solution-two-pointer-approach-o-1-space",
                "content": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int p1=i+1;\\n            int p2=n-1;\\n            int rem=target-arr[i];\\n            while(p1<p2){\\n                if(arr[p1]+arr[p2]<rem)\\n                    p1++;\\n                else if(arr[p1]+arr[p2]>rem)\\n                    p2--;\\n                else\\n                {\\n                   if(arr[p1]==arr[p2])\\n                   {\\n                       int l=p2-p1+1;\\n                       ans+=(l)*(l-1)/2;\\n                       break;\\n                   }\\n                    int v1=arr[p1];\\n                    int v2=arr[p2];\\n                    int c1=0,c2=0;\\n                    while(arr[p1]==v1)\\n                    {\\n                        p1++;\\n                        c1++;\\n                    }\\n                    while(arr[p2]==v2)\\n                    {\\n                        p2--;\\n                        c2++;\\n                    }\\n                    ans+=c1*c2;\\n                }\\n                    \\n            }\\n        }\\n        return ans%mod;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumMulti(vector<int>& arr, int target) {\\n        long mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int p1=i+1;\\n            int p2=n-1;\\n            int rem=target-arr[i];\\n            while(p1<p2){\\n                if(arr[p1]+arr[p2]<rem)\\n                    p1++;\\n                else if(arr[p1]+arr[p2]>rem)\\n                    p2--;\\n                else\\n                {\\n                   if(arr[p1]==arr[p2])\\n                   {\\n                       int l=p2-p1+1;\\n                       ans+=(l)*(l-1)/2;\\n                       break;\\n                   }\\n                    int v1=arr[p1];\\n                    int v2=arr[p2];\\n                    int c1=0,c2=0;\\n                    while(arr[p1]==v1)\\n                    {\\n                        p1++;\\n                        c1++;\\n                    }\\n                    while(arr[p2]==v2)\\n                    {\\n                        p2--;\\n                        c2++;\\n                    }\\n                    ans+=c1*c2;\\n                }\\n                    \\n            }\\n        }\\n        return ans%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918489,
                "title": "javascript-hashmap",
                "content": "```\\nvar threeSumMulti = function(arr, target) {\\n    let map={},count=0;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]]=[];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        for(let j=i+1;j<arr.length;j++){\\n            let a = arr[i]+arr[j];\\n            let x = target - a;\\n            if(map[x]!==undefined){\\n                let k = binarySearch(map[x],j);\\n                if(k!==-1){\\n                    let n = map[x].length-k;\\n                    count+=n;\\n                    count = count%1000000007;\\n                }\\n            }\\n        }\\n    }\\n    \\n    function binarySearch(arr,key){\\n        let start=0,end=arr.length-1,mid,ans=-1;\\n        while(start<=end){\\n            let mid = start + Math.floor((end-start)/2);\\n            if(arr[mid]>key){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumMulti = function(arr, target) {\\n    let map={},count=0;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]]=[];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    for(let i=0;i<arr.length;i++){\\n        for(let j=i+1;j<arr.length;j++){\\n            let a = arr[i]+arr[j];\\n            let x = target - a;\\n            if(map[x]!==undefined){\\n                let k = binarySearch(map[x],j);\\n                if(k!==-1){\\n                    let n = map[x].length-k;\\n                    count+=n;\\n                    count = count%1000000007;\\n                }\\n            }\\n        }\\n    }\\n    \\n    function binarySearch(arr,key){\\n        let start=0,end=arr.length-1,mid,ans=-1;\\n        while(start<=end){\\n            let mid = start + Math.floor((end-start)/2);\\n            if(arr[mid]>key){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918456,
                "title": "java-bucket-sort-navigate-the-middle-number-time-o-100-2",
                "content": "Define the 3 numbers: left <= mid <= right, left + mid + right = target\\n```\\n    public int threeSumMulti(int[] arr, int target) {\\n        int max = Math.min(100, target);\\n        int[] count = new int[101];\\n        for (int i : arr)\\n        \\tcount[i]++;\\n        long res = 0;\\n        for (int mid = 0; mid <= max; mid++)\\n        \\tfor (int left = 0, right = target - left - mid; left <= mid && right >= mid; left++, right--)\\n        \\t\\tif (right > max || count[left] == 0 || count[right] == 0)\\n        \\t\\t\\tcontinue;\\n        \\t\\telse if (left == right)\\n        \\t\\t\\tres += (long)count[mid] * (count[mid] - 1) * (count[mid] - 2) / 6 % 1000000007;\\n        \\t\\telse if (left == mid)\\n        \\t\\t\\tres += (long)count[right] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse if (right == mid)\\n        \\t\\t\\tres += (long)count[left] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse\\n        \\t\\t\\tres += (long)count[left] * count[mid] * count[right] % 1000000007;\\n        return (int)(res % 1000000007);\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "Define the 3 numbers: left <= mid <= right, left + mid + right = target\\n```\\n    public int threeSumMulti(int[] arr, int target) {\\n        int max = Math.min(100, target);\\n        int[] count = new int[101];\\n        for (int i : arr)\\n        \\tcount[i]++;\\n        long res = 0;\\n        for (int mid = 0; mid <= max; mid++)\\n        \\tfor (int left = 0, right = target - left - mid; left <= mid && right >= mid; left++, right--)\\n        \\t\\tif (right > max || count[left] == 0 || count[right] == 0)\\n        \\t\\t\\tcontinue;\\n        \\t\\telse if (left == right)\\n        \\t\\t\\tres += (long)count[mid] * (count[mid] - 1) * (count[mid] - 2) / 6 % 1000000007;\\n        \\t\\telse if (left == mid)\\n        \\t\\t\\tres += (long)count[right] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse if (right == mid)\\n        \\t\\t\\tres += (long)count[left] * count[mid] * (count[mid] - 1) / 2 % 1000000007;\\n        \\t\\telse\\n        \\t\\t\\tres += (long)count[left] * count[mid] * count[right] % 1000000007;\\n        return (int)(res % 1000000007);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1918436,
                "title": "c-solution-with-explanation",
                "content": "**Optimal Approach**\\n\\n1. We create unordered_map to store the frequency of sums ie. (arr[i] + arr[j]) [i != j]\\n2. We\\'ll iterate through the whole array entering two elements sum as key and \\n3. Whenever we get target - arr[i] in the map we store the mapping into result\\n4. arr[i] + arr[j] + arr[k] = target\\n=> (arr[i] + arr[j]) = (target - arr[k]) \\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Time - O(N^2)\\nSpace - O(1)**",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n        unordered_map<int, int> m;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < arr.size(); i++) {\\n            res = (res + m[target - arr[i]]) % mod;\\n            for (int j = 0; j < i; j++) {\\n                m[arr[i] + arr[j]]++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918426,
                "title": "java-easy-solution-using-map",
                "content": "\\'\\'\\' \\n class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }\\n        long ans=0l;\\n        for(int e1: map.keySet()){\\n            for(int e2: map.keySet()){\\n                int e3 = target-e1-e2;\\n                if(map.containsKey(e3)){\\n                    long freq1 = map.get(e1);\\n                    long freq2 = map.get(e2);\\n                    long freq3 = map.get(e3);\\n                    if(e1==e2 && e2==e3)\\n                    ans+=((freq1)*(freq2-1)*(freq3-2))/6;\\n                else if(e1==e2 && e1!=e3)\\n                    ans+=((freq1)*(freq2-1))/2*freq3;\\n                else if(e1<e2 && e2<e3)\\n                    ans+=freq1*freq2*freq3;\\n               \\n                }\\n               ans = ans%1000000007; \\n                \\n            }\\n             \\n        }\\n           return (int)ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int e : arr){\\n             long freq = map.getOrDefault(e,0l);\\n             map.put(e,freq+1l);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1918336,
                "title": "c-o-n-100-2-easy-to-understand",
                "content": "With i < j < k, we consider 4 case:\\n\\t+ i * 3 == target;\\n\\t+ i * 2 + j == target;\\n\\t+ i + j * 2 == target\\n\\t+ i + j + k == target;\\nBacause 0 <= arr[i] <= 100, we don\\'t need sort array.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint threeSumMulti(vector<int>& arr, int target) {\\n\\t\\t\\tvector<long long> map(105);\\n\\t\\t\\tfor(auto& i : arr) map[i]++;\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(int i = 0; i <= 100; i++) {\\n\\t\\t\\t\\tif(i * 3 == target)\\n\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1) * (map[i] - 2)) / 6;\\n\\t\\t\\t\\tfor(int j = i + 1; j <= 100 ; j++) {\\n\\t\\t\\t\\t\\tint k = target - i - j;\\n\\t\\t\\t\\t\\tif (target == i * 2 + j) \\n\\t\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1)) / 2 * map[j];\\n\\t\\t\\t\\t\\telse if (target == i + j * 2) \\n\\t\\t\\t\\t\\t\\tans += (map[j] * (map[j] - 1)) / 2 * map[i];\\n\\t\\t\\t\\t\\telse if (k > j && k <= 100) \\n\\t\\t\\t\\t\\t\\tans += map[i] * map[j] * map[k]; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans %= 1000000007;\\n\\t\\t\\t}\\n\\t\\t\\treturn int(ans);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint threeSumMulti(vector<int>& arr, int target) {\\n\\t\\t\\tvector<long long> map(105);\\n\\t\\t\\tfor(auto& i : arr) map[i]++;\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(int i = 0; i <= 100; i++) {\\n\\t\\t\\t\\tif(i * 3 == target)\\n\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1) * (map[i] - 2)) / 6;\\n\\t\\t\\t\\tfor(int j = i + 1; j <= 100 ; j++) {\\n\\t\\t\\t\\t\\tint k = target - i - j;\\n\\t\\t\\t\\t\\tif (target == i * 2 + j) \\n\\t\\t\\t\\t\\t\\tans += (map[i] * (map[i] - 1)) / 2 * map[j];\\n\\t\\t\\t\\t\\telse if (target == i + j * 2) \\n\\t\\t\\t\\t\\t\\tans += (map[j] * (map[j] - 1)) / 2 * map[i];\\n\\t\\t\\t\\t\\telse if (k > j && k <= 100) \\n\\t\\t\\t\\t\\t\\tans += map[i] * map[j] * map[k]; \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1824831,
                "title": "c-easy-solution-hashmap",
                "content": "class Solution {\\npublic:\\n    \\n\\tint threeSumMulti(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int c = 0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                c+=(m[target-nums[i]-nums[j]]);\\n            }\\n            m[nums[i]]++;\\n            c%=(1000000007);\\n        }\\n        return (c%1000000007);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint threeSumMulti(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int c = 0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                c+=(m[target-nums[i]-nums[j]]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1661663,
                "title": "java-easy-solution-3-sum",
                "content": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        long result=0;\\n        for(int i=0;i<arr.length-2;i++){\\n            int required=target-arr[i];\\n            int j=i+1;\\n            int k=arr.length-1;\\n            while(j<k){\\n                if(arr[j]+arr[k]==required){\\n                    int count1=1,count2=1;\\n                    if(arr[j]==arr[k]) {\\n                        long n=(k-j+1);\\n                        result+=(n*(n-1))/2;\\n                        break;\\n                    }\\n                    \\n                    while(j+1<k&&arr[j]==arr[j+1])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    while(k-1>j&&arr[k]==arr[k-1])\\n                    {\\n                        count2++;\\n                        k--;\\n                    }\\n                    j++;\\n                    k--;\\n                    result+=(count1*count2);\\n                }\\n                else if(arr[j]+arr[k]>required)  k--;\\n                else j++;\\n    \\n            } \\n          \\n            \\n        }\\n        return (int)(result%1_00_00_00_00_7);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumMulti(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        long result=0;\\n        for(int i=0;i<arr.length-2;i++){\\n            int required=target-arr[i];\\n            int j=i+1;\\n            int k=arr.length-1;\\n            while(j<k){\\n                if(arr[j]+arr[k]==required){\\n                    int count1=1,count2=1;\\n                    if(arr[j]==arr[k]) {\\n                        long n=(k-j+1);\\n                        result+=(n*(n-1))/2;\\n                        break;\\n                    }\\n                    \\n                    while(j+1<k&&arr[j]==arr[j+1])\\n                    {\\n                        count1++;\\n                        j++;\\n                    }\\n                    while(k-1>j&&arr[k]==arr[k-1])\\n                    {\\n                        count2++;\\n                        k--;\\n                    }\\n                    j++;\\n                    k--;\\n                    result+=(count1*count2);\\n                }\\n                else if(arr[j]+arr[k]>required)  k--;\\n                else j++;\\n    \\n            } \\n          \\n            \\n        }\\n        return (int)(result%1_00_00_00_00_7);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565648,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1570379,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1572249,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1576585,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 2016239,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1964151,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1897078,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-with-multiplicity/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Notes\n\n  \n**Approach 2:** Three Pointer\n\n  \n**Approach 3:** Counting with Cases\n\n  \n**Approach 4:** Adapt from Three Sum\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "demiurg2000",
                        "content": "Pretty much the title. If you say \\n\\ni < j < k\\n\\nthen 2, 2, 4 shouldn\\'t be a valid answer"
                    },
                    {
                        "username": "guilhermereisrbm",
                        "content": "this is not true, because 2,2,4 are the values, but i < j < k are indexes"
                    },
                    {
                        "username": "pranjalgururani",
                        "content": "Your solution will not be accepted if you are using an int to store the totals as the totals will get very large. Check this before you start to change your logic. Will save you a world of pain. :)"
                    },
                    {
                        "username": "kcshum703",
                        "content": "Seems a test case is wrong.\\n\\nFor inputting 3000 zeros, that is [0,0,0,0, ..., 0,0,0,0], with target 0, the correct answer should be a combination (3000, 3) = 4495501000. \\nBut the expected output of the test case is 495500972, which is possibly some upper bounds of variable/test cases environment. \\n\\n![image](https://assets.leetcode.com/users/images/ff39f24d-a987-4828-9e3d-4516551ac9c3_1649226296.9337702.png)\\n"
                    },
                    {
                        "username": "schajan",
                        "content": "Ran into the same problem, because I forgot to return the result mod 10^9 + 7"
                    },
                    {
                        "username": "rahulseetharaman",
                        "content": "My code fails the test case 39/72. \narr =\n`[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...]`\n\nOutput: 162167636\nExpected: 495500972\n\nAny idea what could be going wrong ?"
                    },
                    {
                        "username": "Rajat_Yadav",
                        "content": "Can Anyone tell me the Approach to solve this question as i am not able to visulize this problem!!Very Helpful"
                    },
                    {
                        "username": "vdas53073",
                        "content": "What giving TLE ? \\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int threeSumMulti(vector<int>& arr, int target) { \\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int target2 = (target - arr[i]);\\n            map<int,int>m;\\n            for(int j = i+1;j<arr.size();j++){\\n                int target3 =target2 -arr[j];\\n                if(m[target3] > 0){\\n                    \\n                    count = (count%mod + m[target3]%mod)%mod;\\n                }\\n                m[arr[j]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Difficulty of a Job Schedule",
        "question_content": "<p>You want to schedule a list of jobs in <code>d</code> days. Jobs are dependent (i.e To work on the <code>i<sup>th</sup></code> job, you have to finish all the jobs <code>j</code> where <code>0 &lt;= j &lt; i</code>).</p>\n\n<p>You have to finish <strong>at least</strong> one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the <code>d</code> days. The difficulty of a day is the maximum difficulty of a job done on that day.</p>\n\n<p>You are given an integer array <code>jobDifficulty</code> and an integer <code>d</code>. The difficulty of the <code>i<sup>th</sup></code> job is <code>jobDifficulty[i]</code>.</p>\n\n<p>Return <em>the minimum difficulty of a job schedule</em>. If you cannot find a schedule for the jobs return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/16/untitled.png\" style=\"width: 365px; height: 370px;\" />\n<pre>\n<strong>Input:</strong> jobDifficulty = [6,5,4,3,2,1], d = 2\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> jobDifficulty = [9,9,9], d = 4\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> jobDifficulty = [1,1,1], d = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The schedule is one job per day. total difficulty will be 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= jobDifficulty.length &lt;= 300</code></li>\n\t<li><code>0 &lt;= jobDifficulty[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= d &lt;= 10</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 490316,
                "title": "java-c-python3-dp-o-nd-solution",
                "content": "# Solution 1: Top-down DP with cache\\n`dfs` help find the the minimum difficulty\\nif start work at `i`th job with `d` days left.\\n\\nIf `d = 1`, only one day left, we have to do all jobs,\\nreturn the maximum difficulty of jobs.\\n\\nTime complexity `O(nnd)`\\nSpace complexity `O(nd)`\\n<br>\\n\\n**Java**\\nby @zea7ot\\n```java\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        final int N = jobDifficulty.length;\\n        if(N < D) return -1;\\n\\n        int[][] memo = new int[N][D + 1];\\n        for(int[] row : memo) Arrays.fill(row, -1);\\n\\n        return dfs(D, 0, jobDifficulty, memo);\\n    }\\n\\n    private int dfs(int d, int len, int[] jobDifficulty, int[][] memo){\\n        final int N = jobDifficulty.length;\\n        if(d == 0 && len == N) return 0;\\n        if(d == 0 || len == N) return Integer.MAX_VALUE;\\n        if(memo[len][d] != -1) return memo[len][d];\\n\\n        int curMax = jobDifficulty[len];\\n        int min = Integer.MAX_VALUE;\\n        for(int schedule = len; schedule < N; ++schedule){\\n            curMax = Math.max(curMax, jobDifficulty[schedule]);\\n            int temp = dfs(d - 1, schedule + 1, jobDifficulty, memo);\\n            if(temp != Integer.MAX_VALUE)\\n                min = Math.min(min, temp + curMax);\\n        }\\n\\n        return memo[len][d] = min;\\n    }\\n```\\n**Python3:**\\n```python\\nimport functools\\nclass Solution:\\n\\n    def minDifficulty(self, A, d):\\n        n = len(A)\\n        if n < d: return -1\\n\\n        @functools.lru_cache(None)\\n        def dfs(i, d):\\n            if d == 1:\\n                return max(A[i:])\\n            res, maxd = float(\\'inf\\'), 0\\n            for j in range(i, n - d + 1):\\n                maxd = max(maxd, A[j])\\n                res = min(res, maxd + dfs(j + 1, d - 1))\\n            return res\\n        return dfs(0, d)\\n```\\n<br>\\n\\n# Solution2: Bottom-up 2D DP\\nTime complexity `O(nnd)`\\nSpace complexity `O(nd)`\\n<br>\\n\\n**Java**\\nby @zea7ot\\n```java\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        final int N = jobDifficulty.length;\\n        if(N < D) return -1;\\n        int[][] dp = new int[D][N];\\n\\n        dp[0][0] = jobDifficulty[0];\\n        for(int j = 1; j < N; ++j){\\n            dp[0][j] = Math.max(jobDifficulty[j], dp[0][j - 1]);\\n        }\\n\\n        for(int d = 1; d < D; ++d){\\n            for(int len = d; len < N; ++len){\\n                int localMax = jobDifficulty[len];\\n                dp[d][len] = Integer.MAX_VALUE;\\n                for(int schedule = len; schedule >= d; --schedule){\\n                    localMax = Math.max(localMax, jobDifficulty[schedule]);\\n                    dp[d][len] = Math.min(dp[d][len], dp[d - 1][schedule - 1] + localMax);\\n                }\\n            }\\n        }\\n\\n        return dp[D - 1][N - 1];\\n    }\\n```\\n**Python2**\\n```py\\n    def minDifficulty(self, A, d):\\n        n, inf = len(A), float(\\'inf\\')\\n        dp = [[inf] * n + [0] for i in xrange(d + 1)]\\n        for d in xrange(1, d + 1):\\n            for i in xrange(n - d + 1):\\n                maxd = 0\\n                for j in xrange(i, n - d + 1):\\n                    maxd = max(maxd, A[j])\\n                    dp[d][i] = min(dp[d][i], maxd + dp[d - 1][j + 1])\\n        return dp[d][0] if dp[d][0] < inf else -1\\n```\\n<br>\\n\\n# Solution3: Bottom-up 1D DP\\nTime complexity `O(nnd)`\\nSpace complexity `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minDifficulty(int[] A, int D) {\\n        int n = A.length, maxd;\\n        if (n < D) return -1;\\n        int[] dp = new int[n + 1];\\n        for (int i = n - 1; i >= 0; --i)\\n            dp[i] = Math.max(dp[i + 1], A[i]);\\n        for (int d = 2; d <= D; ++d) {\\n            for (int i = 0; i <= n - d; ++i) {\\n                maxd = 0;\\n                dp[i] = Integer.MAX_VALUE;\\n                for (int j = i; j <= n - d; ++j) {\\n                    maxd = Math.max(maxd, A[j]);\\n                    dp[i] = Math.min(dp[i], maxd + dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\\n**C++**\\n```cpp\\n    int minDifficulty(vector<int>& A, int D) {\\n        int n = A.size(), inf = 1e9, maxd;\\n        if (n < D) return -1;\\n        vector<int> dp(n + 1, 1e9);\\n        dp[n] = 0;\\n        for (int d = 1; d <= D; ++d) {\\n            for (int i = 0; i <= n - d; ++i) {\\n                maxd = 0, dp[i] = inf;\\n                for (int j = i; j <= n - d; ++j) {\\n                    maxd = max(maxd, A[j]);\\n                    dp[i] = min(dp[i], maxd + dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\\n**Python2**\\n```py\\n    def minDifficulty(self, A, d):\\n        n, inf = len(A), float(\\'inf\\')\\n        if n < d: return -1\\n        dp = [inf] * n + [0]\\n        for d in xrange(1, d + 1):\\n            for i in xrange(n - d + 1):\\n                maxd, dp[i] = 0, inf\\n                for j in xrange(i, n - d + 1):\\n                    maxd = max(maxd, A[j])\\n                    dp[i] = min(dp[i], maxd + dp[j + 1])\\n        return dp[0]\\n```\\n<br>\\n\\n# Solution 4: Stack\\nTime `O(nd)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public int minDifficulty(int[] A, int D) {\\n        int n = A.length;\\n        if (n < D) return -1;\\n        int[] dp = new int[n], dp2 = new int[n], tmp;\\n        Arrays.fill(dp, 1000);\\n        Deque<Integer> stack = new ArrayDeque<Integer>();\\n\\n        for (int d = 0; d < D; ++d) {\\n            stack.clear();\\n            for (int i = d; i < n; i++) {\\n                dp2[i] = i > 0 ? dp[i - 1] + A[i] : A[i];\\n                while (!stack.isEmpty() && A[stack.peek()] <= A[i]) {\\n                    int j = stack.pop();\\n                    dp2[i] = Math.min(dp2[i], dp2[j] - A[j] + A[i]);\\n                }\\n                if (!stack.isEmpty()) {\\n                    dp2[i] = Math.min(dp2[i], dp2[stack.peek()]);\\n                }\\n                stack.push(i);\\n            }\\n            tmp = dp;\\n            dp = dp2;\\n            dp2 = tmp;\\n        }\\n        return dp[n - 1];\\n    }\\n```\\n**C++**\\n```cpp\\n    int minDifficulty(vector<int>& A, int D) {\\n        int n = A.size();\\n        if (n < D) return -1;\\n        vector<int> dp(n, 1000), dp2(n), stack;\\n        for (int d = 0; d < D; ++d) {\\n            stack.clear();\\n            for (int i = d; i < n; i++) {\\n                dp2[i] = i ? dp[i - 1] + A[i] : A[i];\\n                while (stack.size() && A[stack.back()] <= A[i]) {\\n                    int j = stack.back(); stack.pop_back();\\n                    dp2[i] = min(dp2[i], dp2[j] - A[j] + A[i]);\\n                }\\n                if (stack.size()) {\\n                    dp2[i] = min(dp2[i], dp2[stack.back()]);\\n                }\\n                stack.push_back(i);\\n            }\\n            swap(dp, dp2);\\n        }\\n        return dp[n - 1];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minDifficulty(self, A, d):\\n        n = len(A)\\n        if n < d: return -1\\n        dp, dp2 = [float(\\'inf\\')] * n, [0] * n\\n        for d in xrange(d):\\n            stack = []\\n            for i in xrange(d, n):\\n                dp2[i] = dp[i - 1] + A[i] if i else A[i]\\n                while stack and A[stack[-1]] <= A[i]:\\n                    j = stack.pop()\\n                    dp2[i] = min(dp2[i], dp2[j] - A[j] + A[i])\\n                if stack:\\n                    dp2[i] = min(dp2[i], dp2[stack[-1]])\\n                stack.append(i)\\n            dp, dp2 = dp2, dp\\n        return dp[-1]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        final int N = jobDifficulty.length;\\n        if(N < D) return -1;\\n\\n        int[][] memo = new int[N][D + 1];\\n        for(int[] row : memo) Arrays.fill(row, -1);\\n\\n        return dfs(D, 0, jobDifficulty, memo);\\n    }\\n\\n    private int dfs(int d, int len, int[] jobDifficulty, int[][] memo){\\n        final int N = jobDifficulty.length;\\n        if(d == 0 && len == N) return 0;\\n        if(d == 0 || len == N) return Integer.MAX_VALUE;\\n        if(memo[len][d] != -1) return memo[len][d];\\n\\n        int curMax = jobDifficulty[len];\\n        int min = Integer.MAX_VALUE;\\n        for(int schedule = len; schedule < N; ++schedule){\\n            curMax = Math.max(curMax, jobDifficulty[schedule]);\\n            int temp = dfs(d - 1, schedule + 1, jobDifficulty, memo);\\n            if(temp != Integer.MAX_VALUE)\\n                min = Math.min(min, temp + curMax);\\n        }\\n\\n        return memo[len][d] = min;\\n    }\\n```\n```python\\nimport functools\\nclass Solution:\\n\\n    def minDifficulty(self, A, d):\\n        n = len(A)\\n        if n < d: return -1\\n\\n        @functools.lru_cache(None)\\n        def dfs(i, d):\\n            if d == 1:\\n                return max(A[i:])\\n            res, maxd = float(\\'inf\\'), 0\\n            for j in range(i, n - d + 1):\\n                maxd = max(maxd, A[j])\\n                res = min(res, maxd + dfs(j + 1, d - 1))\\n            return res\\n        return dfs(0, d)\\n```\n```java\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        final int N = jobDifficulty.length;\\n        if(N < D) return -1;\\n        int[][] dp = new int[D][N];\\n\\n        dp[0][0] = jobDifficulty[0];\\n        for(int j = 1; j < N; ++j){\\n            dp[0][j] = Math.max(jobDifficulty[j], dp[0][j - 1]);\\n        }\\n\\n        for(int d = 1; d < D; ++d){\\n            for(int len = d; len < N; ++len){\\n                int localMax = jobDifficulty[len];\\n                dp[d][len] = Integer.MAX_VALUE;\\n                for(int schedule = len; schedule >= d; --schedule){\\n                    localMax = Math.max(localMax, jobDifficulty[schedule]);\\n                    dp[d][len] = Math.min(dp[d][len], dp[d - 1][schedule - 1] + localMax);\\n                }\\n            }\\n        }\\n\\n        return dp[D - 1][N - 1];\\n    }\\n```\n```py\\n    def minDifficulty(self, A, d):\\n        n, inf = len(A), float(\\'inf\\')\\n        dp = [[inf] * n + [0] for i in xrange(d + 1)]\\n        for d in xrange(1, d + 1):\\n            for i in xrange(n - d + 1):\\n                maxd = 0\\n                for j in xrange(i, n - d + 1):\\n                    maxd = max(maxd, A[j])\\n                    dp[d][i] = min(dp[d][i], maxd + dp[d - 1][j + 1])\\n        return dp[d][0] if dp[d][0] < inf else -1\\n```\n```java\\n    public int minDifficulty(int[] A, int D) {\\n        int n = A.length, maxd;\\n        if (n < D) return -1;\\n        int[] dp = new int[n + 1];\\n        for (int i = n - 1; i >= 0; --i)\\n            dp[i] = Math.max(dp[i + 1], A[i]);\\n        for (int d = 2; d <= D; ++d) {\\n            for (int i = 0; i <= n - d; ++i) {\\n                maxd = 0;\\n                dp[i] = Integer.MAX_VALUE;\\n                for (int j = i; j <= n - d; ++j) {\\n                    maxd = Math.max(maxd, A[j]);\\n                    dp[i] = Math.min(dp[i], maxd + dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\n```cpp\\n    int minDifficulty(vector<int>& A, int D) {\\n        int n = A.size(), inf = 1e9, maxd;\\n        if (n < D) return -1;\\n        vector<int> dp(n + 1, 1e9);\\n        dp[n] = 0;\\n        for (int d = 1; d <= D; ++d) {\\n            for (int i = 0; i <= n - d; ++i) {\\n                maxd = 0, dp[i] = inf;\\n                for (int j = i; j <= n - d; ++j) {\\n                    maxd = max(maxd, A[j]);\\n                    dp[i] = min(dp[i], maxd + dp[j + 1]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\n```py\\n    def minDifficulty(self, A, d):\\n        n, inf = len(A), float(\\'inf\\')\\n        if n < d: return -1\\n        dp = [inf] * n + [0]\\n        for d in xrange(1, d + 1):\\n            for i in xrange(n - d + 1):\\n                maxd, dp[i] = 0, inf\\n                for j in xrange(i, n - d + 1):\\n                    maxd = max(maxd, A[j])\\n                    dp[i] = min(dp[i], maxd + dp[j + 1])\\n        return dp[0]\\n```\n```java\\n    public int minDifficulty(int[] A, int D) {\\n        int n = A.length;\\n        if (n < D) return -1;\\n        int[] dp = new int[n], dp2 = new int[n], tmp;\\n        Arrays.fill(dp, 1000);\\n        Deque<Integer> stack = new ArrayDeque<Integer>();\\n\\n        for (int d = 0; d < D; ++d) {\\n            stack.clear();\\n            for (int i = d; i < n; i++) {\\n                dp2[i] = i > 0 ? dp[i - 1] + A[i] : A[i];\\n                while (!stack.isEmpty() && A[stack.peek()] <= A[i]) {\\n                    int j = stack.pop();\\n                    dp2[i] = Math.min(dp2[i], dp2[j] - A[j] + A[i]);\\n                }\\n                if (!stack.isEmpty()) {\\n                    dp2[i] = Math.min(dp2[i], dp2[stack.peek()]);\\n                }\\n                stack.push(i);\\n            }\\n            tmp = dp;\\n            dp = dp2;\\n            dp2 = tmp;\\n        }\\n        return dp[n - 1];\\n    }\\n```\n```cpp\\n    int minDifficulty(vector<int>& A, int D) {\\n        int n = A.size();\\n        if (n < D) return -1;\\n        vector<int> dp(n, 1000), dp2(n), stack;\\n        for (int d = 0; d < D; ++d) {\\n            stack.clear();\\n            for (int i = d; i < n; i++) {\\n                dp2[i] = i ? dp[i - 1] + A[i] : A[i];\\n                while (stack.size() && A[stack.back()] <= A[i]) {\\n                    int j = stack.back(); stack.pop_back();\\n                    dp2[i] = min(dp2[i], dp2[j] - A[j] + A[i]);\\n                }\\n                if (stack.size()) {\\n                    dp2[i] = min(dp2[i], dp2[stack.back()]);\\n                }\\n                stack.push_back(i);\\n            }\\n            swap(dp, dp2);\\n        }\\n        return dp[n - 1];\\n    }\\n```\n```py\\n    def minDifficulty(self, A, d):\\n        n = len(A)\\n        if n < d: return -1\\n        dp, dp2 = [float(\\'inf\\')] * n, [0] * n\\n        for d in xrange(d):\\n            stack = []\\n            for i in xrange(d, n):\\n                dp2[i] = dp[i - 1] + A[i] if i else A[i]\\n                while stack and A[stack[-1]] <= A[i]:\\n                    j = stack.pop()\\n                    dp2[i] = min(dp2[i], dp2[j] - A[j] + A[i])\\n                if stack:\\n                    dp2[i] = min(dp2[i], dp2[stack[-1]])\\n                stack.append(i)\\n            dp, dp2 = dp2, dp\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924611,
                "title": "dfs-dp-progression-with-explanation-o-n-3d-o-nd",
                "content": "This problem is almost identical to [`813. Largest Sum of Averages`](https://leetcode.com/problems/largest-sum-of-averages/) (my solution [here](https://leetcode.com/problems/largest-sum-of-averages/discuss/916679/DFS-greater-DP-Progression-With-Explanation-O(kn2)O(kn))).  We are tasked to break up a list into `d` segments such that the sum of the max number in each segment is minimized.  One way to solve this is to then look through all combinations of segments, and return the combination that minimizes the sum of the max of each segment.  DFS is a great tool to use to visualize this, as we can imagine an instance of the function as the current state, and the recursive calls as possible actions you can take to get to another state.  Let\\'s take a look at the DFS tree, where `m(...)` signifies the max of those elements.\\n![image](https://assets.leetcode.com/users/images/cdcfe79a-3706-445e-bdf1-216573d64f32_1604592753.655928.png)\\nEach step down the tree partitions one of the segments into two.  In code, this would look like\\n```\\ndef dfs(jobs, d):\\n\\tif d == 1:\\n\\t\\treturn max(jobs)\\n\\tminDiff = float(\"inf\")\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tcurr = max(jobs[:i]) + dfs(jobs[i:], d - 1)\\n\\t\\tminDiff = min(minDiff, curr)\\n\\treturn minDiff\\nreturn dfs(jobDifficulty, d)\\n```\\nThis is a standard tree traversal, where at each node, we acquire some cost `m(...)`, and then continue down the tree until we hit the base case `(if d == 1: return max(jobs))`.  Therefore, we are looking for the minimum cost root -> leaf path of length `d`.  This DFS approach solves the problem, however for larger inputs it takes far too long and times out.  Why is that?  Notice in the DFS tree, we have the two recursive calls\\n```\\nm(a) + m(b) + dfs(cd)\\nm(a, b) + dfs(cd)\\n```\\nWe encounter `dfs(cd)` twice.  The solution to both of these recursive calls will always return the same solution, and thus we are wasting time recalculating it.  This issue becomes exponentially worse as the the inputs become larger and the DFS tree grows taller.  This is where the DP solution comes in.\\nIn the DFS approach, we are calculating the solution from the top down, meaning we need to recurse all the way down the tree to have any understanding of how much a path costs.  Instead, let\\'s build the solution from the ground up, saving the solution to a given subproblem at each step.  Our recursion relation will be the same, except now we are going to traverse backwards through `jobs`.\\n![image](https://assets.leetcode.com/users/images/0fcd120b-6e1a-41a5-a73f-088686075ab2_1604593819.8360617.png)\\nFor the right branch, we would have already calculated the solution to `dfs(a, b)`, so all we need to do is reference it and add `m(c)`.  In DP terms, the subproblem we are solving is `Let A[i][d] = the minimum difficulty schedule including jobs {1...i } partitioned into d days`.  Thus, we have\\n```\\ndef dp(jobs, d):\\n\\tA = [[float(\"inf\")] * d for i in range(len(jobs))]\\n\\tA[0][0] = jobs[0]\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tA[i][0] = max(A[i - 1][0], jobs[i])\\n\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tfor j in range(1, min(i + 1, d)):\\n\\t\\t\\tfor k in range(i):\\n\\t\\t\\t\\tA[i][j] = min(A[i][j], A[k][j - 1] + max(jobs[k + 1:i + 1]))\\n\\n\\treturn A[-1][-1]\\nreturn dp(jobDifficulty, d)\\n```\\nIf you are confused, try drawing out the 2D array and walking through the function on a basic input (such as `[1,2,3,4], 3`.  Notice that the recursion relation is almost exactly same as in the DFS approach (we could have coded the DFS approach the same way).  This is because we are using the same method of solving the problem, but with DP we have the additional benefit of only calculating a certain function call once.\\n\\nHere is a quick peek at the 2D array\\n![image](https://assets.leetcode.com/users/images/e316ae80-f7ea-44c7-a7c3-6b7ca82bff87_1604791803.0723028.png)\\nNotice the blacked out boxes.  These are in place because we can not partition a list into more segments than the length of that list.  For instance, we can not partition `[1,2,3]` into 4 segments.  Also, we do not need to partition a list more than `d` times, and this is why we have `for j in range(1, min(i + 1, d)`.  \\n\\nP.S. Be sure to include `if d > len(jobDifficulty): return -1` before either approach as there is no schedule for this input.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(jobs, d):\\n\\tif d == 1:\\n\\t\\treturn max(jobs)\\n\\tminDiff = float(\"inf\")\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tcurr = max(jobs[:i]) + dfs(jobs[i:], d - 1)\\n\\t\\tminDiff = min(minDiff, curr)\\n\\treturn minDiff\\nreturn dfs(jobDifficulty, d)\\n```\n```\\nm(a) + m(b) + dfs(cd)\\nm(a, b) + dfs(cd)\\n```\n```\\ndef dp(jobs, d):\\n\\tA = [[float(\"inf\")] * d for i in range(len(jobs))]\\n\\tA[0][0] = jobs[0]\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tA[i][0] = max(A[i - 1][0], jobs[i])\\n\\n\\tfor i in range(1, len(jobs)):\\n\\t\\tfor j in range(1, min(i + 1, d)):\\n\\t\\t\\tfor k in range(i):\\n\\t\\t\\t\\tA[i][j] = min(A[i][j], A[k][j - 1] + max(jobs[k + 1:i + 1]))\\n\\n\\treturn A[-1][-1]\\nreturn dp(jobDifficulty, d)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 944828,
                "title": "short-dp-solution-with-highly-detailed-step-by-step-explanation",
                "content": "Shout out to lee215 for this elegant and beautiful solution. I converted it to JavaScript. \\n\\nInput : an array of job difficulties, call it A, and a number of days, call it D.\\n```\\nconst minDifficulty = (A, D) => {\\n    let n = A.length, inf = Infinity, maxd;\\n    \\n    if (n < D) return -1;\\n    \\n    let dp = new Array(n + 1).fill(Infinity);\\n    dp[n] = 0;\\n    \\n    for (let d = 1; d <= D; d++) {\\n        for (let i = 0; i <= n - d; i++) {\\n            maxd = 0, dp[i] = inf;\\n\\n            for (let j = i; j <= n - d; j++) {\\n                maxd =  Math.max(maxd, A[j]);\\n                dp[i] = Math.min(dp[i], maxd + dp[j + 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[0];\\n}\\n```\\n\\nFirst, let\\'s assume that we have an array, call it dp, of size ( n + 1), where n is the length of the input array.\\n\\nLoop 1: iterates from day 1 to day D, which is the amount of days given. For every iteration of this outer loop, dp[0] will contain an updated answer depending on how many days have passed. For instance, after 2 iterations, we will have the correct minimum difficulty for inputs A and D = 2 stored in dp[0]. We will start at 1 day, and work our way up to the given D days. \\n\\nNow, let\\u2019s take a detailed look at what\\u2019s happening to our dp array as we go through the inner loops. Below is the what happens at every iteration of d. The \\u201C===\\u201C line indicates the end of a day.\\n\\nA = [6,5,7,3]\\nD = 3\\n\\n# DAY ONE \\ni is: 0,  j is: 0,  maxd is: 6, dp array: [ Infinity, Infinity, Infinity, Infinity, 0 ]\\ni is: 0,  j is: 1,  maxd is: 6, dp array: [ Infinity, Infinity, Infinity, Infinity, 0 ]\\ni is: 0,  j is: 2,  maxd is: 7, dp array: [ Infinity, Infinity, Infinity, Infinity, 0 ]\\ni is: 0,  j is: 3,  maxd is: 7, dp array: [ 7, Infinity, Infinity, Infinity, 0 ]\\n(i++)\\ni is: 1,  j is: 1,  maxd is: 5, dp array: [ 7, Infinity, Infinity, Infinity, 0 ]\\ni is: 1,  j is: 2,  maxd is: 7, dp array: [ 7, Infinity, Infinity, Infinity, 0 ]\\ni is: 1,  j is: 3,  maxd is: 7, dp array: [ 7, 7, Infinity, Infinity, 0 ]\\n(i++)\\ni is: 2,  j is: 2,  maxd is: 7, dp array: [ 7, 7, Infinity, Infinity, 0 ]\\ni is: 2,  j is: 3,  maxd is: 7, dp array: [ 7, 7, 7, Infinity, 0 ]\\n(i++)\\ni is: 3,  j is: 3,  maxd is: 3, dp array: [ 7, 7, 7, 3, 0 ]\\n\\n**PAUSE** \\n\\nWhat does [ 7, 7, 7, 3, 0 ] mean?\\nWell, let\\u2019s start from the right. Forget about the 0 for a bit. \\n\\n3 means that **A**. we have one job at A[3] that is of difficulty 3, and **B**. we have only one day work. \\nGiven these two conditions, the minimum difficulty is clearly 3. We would have to complete A[3] = 3 in one day. \\n\\nNow, let\\u2019s move to the left. We have a 7. What does the 7 mean? \\n7 means that **A**. We have two jobs starting at A[2], namely [7, 3], and **B**. still only one day to work with (we are still on the first iteration of the outermost loop)\\nGiven these two conditions, the minimum difficulty of our schedule is 7 because we would have to complete A[2]  = 7 and A[3]  = 3 on the same day. \\n\\nLets move one more to the left, what does this 7 at dp[1] mean? \\nIt means that if **A**. we have three jobs starting at A[1], namely [5, 7, 3], and **B**. one day to work, then the minimum difficulty is 7.\\nWe would have to complete A[1] = 5, A[2] = 7, and A[3] = 3 on the same day. \\n\\nThis all seems correct, but we don\\u2019t quite see how these answers are being generated. \\n\\nLet\\u2019s look at what happens during day 2. \\n\\n=============================================================================\\n# DAY TWO\\ni is: 0,  j is: 0,  maxd is: 6, dp array: [ 13, 7, 7, 3, 0 ]\\n\\n**PAUSE**\\n\\nWhat just happened? \\n\\nmaxd is the maximum difficulty that we have encountered thus far, currently located at A[0] = 6.  \\nNow, pay very close attention to the following. \\n\\nQuestion: If we complete job 6 on the FIRST day, and every other job on the SECOND day, what is the total minimum difficulty of our job schedule?\\n\\nTwo part answer: \\n**A**. if we complete job 6 in one day, the first day\\'s total difficulty is 6. \\n\\nOk, that\\u2019s the first day, but what is the total difficulty of all the other jobs starting from index j + 1, namely [5, 7, 3], completed on the second day? \\n\\n**B**. We already know the answer to this question! It\\u2019s in dp[j + 1], or dp[1].  \\n\\nLook above! We already found that for [5, 7, 3], completing all the jobs in one day would yield a difficulty of 7. \\n\\n6 + 7 = 13 \\n\\nAt this point, the intuition behind Math.min(dp[i], maxd + dp[j + 1]) should start to become apparent, but don\\u2019t worry if not totally clear yet. Let\\u2019s do a few more iterations. \\n\\ni is: 0,  j is: 1,  maxd is: 6, dp array: [ 13, 7, 7, 3, 0 ]\\ni is: 0,  j is: 2 , maxd is: 7, dp array: [ 10, 7, 7, 3, 0 ]\\n\\n**PAUSE**. \\n\\nWhat just happened? \\n\\nmaxd remained 6 for one iteration, and our dp array remained exactly the same, but then maxd became 7 since  j reached 2 and A[2] = 7, which is max([6,5,7]). \\nNow, again, pay very close attention to the following. \\n\\nQuestion: If we complete jobs [6, 5, 7] on the first day, and all of the rest of the jobs starting at index j + 1, namely [3] on the next day (the second day), what is the total minimum difficulty of our job schedule? \\n\\nTwo part answer: \\n\\n**A**. if we complete job  [6, 5, 7] in one, that day\\'s total difficulty is 7 (or maxd!) \\n\\t\\nOk, that\\u2019s the first day, but what is the total difficulty of all the other jobs starting at index j + 1, namely [3] completed on the second day? \\n\\n**B**. We already know the answer to this question! It\\u2019s in dp[j + 1].  We already found, in the very beginning of our analysis, that for [3], completing all the jobs (or in this case, 1 job) in one day would yield a difficulty of 3. \\n\\n7 + 3 = 10, and we just found a new minimum! If we divide the jobs like this : first day:  [6, 5, 7], second day: [3], we get 10 as our minimum difficulty. \\n\\nBut we\\u2019re not done yet! The input has D = 3.  Let\\u2019s fast forward to day 3!\\n\\n(i++)\\ni is: 1,  j is: 1,  maxd is: 5 dp array: [ 10, 12, 7, 3, 0 ]\\ni is: 1,  j is: 2,  maxd is: 7, dp array: [ 10, 10, 7, 3, 0 ]\\n(i++)\\ni is: 2,  j is: 2,  maxd is: 7, dp array: [ 10, 10, 10, 3, 0 ]\\n\\n=============================================================================\\n# DAY THREE\\ni is: 0,  j is: 0,  maxd is: 6, dp array: [ 16, 10, 10, 3, 0 ]\\n\\n**PAUSE**\\n\\nWhat just happened? \\n\\nmaxd = 6, which is the maximum difficulty so far (obviously, we are still at j = 0, and we haven\\u2019t passed any other difficulties)\\nNow, once again, pay very close attention to the following. \\n\\nQuestion: If we complete job [6] on the first day, and all of the rest of the jobs, namely [5,7,3] this time during the next TWO days, day 2 and day 3,  what will be the total minimum difficulty of our job schedule? \\n\\nTwo part answer: \\n\\n**A**. if we complete job [6] in one day, the first day\\'s total difficulty is 6, or maxd! \\n\\t\\nOk, that\\u2019s the first day, but what is the total difficulty of all the other jobs starting at index j + 1, namely [5, 7, 3] completed on the second AND third day.\\n\\n**B**. We already know the answer to this question! It\\u2019s in dp[j + 1], or dp[1].  We already found, during the previous day when d = 2, i = 1, and j = 2, that for [5, 7, 3], completing all the jobs in two days would yield a difficulty of 10. \\n\\n6 + 10 = 16. \\n\\ni is: 0,  j is: 1,  maxd is: 6, dp array: [ 16, 10, 10, 3, 0 ]\\n(i++)\\ni is: 1,  j is: 1,  maxd is: 5, dp array: [ 16, 15, 10, 3, 0 ]\\n\\n=============================================================================\\n\\nNow, lets summarize the algorithm. \\n\\n1. For each day, we want to update dp from i = 0 to i = n - d. \\n\\t*  Why n - d? Well, think of it this way.  After d = 1 is completed, our dp looks like this : [ 7, 7, 7, 3, 0 ]\\n\\t*  When d = 2, would it make sense to update dp[3]? No, because we can\\'t distribute one job, namely, [3] over 2 days.\\n\\t*  This upper limit ensures that we never update dp where there aren\\'t enough jobs to fill the days specified by our outer loop.\\n2. For each iteration of i over dp, we want to go over all of the elements in A from j = i to j = n - d. \\n3. In this innermost loop, keep track of maxd, and for each iteration, the minimum is either dp[i] or maxd + dp[j + 1], whichever is smallest. \\n\\nNow two final things. \\n1. What\\'s up with the 0 at the end of our dp array? \\n\\t* We need that 0 to properly update dp during day 1. \\n2. Why do we reassign dp[i] = inf at the beginning of each iteration of the second loop?\\n\\t* \\tIf we don\\'t assign infinity, dp[i] might not be replaced with a new value. \\n\\n\\nMay 21, 2022 update: \\n\\nI had a crack at this problem once more after leaving it for a few months, and I found the recursive solution a quite a bit more intuitive. Leaving it here as an alternative to the one above. \\n\\nThe idea is to keep track of today\\'s maximum difficulty as well as the overall minimum difficulty. The overall minimum difficulty is today\\'s maximum difficulty plus the minDifficulty of the rest of the jobs (starting at ```i + 1```) and with one less day ```d - 1``` to complete those jobs).\\n\\n```JavaScript\\nconst findMaxArr = (arr, start) => {\\n    let max = -Infinity;\\n    \\n    for (let i = start; i < arr.length; i++) {\\n        max = Math.max(max, arr[i]);\\n        \\n    };\\n    \\n    return max; \\n}\\n\\nconst minDifficulty = (jobDifficulty, d) => {\\n    const cache = new Map();\\n    \\n    const findMin = (jobDifficulty, d, start) => {\\n        if (jobDifficulty.length - start < d) return -1;    \\n        \\n        let maxToday = -Infinity;\\n        let minTotal = Infinity;\\n        \\n\\t\\t// cache the minimum difficulty for a schedule starting at start and with d days remaining\\n        const cachedMinimum = cache.get(`${start}#${d}`);\\n        \\n        if (cachedMinimum) {\\n            return cachedMinimum;\\n        }\\n        \\n        if (d === 1) {\\n            const max = findMaxArr(jobDifficulty, start);\\n            \\n            cache[`${start}-${d}`] = max; \\n            \\n            return max;\\n        };\\n\\n        for (let i = start; i < jobDifficulty.length - d + 1; i++) {\\n            const nextMinDifficulty = findMin(jobDifficulty, d - 1, i + 1);\\n\\n            maxToday = Math.max(jobDifficulty[i], maxToday);\\n            minTotal = Math.min(\\n                minTotal,\\n                nextMinDifficulty + maxToday,\\n            );\\n        };\\n        \\n        cache.set(`${start}#${d}`, minTotal);\\n        \\n        return minTotal;\\n    }\\n    \\n    return findMin(jobDifficulty, d, 0);\\n};\\n```\\n\\nHope you found this helpful. \\n\\n-Aatef",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nconst minDifficulty = (A, D) => {\\n    let n = A.length, inf = Infinity, maxd;\\n    \\n    if (n < D) return -1;\\n    \\n    let dp = new Array(n + 1).fill(Infinity);\\n    dp[n] = 0;\\n    \\n    for (let d = 1; d <= D; d++) {\\n        for (let i = 0; i <= n - d; i++) {\\n            maxd = 0, dp[i] = inf;\\n\\n            for (let j = i; j <= n - d; j++) {\\n                maxd =  Math.max(maxd, A[j]);\\n                dp[i] = Math.min(dp[i], maxd + dp[j + 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[0];\\n}\\n```\n```i + 1```\n```d - 1```\n```JavaScript\\nconst findMaxArr = (arr, start) => {\\n    let max = -Infinity;\\n    \\n    for (let i = start; i < arr.length; i++) {\\n        max = Math.max(max, arr[i]);\\n        \\n    };\\n    \\n    return max; \\n}\\n\\nconst minDifficulty = (jobDifficulty, d) => {\\n    const cache = new Map();\\n    \\n    const findMin = (jobDifficulty, d, start) => {\\n        if (jobDifficulty.length - start < d) return -1;    \\n        \\n        let maxToday = -Infinity;\\n        let minTotal = Infinity;\\n        \\n\\t\\t// cache the minimum difficulty for a schedule starting at start and with d days remaining\\n        const cachedMinimum = cache.get(`${start}#${d}`);\\n        \\n        if (cachedMinimum) {\\n            return cachedMinimum;\\n        }\\n        \\n        if (d === 1) {\\n            const max = findMaxArr(jobDifficulty, start);\\n            \\n            cache[`${start}-${d}`] = max; \\n            \\n            return max;\\n        };\\n\\n        for (let i = start; i < jobDifficulty.length - d + 1; i++) {\\n            const nextMinDifficulty = findMin(jobDifficulty, d - 1, i + 1);\\n\\n            maxToday = Math.max(jobDifficulty[i], maxToday);\\n            minTotal = Math.min(\\n                minTotal,\\n                nextMinDifficulty + maxToday,\\n            );\\n        };\\n        \\n        cache.set(`${start}#${d}`, minTotal);\\n        \\n        return minTotal;\\n    }\\n    \\n    return findMin(jobDifficulty, d, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070611,
                "title": "java-dfs-with-memoization-detailed-step-by-step-explanation",
                "content": "Edit (07/16/2021): I have been practicing other similar problems. I\\'ve noticed that the popular question \"Best Time to Buy or Sell Stock IV\" has an almost identical way of solving it: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/1341629/Java-DFS-with-memoization Please see if the solution over there makes sense and helps you practice after reading the explanation below.\\n\\n[][][][][][][][][]\\n\\nIf you\\'re new to memoization and have struggled as I have for a long time (especially with this problem), I hope this helps you.\\n\\nSo what we wanna do first is understand the question and come up with the naive recursive/DFS approach for this problem\\n\\nIf we had an input like [5,2,4,1,6,2,7] and 3 minimum days, we\\'d have to execute one task per day at miminum. The cost per day is tied to the task with the max cost, for example if we decieded to execute [1,6,2] on day 2, the cost for day 2 would be 6 because the max weight among the jobs we chose that day is 6, similarly if we chose [1,6,2,7] for day 3 instead, the cost for day 3 would be 7.\\n\\nOur goal is to find a way to split these tasks among 3 days (in the above example), so that we can minimize the total costs. The constrait we have is that at least one task must be executed per day, and they are dependent on the previous task so they must be scheduled in order. We can find the optimal solution by trying out *every* single way of splitting the task between the 3 days and finding the minimum among those.\\n\\nIn the above example, for instance, the optimal split would be as follows:\\nDay 1: [5,2,4] | Day 2: [1] | Day 3: [6,2,7] = 5+1+7 = 13\\n\\nHow would we go about writing this recursive function? We\\'d have to go day by day, trying each combination.\\n\\nSo the base case would be: if there\\'s only one day left, just return the max value of the remaining array. Simple enough. If there\\'s more, then sequentially increase the size of the jobs for that day and recursively call the function for the subsequent days. Looking at the code for this:\\n\\n```\\nclass Solution {\\n    public int minDifficulty(int[] k, int d) {\\n        if(d > k.length) return -1;\\n        return dfs(k, d-1, 0);\\n    }\\n    \\n    private int dfs(int[] k, int d, int pos) {\\n\\t\\t//base case\\n        if(d == 0) {\\n            int max = k[pos];\\n            for(int i = pos; i < k.length; i++) max = Math.max(max, k[i]);\\n            return max;\\n        } \\n\\t\\t\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t//try out all ranges for that day\\n        for(int i = pos; i < k.length-d; i++) {\\n            max = Math.max(max, k[i]);\\n            min = Math.min(min, max + dfs(k, d-1, i+1));\\n        }\\n\\t\\treturn min;\\n    }\\n}\\n```\\n\\nA careful look at this will tell you that there\\'s a lot of repeated work in this recursive function. For example, look at these two splits during the recursive:\\nDay 1: [5, 2]  | Day 2 [4, 1] | Day 3: [6,2,7]\\nDay 1: [5, 2, 4] | Day 2: [1] | Day 3: [6,2,7]\\n\\nIn both those cases we\\'re doing repeated work by calling dfs() to calculate max of [6, 2, 7]. What we could do instead is maintain a memo/cache for this so the next time our function knows \"hey, when you make the cut for day 2 at position 4, I know the answer is 7, I\\'ve done this before, don\\'t call dfs again\". In the code below, this is where the concept of the \\'cache\\' maintaining values for day/position comes from. (```cache[day][pos]```) Let\\'s take a look at what\\'s changed.\\n\\n```\\nclass Solution {\\n    public int minDifficulty(int[] k, int d) {\\n        if(d > k.length) return -1;\\n\\t\\t\\n\\t\\t//we now have a cache!\\n\\t\\t//don\\'t really need a row for the last day\\n        int[][] cache = new int[d-1][k.length];\\n        for(int[] day : cache) Arrays.fill(day, -1);\\n\\t\\t\\n        return dfs(k, d-1, 0, cache);\\n    }\\n    \\n    private int dfs(int[] k, int d, int pos, int[][] cache) {\\n\\t\\t//base case\\n        if(d == 0) {\\n            int max = k[pos];\\n            for(int i = pos; i < k.length; i++) max = Math.max(max, k[i]);\\n            return max;\\n        } \\n\\t\\t\\n\\t\\t//just making sure we start indexing from 0\\n        int day = cache.length-d;\\n\\t\\t\\n\\t\\t//we already have this in the cache, just return it right here\\n        if(cache[day][pos] != -1) return cache[day][pos];\\n\\t\\t\\n\\t\\t// same logic as naive recursion\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = pos; i < k.length-d; i++) {\\n            max = Math.max(max, k[i]);\\n            min = Math.min(min, max + dfs(k, d-1, i+1, cache));\\n        }\\n\\t\\t\\n\\t\\t// but now we\\'re also updating the cache the first time we calculate this\\n        return cache[day][pos] = min;\\n    }\\n}\\n```\\n\\nMaybe I\\'m dumb, but I really struggle with visualizing recusive problems, and while it didn\\'t take me long to understand the concept of memoization, I\\'ve really struggled with translating thought to code, especially in interviews where I\\'d have to figure this out in 30 mins and just hopelessly try to visualize the recursion stack on the whiteboard trying to indentify repeated work. I hope this explanation makes sense and helps you if you\\'re like me. Cheers!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] k, int d) {\\n        if(d > k.length) return -1;\\n        return dfs(k, d-1, 0);\\n    }\\n    \\n    private int dfs(int[] k, int d, int pos) {\\n\\t\\t//base case\\n        if(d == 0) {\\n            int max = k[pos];\\n            for(int i = pos; i < k.length; i++) max = Math.max(max, k[i]);\\n            return max;\\n        } \\n\\t\\t\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t//try out all ranges for that day\\n        for(int i = pos; i < k.length-d; i++) {\\n            max = Math.max(max, k[i]);\\n            min = Math.min(min, max + dfs(k, d-1, i+1));\\n        }\\n\\t\\treturn min;\\n    }\\n}\\n```\n```cache[day][pos]```\n```\\nclass Solution {\\n    public int minDifficulty(int[] k, int d) {\\n        if(d > k.length) return -1;\\n\\t\\t\\n\\t\\t//we now have a cache!\\n\\t\\t//don\\'t really need a row for the last day\\n        int[][] cache = new int[d-1][k.length];\\n        for(int[] day : cache) Arrays.fill(day, -1);\\n\\t\\t\\n        return dfs(k, d-1, 0, cache);\\n    }\\n    \\n    private int dfs(int[] k, int d, int pos, int[][] cache) {\\n\\t\\t//base case\\n        if(d == 0) {\\n            int max = k[pos];\\n            for(int i = pos; i < k.length; i++) max = Math.max(max, k[i]);\\n            return max;\\n        } \\n\\t\\t\\n\\t\\t//just making sure we start indexing from 0\\n        int day = cache.length-d;\\n\\t\\t\\n\\t\\t//we already have this in the cache, just return it right here\\n        if(cache[day][pos] != -1) return cache[day][pos];\\n\\t\\t\\n\\t\\t// same logic as naive recursion\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = pos; i < k.length-d; i++) {\\n            max = Math.max(max, k[i]);\\n            min = Math.min(min, max + dfs(k, d-1, i+1, cache));\\n        }\\n\\t\\t\\n\\t\\t// but now we\\'re also updating the cache the first time we calculate this\\n        return cache[day][pos] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934574,
                "title": "explanation-of-problem",
                "content": "I thought this will help someone.\\n\\nInput: jobDifficulty = [6,5,4,3,2,1], d = 2\\nHere, we have to take 2 days. We cannot complete all work in 1 day. Also we cannot rearrange because to do next work previous work should be completed. Therefore:\\n\\n```\\nmax(6,5,4,3,2) = 6\\nmax(1) = 1\\nTotal: 7\\n```\\n\\nInput: jobDifficulty = [9,9,9], d = 4\\nThree jobs cannot be completed in 4 days because we need to do one job per day. So it will finish in 3 days. Therefore:\\n\\n```\\n-1\\n```\\n\\nInput: jobDifficulty = [1,1,1], d = 3\\nWe have to take 3 days.\\n\\n```\\nmax(1) = 1\\nmax(1) = 1\\nmax(1) = 1\\nTotal: 3\\n```\\n\\nInput: jobDifficulty = [7,1,7,1,7,1], d = 3\\nWe have to take three days. Therefore:\\n\\n```\\nmax(7,1,7) = 7\\nmax(1,7) = 7\\nmax(1) = 1\\nTotal: 15\\n```\\n\\nInput: jobDifficulty = [11,111,22,222,33,333,44,444], d = 6\\nOutput: 843\\nWe have to take 6 days. Should not complete fast. Therefore\\n\\n```\\nmax(11) = 11\\nmax(111) = 111\\nmax(22) = 22\\nmax(222) = 222\\nmax(33) = 33\\nmax(333, 44, 444) = 444\\nTotal: 843\\n```",
                "solutionTags": [],
                "code": "```\\nmax(6,5,4,3,2) = 6\\nmax(1) = 1\\nTotal: 7\\n```\n```\\n-1\\n```\n```\\nmax(1) = 1\\nmax(1) = 1\\nmax(1) = 1\\nTotal: 3\\n```\n```\\nmax(7,1,7) = 7\\nmax(1,7) = 7\\nmax(1) = 1\\nTotal: 15\\n```\n```\\nmax(11) = 11\\nmax(111) = 111\\nmax(22) = 22\\nmax(222) = 222\\nmax(33) = 33\\nmax(333, 44, 444) = 444\\nTotal: 843\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490460,
                "title": "java-bottom-up-dp-with-explanation",
                "content": "Let\\'s use a function to represent our target value, say, `F(i, j)` means **the minimum difficulty on i-th day who takes j-th work as its end**.\\n\\nHowever, as we fix the date and the last work, we cannot tell which work to start with in a specific day. To make it clear, the problem is we can start from any of the work on `i-th` day, but which one is the best?\\n\\nLet\\'s make a further step. On `i-th` day, the minimum index of work we can take is `i`, because there should be at least one job done on each previous day, when we reaches `i-th` day, there should be at least `i-1` works finished in total.\\nSo if we let `k` to be the start work, the range of `k` should be `[i, j]`. And each `(k, j)` pair means -- at `i-th` day, we start from `k-th` work and ends at `j-th` work. The difficulty will depend on the one with highest difficulty within the range. And we choose the `k` who creates minimum difficulty.\\n\\nAt last, in order to start at `k-th` work on `i-th` day, we should finish `(k-1)-th` work at `(i-1)-th` day. Then we figure out the functional equation\\n```\\nF(i, j) = MIN{ F(i - 1, k - 1) + MAX_DIFFICULTY(k, j) }, k from i to j\\n```\\n**Implementation**\\n```\\npublic int minDifficulty(int[] jobDifficulty, int d) {\\n    int n = jobDifficulty.length;\\n    if (d > n) return -1;\\n    int[][] F = new int[d+1][n+1];\\n    for (int i = 1; i <= n; i++) F[1][i] = Math.max(F[1][i-1], jobDifficulty[i-1]);\\n    for (int i = 2; i <= d; i++) {\\n        for (int j = i; j <= n; j++) {\\n            F[i][j] = Integer.MAX_VALUE;\\n            int currMax = 0;\\n            for (int k = j; k >= i; k--) {\\n                currMax = Math.max(currMax, jobDifficulty[k-1]);\\n                F[i][j] = Math.min(F[i][j], F[i-1][k-1] + currMax);\\n            }\\n        }\\n    }\\n    return F[d][n];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nF(i, j) = MIN{ F(i - 1, k - 1) + MAX_DIFFICULTY(k, j) }, k from i to j\\n```\n```\\npublic int minDifficulty(int[] jobDifficulty, int d) {\\n    int n = jobDifficulty.length;\\n    if (d > n) return -1;\\n    int[][] F = new int[d+1][n+1];\\n    for (int i = 1; i <= n; i++) F[1][i] = Math.max(F[1][i-1], jobDifficulty[i-1]);\\n    for (int i = 2; i <= d; i++) {\\n        for (int j = i; j <= n; j++) {\\n            F[i][j] = Integer.MAX_VALUE;\\n            int currMax = 0;\\n            for (int k = j; k >= i; k--) {\\n                currMax = Math.max(currMax, jobDifficulty[k-1]);\\n                F[i][j] = Math.min(F[i][j], F[i-1][k-1] + currMax);\\n            }\\n        }\\n    }\\n    return F[d][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963963,
                "title": "java-top-down-and-bottom-up-dp-monotonic-stack-time-o-nd-space-o-nd-with-detailed-explanation",
                "content": "## Understand the problem\\n\\nThis problem can be rephrased as \"Split array `jobDifficulty` into `d` continguous subarrays so that the sum of subarray maximum is minimized\".\\n\\n## DFS with memoization (top-down DP)\\n\\nThis problem is similar to \"all combinations of array\" and can use DFS to search the tree for all possible combinations of the `d - 1` break points. \\n\\n* State `f(i,j):= minimized sum of subarray maximum when splitting A[0..j] into i subarrays`. (Use a shorter name `A` for `jobDifficulty`)\\n* Recurrence relation `f(i,j) = min{f(i-1,k) + max(A[k+1..j]), i - 2 <= k < j`\\n* Base case `f(1,j) = max(A[0..j]), f(i,j) = -1 if i > j + 1`\\n\\nTime O(nnd), space O(nd)\\n\\n```java\\nclass Solution {\\n    private Integer[][] memo;\\n    private int[] maxSoFar;\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        memo = new Integer[d + 1][n];\\n        \\n        maxSoFar = new int[n];\\n        maxSoFar[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            maxSoFar[i] = Math.max(maxSoFar[i - 1], jobDifficulty[i]);\\n        }\\n        \\n        return dfs(jobDifficulty, d, n - 1);\\n    }\\n    \\n    // return min difficulty if dividing A[0..j] to i days\\n    private int dfs(int[] A, int i, int j) {\\n        if (i > j + 1) { // more days than tasks\\n            return -1;\\n        } else if (i == 1) {\\n            return maxSoFar[j];\\n        } else if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        memo[i][j] = Integer.MAX_VALUE;\\n        \\n        int maxK2J = A[j]; // max(A[k+1..j])\\n        for (int k = j - 1; k >= i - 2; k--) { // assume second last subarray ends at A[k]\\n            maxK2J = Math.max(maxK2J, A[k + 1]);\\n            memo[i][j] = Math.min(memo[i][j], maxK2J + dfs(A, i - 1, k));\\n        }\\n        return memo[i][j];\\n    }\\n}\\n```\\n\\n## Bottom-up DP\\n\\n* State `f(i,j):= minimized sum of subarray maximum when splitting A[0..j] into i subarrays`. (Use a shorter name `A` for `jobDifficulty`)\\n* Function `f(i,j) = min{f(i-1,k) + max(A[k+1..j]), i - 2 <= k < j`\\n* Initialization `f(1,j) = max(A[0..j]), f(i,j) = -1 if i > j + 1`\\n* Answer is `f(d,n-1)`\\n\\nTime O(nnd), space O(nd)\\n\\n```java\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        int[][] dp = new int[d + 1][n];\\n        \\n        // initialization\\n        dp[1][0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[1][i] = Math.max(dp[1][i - 1], jobDifficulty[i]);\\n        }\\n        \\n        for (int i = 2; i <= d; i++) {\\n            for (int j = i - 1; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                int lastMax = jobDifficulty[j]; // last subarray\\'s max difficulty\\n                for (int k = j - 1; k >= i - 2; k--) { // assume second last subarray ends at A[k]\\n                    lastMax = Math.max(lastMax, jobDifficulty[k + 1]); // max(A[k+1..j])\\n                    dp[i][j] = Math.min(dp[i][j], lastMax + dp[i - 1][k]);\\n                }\\n            }\\n        }\\n        return dp[d][n - 1];\\n    }\\n}\\n```\\n\\nWith space optimization we can reduce the space complexity to `O(n)`\\n\\n```java\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        int[] dp = new int[n];\\n        \\n        // initialization for d = 1\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i - 1], jobDifficulty[i]);\\n        }\\n        \\n        for (int i = 2; i <= d; i++) {\\n            for (int j = n - 1; j >= i - 1; j--) { // space optimization requires this\\n                dp[j] = Integer.MAX_VALUE;\\n                \\n                int lastMax = jobDifficulty[j]; // last subarray\\'s max difficulty\\n                for (int k = j - 1; k >= i - 2; k--) { // assume second last subarray ends at A[k]\\n                    lastMax = Math.max(lastMax, jobDifficulty[k + 1]); // max(A[k+1..j])\\n                    dp[j] = Math.min(dp[j], lastMax + dp[k]);\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```\\n\\n## Bottom-up DP with monotonic stack, time O(nd) space O(n) (Not recommended in interview, hard to explain)\\nI\\'ll try my best to explain how this works, it\\'s a more detailed version of https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/494187/O(n*d)-time-and-O(n)-space-solution. \\n\\nThe recurrence relation `f(i,j) = min{f(i-1,k) + max(A[k+1..j]), i - 2 <= k < j` can be further simplified.\\n\\nLet\\'s define `l(j)` as the **index of first greater difficulty on the left of j**, i.e. `A[l(j)] > A[j], l(j) < j` and there is no other `l(j) < k < j and A[k] > A[j]`. \\n\\n1. `k < l(j)`\\n`max(A[k+1..j] = max(A[k+1..l(j)]` since `max(A[l(j)..j]) = A[l(j)]` according to the definition of `l(j)`.\\n=> `f(i,j) = min{f(i-1,k) + max(A[k+1..l(j)])}, i - 2 <= k < l(j) = f(i, l(j))`\\n2. `k >= l(j)`\\n`max(A[k+1..j] = A[j]` \\n=> `f(i,j) = min{f(i-1,k)} + A[j], l(j) <= k < j`\\n\\nCombining these two we get:\\n`f(i,j) = min{f(i,l(j)), A[j] + min{f(i-1,k) | l(j) <= k < j}}`\\n\\nWhen we compute `f(i,j)` in ascending order, `f(i,l(j))` is already computed, all we need is to compute `oldMin(j) = min{f(i-1,l(j)..j-1)} = g(l(j)..j-1)`, which is the inner-most loop and cost `O(j-1 - l(j)) = O(n)` time. \\n\\nIs there any duplicate calculation that can be avoided here? e.g. can we pre-process `f(i-1:)` array to get `oldMin(j) = g(l(j)..j-1)` for all j in O(n) time? The answer is YES thanks to the special property of `l(j)`.\\n\\nAssume `A[j-1] <= A[j]`, i.e. `l(j) < j-1`. Let\\'s take a look at `oldMin(j-1) = g(l(j-1)..j-2)`, it\\'s a function computed by scanning the index range `l(j-1)..j-2`. Since `A[j-1] <= A[j]`, it\\'s easy to prove that `l(j-1) >= l(j)`, i.e. `oldMin(j-1) = g(l(j-1)..j-2)` covers a sub-range of `l(j)..j-1`. \\n\\nSimilarly, `oldMin(l(j-1)) = g(l^2(j-1)), l(j-1) - 1` covers another sub-range of `l(j)..j-1` just to the left of the sub-range covered by `oldMin(j-1)`. Keep splitting like that eventually we can reach `oldMin(l^(k-1)(j-1)) = g(l^k(j-1), l^(k-1)(j-1) - 1` where `l^k(j-1) = l(j)`, as shown by the graph below. NOTE `l^2(j-1)` represents `l(l(j-1))`.\\n\\n\\n![image](https://assets.leetcode.com/users/images/b681eca4-f042-4a00-afed-923c5ca8d0ff_1607392541.2381656.png)\\n\\n\\nWith the property above, we can obtain `oldMin(j) = min{f(i-1,j-1), oldMin(j-1), oldMin(l(j-1))..oldMin(l^(k-1)(j-1))` from oldMin already computed for smaller j values. We need a data structure that persists `l(j-1), l^2(j-1), ...l^(k-1)(j-1)`, which is exactly what a monotonic stack does. To store the index of first greater element on the left, we can use a descending stack here, i.e. at index `j`, we keep poping stack top until stack top is larger than `A[j]`, so the stack top is just `l(j)`. Strict proof is ignored here.\\n\\nThe time complexity is reduced to O(nd) since in the inner loop each `j` index is pushed and popped at most once.\\n```\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        int[] dp = new int[n];\\n        int[] old = new int[n]; // old dp\\n        \\n        // initialization for d = 1\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i - 1], jobDifficulty[i]);\\n        }\\n        \\n        for (int i = 2; i <= d; i++) {\\n            // swap old and dp\\n            int[] tmp = old;\\n            old = dp;\\n            dp = tmp;\\n            \\n            // descending stack for jobDifficulty, persisting index and oldMin(index)\\n            Deque<int[]> stack = new ArrayDeque<>(); \\n            for (int j = i - 1; j < n; j++) {\\n                int oldMin = old[j - 1];\\n                while (!stack.isEmpty() && jobDifficulty[stack.peek()[0]] <= jobDifficulty[j]) {\\n                    oldMin = Math.min(oldMin, stack.pop()[1]);\\n                }\\n                dp[j] = oldMin + jobDifficulty[j];\\n                if (!stack.isEmpty()) {\\n                    dp[j] = Math.min(dp[j], dp[stack.peek()[0]]);\\n                }\\n                stack.push(new int[]{j, oldMin});\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n    \\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private Integer[][] memo;\\n    private int[] maxSoFar;\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        memo = new Integer[d + 1][n];\\n        \\n        maxSoFar = new int[n];\\n        maxSoFar[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            maxSoFar[i] = Math.max(maxSoFar[i - 1], jobDifficulty[i]);\\n        }\\n        \\n        return dfs(jobDifficulty, d, n - 1);\\n    }\\n    \\n    // return min difficulty if dividing A[0..j] to i days\\n    private int dfs(int[] A, int i, int j) {\\n        if (i > j + 1) { // more days than tasks\\n            return -1;\\n        } else if (i == 1) {\\n            return maxSoFar[j];\\n        } else if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        memo[i][j] = Integer.MAX_VALUE;\\n        \\n        int maxK2J = A[j]; // max(A[k+1..j])\\n        for (int k = j - 1; k >= i - 2; k--) { // assume second last subarray ends at A[k]\\n            maxK2J = Math.max(maxK2J, A[k + 1]);\\n            memo[i][j] = Math.min(memo[i][j], maxK2J + dfs(A, i - 1, k));\\n        }\\n        return memo[i][j];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        int[][] dp = new int[d + 1][n];\\n        \\n        // initialization\\n        dp[1][0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[1][i] = Math.max(dp[1][i - 1], jobDifficulty[i]);\\n        }\\n        \\n        for (int i = 2; i <= d; i++) {\\n            for (int j = i - 1; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                int lastMax = jobDifficulty[j]; // last subarray\\'s max difficulty\\n                for (int k = j - 1; k >= i - 2; k--) { // assume second last subarray ends at A[k]\\n                    lastMax = Math.max(lastMax, jobDifficulty[k + 1]); // max(A[k+1..j])\\n                    dp[i][j] = Math.min(dp[i][j], lastMax + dp[i - 1][k]);\\n                }\\n            }\\n        }\\n        return dp[d][n - 1];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        int[] dp = new int[n];\\n        \\n        // initialization for d = 1\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i - 1], jobDifficulty[i]);\\n        }\\n        \\n        for (int i = 2; i <= d; i++) {\\n            for (int j = n - 1; j >= i - 1; j--) { // space optimization requires this\\n                dp[j] = Integer.MAX_VALUE;\\n                \\n                int lastMax = jobDifficulty[j]; // last subarray\\'s max difficulty\\n                for (int k = j - 1; k >= i - 2; k--) { // assume second last subarray ends at A[k]\\n                    lastMax = Math.max(lastMax, jobDifficulty[k + 1]); // max(A[k+1..j])\\n                    dp[j] = Math.min(dp[j], lastMax + dp[k]);\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length < d || d <= 0) {\\n            return -1;\\n        }\\n        int n = jobDifficulty.length;\\n        int[] dp = new int[n];\\n        int[] old = new int[n]; // old dp\\n        \\n        // initialization for d = 1\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i - 1], jobDifficulty[i]);\\n        }\\n        \\n        for (int i = 2; i <= d; i++) {\\n            // swap old and dp\\n            int[] tmp = old;\\n            old = dp;\\n            dp = tmp;\\n            \\n            // descending stack for jobDifficulty, persisting index and oldMin(index)\\n            Deque<int[]> stack = new ArrayDeque<>(); \\n            for (int j = i - 1; j < n; j++) {\\n                int oldMin = old[j - 1];\\n                while (!stack.isEmpty() && jobDifficulty[stack.peek()[0]] <= jobDifficulty[j]) {\\n                    oldMin = Math.min(oldMin, stack.pop()[1]);\\n                }\\n                dp[j] = oldMin + jobDifficulty[j];\\n                if (!stack.isEmpty()) {\\n                    dp[j] = Math.min(dp[j], dp[stack.peek()[0]]);\\n                }\\n                stack.push(new int[]{j, oldMin});\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490297,
                "title": "java-bottom-up-dp",
                "content": "Time Complexity(n<sup>2</sup>d)\\nSpace Complexity(nd)\\nWhere n is number of jobs\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        \\n\\t\\tint n = jobDifficulty.length; \\n        if(n < d) return -1;\\n        int[][] dp = new int[d][n];\\n        \\n        dp[0][0] = jobDifficulty[0];\\n        for(int i = 1; i < n; i++){\\n            dp[0][i] = Math.max(jobDifficulty[i],dp[0][i-1]);\\n        }\\n        \\n        for(int i = 1; i < d; i++){\\n            for(int j = i; j < n; j++){\\n                int localMax = jobDifficulty[j];\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for(int r = j; r >= i; r--){\\n                    localMax = Math.max(localMax,jobDifficulty[r]);\\n                    dp[i][j] =  Math.min(dp[i][j],dp[i-1][r-1] + localMax);\\n                }\\n            }\\n        }\\n        \\n        return dp[d-1][n-1];\\n    }\\n}\\n```\\n\\n**Similar Logic:**\\n[Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/) (Binary Search Solution is also there)\\n[Pallindrome Partitioning III](https://leetcode.com/problems/palindrome-partitioning-iii/)\\n**Exact Question**\\nhttps://www.geeksforgeeks.org/divide-the-array-in-k-segments-such-that-the-sum-of-minimums-is-maximized/",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        \\n\\t\\tint n = jobDifficulty.length; \\n        if(n < d) return -1;\\n        int[][] dp = new int[d][n];\\n        \\n        dp[0][0] = jobDifficulty[0];\\n        for(int i = 1; i < n; i++){\\n            dp[0][i] = Math.max(jobDifficulty[i],dp[0][i-1]);\\n        }\\n        \\n        for(int i = 1; i < d; i++){\\n            for(int j = i; j < n; j++){\\n                int localMax = jobDifficulty[j];\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for(int r = j; r >= i; r--){\\n                    localMax = Math.max(localMax,jobDifficulty[r]);\\n                    dp[i][j] =  Math.min(dp[i][j],dp[i-1][r-1] + localMax);\\n                }\\n            }\\n        }\\n        \\n        return dp[d-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495000,
                "title": "c-0ms-o-d-n-time-o-n-space-dp-monotonic-minimum-stack",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobs, int days) {\\n        const int n = (int)jobs.size();\\n        if (n < days) return -1;\\n        vector<int> dp(n), old(n); // new and old dp\\n        // fill dp for d = 1\\n        dp[0] = jobs[0];\\n        for (int i = 1; i < n; i++)\\n            dp[i] = max(dp[i-1], jobs[i]);\\n        \\n        // fill dp for remaining days\\n        for (int d = 1; d < days; d++) {\\n            swap(dp, old);    \\n            // monotonic and minimum stack {oldBest, curMax, bestSoFar}\\n            vector<array<int,3>> stk = {{1<<30,1<<30,1<<30}};\\n            for (int i = d; i < n; i++) {\\n                int oldBest = old[i-1];\\n                while (stk.back()[1] <= jobs[i]) {\\n                    oldBest = min(oldBest, stk.back()[0]);\\n                    stk.pop_back();\\n                }\\n                stk.push_back({oldBest, jobs[i], min(oldBest + jobs[i], stk.back()[2])});\\n                dp[i] = stk.back()[2];\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobs, int days) {\\n        const int n = (int)jobs.size();\\n        if (n < days) return -1;\\n        vector<int> dp(n), old(n); // new and old dp\\n        // fill dp for d = 1\\n        dp[0] = jobs[0];\\n        for (int i = 1; i < n; i++)\\n            dp[i] = max(dp[i-1], jobs[i]);\\n        \\n        // fill dp for remaining days\\n        for (int d = 1; d < days; d++) {\\n            swap(dp, old);    \\n            // monotonic and minimum stack {oldBest, curMax, bestSoFar}\\n            vector<array<int,3>> stk = {{1<<30,1<<30,1<<30}};\\n            for (int i = d; i < n; i++) {\\n                int oldBest = old[i-1];\\n                while (stk.back()[1] <= jobs[i]) {\\n                    oldBest = min(oldBest, stk.back()[0]);\\n                    stk.pop_back();\\n                }\\n                stk.push_back({oldBest, jobs[i], min(oldBest + jobs[i], stk.back()[2])});\\n                dp[i] = stk.back()[2];\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490256,
                "title": "c-dp-solution-with-explanation",
                "content": "This problem can be solved using DP.\\n\\nWe denote `dp[d][i]` as: We have d days left, and and we have finished all the tasks before `arr[i]` (not including i). \\nThen the answer is just `dp[day][0]` (using all the days given, and starting from `arr[0]`).\\n\\nNow, consider the state conversion:\\n\\n`dp[d][i] = minimum of ( maximum value between arr[i,j] + dp[d-1][j+1] ); ` in which j is from [i, n]. \\n\\n**Explanation**: We can use current day to finish many tasks, so we discuss them one by one. \\nIf we just finish one task today, then `dp[d][i] = arr[i] + dp[d-1][i+1]`\\nIf we finish two tasks today, then `dp[d][i] = max(arr[i], arr[i+1]) + dp[d-1][i+2]` and so on...\\n\\n**Note**: We should note that there could be illegal cases, where you have too many days left, and even you finish only one tasks per day, you cannot use all the days left, we should explicitly consider this case, that is: `n-i < d`, and assign this case with value INF.\\n\\n**Improvement** (not included in the code): We can preprocess the maximum value between `arr[i,j]` and store them to make the code faster, I will not implement it here, just to make the code easier to understand.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int dp[12][305];  //dp[d][i] is the answer that we have d days left, and we have finished all the tasks before arr[i](exclusive)\\n    vector<int> arr; \\n    \\n    int maxquery(int i,int j) {  //return the maximum value of arr[i,j]\\n        int maxi = -1;\\n        for (int k = i; k <= j; k++) maxi = max(maxi,arr[k]);\\n        return maxi;\\n    }\\n    \\n    int minDifficulty(vector<int>& arr, int day) {\\n        this->arr = arr;\\n        int n = arr.size();\\n        if (n < day) return -1;\\n        \\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 305; j++) dp[i][j] = 1e6;  //initialize the array with INF\\n        }\\n                \\n        for (int i = 0; i < n; i++) dp[1][i] = maxquery(i,n-1);  //base case\\n        \\n        for (int d = 2; d <= day; d++) {\\n            for (int i = 0; i < n; i++) {\\n                if (n-i < d) {  //too many days left, not possible to use them all\\n                    dp[d][i] = 1e6;\\n                    continue;\\n                }\\n                for (int j = i; j < n; j++) {\\n                    dp[d][i] = min(dp[d][i], maxquery(i,j) + dp[d-1][j+1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[day][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[12][305];  //dp[d][i] is the answer that we have d days left, and we have finished all the tasks before arr[i](exclusive)\\n    vector<int> arr; \\n    \\n    int maxquery(int i,int j) {  //return the maximum value of arr[i,j]\\n        int maxi = -1;\\n        for (int k = i; k <= j; k++) maxi = max(maxi,arr[k]);\\n        return maxi;\\n    }\\n    \\n    int minDifficulty(vector<int>& arr, int day) {\\n        this->arr = arr;\\n        int n = arr.size();\\n        if (n < day) return -1;\\n        \\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 305; j++) dp[i][j] = 1e6;  //initialize the array with INF\\n        }\\n                \\n        for (int i = 0; i < n; i++) dp[1][i] = maxquery(i,n-1);  //base case\\n        \\n        for (int d = 2; d <= day; d++) {\\n            for (int i = 0; i < n; i++) {\\n                if (n-i < d) {  //too many days left, not possible to use them all\\n                    dp[d][i] = 1e6;\\n                    continue;\\n                }\\n                for (int j = i; j < n; j++) {\\n                    dp[d][i] = min(dp[d][i], maxquery(i,j) + dp[d-1][j+1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[day][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805151,
                "title": "c-dfs-with-memoization-easy-explanation",
                "content": "The idea is very simple. We manually find the max element from index i to j ( in our code) and recur for the remaining elements and d-1 days. Just memoize the solution to greatly improve the time complexity. Rest of the explanation is in the code. Comment for any doubt! \\n```\\n#define INF 10000000\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[305][15];\\n    int dfs(int i,int d,vector <int> &jd)\\n    {\\n        if(i==n && d==0) //end of our search with all elements covered and 0 days remaining\\n            return 0;\\n        if(i==n || d==0 || n-i<d) //if elements are remaining or elements are used up but days are remaining\\n            return INF;\\n        if(dp[i][d]!=-1) //if already seen this state,return it\\n            return dp[i][d];\\n        int ans=INF;\\n        int maxele=-INF;\\n        for(int j=i;j<n;j++)\\n        {   \\n            maxele=max(maxele,jd[j]); //max element from i to j\\n            ans=min(ans,maxele+dfs(j+1,d-1,jd)); //minimum of all possible answers\\n        }\\n        dp[i][d]=ans;\\n        return ans;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        n=jobDifficulty.size();\\n        if(n<d)       //not possible\\n            return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans= dfs(0,d,jobDifficulty);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n#define INF 10000000\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[305][15];\\n    int dfs(int i,int d,vector <int> &jd)\\n    {\\n        if(i==n && d==0) //end of our search with all elements covered and 0 days remaining\\n            return 0;\\n        if(i==n || d==0 || n-i<d) //if elements are remaining or elements are used up but days are remaining\\n            return INF;\\n        if(dp[i][d]!=-1) //if already seen this state,return it\\n            return dp[i][d];\\n        int ans=INF;\\n        int maxele=-INF;\\n        for(int j=i;j<n;j++)\\n        {   \\n            maxele=max(maxele,jd[j]); //max element from i to j\\n            ans=min(ans,maxele+dfs(j+1,d-1,jd)); //minimum of all possible answers\\n        }\\n        dp[i][d]=ans;\\n        return ans;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        n=jobDifficulty.size();\\n        if(n<d)       //not possible\\n            return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans= dfs(0,d,jobDifficulty);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708329,
                "title": "c-memoized-solution-runtime-130-ms-beats-34-93-memory-7-3-mb-beats-93-10",
                "content": "# Approach\\nGiven an array , cut it into d contiguous subarrays and return the minimum sum of max of each subarray\\uD83E\\uDD14\\uD83E\\uDD14\\uD83E\\uDD14. Confusing right\\uD83D\\uDE3F\\uD83D\\uDE3F.\\nLet\\'s understand using the test case given:\\njobDifficulty[] = [6,5,4,3,2,1],    d = 2;\\nSo we have to partition the array into 2 such that the maximum of each subarray gives the minimum result. **Still Confused??** Read more ->\\n\\n## Case 1:\\n ``` jobDifficulty[] = [6,5,4,3,2], [1] ```\\nsum = max([6,5,4,3,2]) + max([1]) = 6+1 = 7 ------> Solution 1\\n\\n## Case 2:\\n``` jobDifficulty[] = [6,5,4,3], [2,1] ```\\nsum = max([6,5,4,3]) + max([2,1]) = 6+2 = 8 ------> Solution 2.\\n\\n##### And similiarly we have to find the minimum sum from max nums of subarrays.\\nHope it makes sense now.\\n\\n\\nSo we have to try out various possible ways to do so and this can be achievd by using the *Dynamic Programming*!!!\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity is O(n*d).\\n\\n- Space complexity:\\nAn external array is made but it\\'s of constant size so Space Complexity is O(1).\\n\\nIf you liked the solution please Upvote it.\\n*Happy Coding*!!!\\uD83D\\uDE07\\uD83D\\uDE07\\uD83D\\uDE07\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t[301][11];\\n    int solve(vector<int>& mat, int n, int idx, int d) {\\n        if(d == 1)\\n            return *max_element(begin(mat)+idx, end(mat));\\n        \\n        if(t[idx][d] != -1)\\n            return t[idx][d];\\n    \\n        \\n        int Max = INT_MIN;\\n        int result = INT_MAX;\\n        \\n        for(int i = idx; i<=n-d; i++) {\\n            Max = max(Max, mat[i]);\\n            result = min(result, Max + solve(mat, n, i+1, d-1));\\n        }\\n        return t[idx][d] = result;\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d)\\n            return -1;\\n        memset(t, -1, sizeof(t));\\n        return solve(jobDifficulty, n, 0, d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` jobDifficulty[] = [6,5,4,3,2], [1] ```\n``` jobDifficulty[] = [6,5,4,3], [2,1] ```\n```\\nclass Solution {\\npublic:\\n    int t[301][11];\\n    int solve(vector<int>& mat, int n, int idx, int d) {\\n        if(d == 1)\\n            return *max_element(begin(mat)+idx, end(mat));\\n        \\n        if(t[idx][d] != -1)\\n            return t[idx][d];\\n    \\n        \\n        int Max = INT_MIN;\\n        int result = INT_MAX;\\n        \\n        for(int i = idx; i<=n-d; i++) {\\n            Max = max(Max, mat[i]);\\n            result = min(result, Max + solve(mat, n, i+1, d-1));\\n        }\\n        return t[idx][d] = result;\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d)\\n            return -1;\\n        memset(t, -1, sizeof(t));\\n        return solve(jobDifficulty, n, 0, d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708161,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/8Z5gmteC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/8Z5gmteC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 491590,
                "title": "java-dp-top-down-solution-clean-code",
                "content": "```java\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (n < d) return -1;\\n        int[][] cache = new int[n][d+1];\\n        for (int i = 0; i < n; i++) Arrays.fill(cache[i], -1);\\n        return dfs(jobDifficulty, n, 0, d, cache);\\n    }\\n\\n    private int dfs(int[] arr, int n, int i, int d, int[][] cache) {\\n        if (cache[i][d] != -1) return cache[i][d];\\n        if (d == 1) {\\n            int max = 0;\\n            while (i < n) max = Math.max(max, arr[i++]);\\n            return max;\\n        }\\n        int res = Integer.MAX_VALUE, maxDifficulty = 0;\\n        for (int j = i; j < n - d + 1; j++) {\\n            maxDifficulty = Math.max(arr[j], maxDifficulty);\\n            res = Math.min(res, maxDifficulty + dfs(arr, n, j + 1, d - 1, cache));\\n        }\\n        return cache[i][d] = res;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*n*d)`\\n- Space: `O(n*d)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (n < d) return -1;\\n        int[][] cache = new int[n][d+1];\\n        for (int i = 0; i < n; i++) Arrays.fill(cache[i], -1);\\n        return dfs(jobDifficulty, n, 0, d, cache);\\n    }\\n\\n    private int dfs(int[] arr, int n, int i, int d, int[][] cache) {\\n        if (cache[i][d] != -1) return cache[i][d];\\n        if (d == 1) {\\n            int max = 0;\\n            while (i < n) max = Math.max(max, arr[i++]);\\n            return max;\\n        }\\n        int res = Integer.MAX_VALUE, maxDifficulty = 0;\\n        for (int j = i; j < n - d + 1; j++) {\\n            maxDifficulty = Math.max(arr[j], maxDifficulty);\\n            res = Math.min(res, maxDifficulty + dfs(arr, n, j + 1, d - 1, cache));\\n        }\\n        return cache[i][d] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490278,
                "title": "java-recursion-memoization",
                "content": "```\\nclass Solution {\\n    static int inf = Integer.MAX_VALUE;\\n    public static int function(int[] jobDifficulty, int n, int i, int d, int[][] dp) {\\n        if(d == 0 && i == n) return 0;\\n        if(d == 0 || i == n) return inf;\\n        if(dp[i][d] != -1) return dp[i][d];\\n        int currMax = jobDifficulty[i];\\n        int min = inf;\\n        for(int j = i; j < n; j++) {\\n            currMax = Math.max(jobDifficulty[j], currMax);\\n            int temp = function(jobDifficulty, n, j + 1, d - 1, dp);\\n            if(temp != inf) min = Math.min(min, temp + currMax);\\n        }\\n        return dp[i][d] = min;\\n    }\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if(d > n) return -1;\\n        int[][] dp = new int[n][d + 1];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < d + 1; j++) dp[i][j] = -1;\\n        }\\n        return function(jobDifficulty, n, 0, d, dp);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int inf = Integer.MAX_VALUE;\\n    public static int function(int[] jobDifficulty, int n, int i, int d, int[][] dp) {\\n        if(d == 0 && i == n) return 0;\\n        if(d == 0 || i == n) return inf;\\n        if(dp[i][d] != -1) return dp[i][d];\\n        int currMax = jobDifficulty[i];\\n        int min = inf;\\n        for(int j = i; j < n; j++) {\\n            currMax = Math.max(jobDifficulty[j], currMax);\\n            int temp = function(jobDifficulty, n, j + 1, d - 1, dp);\\n            if(temp != inf) min = Math.min(min, temp + currMax);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 490263,
                "title": "python-dp-w-throught-process-for-general-brute-force-greedy-dp",
                "content": "Some of these problems use DP, based on some choice to make among a set of available choices.\\n\\nBrute force is, based on the choices you have, do exhaustive search on all possible choices and choose the best.\\n\\nGreedy is, based on the choices you have, we know exactly what is the optimal one. (Only applies to few problems, like Dkjistras)\\n\\nDP is brute force of making all possible choices, but finding an optimal substructure (recurisve equation that helps us to construct solutions for bigger instance based on solutions for smallers instances of the problem) and hence using cached results or building bottom up table.\\n\\nIn this problem, \\n\\nFor day 1, we can put just task 1, OR task 1 and task 2, OR task1, task2 and task3 .. we dont know which would give us the best solution.\\nLets try all possible choices and choose the best, and cache the intermediate results.\\n\\n```\\ndef minDifficulty(self, jobsd: List[int], d: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def cut(st, days):\\n            if st == len(jobsd) or days == 0 or len(jobsd) - st < days:\\n                return math.inf\\n            if days == 1:\\n                return max(jobsd[st:])\\n            maxsofar, res = -math.inf, math.inf\\n            for i in range(st, len(jobsd)-1):\\n                maxsofar = max(maxsofar, jobsd[i])\\n                res = min(res, maxsofar + cut(i+1, days-1))\\n            return res\\n        res = cut(0, d)\\n        return -1 if res == math.inf else res\\n```",
                "solutionTags": [],
                "code": "```\\ndef minDifficulty(self, jobsd: List[int], d: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def cut(st, days):\\n            if st == len(jobsd) or days == 0 or len(jobsd) - st < days:\\n                return math.inf\\n            if days == 1:\\n                return max(jobsd[st:])\\n            maxsofar, res = -math.inf, math.inf\\n            for i in range(st, len(jobsd)-1):\\n                maxsofar = max(maxsofar, jobsd[i])\\n                res = min(res, maxsofar + cut(i+1, days-1))\\n            return res\\n        res = cut(0, d)\\n        return -1 if res == math.inf else res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1035458,
                "title": "python-3-solutions-with-clear-explanation",
                "content": "### Recursion + Memoization\\nRecursion should be thought of when seeing the tasks are dependent and all *j* tasks have to be completed before scheduling *i* task. For each recursion, we try to calculate the difficulty of including the *i* task for the *d* day, and get the difficulty for the *d + 1* day with all elements starting from *i + 1* recusively. If the difficulty of *d + 1* day is `-1` then we can\\'t schedule *i* task for the *d* day and stop the procedure, otherwise find out the minimum difficulty and return from the valid choices. \\nIn order to reduce the time complexity we use `lru_cache` to store each intermediary result\\n\\n```python\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        \\n        @lru_cache(None)\\n        def helper(index, day):\\n            if n - index < d - day + 1:\\n                return -1\\n            if day == d:\\n                return max(jobDifficulty[index:])\\n            difficulty = float(\\'inf\\')\\n            current =  0\\n            for i in range(index, n - d + day + 1):\\n                current = max(current, jobDifficulty[i])\\n                next_day = helper(i + 1, day + 1)\\n                if next_day != -1:\\n                    difficulty = min(difficulty, current + next_day) \\n            return difficulty          \\n        return helper(0, 1)\\n```\\n\\n*Time Complexity*= **O(n^2\\\\*d)**\\n*Space Complexity* =**O(nd)**\\n\\n\\n### Dynamic Programming\\nThe idea is the same as recursion approach, but with dynamic programming implementation. We use *dp[day][j]* to represent the minimum difficulty of scheduling jobs ending up at *j* for *day* days. So we get below transition formula\\n\\n```\\ndp[day][j] = min(dp[day - 1][i -1] + max(difficulty[i:j])) for i in 0...j\\n```\\n\\n```python\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if n < d:\\n            return -1\\n        \\n        dp = [[0] + [float(\\'inf\\')] * n for _ in range(d + 1)]\\n        \\n        for i in range(1, d + 1):\\n            for j in range(i, n + 1):\\n                current = 0\\n                for k in range(j, i - 1, -1):\\n                    current = max(current, jobDifficulty[k - 1])\\n                    dp[i][j] = min(dp[i][j], current + dp[i - 1][k - 1])\\n        return dp[-1][-1]\\n```\\n\\n*Time Complexity* = **O(n^2\\\\*d)**\\n*Space Complexity*= **O(nd)**\\n\\n### Dynamic Programming + Stack\\nBy looking into dp solution, we find that the minimum difficulty is related to maximum difficulty seen up to *j*, which means for those *i* such that `difficulty[i] <= difficulty[j]`, the minimum diffculty is possible to appear because the *i* can be scheduled at the same day with *j* without changing the difficulty for *day* day instead of the day *day - 1* . So the minimum difficulty of previous day might be changed. Otherwise, the *j* can be scheduled at the same day with the maximum jobDifficulty so far for the minimum difficulty.\\nWith this obeservation, we can mantain the maximum difficulty using decreasing stack and update the minimum difficulty when seeing larger difficulty.\\nWhat\\'s more, we can reduce space to linear as only result of previous day is involved which ends up with 2 arrays with size of *n*. Leaving this for you to implement\\n\\n```python\\n    def minDifficulty(self, A: List[int], d: int) -> int:\\n        n = len(A)\\n        if n < d:\\n            return -1\\n        \\n        dp = [[0] + [float(\\'inf\\')] * n for _ in range(d + 1)]\\n        \\n        for day in range(1, d + 1):\\n            stack = []\\n            for j in range(day, n + 1):\\n    \\t\\t\\t# schedule j at the dayth days\\n                dp[day][j] = dp[day - 1][j - 1] + A[j - 1] \\n                while stack and A[stack[-1] - 1] <= A[j - 1]:\\n                    i = stack.pop()\\n\\t\\t\\t\\t\\t# find i such that A[i] <= A[j], then schedule i at the same day as j\\n                    dp[day][j] = min(dp[day][j], dp[day][i] - A[i - 1] + A[j - 1])\\n                if stack:\\n\\t\\t\\t\\t    # j might not be the max, schedule j at the same day as the max\\n                    dp[day][j] = min(dp[day][j], dp[day][stack[-1]])\\n                stack.append(j)\\n        return dp[-1][-1]\\n```\\n\\n*Time Complexity* = **O(nd)**\\n*Space Complexity*= **O(n)**, which for the code is *O(nd)*, but it could be *O(n)*\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        \\n        @lru_cache(None)\\n        def helper(index, day):\\n            if n - index < d - day + 1:\\n                return -1\\n            if day == d:\\n                return max(jobDifficulty[index:])\\n            difficulty = float(\\'inf\\')\\n            current =  0\\n            for i in range(index, n - d + day + 1):\\n                current = max(current, jobDifficulty[i])\\n                next_day = helper(i + 1, day + 1)\\n                if next_day != -1:\\n                    difficulty = min(difficulty, current + next_day) \\n            return difficulty          \\n        return helper(0, 1)\\n```\n```\\ndp[day][j] = min(dp[day - 1][i -1] + max(difficulty[i:j])) for i in 0...j\\n```\n```python\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if n < d:\\n            return -1\\n        \\n        dp = [[0] + [float(\\'inf\\')] * n for _ in range(d + 1)]\\n        \\n        for i in range(1, d + 1):\\n            for j in range(i, n + 1):\\n                current = 0\\n                for k in range(j, i - 1, -1):\\n                    current = max(current, jobDifficulty[k - 1])\\n                    dp[i][j] = min(dp[i][j], current + dp[i - 1][k - 1])\\n        return dp[-1][-1]\\n```\n```python\\n    def minDifficulty(self, A: List[int], d: int) -> int:\\n        n = len(A)\\n        if n < d:\\n            return -1\\n        \\n        dp = [[0] + [float(\\'inf\\')] * n for _ in range(d + 1)]\\n        \\n        for day in range(1, d + 1):\\n            stack = []\\n            for j in range(day, n + 1):\\n    \\t\\t\\t# schedule j at the dayth days\\n                dp[day][j] = dp[day - 1][j - 1] + A[j - 1] \\n                while stack and A[stack[-1] - 1] <= A[j - 1]:\\n                    i = stack.pop()\\n\\t\\t\\t\\t\\t# find i such that A[i] <= A[j], then schedule i at the same day as j\\n                    dp[day][j] = min(dp[day][j], dp[day][i] - A[i - 1] + A[j - 1])\\n                if stack:\\n\\t\\t\\t\\t    # j might not be the max, schedule j at the same day as the max\\n                    dp[day][j] = min(dp[day][j], dp[day][stack[-1]])\\n                stack.append(j)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 494187,
                "title": "o-n-d-time-and-o-n-space-solution",
                "content": "Firstly we have the basic O(nnd) DP solution:\\nf[i][j]=min{f[i-1][k]+max(val[k+1..j])},i-2<=k<j\\nwhere f[i][j] is the minimum difficulty for first j jobs done in i days, and val=jobDifficulty\\nDefine t=l[j] to be the largest t such that t<j and val[t]>=val[j]\\nThen we know that for t<=k<j, max(val[k+1..j])=val[j]; and that for k<t, max(val[k+1..j])=max(val[k+1..t])\\nSo for k<t case we have min{f[i-1][k]+max(val[k+1..j])}=f[i][t]\\nFor t<=k<j case we have max(val[k+1..j])=val[j], so we only need to calculate min(f[i-1][t..j-1])\\nThe DP equation becomes:\\nf[i][j]=min(f[i][l[j]],val[j]+min(f[i-1][l[j]..j-1]))\\nHere we notice that if a>b and val[a]>val[b] then for any c>a, l[c]!=b\\nTherefore for any l[a]<b<a<c, we have l[c]!=b, so we can suppress the interval l[a]..a-1 since they will always be included together\\nFinally we use a monotonic stack to maintain the array f[i-1][l[a]..a-1] where a={...,l[l[j]],l[j],j} is the representatives for the intervals\\nThe time complexity is O(nd) since in each of the d rounds every j will be popped only once, and the space is O(n) because f[i][...] only depends on f[i-1][...]\\n```\\nclass Solution:\\n    def minDifficulty(self, val: List[int], d: int) -> int:\\n        if len(val)<d:\\n            return -1\\n        n,f=len(val),val[:]\\n        for i in range(1,n):\\n            f[i]=max(f[i-1],f[i])\\n        for t in range(1,d):\\n            temp=[10**9]*t\\n            st=[(10**9,0,0)]\\n            for i in range(t,n):\\n                m,j=f[i-1],i-1\\n                while st[-1][0]<val[i]:\\n                    m,j=min(m,st[-1][1]),st[-1][2]\\n                    st.pop()\\n                if len(st)>1:\\n                    temp.append(min(temp[j],m+val[i]))\\n                else:\\n                    temp.append(m+val[i])\\n                st.append((val[i],m,j))\\n            f=temp\\n        return f[n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, val: List[int], d: int) -> int:\\n        if len(val)<d:\\n            return -1\\n        n,f=len(val),val[:]\\n        for i in range(1,n):\\n            f[i]=max(f[i-1],f[i])\\n        for t in range(1,d):\\n            temp=[10**9]*t\\n            st=[(10**9,0,0)]\\n            for i in range(t,n):\\n                m,j=f[i-1],i-1\\n                while st[-1][0]<val[i]:\\n                    m,j=min(m,st[-1][1]),st[-1][2]\\n                    st.pop()\\n                if len(st)>1:\\n                    temp.append(min(temp[j],m+val[i]))\\n                else:\\n                    temp.append(m+val[i])\\n                st.append((val[i],m,j))\\n            f=temp\\n        return f[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707960,
                "title": "python-3-1335-minimum-difficulty-of-a-job-schedule",
                "content": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(idx,d,curr):\\n\\t\\t\\n            if idx == len(jobDifficulty) and d == 0: return curr\\n            if idx >= len(jobDifficulty) or  d <= 0: return inf\\n            \\n            return min(dp(idx+1,d,max(curr,jobDifficulty[idx])),\\n                       max(curr,jobDifficulty[idx])+dp(idx+1,d-1,0))\\n       \\n        ans = dp(0,d,0)\\n\\n        return ans if ans != inf else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(idx,d,curr):\\n\\t\\t\\n            if idx == len(jobDifficulty) and d == 0: return curr\\n            if idx >= len(jobDifficulty) or  d <= 0: return inf\\n            \\n            return min(dp(idx+1,d,max(curr,jobDifficulty[idx])),\\n                       max(curr,jobDifficulty[idx])+dp(idx+1,d-1,0))\\n       \\n        ans = dp(0,d,0)\\n\\n        return ans if ans != inf else -1",
                "codeTag": "Java"
            },
            {
                "id": 2708517,
                "title": "easy-soln-java-recursion-memoization",
                "content": "```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    int n;\\n    \\n    public int Helper(int idx, int[] arr, int d){\\n        \\n        if(idx == n && d == 0)    return 0;\\n        if(n - idx < d)           return (int)1e5;          // only for optimization not necessary\\n        if(d < 0)                 return (int)1e5;\\n\\t\\t\\n        if(dp[idx][d] != null)      return dp[idx][d];\\n        \\n        int max = 0;\\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int i = idx; i < n; ++i){\\n            max = Math.max(arr[i], max);\\n            res = Math.min(res, max + Helper(i + 1, arr, d - 1));\\n        }\\n    \\n        return dp[idx][d] = res;\\n    }\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        this.n = jobDifficulty.length;\\n\\t\\tthis.dp = new Integer[n][d + 1]; \\n\\t\\t\\n        if(n < d)   return -1;\\n       \\n        return Helper(0, jobDifficulty, d);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    int n;\\n    \\n    public int Helper(int idx, int[] arr, int d){\\n        \\n        if(idx == n && d == 0)    return 0;\\n        if(n - idx < d)           return (int)1e5;          // only for optimization not necessary\\n        if(d < 0)                 return (int)1e5;\\n\\t\\t\\n        if(dp[idx][d] != null)      return dp[idx][d];\\n        \\n        int max = 0;\\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int i = idx; i < n; ++i){\\n            max = Math.max(arr[i], max);\\n            res = Math.min(res, max + Helper(i + 1, arr, d - 1));\\n        }\\n    \\n        return dp[idx][d] = res;\\n    }\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        this.n = jobDifficulty.length;\\n\\t\\tthis.dp = new Integer[n][d + 1]; \\n\\t\\t\\n        if(n < d)   return -1;\\n       \\n        return Helper(0, jobDifficulty, d);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001011,
                "title": "no-code-just-breaking-down-the-problem",
                "content": "```\\n/**\\n\\n    schedule all jobs within \\'d\\' days\\n    To do a \\'i\\'th job all the prev jobs should have been completed\\n    at-least one task everyday\\n    \\n    if given \\'d\\' days  > number of jobs, return -1\\n    \\n    [6,5,4,3,2,1] , 2\\n     0 1 2 3 4 5\\n     \\n    we have to do \\'d - 1\\' cuts in the array to have \\'d\\' sub-arrays.\\n    All we need to do is to return the sum of max of all the sub-arrays [IMPORTANT]\\n    \\n\\tSo, try to do \\'d - 1\\' cuts at all possible positions till N - d + 1\\n\\t\\n                     prevMax + f(i + 1, d - 1) \\n     [6] [5,4,3,2,1]   6 + 5 = 11 (max of 6 in first cut and max of 5 in second cut)\\n     [6,5] [4,3,2,1]   6 + 4 = 10\\n     [6,5,4] [3,2,1]   6 + 3 = 9\\n     [6,5,4,3] [2,1]   6 + 2 = 8\\n     [6,5,4,3,2,] [1]  6 + 1 = 7 (best candidate answer)\\n \\n    \\n    Let f(i, d) denote a value for min-diff of schedule ending at\\n    index \\'i\\' with days \\'d\\', hence\\n    \\n                0                           when \\'d\\' is 0\\n    f(i, d) =   0                           when \\'i\\' is >= N\\n                maxOf(A[i:])                when \\'d\\' is 1, max value of the array from i..lastIndex (obviously, with d==1, we needn\\'t do any cut, \\n\\t\\t\\t\\t                                just return max value of A in i..lastIndex)\\n                minOf(                      otherwise, where i <= j <= N\\n                    prevMax(i..j) +\\n                    f(j + 1, d - 1),\\n                    result \\n                )\\n                \\n**/\\n```\\n\\ncode: https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/1001015/Bruteforce-greater-top-down",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n\\n    schedule all jobs within \\'d\\' days\\n    To do a \\'i\\'th job all the prev jobs should have been completed\\n    at-least one task everyday\\n    \\n    if given \\'d\\' days  > number of jobs, return -1\\n    \\n    [6,5,4,3,2,1] , 2\\n     0 1 2 3 4 5\\n     \\n    we have to do \\'d - 1\\' cuts in the array to have \\'d\\' sub-arrays.\\n    All we need to do is to return the sum of max of all the sub-arrays [IMPORTANT]\\n    \\n\\tSo, try to do \\'d - 1\\' cuts at all possible positions till N - d + 1\\n\\t\\n                     prevMax + f(i + 1, d - 1) \\n     [6] [5,4,3,2,1]   6 + 5 = 11 (max of 6 in first cut and max of 5 in second cut)\\n     [6,5] [4,3,2,1]   6 + 4 = 10\\n     [6,5,4] [3,2,1]   6 + 3 = 9\\n     [6,5,4,3] [2,1]   6 + 2 = 8\\n     [6,5,4,3,2,] [1]  6 + 1 = 7 (best candidate answer)\\n \\n    \\n    Let f(i, d) denote a value for min-diff of schedule ending at\\n    index \\'i\\' with days \\'d\\', hence\\n    \\n                0                           when \\'d\\' is 0\\n    f(i, d) =   0                           when \\'i\\' is >= N\\n                maxOf(A[i:])                when \\'d\\' is 1, max value of the array from i..lastIndex (obviously, with d==1, we needn\\'t do any cut, \\n\\t\\t\\t\\t                                just return max value of A in i..lastIndex)\\n                minOf(                      otherwise, where i <= j <= N\\n                    prevMax(i..j) +\\n                    f(j + 1, d - 1),\\n                    result \\n                )\\n                \\n**/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951222,
                "title": "java-dfs-pruning-dp-with-complete-demo-explanations-intuitive-never-confused-agian",
                "content": "Approach 1: DFS no return value\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        int[] min = new int[1];\\n        min[0] = Integer.MAX_VALUE;\\n        dfs(jobDifficulty, d, 0, min, 0);\\n        return min[0];\\n    }\\n    \\n    private void dfs(int[] jobDifficulty, int d, int idx, int[] min, int sum) {\\n        int jobs = jobDifficulty.length;\\n        // Base Case\\n        if(idx == jobs && d == 0) { \\n            min[0] = Math.min(sum, min[0]);\\n            return;\\n        }\\n        if(d == 0 || jobs - idx < d) return;\\n        \\n        int diff = 0;\\n        for(int i = idx; i < jobs; i++) {\\n            diff = Math.max(diff, jobDifficulty[i]);\\n            dfs(jobDifficulty, d - 1, i + 1, min, sum + diff);\\n        }\\n        return;\\n    }\\n}\\n```\\nApproach 2: DFS int as return value\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        return dfs(jobDifficulty, 0, d);\\n    }\\n    \\n    private int dfs(int[] jobDifficulty, int idx, int d) {\\n        int jobs = jobDifficulty.length;\\n        // Base Case\\n        if(idx == jobs && d == 0) return 0;\\n        if(d == 0 || jobs - idx < d) return Integer.MAX_VALUE;\\n        \\n        int sum = Integer.MAX_VALUE;\\n        int curDiff = 0;\\n        for(int i = idx; i < jobs; i++) {\\n            curDiff = Math.max(curDiff, jobDifficulty[i]);\\n            int diff = dfs(jobDifficulty, i + 1, d - 1);\\n            if(diff != Integer.MAX_VALUE) sum = Math.min(curDiff + diff, sum);\\n        }\\n        return sum;\\n    }\\n}\\n```\\nApproach 3: DFS Pruning\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        int[][] memo = new int[jobs][d + 1];\\n        return dfs(jobDifficulty, 0, d, memo);\\n    }\\n    \\n    private int dfs(int[] jobDifficulty, int idx, int d, int[][] memo) {\\n        int jobs = jobDifficulty.length;\\n        // Base Case\\n        if(idx == jobs && d == 0) return 0;\\n        if(d == 0 || jobs - idx < d) return Integer.MAX_VALUE;\\n        // Pruning\\n        if(memo[idx][d] != 0) return memo[idx][d];\\n        \\n        int sum = Integer.MAX_VALUE;\\n        int curDiff = 0;\\n        for(int i = idx; i < jobs; i++) {\\n            curDiff = Math.max(curDiff, jobDifficulty[i]);\\n            int diff = dfs(jobDifficulty, i + 1, d - 1, memo);\\n            if(diff != Integer.MAX_VALUE) sum = Math.min(curDiff + diff, sum);\\n        }\\n        return memo[idx][d] = sum;\\n    }\\n}\\n```\\nDemo for Pruning Approach:\\nUse [11,111,22,222,33,333,44,444], d = 6 as Example\\n```\\ndfs(0,6): i=0<8,curDiff=11,diff=dfs(1,5)=832,sum=843;\\n          \\u2026 \\n          i=8=8. return 843.\\n\\tdfs(1,5): i=1<8,curDiff=111,diff=dfs(2,4)=721,sum=832;\\n\\t          \\u2026 \\n\\t          i=8=8. return 832.\\n\\t\\tdfs(2,4): i=2<8,curDiff=22,diff=dfs(3,3)=699,sum=721;\\n\\t\\t          i=3<8,curDiff=222,diff=dfs(4,3)=810,sum=721;\\n\\t\\t          i=4<8,curDiff=222,diff=dfs(5,3)=821,sum=721;\\n\\t\\t          i=5<8,curDiff=333,diff=dfs(6,3)=MAX;\\n\\t\\t          i=6<8,curDiff=333,diff=dfs(7,3)=MAX;\\n\\t\\t          i=7<8,curDiff=444,diff=dfs(8,3)=MAX;\\n\\t\\t          i=8=8. return memo[2][4] = 721.\\n\\t\\t\\tdfs(3,3): i=3<8,curDiff=222,diff=dfs(4,2)=477,sum=699;\\n\\t\\t\\t          i=4<8,curDiff=222,diff=dfs(5,2)=777,sum=699;\\n\\t\\t\\t          i=5<8,curDiff=333,diff=dfs(6,2)=488,sum=699;\\n\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,2)=MAX;\\n\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,2)=MAX;\\n\\t\\t\\t          i=8=8. return memo[3][3] = 699.\\n\\t\\t\\t\\tdfs(4,2): i=4<8,curDiff=33,diff=dfs(5,1)=444,sum=477;\\n\\t\\t\\t\\t          i=5<8,curDiff=333,diff=dfs(6,1)=444,sum=477;\\n\\t\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,1)=444,sum=477;\\n\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,1)=MAX;\\n\\t\\t\\t\\t          i=8=8. return memo[4][2] = 477.\\n\\t\\t\\t\\t\\tdfs(5,1): i=5<8,curDiff=333,diff=dfs(6,0)=MAX;\\n\\t\\t\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,0)=MAX;\\n\\t\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,0)=0,sum=444;\\n\\t\\t\\t\\t\\t          i=8=8. return memo[5][1] = 444.\\n\\t\\t\\t\\t\\tdfs(6,1): i=6<8,curDiff=44,diff=dfs(7,0)=MAX;\\n\\t\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,0)=0,sum=444;\\n\\t\\t\\t\\t \\t          i=8=8. return memo[6][1] = 444.\\n\\t\\t\\t\\t\\tdfs(7,1): i=7<8,curDiff=444,diff=dfs(i,0)=0,sum=444;\\n\\t\\t\\t\\t\\t          i=8=8. return memo[6][1] = 444.\\n\\t\\t\\t\\tdfs(5,2): i=5<8,curDiff=333,diff=dfs(6,1)=444,sum=777;\\n\\t\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,1)=444,sum=777;\\n\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,1)=MAX;\\n\\t\\t\\t\\t          i=8=8. return memo[5][2] = 777.\\n\\t\\t\\t\\tdfs(6,2): i=6<8,curDiff=44,diff=dfs(7,1)=444,sum=488;\\n\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,1)=MAX;\\n\\t\\t\\t\\t          i=8=8. return memo[6][2] = 488.\\n\\t\\t\\tdfs(4,3): i=4<8,curDiff=33,diff=dfs(5,2)=777,sum=810;\\n\\t\\t\\t          i=5<8,curDiff=333,diff=dfs(6,2)=488,sum=810;\\n\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,2)=MAX;\\n\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,2)=MAX;\\n\\t\\t\\t          i=8=8. return memo[4][3] = 810.\\n\\t\\t\\tdfs(5,3): i=5<8,curDiff=333,diff=dfs(6,2)=488,sum=821;\\n\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,2)=MAX;\\n\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,2)=MAX;\\n\\t\\t\\t          i=8=8. return memo[5][3] = 821.\\n```\\nApproach 4: DP\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        int[][] dp = new int[d][jobs];\\n        dp[0][0] = jobDifficulty[0];\\n        for(int j = 1; j < jobs; j++) {\\n            dp[0][j] = Math.max(dp[0][j-1], jobDifficulty[j]);\\n        }\\n        for(int i = 1; i < d; i++) {\\n            for(int j = i; j < jobs; j++) {\\n                int max = Integer.MIN_VALUE;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for(int k = j; k >= i; k--) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    dp[i][j] = Math.min(dp[i-1][k-1] + max, dp[i][j]);\\n                } \\n            }\\n        }\\n        return dp[d-1][jobs-1];\\n    }\\n}\\n/*\\n    dp[6][8]:\\n    [11,111,111,222,222,333,333,444]\\n    [--,122,122,233,233,344,344,455]\\n    [--,---,144,344,266,455,388,566]\\n    [--,---,---,366,366,477,477,588]\\n    [--,---,---,---,399,699,521,810]\\n    [--,---,---,---,---,732,732,843]\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        int[] min = new int[1];\\n        min[0] = Integer.MAX_VALUE;\\n        dfs(jobDifficulty, d, 0, min, 0);\\n        return min[0];\\n    }\\n    \\n    private void dfs(int[] jobDifficulty, int d, int idx, int[] min, int sum) {\\n        int jobs = jobDifficulty.length;\\n        // Base Case\\n        if(idx == jobs && d == 0) { \\n            min[0] = Math.min(sum, min[0]);\\n            return;\\n        }\\n        if(d == 0 || jobs - idx < d) return;\\n        \\n        int diff = 0;\\n        for(int i = idx; i < jobs; i++) {\\n            diff = Math.max(diff, jobDifficulty[i]);\\n            dfs(jobDifficulty, d - 1, i + 1, min, sum + diff);\\n        }\\n        return;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        return dfs(jobDifficulty, 0, d);\\n    }\\n    \\n    private int dfs(int[] jobDifficulty, int idx, int d) {\\n        int jobs = jobDifficulty.length;\\n        // Base Case\\n        if(idx == jobs && d == 0) return 0;\\n        if(d == 0 || jobs - idx < d) return Integer.MAX_VALUE;\\n        \\n        int sum = Integer.MAX_VALUE;\\n        int curDiff = 0;\\n        for(int i = idx; i < jobs; i++) {\\n            curDiff = Math.max(curDiff, jobDifficulty[i]);\\n            int diff = dfs(jobDifficulty, i + 1, d - 1);\\n            if(diff != Integer.MAX_VALUE) sum = Math.min(curDiff + diff, sum);\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        int[][] memo = new int[jobs][d + 1];\\n        return dfs(jobDifficulty, 0, d, memo);\\n    }\\n    \\n    private int dfs(int[] jobDifficulty, int idx, int d, int[][] memo) {\\n        int jobs = jobDifficulty.length;\\n        // Base Case\\n        if(idx == jobs && d == 0) return 0;\\n        if(d == 0 || jobs - idx < d) return Integer.MAX_VALUE;\\n        // Pruning\\n        if(memo[idx][d] != 0) return memo[idx][d];\\n        \\n        int sum = Integer.MAX_VALUE;\\n        int curDiff = 0;\\n        for(int i = idx; i < jobs; i++) {\\n            curDiff = Math.max(curDiff, jobDifficulty[i]);\\n            int diff = dfs(jobDifficulty, i + 1, d - 1, memo);\\n            if(diff != Integer.MAX_VALUE) sum = Math.min(curDiff + diff, sum);\\n        }\\n        return memo[idx][d] = sum;\\n    }\\n}\\n```\n```\\ndfs(0,6): i=0<8,curDiff=11,diff=dfs(1,5)=832,sum=843;\\n          \\u2026 \\n          i=8=8. return 843.\\n\\tdfs(1,5): i=1<8,curDiff=111,diff=dfs(2,4)=721,sum=832;\\n\\t          \\u2026 \\n\\t          i=8=8. return 832.\\n\\t\\tdfs(2,4): i=2<8,curDiff=22,diff=dfs(3,3)=699,sum=721;\\n\\t\\t          i=3<8,curDiff=222,diff=dfs(4,3)=810,sum=721;\\n\\t\\t          i=4<8,curDiff=222,diff=dfs(5,3)=821,sum=721;\\n\\t\\t          i=5<8,curDiff=333,diff=dfs(6,3)=MAX;\\n\\t\\t          i=6<8,curDiff=333,diff=dfs(7,3)=MAX;\\n\\t\\t          i=7<8,curDiff=444,diff=dfs(8,3)=MAX;\\n\\t\\t          i=8=8. return memo[2][4] = 721.\\n\\t\\t\\tdfs(3,3): i=3<8,curDiff=222,diff=dfs(4,2)=477,sum=699;\\n\\t\\t\\t          i=4<8,curDiff=222,diff=dfs(5,2)=777,sum=699;\\n\\t\\t\\t          i=5<8,curDiff=333,diff=dfs(6,2)=488,sum=699;\\n\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,2)=MAX;\\n\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,2)=MAX;\\n\\t\\t\\t          i=8=8. return memo[3][3] = 699.\\n\\t\\t\\t\\tdfs(4,2): i=4<8,curDiff=33,diff=dfs(5,1)=444,sum=477;\\n\\t\\t\\t\\t          i=5<8,curDiff=333,diff=dfs(6,1)=444,sum=477;\\n\\t\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,1)=444,sum=477;\\n\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,1)=MAX;\\n\\t\\t\\t\\t          i=8=8. return memo[4][2] = 477.\\n\\t\\t\\t\\t\\tdfs(5,1): i=5<8,curDiff=333,diff=dfs(6,0)=MAX;\\n\\t\\t\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,0)=MAX;\\n\\t\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,0)=0,sum=444;\\n\\t\\t\\t\\t\\t          i=8=8. return memo[5][1] = 444.\\n\\t\\t\\t\\t\\tdfs(6,1): i=6<8,curDiff=44,diff=dfs(7,0)=MAX;\\n\\t\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,0)=0,sum=444;\\n\\t\\t\\t\\t \\t          i=8=8. return memo[6][1] = 444.\\n\\t\\t\\t\\t\\tdfs(7,1): i=7<8,curDiff=444,diff=dfs(i,0)=0,sum=444;\\n\\t\\t\\t\\t\\t          i=8=8. return memo[6][1] = 444.\\n\\t\\t\\t\\tdfs(5,2): i=5<8,curDiff=333,diff=dfs(6,1)=444,sum=777;\\n\\t\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,1)=444,sum=777;\\n\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,1)=MAX;\\n\\t\\t\\t\\t          i=8=8. return memo[5][2] = 777.\\n\\t\\t\\t\\tdfs(6,2): i=6<8,curDiff=44,diff=dfs(7,1)=444,sum=488;\\n\\t\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,1)=MAX;\\n\\t\\t\\t\\t          i=8=8. return memo[6][2] = 488.\\n\\t\\t\\tdfs(4,3): i=4<8,curDiff=33,diff=dfs(5,2)=777,sum=810;\\n\\t\\t\\t          i=5<8,curDiff=333,diff=dfs(6,2)=488,sum=810;\\n\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,2)=MAX;\\n\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,2)=MAX;\\n\\t\\t\\t          i=8=8. return memo[4][3] = 810.\\n\\t\\t\\tdfs(5,3): i=5<8,curDiff=333,diff=dfs(6,2)=488,sum=821;\\n\\t\\t\\t          i=6<8,curDiff=333,diff=dfs(7,2)=MAX;\\n\\t\\t\\t          i=7<8,curDiff=444,diff=dfs(8,2)=MAX;\\n\\t\\t\\t          i=8=8. return memo[5][3] = 821.\\n```\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        // Corner Case \\n        if(jobDifficulty == null || jobDifficulty.length == 0) throw new IllegalArgumentException();\\n        int jobs = jobDifficulty.length;\\n        if(jobs < d) return -1;\\n        \\n        int[][] dp = new int[d][jobs];\\n        dp[0][0] = jobDifficulty[0];\\n        for(int j = 1; j < jobs; j++) {\\n            dp[0][j] = Math.max(dp[0][j-1], jobDifficulty[j]);\\n        }\\n        for(int i = 1; i < d; i++) {\\n            for(int j = i; j < jobs; j++) {\\n                int max = Integer.MIN_VALUE;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for(int k = j; k >= i; k--) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    dp[i][j] = Math.min(dp[i-1][k-1] + max, dp[i][j]);\\n                } \\n            }\\n        }\\n        return dp[d-1][jobs-1];\\n    }\\n}\\n/*\\n    dp[6][8]:\\n    [11,111,111,222,222,333,333,444]\\n    [--,122,122,233,233,344,344,455]\\n    [--,---,144,344,266,455,388,566]\\n    [--,---,---,366,366,477,477,588]\\n    [--,---,---,---,399,699,521,810]\\n    [--,---,---,---,---,732,732,843]\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490323,
                "title": "python-top-down-bottom-up-solutions-with-explanation",
                "content": "**Recursion with Memoization, Top-down**\\n\\nStarting from the last day, we simply try out all the possible schdules for each day.\\nWe track the intended finished day (`intended`) and the first i-th jobs (`end`).\\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, J, d):\\n        @lru_cache(maxsize=None) # memoization\\n        def helper(intended, end):\\n\\t\\t    # the base case, if we only have 1 day left, we need to handle all the tasks on that day\\n            if intended == 1: return max(J[:end])\\n\\t\\t\\t\\n            res, mx = math.inf, 0\\n            for done in range(1,end-intended+2):\\n                mx = max(mx, J[end-done])\\n                res = min(helper(intended-1, end-done) + mx, res)\\n            return res                \\n        \\n        return helper(d, len(J)) if len(J) >= d else -1\\n```\\n\\n**DP, Bottom-up**\\n```\\nclass Solution:\\n    def minDifficulty(self, J, d):\\n        if len(J) < d: return -1\\n        \\n        dp = {} # (index of day, index of the last finished job)\\n        for i,job in enumerate(J):\\n            # the base case, all jobs need to be finish in one day\\n            dp[0, i] = max(dp.get((0, i-1), 0), job)\\n            \\n        for i in range(1, d):\\n            for j in range(i, len(J)):\\n                mx = J[j]\\n                for k in range(j, i-1, -1):\\n                    mx = max(mx, J[k])\\n                    dp[i, j] = min(dp.get((i, j), math.inf), mx + dp[i-1, k-1])\\n                \\n        return dp[d-1, len(J)-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, J, d):\\n        @lru_cache(maxsize=None) # memoization\\n        def helper(intended, end):\\n\\t\\t    # the base case, if we only have 1 day left, we need to handle all the tasks on that day\\n            if intended == 1: return max(J[:end])\\n\\t\\t\\t\\n            res, mx = math.inf, 0\\n            for done in range(1,end-intended+2):\\n                mx = max(mx, J[end-done])\\n                res = min(helper(intended-1, end-done) + mx, res)\\n            return res                \\n        \\n        return helper(d, len(J)) if len(J) >= d else -1\\n```\n```\\nclass Solution:\\n    def minDifficulty(self, J, d):\\n        if len(J) < d: return -1\\n        \\n        dp = {} # (index of day, index of the last finished job)\\n        for i,job in enumerate(J):\\n            # the base case, all jobs need to be finish in one day\\n            dp[0, i] = max(dp.get((0, i-1), 0), job)\\n            \\n        for i in range(1, d):\\n            for j in range(i, len(J)):\\n                mx = J[j]\\n                for k in range(j, i-1, -1):\\n                    mx = max(mx, J[k])\\n                    dp[i, j] = min(dp.get((i, j), math.inf), mx + dp[i-1, k-1])\\n                \\n        return dp[d-1, len(J)-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709968,
                "title": "c-memoized-solution-runtime-41ms",
                "content": "Complexity- O(N*N*D)\\nAuxilary Space - O(N*d)\\nSolved Using DP + Memoization \\nTry all the possible partitions that are possible using recursion. Let dp[i][k] be the minimum sum of maximums till index i with k partitions. Hence the possible states will be partition at every index from the index i till n. The minimum sum of maximums of all those states will be our answer. After writing this recurrence, we can use memoization.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[305][12];\\n    int minSum(vector<int>&a, int d ,int i,int n){\\n        if(d==0){\\n            if(i==n)  return 0;\\n            else return 1e9;\\n        }\\n        if(i==n)  return 1e9;\\n        if(dp[i][d]!=-1)  return dp[i][d];\\n        int ans=1e9;\\n        //Get the maximum element from the segment \\n        int ma=a[i];\\n        for(int j=i;j<n;j++){\\n            ma=max(ma,a[j]);\\n            ans=min(ans,minSum(a,d-1,j+1,n)+ma);\\n        }\\n        return dp[i][d]=ans;\\n    }\\n    int minDifficulty(vector<int>&a, int d) {\\n        int n=a.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans=minSum(a,d,0,n);\\n        return ans==1e9?-1:ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[305][12];\\n    int minSum(vector<int>&a, int d ,int i,int n){\\n        if(d==0){\\n            if(i==n)  return 0;\\n            else return 1e9;\\n        }\\n        if(i==n)  return 1e9;\\n        if(dp[i][d]!=-1)  return dp[i][d];\\n        int ans=1e9;\\n        //Get the maximum element from the segment \\n        int ma=a[i];\\n        for(int j=i;j<n;j++){\\n            ma=max(ma,a[j]);\\n            ans=min(ans,minSum(a,d-1,j+1,n)+ma);\\n        }\\n        return dp[i][d]=ans;\\n    }\\n    int minDifficulty(vector<int>&a, int d) {\\n        int n=a.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans=minSum(a,d,0,n);\\n        return ans==1e9?-1:ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490455,
                "title": "javascript-dynamic-programming-w-explanation",
                "content": "```javascript\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number} d\\n * @return {number}\\n */\\nvar minDifficulty = function(jobDifficulty, d) {\\n  // if we don\\'t have enough jobs for the number of days return -1;\\n  if (jobDifficulty.length < d) return -1;\\n\\n  // initialize the cache that will have the key of starting index\\n  // and number of days\\n  // the value will be the value of the max for the current job plus the\\n  // minimum total of all days after\\n  const cache = {};\\n\\n  // Depth First Search using a bottom up approach\\n  // We want to return the minimum total difficulty for each starting index\\n  // corresponding to each number of days left\\n  const dfs = (start, numDays) => {\\n\\n    // if we have used all of our days and we have reach the end of jobs\\n    // return 0\\n    // if we have used all our days but haven\\'t finished all our jobs\\n    // return Infinity because we didn\\'t complete all of our jobs (result is invalid)\\n    if (numDays === d) {\\n      return start === jobDifficulty.length ? 0 : Infinity\\n    }\\n\\n    // create a unique key for our cache for each depth\\n    const key = `${start}-${numDays}`\\n    // if the key is in the cache return the value\\n    if (cache[key] !== undefined) return cache[key];\\n\\n    // calculate the last index for this day\\'s number\\n    // if we go beyond that index we will have more days than jobs\\n    const end = jobDifficulty.length - d + numDays;\\n\\n    // result will hold the minimum total of all following days\\n    let result = Infinity;\\n    // max will hold the max for the current day\\n    let max = -Infinity\\n\\n    // iterate through the jobs updating the max and searching the remainder\\n    // of jobs and days\\n    for (let i = start; i <= end; i++) {\\n      max = Math.max(max, jobDifficulty[i]);\\n      result = Math.min(result, max + dfs(i + 1, numDays + 1));\\n    }\\n\\n    // save the result in the cach and return it;\\n    return cache[key] = result;\\n  }\\n  return dfs(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number} d\\n * @return {number}\\n */\\nvar minDifficulty = function(jobDifficulty, d) {\\n  // if we don\\'t have enough jobs for the number of days return -1;\\n  if (jobDifficulty.length < d) return -1;\\n\\n  // initialize the cache that will have the key of starting index\\n  // and number of days\\n  // the value will be the value of the max for the current job plus the\\n  // minimum total of all days after\\n  const cache = {};\\n\\n  // Depth First Search using a bottom up approach\\n  // We want to return the minimum total difficulty for each starting index\\n  // corresponding to each number of days left\\n  const dfs = (start, numDays) => {\\n\\n    // if we have used all of our days and we have reach the end of jobs\\n    // return 0\\n    // if we have used all our days but haven\\'t finished all our jobs\\n    // return Infinity because we didn\\'t complete all of our jobs (result is invalid)\\n    if (numDays === d) {\\n      return start === jobDifficulty.length ? 0 : Infinity\\n    }\\n\\n    // create a unique key for our cache for each depth\\n    const key = `${start}-${numDays}`\\n    // if the key is in the cache return the value\\n    if (cache[key] !== undefined) return cache[key];\\n\\n    // calculate the last index for this day\\'s number\\n    // if we go beyond that index we will have more days than jobs\\n    const end = jobDifficulty.length - d + numDays;\\n\\n    // result will hold the minimum total of all following days\\n    let result = Infinity;\\n    // max will hold the max for the current day\\n    let max = -Infinity\\n\\n    // iterate through the jobs updating the max and searching the remainder\\n    // of jobs and days\\n    for (let i = start; i <= end; i++) {\\n      max = Math.max(max, jobDifficulty[i]);\\n      result = Math.min(result, max + dfs(i + 1, numDays + 1));\\n    }\\n\\n    // save the result in the cach and return it;\\n    return cache[key] = result;\\n  }\\n  return dfs(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011347,
                "title": "python-recursion-memoization-very-easy-to-understand-91-06",
                "content": "The main idea is to divide the given array into d parts such that we minimise the sum of all the maximums from those d sub-arrays. \\n\\nThe idea behind recursion: At each element we have two option,s either we can stop there to form a sub array or include it to the current sub array. Now using this intuition we also track the  maximum of the current subarray. \\n\\nKey point: for each step in the recursion we have two options and we store the minimum from the answers returned by the two recusrive calls.\\n\\nFinally we can cache the answer to each subproblem(recursive call.)\\n\\nNote: Very new to posting answers. If the above does not make sense, please let me know, I will try to explain differently.\\n\\n```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        \\n        memo ={}\\n        def rec(i,d,maxs):\\n            \\n            if i==-1 and d: #there are no elements to observe but there are d sub arrays left to create\\n                return float(\\'inf\\') \\n            elif i!=-1 and d==0: #there still some elements to observe but we have already created the required number of sub arrays\\n                return float(\\'inf\\')\\n            elif i==-1 and d==0: #we have observed all the elements and created all the required sub arrays\\n                return 0\\n            if (i,d,maxs) in memo: #returning the cached answer\\n                return memo[(i,d,maxs)]\\n            \\n            a= rec(i-1,d-1,jobDifficulty[i-1])+max(maxs,jobDifficulty[i]) #with this step we end the making of sub-array and create the other from rest of the elements\\n            b = rec(i-1,d,max(jobDifficulty[i],maxs)) #we add the current element to the current sub-array\\n            memo[(i,d,maxs)]=min(a,b) #cacheing the minimum of two possibilities\\n            return min(a,b) \\n        \\n        \\n        a= (rec(len(jobDifficulty)-1,d,-float(\"inf\")))\\n        if a==float(\\'inf\\'):\\n            return -1\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        \\n        memo ={}\\n        def rec(i,d,maxs):\\n            \\n            if i==-1 and d: #there are no elements to observe but there are d sub arrays left to create\\n                return float(\\'inf\\') \\n            elif i!=-1 and d==0: #there still some elements to observe but we have already created the required number of sub arrays\\n                return float(\\'inf\\')\\n            elif i==-1 and d==0: #we have observed all the elements and created all the required sub arrays\\n                return 0\\n            if (i,d,maxs) in memo: #returning the cached answer\\n                return memo[(i,d,maxs)]\\n            \\n            a= rec(i-1,d-1,jobDifficulty[i-1])+max(maxs,jobDifficulty[i]) #with this step we end the making of sub-array and create the other from rest of the elements\\n            b = rec(i-1,d,max(jobDifficulty[i],maxs)) #we add the current element to the current sub-array\\n            memo[(i,d,maxs)]=min(a,b) #cacheing the minimum of two possibilities\\n            return min(a,b) \\n        \\n        \\n        a= (rec(len(jobDifficulty)-1,d,-float(\"inf\")))\\n        if a==float(\\'inf\\'):\\n            return -1\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796192,
                "title": "java-o-nd-time-o-n-space",
                "content": "Inspired by Mr. Lee\\'s post. However, I am not sure if his O(nd) solution is correct (or it is very likely that I did not understand his superb logic). I made some change based on my understanding and added comments. Hope it helps.\\n```\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (n < d) return -1;\\n        \\n        int[] dp = new int[n]; // dp[i] stores the min difficulty of a schedule that ends at job i\\n        \\n        // set up dp for the first day\\n        dp[0] = jobDifficulty[0];\\n        for(int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i-1], jobDifficulty[i]);\\n        }\\n        \\n        // second day and more ...\\n        for(int k = 1; k < d; k++) {\\n            // for every element in the stack, idx, dp[idx] is the min difficulty of the schedule\\n            // that ends at job idx and the last day\\'s max difficulty is jobDifficulty[idx]\\n            // if an index is not in the stack, its schedule min difficulty must be the same as \\n            // the nearest one in front of it that is in the stack.\\n            Deque<Integer> stack = new ArrayDeque<>();\\n            int[] dp2 = new int[n];\\n            for(int i = k; i < n; i++) {\\n                dp2[i] = dp[i - 1] + jobDifficulty[i];\\n                while(!stack.isEmpty() && jobDifficulty[stack.peek()] <= jobDifficulty[i]){\\n                    int idx = stack.pop();\\n                    // try to absorb [idx..i] into the same last day\\n                    // see if we can make any improvement\\n                    dp2[i] = Math.min(dp2[i], dp2[idx] - jobDifficulty[idx] + jobDifficulty[i]);\\n                }\\n                \\n                if(!stack.isEmpty() && dp2[i] > dp2[stack.peek()]){\\n                    // in this case, we shall merge [stack.peek() .. i] into the same day\\n                    dp2[i] = dp2[stack.peek()];\\n                    // since the max difficulty of day i is not jobDifficulty[i],\\n                    // we will not add i to the stack\\n                } else {\\n                    // dp2[i] is the min difficulty of the schedule that ends at job i\\n                    // and the max difficulty of the last day is jobDifficulty[i]\\n                    stack.push(i);\\n                }\\n            }\\n            dp = dp2;\\n        }\\n        \\n        return dp[n-1];\\n    }",
                "solutionTags": [],
                "code": "Inspired by Mr. Lee\\'s post. However, I am not sure if his O(nd) solution is correct (or it is very likely that I did not understand his superb logic). I made some change based on my understanding and added comments. Hope it helps.\\n```\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (n < d) return -1;\\n        \\n        int[] dp = new int[n]; // dp[i] stores the min difficulty of a schedule that ends at job i\\n        \\n        // set up dp for the first day\\n        dp[0] = jobDifficulty[0];\\n        for(int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i-1], jobDifficulty[i]);\\n        }\\n        \\n        // second day and more ...\\n        for(int k = 1; k < d; k++) {\\n            // for every element in the stack, idx, dp[idx] is the min difficulty of the schedule\\n            // that ends at job idx and the last day\\'s max difficulty is jobDifficulty[idx]\\n            // if an index is not in the stack, its schedule min difficulty must be the same as \\n            // the nearest one in front of it that is in the stack.\\n            Deque<Integer> stack = new ArrayDeque<>();\\n            int[] dp2 = new int[n];\\n            for(int i = k; i < n; i++) {\\n                dp2[i] = dp[i - 1] + jobDifficulty[i];\\n                while(!stack.isEmpty() && jobDifficulty[stack.peek()] <= jobDifficulty[i]){\\n                    int idx = stack.pop();\\n                    // try to absorb [idx..i] into the same last day\\n                    // see if we can make any improvement\\n                    dp2[i] = Math.min(dp2[i], dp2[idx] - jobDifficulty[idx] + jobDifficulty[i]);\\n                }\\n                \\n                if(!stack.isEmpty() && dp2[i] > dp2[stack.peek()]){\\n                    // in this case, we shall merge [stack.peek() .. i] into the same day\\n                    dp2[i] = dp2[stack.peek()];\\n                    // since the max difficulty of day i is not jobDifficulty[i],\\n                    // we will not add i to the stack\\n                } else {\\n                    // dp2[i] is the min difficulty of the schedule that ends at job i\\n                    // and the max difficulty of the last day is jobDifficulty[i]\\n                    stack.push(i);\\n                }\\n            }\\n            dp = dp2;\\n        }\\n        \\n        return dp[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2708837,
                "title": "memoized-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar as Partition DP problems.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPartition the array into d cuts and find the answer for each possible cut and take optimal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThere are n*d unique states to $$O(n*d)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUsed a dp array so  $$O((n+1)*(d+1))$$ and also recursion stack space\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index, vector<int>& a,int d,vector<vector<int>>& dp){\\n        int n = a.size();\\n        if(d==1){\\n            int mx = a[index];\\n            for(int i=index;i<n;i++){\\n                mx = max(mx,a[i]);\\n            }\\n            return mx;\\n        }\\n        if(dp[index][d]!=-1) return dp[index][d];\\n        int mx = INT_MIN;\\n        int ans = INT_MAX;\\n        for(int i=index;i<=n-d;i++){\\n            mx= max(mx,a[i]);\\n            ans = min(ans,mx + solve(i+1,a,d-1,dp));\\n        }\\n        return dp[index][d] = ans;\\n\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n<d) return -1;\\n        vector<vector<int>> dp(n+1,vector<int>(d+1,-1));\\n        return solve(0,jobDifficulty,d,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index, vector<int>& a,int d,vector<vector<int>>& dp){\\n        int n = a.size();\\n        if(d==1){\\n            int mx = a[index];\\n            for(int i=index;i<n;i++){\\n                mx = max(mx,a[i]);\\n            }\\n            return mx;\\n        }\\n        if(dp[index][d]!=-1) return dp[index][d];\\n        int mx = INT_MIN;\\n        int ans = INT_MAX;\\n        for(int i=index;i<=n-d;i++){\\n            mx= max(mx,a[i]);\\n            ans = min(ans,mx + solve(i+1,a,d-1,dp));\\n        }\\n        return dp[index][d] = ans;\\n\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n<d) return -1;\\n        vector<vector<int>> dp(n+1,vector<int>(d+1,-1));\\n        return solve(0,jobDifficulty,d,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707961,
                "title": "java-100-5ms-2d-dp-solution-w-video-explanation",
                "content": "*Please **Upvote** if you find the Explanation Helpful*\\n\\n**Video Explanation**\\n[Minimum Difficulty of a Job Schedule | YouTube](https://www.youtube.com/watch?v=UmtyZGkL5rg&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//5ms\\n//TC: O(nnd)  n being length of jobDifficulty array\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len = jobDifficulty.length;\\n        if (d > len) return -1;\\n        int[][] minDifficulty = new int[d][len];\\n        for (int i = 1; i < d; i++) {\\n            Arrays.fill(minDifficulty[i], Integer.MAX_VALUE);\\n        }\\n        int maxDifficulty = 0;\\n        for (int i = 0; i <= len - d; i++) {\\n            maxDifficulty = Math.max(maxDifficulty, jobDifficulty[i]);\\n            minDifficulty[0][i] = maxDifficulty;\\n        }\\n        for (int day = 1; day < d; day++) {\\n            for (int to = day; to <= len - d + day; to++) {\\n                int currentDayDifficulty = jobDifficulty[to];\\n                int result = Integer.MAX_VALUE;\\n                for (int j = to - 1; j >= day - 1; j--) {\\n                    result = Math.min(result, minDifficulty[day - 1][j] + currentDayDifficulty);\\n                    currentDayDifficulty = Math.max(currentDayDifficulty, jobDifficulty[j]);\\n                }\\n                minDifficulty[day][to] = result;\\n            }   \\n        }\\n        return minDifficulty[d - 1][len - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//5ms\\n//TC: O(nnd)  n being length of jobDifficulty array\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len = jobDifficulty.length;\\n        if (d > len) return -1;\\n        int[][] minDifficulty = new int[d][len];\\n        for (int i = 1; i < d; i++) {\\n            Arrays.fill(minDifficulty[i], Integer.MAX_VALUE);\\n        }\\n        int maxDifficulty = 0;\\n        for (int i = 0; i <= len - d; i++) {\\n            maxDifficulty = Math.max(maxDifficulty, jobDifficulty[i]);\\n            minDifficulty[0][i] = maxDifficulty;\\n        }\\n        for (int day = 1; day < d; day++) {\\n            for (int to = day; to <= len - d + day; to++) {\\n                int currentDayDifficulty = jobDifficulty[to];\\n                int result = Integer.MAX_VALUE;\\n                for (int j = to - 1; j >= day - 1; j--) {\\n                    result = Math.min(result, minDifficulty[day - 1][j] + currentDayDifficulty);\\n                    currentDayDifficulty = Math.max(currentDayDifficulty, jobDifficulty[j]);\\n                }\\n                minDifficulty[day][to] = result;\\n            }   \\n        }\\n        return minDifficulty[d - 1][len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805374,
                "title": "readable-top-down-dp-beats-98",
                "content": "**RANT:** Why doesn\\'t anyone write readable DP solutions? I mean seriously, use some decent variable names.\\n\\n```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        jobs = jobDifficulty\\n        numDays = d\\n        \\n        @cache\\n        def minDifficultyHelper(currentJobDif, currentDay, jobIndex):\\n            jobsLeft = len(jobDifficulty) - jobIndex\\n            daysLeft = numDays - currentDay\\n            if(jobsLeft < daysLeft or currentDay > numDays):\\n                return float(\\'inf\\')\\n            \\n            if(jobIndex == len(jobDifficulty)):\\n                if(currentDay == numDays):\\n                    return currentJobDif\\n                return float(\\'inf\\')\\n            \\n            nextJobDif = jobs[jobIndex]\\n            ###do job today\\n            minCostToday = minDifficultyHelper(max(currentJobDif,nextJobDif), currentDay, jobIndex+1)\\n            ###do job tomorrow            \\n            minCostTomorrow = currentJobDif + minDifficultyHelper(nextJobDif, currentDay+1, jobIndex+1)\\n            \\n            return min(minCostToday, minCostTomorrow)\\n        \\n        \\n        currentDayDif = jobDifficulty[0]\\n        currentDay = 1\\n        jobIndex = 1\\n        \\n        minDifficulty = minDifficultyHelper(currentDayDif, currentDay, jobIndex)\\n        \\n        return -1 if minDifficulty == float(\\'inf\\') else minDifficulty\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        jobs = jobDifficulty\\n        numDays = d\\n        \\n        @cache\\n        def minDifficultyHelper(currentJobDif, currentDay, jobIndex):\\n            jobsLeft = len(jobDifficulty) - jobIndex\\n            daysLeft = numDays - currentDay\\n            if(jobsLeft < daysLeft or currentDay > numDays):\\n                return float(\\'inf\\')\\n            \\n            if(jobIndex == len(jobDifficulty)):\\n                if(currentDay == numDays):\\n                    return currentJobDif\\n                return float(\\'inf\\')\\n            \\n            nextJobDif = jobs[jobIndex]\\n            ###do job today\\n            minCostToday = minDifficultyHelper(max(currentJobDif,nextJobDif), currentDay, jobIndex+1)\\n            ###do job tomorrow            \\n            minCostTomorrow = currentJobDif + minDifficultyHelper(nextJobDif, currentDay+1, jobIndex+1)\\n            \\n            return min(minCostToday, minCostTomorrow)\\n        \\n        \\n        currentDayDif = jobDifficulty[0]\\n        currentDay = 1\\n        jobIndex = 1\\n        \\n        minDifficulty = minDifficultyHelper(currentDayDif, currentDay, jobIndex)\\n        \\n        return -1 if minDifficulty == float(\\'inf\\') else minDifficulty\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146288,
                "title": "dp",
                "content": "## \\u524D\\u63D0\\n1. task \\u5FC5\\u987B\\u8FDE\\u7740\\u505A\\n2. \\u6BCF\\u5929\\u81F3\\u5C11\\u6709\\u4E00\\u4E2Atask\\n\\n## \\u76F4\\u89C2\\u601D\\u8003\\n\\u6240\\u4EE5\\u8BF4\\u7ED9\\u6211\\u4EEC\\u7684task array\\u4F1A\\u88AB\\u5212\\u5206\\u6210\\u4E00\\u622A\\u4E00\\u622A\\uFF0C\\u5E76\\u4E14\\u53D6\\u6BCF\\u4E00\\u622A\\u6700\\u5927\\u7684\\u6570\\u3002\\n\\u6BD4\\u5982**\\u4F8B\\u5B50**\\u91CC \\u7ED9\\u7684\\uFF1A \\n[6, 5, 4, 3, 2, 1] \\u5982\\u679C\\u662F 3 \\u5929\\u7684\\u8BDD\\uFF0C\\u53EF\\u4EE5\\u88AB\\u5206\\u6210\\n[**6**, | **5**, |  **4**, 3, 2, 1] -> \\u7ED3\\u679C\\u662F 6 + 5 + 4 \\n[**6**, | **5** , 4, | **3**, 2, 1] -> \\u7ED3\\u679C\\u662F 5 + 5 + 3\\n[**6**, | **5**, 4, 3, | **2**, 1] -> \\u7ED3\\u679C\\u662F 6 + 5 + 2\\n....\\n\\u53EF\\u4EE5\\u770B\\u5230\\u60F3\\u6CD5\\u81EA\\u7136\\u662F\\u5C3D\\u91CF\\u628A\\u5927\\u7684\\u653E\\u5230\\u4E00\\u4E2A\\u6846\\u91CC\\u5C31\\u770B\\u6211\\u4EEC\\u600E\\u4E48\\u5207\\u5206\\uFF0C\\u4F46\\u662F\\u5982\\u679C\\u6211\\u4EEC\\u4E0D\\u904D\\u5386\\u6240\\u6709\\u5207\\u5206\\u65B9\\u5F0F\\u7684\\u8BDD\\u662F\\u4E0D\\u53EF\\u80FD\\u77E5\\u9053\\u6700\\u4F18\\u89E3\\u7684\\u6240\\u4EE5\\u8BF4\\u6700\\u76F4\\u89C2\\u7684\\u65B9\\u5F0F\\u5C31\\u662F\\u76F4\\u63A5\\u4F7F\\u7528**DFS**\\u3002\\n\\u6211\\u4EEC\\u89C4\\u5B9A\\u5269\\u4F59\\u591A\\u5C11\\u5929\\uFF0C\\u548C\\u591A\\u5C11\\u4E2A\\u4EFB\\u52A1\\u3002\\n\\u6BD4\\u5982\\u6211\\u4EEC\\u8FD8\\u52693 \\u5929 \\u4ECE index \\u4E3A 0 \\u7684\\u4EFB\\u52A1\\u5411\\u540E\\u904D\\u5386\\uFF0C \\u904D\\u5386\\u8FC7\\u7A0B\\u4E2D\\u4E0D\\u65AD\\u8BB0\\u5F55\\u6700\\u5927\\u503C\\uFF0C\\u7136\\u540E\\u770B\\u770B\\u5F53\\u524D\\u7684\\u6700\\u5927\\u503C + dfs\\uFF082\\u5929\\uFF0C \\u5F53\\u524D\\u4EFB\\u52A1index + 1\\uFF09 \\u662F\\u4E0D\\u662F\\u5F53\\u524D\\u5929\\u6700\\u5C0F\\u503C\\u3002\\n\\u5199\\u6210psudo code\\u5C31\\u662F\\n```\\n\\t//currentMax \\u4EE3\\u8868 \\u5F53\\u524D\\u5929\\u9047\\u5230\\u7684\\u6700\\u5927\\u503C\\n\\tdfs(left_days, start_index){\\n\\t\\tfor(int i = start index; i < array size; i++)\\n\\t\\t\\tcurrentMax = max(currentMax, array[i])\\n\\t\\t\\tres = min(res, currentMax + dfs(left_days - 1, start_index + 1)\\n\\t}\\n```\\n\\u4F46\\u662F\\u8FD9\\u4E48\\u505A\\u7684\\u4E00\\u4E2A\\u95EE\\u9898\\u5C31\\u662F\\u4F1A\\u6709\\u5F88\\u591A\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u5047\\u8BBE\\u6709n\\u5929\\uFF0Carray size\\u4E3Ak worst\\u6709 -> O(n^k).\\n\\u6240\\u4EE5\\u8BF4\\u4E3A\\u4E86\\u907F\\u514D\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u9700\\u8981\\u52A0\\u4E0Amemo\\u6765\\u8BB0\\u5F55\\u5BF9\\u5E94\\u7684\\u5929\\u548C\\u5269\\u4F59index\\u7684\\u6700\\u4F18\\u503C, \\u5BF9\\u4E8E\\u6BCF\\u4E2Aindex \\u6211\\u4EEC\\u8981 traverse n\\u6B21 \\u6211\\u4EEC\\u6709 n\\u4E2A index\\uFF0C\\u540C\\u6837recursion\\u662F\\u4E3Ak \\u5929 \\u6240\\u4EE5\\u4F18\\u5316\\u540E\\u7684amortized\\u7ED3\\u679C\\u4E3A O\\uFF08nnk\\uFF09\\u3002\\n\\n## \\u53CD\\u5411\\u601D\\u8003\\n\\u65E2\\u7136 \\u770B\\u5230\\u4E86top - bottom\\uFF0C\\u73B0\\u5728\\u53EF\\u4EE5\\u601D\\u8003\\u4E00\\u4E0Bbottom - up\\uFF0C \\u5229\\u7528\\u4E4B\\u524D\\u4E00\\u5929\\u627E\\u5230\\u7684\\u6700\\u5C0F\\u7ED3\\u679C\\u627E\\u4E0B\\u4E00\\u5929\\u7684\\u7ED3\\u679C\\u3002\\n\\u6240\\u4EE5\\u5047\\u8BBE\\u6211\\u4EEC2d array \\u4E3A dp[day][ array_index] \\n```\\n\\t//\\u63A8\\u5BFC\\u516C\\u5F0F\\u5C31\\u662F\\n\\tdp[day][array_index] = min(dp[day -1][array_index - 1] + currentMax)//arrayIndex range [d, arrayIndex], currentMax \\u968F\\u7740range\\u800C\\u6539\\u53D8\\n```\\n\\n## \\u6700\\u7EC8\\u4F18\\u5316\\n\\u901A\\u8FC7\\u8FD9\\u79CD\\u65B9\\u5F0F\\u6211\\u4EEC\\u53EF\\u4EE5\\u770B\\u5230\\u6211\\u4EEC\\u5176\\u5B9E\\u53EA\\u9700\\u8981\\u524D\\u4E00\\u5929\\u7684\\u6240\\u6709\\u7ED3\\u679C\\u6240\\u4EE5\\u53EF\\u4EE5\\u628A\\u7ED3\\u679C\\u62CD\\u6241\\n\\n(\\u6709\\u7A7A\\u53EF\\u4EE5\\u76F4\\u63A5\\u770B\\u524D\\u4EBA\\u7684code\\uFF0C\\u8FD9\\u91CC\\u53EA\\u662F\\u65B9\\u4FBF\\u590D\\u4E60\\u601D\\u8003\\u8FC7\\u7A0B\\uFF09\\n",
                "solutionTags": [],
                "code": "```\\n\\t//currentMax \\u4EE3\\u8868 \\u5F53\\u524D\\u5929\\u9047\\u5230\\u7684\\u6700\\u5927\\u503C\\n\\tdfs(left_days, start_index){\\n\\t\\tfor(int i = start index; i < array size; i++)\\n\\t\\t\\tcurrentMax = max(currentMax, array[i])\\n\\t\\t\\tres = min(res, currentMax + dfs(left_days - 1, start_index + 1)\\n\\t}\\n```\n```\\n\\t//\\u63A8\\u5BFC\\u516C\\u5F0F\\u5C31\\u662F\\n\\tdp[day][array_index] = min(dp[day -1][array_index - 1] + currentMax)//arrayIndex range [d, arrayIndex], currentMax \\u968F\\u7740range\\u800C\\u6539\\u53D8\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598603,
                "title": "recursion-memoization-top-down-dp",
                "content": "I think it is not very hard to come up with the brute force approach. We need to check all the possibilities and select the minimum. \\n``` \\n\\n    int minDifficulty(vector<int>& jobDifficulty, int d)\\n    {\\n        int value =  minDifficulty(jobDifficulty, 0, d);\\n        return value == INT_MAX? -1: value;\\n    }\\n    \\n    \\n    int minDifficulty(const vector<int>& jobs, int i, int d)\\n    {\\n        if( i == jobs.size() && d == 0)\\n            return 0; \\n        else if(d==0)\\n            return 300000;\\n        \\n        int minVal = INT_MAX;\\n        \\n        int curMax = INT_MIN;\\n        \\n        for(int j = i; j+d <= jobs.size(); ++j)\\n        {\\n            curMax = max(curMax, jobs[j]);\\n            minVal = min(minVal, minDifficulty(jobs, j+1, d-1)+ curMax);\\n        }\\n        \\n        return minVal;\\n    }\\n\\n```\\n\\nOnce you have the brute force recursion, it is much easier to add memoization. Only thing to care about is the state, as we can see above code, i and d define the states. \\n\\n```\\n\\n int minDifficulty(vector<int>& jobDifficulty, int d)\\n    {\\n        vector<vector<int>> memo(jobDifficulty.size(), vector<int>(d+1, -1));\\n        int value =  minDifficulty(memo, jobDifficulty, 0, d);\\n        return value == INT_MAX? -1: value;\\n    }\\n    \\n    \\n    int minDifficulty(vector<vector<int>>& memo, const vector<int>& jobs, int i, int d)\\n    {\\n        if( i == jobs.size() && d == 0)\\n            return 0; \\n        else if(d==0)\\n            return 300000;\\n        \\n        if(memo[i][d]!=-1)\\n            return memo[i][d];\\n        \\n        int minVal = INT_MAX;\\n        \\n        int curMax = INT_MIN;\\n        \\n        for(int j = i; j+d <= jobs.size(); ++j)\\n        {\\n            curMax = max(curMax, jobs[j]);\\n            minVal = min(minVal, minDifficulty(memo, jobs, j+1, d-1)+ curMax);\\n        }\\n        \\n        memo[i][d] = minVal;\\n        return memo[i][d];\\n    }\\n\\n```\\n\\nTop-down DP just follows the memoization.\\n\\n```\\n    int minDifficulty(vector<int>& jobDifficulty, int D)\\n    {\\n        int len = jobDifficulty.size()+1;\\n        vector<vector<int>> dp(jobDifficulty.size()+1, vector<int>(D+1, INT_MAX));\\n        dp[len-1][0] = 0;\\n        \\n        for(int i = 0; i < len-1; ++i)\\n            dp[i][0] = 300000;\\n        \\n        for(int d = 1; d <= D; ++d)\\n            for(int i = 0; i < len-1; ++i)\\n            {\\n               int curMax = INT_MIN;\\n                for(int j = i; j+d <=(len-1); ++j)\\n                {\\n                    curMax = max(curMax, jobDifficulty[j]);\\n                    dp[i][d] = min(dp[i][d], dp[j+1][d-1] + curMax);\\n                }\\n            }\\n        \\n        return dp[0][D] == INT_MAX? -1 : dp[0][D];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "``` \\n\\n    int minDifficulty(vector<int>& jobDifficulty, int d)\\n    {\\n        int value =  minDifficulty(jobDifficulty, 0, d);\\n        return value == INT_MAX? -1: value;\\n    }\\n    \\n    \\n    int minDifficulty(const vector<int>& jobs, int i, int d)\\n    {\\n        if( i == jobs.size() && d == 0)\\n            return 0; \\n        else if(d==0)\\n            return 300000;\\n        \\n        int minVal = INT_MAX;\\n        \\n        int curMax = INT_MIN;\\n        \\n        for(int j = i; j+d <= jobs.size(); ++j)\\n        {\\n            curMax = max(curMax, jobs[j]);\\n            minVal = min(minVal, minDifficulty(jobs, j+1, d-1)+ curMax);\\n        }\\n        \\n        return minVal;\\n    }\\n\\n```\n```\\n\\n int minDifficulty(vector<int>& jobDifficulty, int d)\\n    {\\n        vector<vector<int>> memo(jobDifficulty.size(), vector<int>(d+1, -1));\\n        int value =  minDifficulty(memo, jobDifficulty, 0, d);\\n        return value == INT_MAX? -1: value;\\n    }\\n    \\n    \\n    int minDifficulty(vector<vector<int>>& memo, const vector<int>& jobs, int i, int d)\\n    {\\n        if( i == jobs.size() && d == 0)\\n            return 0; \\n        else if(d==0)\\n            return 300000;\\n        \\n        if(memo[i][d]!=-1)\\n            return memo[i][d];\\n        \\n        int minVal = INT_MAX;\\n        \\n        int curMax = INT_MIN;\\n        \\n        for(int j = i; j+d <= jobs.size(); ++j)\\n        {\\n            curMax = max(curMax, jobs[j]);\\n            minVal = min(minVal, minDifficulty(memo, jobs, j+1, d-1)+ curMax);\\n        }\\n        \\n        memo[i][d] = minVal;\\n        return memo[i][d];\\n    }\\n\\n```\n```\\n    int minDifficulty(vector<int>& jobDifficulty, int D)\\n    {\\n        int len = jobDifficulty.size()+1;\\n        vector<vector<int>> dp(jobDifficulty.size()+1, vector<int>(D+1, INT_MAX));\\n        dp[len-1][0] = 0;\\n        \\n        for(int i = 0; i < len-1; ++i)\\n            dp[i][0] = 300000;\\n        \\n        for(int d = 1; d <= D; ++d)\\n            for(int i = 0; i < len-1; ++i)\\n            {\\n               int curMax = INT_MIN;\\n                for(int j = i; j+d <=(len-1); ++j)\\n                {\\n                    curMax = max(curMax, jobDifficulty[j]);\\n                    dp[i][d] = min(dp[i][d], dp[j+1][d-1] + curMax);\\n                }\\n            }\\n        \\n        return dp[0][D] == INT_MAX? -1 : dp[0][D];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777808,
                "title": "c-solution-using-dp-with-memoization-clean-code-with-simple-idea",
                "content": "In this problem we need to partition our array into **d** subarrays and we need to take the maximum of those d subarrays and add them to get a sum **S**. The main aim is to minimise this sum **S**.\\n\\nIn order to solve this problem we should try all the possibilites to partition the array into d subarrays and at same time compute the maximum of those d-subarrays and add them. The final step being taking the minimum of those sums generated.\\n\\n```\\n/*\\n\\nidea : Select d subarrays and take the sum of max across all those subarrays and find the minimum sum obtained.\\n\\n*/\\n\\nint dp[301][11];\\nclass Solution {\\n    int n;\\n    int solve(int i,int j,vector<int>& jd, int d){\\n        if(j>d){\\n            return 1e9;\\n        }\\n        if(i==n){\\n            if(j==d){\\n                return 0;\\n            }\\n            else{\\n                return 1e9;\\n            }\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=1e9;\\n        int mx=jd[i];\\n        for(int k=i;k<n;k++){\\n            mx=max(mx,jd[k]);    // simultaneously determining the maximum of the subarray.\\n            ans=min(ans,mx+solve(k+1,j+1,jd,d));   //deciding where to start a new partition from , here : new partition starts from k+1.This means the subarray we choose starts from i and ends at k ,i,e jd[i..k] and thats why we incremented j i.e j+1 by this we increased the count of subarrays choosen.  \\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jd, int d) {\\n        \\n        n=jd.size();\\n        if(d>n){\\n            return -1;\\n        }\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=d;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int res=solve(0,0,jd,d);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\n\\nidea : Select d subarrays and take the sum of max across all those subarrays and find the minimum sum obtained.\\n\\n*/\\n\\nint dp[301][11];\\nclass Solution {\\n    int n;\\n    int solve(int i,int j,vector<int>& jd, int d){\\n        if(j>d){\\n            return 1e9;\\n        }\\n        if(i==n){\\n            if(j==d){\\n                return 0;\\n            }\\n            else{\\n                return 1e9;\\n            }\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=1e9;\\n        int mx=jd[i];\\n        for(int k=i;k<n;k++){\\n            mx=max(mx,jd[k]);    // simultaneously determining the maximum of the subarray.\\n            ans=min(ans,mx+solve(k+1,j+1,jd,d));   //deciding where to start a new partition from , here : new partition starts from k+1.This means the subarray we choose starts from i and ends at k ,i,e jd[i..k] and thats why we incremented j i.e j+1 by this we increased the count of subarrays choosen.  \\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jd, int d) {\\n        \\n        n=jd.size();\\n        if(d>n){\\n            return -1;\\n        }\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=d;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int res=solve(0,0,jd,d);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708958,
                "title": "c-dp-memoization-faster-easy-to-understand",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * N * K)***\\n\\n* ***Space Complexity :- O(N * K)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[305][15];\\n    \\n    int helper(vector<int>& arr, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n && k == 0)\\n            return 0;\\n        \\n        // if exactly k partition is not possible\\n        \\n        if(k <= 0)\\n            return INT_MAX;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        // maxi will store the maximum of subarray taken\\n        \\n        int maxi = 0;\\n        \\n        // mini will store the minimum difficulty\\n        \\n        int mini = INT_MAX;\\n        \\n        // partition the array between [i, n - 1] and call for remaining elements\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            // update maxi\\n            \\n            maxi = max(maxi, arr[j]);\\n            \\n            // call for remaining elements\\n            \\n            int temp = helper(arr, j + 1, n, k - 1);\\n            \\n            // if it possible to partition into exactly k subarrays, then update mini\\n            \\n            if(temp != INT_MAX)\\n            {\\n                mini = min(mini, maxi + temp);\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i][k] = mini;\\n    }\\n    \\n    int minDifficulty(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        int mini = helper(arr, 0, n, k);\\n        \\n        // if it is not possible to partition into exactly k subarrays\\n        \\n        if(mini == INT_MAX)\\n            return -1;\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[305][15];\\n    \\n    int helper(vector<int>& arr, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n && k == 0)\\n            return 0;\\n        \\n        // if exactly k partition is not possible\\n        \\n        if(k <= 0)\\n            return INT_MAX;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        // maxi will store the maximum of subarray taken\\n        \\n        int maxi = 0;\\n        \\n        // mini will store the minimum difficulty\\n        \\n        int mini = INT_MAX;\\n        \\n        // partition the array between [i, n - 1] and call for remaining elements\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            // update maxi\\n            \\n            maxi = max(maxi, arr[j]);\\n            \\n            // call for remaining elements\\n            \\n            int temp = helper(arr, j + 1, n, k - 1);\\n            \\n            // if it possible to partition into exactly k subarrays, then update mini\\n            \\n            if(temp != INT_MAX)\\n            {\\n                mini = min(mini, maxi + temp);\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i][k] = mini;\\n    }\\n    \\n    int minDifficulty(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        int mini = helper(arr, 0, n, k);\\n        \\n        // if it is not possible to partition into exactly k subarrays\\n        \\n        if(mini == INT_MAX)\\n            return -1;\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985532,
                "title": "java-dp-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (d > n) return -1;\\n        \\n        \\n        int[][] dp = new int[d][n];\\n        \\n        // Initialize dp for single day\\n        dp[0][0] = jobDifficulty[0];\\n        for (int j = 1; j < n; j++) {\\n            dp[0][j] = Math.max(dp[0][j - 1], jobDifficulty[j]);\\n        }\\n        \\n        // For each day\\n        for (int i = 1; i < d; i++) {\\n            \\n            // For each job\\n            for (int j = i; j < n; j++) {\\n                \\n                // init day max difficulty to current job.\\n                int dayMax = jobDifficulty[j];\\n                // init min cost to previous day job j-1 + dayMax\\n                int minCost = dp[i-1][j-1] + dayMax;\\n                \\n                // Travel backwards over the jobs, updating dayMax and recalculating the minCost \\n                for (int k = j-1; k >= i; k--) {\\n\\n                    // update max difficulty if jobs j where k <= j < n\\n                    dayMax = Math.max(dayMax, jobDifficulty[k]);\\n                    // update minCost of dayMax plus previous day of jobs j s.t. k < j\\n                    minCost = Math.min(minCost, dp[i-1][k-1] + dayMax);\\n                }\\n                \\n                // Set minCost of day i for all jobs up to j\\n                dp[i][j] = minCost;\\n            }\\n        }\\n        // return final minCost of all jobs at last day\\n        return dp[d-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (d > n) return -1;\\n        \\n        \\n        int[][] dp = new int[d][n];\\n        \\n        // Initialize dp for single day\\n        dp[0][0] = jobDifficulty[0];\\n        for (int j = 1; j < n; j++) {\\n            dp[0][j] = Math.max(dp[0][j - 1], jobDifficulty[j]);\\n        }\\n        \\n        // For each day\\n        for (int i = 1; i < d; i++) {\\n            \\n            // For each job\\n            for (int j = i; j < n; j++) {\\n                \\n                // init day max difficulty to current job.\\n                int dayMax = jobDifficulty[j];\\n                // init min cost to previous day job j-1 + dayMax\\n                int minCost = dp[i-1][j-1] + dayMax;\\n                \\n                // Travel backwards over the jobs, updating dayMax and recalculating the minCost \\n                for (int k = j-1; k >= i; k--) {\\n\\n                    // update max difficulty if jobs j where k <= j < n\\n                    dayMax = Math.max(dayMax, jobDifficulty[k]);\\n                    // update minCost of dayMax plus previous day of jobs j s.t. k < j\\n                    minCost = Math.min(minCost, dp[i-1][k-1] + dayMax);\\n                }\\n                \\n                // Set minCost of day i for all jobs up to j\\n                dp[i][j] = minCost;\\n            }\\n        }\\n        // return final minCost of all jobs at last day\\n        return dp[d-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907494,
                "title": "java-dp-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    /*\\n    Let\\'s say f(i, j) is the `minimum difficulty` on day i and when getting first j jobs done.\\n    The number of jobs has been done from previous day would affect the result of f(i, j).\\n    \\n\\tIf we have k jobs done on i - 1 day, then we have the following formula:\\n        f(i, j) = f(i - 1, k) + (max of jobDifficulty between [k+1 : j])\\n\\n     */\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length == 0) return 0;\\n        // There are not enough jobs to make \"at least one task every day\"\\n        if (jobDifficulty.length < d) return -1;\\n\\n        int n = jobDifficulty.length;\\n\\n        int[][] f = new int[d + 1][n + 1];\\n        // init\\n        for (int[] r: f) Arrays.fill(r, 1000 * d);\\n        f[0][0] = 0;  // The minimum difficulty on day 0 to get 0 job done is 0\\n\\n        for (int i = 1; i <= d; i ++) {  // starting from day 1\\n            // j starts from i that is because there must have at least i jobs to be done on day i\\n            // n - j >= d - i means we need to leave enough jobs for rest of days\\n\\t\\t\\t// n - j is the jobs left AND d - i is the days left\\n            for (int j = i; n - j >= d - i; j++) {\\n                // On i - 1 day could finish [i - 1, j - 1] jobs\\n                for (int k = i - 1; k <= j - 1; k++) {\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][k] + max(jobDifficulty, k + 1, j));\\n                }\\n            }\\n        }\\n\\n        return f[d][n];\\n    }\\n\\n    // O(n)\\n    private int max(int[] jobDifficulty, int fromJob, int toJob) {\\n        int max = 0;\\n        // fromJob is the ith job, not the 0 based index, so we need fromJob|toJob - 1\\n        for (int i = fromJob - 1; i <= toJob - 1; i++) {\\n            max = Math.max(max, jobDifficulty[i]);\\n        }\\n        return max;\\n    }\\n\\n======================================================================\\n    /*\\n    Improvement\\n\\n    max(jobDifficulty, k + 1, j) is liner time complexity which is not good.\\n\\n    We could improve it by changing the loop direction from k++ to k--, so that if we know the max of [a, b], we could\\n    easily get the max of [a - 1, b] by using Math.max(jobDifficulty[a - 1], preMax);\\n     */\\n\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length == 0) return 0;\\n        // There are not enough jobs to make \"at least one task every day\"\\n        if (jobDifficulty.length < d) return -1;\\n\\n        int n = jobDifficulty.length;\\n\\n        int[][] f = new int[d + 1][n + 1];\\n        // init\\n        for (int[] r: f) Arrays.fill(r, 1000 * d);\\n        f[0][0] = 0;  // The minimum difficulty on day 0 to get 0 job done is 0\\n\\n        for (int i = 1; i <= d; i ++) {\\n            for (int j = i; n - j >= d - i; j++) {\\n\\t\\t\\t    int currMax = jobDifficulty[j - 1];\\n                for (int k = j - 1; k >= i - 1; k--) {\\n                    currMax = Math.max(jobDifficulty[k], currMax);  // jobDifficulty[k] means the job difficulty of (k + 1)th job, converted to be 0-index based\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][k] + currMax);\\n                }\\n            }\\n        }\\n\\n        return f[d][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Let\\'s say f(i, j) is the `minimum difficulty` on day i and when getting first j jobs done.\\n    The number of jobs has been done from previous day would affect the result of f(i, j).\\n    \\n\\tIf we have k jobs done on i - 1 day, then we have the following formula:\\n        f(i, j) = f(i - 1, k) + (max of jobDifficulty between [k+1 : j])\\n\\n     */\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length == 0) return 0;\\n        // There are not enough jobs to make \"at least one task every day\"\\n        if (jobDifficulty.length < d) return -1;\\n\\n        int n = jobDifficulty.length;\\n\\n        int[][] f = new int[d + 1][n + 1];\\n        // init\\n        for (int[] r: f) Arrays.fill(r, 1000 * d);\\n        f[0][0] = 0;  // The minimum difficulty on day 0 to get 0 job done is 0\\n\\n        for (int i = 1; i <= d; i ++) {  // starting from day 1\\n            // j starts from i that is because there must have at least i jobs to be done on day i\\n            // n - j >= d - i means we need to leave enough jobs for rest of days\\n\\t\\t\\t// n - j is the jobs left AND d - i is the days left\\n            for (int j = i; n - j >= d - i; j++) {\\n                // On i - 1 day could finish [i - 1, j - 1] jobs\\n                for (int k = i - 1; k <= j - 1; k++) {\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][k] + max(jobDifficulty, k + 1, j));\\n                }\\n            }\\n        }\\n\\n        return f[d][n];\\n    }\\n\\n    // O(n)\\n    private int max(int[] jobDifficulty, int fromJob, int toJob) {\\n        int max = 0;\\n        // fromJob is the ith job, not the 0 based index, so we need fromJob|toJob - 1\\n        for (int i = fromJob - 1; i <= toJob - 1; i++) {\\n            max = Math.max(max, jobDifficulty[i]);\\n        }\\n        return max;\\n    }\\n\\n======================================================================\\n    /*\\n    Improvement\\n\\n    max(jobDifficulty, k + 1, j) is liner time complexity which is not good.\\n\\n    We could improve it by changing the loop direction from k++ to k--, so that if we know the max of [a, b], we could\\n    easily get the max of [a - 1, b] by using Math.max(jobDifficulty[a - 1], preMax);\\n     */\\n\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (jobDifficulty == null || jobDifficulty.length == 0) return 0;\\n        // There are not enough jobs to make \"at least one task every day\"\\n        if (jobDifficulty.length < d) return -1;\\n\\n        int n = jobDifficulty.length;\\n\\n        int[][] f = new int[d + 1][n + 1];\\n        // init\\n        for (int[] r: f) Arrays.fill(r, 1000 * d);\\n        f[0][0] = 0;  // The minimum difficulty on day 0 to get 0 job done is 0\\n\\n        for (int i = 1; i <= d; i ++) {\\n            for (int j = i; n - j >= d - i; j++) {\\n\\t\\t\\t    int currMax = jobDifficulty[j - 1];\\n                for (int k = j - 1; k >= i - 1; k--) {\\n                    currMax = Math.max(jobDifficulty[k], currMax);  // jobDifficulty[k] means the job difficulty of (k + 1)th job, converted to be 0-index based\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][k] + currMax);\\n                }\\n            }\\n        }\\n\\n        return f[d][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490259,
                "title": "c-minimum-sum-partition-with-dp-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobs, int d) {\\n        \\n        /**\\n            Minimum Sum Partition Problem:\\n        \\n            dp[i][j]: The minimum cost to finish the first j jobs in the first i days.\\n            \\n            dp[i][j] =  MIN { dp[i - 1][k] + MAX(difficulty[k + 1][j]) }\\n                      i-1<=k<j \\n        */\\n        \\n        int n = jobs.size();\\n        if (d > n) {\\n            return -1;\\n        }\\n        \\n        vector<vector<int>> cost(n, vector<int>(n, 0));\\n        for (int i = 0 ; i < n ; ++i) {\\n            cost[i][i] = jobs[i];\\n        }\\n        for (int l = 2 ; l <= n ; ++l) {\\n            for (int i = 0, j = i + l - 1 ; i <= n - l ; ++i, ++j) {\\n                cost[i][j] = max(cost[i][j - 1], jobs[j]);\\n            }\\n        }\\n        \\n        vector<vector<int>> dp(d, vector<int>(n, 0));\\n        for (int i = 0 ; i < n ; ++i) {\\n            dp[0][i] = cost[0][i];\\n        }\\n        \\n        for (int i = 1 ; i < d ; ++i) {\\n            for (int j = i ; j < n ; ++j) {\\n                int opt = INT_MAX;\\n                \\n                for (int k = i - 1 ; k < j ; ++k) {\\n                    int sum = dp[i - 1][k] + cost[k + 1][j];\\n                    opt = min(opt, sum);\\n                }\\n                \\n                dp[i][j] = opt;\\n            }\\n        }\\n        \\n        return dp[d - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobs, int d) {\\n        \\n        /**\\n            Minimum Sum Partition Problem:\\n        \\n            dp[i][j]: The minimum cost to finish the first j jobs in the first i days.\\n            \\n            dp[i][j] =  MIN { dp[i - 1][k] + MAX(difficulty[k + 1][j]) }\\n                      i-1<=k<j \\n        */\\n        \\n        int n = jobs.size();\\n        if (d > n) {\\n            return -1;\\n        }\\n        \\n        vector<vector<int>> cost(n, vector<int>(n, 0));\\n        for (int i = 0 ; i < n ; ++i) {\\n            cost[i][i] = jobs[i];\\n        }\\n        for (int l = 2 ; l <= n ; ++l) {\\n            for (int i = 0, j = i + l - 1 ; i <= n - l ; ++i, ++j) {\\n                cost[i][j] = max(cost[i][j - 1], jobs[j]);\\n            }\\n        }\\n        \\n        vector<vector<int>> dp(d, vector<int>(n, 0));\\n        for (int i = 0 ; i < n ; ++i) {\\n            dp[0][i] = cost[0][i];\\n        }\\n        \\n        for (int i = 1 ; i < d ; ++i) {\\n            for (int j = i ; j < n ; ++j) {\\n                int opt = INT_MAX;\\n                \\n                for (int k = i - 1 ; k < j ; ++k) {\\n                    int sum = dp[i - 1][k] + cost[k + 1][j];\\n                    opt = min(opt, sum);\\n                }\\n                \\n                dp[i][j] = opt;\\n            }\\n        }\\n        \\n        return dp[d - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708948,
                "title": "c-bottom-up-dp",
                "content": "```\\nn -> size of jobDifficulty.\\n\\nTime Complexity - O(n*n*days)\\nSpace Complexity - O(n*days)\\n\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int days) {\\n        int n=jobDifficulty.size();\\n        vector<vector<int>> dp(n+1,vector<int>(days+1,INT_MAX));\\n        //dp[i][j] -> minimum difficulty to schedule [0..i-1] jobs in j days.\\n        dp[0][0]=0;\\n        for(int i=1;i<=n;i++){\\n            int maxi=jobDifficulty[i-1]; // maxi will keep track of maximum jobDifficulty[j...i-1]\\n            for(int j=i-1;j>=0;j--){\\n                for(int d=1;d<=days;d++)\\n                    if(dp[j][d-1]!=INT_MAX)\\n                        dp[i][d]=min(dp[i][d],dp[j][d-1]+maxi);\\n                \\n                if(j-1>=0)\\n                    maxi=max(maxi,jobDifficulty[j-1]);\\n            }\\n        }\\n        \\n        return dp[n][days]==INT_MAX?-1:dp[n][days];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nn -> size of jobDifficulty.\\n\\nTime Complexity - O(n*n*days)\\nSpace Complexity - O(n*days)\\n\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int days) {\\n        int n=jobDifficulty.size();\\n        vector<vector<int>> dp(n+1,vector<int>(days+1,INT_MAX));\\n        //dp[i][j] -> minimum difficulty to schedule [0..i-1] jobs in j days.\\n        dp[0][0]=0;\\n        for(int i=1;i<=n;i++){\\n            int maxi=jobDifficulty[i-1]; // maxi will keep track of maximum jobDifficulty[j...i-1]\\n            for(int j=i-1;j>=0;j--){\\n                for(int d=1;d<=days;d++)\\n                    if(dp[j][d-1]!=INT_MAX)\\n                        dp[i][d]=min(dp[i][d],dp[j][d-1]+maxi);\\n                \\n                if(j-1>=0)\\n                    maxi=max(maxi,jobDifficulty[j-1]);\\n            }\\n        }\\n        \\n        return dp[n][days]==INT_MAX?-1:dp[n][days];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708826,
                "title": "how-to-approach-a-general-tip-for-solutions",
                "content": "Instead of posting specific solution to this problem first, I want to highlight a general idea on how to approach such problems using recursion\\n\\nIdentify:\\nIn such problems typically, we need to construct \"groups\" which are \"subarrays\". Please notice how the constraint that the ith job can be only done when previous jth day jobs (j<i) have already been constructed. This marks the main distinctive property of such problems. Identify \"groups\" which are also subarrays. Also notice how this is a daily problem for 16th Oct, 2022 and the previous day\\'s daily problem was https://leetcode.com/problems/string-compression-ii/ which uses an eerily similar approach. Try to identify the same pattern in that problem as well. Also you will notice, the constraint for these problems are typically <=100 or so. \\n\\nApproach:\\nNow that we have identified the pattern, the way to approach them is recursion with memoization (or tabulation). I like doing it with memoization cause in my mind I have a recursion pattern already built out. Alright, now let\\'s think of it as the problem for nums[0..i-1] is already solved and I  just need to find the solution for nums[i...n-1]. This is the \"invariant\". Focus only on the part I am \"yet\" to solve that is nums[i....n-1]. I can place a cut anywhere from i to n-1 i.e. at i, i+1, i+2... upto n-1, let\\'s call the position where I place it as \"cut\". The left cut group is then nums[i..cut] and the right group is nums[cut+1...n-1]. For the left cut part for  this problem is just the max element seen till now. The right cut part can be recursively solved  by calling the recursive method for cut+1. Now the entire solution for nums[i...n-1] is the minimum of solutions with cut placed at each position. And voila, write some simple base cases and we are done! \\n\\nFollow my approach while reading the solution to this problem below: \\n```\\nclass Solution {\\npublic:\\n    int solve(int left, int d, int n, vector<int>& jobDifficulty, vector<vector<int>>& dp){\\n        if(d==0 && left==n)\\n            return 0;\\n        //this means days left to be schedule but no jobs\\n        // or jobs left to be scheduled but no days left\\n        if(d==0 || left==n)\\n            return INT_MAX;\\n        if(dp[left][d]!=-1)\\n            return dp[left][d];\\n        int currMax = jobDifficulty[left], restMax, res=INT_MAX;\\n        for(int i = left; i<n;i++){\\n            currMax = max(currMax, jobDifficulty[i]);\\n            restMax = solve(i+1, d-1, n, jobDifficulty, dp);\\n            if(restMax!=INT_MAX)\\n                res = min(res, currMax + restMax);\\n        }\\n        \\n        dp[left][d] = res;\\n        \\n        return dp[left][d];\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        vector<vector<int>>dp(n, vector<int>(d+1, -1));\\n        if(n<d)\\n            return -1;\\n        return solve(0, d, n, jobDifficulty, dp);\\n        \\n        //return dp[n-1][d];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int left, int d, int n, vector<int>& jobDifficulty, vector<vector<int>>& dp){\\n        if(d==0 && left==n)\\n            return 0;\\n        //this means days left to be schedule but no jobs\\n        // or jobs left to be scheduled but no days left\\n        if(d==0 || left==n)\\n            return INT_MAX;\\n        if(dp[left][d]!=-1)\\n            return dp[left][d];\\n        int currMax = jobDifficulty[left], restMax, res=INT_MAX;\\n        for(int i = left; i<n;i++){\\n            currMax = max(currMax, jobDifficulty[i]);\\n            restMax = solve(i+1, d-1, n, jobDifficulty, dp);\\n            if(restMax!=INT_MAX)\\n                res = min(res, currMax + restMax);\\n        }\\n        \\n        dp[left][d] = res;\\n        \\n        return dp[left][d];\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        vector<vector<int>>dp(n, vector<int>(d+1, -1));\\n        if(n<d)\\n            return -1;\\n        return solve(0, d, n, jobDifficulty, dp);\\n        \\n        //return dp[n-1][d];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707706,
                "title": "daily-leetcoding-challenge-october-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-down DP\n\n  \n**Approach 2:** Bottom-up 2D DP\n\n  \n**Approach 3:** Bottom-up 1D DP\n\n  \n**Approach 4:** Monotonic Stack - Better Time Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1038135,
                "title": "java-dp-bottom-up-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int leng =  jobDifficulty.length;\\n        if (leng < d) return -1;\\n        \\n        int[][] dp = new int[d][leng]; // two D array\\n        dp[0][0] = jobDifficulty[0];\\n        for (int i = 1; i < leng; i++) { // initialte first row\\n            dp[0][i] = Math.max(dp[0][i - 1], jobDifficulty[i]);\\n        }\\n        \\n        /**\\n        At position x, y, assume x = 2, y = 4 we have\\n        dp[x - 1] = dp[1] = [0,b,c,d,e,f]; // first x number in this row should be 0, because tasks finish in x days must >= x\\n                    dp[2] = [0,0,p,q,r,s];\\n            jobDifficulty = [h,i,j,k,l,m]; \\n        \\n        the value we want to get is \"r\": there are 3 position to sperate the row:\\n            between k and l: candidate1 = d + l;\\n            between j and k: candidate2 = c + Max(k, l);\\n            between i and j: candidate3 = b + Max(j, k, l);\\n            r = Min(candiate1, candidate2, candidate3);\\n        **/\\n        for (int i = 1 ; i < d; i++) { // deduct following row\\n            for (int j = i; j < leng; j++) {\\n                int max = 0;\\n                int min = Integer.MAX_VALUE;\\n                for (int k = j; k >= i; k--) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    min = Math.min(min, dp[i - 1][k - 1] + max);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[d - 1][leng - 1];   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int leng =  jobDifficulty.length;\\n        if (leng < d) return -1;\\n        \\n        int[][] dp = new int[d][leng]; // two D array\\n        dp[0][0] = jobDifficulty[0];\\n        for (int i = 1; i < leng; i++) { // initialte first row\\n            dp[0][i] = Math.max(dp[0][i - 1], jobDifficulty[i]);\\n        }\\n        \\n        /**\\n        At position x, y, assume x = 2, y = 4 we have\\n        dp[x - 1] = dp[1] = [0,b,c,d,e,f]; // first x number in this row should be 0, because tasks finish in x days must >= x\\n                    dp[2] = [0,0,p,q,r,s];\\n            jobDifficulty = [h,i,j,k,l,m]; \\n        \\n        the value we want to get is \"r\": there are 3 position to sperate the row:\\n            between k and l: candidate1 = d + l;\\n            between j and k: candidate2 = c + Max(k, l);\\n            between i and j: candidate3 = b + Max(j, k, l);\\n            r = Min(candiate1, candidate2, candidate3);\\n        **/\\n        for (int i = 1 ; i < d; i++) { // deduct following row\\n            for (int j = i; j < leng; j++) {\\n                int max = 0;\\n                int min = Integer.MAX_VALUE;\\n                for (int k = j; k >= i; k--) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    min = Math.min(min, dp[i - 1][k - 1] + max);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[d - 1][leng - 1];   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993055,
                "title": "python-3-recursion-memoization",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        @lru_cache(None)\\n        def helper(idx, d): \\n            if d == 1: \\n                return max(jobDifficulty[idx:])\\n            \\n            res = float(\\'inf\\')\\n            max_sofar = float(\\'-inf\\')\\n            for i in range(idx, n - d + 1): \\n                max_sofar = max(max_sofar, jobDifficulty[i])\\n                res = min(res, max_sofar + helper(i+1, d-1))\\n            return res\\n        \\n        \\n        n = len(jobDifficulty)\\n        if n < d: \\n            return -1\\n        else:\\n            return helper(0, d)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        @lru_cache(None)\\n        def helper(idx, d): \\n            if d == 1: \\n                return max(jobDifficulty[idx:])\\n            \\n            res = float(\\'inf\\')\\n            max_sofar = float(\\'-inf\\')\\n            for i in range(idx, n - d + 1): \\n                max_sofar = max(max_sofar, jobDifficulty[i])\\n                res = min(res, max_sofar + helper(i+1, d-1))\\n            return res\\n        \\n        \\n        n = len(jobDifficulty)\\n        if n < d: \\n            return -1\\n        else:\\n            return helper(0, d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612228,
                "title": "c-bottom-up-dp-o-n-2-space-with-comments",
                "content": "```\\n/*\\nMy thought process for the question :\\nPrerequisite:\\nFor each i (0 <= i < n) all previous tasks need to completed.\\n\\nThe question can be framed into another statement which might be more intuitive\\nPartition the array into d contiguous subsets such that sum of maximum of each subset is minimum.\\n\\nI defined the state function as the minimum sum of partitioning array ending at index i into x subsets\\nfor all  0 <= i < n and 0 <= x < d\\nState function: S(i, d) (Definition given above)\\nSome edges cases : \\nIf number of jobs is less that d then return -1 since partitioning is not possible\\nIf d == 1 then return max element in array\\nif no of jobs == d then return sum of array\\n\\nExample :\\n\\n6 5 4 3 2 1.\\nIf we are at index 3 and d = 2\\nthen the subproblem is partitioning 6 5 4 3 into 2 subsets such that sum of maximum of subsets is minimum.\\n6 5 4 3 in d = 2 depends on min of :\\n\\n6 5 4 in 1 + 3 in 1 -> subproblem 1\\n65 in 1 + 43 in 1 -> subproblem 2\\n6 in 1 + 543 in 1 -> subproblem 3\\n\\nIt should be noted that ( 43 in 1 ) can be calulated by looping back from 3 and taking max.\\n2D matrix for more clarification :\\n    6  4  5  3  2  1\\n1   6  6  6  6  6  6\\n2  -1  10 10 9  8  7\\n*/\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if(jobDifficulty.size() < d){ return -1; }\\n        if(jobDifficulty.size() == d){ return accumulate(jobDifficulty.begin(), jobDifficulty.end(), 0); }\\n        if(d == 1){ return *max_element(jobDifficulty.begin(), jobDifficulty.end()); }\\n        vector<vector<int>> dp(d, vector<int>(jobDifficulty.size(), -1));\\n        int maxEl = -1;\\n        \\n        for(int i = 0; i < jobDifficulty.size(); i++){\\n            maxEl = max(maxEl, jobDifficulty[i]);\\n            dp[0][i] = maxEl;\\n        }\\n        \\n        for(int i = 1; i < d; i++){\\n            for(int j = i; j < dp[0].size(); j++){\\n                dp[i][j] = INT_MAX - 2000;\\n                int maxDiff = jobDifficulty[j];\\n                for(int r = j; r >= i; r--){\\n                    maxDiff = max(maxDiff, jobDifficulty[r]);\\n                    dp[i][j] = min(dp[i - 1][r - 1] + maxDiff, dp[i][j]);\\n                }\\n            }\\n        }\\n        return dp[d - 1][dp[0].size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nMy thought process for the question :\\nPrerequisite:\\nFor each i (0 <= i < n) all previous tasks need to completed.\\n\\nThe question can be framed into another statement which might be more intuitive\\nPartition the array into d contiguous subsets such that sum of maximum of each subset is minimum.\\n\\nI defined the state function as the minimum sum of partitioning array ending at index i into x subsets\\nfor all  0 <= i < n and 0 <= x < d\\nState function: S(i, d) (Definition given above)\\nSome edges cases : \\nIf number of jobs is less that d then return -1 since partitioning is not possible\\nIf d == 1 then return max element in array\\nif no of jobs == d then return sum of array\\n\\nExample :\\n\\n6 5 4 3 2 1.\\nIf we are at index 3 and d = 2\\nthen the subproblem is partitioning 6 5 4 3 into 2 subsets such that sum of maximum of subsets is minimum.\\n6 5 4 3 in d = 2 depends on min of :\\n\\n6 5 4 in 1 + 3 in 1 -> subproblem 1\\n65 in 1 + 43 in 1 -> subproblem 2\\n6 in 1 + 543 in 1 -> subproblem 3\\n\\nIt should be noted that ( 43 in 1 ) can be calulated by looping back from 3 and taking max.\\n2D matrix for more clarification :\\n    6  4  5  3  2  1\\n1   6  6  6  6  6  6\\n2  -1  10 10 9  8  7\\n*/\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if(jobDifficulty.size() < d){ return -1; }\\n        if(jobDifficulty.size() == d){ return accumulate(jobDifficulty.begin(), jobDifficulty.end(), 0); }\\n        if(d == 1){ return *max_element(jobDifficulty.begin(), jobDifficulty.end()); }\\n        vector<vector<int>> dp(d, vector<int>(jobDifficulty.size(), -1));\\n        int maxEl = -1;\\n        \\n        for(int i = 0; i < jobDifficulty.size(); i++){\\n            maxEl = max(maxEl, jobDifficulty[i]);\\n            dp[0][i] = maxEl;\\n        }\\n        \\n        for(int i = 1; i < d; i++){\\n            for(int j = i; j < dp[0].size(); j++){\\n                dp[i][j] = INT_MAX - 2000;\\n                int maxDiff = jobDifficulty[j];\\n                for(int r = j; r >= i; r--){\\n                    maxDiff = max(maxDiff, jobDifficulty[r]);\\n                    dp[i][j] = min(dp[i - 1][r - 1] + maxDiff, dp[i][j]);\\n                }\\n            }\\n        }\\n        return dp[d - 1][dp[0].size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491061,
                "title": "java-bottom-up-dp-solution-with-explanation",
                "content": "This is a typical DP problem.\\n\\n1. Subproblems: finish the `job[i:]` with `k` days left.\\n\\n   Number of subproblems: O(n* len).  (len means # of days)\\n\\n2. Guess: next day, we choose to solve `job[i:j] jobs for j in range(i, n)` \\n\\n3. Recurrence:\\n\\n   dp(i, j) means solve job[i:] with j days left.\\n\\n   `dp(i, k) = min{ dp(i, k), max{job[k] for k in range(i, j)} + dp(j, k-1) } for j in range(i, n)`\\n\\n   time/subproblem: O(n)\\n\\n4. Total run time: O(n^2* len)\\n\\n5. Topological Order:\\n\\n   from right to left. \\n   \\nMind the initialization:\\n\\nall `dp[n][i]` and `dp[i][0]` should be Integer.MAX_VALUE\\n\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (n < d) return -1;\\n        int[][] dp = new int[n+1][d+1];\\n        for (int i = 1; i <= d; i++) {\\n            dp[n][i] = Integer.MAX_VALUE; // There\\'re days unused.\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dp[i][0] = Integer.MAX_VALUE; // No day left.\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 1; j <= d; ++j) {\\n                int min = Integer.MAX_VALUE;\\n                int max = 0;\\n                for (int k = i; k <= n - 1; k++) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    if (dp[k+1][j-1] != Integer.MAX_VALUE) {\\n                        min = Math.min(min, max + dp[k+1][j-1]);\\n                    }\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[0][d] == Integer.MAX_VALUE ? -1 : dp[0][d];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if (n < d) return -1;\\n        int[][] dp = new int[n+1][d+1];\\n        for (int i = 1; i <= d; i++) {\\n            dp[n][i] = Integer.MAX_VALUE; // There\\'re days unused.\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dp[i][0] = Integer.MAX_VALUE; // No day left.\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 1; j <= d; ++j) {\\n                int min = Integer.MAX_VALUE;\\n                int max = 0;\\n                for (int k = i; k <= n - 1; k++) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    if (dp[k+1][j-1] != Integer.MAX_VALUE) {\\n                        min = Math.min(min, max + dp[k+1][j-1]);\\n                    }\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[0][d] == Integer.MAX_VALUE ? -1 : dp[0][d];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711423,
                "title": "python-rust-bottom-up-and-top-down-dp-solutions-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n\\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/823720463/) employs a top-down recursive DP approach. It demonstrated **1157 ms runtime (80.04%)** and used **15.4 MB memory (22.15%)**. Time complexity is: **O(n\\\\*n\\\\*d)**. Space complexity is: **O(n\\\\*d)**. \\n```\\nclass Solution:\\n    def minDifficulty(self, job_diff: list[int], d: int) -> int:\\n        \\n        # this helper function performs a DP-based exploration\\n        # of possible combinations (with activated cache);\\n        # it returns schedule difficulty for the sublist \\'job_diff[i:]\\'\\n        # with the allowed number of subdivisions that equals \\'d\\'\\n        @functools.cache\\n        def dp(i: int, d: int) -> int:\\n\\n            # [1] branches with more than \\'d\\' divisions are not\\n            #     allowed, thus, penalized with infinite score\\n            if d < 0 : return inf\\n                        \\n            this_day_diff = 0\\n            schedule_diff = inf\\n            last_idx = min(n-d+1,n)\\n            \\n            # [2] this problem allows splitting the calculations\\n            #     into two parts:\\n            #     - difficulty for this day\\n            #     - cumulative difficulty for all next days\\n            #     we search for min across all \\'this+next\\' combinations\\n            for ii in range(i, last_idx):\\n                this_day_diff  = max(this_day_diff, job_diff[ii])\\n                next_days_diff = dp(ii+1, d-1) if ii + 1 < len(job_diff) else 0\\n                schedule_diff  = min(schedule_diff, this_day_diff + next_days_diff)\\n            \\n            return schedule_diff\\n        \\n        n = len(job_diff)\\n        \\n        # [a] trivial case\\n        if d > len(job_diff): return -1\\n        \\n        # [b] typical case\\n        return  dp(0, d)\\n\\n```\\n\\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/823925102/) employs a bottom-up iterative DP approach. It demonstrated **6 ms runtime (100.00%)** and used **2.1 MB memory (92.86%)**. Time complexity is: **O(n\\\\*n\\\\*d)**. Space complexity is: **O(n\\\\*d)**. \\n```\\nimpl Solution \\n{\\n    pub fn min_difficulty(job_diff: Vec<i32>, days: i32) -> i32 \\n    {\\n        let jobs = job_diff.len() as usize;\\n        let days = days as usize;\\n\\n        // [1] trivial case\\n        if days > jobs { return -1; }\\n\\n        // [2] as a collection of state variables for bottom-up DP, we\\n        //     use a matrix where for each job and for each day we compute\\n        //     the minimal possible schedule difficulty that is attainable\\n        //     when considering all following days (yes, we iterate in \\n        //     reverse order, thus, reproducing in some sense the logic\\n        //     of the Python top-down solution above) \\n        let mut schedule_diff = vec![vec![i32::MAX;days+1];jobs+1];\\n        schedule_diff[jobs][days] = 0;\\n        \\n        // [3] iteratively update DP state starting from the last day  \\n        //     and last job till we reach first day and first job;\\n        //     when considering some day, we have to keep track of \\n        //     indices such that there is always room for at least one\\n        //     job in each of preceding and following days;\\n        for d in (0..days).rev()\\n        {\\n            let last_idx = jobs - days + d;\\n            for j in (d..=last_idx).rev()\\n            {\\n                let mut this_day_diff = 0;\\n                for i in (j..=last_idx)\\n                {\\n                    this_day_diff = this_day_diff.max(job_diff[i]);\\n                    if schedule_diff[i+1][d+1] < i32::MAX\\n                    {\\n                        // [4] magic happens here: for each day \\'d\\' and each job \\'j\\', we test\\n                        //     whether the cumulative difficulty for jobs [j,i] on day \\'d\\' \\n                        //     together with jobs [i+1,n) on days [d+1,days) is less than\\n                        //     the currently attained value for some other \\'i\\'\\n                        schedule_diff[j][d] = schedule_diff[j][d].min(this_day_diff + schedule_diff[i+1][d+1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // [5] in the end, the minimal attainable schedule difficulty\\n        //     will be stored as the DP state for day=0 and job=0\\n        return schedule_diff[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, job_diff: list[int], d: int) -> int:\\n        \\n        # this helper function performs a DP-based exploration\\n        # of possible combinations (with activated cache);\\n        # it returns schedule difficulty for the sublist \\'job_diff[i:]\\'\\n        # with the allowed number of subdivisions that equals \\'d\\'\\n        @functools.cache\\n        def dp(i: int, d: int) -> int:\\n\\n            # [1] branches with more than \\'d\\' divisions are not\\n            #     allowed, thus, penalized with infinite score\\n            if d < 0 : return inf\\n                        \\n            this_day_diff = 0\\n            schedule_diff = inf\\n            last_idx = min(n-d+1,n)\\n            \\n            # [2] this problem allows splitting the calculations\\n            #     into two parts:\\n            #     - difficulty for this day\\n            #     - cumulative difficulty for all next days\\n            #     we search for min across all \\'this+next\\' combinations\\n            for ii in range(i, last_idx):\\n                this_day_diff  = max(this_day_diff, job_diff[ii])\\n                next_days_diff = dp(ii+1, d-1) if ii + 1 < len(job_diff) else 0\\n                schedule_diff  = min(schedule_diff, this_day_diff + next_days_diff)\\n            \\n            return schedule_diff\\n        \\n        n = len(job_diff)\\n        \\n        # [a] trivial case\\n        if d > len(job_diff): return -1\\n        \\n        # [b] typical case\\n        return  dp(0, d)\\n\\n```\n```\\nimpl Solution \\n{\\n    pub fn min_difficulty(job_diff: Vec<i32>, days: i32) -> i32 \\n    {\\n        let jobs = job_diff.len() as usize;\\n        let days = days as usize;\\n\\n        // [1] trivial case\\n        if days > jobs { return -1; }\\n\\n        // [2] as a collection of state variables for bottom-up DP, we\\n        //     use a matrix where for each job and for each day we compute\\n        //     the minimal possible schedule difficulty that is attainable\\n        //     when considering all following days (yes, we iterate in \\n        //     reverse order, thus, reproducing in some sense the logic\\n        //     of the Python top-down solution above) \\n        let mut schedule_diff = vec![vec![i32::MAX;days+1];jobs+1];\\n        schedule_diff[jobs][days] = 0;\\n        \\n        // [3] iteratively update DP state starting from the last day  \\n        //     and last job till we reach first day and first job;\\n        //     when considering some day, we have to keep track of \\n        //     indices such that there is always room for at least one\\n        //     job in each of preceding and following days;\\n        for d in (0..days).rev()\\n        {\\n            let last_idx = jobs - days + d;\\n            for j in (d..=last_idx).rev()\\n            {\\n                let mut this_day_diff = 0;\\n                for i in (j..=last_idx)\\n                {\\n                    this_day_diff = this_day_diff.max(job_diff[i]);\\n                    if schedule_diff[i+1][d+1] < i32::MAX\\n                    {\\n                        // [4] magic happens here: for each day \\'d\\' and each job \\'j\\', we test\\n                        //     whether the cumulative difficulty for jobs [j,i] on day \\'d\\' \\n                        //     together with jobs [i+1,n) on days [d+1,days) is less than\\n                        //     the currently attained value for some other \\'i\\'\\n                        schedule_diff[j][d] = schedule_diff[j][d].min(this_day_diff + schedule_diff[i+1][d+1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // [5] in the end, the minimal attainable schedule difficulty\\n        //     will be stored as the DP state for day=0 and job=0\\n        return schedule_diff[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710942,
                "title": "easy-to-understand-java-detailed-solution-recursive-memoized",
                "content": "## How to approach the problem:\\n\\n- Assume that we have `[5,6,4,1,3,2]` as difficulty array and `d = 2`. And no matter how many jobs we do in a day, the effective difficulty will always be the highest difficulty.\\n\\n## First let\\'s see how this is a dynamic problem. \\n- Say, we choose to do first job (difficulty `5`) in a day and rest of them on next day, then for the first day,we made a choice of doing `5`. That left us with `6,4,1,3,2`. Now this choise landed us with cumulative difficulty of `5 + 6 = 11` (because we\\'d be doing job `6` on day 2).\\nBut if we did `5,6,4` jobs on first day and `1,3,2` on second day, we would have cumulative difficulty of `6 + 3 = 9` (because on second day highest difficulty is `3`).\\n\\n- So, our choices are landing us in different situations and those situations are leading to different answers. So, we might have n different answers based on the **choice** that we make. And we need to take the **minimum** of those answers. This kind of problem where we have to **optimise** something and **choices** lead to different answers are usually dynamic programming problems. This is one such problem.\\n\\n## How to solve this problem:\\n\\n- For solving dynamic programming questions, the best approach I think is to write recursive code and later optimise that.\\n- A recursive code has **3 things**: **1**. Base condition(s) **2**. Recursive function call with smaller input assuming that the recursive call would give us correct result for the smaller input and **3**. Some additional code to make step 2 work. If you didn\\'t get the last point, it\\'s okay, I\\'ll explain.\\n\\n- **1. Base condition**: the smallest possible input for the question can be `d = 1` and no matter how many tasks are there, they need to be performed in a single day. Obviously, the effective difficulty for a day is the highest difficulty task performed. This is a simple code to write. Iterate over the entire array of tasks and find the maximum difficulty task.\\nLet\\'s code this part:\\n\\n\\t\\tif(d == 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n- **2. Recursive calls on smaller input**: Let\\'s say we have `d = 3` for `[5,6,4,1,3,2]`. We assume that if we take `5` on day 1, and make a recursive call on `6,4,1,3,2`, for `d = 2` (because we\\'d have one day less), that should give us the correct result!\\n- Now, initially, we say that we start at index `0` and take `5` as day 1 task. But we can take `5` and `6` as day 1 task and so on. Maximum we can take `5,6,4,1` as day 1 task (*think about it - if you do 5,6,4,1 on day 1 and you have to adjust two more days, you should leave at least 2 tasks for remaining two days*). So, in this case, our start index would vary from `0` till `array length - d` (inclusive). If you are having a hard time thinking about this, I suggest you take a pen and paper and see how we reached this conclusion.\\n- So, the conclusion is that our start index can vary from **`0` to `length - d`**. And for each choice we need to make a recursive call for `d - 1` while increasing start index.\\n\\n- This is the recursive calls that we need to make for `d = 3`:\\n\\n\\t\\t[5] (max 5) + f(6,4,1,3,2 & d - 1)\\n\\t\\t[5,6] (max 6) + f (4,1,3,2 & d - 1)\\n\\t\\t[5,6,4] (max 6) + f (1,3,2 & d - 1) and\\n\\t\\t[5,6,4,1] (max 6) + f (3,2 & d - 1)   // we stop here because 3 and 2 would be done on 2nd and 3rd day\\n\\n- **3. Some code that would make our magic recursive function work**: the above resurive calls would give us some results and we need to choose **minimum** out of them. And of course, we need to figure out the max element each time also.\\n\\n- If we write the code for this:\\n\\n\\t\\t//initialise max - 0 and r = MAX_VALUE (r is for result)\\n\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\tmax = Math.max(max, array[i]);   // find out max\\n\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1));   // add max to result from sub-problem\\n\\t\\t}\\n\\n- And finally we return the result. That is it. We have coded our solution. Let\\'s put these bits together.\\n\\n\\t\\tint f(int[] array, int start, int d) {\\n\\t\\t\\t//base condition\\n\\t\\t\\tif(d == 1) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\t\\t\\t// recursion  + some extra code to make it work\\n\\t\\t\\tint max  = 0;\\n\\t\\t\\tint r = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\t\\tmax = Math.max(max, array[i]);\\n\\t\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\n- If we write complete solution together, we would begin with `start = 0`:\\n\\n\\t\\tpublic int minDifficulty(int[] jobDifficulty, int d) {\\n\\t\\t\\tif (d > jobDifficulty.length) return -1;\\t// condition as per question.\\n\\t\\t\\tif (d == jobDifficulty.length) return Arrays.stream(jobDifficulty).sum();\\t// condition as per question.\\n\\t\\t\\treturn f(jobDifficulty, 0, d);\\t//start = 0\\n\\t\\t}\\n\\n\\t\\tprivate int f(int[] array, int start, int d) {\\n\\t\\t\\t//base condition\\n\\t\\t\\tif(d == 1) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\t\\t\\t// recursion  + some extra code to make it work\\n\\t\\t\\tint max  = 0;\\n\\t\\t\\tint r = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\t\\tmax = Math.max(max, array[i]);\\n\\t\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\n- The above solution works well for small inputs but would give you **TLE** for larger inputs. To avoid, TLE we can **memoize** the code. To memoize, we take elements which are changing in the recursive call and make a cache array based on that. We see that two variables - `start` and `d` are changing in the recursive call. We know that the `start` can go till the end of the array, we can make a 2D cache array of size `array.length + 1 * d + 1` and use that:\\n\\n\\t\\tpublic int minDifficulty(int[] jobDifficulty, int d) {\\n\\t\\t\\tif (d > jobDifficulty.length) return -1;\\t// condition as per question.\\n\\t\\t\\tif (d == jobDifficulty.length) return Arrays.stream(jobDifficulty).sum();\\t// condition as per question.\\n\\t\\t\\tint[][] mem = new int[jobDifficulty.length + 1][d + 1];\\n\\t\\t\\tfor(int[] arr : mem) Arrays.fill(arr, -1);\\n\\t\\t\\treturn f(jobDifficulty, 0, d);\\t//start = 0\\n\\t\\t}\\n\\n\\t\\tprivate int f(int[] array, int start, int d, int[][] mem) {\\n\\t\\t\\t//base condition\\n\\t\\t\\tif(d == 1) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(mem[start][d] != -1) return mem[start][d]; // if value present in cache, don\\'t go into rabbithole of recursion again.\\n\\n\\t\\t\\t// recursion  + some extra code to make it work\\n\\t\\t\\tint max  = 0;\\n\\t\\t\\tint r = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\t\\tmax = Math.max(max, array[i]);\\n\\t\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1, mem));\\n\\t\\t\\t}\\n\\t\\t\\treturn mem[start][d] = r;\\t//once calculated, put it in cache.\\n\\t\\t}\\n\\nThat\\'s all, my friends. Thank you for reading.\\n\\n\\nIf above code has any typograohical errors, [here is my working code on GitHub](https://github.com/penguinmishra/leetcode-java/blob/main/src/com/code/leetcode/MinimumDifficultyOfAJobSchedule.java).\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "## How to approach the problem:\\n\\n- Assume that we have `[5,6,4,1,3,2]` as difficulty array and `d = 2`. And no matter how many jobs we do in a day, the effective difficulty will always be the highest difficulty.\\n\\n## First let\\'s see how this is a dynamic problem. \\n- Say, we choose to do first job (difficulty `5`) in a day and rest of them on next day, then for the first day,we made a choice of doing `5`. That left us with `6,4,1,3,2`. Now this choise landed us with cumulative difficulty of `5 + 6 = 11` (because we\\'d be doing job `6` on day 2).\\nBut if we did `5,6,4` jobs on first day and `1,3,2` on second day, we would have cumulative difficulty of `6 + 3 = 9` (because on second day highest difficulty is `3`).\\n\\n- So, our choices are landing us in different situations and those situations are leading to different answers. So, we might have n different answers based on the **choice** that we make. And we need to take the **minimum** of those answers. This kind of problem where we have to **optimise** something and **choices** lead to different answers are usually dynamic programming problems. This is one such problem.\\n\\n## How to solve this problem:\\n\\n- For solving dynamic programming questions, the best approach I think is to write recursive code and later optimise that.\\n- A recursive code has **3 things**: **1**. Base condition(s) **2**. Recursive function call with smaller input assuming that the recursive call would give us correct result for the smaller input and **3**. Some additional code to make step 2 work. If you didn\\'t get the last point, it\\'s okay, I\\'ll explain.\\n\\n- **1. Base condition**: the smallest possible input for the question can be `d = 1` and no matter how many tasks are there, they need to be performed in a single day. Obviously, the effective difficulty for a day is the highest difficulty task performed. This is a simple code to write. Iterate over the entire array of tasks and find the maximum difficulty task.\\nLet\\'s code this part:\\n\\n\\t\\tif(d == 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n- **2. Recursive calls on smaller input**: Let\\'s say we have `d = 3` for `[5,6,4,1,3,2]`. We assume that if we take `5` on day 1, and make a recursive call on `6,4,1,3,2`, for `d = 2` (because we\\'d have one day less), that should give us the correct result!\\n- Now, initially, we say that we start at index `0` and take `5` as day 1 task. But we can take `5` and `6` as day 1 task and so on. Maximum we can take `5,6,4,1` as day 1 task (*think about it - if you do 5,6,4,1 on day 1 and you have to adjust two more days, you should leave at least 2 tasks for remaining two days*). So, in this case, our start index would vary from `0` till `array length - d` (inclusive). If you are having a hard time thinking about this, I suggest you take a pen and paper and see how we reached this conclusion.\\n- So, the conclusion is that our start index can vary from **`0` to `length - d`**. And for each choice we need to make a recursive call for `d - 1` while increasing start index.\\n\\n- This is the recursive calls that we need to make for `d = 3`:\\n\\n\\t\\t[5] (max 5) + f(6,4,1,3,2 & d - 1)\\n\\t\\t[5,6] (max 6) + f (4,1,3,2 & d - 1)\\n\\t\\t[5,6,4] (max 6) + f (1,3,2 & d - 1) and\\n\\t\\t[5,6,4,1] (max 6) + f (3,2 & d - 1)   // we stop here because 3 and 2 would be done on 2nd and 3rd day\\n\\n- **3. Some code that would make our magic recursive function work**: the above resurive calls would give us some results and we need to choose **minimum** out of them. And of course, we need to figure out the max element each time also.\\n\\n- If we write the code for this:\\n\\n\\t\\t//initialise max - 0 and r = MAX_VALUE (r is for result)\\n\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\tmax = Math.max(max, array[i]);   // find out max\\n\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1));   // add max to result from sub-problem\\n\\t\\t}\\n\\n- And finally we return the result. That is it. We have coded our solution. Let\\'s put these bits together.\\n\\n\\t\\tint f(int[] array, int start, int d) {\\n\\t\\t\\t//base condition\\n\\t\\t\\tif(d == 1) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\t\\t\\t// recursion  + some extra code to make it work\\n\\t\\t\\tint max  = 0;\\n\\t\\t\\tint r = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\t\\tmax = Math.max(max, array[i]);\\n\\t\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\n- If we write complete solution together, we would begin with `start = 0`:\\n\\n\\t\\tpublic int minDifficulty(int[] jobDifficulty, int d) {\\n\\t\\t\\tif (d > jobDifficulty.length) return -1;\\t// condition as per question.\\n\\t\\t\\tif (d == jobDifficulty.length) return Arrays.stream(jobDifficulty).sum();\\t// condition as per question.\\n\\t\\t\\treturn f(jobDifficulty, 0, d);\\t//start = 0\\n\\t\\t}\\n\\n\\t\\tprivate int f(int[] array, int start, int d) {\\n\\t\\t\\t//base condition\\n\\t\\t\\tif(d == 1) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\t\\t\\t// recursion  + some extra code to make it work\\n\\t\\t\\tint max  = 0;\\n\\t\\t\\tint r = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\t\\tmax = Math.max(max, array[i]);\\n\\t\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\n- The above solution works well for small inputs but would give you **TLE** for larger inputs. To avoid, TLE we can **memoize** the code. To memoize, we take elements which are changing in the recursive call and make a cache array based on that. We see that two variables - `start` and `d` are changing in the recursive call. We know that the `start` can go till the end of the array, we can make a 2D cache array of size `array.length + 1 * d + 1` and use that:\\n\\n\\t\\tpublic int minDifficulty(int[] jobDifficulty, int d) {\\n\\t\\t\\tif (d > jobDifficulty.length) return -1;\\t// condition as per question.\\n\\t\\t\\tif (d == jobDifficulty.length) return Arrays.stream(jobDifficulty).sum();\\t// condition as per question.\\n\\t\\t\\tint[][] mem = new int[jobDifficulty.length + 1][d + 1];\\n\\t\\t\\tfor(int[] arr : mem) Arrays.fill(arr, -1);\\n\\t\\t\\treturn f(jobDifficulty, 0, d);\\t//start = 0\\n\\t\\t}\\n\\n\\t\\tprivate int f(int[] array, int start, int d, int[][] mem) {\\n\\t\\t\\t//base condition\\n\\t\\t\\tif(d == 1) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\twhile(start < array.length) max = Math.max(max, array[start++]);\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(mem[start][d] != -1) return mem[start][d]; // if value present in cache, don\\'t go into rabbithole of recursion again.\\n\\n\\t\\t\\t// recursion  + some extra code to make it work\\n\\t\\t\\tint max  = 0;\\n\\t\\t\\tint r = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = start; i <= array.length - d; i++) {\\n\\t\\t\\t\\tmax = Math.max(max, array[i]);\\n\\t\\t\\t\\tr = Math.min(r, max + f(array, i + 1, d - 1, mem));\\n\\t\\t\\t}\\n\\t\\t\\treturn mem[start][d] = r;\\t//once calculated, put it in cache.\\n\\t\\t}\\n\\nThat\\'s all, my friends. Thank you for reading.\\n\\n\\nIf above code has any typograohical errors, [here is my working code on GitHub](https://github.com/penguinmishra/leetcode-java/blob/main/src/com/code/leetcode/MinimumDifficultyOfAJobSchedule.java).\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2710333,
                "title": "proper-explanation-how-to-approach-this-problem-2-approach",
                "content": "# Proper video explanation, might help you \\n#https://www.youtube.com/watch?v=GjYQdn5UAWA\\n\\nUpvote if you like \\n# Notes\\n\\n![image](https://assets.leetcode.com/users/images/f0a2fe7f-fbb0-41a9-9ae9-8c3bc94b3d7b_1665925968.9114232.png)\\n![image](https://assets.leetcode.com/users/images/65eed825-afa1-41ef-92e8-e831ef6c5c12_1665925974.715646.png)\\n\\n\\n# code:\\n1-approach : Recursion-\\n```\\nclass Solution {\\npublic:\\n    \\n    int find( vector<int>& job ,  int d , int start , int n){\\n        if( d == 1){\\n            int res = INT_MIN;\\n            for(int i = start ; i< n ; i++){\\n                res = max ( res , job [ i]);\\n            }\\n            return res;\\n        }\\n        else{\\n            int val = INT_MIN;\\n            int res = INT_MAX;\\n            \\n            for( int i = start ; i< n-d+1 ; i++){\\n                val = max ( val , job[i]);\\n                res = min ( res , val+find(job , d-1, i+1 , n));\\n            }\\n            return res;\\n        }\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int size = jobDifficulty.size();\\n        \\n        if(size < d) return -1;\\n        \\n        return find ( jobDifficulty , d, 0 , size);\\n    }\\n};\\n```\\n\\n2- approach:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int find( vector<int>& job ,  int d , int start , int n,vector<vector<int>>&dp){\\n        if(dp[start][d] != -1) return dp[start][d];\\n        if( d == 1){\\n            int res = INT_MIN;\\n            for(int i = start ; i< n ; i++){\\n                res = max ( res , job [ i]);\\n            }\\n            return res;\\n        }\\n        else{\\n            int val = INT_MIN;\\n            int res = INT_MAX;\\n            \\n            for( int i = start ; i< n-d+1 ; i++){\\n                val = max ( val , job[i]);\\n                res = min ( res , val+find(job , d-1, i+1 , n,dp));\\n            }\\n            return dp[start][d] = res;\\n        }\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int size = jobDifficulty.size();\\n\\n        vector<vector<int>>dp(size+1, vector<int>(d+1,-1));\\n        \\n        if(size < d) return -1;\\n        \\n        return find ( jobDifficulty , d, 0 , size,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find( vector<int>& job ,  int d , int start , int n){\\n        if( d == 1){\\n            int res = INT_MIN;\\n            for(int i = start ; i< n ; i++){\\n                res = max ( res , job [ i]);\\n            }\\n            return res;\\n        }\\n        else{\\n            int val = INT_MIN;\\n            int res = INT_MAX;\\n            \\n            for( int i = start ; i< n-d+1 ; i++){\\n                val = max ( val , job[i]);\\n                res = min ( res , val+find(job , d-1, i+1 , n));\\n            }\\n            return res;\\n        }\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int size = jobDifficulty.size();\\n        \\n        if(size < d) return -1;\\n        \\n        return find ( jobDifficulty , d, 0 , size);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int find( vector<int>& job ,  int d , int start , int n,vector<vector<int>>&dp){\\n        if(dp[start][d] != -1) return dp[start][d];\\n        if( d == 1){\\n            int res = INT_MIN;\\n            for(int i = start ; i< n ; i++){\\n                res = max ( res , job [ i]);\\n            }\\n            return res;\\n        }\\n        else{\\n            int val = INT_MIN;\\n            int res = INT_MAX;\\n            \\n            for( int i = start ; i< n-d+1 ; i++){\\n                val = max ( val , job[i]);\\n                res = min ( res , val+find(job , d-1, i+1 , n,dp));\\n            }\\n            return dp[start][d] = res;\\n        }\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int size = jobDifficulty.size();\\n\\n        vector<vector<int>>dp(size+1, vector<int>(d+1,-1));\\n        \\n        if(size < d) return -1;\\n        \\n        return find ( jobDifficulty , d, 0 , size,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709132,
                "title": "91-faster-solution",
                "content": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        jobCount = len(jobDifficulty)    \\n        if jobCount < d:\\n            return -1\\n\\n        @lru_cache(None)\\n        def topDown(jobIndex: int, remainDayCount: int) -> int:\\n            remainJobCount = jobCount - jobIndex\\n            if remainDayCount == 1:\\n                return max(jobDifficulty[jobIndex:])\\n            \\n            if remainJobCount == remainDayCount:\\n                return sum(jobDifficulty[jobIndex:])\\n\\n            minDiff = float(\\'inf\\')\\n            maxToday = 0\\n            for i in range(jobIndex, jobCount - remainDayCount + 1):\\n                maxToday = max(maxToday, jobDifficulty[i])\\n                minDiff = min(minDiff, maxToday + topDown(i+1, remainDayCount-1))\\n            return minDiff\\n\\n        return topDown(0, d)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        jobCount = len(jobDifficulty)    \\n        if jobCount < d:\\n            return -1\\n\\n        @lru_cache(None)\\n        def topDown(jobIndex: int, remainDayCount: int) -> int:\\n            remainJobCount = jobCount - jobIndex\\n            if remainDayCount == 1:\\n                return max(jobDifficulty[jobIndex:])\\n            \\n            if remainJobCount == remainDayCount:\\n                return sum(jobDifficulty[jobIndex:])\\n\\n            minDiff = float(\\'inf\\')\\n            maxToday = 0\\n            for i in range(jobIndex, jobCount - remainDayCount + 1):\\n                maxToday = max(maxToday, jobDifficulty[i])\\n                minDiff = min(minDiff, maxToday + topDown(i+1, remainDayCount-1))\\n            return minDiff\\n\\n        return topDown(0, d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707923,
                "title": "c-recursion-memoization-commented",
                "content": "```\\n//My Github Repo for complete list for interview Qns : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/DP/Minimum%20Difficulty%20of%20a%20Job%20Schedule.cpp\\n\\n//Youtube video : https://www.youtube.com/watch?v=smTnSl6UKi0\\n\\nclass Solution {\\npublic:\\n    int t[301][11];\\n    int solve(vector<int>& jd, int n, int idx, int d) {\\n        \\n        //if you have only 1 day, then you will all the remaining jobs\\n        //and select the max difficulty as the answer\\n        if(d == 1) {\\n            return *max_element(begin(jd)+idx, end(jd));\\n        }\\n        \\n        if(t[idx][d] != -1)\\n            return t[idx][d];\\n    \\n        \\n        int Max = INT_MIN;\\n        int result = INT_MAX;\\n        \\n        //Try one by one with all possibility\\n        /*\\n            Take 1 job in one day\\n            Take 2 jobs in one day\\n            Take 3 jobs in one day\\n            and so on\\n            \\n            Then find the optimal one among all the results\\n        */\\n        for(int i = idx; i<=n-d; i++) {\\n            Max = max(Max, jd[i]);\\n            \\n            result = min(result, Max + solve(jd, n, i+1, d-1));\\n        }\\n        \\n        return t[idx][d] = result;\\n    }\\n    \\n    int minDifficulty(vector<int>& jd, int d) {\\n        int n = jd.size();\\n        \\n        if(n < d)\\n            return -1;\\n\\n        memset(t, -1, sizeof(t));\\n        \\n        return solve(jd, n, 0, d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//My Github Repo for complete list for interview Qns : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/DP/Minimum%20Difficulty%20of%20a%20Job%20Schedule.cpp\\n\\n//Youtube video : https://www.youtube.com/watch?v=smTnSl6UKi0\\n\\nclass Solution {\\npublic:\\n    int t[301][11];\\n    int solve(vector<int>& jd, int n, int idx, int d) {\\n        \\n        //if you have only 1 day, then you will all the remaining jobs\\n        //and select the max difficulty as the answer\\n        if(d == 1) {\\n            return *max_element(begin(jd)+idx, end(jd));\\n        }\\n        \\n        if(t[idx][d] != -1)\\n            return t[idx][d];\\n    \\n        \\n        int Max = INT_MIN;\\n        int result = INT_MAX;\\n        \\n        //Try one by one with all possibility\\n        /*\\n            Take 1 job in one day\\n            Take 2 jobs in one day\\n            Take 3 jobs in one day\\n            and so on\\n            \\n            Then find the optimal one among all the results\\n        */\\n        for(int i = idx; i<=n-d; i++) {\\n            Max = max(Max, jd[i]);\\n            \\n            result = min(result, Max + solve(jd, n, i+1, d-1));\\n        }\\n        \\n        return t[idx][d] = result;\\n    }\\n    \\n    int minDifficulty(vector<int>& jd, int d) {\\n        int n = jd.size();\\n        \\n        if(n < d)\\n            return -1;\\n\\n        memset(t, -1, sizeof(t));\\n        \\n        return solve(jd, n, 0, d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314274,
                "title": "c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int yes=0;\\n    int dp[301][12];\\n    int find(vector<int>&nums,int index,int d)\\n    {\\n        if(index>=n)\\n        {\\n            return 1e9;\\n        }\\n        if(dp[index][d]!=-1)\\n        {\\n            return dp[index][d];\\n        }\\n        if(d==1)\\n        {\\n            yes=1;\\n            int val=0;\\n            for(int i=index;i<n;i++)\\n            {\\n                val=max(val,nums[i]);\\n            }\\n            return val;\\n        }\\n        int max_val=nums[index];\\n        int ans=1e9;\\n        for(int i=index;i<n;i++)\\n        {\\n            max_val=max(max_val,nums[i]);\\n            ans=min(ans,max_val+find(nums,i+1,d-1));\\n        }\\n        return dp[index][d]=ans;\\n    }\\n    int minDifficulty(vector<int>&nums, int d) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        yes=0;\\n        n=nums.size();\\n        int val=find(nums,0,d);\\n        if(yes)\\n        {\\n            return val;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int yes=0;\\n    int dp[301][12];\\n    int find(vector<int>&nums,int index,int d)\\n    {\\n        if(index>=n)\\n        {\\n            return 1e9;\\n        }\\n        if(dp[index][d]!=-1)\\n        {\\n            return dp[index][d];\\n        }\\n        if(d==1)\\n        {\\n            yes=1;\\n            int val=0;\\n            for(int i=index;i<n;i++)\\n            {\\n                val=max(val,nums[i]);\\n            }\\n            return val;\\n        }\\n        int max_val=nums[index];\\n        int ans=1e9;\\n        for(int i=index;i<n;i++)\\n        {\\n            max_val=max(max_val,nums[i]);\\n            ans=min(ans,max_val+find(nums,i+1,d-1));\\n        }\\n        return dp[index][d]=ans;\\n    }\\n    int minDifficulty(vector<int>&nums, int d) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        yes=0;\\n        n=nums.size();\\n        int val=find(nums,0,d);\\n        if(yes)\\n        {\\n            return val;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597586,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimization: we only need the previous `k`<sup>th</sup> solutions to construct the `k + 1`<sup>th</sup> solutions\\n\\n---\\n\\nRecursively split up the input array `A` into `K` subarrays with the goal of minimizing the accumulated `cost` of all subarrays.  The difficulty of each `k`<sup>th</sup> day is the maximum difficulty of a job done in that day, thus each subarray from `i..j` inclusive has `cost` equal to the maximum of `A[i..j]`.  Consider all `k` subarrays and return the `best` solution by keeping track of ongoing maximum `cost` from `A[i..j]` under consideration for the current `k`<sup>th</sup> subarray.  This `cost` is to be returned as we search for the `best` subproblem solution as the recursive stack unwinds.  Thus for the top-down solutions, we keep track of how many `k` subarrays remain to reduce `A`, ie. for each `j`<sup>th</sup> index under consideration, we can split up `A` into a subarray ending at `j` with next subarray starting at `j + 1`, and thus the recurrence relation is to track each `cost` from `i = 0..N - k` for the current subarray and take a mental leap of faith for the optimal `j + 1`<sup>th</sup> subarray `cost` with `k - 1` subarrays remaining as the next subarray\\'s `best` solution.  The base case occurs when `k = 1`, and we can precompute the `cost` of each subarray starting at each index `i` as the right-most maximal value in the array `R`.  It follows that the bottom-up solutions build upon the base case of `k = 1` subarray to iteratively generate `k = 2..K` subarray solutions, ie. each current `k`<sup>th</sup> solution builds upon the previous `k - 1`<sup>th</sup> solution.  Let `dp[i][k]` denote the best solution starting at `A[i]` with `k` subarrays to be formed from `A[i..N-1]`.  And finally, we can optimize memory from `O(N * K)` to `O(N)` by only storing the current `cur` and previous `pre` solutions instead of all `K` solutions.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        if (N < K)\\n            return -1\\n        var R = A.copyOf()\\n        for (i in N - 2 downTo 0)\\n            R[i] = Math.max(R[i], R[i + 1])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (k == 1)\\n                return R[i]\\n            var (best, cost) = listOf(INF, A[i])\\n            for (j in i..N - k) {\\n                cost = Math.max(cost, A[j])\\n                best = Math.min(best, cost + go(j + 1, k - 1))\\n            }\\n            return best\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        if (N < K)\\n            return -1\\n        var R = A.copyOf()\\n        for (i in N - 2 downTo 0)\\n            R[i] = Math.max(R[i], R[i + 1])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (k == 1)\\n                return R[i]\\n            var key = \"$i,$k\"\\n            if (!m.contains(key)) {\\n                var (best, cost) = listOf(INF, A[i])\\n                for (j in i..N - k) {\\n                    cost = Math.max(cost, A[j])\\n                    best = Math.min(best, cost + go(j + 1, k - 1))\\n                }\\n                m[key] = best\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        if (N < K)\\n            return -1\\n        var dp = Array(N) { IntArray(K + 1) { 0 } }\\n        dp[N - 1][1] = A[N - 1]\\n        for (i in N - 2 downTo 0)\\n            dp[i][1] = Math.max(dp[i + 1][1], A[i])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (k in 2..K) {\\n            for (i in 0..N - k) {\\n                var (best, cost) = listOf(INF, A[i])\\n                for (j in i..N - k) {\\n                    cost = Math.max(cost, A[j])\\n                    best = Math.min(best, cost + dp[j + 1][k - 1])\\n                }\\n                dp[i][k] = best\\n            }\\n        }\\n        return dp[0][K]\\n    }\\n}\\n```\\n\\n4. Memory optimization: we only need the previous `k`<sup>th</sup> solutions to construct the `k + 1`<sup>th</sup> solutions\\n```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        if (N < K)\\n            return -1\\n        var pre = IntArray(N) { 0 }\\n        pre[N - 1] = A[N - 1]\\n        for (i in N - 2 downTo 0)\\n            pre[i] = Math.max(pre[i + 1], A[i])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (k in 2..K) {\\n            var cur = pre.copyOf()\\n            for (i in 0..N - k) {\\n                var (best, cost) = listOf(INF, A[i])\\n                for (j in i..N - k) {\\n                    cost = Math.max(cost, A[j])\\n                    best = Math.min(best, cost + pre[j + 1])\\n                }\\n                cur[i] = best\\n            }\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet minDifficulty = (A, K) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let R = [...A];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] = Math.max(R[i], R[i + 1]);  // prefix right maximums used for base case to consume cost of last right-most chunk\\n    let go = (i = 0, k = K) => {\\n        if (k == 1)\\n            return R[i];\\n        let [best, cost] = [Infinity, A[i]];\\n        for (let j = i; j + k <= N; ++j) {\\n            cost = Math.max(cost, A[j]);\\n            best = Math.min(best, cost + go(j + 1, k - 1));\\n        }\\n        return best;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet minDifficulty = (A, K, m = new Map()) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let R = [...A];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] = Math.max(R[i], R[i + 1]);  // prefix right maximums used for base case to consume cost of last right-most chunk\\n    let go = (i = 0, k = K) => {\\n        if (k == 1)\\n            return R[i];\\n        let key = `${i},${k}`;\\n        if (!m.has(key)) {\\n            let [best, cost] = [Infinity, A[i]];\\n            for (let j = i; j + k <= N; ++j) {\\n                cost = Math.max(cost, A[j]);\\n                best = Math.min(best, cost + go(j + 1, k - 1));\\n            }\\n            m.set(key, best);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minDifficulty = (A, K) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let dp = [...Array(N)].map(_ => Array(K + 1).fill(Infinity));\\n    dp[N - 1][1] = A[N - 1];\\n    for (let i = N - 2; 0 <= i; --i)\\n        dp[i][1] = Math.max(dp[i + 1][1], A[i]);\\n    for (let k = 2; k <= K; ++k) {\\n        for (let i = 0; i + k <= N; ++i) {\\n            let [best, cost] = [Infinity, A[i]];\\n            for (let j = i; j + k <= N; ++j) {\\n                cost = Math.max(cost, A[j]);\\n                best = Math.min(best, cost + dp[j + 1][k - 1]);\\n            }\\n            dp[i][k] = best;\\n        }\\n    }\\n    return dp[0][K];\\n};\\n```\\n\\n4. Memory optimization: we only need the previous `k`<sup>th</sup> solutions to construct the `k + 1`<sup>th</sup> solutions\\n```\\nlet minDifficulty = (A, K) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let pre = [...A];\\n    for (let i = N - 2; 0 <= i; --i)\\n        pre[i] = Math.max(pre[i], pre[i + 1]);\\n    for (let k = 2; k <= K; ++k) {\\n        let cur = [...pre];\\n        for (let i = 0; i + k <= N; ++i) {\\n            let [best, cost] = [Infinity, A[i]];\\n            for (let j = i; j + k <= N; ++j) {\\n                cost = Math.max(cost, A[j]);\\n                best = Math.min(best, cost + pre[j + 1]);\\n            }\\n            cur[i] = best;\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        R = A[:]  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for i in range(N - 2, -1, -1):\\n            R[i] = max(R[i], R[i + 1])\\n        def go(i = 0, k = K):\\n            if k == 1:\\n                return R[i]\\n            best, cost = float(\\'inf\\'), A[i]\\n            for j in range(i, N - k + 1):\\n                cost = max(cost, A[j])\\n                best = min(best, cost + go(j + 1, k - 1))\\n            return best\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        R = A[:]  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for i in range(N - 2, -1, -1):\\n            R[i] = max(R[i], R[i + 1])\\n        @cache\\n        def go(i = 0, k = K):\\n            if k == 1:\\n                return R[i]\\n            best, cost = float(\\'inf\\'), A[i]\\n            for j in range(i, N - k + 1):\\n                cost = max(cost, A[j])\\n                best = min(best, cost + go(j + 1, k - 1))\\n            return best\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        dp = [[float(\\'inf\\')] * (K + 1) for _ in range(N)]\\n        dp[N - 1][1] = A[N - 1]\\n        for i in range(N - 2, -1, -1):\\n            dp[i][1] = max(dp[i + 1][1], A[i])  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for k in range(2, K + 1):\\n            for i in range(N):\\n                best, cost = float(\\'inf\\'), A[i]\\n                for j in range(i, N - k + 1):\\n                    cost = max(cost, A[j])\\n                    best = min(best, cost + dp[j + 1][k - 1])\\n                dp[i][k] = best\\n        return dp[0][K]\\n```\\n\\n4. Memory optimization: we only need the previous `k`<sup>th</sup> solutions to construct the `k + 1`<sup>th</sup> solutions\\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        pre = [float(\\'inf\\')] * N\\n        pre[N - 1] = A[N - 1]\\n        for i in range(N - 2, -1, -1):\\n            pre[i] = max(pre[i + 1], A[i])  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for k in range(2, K + 1):\\n            cur = pre[:]\\n            for i in range(N):\\n                best, cost = float(\\'inf\\'), A[i]\\n                for j in range(i, N - k + 1):\\n                    cost = max(cost, A[j])\\n                    best = min(best, cost + pre[j + 1])\\n                cur[i] = best\\n            pre, cur = cur, pre\\n        return pre[0]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        auto R{ A }; // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = max(R[i], R[i + 1]);\\n        fun go = [&](auto i, auto k) {\\n            if (k == 1)\\n                return R[i];\\n            auto [best, cost] = make_tuple(INF, A[i]);\\n            for (auto j{ i }; j + k <= N; ++j) {\\n                cost = max(cost, A[j]);\\n                best = min(best, cost + go(j + 1, k - 1));\\n            }\\n            return best;\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\\n\\n2a. **R**emember each subproblem\\'s optimal solution via a DP memo (using a Map `m`)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDifficulty(VI& A, int K, Map m = {}, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        auto R{ A }; // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = max(R[i], R[i + 1]);\\n        auto hash = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto k) {\\n            if (k == 1)\\n                return R[i];\\n            auto key = hash(i, k);\\n            if (m.find(key) == m.end()) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + go(j + 1, k - 1));\\n                }\\n                m[key] = best;\\n            }\\n            return m[key];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\\n\\n2b. **R**emember each subproblem\\'s optimal solution via a DP memo (using a 2d vector `dp`)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        auto R{ A }; // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = max(R[i], R[i + 1]);\\n        VVI dp(N, VI(K + 1, INF));\\n        fun go = [&](auto i, auto k) {\\n            if (k == 1)\\n                return R[i];\\n            if (dp[i][k] == INF) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + go(j + 1, k - 1));\\n                }\\n                dp[i][k] = best;\\n            }\\n            return dp[i][k];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        VVI dp(N + 1, VI(K + 1, INF));\\n        dp[N - 1][1] = A[N - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            dp[i][1] = max(dp[i + 1][1], A[i]); // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto k{ 2 }; k <= K; ++k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + dp[j + 1][k - 1]);\\n                }\\n                dp[i][k] = best;\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n};\\n```\\n\\n4. Memory optimization: we only need the previous `k`<sup>th</sup> solutions to construct the `k + 1`<sup>th</sup> solutions\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        VI pre(N, INF);\\n        pre[N - 1] = A[N - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            pre[i] = max(pre[i + 1], A[i]); // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto k{ 2 }; k <= K; ++k) {\\n            auto cur{ pre };\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + pre[j + 1]);\\n                }\\n                cur[i] = best;\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        if (N < K)\\n            return -1\\n        var R = A.copyOf()\\n        for (i in N - 2 downTo 0)\\n            R[i] = Math.max(R[i], R[i + 1])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (k == 1)\\n                return R[i]\\n            var (best, cost) = listOf(INF, A[i])\\n            for (j in i..N - k) {\\n                cost = Math.max(cost, A[j])\\n                best = Math.min(best, cost + go(j + 1, k - 1))\\n            }\\n            return best\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        if (N < K)\\n            return -1\\n        var R = A.copyOf()\\n        for (i in N - 2 downTo 0)\\n            R[i] = Math.max(R[i], R[i + 1])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (k == 1)\\n                return R[i]\\n            var key = \"$i,$k\"\\n            if (!m.contains(key)) {\\n                var (best, cost) = listOf(INF, A[i])\\n                for (j in i..N - k) {\\n                    cost = Math.max(cost, A[j])\\n                    best = Math.min(best, cost + go(j + 1, k - 1))\\n                }\\n                m[key] = best\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        if (N < K)\\n            return -1\\n        var dp = Array(N) { IntArray(K + 1) { 0 } }\\n        dp[N - 1][1] = A[N - 1]\\n        for (i in N - 2 downTo 0)\\n            dp[i][1] = Math.max(dp[i + 1][1], A[i])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (k in 2..K) {\\n            for (i in 0..N - k) {\\n                var (best, cost) = listOf(INF, A[i])\\n                for (j in i..N - k) {\\n                    cost = Math.max(cost, A[j])\\n                    best = Math.min(best, cost + dp[j + 1][k - 1])\\n                }\\n                dp[i][k] = best\\n            }\\n        }\\n        return dp[0][K]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDifficulty(A: IntArray, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        if (N < K)\\n            return -1\\n        var pre = IntArray(N) { 0 }\\n        pre[N - 1] = A[N - 1]\\n        for (i in N - 2 downTo 0)\\n            pre[i] = Math.max(pre[i + 1], A[i])  // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (k in 2..K) {\\n            var cur = pre.copyOf()\\n            for (i in 0..N - k) {\\n                var (best, cost) = listOf(INF, A[i])\\n                for (j in i..N - k) {\\n                    cost = Math.max(cost, A[j])\\n                    best = Math.min(best, cost + pre[j + 1])\\n                }\\n                cur[i] = best\\n            }\\n            pre = cur.also{ cur = pre }\\n        }\\n        return pre[0]\\n    }\\n}\\n```\n```\\nlet minDifficulty = (A, K) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let R = [...A];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] = Math.max(R[i], R[i + 1]);  // prefix right maximums used for base case to consume cost of last right-most chunk\\n    let go = (i = 0, k = K) => {\\n        if (k == 1)\\n            return R[i];\\n        let [best, cost] = [Infinity, A[i]];\\n        for (let j = i; j + k <= N; ++j) {\\n            cost = Math.max(cost, A[j]);\\n            best = Math.min(best, cost + go(j + 1, k - 1));\\n        }\\n        return best;\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDifficulty = (A, K, m = new Map()) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let R = [...A];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] = Math.max(R[i], R[i + 1]);  // prefix right maximums used for base case to consume cost of last right-most chunk\\n    let go = (i = 0, k = K) => {\\n        if (k == 1)\\n            return R[i];\\n        let key = `${i},${k}`;\\n        if (!m.has(key)) {\\n            let [best, cost] = [Infinity, A[i]];\\n            for (let j = i; j + k <= N; ++j) {\\n                cost = Math.max(cost, A[j]);\\n                best = Math.min(best, cost + go(j + 1, k - 1));\\n            }\\n            m.set(key, best);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDifficulty = (A, K) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let dp = [...Array(N)].map(_ => Array(K + 1).fill(Infinity));\\n    dp[N - 1][1] = A[N - 1];\\n    for (let i = N - 2; 0 <= i; --i)\\n        dp[i][1] = Math.max(dp[i + 1][1], A[i]);\\n    for (let k = 2; k <= K; ++k) {\\n        for (let i = 0; i + k <= N; ++i) {\\n            let [best, cost] = [Infinity, A[i]];\\n            for (let j = i; j + k <= N; ++j) {\\n                cost = Math.max(cost, A[j]);\\n                best = Math.min(best, cost + dp[j + 1][k - 1]);\\n            }\\n            dp[i][k] = best;\\n        }\\n    }\\n    return dp[0][K];\\n};\\n```\n```\\nlet minDifficulty = (A, K) => {\\n    let N = A.length;\\n    if (N < K)\\n        return -1;\\n    let pre = [...A];\\n    for (let i = N - 2; 0 <= i; --i)\\n        pre[i] = Math.max(pre[i], pre[i + 1]);\\n    for (let k = 2; k <= K; ++k) {\\n        let cur = [...pre];\\n        for (let i = 0; i + k <= N; ++i) {\\n            let [best, cost] = [Infinity, A[i]];\\n            for (let j = i; j + k <= N; ++j) {\\n                cost = Math.max(cost, A[j]);\\n                best = Math.min(best, cost + pre[j + 1]);\\n            }\\n            cur[i] = best;\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[0];\\n};\\n```\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        R = A[:]  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for i in range(N - 2, -1, -1):\\n            R[i] = max(R[i], R[i + 1])\\n        def go(i = 0, k = K):\\n            if k == 1:\\n                return R[i]\\n            best, cost = float(\\'inf\\'), A[i]\\n            for j in range(i, N - k + 1):\\n                cost = max(cost, A[j])\\n                best = min(best, cost + go(j + 1, k - 1))\\n            return best\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        R = A[:]  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for i in range(N - 2, -1, -1):\\n            R[i] = max(R[i], R[i + 1])\\n        @cache\\n        def go(i = 0, k = K):\\n            if k == 1:\\n                return R[i]\\n            best, cost = float(\\'inf\\'), A[i]\\n            for j in range(i, N - k + 1):\\n                cost = max(cost, A[j])\\n                best = min(best, cost + go(j + 1, k - 1))\\n            return best\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        dp = [[float(\\'inf\\')] * (K + 1) for _ in range(N)]\\n        dp[N - 1][1] = A[N - 1]\\n        for i in range(N - 2, -1, -1):\\n            dp[i][1] = max(dp[i + 1][1], A[i])  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for k in range(2, K + 1):\\n            for i in range(N):\\n                best, cost = float(\\'inf\\'), A[i]\\n                for j in range(i, N - k + 1):\\n                    cost = max(cost, A[j])\\n                    best = min(best, cost + dp[j + 1][k - 1])\\n                dp[i][k] = best\\n        return dp[0][K]\\n```\n```\\nclass Solution:\\n    def minDifficulty(self, A: List[int], K: int) -> int:\\n        N = len(A)\\n        if N < K:\\n            return -1\\n        pre = [float(\\'inf\\')] * N\\n        pre[N - 1] = A[N - 1]\\n        for i in range(N - 2, -1, -1):\\n            pre[i] = max(pre[i + 1], A[i])  # prefix right maximums used for base case to consume cost of last right-most chunk\\n        for k in range(2, K + 1):\\n            cur = pre[:]\\n            for i in range(N):\\n                best, cost = float(\\'inf\\'), A[i]\\n                for j in range(i, N - k + 1):\\n                    cost = max(cost, A[j])\\n                    best = min(best, cost + pre[j + 1])\\n                cur[i] = best\\n            pre, cur = cur, pre\\n        return pre[0]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        auto R{ A }; // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = max(R[i], R[i + 1]);\\n        fun go = [&](auto i, auto k) {\\n            if (k == 1)\\n                return R[i];\\n            auto [best, cost] = make_tuple(INF, A[i]);\\n            for (auto j{ i }; j + k <= N; ++j) {\\n                cost = max(cost, A[j]);\\n                best = min(best, cost + go(j + 1, k - 1));\\n            }\\n            return best;\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDifficulty(VI& A, int K, Map m = {}, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        auto R{ A }; // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = max(R[i], R[i + 1]);\\n        auto hash = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto k) {\\n            if (k == 1)\\n                return R[i];\\n            auto key = hash(i, k);\\n            if (m.find(key) == m.end()) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + go(j + 1, k - 1));\\n                }\\n                m[key] = best;\\n            }\\n            return m[key];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        auto R{ A }; // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = max(R[i], R[i + 1]);\\n        VVI dp(N, VI(K + 1, INF));\\n        fun go = [&](auto i, auto k) {\\n            if (k == 1)\\n                return R[i];\\n            if (dp[i][k] == INF) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + go(j + 1, k - 1));\\n                }\\n                dp[i][k] = best;\\n            }\\n            return dp[i][k];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        VVI dp(N + 1, VI(K + 1, INF));\\n        dp[N - 1][1] = A[N - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            dp[i][1] = max(dp[i + 1][1], A[i]); // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto k{ 2 }; k <= K; ++k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + dp[j + 1][k - 1]);\\n                }\\n                dp[i][k] = best;\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDifficulty(VI& A, int K, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        if (N < K)\\n            return -1;\\n        VI pre(N, INF);\\n        pre[N - 1] = A[N - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            pre[i] = max(pre[i + 1], A[i]); // prefix right maximums used for base case to consume cost of last right-most chunk\\n        for (auto k{ 2 }; k <= K; ++k) {\\n            auto cur{ pre };\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto [best, cost] = make_tuple(INF, A[i]);\\n                for (auto j{ i }; j + k <= N; ++j) {\\n                    cost = max(cost, A[j]);\\n                    best = min(best, cost + pre[j + 1]);\\n                }\\n                cur[i] = best;\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415950,
                "title": "c-memoization",
                "content": "What is the meaning of the question?\\nSplit the array into \\'d\\' groups such that the sum of maximum in each group in minimum. \\n```\\nclass Solution {\\npublic:\\n    int n , maxVal = 1e7;\\n    int solve(vector<int>& jobs, int d , int index ,  vector<vector<int>> &dp){\\n        if(n==index && d==0)\\n            return 0; \\n        if(n==index || d==0 || n-index<d)\\n            return maxVal; \\n        if(dp[index][d]!=-1)\\n            return dp[index][d]; \\n        int maxEle = 0 , ans = maxVal; \\n        for(int i=index;i<n;i++){\\n            maxEle = max(maxEle, jobs[i]);\\n            ans = min(ans , maxEle + solve(jobs , d-1 , i+1 , dp));\\n        }\\n        return dp[index][d] =ans;\\n    }\\n    \\n    int minDifficulty(vector<int>& jobs, int d) {\\n        n = jobs.size();\\n        if(n<d)\\n            return -1; \\n        vector<vector<int>> dp(n,vector<int>(d+1,-1));\\n        return solve(jobs , d , 0 , dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , maxVal = 1e7;\\n    int solve(vector<int>& jobs, int d , int index ,  vector<vector<int>> &dp){\\n        if(n==index && d==0)\\n            return 0; \\n        if(n==index || d==0 || n-index<d)\\n            return maxVal; \\n        if(dp[index][d]!=-1)\\n            return dp[index][d]; \\n        int maxEle = 0 , ans = maxVal; \\n        for(int i=index;i<n;i++){\\n            maxEle = max(maxEle, jobs[i]);\\n            ans = min(ans , maxEle + solve(jobs , d-1 , i+1 , dp));\\n        }\\n        return dp[index][d] =ans;\\n    }\\n    \\n    int minDifficulty(vector<int>& jobs, int d) {\\n        n = jobs.size();\\n        if(n<d)\\n            return -1; \\n        vector<vector<int>> dp(n,vector<int>(d+1,-1));\\n        return solve(jobs , d , 0 , dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402272,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[302][11];\\n    int solve(vector<int>&v, int n, int i, int d){\\n        if(d==1){\\n            int mx=0;\\n            for(int k=i;k<n;k++){\\n                mx=max(mx,v[k]);\\n            }\\n            return mx;\\n        }\\n        if(dp[i][d]!=-1)\\n            return dp[i][d];\\n        int mx=0;\\n        int ans=INT_MAX;\\n        for(int k=i;k<=n-d;k++){\\n            mx=max(mx,v[k]);\\n            int temp=solve(v,n,k+1,d-1);\\n            ans=min(ans,mx+temp);\\n        }\\n        return dp[i][d]=ans;\\n    }\\n    int minDifficulty(vector<int>& v, int d) {\\n        int n=v.size();\\n        if(n<d)\\n            return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(v,n,0,d);\\n        return res;\\n    }\\n};\\n```\\n**Do upvote if you find it helpful!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[302][11];\\n    int solve(vector<int>&v, int n, int i, int d){\\n        if(d==1){\\n            int mx=0;\\n            for(int k=i;k<n;k++){\\n                mx=max(mx,v[k]);\\n            }\\n            return mx;\\n        }\\n        if(dp[i][d]!=-1)\\n            return dp[i][d];\\n        int mx=0;\\n        int ans=INT_MAX;\\n        for(int k=i;k<=n-d;k++){\\n            mx=max(mx,v[k]);\\n            int temp=solve(v,n,k+1,d-1);\\n            ans=min(ans,mx+temp);\\n        }\\n        return dp[i][d]=ans;\\n    }\\n    int minDifficulty(vector<int>& v, int d) {\\n        int n=v.size();\\n        if(n<d)\\n            return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(v,n,0,d);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276408,
                "title": "c-simple-and-short-dfs-dp-solution",
                "content": "```\\nint dp[301][11];\\nint solve(vector<int> &diff, int i, int days) {\\n\\tif(i >= diff.size() && days <= 0) return 0; \\n\\tif(i >= diff.size() || days <= 0) return 1e6;\\n\\tif(dp[i][days] != -1) return dp[i][days];\\n\\n\\tint maxTillHere = diff[i], ans = 1e6;\\n\\tfor(int j=i;j<diff.size();j++) {\\n\\t\\tmaxTillHere = max(maxTillHere, diff[j]);\\n\\t\\tans = min(ans, solve(diff, j+1, days-1) + maxTillHere);\\n\\t}\\n\\treturn dp[i][days] = ans;\\n}\\n\\nint minDifficulty(vector<int> &jobDiff, int d) {\\n\\tmemset(dp, -1, sizeof dp);\\n\\tint ans = solve(jobDiff, 0, d);\\n\\treturn ans >= 1e6 ? -1 : ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[301][11];\\nint solve(vector<int> &diff, int i, int days) {\\n\\tif(i >= diff.size() && days <= 0) return 0; \\n\\tif(i >= diff.size() || days <= 0) return 1e6;\\n\\tif(dp[i][days] != -1) return dp[i][days];\\n\\n\\tint maxTillHere = diff[i], ans = 1e6;\\n\\tfor(int j=i;j<diff.size();j++) {\\n\\t\\tmaxTillHere = max(maxTillHere, diff[j]);\\n\\t\\tans = min(ans, solve(diff, j+1, days-1) + maxTillHere);\\n\\t}\\n\\treturn dp[i][days] = ans;\\n}\\n\\nint minDifficulty(vector<int> &jobDiff, int d) {\\n\\tmemset(dp, -1, sizeof dp);\\n\\tint ans = solve(jobDiff, 0, d);\\n\\treturn ans >= 1e6 ? -1 : ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079504,
                "title": "python-memoization",
                "content": "# Idea\\nWe can solve this problem by splitting it into subproblems. With each job we have to make a decision, do we keep working today after we\\'re finished with this or do we end our day and start from scratch tomorrow. We also need to make sure we work at least one day each day (edge cases). See the comments for more clarification.\\n```\\ndef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\tjob_count = len(jobDifficulty)\\n\\tif job_count < d: return -1  # not enough jobs to work on at least one a day\\n\\n\\t@lru_cache(None)\\n\\tdef min_score(last_score=0, cur_idx=0, div_left=d-1):\\n\\t\\tif div_left == 0: return max([last_score] + jobDifficulty[cur_idx:])  # our last day, we have to keep working until we\\'re out of jobs\\n\\t\\tcur_score = max(last_score, jobDifficulty[cur_idx])  # our difficulty for today might increase since we take on this job\\n\\t\\t\\n\\t\\tif job_count - cur_idx == div_left + 1:\\n\\t\\t\\treturn cur_score + sum(jobDifficulty[cur_idx+1:]) # we have to keep splitting to have 1 job per day\\n\\t\\tjoin_score = min_score(cur_score, cur_idx+1, div_left)  # keep working \\n\\t\\tdiv_score = cur_score + min_score(0, cur_idx+1, div_left-1) # start fresh tomorrow\\n\\t\\treturn min(join_score, div_score)\\n\\n\\treturn min_score()\\n```\\n## Complexity\\nTime/Memory: `O(n^2*d)`\\nPlease correct me if I\\'m wrong about the complexity.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\tjob_count = len(jobDifficulty)\\n\\tif job_count < d: return -1  # not enough jobs to work on at least one a day\\n\\n\\t@lru_cache(None)\\n\\tdef min_score(last_score=0, cur_idx=0, div_left=d-1):\\n\\t\\tif div_left == 0: return max([last_score] + jobDifficulty[cur_idx:])  # our last day, we have to keep working until we\\'re out of jobs\\n\\t\\tcur_score = max(last_score, jobDifficulty[cur_idx])  # our difficulty for today might increase since we take on this job\\n\\t\\t\\n\\t\\tif job_count - cur_idx == div_left + 1:\\n\\t\\t\\treturn cur_score + sum(jobDifficulty[cur_idx+1:]) # we have to keep splitting to have 1 job per day\\n\\t\\tjoin_score = min_score(cur_score, cur_idx+1, div_left)  # keep working \\n\\t\\tdiv_score = cur_score + min_score(0, cur_idx+1, div_left-1) # start fresh tomorrow\\n\\t\\treturn min(join_score, div_score)\\n\\n\\treturn min_score()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1023488,
                "title": "python3-clean-dynamic-programming-explanation-in-comments",
                "content": "```\\nclass Solution:       \\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        A = [[1 for j in range(n)] for i in range(d)]\\n\\t\\t# A[i][j] will refer to minimum difficulty schedule cost for finishing first (j+1) jobs in exactly (i+1) days.\\n        for i in range(d):\\n            for j in range(n):\\n                if i == 0:  # If only 1 day is available, minimum difficulty is simply maximum difficulty of the job.\\n                    A[0][j] = max(jobDifficulty[:j+1])\\n                elif i == j: # If number of days is equal to number of jobs, then each day is allocated exactly one job.\\n                    A[i][j] = sum(jobDifficulty[:j+1])\\n                elif i > j: # If number of days > number of jobs, scheduling is infeasible\\n                    A[i][j] = -1\\n                else:\\n                    vals = []\\n                    for k in range(i-1, j):\\n                        prev_difficulty = A[i-1][k] # First (k+1) jobs in exactly (i-1) days\\n                        curr_difficulty = max(jobDifficulty[k+1:j+1]) # Allocate remaining jobs to i-th day.\\n                        vals.append(curr_difficulty + prev_difficulty)\\n                    A[i][j] = min(vals) # Find the best split from above choices of splits.\\n        return A[d-1][n-1]\\n```\\n\\nI suppose this solution is slower than most because I do not use memoization. But it is clean and easy to understand. So sharing it.\\n\\nThis solution can be further optimized for space complexity by realizing that for calculing values of `i`-th row, we only need values from the `(i-1)`-th row, and we can discard all the rows before that. So, instead we just need to keep 2 rows at a time.",
                "solutionTags": [],
                "code": "```\\nclass Solution:       \\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        A = [[1 for j in range(n)] for i in range(d)]\\n\\t\\t# A[i][j] will refer to minimum difficulty schedule cost for finishing first (j+1) jobs in exactly (i+1) days.\\n        for i in range(d):\\n            for j in range(n):\\n                if i == 0:  # If only 1 day is available, minimum difficulty is simply maximum difficulty of the job.\\n                    A[0][j] = max(jobDifficulty[:j+1])\\n                elif i == j: # If number of days is equal to number of jobs, then each day is allocated exactly one job.\\n                    A[i][j] = sum(jobDifficulty[:j+1])\\n                elif i > j: # If number of days > number of jobs, scheduling is infeasible\\n                    A[i][j] = -1\\n                else:\\n                    vals = []\\n                    for k in range(i-1, j):\\n                        prev_difficulty = A[i-1][k] # First (k+1) jobs in exactly (i-1) days\\n                        curr_difficulty = max(jobDifficulty[k+1:j+1]) # Allocate remaining jobs to i-th day.\\n                        vals.append(curr_difficulty + prev_difficulty)\\n                    A[i][j] = min(vals) # Find the best split from above choices of splits.\\n        return A[d-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946361,
                "title": "dp-solution-easy-to-understand",
                "content": "DP Solution, easy to understand\\n\\n**n** is the total jobs number, **dp(i, d)** means it takes **d** days to finish jobs starting from i, that is jobs **[i ... n-1]**. \\nThe final answer is **dp(0, d)** - finish all jobs in d days.\\n\\nFor day = 1,\\ndp(0, 1) means finish jobs [0 .. n-1] in 1 day,\\ndp(1, 1) means finish jobs [1 .. n-1] in 1 day,\\n...\\ndp(n-1, 1) means finish jobs [n-1, n-1] in 1 day,\\nObviously, **dp(i, 1) = Max(job[i] ... job[n-1])**.\\n\\nTo solve this problem, we split it as **finish  [0..i] in 1 day, then finish [i+1,n-1] in d-1 days**\\n\\ne.g. for day = 2\\uFF0C\\ndp(0, 2) = Min ( Max(job[0] ... job[i]) + dp(i+1, 1))\\ndp(1, 2) = Min ( Max(job[1] ... job[i]) + dp(i+1, 1))\\n...\\ndp(n-2, 2) = Min ( Max(job[n-2] ...job[n-2]) + dp(n-1, 1) )\\n\\nNote that in dp(i, d)\\uFF0Cthe range of **i** is [0 ... n-d]. The reason is **for d-1 days, we need at least d-1 jobs, so the max jobs done in day 1 is` n-1-(d-1) = n-d`**.\\n\\n~~~\\n\\nint n = jobDifficulty.length;\\n\\nif (d>n) return -1;\\n\\nif (d==n) {\\n\\tint sum = 0;\\n\\tfor (int i : jobDifficulty) sum += i;\\n\\treturn sum;\\n}\\n        \\n//Calculate the max difficulty job within jobDifficulty[i ... j]\\nmaxDiff = new int[n][n];\\nfor (int i=0; i<n; i++) {\\n\\tint max = jobDifficulty[i];\\n\\tfor (int j=i; j<n; j++) {\\n\\t\\tmax = Math.max(max, jobDifficulty[j]);\\n\\t\\tmaxDiff[i][j]=max;\\n\\t}\\n}\\n        \\n//dp[i][j] means for all jobs starting from i, finish them in j days\\n//so the answer is dp[0][d] - finish all jobs in d days\\ndp = new int[n][d+1];\\n//If day == 1,\\n//it is obvious that dp[i][1] is the max difficulty of jobs of [i ... n-1]\\nfor (int i=0; i<n; i++) {\\n\\tdp[i][1] = maxDiff[i][n-1];\\n}\\n\\n\\nfor (int day=2; day<=d; day++) {\\n\\t//we need to calc dp[0][day], dp[1][day], ..., dp[n-day][day]\\n\\tfor (int i=0; i<=n-day; i++) {\\n\\t\\tint val = Integer.MAX_VALUE;\\n\\t\\tfor (int j=i; j<=n-day; j++) {\\n\\t\\t\\t//try to do jobs [i..j] in day 1, do [j+1...n-1] in rest days\\n\\t\\t\\t//get the minimal value\\n\\t\\t\\tval = Math.min(val, maxDiff[i][j] + dp[j+1][day-1]);\\n\\t\\t}\\n\\t\\tdp[i][day]=val;\\n\\t}\\n}\\n\\nreturn dp[0][d];\\n\\n~~~~\\n",
                "solutionTags": [],
                "code": "DP Solution, easy to understand\\n\\n**n** is the total jobs number, **dp(i, d)** means it takes **d** days to finish jobs starting from i, that is jobs **[i ... n-1]**. \\nThe final answer is **dp(0, d)** - finish all jobs in d days.\\n\\nFor day = 1,\\ndp(0, 1) means finish jobs [0 .. n-1] in 1 day,\\ndp(1, 1) means finish jobs [1 .. n-1] in 1 day,\\n...\\ndp(n-1, 1) means finish jobs [n-1, n-1] in 1 day,\\nObviously, **dp(i, 1) = Max(job[i] ... job[n-1])**.\\n\\nTo solve this problem, we split it as **finish  [0..i] in 1 day, then finish [i+1,n-1] in d-1 days**\\n\\ne.g. for day = 2\\uFF0C\\ndp(0, 2) = Min ( Max(job[0] ... job[i]) + dp(i+1, 1))\\ndp(1, 2) = Min ( Max(job[1] ... job[i]) + dp(i+1, 1))\\n...\\ndp(n-2, 2) = Min ( Max(job[n-2] ...job[n-2]) + dp(n-1, 1) )\\n\\nNote that in dp(i, d)\\uFF0Cthe range of **i** is [0 ... n-d]. The reason is **for d-1 days, we need at least d-1 jobs, so the max jobs done in day 1 is` n-1-(d-1) = n-d`**.\\n\\n~~~\\n\\nint n = jobDifficulty.length;\\n\\nif (d>n) return -1;\\n\\nif (d==n) {\\n\\tint sum = 0;\\n\\tfor (int i : jobDifficulty) sum += i;\\n\\treturn sum;\\n}\\n        \\n//Calculate the max difficulty job within jobDifficulty[i ... j]\\nmaxDiff = new int[n][n];\\nfor (int i=0; i<n; i++) {\\n\\tint max = jobDifficulty[i];\\n\\tfor (int j=i; j<n; j++) {\\n\\t\\tmax = Math.max(max, jobDifficulty[j]);\\n\\t\\tmaxDiff[i][j]=max;\\n\\t}\\n}\\n        \\n//dp[i][j] means for all jobs starting from i, finish them in j days\\n//so the answer is dp[0][d] - finish all jobs in d days\\ndp = new int[n][d+1];\\n//If day == 1,\\n//it is obvious that dp[i][1] is the max difficulty of jobs of [i ... n-1]\\nfor (int i=0; i<n; i++) {\\n\\tdp[i][1] = maxDiff[i][n-1];\\n}\\n\\n\\nfor (int day=2; day<=d; day++) {\\n\\t//we need to calc dp[0][day], dp[1][day], ..., dp[n-day][day]\\n\\tfor (int i=0; i<=n-day; i++) {\\n\\t\\tint val = Integer.MAX_VALUE;\\n\\t\\tfor (int j=i; j<=n-day; j++) {\\n\\t\\t\\t//try to do jobs [i..j] in day 1, do [j+1...n-1] in rest days\\n\\t\\t\\t//get the minimal value\\n\\t\\t\\tval = Math.min(val, maxDiff[i][j] + dp[j+1][day-1]);\\n\\t\\t}\\n\\t\\tdp[i][day]=val;\\n\\t}\\n}\\n\\nreturn dp[0][d];\\n\\n~~~~\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 907440,
                "title": "python-3-dp-o-dn-2-bottom-up-easy-understandable",
                "content": "Hi All,\\nThis is my first attempt of answering a problem. \\nIt is a hard problem for this reason you would need to spend more time than usual to solve this. It took me 40 mins to get to a solution, this is with the idea that I have a background in CS as well as I have done a few DP problems.\\nFirst step is to consider how to break the problem. Either by days or by jobListings.\\nThe only way I broke the problem is on the number of days, since breaking by jobListing was not intuitive for me. \\nI have to start from what if there is only 1 day then it is max(jobListing).\\nDay 2 would be max(jobListings for Day 2) + max(joblisting for Day 1).\\nThis gives me the idea that each stage the solution is dependent on the previous stage and that the solution depends on both the day as well as jobListing. \\nFrom here I formalize my DP solution, first stage on day and then on Joblisting.  \\nDay 1 - would have my solution till the jobListing I am considering which means \\n0,0 - would be just day 1 with 1 jobListing\\n0,1 would be day 1 with 1,2 jobListing\\nHence the day representation would need a list of length JobListing and the whole storage would need length of days * length of jobListing..\\nSo now formalizing the algorithm\\njobListing i\\n#DP[0][i] = max(jobListing[ 0...i ])\\nDay 1, jobListing i\\n#DP[1][0] = Invalid/None\\n#DP[1][1] = max(job[1:1]) + DP[0][0]\\n#DP[1][2] = min(max(job[1:2]) + DP[0][0], max(job[2:2]) + DP[0][1])\\n#DP[1][3] = min(max(job[1:3]) + DP[0][0], max(job[2:3]) + DP[0][1], max(job[3:3]) + DP[0][2])\\n\\t\\t\\n\\nclass Solution:\\n    \\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:     \\n\\t\\tN_job = len(jobDifficulty)\\n        DP = [ [None]*N_job for _ in range(d)]\\n        DP[0][0] = jobDifficulty[0]\\n        for i in range(1,N_job-(d-1)):\\n            DP[0][i] = max(jobDifficulty[0:i+1])\\n        \\n        for day in range(1,d):\\n            jobsConsidered = N_job-(d-(day+1))\\n            for job in range(day,jobsConsidered):\\n                DP[day][job] = float(\"inf\")\\n                for i in range(day,job+1):\\n                    val = max(jobDifficulty[i:job+1]) + DP[day-1][i-1]\\n                    DP[day][job] = min(DP[day][job],val)\\n        \\n        if DP[d-1][N_job-1] == None:\\n            return -1\\n        return DP[d-1][N_job-1]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "Hi All,\\nThis is my first attempt of answering a problem. \\nIt is a hard problem for this reason you would need to spend more time than usual to solve this. It took me 40 mins to get to a solution, this is with the idea that I have a background in CS as well as I have done a few DP problems.\\nFirst step is to consider how to break the problem. Either by days or by jobListings.\\nThe only way I broke the problem is on the number of days, since breaking by jobListing was not intuitive for me. \\nI have to start from what if there is only 1 day then it is max(jobListing).\\nDay 2 would be max(jobListings for Day 2) + max(joblisting for Day 1).\\nThis gives me the idea that each stage the solution is dependent on the previous stage and that the solution depends on both the day as well as jobListing. \\nFrom here I formalize my DP solution, first stage on day and then on Joblisting.  \\nDay 1 - would have my solution till the jobListing I am considering which means \\n0,0 - would be just day 1 with 1 jobListing\\n0,1 would be day 1 with 1,2 jobListing\\nHence the day representation would need a list of length JobListing and the whole storage would need length of days * length of jobListing..\\nSo now formalizing the algorithm\\njobListing i\\n#DP[0][i] = max(jobListing[ 0...i ])\\nDay 1, jobListing i\\n#DP[1][0] = Invalid/None\\n#DP[1][1] = max(job[1:1]) + DP[0][0]\\n#DP[1][2] = min(max(job[1:2]) + DP[0][0], max(job[2:2]) + DP[0][1])\\n#DP[1][3] = min(max(job[1:3]) + DP[0][0], max(job[2:3]) + DP[0][1], max(job[3:3]) + DP[0][2])\\n\\t\\t\\n\\nclass Solution:\\n    \\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:     \\n\\t\\tN_job = len(jobDifficulty)\\n        DP = [ [None]*N_job for _ in range(d)]\\n        DP[0][0] = jobDifficulty[0]\\n        for i in range(1,N_job-(d-1)):\\n            DP[0][i] = max(jobDifficulty[0:i+1])\\n        \\n        for day in range(1,d):\\n            jobsConsidered = N_job-(d-(day+1))\\n            for job in range(day,jobsConsidered):\\n                DP[day][job] = float(\"inf\")\\n                for i in range(day,job+1):\\n                    val = max(jobDifficulty[i:job+1]) + DP[day-1][i-1]\\n                    DP[day][job] = min(DP[day][job],val)\\n        \\n        if DP[d-1][N_job-1] == None:\\n            return -1\\n        return DP[d-1][N_job-1]",
                "codeTag": "Java"
            },
            {
                "id": 542109,
                "title": "simple-c-dp-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int MinDifficulty(int[] jobDifficulty, int d)\\n        {\\n            checked\\n            {\\n                long[,] dp = new long[jobDifficulty.Length + 1, d + 1];\\n\\n                for (int i = 1; i <= jobDifficulty.Length; i++)\\n                {\\n                    dp[i, 0] = int.MaxValue;\\n                }\\n\\n                for (int i = 1; i <= d; i++)\\n                {\\n                    dp[0, i] = int.MaxValue;\\n                }\\n\\n                for (int i = 1; i <= jobDifficulty.Length; i++)\\n                {\\n                    for (int j = 1; j <= d; j++)\\n                    {\\n                        dp[i, j] = int.MaxValue;\\n\\n                        if (j > i)\\n                        {\\n                            continue;\\n                        }\\n\\n                        int max = int.MinValue;\\n                        for (int k = i; k >= 1; k--)\\n                        {\\n                            max = Math.Max(max, jobDifficulty[k - 1]);\\n                            dp[i, j] = Math.Min(dp[i, j], dp[k - 1, j - 1] + max);\\n                        }\\n\\n                    }\\n                }\\n\\n                var res = dp[jobDifficulty.Length, d];\\n                return res >= int.MaxValue ? -1 : (int)res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public int MinDifficulty(int[] jobDifficulty, int d)\\n        {\\n            checked\\n            {\\n                long[,] dp = new long[jobDifficulty.Length + 1, d + 1];\\n\\n                for (int i = 1; i <= jobDifficulty.Length; i++)\\n                {\\n                    dp[i, 0] = int.MaxValue;\\n                }\\n\\n                for (int i = 1; i <= d; i++)\\n                {\\n                    dp[0, i] = int.MaxValue;\\n                }\\n\\n                for (int i = 1; i <= jobDifficulty.Length; i++)\\n                {\\n                    for (int j = 1; j <= d; j++)\\n                    {\\n                        dp[i, j] = int.MaxValue;\\n\\n                        if (j > i)\\n                        {\\n                            continue;\\n                        }\\n\\n                        int max = int.MinValue;\\n                        for (int k = i; k >= 1; k--)\\n                        {\\n                            max = Math.Max(max, jobDifficulty[k - 1]);\\n                            dp[i, j] = Math.Min(dp[i, j], dp[k - 1, j - 1] + max);\\n                        }\\n\\n                    }\\n                }\\n\\n                var res = dp[jobDifficulty.Length, d];\\n                return res >= int.MaxValue ? -1 : (int)res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507670,
                "title": "javascript-easy-to-understand-dfs-1d-dp-monotonic-stack",
                "content": "### DFS\\n\\nWe try all possible case by DFS. Don\\'t forget the cache.\\n\\n```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n  const cache = new Map();\\n  return helper(0, d);\\n\\n  function helper(idx, count) {\\n    const key = idx * 100 + count;\\n    if (!cache.has(key)) {\\n      if (count === 1) {\\n        let max = 0;\\n        for (let i = idx; i < LEN; ++i) {\\n          jobDifficulty[i] > max && (max = jobDifficulty[i]);\\n        }\\n        return max;\\n      }\\n      let min = 10000;\\n      let curMax = 0;\\n      for (let i = idx; i <= LEN - count; ++i) {\\n        if (jobDifficulty[i] > curMax) curMax = jobDifficulty[i];\\n        min = Math.min(min, curMax + helper(i + 1, count - 1));\\n      }\\n      cache.set(key, min);\\n    }\\n    return cache.get(key);\\n  }\\n};\\n```\\n\\n### 2D DP\\n\\nWe can get `dp[i][j]` by this:\\n\\n```js\\ndp[i][j] = Math.min(\\n  dp[i + 1][j - 1] + max(i, i),\\n  dp[i + 2][j - 1] + max(i, i + 1),\\n  ...\\n  dp[n - j + 1][j - 1] + max(i, n - j)\\n);\\n```\\n\\nSo here\\'s the code:\\n\\n```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n  const dp = Array.from({ length: LEN }, () => new Uint16Array(d + 1).fill(10000));\\n\\n  for (let i = LEN - 1, curMax = 0; i >= 0; --i) {\\n    jobDifficulty[i] > curMax && (curMax = jobDifficulty[i]);\\n    dp[i][1] = curMax;\\n  }\\n\\n  for (let i = 2; i <= d; ++i) {\\n    for (let j = 0; j <= LEN - i; ++j) {\\n      let max = 0;\\n      for (let k = j; k <= LEN - i; ++k) {\\n        jobDifficulty[k] > max && (max = jobDifficulty[k]);\\n        dp[j][i] = Math.min(dp[j][i], dp[k + 1][i - 1] + max);\\n      }\\n    }\\n  }\\n\\n  return dp[0][d];\\n};\\n```\\n\\n### 1D DP\\n\\nWe can do the optimization from the code above to just use 1D array.\\n\\n```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n  const dp = new Uint16Array(LEN + 1);\\n\\n  for (let i = LEN - 1; i >= 0; --i) {\\n    dp[i] = jobDifficulty[i] > dp[i + 1] ? jobDifficulty[i] : dp[i + 1];\\n  }\\n\\n  for (let i = 2; i <= d; ++i) {\\n    for (let j = 0; j <= LEN - i; ++j) {\\n      let max = 0;\\n      dp[j] = 10000;\\n      for (let k = j; k <= LEN - i; ++k) {\\n        jobDifficulty[k] > max && (max = jobDifficulty[k]);\\n        dp[j] > dp[k + 1] + max && (dp[j] = dp[k + 1] + max);\\n      }\\n    }\\n  }\\n\\n  return dp[0];\\n};\\n```\\n\\n### Monotonic stack\\n\\n```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n\\n  const dp = new Uint16Array(LEN);\\n  dp[0] = jobDifficulty[0];\\n  for (let i = 1; i < LEN; ++i) {\\n    dp[i] = jobDifficulty[i] > dp[i - 1] ? jobDifficulty[i] : dp[i - 1];\\n  }\\n\\n  for (let i = 1; i < d; ++i) {\\n    const stack = [];\\n    let old = dp[i - 1];\\n    for (let j = i; j < LEN; ++j) {\\n      let min = old;\\n      old = dp[j];\\n      while (stack.length && jobDifficulty[stack[stack.length - 1]] <= jobDifficulty[j]) {\\n        const top = stack.pop();\\n        min = Math.min(min, dp[top] - jobDifficulty[top]);\\n      }\\n      dp[j] = min + jobDifficulty[j];\\n      if (stack.length) {\\n        const top = dp[stack[stack.length - 1]];\\n        top < dp[j] && (dp[j] = top);\\n      }\\n      stack.push(j);\\n    }\\n  }\\n\\n  return dp[LEN - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Monotonic Stack"
                ],
                "code": "```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n  const cache = new Map();\\n  return helper(0, d);\\n\\n  function helper(idx, count) {\\n    const key = idx * 100 + count;\\n    if (!cache.has(key)) {\\n      if (count === 1) {\\n        let max = 0;\\n        for (let i = idx; i < LEN; ++i) {\\n          jobDifficulty[i] > max && (max = jobDifficulty[i]);\\n        }\\n        return max;\\n      }\\n      let min = 10000;\\n      let curMax = 0;\\n      for (let i = idx; i <= LEN - count; ++i) {\\n        if (jobDifficulty[i] > curMax) curMax = jobDifficulty[i];\\n        min = Math.min(min, curMax + helper(i + 1, count - 1));\\n      }\\n      cache.set(key, min);\\n    }\\n    return cache.get(key);\\n  }\\n};\\n```\n```js\\ndp[i][j] = Math.min(\\n  dp[i + 1][j - 1] + max(i, i),\\n  dp[i + 2][j - 1] + max(i, i + 1),\\n  ...\\n  dp[n - j + 1][j - 1] + max(i, n - j)\\n);\\n```\n```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n  const dp = Array.from({ length: LEN }, () => new Uint16Array(d + 1).fill(10000));\\n\\n  for (let i = LEN - 1, curMax = 0; i >= 0; --i) {\\n    jobDifficulty[i] > curMax && (curMax = jobDifficulty[i]);\\n    dp[i][1] = curMax;\\n  }\\n\\n  for (let i = 2; i <= d; ++i) {\\n    for (let j = 0; j <= LEN - i; ++j) {\\n      let max = 0;\\n      for (let k = j; k <= LEN - i; ++k) {\\n        jobDifficulty[k] > max && (max = jobDifficulty[k]);\\n        dp[j][i] = Math.min(dp[j][i], dp[k + 1][i - 1] + max);\\n      }\\n    }\\n  }\\n\\n  return dp[0][d];\\n};\\n```\n```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n  const dp = new Uint16Array(LEN + 1);\\n\\n  for (let i = LEN - 1; i >= 0; --i) {\\n    dp[i] = jobDifficulty[i] > dp[i + 1] ? jobDifficulty[i] : dp[i + 1];\\n  }\\n\\n  for (let i = 2; i <= d; ++i) {\\n    for (let j = 0; j <= LEN - i; ++j) {\\n      let max = 0;\\n      dp[j] = 10000;\\n      for (let k = j; k <= LEN - i; ++k) {\\n        jobDifficulty[k] > max && (max = jobDifficulty[k]);\\n        dp[j] > dp[k + 1] + max && (dp[j] = dp[k + 1] + max);\\n      }\\n    }\\n  }\\n\\n  return dp[0];\\n};\\n```\n```js\\nconst minDifficulty = (jobDifficulty, d) => {\\n  const LEN = jobDifficulty.length;\\n  if (LEN < d) return -1;\\n\\n  const dp = new Uint16Array(LEN);\\n  dp[0] = jobDifficulty[0];\\n  for (let i = 1; i < LEN; ++i) {\\n    dp[i] = jobDifficulty[i] > dp[i - 1] ? jobDifficulty[i] : dp[i - 1];\\n  }\\n\\n  for (let i = 1; i < d; ++i) {\\n    const stack = [];\\n    let old = dp[i - 1];\\n    for (let j = i; j < LEN; ++j) {\\n      let min = old;\\n      old = dp[j];\\n      while (stack.length && jobDifficulty[stack[stack.length - 1]] <= jobDifficulty[j]) {\\n        const top = stack.pop();\\n        min = Math.min(min, dp[top] - jobDifficulty[top]);\\n      }\\n      dp[j] = min + jobDifficulty[j];\\n      if (stack.length) {\\n        const top = dp[stack[stack.length - 1]];\\n        top < dp[j] && (dp[j] = top);\\n      }\\n      stack.push(j);\\n    }\\n  }\\n\\n  return dp[LEN - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710722,
                "title": "3d-dp-no-for-loop-c",
                "content": "# Approach\\nTry to make cut at every index and return minimum ans possible\\n\\n# Complexity\\n- Time complexity: O(N * K * maximum_element_in_array)\\n- Space complexity: O(N * K * maximum_element_in_array)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long dp[11][301][1002];\\n    long long solve(int i,int d,int mx,vector<int> &arr){\\n        if(i == arr.size()) return d == 0 ? mx : 1e9;\\n        if(dp[d][i][mx] != -1) return dp[d][i][mx];\\n\\n        long long op1 = 1e9, op2 = 1e9;\\n        \\n        if(d > 0) op1 = max(arr[i],mx) + solve(i+1,d-1,0,arr);\\n        op2 = solve(i+1,d,max(mx,arr[i]),arr);\\n        \\n\\n        return dp[d][i][mx] = min(op1,op2);\\n    }\\npublic:\\n    int minDifficulty(vector<int>& arr, int d) {\\n        if(d > arr.size()) return -1;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,d,0,arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long dp[11][301][1002];\\n    long long solve(int i,int d,int mx,vector<int> &arr){\\n        if(i == arr.size()) return d == 0 ? mx : 1e9;\\n        if(dp[d][i][mx] != -1) return dp[d][i][mx];\\n\\n        long long op1 = 1e9, op2 = 1e9;\\n        \\n        if(d > 0) op1 = max(arr[i],mx) + solve(i+1,d-1,0,arr);\\n        op2 = solve(i+1,d,max(mx,arr[i]),arr);\\n        \\n\\n        return dp[d][i][mx] = min(op1,op2);\\n    }\\npublic:\\n    int minDifficulty(vector<int>& arr, int d) {\\n        if(d > arr.size()) return -1;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,d,0,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710250,
                "title": "c-dp-brute-force-memoization-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple brute force approach suggests us to consider all possible distributions of jobs amongst given days, that is we must split the given jobs into \"d\" subsets, where no subset is empty. Difficulty of each day, is then given by the max difficulty of the job performed in each day.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe above idea can be represented in code, as follows. Before we go ahead and write the code, let\\'s handle the side case of \"number of jobs < number of days\" first. Clearly, in this case there will be a day with 0 jobs done. In this case, then we shall return -1. Here\\'s the brute force approach:\\n\\n```\\nclass Solution {\\n    int minDif(vector<int> jobDifficulty, int d, int idx){\\n        int n = jobDifficulty.size();\\n        if(d == 0) return (idx == n) ? 0 : INT_MAX; \\n        if(idx == n) return (d == 0) ? 0 : INT_MAX;\\n        int res = INT_MAX, mx = 0;\\n        for(int i = idx; i <= n-d; i++){\\n            mx = max(mx, jobDifficulty[i]);\\n            int temp = minDif(jobDifficulty, d-1, i+1);\\n            res = min(res, ((temp == INT_MAX) ? INT_MAX : temp + mx));\\n        }\\n        return res;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        return minDif(jobDifficulty, d, 0);\\n    }\\n};\\n```\\nGood, Now we are able to run 9 test cases before hitting TLE. Let\\'s remove the redundant work of recalculating for the same argument set over and over by applying memoization:\\n```\\nclass Solution {\\n    map<pair<int, int>, int> mp;\\n    int minDif(vector<int> jobDifficulty, int d, int idx){\\n        if(mp.find({d, idx}) != mp.end()) return mp[{d, idx}];\\n        int n = jobDifficulty.size();\\n        if(d == 0) return mp[{d, idx}] = (idx == n) ? 0 : INT_MAX; \\n        if(idx == n) return mp[{d, idx}] = (d == 0) ? 0 : INT_MAX;\\n        int res = INT_MAX, mx = 0;\\n        for(int i = idx; i <= n-d; i++){\\n            mx = max(mx, jobDifficulty[i]);\\n            int temp = minDif(jobDifficulty, d-1, i+1);\\n            res = min(res, ((temp == INT_MAX) ? INT_MAX : temp + mx));\\n        }\\n        return mp[{d, idx}] = res;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        return minDif(jobDifficulty, d, 0);\\n    }\\n};\\n```\\n33/34 test cases not bad! Final step: Here\\'s the tabulated version of the above code:\\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        \\n        vector<vector<int>> dp(d+1, vector<int>(n + 1, INT_MAX));\\n        dp[0][n] = 0;\\n\\n        for(int i = 1; i <= d; i++){\\n            for(int j = n-1; j >= 0; j--){\\n                int mx = 0;\\n                for(int k = j; k <= n-i; k++){\\n                    mx = max(mx, jobDifficulty[k]);\\n                    dp[i][j] = min(dp[i][j], ((dp[i-1][k+1] == INT_MAX) ? INT_MAX : mx + dp[i-1][k+1]));\\n                }\\n            }\\n        }\\n        return dp[d][0];\\n    }\\n};\\n```\\nAccepted! And we\\'re done! (For revised space complexity visit the last section of this article)\\n# Complexity\\n- Time complexity: $$O(n*n*d)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*d)$$ Revised - $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Final Code (AC)\\nHere\\'s the final code, with a little more on space optimization. Notice that we really don\\'t need a 2d vector but simply the previous and current row for calculations!\\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        \\n        vector<int> prev(n+1, INT_MAX), curr(n+1, INT_MAX);\\n        prev[n] = 0;\\n\\n        for(int i = 1; i <= d; i++){\\n            for(int j = n-1; j >= 0; j--){\\n                int mx = 0;\\n                for(int k = j; k <= n-i; k++){\\n                    mx = max(mx, jobDifficulty[k]);\\n                    curr[j] = min(curr[j], ((prev[k+1] == INT_MAX) ? INT_MAX : mx + prev[k+1]));\\n                }\\n            }\\n            prev = curr; curr = vector<int>(n+1, INT_MAX);\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int minDif(vector<int> jobDifficulty, int d, int idx){\\n        int n = jobDifficulty.size();\\n        if(d == 0) return (idx == n) ? 0 : INT_MAX; \\n        if(idx == n) return (d == 0) ? 0 : INT_MAX;\\n        int res = INT_MAX, mx = 0;\\n        for(int i = idx; i <= n-d; i++){\\n            mx = max(mx, jobDifficulty[i]);\\n            int temp = minDif(jobDifficulty, d-1, i+1);\\n            res = min(res, ((temp == INT_MAX) ? INT_MAX : temp + mx));\\n        }\\n        return res;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        return minDif(jobDifficulty, d, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    map<pair<int, int>, int> mp;\\n    int minDif(vector<int> jobDifficulty, int d, int idx){\\n        if(mp.find({d, idx}) != mp.end()) return mp[{d, idx}];\\n        int n = jobDifficulty.size();\\n        if(d == 0) return mp[{d, idx}] = (idx == n) ? 0 : INT_MAX; \\n        if(idx == n) return mp[{d, idx}] = (d == 0) ? 0 : INT_MAX;\\n        int res = INT_MAX, mx = 0;\\n        for(int i = idx; i <= n-d; i++){\\n            mx = max(mx, jobDifficulty[i]);\\n            int temp = minDif(jobDifficulty, d-1, i+1);\\n            res = min(res, ((temp == INT_MAX) ? INT_MAX : temp + mx));\\n        }\\n        return mp[{d, idx}] = res;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        return minDif(jobDifficulty, d, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        \\n        vector<vector<int>> dp(d+1, vector<int>(n + 1, INT_MAX));\\n        dp[0][n] = 0;\\n\\n        for(int i = 1; i <= d; i++){\\n            for(int j = n-1; j >= 0; j--){\\n                int mx = 0;\\n                for(int k = j; k <= n-i; k++){\\n                    mx = max(mx, jobDifficulty[k]);\\n                    dp[i][j] = min(dp[i][j], ((dp[i-1][k+1] == INT_MAX) ? INT_MAX : mx + dp[i-1][k+1]));\\n                }\\n            }\\n        }\\n        return dp[d][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n        \\n        vector<int> prev(n+1, INT_MAX), curr(n+1, INT_MAX);\\n        prev[n] = 0;\\n\\n        for(int i = 1; i <= d; i++){\\n            for(int j = n-1; j >= 0; j--){\\n                int mx = 0;\\n                for(int k = j; k <= n-i; k++){\\n                    mx = max(mx, jobDifficulty[k]);\\n                    curr[j] = min(curr[j], ((prev[k+1] == INT_MAX) ? INT_MAX : mx + prev[k+1]));\\n                }\\n            }\\n            prev = curr; curr = vector<int>(n+1, INT_MAX);\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709604,
                "title": "c-recursive-memoization-tabulation-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n\\n        if(d > n){\\n            return -1;\\n        }\\n\\n        // vector<vector<int>> dp(n + 1, vector<int> (d + 1, -1));\\n        return difficulty(jobDifficulty, n, d);\\n    }\\n\\nprivate:\\n    // TABULATION\\n    int difficulty(vector<int> &jobDifficulty, int n, int d){\\n        vector<vector<int>> dp(n + 1, vector<int> (d + 1, 1e9));\\n        dp[0][0] = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= d; j++){\\n                int maxi = INT_MIN;\\n                for(int k = i - 1; k >= j - 1; k--){\\n                    maxi = max(maxi, jobDifficulty[k]);\\n                    dp[i][j] = min(dp[i][j], maxi + dp[k][j - 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n][d];\\n    }\\n\\n\\n    // MEMOIZATION\\n    int difficulty(vector<int> &jobDifficulty, int start, int n, int d, vector<vector<int>> &dp){\\n        if(d == 1){\\n            int maxi = jobDifficulty[start];\\n            for(int i = start + 1; i < n; i++){\\n                maxi = max(maxi, jobDifficulty[i]);\\n            }\\n            return maxi;\\n        }\\n\\n        if(dp[start][d] != -1){\\n            return dp[start][d];\\n        }\\n\\n        int maxi = INT_MIN;\\n        int res = INT_MAX;\\n\\n        for(int i = start; i < n - d + 1; i++){\\n            maxi = max(maxi, jobDifficulty[i]);\\n            res = min(res, maxi + difficulty(jobDifficulty, i + 1, n, d - 1, dp));\\n        }\\n\\n        return dp[start][d] = res;\\n    }\\n\\n\\n    // RECURSIVE\\n    int difficulty(vector<int> &jobDifficulty, int start, int n, int d){\\n        if(d == 1){\\n            int maxi = jobDifficulty[start];\\n            for(int i = start + 1; i < n; i++){\\n                maxi = max(maxi, jobDifficulty[i]);\\n            }\\n            return maxi;\\n        }\\n\\n        int maxi = INT_MIN;\\n        int res = INT_MAX;\\n\\n        for(int i = start; i < n - d + 1; i++){\\n            maxi = max(maxi, jobDifficulty[i]);\\n            res = min(res, maxi + difficulty(jobDifficulty, i + 1, n, d - 1));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n\\n        if(d > n){\\n            return -1;\\n        }\\n\\n        // vector<vector<int>> dp(n + 1, vector<int> (d + 1, -1));\\n        return difficulty(jobDifficulty, n, d);\\n    }\\n\\nprivate:\\n    // TABULATION\\n    int difficulty(vector<int> &jobDifficulty, int n, int d){\\n        vector<vector<int>> dp(n + 1, vector<int> (d + 1, 1e9));\\n        dp[0][0] = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= d; j++){\\n                int maxi = INT_MIN;\\n                for(int k = i - 1; k >= j - 1; k--){\\n                    maxi = max(maxi, jobDifficulty[k]);\\n                    dp[i][j] = min(dp[i][j], maxi + dp[k][j - 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n][d];\\n    }\\n\\n\\n    // MEMOIZATION\\n    int difficulty(vector<int> &jobDifficulty, int start, int n, int d, vector<vector<int>> &dp){\\n        if(d == 1){\\n            int maxi = jobDifficulty[start];\\n            for(int i = start + 1; i < n; i++){\\n                maxi = max(maxi, jobDifficulty[i]);\\n            }\\n            return maxi;\\n        }\\n\\n        if(dp[start][d] != -1){\\n            return dp[start][d];\\n        }\\n\\n        int maxi = INT_MIN;\\n        int res = INT_MAX;\\n\\n        for(int i = start; i < n - d + 1; i++){\\n            maxi = max(maxi, jobDifficulty[i]);\\n            res = min(res, maxi + difficulty(jobDifficulty, i + 1, n, d - 1, dp));\\n        }\\n\\n        return dp[start][d] = res;\\n    }\\n\\n\\n    // RECURSIVE\\n    int difficulty(vector<int> &jobDifficulty, int start, int n, int d){\\n        if(d == 1){\\n            int maxi = jobDifficulty[start];\\n            for(int i = start + 1; i < n; i++){\\n                maxi = max(maxi, jobDifficulty[i]);\\n            }\\n            return maxi;\\n        }\\n\\n        int maxi = INT_MIN;\\n        int res = INT_MAX;\\n\\n        for(int i = start; i < n - d + 1; i++){\\n            maxi = max(maxi, jobDifficulty[i]);\\n            res = min(res, maxi + difficulty(jobDifficulty, i + 1, n, d - 1));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708772,
                "title": "java-memoization-tabulation-solution",
                "content": "**Intution**\\n\\n* We have to partition the jobs in given days.\\n* After partioning from a certain point means that we have done those jobs in that day. The max among them is the job difiiculty for that day.\\n* Now move further with days - 1 which are the remaing days.\\n* Once the jobDifficulty is exhausted and days is also 0 then it is valid answer and we can\\'t move further. Therefore return 0.\\n\\n**We don\\'t actually partition the array but instead move the index pointer by 1 in recursion call**\\n\\nexample : jobDifficulty = [6, 5, 4, 3, 7, 2, 1, 8], days = 3\\n\\n**One way of partitioning**\\n\\n1. Try partioning the difficulty array from `index 1` and `days - 1 = 2`. max for day 1 becomes 6 \\n2. From day 2  [6, `5, 4, 3, 7, 2, 1, 8] and days = 2` is remaining after the 1st partition.\\n3. Again Try partioning the difficulty array from `index 2` and `days - 1 = 1`. max for day 2 becomes 5\\n4. From day 3  [6, 5, `4, 3, 7, 2, 1, 8] and days = 1` is remaining after the 2nd partition.\\n5. Now as we have only 1 day remaining we have to complete all the jobs. Therefore max for day 3 becomes 8.\\n6. Answer from the above partitions become `6 + 5 + 8 = 19`.\\n\\n**Optimal way of partitioning**\\n1. Try partioning the difficulty array from `index 5` and `days - 1 = 2`. max for day 1 becomes 7 -> Jobs done `[6, 5, 4, 3, 7, 2]`\\n2. From day 2  [6, 5, 4, 3, 7, 2, `1, 8] and days = 2` is remaining after the 1st partition.\\n3. Again Try partioning the difficulty array from `index 6` and `days - 1 = 2`. max for day 2 becomes 1\\n4. From day 3   [6, 5, 4, 3, 7, 2, 1, `8] and days = 1` is remaining after the 2nd partition.\\n5. Now as we have only 1 day remaining we have to complete all the jobs. Therefore max for day 3 becomes 8.\\n6. Answer from the above partitions become `7 + 1 + 8 = 16`. which is minimum.\\n\\nN = jobDifficulty array length;\\nD = days;\\n\\n**Recursion TC -> O(NND) and SC -> O(ND) + recursion stack space**\\n\\n```\\npublic int minDifficulty(int[] jobDifficulty, int days) {\\n        \\n        if(days > jobDifficulty.length){\\n            return -1;\\n        }\\n        \\n        int dp[][] = new int[jobDifficulty.length + 1][days + 1];\\n        for(int row[] : dp){\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        \\n        return solve(0, jobDifficulty, days, dp);\\n    }\\n    \\n    public int solve(int idx, int[] jd, int days, int dp[][]){\\n        \\n        if(idx >= jd.length){\\n            if(days == 0){\\n                return 0;\\n            } else {\\n                return (int)1e8;\\n            }\\n        } else if(days == 0){\\n            return (int)1e8;\\n        }\\n        \\n        if(dp[idx][days] != -1){\\n            return dp[idx][days];\\n        }\\n        \\n        int ans = (int)1e8;\\n        int max = -1;\\n        \\n        for(int i = idx; i <= jd.length - days; i++){\\n            max = Math.max(max, jd[i]);\\n                        \\n            int temp = max + solve(i + 1, jd, days - 1, dp);\\n            \\n            ans = Math.min(temp, ans);\\n        }\\n        \\n        return dp[idx][days] = ans;\\n    }\\n```\\n\\t\\n\\n**Tabulation  TC -> O(NND) and SC -> O(ND)**\\n\\n\\n```\\npublic int minDifficulty(int[] jobDifficulty, int days) {\\n        \\n        if(days > jobDifficulty.length){\\n            return -1;\\n        }\\n        \\n        int dp[][] = new int[jobDifficulty.length + 1][days + 1];\\n        \\n        for(int idx = jobDifficulty.length - 1; idx >= 0; idx--){\\n            for(int d = days; d >= 0; d--){\\n                if(idx >= jobDifficulty.length){\\n                    if(d == 0){\\n                        dp[idx][d] = 0;\\n                        continue;\\n                    } else {\\n                        dp[idx][d] =  (int)1e8;\\n                        continue;\\n                    }\\n                } else if(d == 0){\\n                    dp[idx][d] =  (int)1e8;\\n                    continue;\\n                }\\n\\n                int ans = (int)1e8;\\n                int max = -1;\\n\\n                for(int i = idx; i <= jobDifficulty.length - d; i++){\\n                    max = Math.max(max, jobDifficulty[i]);\\n\\n                    int temp = max + dp[i + 1][d - 1];\\n\\n                    ans = Math.min(temp, ans);\\n                }\\n\\n                dp[idx][d] = ans;\\n            }\\n        }\\n        \\n        \\n        return dp[0][days];\\n    }\\n```\\n\\nPlease UpVote !!!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic int minDifficulty(int[] jobDifficulty, int days) {\\n        \\n        if(days > jobDifficulty.length){\\n            return -1;\\n        }\\n        \\n        int dp[][] = new int[jobDifficulty.length + 1][days + 1];\\n        for(int row[] : dp){\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        \\n        return solve(0, jobDifficulty, days, dp);\\n    }\\n    \\n    public int solve(int idx, int[] jd, int days, int dp[][]){\\n        \\n        if(idx >= jd.length){\\n            if(days == 0){\\n                return 0;\\n            } else {\\n                return (int)1e8;\\n            }\\n        } else if(days == 0){\\n            return (int)1e8;\\n        }\\n        \\n        if(dp[idx][days] != -1){\\n            return dp[idx][days];\\n        }\\n        \\n        int ans = (int)1e8;\\n        int max = -1;\\n        \\n        for(int i = idx; i <= jd.length - days; i++){\\n            max = Math.max(max, jd[i]);\\n                        \\n            int temp = max + solve(i + 1, jd, days - 1, dp);\\n            \\n            ans = Math.min(temp, ans);\\n        }\\n        \\n        return dp[idx][days] = ans;\\n    }\\n```\n```\\npublic int minDifficulty(int[] jobDifficulty, int days) {\\n        \\n        if(days > jobDifficulty.length){\\n            return -1;\\n        }\\n        \\n        int dp[][] = new int[jobDifficulty.length + 1][days + 1];\\n        \\n        for(int idx = jobDifficulty.length - 1; idx >= 0; idx--){\\n            for(int d = days; d >= 0; d--){\\n                if(idx >= jobDifficulty.length){\\n                    if(d == 0){\\n                        dp[idx][d] = 0;\\n                        continue;\\n                    } else {\\n                        dp[idx][d] =  (int)1e8;\\n                        continue;\\n                    }\\n                } else if(d == 0){\\n                    dp[idx][d] =  (int)1e8;\\n                    continue;\\n                }\\n\\n                int ans = (int)1e8;\\n                int max = -1;\\n\\n                for(int i = idx; i <= jobDifficulty.length - d; i++){\\n                    max = Math.max(max, jobDifficulty[i]);\\n\\n                    int temp = max + dp[i + 1][d - 1];\\n\\n                    ans = Math.min(temp, ans);\\n                }\\n\\n                dp[idx][d] = ans;\\n            }\\n        }\\n        \\n        \\n        return dp[0][days];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708410,
                "title": "c-100-faster-than-all-easy-3ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int minDifficulty(vector<int>& jobs, int days) {\\n        const int n = (int)jobs.size();\\n        if (n < days) return -1;\\n        vector<int> dp(n), old(n);\\n        dp[0] = jobs[0];\\n        for (int i = 1; i < n; i++)\\n            dp[i] = max(dp[i-1], jobs[i]);\\n\\n        for (int d = 1; d < days; d++) {\\n            swap(dp, old);\\n            vector<array<int,3>> stk = {{1<<30,1<<30,1<<30}};\\n            for (int i = d; i < n; i++) {\\n                int oldBest = old[i-1];\\n                while (stk.back()[1] <= jobs[i]) {\\n                    oldBest = min(oldBest, stk.back()[0]);\\n                    stk.pop_back();\\n                }\\n                stk.push_back({oldBest, jobs[i], min(oldBest + jobs[i], stk.back()[2])});\\n                dp[i] = stk.back()[2];\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minDifficulty(vector<int>& jobs, int days) {\\n        const int n = (int)jobs.size();\\n        if (n < days) return -1;\\n        vector<int> dp(n), old(n);\\n        dp[0] = jobs[0];\\n        for (int i = 1; i < n; i++)\\n            dp[i] = max(dp[i-1], jobs[i]);\\n\\n        for (int d = 1; d < days; d++) {\\n            swap(dp, old);\\n            vector<array<int,3>> stk = {{1<<30,1<<30,1<<30}};\\n            for (int i = d; i < n; i++) {\\n                int oldBest = old[i-1];\\n                while (stk.back()[1] <= jobs[i]) {\\n                    oldBest = min(oldBest, stk.back()[0]);\\n                    stk.pop_back();\\n                }\\n                stk.push_back({oldBest, jobs[i], min(oldBest + jobs[i], stk.back()[2])});\\n                dp[i] = stk.back()[2];\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721372,
                "title": "python-dp-top-down",
                "content": "\\n\\n\\n\\n\\nclass Solution:    \\n\\t\\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        if d > len(jobDifficulty):\\n            return -1\\n        \\n        @cache\\n        def dp(l, d):\\n            if d == 1:\\n                return max(jobDifficulty[l:])            \\n            \\n            m = jobDifficulty[l]\\n            ans = float(\"inf\")\\n            for j in range(l, len(jobDifficulty)-(d-1)):\\n                m = max(m, jobDifficulty[j])\\n                ans = min(ans, m+dp(j+1, d-1))\\n                \\n            return ans\\n        \\n        return dp(0, d)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n\\n\\n\\nclass Solution:    \\n\\t\\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        if d > len(jobDifficulty):\\n            return -1\\n        \\n        @cache\\n        def dp(l, d):\\n            if d == 1:\\n                return max(jobDifficulty[l:])            \\n            \\n            m = jobDifficulty[l]\\n            ans = float(\"inf\")\\n            for j in range(l, len(jobDifficulty)-(d-1)):\\n                m = max(m, jobDifficulty[j])\\n                ans = min(ans, m+dp(j+1, d-1))\\n                \\n            return ans\\n        \\n        return dp(0, d)",
                "codeTag": "Java"
            },
            {
                "id": 1207034,
                "title": "java-clean-o-nd-time-stack-and-dp-solution",
                "content": "This Dynammic Programming Solution itself is not easy at all. The DP-Solution put this problem on par with these problems (marked as Hard): \\n* [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/1133417/Java-Clean-Binary-Search-and-Dynamic-Programming-Solution-oror-with-comments)\\n\\nHowever, the logic is rather straightforward: \\n```\\n // dp[i][d] is the result of splitting jobs[0:i] into d parts\\n  dp[i][d] := res(jobs[0: i]  ==> d parts)\\n            = res(jobs[0: k]  ==> d-1 parst)  +  res(jobs[k+1 : i]  ==>  1 part)   for some k in [0: i-1]\\n            =             dp[k][d-1]          +     max(jobs[k+1 : i])             for some k in [0: i-1]\\n// Thus we have:        \\n  dp[i][d] = min( dp[k][d-1] + max(jobs[k+1 : i]) )                                for some k in [0: i-1]\\n```\\n\\nThen we may have this naive DP-Solution. To calculate maximum in a range fast, we may either calculate max(dp[i : j]) for all range before calculating DP-entries. Or we may traverse from the tail for each row as follow: \\n\\n```\\n// Time: O(D * N^2)    Space: O(N^2)\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        int n = jobDifficulty.length;\\n        if (n < D) return -1;\\n        \\n        int[][] dp = new int[n][D+1];\\n        for (int[] r : dp) Arrays.fill(r, Integer.MAX_VALUE);\\n        \\n        // d == 1 (split into 1 part):\\n        dp[0][1] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = Math.max(dp[i-1][1], jobDifficulty[i]);\\n        }\\n        \\n        for (int d = 2; d <= D; d++) {\\n            for (int i = n-1; i >= 0; i--) {\\n                int currMax = jobDifficulty[i];    // max(jobs[k : n-1])\\n                for (int k = i-1; k >= 0; k--) {\\n                    if (dp[k][d-1] == Integer.MAX_VALUE) continue;\\n                    dp[i][d] = Math.min(dp[i][d], dp[k][d-1] + currMax);\\n                    currMax = Math.max(currMax, jobDifficulty[k]);\\n                }\\n            }\\n        }\\n        return dp[n-1][D];\\n    }\\n}\\n```\\n\\nA quick notice is that for calculating each column we only information from the previous column. Thus we may easily reduce the space complexity into O(N): \\n\\n```\\n// Time: O(D * N^2)  Space: O(N)\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        int n = jobDifficulty.length;\\n        if (n < D) return -1;\\n        \\n\\t\\t// d == 1 (first col, split into 1 part):\\n        int[] dp = new int[n];\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i-1], jobDifficulty[i]);\\n        }\\n    \\n        for (int d = 2; d <= D; d++) {\\n            int[] next = new int[n];\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            \\n            for (int i = n-1; i >= 0; i--) {\\n                int currMax = jobDifficulty[i]; \\n                for (int k = i-1; k >= 0; k--) {\\n                    if (dp[k] == Integer.MAX_VALUE) continue;\\n                    next[i] = Math.min(next[i], dp[k] + currMax);\\n                    currMax = Math.max(currMax, jobDifficulty[k]);\\n                }\\n            }\\n            \\n            dp = next;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n\\nHowever, we may still feel the redundency when traversing all possible k for all index i. This leads to the final O(D * N) Solution: \\n\\n```\\n// Time: O(D * N)  Space: O(N)\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        int n = jobDifficulty.length;\\n        if (n < D) return -1;\\n        \\n        // d == 1 (first col, split into 1 part):\\n        int[] dp = new int[n];\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i-1], jobDifficulty[i]);\\n        }\\n        \\n        for (int d = 2; d <= D; d++) {\\n            Deque<Integer> stack = new LinkedList<>();\\n            int[] next = new int[n];\\n            \\n            for (int i = d-1; i < n; i++) {\\n                next[i] = (i == 0) ? jobDifficulty[i] : dp[i-1] + jobDifficulty[i];\\n                \\n                while (!stack.isEmpty() && jobDifficulty[stack.peekLast()] < jobDifficulty[i]) {\\n                    int idx = stack.pollLast();\\n                    next[i] = Math.min(next[i], next[idx] - jobDifficulty[idx] + jobDifficulty[i]);\\n                }\\n                \\n                if (!stack.isEmpty()) {\\n                    next[i] = Math.min(next[i], next[stack.peekLast()]);\\n                }\\n                stack.offerLast(i);\\n            }\\n            \\n            dp = next;\\n        }\\n        \\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n // dp[i][d] is the result of splitting jobs[0:i] into d parts\\n  dp[i][d] := res(jobs[0: i]  ==> d parts)\\n            = res(jobs[0: k]  ==> d-1 parst)  +  res(jobs[k+1 : i]  ==>  1 part)   for some k in [0: i-1]\\n            =             dp[k][d-1]          +     max(jobs[k+1 : i])             for some k in [0: i-1]\\n// Thus we have:        \\n  dp[i][d] = min( dp[k][d-1] + max(jobs[k+1 : i]) )                                for some k in [0: i-1]\\n```\n```\\n// Time: O(D * N^2)    Space: O(N^2)\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        int n = jobDifficulty.length;\\n        if (n < D) return -1;\\n        \\n        int[][] dp = new int[n][D+1];\\n        for (int[] r : dp) Arrays.fill(r, Integer.MAX_VALUE);\\n        \\n        // d == 1 (split into 1 part):\\n        dp[0][1] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = Math.max(dp[i-1][1], jobDifficulty[i]);\\n        }\\n        \\n        for (int d = 2; d <= D; d++) {\\n            for (int i = n-1; i >= 0; i--) {\\n                int currMax = jobDifficulty[i];    // max(jobs[k : n-1])\\n                for (int k = i-1; k >= 0; k--) {\\n                    if (dp[k][d-1] == Integer.MAX_VALUE) continue;\\n                    dp[i][d] = Math.min(dp[i][d], dp[k][d-1] + currMax);\\n                    currMax = Math.max(currMax, jobDifficulty[k]);\\n                }\\n            }\\n        }\\n        return dp[n-1][D];\\n    }\\n}\\n```\n```\\n// Time: O(D * N^2)  Space: O(N)\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        int n = jobDifficulty.length;\\n        if (n < D) return -1;\\n        \\n\\t\\t// d == 1 (first col, split into 1 part):\\n        int[] dp = new int[n];\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i-1], jobDifficulty[i]);\\n        }\\n    \\n        for (int d = 2; d <= D; d++) {\\n            int[] next = new int[n];\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            \\n            for (int i = n-1; i >= 0; i--) {\\n                int currMax = jobDifficulty[i]; \\n                for (int k = i-1; k >= 0; k--) {\\n                    if (dp[k] == Integer.MAX_VALUE) continue;\\n                    next[i] = Math.min(next[i], dp[k] + currMax);\\n                    currMax = Math.max(currMax, jobDifficulty[k]);\\n                }\\n            }\\n            \\n            dp = next;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\n// Time: O(D * N)  Space: O(N)\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int D) {\\n        int n = jobDifficulty.length;\\n        if (n < D) return -1;\\n        \\n        // d == 1 (first col, split into 1 part):\\n        int[] dp = new int[n];\\n        dp[0] = jobDifficulty[0];\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i-1], jobDifficulty[i]);\\n        }\\n        \\n        for (int d = 2; d <= D; d++) {\\n            Deque<Integer> stack = new LinkedList<>();\\n            int[] next = new int[n];\\n            \\n            for (int i = d-1; i < n; i++) {\\n                next[i] = (i == 0) ? jobDifficulty[i] : dp[i-1] + jobDifficulty[i];\\n                \\n                while (!stack.isEmpty() && jobDifficulty[stack.peekLast()] < jobDifficulty[i]) {\\n                    int idx = stack.pollLast();\\n                    next[i] = Math.min(next[i], next[idx] - jobDifficulty[idx] + jobDifficulty[i]);\\n                }\\n                \\n                if (!stack.isEmpty()) {\\n                    next[i] = Math.min(next[i], next[stack.peekLast()]);\\n                }\\n                stack.offerLast(i);\\n            }\\n            \\n            dp = next;\\n        }\\n        \\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155322,
                "title": "python-dynamic-programming",
                "content": "```\\nclass Solution:       \\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if d>n: return -1\\n        dp = [[float(\\'inf\\') for j in range(n)] for i in range(d)]\\n        for i in range(d):\\n            for j in range(i,n):\\n                if i == 0: \\n                    dp[0][j] = max(jobDifficulty[:j+1])\\n                else:\\n                    for k in range(i-1, j):\\n                        dp[i][j] = min(dp[i][j],max(jobDifficulty[k+1:j+1])+dp[i-1][k]) \\n        return dp[-1][-1]",
                "solutionTags": [],
                "code": "```\\nclass Solution:       \\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if d>n: return -1\\n        dp = [[float(\\'inf\\') for j in range(n)] for i in range(d)]\\n        for i in range(d):\\n            for j in range(i,n):\\n                if i == 0: \\n                    dp[0][j] = max(jobDifficulty[:j+1])\\n                else:\\n                    for k in range(i-1, j):\\n                        dp[i][j] = min(dp[i][j],max(jobDifficulty[k+1:j+1])+dp[i-1][k]) \\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 1149366,
                "title": "java-dp-simple-solution",
                "content": "1. We use a 2D array to calculate the result from bottom up\\n2. dp[i][k] represents the result when we have i jobs and k days (both start from 1).\\n3. dp[n][d] is the final result since it represents we have n jobs and d days.\\n4. Explanation for dp[i][k] =  Math.min(dp[i][k],dp[j-1][k-1] + max).\\n*   j starts from k to i since we need to leave at least k-1 jobs for k-1 days.\\n* \\tFor k-1 days, we have j-1 jobs, so it\\'s dp[j-1][k-1].\\n\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n\\t\\tint n = jobDifficulty.length; \\n        if(n < d) return -1;\\n        //XXXX(k-1) jXXXi\\n        //dp[i][k] = min(dp[i][k], dp[j-1][k-1] + max(j:i))\\n        int[][] dp = new int[n+1][d+1]; \\n        for(int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE/2);\\n        }\\n        \\n        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            for(int k = 1; k <= d; k++){\\n                int max = 0;\\n                for(int j = i; j >= k; j--){\\n                    max = Math.max(max,jobDifficulty[j-1]);\\n                    dp[i][k] =  Math.min(dp[i][k],dp[j-1][k-1] + max);\\n                }\\n            }\\n        }\\n        return dp[n][d];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n\\t\\tint n = jobDifficulty.length; \\n        if(n < d) return -1;\\n        //XXXX(k-1) jXXXi\\n        //dp[i][k] = min(dp[i][k], dp[j-1][k-1] + max(j:i))\\n        int[][] dp = new int[n+1][d+1]; \\n        for(int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE/2);\\n        }\\n        \\n        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            for(int k = 1; k <= d; k++){\\n                int max = 0;\\n                for(int j = i; j >= k; j--){\\n                    max = Math.max(max,jobDifficulty[j-1]);\\n                    dp[i][k] =  Math.min(dp[i][k],dp[j-1][k-1] + max);\\n                }\\n            }\\n        }\\n        return dp[n][d];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128868,
                "title": "top-down-dp-in-java-with-comments",
                "content": "I found this a standard DP problem. From interview perspective, I prefer top-down since you can draw a recursion tree, and it is easier to arrive at recurrance relation.\\n\\nSpace complexity is easier to determine: d*n (memoization array)\\nTime complexity should be d*n^2 at worst case because of the inner loop, but I think the ammortized value will be much less than that because of memoization.\\nComments welcome!\\n\\n```\\nclass Solution {\\n    int[][] map; // For memoization\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int LEN = jobDifficulty.length;\\n        if (d > jobDifficulty.length) {\\n            return -1; // This cannot be fulfilled\\n        }\\n        map = new int[LEN][d]; \\n        int minDiff = helper(jobDifficulty, 0, d);\\n        if (minDiff == Integer.MAX_VALUE) \\n            return -1;\\n        return minDiff;\\n    }\\n    \\n    // Top-down DP: we solve for first finding maximum job difficulty for all legal \\n    // combinations in any given day, and then return the minimum of that value\\n    // For memoization, we save the value for any given job index and remaining days\\n    private int helper(int[] jd, int index, int remDays) {\\n        if (remDays == 0 || index >= jd.length) {\\n            return 0; //Base case\\n        }\\n        \\n        if (map[index][remDays - 1] != 0) {\\n            return map[index][remDays - 1];\\n        }\\n        \\n        int minDiff = Integer.MAX_VALUE;\\n\\n        if (remDays == 1) {\\n            // This is the last day, no other combination possible, since all jobs need to be done\\n            int currDiff = 0;\\n            for (int i = index; i < jd.length; i++) {\\n                currDiff = Math.max(currDiff, jd[i]);\\n            }\\n            map[index][remDays - 1] = currDiff;\\n            return currDiff;\\n        }\\n        \\n        // We consider doing jobs from index to jId on the current day, and let\\n        // recursion figure out what is the min value of jobs for remaining \\n        // days in this top-down approach\\n        for (int jId = index; jId <= jd.length - remDays; jId++) {\\n            int currDiff = 0; // Difficulty of present day\\n            for (int inner = index; inner <= jId; inner++) {\\n                currDiff = Math.max(currDiff, jd[inner]);\\n            }\\n            int remDiff = helper(jd, jId + 1, remDays - 1);\\n            if (remDiff != Integer.MAX_VALUE)\\n                minDiff = Math.min(minDiff, currDiff + remDiff);\\n        }\\n        \\n        map[index][remDays - 1] = minDiff;\\n        return minDiff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[][] map; // For memoization\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int LEN = jobDifficulty.length;\\n        if (d > jobDifficulty.length) {\\n            return -1; // This cannot be fulfilled\\n        }\\n        map = new int[LEN][d]; \\n        int minDiff = helper(jobDifficulty, 0, d);\\n        if (minDiff == Integer.MAX_VALUE) \\n            return -1;\\n        return minDiff;\\n    }\\n    \\n    // Top-down DP: we solve for first finding maximum job difficulty for all legal \\n    // combinations in any given day, and then return the minimum of that value\\n    // For memoization, we save the value for any given job index and remaining days\\n    private int helper(int[] jd, int index, int remDays) {\\n        if (remDays == 0 || index >= jd.length) {\\n            return 0; //Base case\\n        }\\n        \\n        if (map[index][remDays - 1] != 0) {\\n            return map[index][remDays - 1];\\n        }\\n        \\n        int minDiff = Integer.MAX_VALUE;\\n\\n        if (remDays == 1) {\\n            // This is the last day, no other combination possible, since all jobs need to be done\\n            int currDiff = 0;\\n            for (int i = index; i < jd.length; i++) {\\n                currDiff = Math.max(currDiff, jd[i]);\\n            }\\n            map[index][remDays - 1] = currDiff;\\n            return currDiff;\\n        }\\n        \\n        // We consider doing jobs from index to jId on the current day, and let\\n        // recursion figure out what is the min value of jobs for remaining \\n        // days in this top-down approach\\n        for (int jId = index; jId <= jd.length - remDays; jId++) {\\n            int currDiff = 0; // Difficulty of present day\\n            for (int inner = index; inner <= jId; inner++) {\\n                currDiff = Math.max(currDiff, jd[inner]);\\n            }\\n            int remDiff = helper(jd, jId + 1, remDays - 1);\\n            if (remDiff != Integer.MAX_VALUE)\\n                minDiff = Math.min(minDiff, currDiff + remDiff);\\n        }\\n        \\n        map[index][remDays - 1] = minDiff;\\n        return minDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085239,
                "title": "java-recursion-memoization-dp",
                "content": "**Bruce Force Recursion**\\nrecursion definition `int recursion(int idx_day, int idx_job, int[] jobDiff, int d)`\\nit returns the maxprofile when we schedule [idx_jobs...last jobs] during [idx_day..last days]\\n\\ntime complexity: o(d ^ jobDifficulty.len)\\nspace:  o(d)\\nTLE at one huge test case\\n\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (d > jobDifficulty.length)\\n            return -1;\\n        \\n        return recursion(0, 0, jobDifficulty, d);\\n    }\\n    \\n    private int recursion(int idx_day, int idx_job, int[] jobDiff, int d) {\\n        // at idx_day, [idx_job ... lastjob] remain unscheduled\\n        int minDiff = Integer.MAX_VALUE;\\n        int maxDiffDay = 0;\\n        if (idx_day == d - 1) {\\n            //schedule all left jobs in last day\\n            for (int i = idx_job; i < jobDiff.length; i++) {\\n                maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            }\\n            \\n            return maxDiffDay;\\n        }\\n        \\n        for (int i = idx_job; i < jobDiff.length - (d - idx_day) + 1; i++) {\\n            maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            int future =  recursion(idx_day + 1, i + 1, jobDiff, d);\\n            if (future == -1)\\n                continue;\\n            minDiff = Math.min(minDiff, maxDiffDay + future);\\n        }\\n        \\n        if (minDiff == Integer.MAX_VALUE)\\n            return -1;\\n        return minDiff;\\n    }\\n}\\n```\\n**Memoization**\\nmemo[i][j]: the maxprofit when we schedule [idx_jobs...last jobs] during [idx_day..last days]\\nwhy this? that is exactly my definition of recursion.\\n\\nTime Complexity: o(jobDifficulty.len * d * jobDifficulty.len)\\nSpace Complexity: o(jobDifficulty.len * d)\\nRuntime: 8 ms, faster than 65.52% of Java online submissions for Minimum Difficulty of a Job Schedule.\\nMemory Usage: 36.5 MB, less than 89.99% of Java online submissions for Minimum Difficulty of a Job Schedule.\\n\\nProof of Time Complexity:\\n(Below are inspired from Introduction to Algorithm page 388,389, you can read it first)\\nwe can recognize calls of recursion function as below two types\\n1st type: memo[i][j] == 0,  it would go to for loop, \\n2nd type: memo[i][j] != 0, it returns immediately\\n\\n1.Take len as jobDifficulty.len, there are o(len * d) of first type, since one for each table entry.\\n2.All second types are executed as recursive calls by first type. Whenever a first type makes recursive calls, it makes o(len) of them, because for loop\\n  so there are total O(len*d*len) of second type.\\n3.Time cost of each first type would be o(len) of recursive calls plus time for each recursive calls.\\ntotal time would be o(len * d * len)\\n\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (d > jobDifficulty.length)\\n            return -1;\\n        int[][] memo = new int[d][jobDifficulty.length];\\n        recursion(0, 0, jobDifficulty, d, memo);\\n        \\n        return memo[0][0];\\n    }\\n    \\n    private int recursion(int idx_day, int idx_job, int[] jobDiff, int d, int[][] memo) {\\n        // at idx_day, [idx_job ... lastjob] remain unscheduled\\n        int minDiff = Integer.MAX_VALUE;\\n        int maxDiffDay = 0;\\n        \\n        if (memo[idx_day][idx_job] != 0)\\n            return memo[idx_day][idx_job];\\n        if (idx_day == d - 1) {\\n            //schedule all left jobs in last day\\n            for (int i = idx_job; i < jobDiff.length; i++) {\\n                maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            }\\n            \\n            memo[idx_day][idx_job] = maxDiffDay;\\n            return maxDiffDay;\\n        }\\n        \\n        for (int i = idx_job; i < jobDiff.length - (d - idx_day) + 1; i++) {\\n            maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            int future =  recursion(idx_day + 1, i + 1, jobDiff, d, memo);\\n            if (future == -1)\\n                continue;\\n            minDiff = Math.min(minDiff, maxDiffDay + future);\\n        }\\n        \\n        if (minDiff == Integer.MAX_VALUE)\\n            memo[idx_day][idx_job] = -1;\\n        memo[idx_day][idx_job] = minDiff;\\n        \\n        return memo[idx_day][idx_job];\\n    }\\n}\\n```\\n\\n**DP**\\nHow to convert memoization to DP\\nhere dp table entry definition is complementary with recursion definition\\ndp[i][j] represents the maxProfig to get when schedule [0...j] jobs during [0..i] days. all 0-based\\ntransition: dp[i][j] = min (dp[i-1][k]+ max Difficulty of jobs from j to k + 1)\\nexample would be\\ndp[2][4] has below three options\\ndp[1][3] + job[4], \\ndp[1][2]  + max(job[4], job[3])\\ndp[1][1] + max(job[4], job[3], job[2])\\n\\nplz take a given exmaple and fill out a dp table entry one by one, then it would be much clear to undetstand.\\nOnly after you fill out a dp table by yourself on the paper, we can say we understand that. Just looking at code helps little, at least for me\\n\\n```\\npublic int minDifficulty(int[] jobDifficulty, int d) {\\n\\tif (d > jobDifficulty.length)\\n\\t\\treturn -1;\\n\\tint[][] dp = new int[d][jobDifficulty.length];\\n\\tint max = 0, len = jobDifficulty.length;\\n\\tfor (int i = 0; i <= len - 1 - (d - 1 - 0); i++) {\\n\\t\\tmax = Math.max(jobDifficulty[i], max);\\n\\t\\tdp[0][i] = max;\\n\\t\\tSystem.out.println(i +  \" \" + dp[0][i] + \" \");\\n\\t}\\n\\tif (d == 1)\\n\\t\\treturn dp[d-1][jobDifficulty.length - 1];\\n\\tfor (int row = 1; row < d; row++) {\\n\\t\\tfor (int col = (len - 1 - (d-1-row)); col >= row; col--) {\\n\\t\\t\\tdp[row][col] = Integer.MAX_VALUE;\\n\\t\\t\\tint maxDay = 0;\\n\\t\\t\\tfor (int i = col - 1; i >= row - 1; i--) {\\n\\t\\t\\t\\tmaxDay = Math.max(maxDay, jobDifficulty[i+1]);\\n\\t\\t\\t\\tdp[row][col] = Math.min(dp[row][col], dp[row - 1][i] + maxDay);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (row == d - 1 && col == jobDifficulty.length - 1)\\n\\t\\t\\t\\treturn dp[row][col];\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (d > jobDifficulty.length)\\n            return -1;\\n        \\n        return recursion(0, 0, jobDifficulty, d);\\n    }\\n    \\n    private int recursion(int idx_day, int idx_job, int[] jobDiff, int d) {\\n        // at idx_day, [idx_job ... lastjob] remain unscheduled\\n        int minDiff = Integer.MAX_VALUE;\\n        int maxDiffDay = 0;\\n        if (idx_day == d - 1) {\\n            //schedule all left jobs in last day\\n            for (int i = idx_job; i < jobDiff.length; i++) {\\n                maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            }\\n            \\n            return maxDiffDay;\\n        }\\n        \\n        for (int i = idx_job; i < jobDiff.length - (d - idx_day) + 1; i++) {\\n            maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            int future =  recursion(idx_day + 1, i + 1, jobDiff, d);\\n            if (future == -1)\\n                continue;\\n            minDiff = Math.min(minDiff, maxDiffDay + future);\\n        }\\n        \\n        if (minDiff == Integer.MAX_VALUE)\\n            return -1;\\n        return minDiff;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if (d > jobDifficulty.length)\\n            return -1;\\n        int[][] memo = new int[d][jobDifficulty.length];\\n        recursion(0, 0, jobDifficulty, d, memo);\\n        \\n        return memo[0][0];\\n    }\\n    \\n    private int recursion(int idx_day, int idx_job, int[] jobDiff, int d, int[][] memo) {\\n        // at idx_day, [idx_job ... lastjob] remain unscheduled\\n        int minDiff = Integer.MAX_VALUE;\\n        int maxDiffDay = 0;\\n        \\n        if (memo[idx_day][idx_job] != 0)\\n            return memo[idx_day][idx_job];\\n        if (idx_day == d - 1) {\\n            //schedule all left jobs in last day\\n            for (int i = idx_job; i < jobDiff.length; i++) {\\n                maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            }\\n            \\n            memo[idx_day][idx_job] = maxDiffDay;\\n            return maxDiffDay;\\n        }\\n        \\n        for (int i = idx_job; i < jobDiff.length - (d - idx_day) + 1; i++) {\\n            maxDiffDay = Math.max(maxDiffDay, jobDiff[i]);\\n            int future =  recursion(idx_day + 1, i + 1, jobDiff, d, memo);\\n            if (future == -1)\\n                continue;\\n            minDiff = Math.min(minDiff, maxDiffDay + future);\\n        }\\n        \\n        if (minDiff == Integer.MAX_VALUE)\\n            memo[idx_day][idx_job] = -1;\\n        memo[idx_day][idx_job] = minDiff;\\n        \\n        return memo[idx_day][idx_job];\\n    }\\n}\\n```\n```\\npublic int minDifficulty(int[] jobDifficulty, int d) {\\n\\tif (d > jobDifficulty.length)\\n\\t\\treturn -1;\\n\\tint[][] dp = new int[d][jobDifficulty.length];\\n\\tint max = 0, len = jobDifficulty.length;\\n\\tfor (int i = 0; i <= len - 1 - (d - 1 - 0); i++) {\\n\\t\\tmax = Math.max(jobDifficulty[i], max);\\n\\t\\tdp[0][i] = max;\\n\\t\\tSystem.out.println(i +  \" \" + dp[0][i] + \" \");\\n\\t}\\n\\tif (d == 1)\\n\\t\\treturn dp[d-1][jobDifficulty.length - 1];\\n\\tfor (int row = 1; row < d; row++) {\\n\\t\\tfor (int col = (len - 1 - (d-1-row)); col >= row; col--) {\\n\\t\\t\\tdp[row][col] = Integer.MAX_VALUE;\\n\\t\\t\\tint maxDay = 0;\\n\\t\\t\\tfor (int i = col - 1; i >= row - 1; i--) {\\n\\t\\t\\t\\tmaxDay = Math.max(maxDay, jobDifficulty[i+1]);\\n\\t\\t\\t\\tdp[row][col] = Math.min(dp[row][col], dp[row - 1][i] + maxDay);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (row == d - 1 && col == jobDifficulty.length - 1)\\n\\t\\t\\t\\treturn dp[row][col];\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979663,
                "title": "javascript-dp",
                "content": "```\\n// Time: O(LLd), space: O(Ld)\\nvar minDifficulty = function (A, d) {\\n  const L = A.length;\\n  const dp = Array.from(Array(d), () => Array(L));\\n\\n  for (let i = 0; i < d; i++) {\\n    for (let j = 0; j < L; j++) {\\n      if (i === 0) dp[i][j] = Math.max(j >= 1 ? dp[i][j - 1] : 0, A[j]); // If only one day\\n      else if (i > j) dp[i][j] = -1; // If day larger than work, return -1\\n      else {\\n        let max = A[j];\\n        for (let k = 1; k <= j && i - 1 <= j - k; k++) {\\n          max = Math.max(max, A[j - k + 1]);\\n          dp[i][j] = Math.min(dp[i][j] || Infinity, dp[i - 1][j - k] + max);\\n        }\\n      }\\n      // dp[i][j] = Math.min(\\n      //   dp[i - 1][j - 1] + A[j] // Do one job in new day\\n      //   dp[i - 1][j - 2] + Math.max(A[j], A[j - 1]) // Do two jobs in new day\\n      //   ...\\n      //   dp[i - 1][j - k] + Math.max(max, A[j - k + 1])\\n      //   ...\\n      //   dp[i - 1][0] + Math.max(A[j], A[j - 1], ..., A[1]) // Leave only one job in previous day\\n      // );\\n    }\\n  }\\n\\n  return dp[d - 1][L - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Time: O(LLd), space: O(Ld)\\nvar minDifficulty = function (A, d) {\\n  const L = A.length;\\n  const dp = Array.from(Array(d), () => Array(L));\\n\\n  for (let i = 0; i < d; i++) {\\n    for (let j = 0; j < L; j++) {\\n      if (i === 0) dp[i][j] = Math.max(j >= 1 ? dp[i][j - 1] : 0, A[j]); // If only one day\\n      else if (i > j) dp[i][j] = -1; // If day larger than work, return -1\\n      else {\\n        let max = A[j];\\n        for (let k = 1; k <= j && i - 1 <= j - k; k++) {\\n          max = Math.max(max, A[j - k + 1]);\\n          dp[i][j] = Math.min(dp[i][j] || Infinity, dp[i - 1][j - k] + max);\\n        }\\n      }\\n      // dp[i][j] = Math.min(\\n      //   dp[i - 1][j - 1] + A[j] // Do one job in new day\\n      //   dp[i - 1][j - 2] + Math.max(A[j], A[j - 1]) // Do two jobs in new day\\n      //   ...\\n      //   dp[i - 1][j - k] + Math.max(max, A[j - k + 1])\\n      //   ...\\n      //   dp[i - 1][0] + Math.max(A[j], A[j - 1], ..., A[1]) // Leave only one job in previous day\\n      // );\\n    }\\n  }\\n\\n  return dp[d - 1][L - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919816,
                "title": "java-dp-o-n-2-d",
                "content": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int limit = 300000;\\n        // basically how to split the array and get max for each subarray and find the \\n        // minimal sum of subarray max.\\n        int len = jobDifficulty.length;\\n        // dp[i][j] means the minimal sum of max number of subarray ending at idx j for ith day.\\n        int[][] dp = new int[d][len];\\n        \\n        dp[0][0] = jobDifficulty[0];\\n        for (int j = 1; j < len; j++) {\\n            dp[0][j] = Math.max(dp[0][j - 1], jobDifficulty[j]);\\n        }\\n        \\n        for (int i = 1; i < d; i++) {\\n            for (int j = 0; j < len; j++) { // say, for 2nd, ending at jth idx.\\n                int cur = limit;\\n                int arrmax = 0;\\n                // Start from j and decrease\\uFF01\\uFF01\\uFF01\\uFF01\\uFF01\\u8FD9\\u91CC\\u662F\\u5173\\u952E\\u5426\\u5219\\u53C8\\u8981\\u589E\\u52A0\\u4E00\\u7EF4\\u590D\\u6742\\u5EA6\\n                for (int k = j; k >= 1; k--) {\\n                    // dp[i - 1][k] + max[k + 1, j]\\n                    arrmax = Math.max(arrmax, jobDifficulty[k]);\\n                    cur = Math.min(cur, dp[i - 1][k - 1] + arrmax);\\n                }\\n                dp[i][j] = cur;\\n            }\\n        }\\n        if (dp[d - 1][len - 1] == limit) return -1;\\n        return dp[d - 1][len - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int limit = 300000;\\n        // basically how to split the array and get max for each subarray and find the \\n        // minimal sum of subarray max.\\n        int len = jobDifficulty.length;\\n        // dp[i][j] means the minimal sum of max number of subarray ending at idx j for ith day.\\n        int[][] dp = new int[d][len];\\n        \\n        dp[0][0] = jobDifficulty[0];\\n        for (int j = 1; j < len; j++) {\\n            dp[0][j] = Math.max(dp[0][j - 1], jobDifficulty[j]);\\n        }\\n        \\n        for (int i = 1; i < d; i++) {\\n            for (int j = 0; j < len; j++) { // say, for 2nd, ending at jth idx.\\n                int cur = limit;\\n                int arrmax = 0;\\n                // Start from j and decrease\\uFF01\\uFF01\\uFF01\\uFF01\\uFF01\\u8FD9\\u91CC\\u662F\\u5173\\u952E\\u5426\\u5219\\u53C8\\u8981\\u589E\\u52A0\\u4E00\\u7EF4\\u590D\\u6742\\u5EA6\\n                for (int k = j; k >= 1; k--) {\\n                    // dp[i - 1][k] + max[k + 1, j]\\n                    arrmax = Math.max(arrmax, jobDifficulty[k]);\\n                    cur = Math.min(cur, dp[i - 1][k - 1] + arrmax);\\n                }\\n                dp[i][j] = cur;\\n            }\\n        }\\n        if (dp[d - 1][len - 1] == limit) return -1;\\n        return dp[d - 1][len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887069,
                "title": "can-somebody-explain-the-bottom-up-dp-solution-to-me",
                "content": "I was able come up with the memoization solution but I don\\'t understand the DP solutions. How does one populate the `dp` table? Thanks.\\n\\nHere is my memoization solution if you want to see:\\n```\\nclass Solution {\\n  const int MAX_DIFFICULTY = 1000 * 300;\\n  \\n  int min_diff(vector<int>& job_diff, int d, size_t begin_pos,\\n               vector<vector<int>>& memo) {\\n    if (memo[begin_pos][d]) {\\n      return memo[begin_pos][d];\\n    }\\n    if (d == 1) {\\n      return memo[begin_pos][d] = \\n          *max_element(begin(job_diff) + begin_pos, end(job_diff));\\n    }\\n    int prefix_diff = 0, total_diff = MAX_DIFFICULTY;\\n    for (size_t i = begin_pos; i < job_diff.size()-1; i++) {\\n      prefix_diff = max(prefix_diff, job_diff[i]);\\n      \\n      // total difficulty = min(total difficulty, suffix difficulty)\\n      // suffix = all - prefix\\n      total_diff = min(total_diff, \\n                       prefix_diff + min_diff(job_diff, d-1, i+1, memo));\\n    }\\n    return memo[begin_pos][d] = total_diff;\\n  }\\n  \\npublic:\\n  // O(d * N^2) time, O(d * N) space\\n  int minDifficulty(vector<int>& jobDifficulty, int d) {\\n    if (jobDifficulty.size() < d) return -1;\\n    vector<vector<int>> memo(jobDifficulty.size()+1, vector<int>(d+1));\\n    return min_diff(jobDifficulty, d, 0, memo);\\n  }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  const int MAX_DIFFICULTY = 1000 * 300;\\n  \\n  int min_diff(vector<int>& job_diff, int d, size_t begin_pos,\\n               vector<vector<int>>& memo) {\\n    if (memo[begin_pos][d]) {\\n      return memo[begin_pos][d];\\n    }\\n    if (d == 1) {\\n      return memo[begin_pos][d] = \\n          *max_element(begin(job_diff) + begin_pos, end(job_diff));\\n    }\\n    int prefix_diff = 0, total_diff = MAX_DIFFICULTY;\\n    for (size_t i = begin_pos; i < job_diff.size()-1; i++) {\\n      prefix_diff = max(prefix_diff, job_diff[i]);\\n      \\n      // total difficulty = min(total difficulty, suffix difficulty)\\n      // suffix = all - prefix\\n      total_diff = min(total_diff, \\n                       prefix_diff + min_diff(job_diff, d-1, i+1, memo));\\n    }\\n    return memo[begin_pos][d] = total_diff;\\n  }\\n  \\npublic:\\n  // O(d * N^2) time, O(d * N) space\\n  int minDifficulty(vector<int>& jobDifficulty, int d) {\\n    if (jobDifficulty.size() < d) return -1;\\n    vector<vector<int>> memo(jobDifficulty.size()+1, vector<int>(d+1));\\n    return min_diff(jobDifficulty, d, 0, memo);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836442,
                "title": "python-top-down-memoization-dfs",
                "content": "```\\nclass Solution:\\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\\n        if len(jobs) < d:\\n            return -1\\n        \\n        return self.topDown(jobs, d, 0, {})\\n    \\n    def topDown(self, jobs, d, index, memo):\\n        if d <= 0:\\n            return float(\\'inf\\')\\n        # if len(jobs) - index + 1 < d:\\n        #     return float(\\'inf\\')\\n        if d == 1:\\n            if index < len(jobs):\\n                return max(jobs[index: ])\\n            return float(\\'inf\\')\\n        \\n        if (d, index) in memo:\\n            return memo[(d, index)]\\n        \\n        mindiff = float(\\'inf\\')\\n        \\n        for i in range(index, len(jobs)):\\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\\n        memo[(d, index)] = mindiff\\n        return mindiff\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\\n        if len(jobs) < d:\\n            return -1\\n        \\n        return self.topDown(jobs, d, 0, {})\\n    \\n    def topDown(self, jobs, d, index, memo):\\n        if d <= 0:\\n            return float(\\'inf\\')\\n        # if len(jobs) - index + 1 < d:\\n        #     return float(\\'inf\\')\\n        if d == 1:\\n            if index < len(jobs):\\n                return max(jobs[index: ])\\n            return float(\\'inf\\')\\n        \\n        if (d, index) in memo:\\n            return memo[(d, index)]\\n        \\n        mindiff = float(\\'inf\\')\\n        \\n        for i in range(index, len(jobs)):\\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\\n        memo[(d, index)] = mindiff\\n        return mindiff\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 494700,
                "title": "c-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDifficulty(vector<int>& jobDifficulty, int d) {\\n\\t\\t\\tif(jobDifficulty.size()<d) return -1;\\n\\t\\t\\tint n=jobDifficulty.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(d+1,INT_MAX/2));\\n\\t\\t\\tdp[0][0]=0;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int k=1;k<=d;k++){\\n\\t\\t\\t\\t\\tint temp=0;\\n\\t\\t\\t\\t\\tfor(int j=i-1;j>=k-1;j--){\\n\\t\\t\\t\\t\\t\\ttemp=max(temp,jobDifficulty[j]);\\n\\t\\t\\t\\t\\t\\tdp[i][k]=min(dp[i][k],dp[j][k-1]+temp);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n][d];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minDifficulty(vector<int>& jobDifficulty, int d) {\\n\\t\\t\\tif(jobDifficulty.size()<d) return -1;\\n\\t\\t\\tint n=jobDifficulty.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(d+1,INT_MAX/2));\\n\\t\\t\\tdp[0][0]=0;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int k=1;k<=d;k++){\\n\\t\\t\\t\\t\\tint temp=0;\\n\\t\\t\\t\\t\\tfor(int j=i-1;j>=k-1;j--){\\n\\t\\t\\t\\t\\t\\ttemp=max(temp,jobDifficulty[j]);\\n\\t\\t\\t\\t\\t\\tdp[i][k]=min(dp[i][k],dp[j][k-1]+temp);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 491302,
                "title": "c-solution-dp",
                "content": "```\\npublic class Solution \\n{\\n    public int MinDifficulty(int[] jobDifficulty, int d) \\n    {\\n        int n = jobDifficulty.Length;\\n        if (n < d) return -1;\\n        var dp = new int[d, n];\\n        for (int day = 0; day < d; day++) \\n        {\\n            for (int j = day; j < n; j++)\\n            {\\n                if(day == 0)\\n                    dp[0, j] = j == 0 ? jobDifficulty[0] : Math.Max(dp[0, j-1], jobDifficulty[j]);\\n                else\\n                {\\n                    int max = jobDifficulty[j];\\n                    dp[day, j] = int.MaxValue;\\n                    for (int i = j - 1; i >= day - 1; i--) \\n                    {\\n                        max = Math.Max(max, jobDifficulty[i+1]);\\n                        dp[day, j] = Math.Min(dp[day, j], dp[day - 1, i] + max);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[d-1, n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinDifficulty(int[] jobDifficulty, int d) \\n    {\\n        int n = jobDifficulty.Length;\\n        if (n < d) return -1;\\n        var dp = new int[d, n];\\n        for (int day = 0; day < d; day++) \\n        {\\n            for (int j = day; j < n; j++)\\n            {\\n                if(day == 0)\\n                    dp[0, j] = j == 0 ? jobDifficulty[0] : Math.Max(dp[0, j-1], jobDifficulty[j]);\\n                else\\n                {\\n                    int max = jobDifficulty[j];\\n                    dp[day, j] = int.MaxValue;\\n                    for (int i = j - 1; i >= day - 1; i--) \\n                    {\\n                        max = Math.Max(max, jobDifficulty[i+1]);\\n                        dp[day, j] = Math.Min(dp[day, j], dp[day - 1, i] + max);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[d-1, n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490458,
                "title": "easy-python3-top-down-dfs-with-memo",
                "content": "```python\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if n < d: return -1\\n        \\n        memo = {}\\n        def dfs(i,left): # left means the number of days we left\\n            if (i,left) in memo:\\n                return memo[(i, left)]\\n            \\n            if i == n and left == 0: #success case \\n                return 0\\n            \\n            if i == n and left > 0: #failure case\\n                return float(\\'inf\\')\\n            \\n            if i < n and left == 0: #failure case\\n                return float(\\'inf\\')\\n                   \\n            res = float(\\'inf\\')\\n            cost = -float(\\'inf\\')\\n            for j in range(i,n):\\n                cost = max(jobDifficulty[j],cost) #calculate the max cost between jobDifficulty[i : j + 1]\\n                res = min(res, cost + dfs(j + 1,left - 1)) \\n            memo[(i,left)] = res\\n            return res\\n        return dfs(0,d)\\n\\t\\t# I really appreciate it if u vote up! \\uFF08\\uFFE3\\uFE36\\uFFE3\\uFF09\\u2197\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if n < d: return -1\\n        \\n        memo = {}\\n        def dfs(i,left): # left means the number of days we left\\n            if (i,left) in memo:\\n                return memo[(i, left)]\\n            \\n            if i == n and left == 0: #success case \\n                return 0\\n            \\n            if i == n and left > 0: #failure case\\n                return float(\\'inf\\')\\n            \\n            if i < n and left == 0: #failure case\\n                return float(\\'inf\\')\\n                   \\n            res = float(\\'inf\\')\\n            cost = -float(\\'inf\\')\\n            for j in range(i,n):\\n                cost = max(jobDifficulty[j],cost) #calculate the max cost between jobDifficulty[i : j + 1]\\n                res = min(res, cost + dfs(j + 1,left - 1)) \\n            memo[(i,left)] = res\\n            return res\\n        return dfs(0,d)\\n\\t\\t# I really appreciate it if u vote up! \\uFF08\\uFFE3\\uFE36\\uFFE3\\uFF09\\u2197\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490397,
                "title": "c-py3-dp-solution",
                "content": "Split an integer string `a` into `d` parts so that the sum of the maximum of these parts is minimal.\\n\\n# Analysis\\nLet `f[i][j]` denote the best result of splitting the first `i` elements of `a` into `j` parts. Then the DP formula is:\\n\\n`f[i][j] = min(f[i][j], f[k][j-1] + max(a[k+1..j])), k = 0..i-1`\\n\\nThe time complexity is  O(n^2 * d).\\n\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int maxn[305][305];\\n        int n = jobDifficulty.size();\\n        if (n < d) return -1;\\n        \\n        for (int i = 0; i < n; i++) {\\n            maxn[i][i] = jobDifficulty[i];\\n            for (int j = i + 1; j < n; j++)\\n                maxn[i][j] = max(maxn[i][j-1], jobDifficulty[j]);\\n        }\\n        \\n        int f[305][15];\\n        for (int i = 0; i < n; i++) {\\n            f[i][0] = maxn[0][i];\\n            for (int j = 1; j < d; j++) {\\n                f[i][j] = 1e9;\\n                for (int k = i - 1; k >= 0; k--)\\n                    f[i][j] = min(f[i][j], f[k][j-1] + maxn[k+1][i]);\\n            }\\n        }\\n        return f[n-1][d-1];\\n    }\\n};\\n```\\n\\n# PY3 Solution\\n```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if n < d:\\n            return -1;\\n        maxn = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n):\\n            maxn[i][i] = jobDifficulty[i]\\n            for j in range(i + 1, n):\\n                maxn[i][j] = max(maxn[i][j-1], jobDifficulty[j])\\n        \\n        f = [[0] * d for _ in range(n)]\\n        for i in range(n):\\n            f[i][0] = maxn[0][i]\\n            for j in range(1, d):\\n                f[i][j] = 1e9;\\n                for k in range(i - 1, -1, -1):\\n                    f[i][j] = min(f[i][j], f[k][j-1] + maxn[k+1][i])\\n\\n        return f[n - 1][d - 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int maxn[305][305];\\n        int n = jobDifficulty.size();\\n        if (n < d) return -1;\\n        \\n        for (int i = 0; i < n; i++) {\\n            maxn[i][i] = jobDifficulty[i];\\n            for (int j = i + 1; j < n; j++)\\n                maxn[i][j] = max(maxn[i][j-1], jobDifficulty[j]);\\n        }\\n        \\n        int f[305][15];\\n        for (int i = 0; i < n; i++) {\\n            f[i][0] = maxn[0][i];\\n            for (int j = 1; j < d; j++) {\\n                f[i][j] = 1e9;\\n                for (int k = i - 1; k >= 0; k--)\\n                    f[i][j] = min(f[i][j], f[k][j-1] + maxn[k+1][i]);\\n            }\\n        }\\n        return f[n-1][d-1];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n = len(jobDifficulty)\\n        if n < d:\\n            return -1;\\n        maxn = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n):\\n            maxn[i][i] = jobDifficulty[i]\\n            for j in range(i + 1, n):\\n                maxn[i][j] = max(maxn[i][j-1], jobDifficulty[j])\\n        \\n        f = [[0] * d for _ in range(n)]\\n        for i in range(n):\\n            f[i][0] = maxn[0][i]\\n            for j in range(1, d):\\n                f[i][j] = 1e9;\\n                for k in range(i - 1, -1, -1):\\n                    f[i][j] = min(f[i][j], f[k][j-1] + maxn[k+1][i])\\n\\n        return f[n - 1][d - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013654,
                "title": "it-feels-great-when-you-are-able-to-solve-dp-problem-on-your-own-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSame pick & not_pick approach taught by striver\\n\\n\\n**Time complexity**\\n- Time complexity: Exponential\\n\\n# Code\\n\\n# Recursion\\n\\n```\\n   \\n     int helper(vector<int>& jobs, int ind, int d, int maxi) {\\n         if (d == 1) {\\n             // Base case: When there is only 1 day left, return the maximum difficulty\\n             return *max_element(jobs.begin() + ind, jobs.end());\\n         }\\n         // Atleast 1 job should be there on each day so it should go till n-d (6-2)till index 4\\n         if(ind >jobs.size()-d)\\n          return 1e9;\\n\\n         \\n         maxi = max(maxi, jobs[ind]);\\n\\n         \\n         int pick = maxi + helper(jobs, ind + 1, d - 1, 0); // Reset maxi to 0 when a new day starts\\n         int not_pick = helper(jobs, ind + 1, d, maxi);\\n\\n         \\n         return min(pick, not_pick);\\n     }\\n\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if (jobDifficulty.size() < d) {\\n            return -1; \\n        }\\n        int n = jobDifficulty.size();\\n      \\n        return helper(jobDifficulty, 0, d, 0);\\n    }\\n};\\n \\n\\n\\n\\n```\\n# Memoization\\n\\n**Time complexity**\\n- Time complexity:0(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n^3)+recursion stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n       vector<vector<vector<int>>>dp;\\n     int helper(vector<int>& jobs, int ind, int d, int maxi) {\\n         if (d == 1) {\\n             // Base case: When there is only 1 day left, return the maximum difficulty\\n             return *max_element(jobs.begin() + ind, jobs.end());\\n         }\\n         // Atleast 1 job should be there on each day so it should go till n-d (6-2)till index 4\\n         if(ind >jobs.size()-d)\\n          return 1e9;\\n\\n         if(dp[ind][d][maxi] !=-1)\\n           return dp[ind][d][maxi];\\n\\n           \\n         maxi = max(maxi, jobs[ind]);\\n\\n         \\n         int pick = maxi + helper(jobs, ind + 1, d - 1, 0); // Reset maxi to 0 when a new day starts\\n         int not_pick = helper(jobs, ind + 1, d, maxi);\\n\\n         \\n         return dp[ind][d][maxi] = min(pick, not_pick);\\n     }\\n\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if (jobDifficulty.size() < d) {\\n            return -1; \\n        }\\n        int n = jobDifficulty.size();\\n\\n        int maxi = *max_element(jobDifficulty.begin(),jobDifficulty.end());\\n\\n        dp.resize(n+1,vector<vector<int>>(d+1,vector<int>(maxi+1,-1)));\\n        return helper(jobDifficulty, 0, d, 0);\\n    }\\n};\\n\\n```\\n**Time complexity**\\n- Time complexity:0(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n^2)+recursion stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<int>& jd,int n,int ind ,int d)\\n    {\\n        if(d==1)\\n        {\\n            return *max_element(jd.begin()+ind,jd.end());\\n        }\\n        if(dp[ind][d] !=-1)\\n         return dp[ind][d];\\n\\n\\n        int maxi = -1e9;\\n        int result = 1e9;\\n        for(int i = ind ; i <=n-d ;i++)\\n        {\\n           maxi = max(maxi,jd[i]);\\n           result = min(result , maxi+solve(jd,n,i+1,d-1));\\n        }\\n        return dp[ind][d]= result;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n\\n        if(n < d)\\n        {\\n            return -1;\\n        }\\n        dp.resize(n+1,vector<int>(d+1,-1));\\n        return solve(jobDifficulty , n,0,d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n   \\n     int helper(vector<int>& jobs, int ind, int d, int maxi) {\\n         if (d == 1) {\\n             // Base case: When there is only 1 day left, return the maximum difficulty\\n             return *max_element(jobs.begin() + ind, jobs.end());\\n         }\\n         // Atleast 1 job should be there on each day so it should go till n-d (6-2)till index 4\\n         if(ind >jobs.size()-d)\\n          return 1e9;\\n\\n         \\n         maxi = max(maxi, jobs[ind]);\\n\\n         \\n         int pick = maxi + helper(jobs, ind + 1, d - 1, 0); // Reset maxi to 0 when a new day starts\\n         int not_pick = helper(jobs, ind + 1, d, maxi);\\n\\n         \\n         return min(pick, not_pick);\\n     }\\n\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if (jobDifficulty.size() < d) {\\n            return -1; \\n        }\\n        int n = jobDifficulty.size();\\n      \\n        return helper(jobDifficulty, 0, d, 0);\\n    }\\n};\\n \\n\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n       vector<vector<vector<int>>>dp;\\n     int helper(vector<int>& jobs, int ind, int d, int maxi) {\\n         if (d == 1) {\\n             // Base case: When there is only 1 day left, return the maximum difficulty\\n             return *max_element(jobs.begin() + ind, jobs.end());\\n         }\\n         // Atleast 1 job should be there on each day so it should go till n-d (6-2)till index 4\\n         if(ind >jobs.size()-d)\\n          return 1e9;\\n\\n         if(dp[ind][d][maxi] !=-1)\\n           return dp[ind][d][maxi];\\n\\n           \\n         maxi = max(maxi, jobs[ind]);\\n\\n         \\n         int pick = maxi + helper(jobs, ind + 1, d - 1, 0); // Reset maxi to 0 when a new day starts\\n         int not_pick = helper(jobs, ind + 1, d, maxi);\\n\\n         \\n         return dp[ind][d][maxi] = min(pick, not_pick);\\n     }\\n\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if (jobDifficulty.size() < d) {\\n            return -1; \\n        }\\n        int n = jobDifficulty.size();\\n\\n        int maxi = *max_element(jobDifficulty.begin(),jobDifficulty.end());\\n\\n        dp.resize(n+1,vector<vector<int>>(d+1,vector<int>(maxi+1,-1)));\\n        return helper(jobDifficulty, 0, d, 0);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<int>& jd,int n,int ind ,int d)\\n    {\\n        if(d==1)\\n        {\\n            return *max_element(jd.begin()+ind,jd.end());\\n        }\\n        if(dp[ind][d] !=-1)\\n         return dp[ind][d];\\n\\n\\n        int maxi = -1e9;\\n        int result = 1e9;\\n        for(int i = ind ; i <=n-d ;i++)\\n        {\\n           maxi = max(maxi,jd[i]);\\n           result = min(result , maxi+solve(jd,n,i+1,d-1));\\n        }\\n        return dp[ind][d]= result;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n\\n        if(n < d)\\n        {\\n            return -1;\\n        }\\n        dp.resize(n+1,vector<int>(d+1,-1));\\n        return solve(jobDifficulty , n,0,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982065,
                "title": "line-by-line-code-explained-dp-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t[301][11];\\n    int solve(vector<int>& jd, int n, int idx, int d) {\\n        //if you have only 1 day, then you will all the remaining jobs\\n        //and select the max difficulty as the answer\\n        if(d == 1) {\\n            return *max_element(begin(jd)+idx, end(jd));\\n        }\\n        if(t[idx][d] != -1)\\n            return t[idx][d];\\n        int Max = INT_MIN;\\n        int result = INT_MAX;\\n        //Try one by one with all possibility\\n        /*\\n            Take 1 job in one day\\n            Take 2 jobs in one day\\n            Take 3 jobs in one day\\n            and so on\\n            \\n            Then find the optimal one among all the results\\n        */\\n        for(int i = idx; i<=n-d; i++) {\\n            Max = max(Max, jd[i]);  \\n            result = min(result, Max + solve(jd, n, i+1, d-1));\\n        }\\n        return t[idx][d] = result;\\n    }\\n    int minDifficulty(vector<int>& jd, int d) {\\n        int n = jd.size();  \\n        if(n < d)\\n            return -1;\\n        memset(t, -1, sizeof(t));\\n        return solve(jd, n, 0, d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[301][11];\\n    int solve(vector<int>& jd, int n, int idx, int d) {\\n        //if you have only 1 day, then you will all the remaining jobs\\n        //and select the max difficulty as the answer\\n        if(d == 1) {\\n            return *max_element(begin(jd)+idx, end(jd));\\n        }\\n        if(t[idx][d] != -1)\\n            return t[idx][d];\\n        int Max = INT_MIN;\\n        int result = INT_MAX;\\n        //Try one by one with all possibility\\n        /*\\n            Take 1 job in one day\\n            Take 2 jobs in one day\\n            Take 3 jobs in one day\\n            and so on\\n            \\n            Then find the optimal one among all the results\\n        */\\n        for(int i = idx; i<=n-d; i++) {\\n            Max = max(Max, jd[i]);  \\n            result = min(result, Max + solve(jd, n, i+1, d-1));\\n        }\\n        return t[idx][d] = result;\\n    }\\n    int minDifficulty(vector<int>& jd, int d) {\\n        int n = jd.size();  \\n        if(n < d)\\n            return -1;\\n        memset(t, -1, sizeof(t));\\n        return solve(jd, n, 0, d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711089,
                "title": "recursion-memoization-topdown-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int helpme(vector<int>&nums,int d,int idx,int &n,vector<vector<int>>&dp,vector<int>&maxarr)\\n    {\\n        if(n<d)\\n            return -1;\\n        if(d==1)\\n            return maxarr[idx];\\n        if(dp[d][idx]!=-2)\\n            return  dp[d][idx];\\n        int ans=INT_MAX;\\n        int maxTillithIndex=INT_MIN;\\n        for(int i=idx;i<=n-d;i++)\\n        {\\n            maxTillithIndex=max(maxTillithIndex,nums[i]);\\n            ans=min(ans,maxTillithIndex+helpme(nums,d-1,i+1,n,dp,maxarr));\\n        }\\n        return dp[d][idx]=ans;\\n    }\\n     int minDifficulty(vector<int>& A, int D) {\\n       int n=A.size();\\n         vector<vector<int>>dp(11,vector<int>(301,-2));\\n         \\n         //this vector is to store the maxElement in the righwards(i.e. maxarr[i] contains max element from i...n)\\n         vector<int>maxarr(n,0);\\n         maxarr[n-1]=A[n-1];\\n         for(int i=n-2;i>=0;i--)\\n             maxarr[i]=max(maxarr[i+1],A[i]);\\n         return helpme(A,D,0,n,dp,maxarr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helpme(vector<int>&nums,int d,int idx,int &n,vector<vector<int>>&dp,vector<int>&maxarr)\\n    {\\n        if(n<d)\\n            return -1;\\n        if(d==1)\\n            return maxarr[idx];\\n        if(dp[d][idx]!=-2)\\n            return  dp[d][idx];\\n        int ans=INT_MAX;\\n        int maxTillithIndex=INT_MIN;\\n        for(int i=idx;i<=n-d;i++)\\n        {\\n            maxTillithIndex=max(maxTillithIndex,nums[i]);\\n            ans=min(ans,maxTillithIndex+helpme(nums,d-1,i+1,n,dp,maxarr));\\n        }\\n        return dp[d][idx]=ans;\\n    }\\n     int minDifficulty(vector<int>& A, int D) {\\n       int n=A.size();\\n         vector<vector<int>>dp(11,vector<int>(301,-2));\\n         \\n         //this vector is to store the maxElement in the righwards(i.e. maxarr[i] contains max element from i...n)\\n         vector<int>maxarr(n,0);\\n         maxarr[n-1]=A[n-1];\\n         for(int i=n-2;i>=0;i--)\\n             maxarr[i]=max(maxarr[i+1],A[i]);\\n         return helpme(A,D,0,n,dp,maxarr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710684,
                "title": "java-tabulation-simple-and-fastest-solution-99-both-in-memory-and-runtime",
                "content": "Just make a dp of length d+1 and n+1, **After that we will move from top right corner of this matrix getting answer from 0 to d and taking elements from last to first.**\\nPut a check whether **we can take a element and make a new partition or take it into the the current subarray.** Loop from current element to the end for this check and **take the minimum as the current answer.**\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jD, int d) {\\n        \\n        int n = jD.length;\\n        int [][]dp = new int[d+1][n+1]; // dp\\n        \\n        for( int i=0; i<=d; i++ ) {\\n          /*  the limit for the elements is the amount of partitions left so if we have no partitions left then we can go all the way from the first element to the last but if we have one partition left , we have to leave one element by default to make sure that even if we take all elements for current subarray there is still an element left in order for that one partition to accomodate */\\n            int left = (d-i);\\n            for( int j=n; j>=left; j--) {\\n                \\n\\t\\t\\t\\t// default answer\\n                int cans = (int)1e5;\\n                \\n\\t\\t\\t\\t// base case \\n                if( i==0 && j==n ) dp[i][j] = 0;\\n\\t\\t\\t\\t// in cases when elements are less than partition\\n                else if( i==0 || j==n ) dp[i][j] = cans;\\n                else {\\n                    int max = -1;\\n\\t\\t\\t\\t\\t// loop to check the for the condition mentioned\\n                    for( int k=j+1; k<=n; k++ ) {\\n                        max = Math.max(jD[k-1],max);\\n                        cans = Math.min(cans,max+dp[i-1][k]);\\n                    }\\n                    \\n                    dp[i][j] = cans;\\n                }\\n            }\\n        }\\n        \\n        return (dp[d][0]==(int)1e5) ? -1 : dp[d][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jD, int d) {\\n        \\n        int n = jD.length;\\n        int [][]dp = new int[d+1][n+1]; // dp\\n        \\n        for( int i=0; i<=d; i++ ) {\\n          /*  the limit for the elements is the amount of partitions left so if we have no partitions left then we can go all the way from the first element to the last but if we have one partition left , we have to leave one element by default to make sure that even if we take all elements for current subarray there is still an element left in order for that one partition to accomodate */\\n            int left = (d-i);\\n            for( int j=n; j>=left; j--) {\\n                \\n\\t\\t\\t\\t// default answer\\n                int cans = (int)1e5;\\n                \\n\\t\\t\\t\\t// base case \\n                if( i==0 && j==n ) dp[i][j] = 0;\\n\\t\\t\\t\\t// in cases when elements are less than partition\\n                else if( i==0 || j==n ) dp[i][j] = cans;\\n                else {\\n                    int max = -1;\\n\\t\\t\\t\\t\\t// loop to check the for the condition mentioned\\n                    for( int k=j+1; k<=n; k++ ) {\\n                        max = Math.max(jD[k-1],max);\\n                        cans = Math.min(cans,max+dp[i-1][k]);\\n                    }\\n                    \\n                    dp[i][j] = cans;\\n                }\\n            }\\n        }\\n        \\n        return (dp[d][0]==(int)1e5) ? -1 : dp[d][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710023,
                "title": "c-dp-short-simple-code-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve( int idx, int d, vector<int>&job, vector<vector<int>>&dp ){\\n        \\n        if( idx == job.size() ){\\n            if( d == 0 )    return 0 ;\\n            return 1e9 ;\\n        }  \\n        \\n        if( d <= 0 )    return 1e9 ;\\n        \\n        if( dp[idx][d] != -1 ) return dp[idx][d] ;\\n        \\n        int ans = INT_MAX , maxi = INT_MIN ;\\n        \\n        for( int i = idx ; i < job.size() ; i++ ){\\n            \\n            maxi = max( maxi, job[i] ) ;\\n\\t\\t\\t\\n            int temp = maxi + solve(i+1, job, d-1, dp) ;\\n\\t\\t\\t\\n            ans = min(temp, ans) ;\\n\\t\\t\\t\\n        }\\n        return dp[idx][d] = ans ;\\n    }\\n    \\n    \\n    int minDifficulty(vector<int>& job, int d) {\\n\\t\\n        int n = job.size() ;\\n        \\n        vector<vector<int>>dp(n+1, vector<int>(d+1, -1)) ;\\n        \\n        int ans = solve(0, job, d, dp) ;\\n        \\n        if( ans >= 1e9 )    return -1 ;\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve( int idx, int d, vector<int>&job, vector<vector<int>>&dp ){\\n        \\n        if( idx == job.size() ){\\n            if( d == 0 )    return 0 ;\\n            return 1e9 ;\\n        }  \\n        \\n        if( d <= 0 )    return 1e9 ;\\n        \\n        if( dp[idx][d] != -1 ) return dp[idx][d] ;\\n        \\n        int ans = INT_MAX , maxi = INT_MIN ;\\n        \\n        for( int i = idx ; i < job.size() ; i++ ){\\n            \\n            maxi = max( maxi, job[i] ) ;\\n\\t\\t\\t\\n            int temp = maxi + solve(i+1, job, d-1, dp) ;\\n\\t\\t\\t\\n            ans = min(temp, ans) ;\\n\\t\\t\\t\\n        }\\n        return dp[idx][d] = ans ;\\n    }\\n    \\n    \\n    int minDifficulty(vector<int>& job, int d) {\\n\\t\\n        int n = job.size() ;\\n        \\n        vector<vector<int>>dp(n+1, vector<int>(d+1, -1)) ;\\n        \\n        int ans = solve(0, job, d, dp) ;\\n        \\n        if( ans >= 1e9 )    return -1 ;\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709312,
                "title": "c-dp-memorisation-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[301][11];\\n    int solve(vector<int> &jobd,int n,int i,int d){\\n        if(d == 1)\\n        {\\n            return *max_element(begin(jobd)+i,end(jobd));\\n        }\\n        if(dp[i][d] != -1){\\n            return dp[i][d];\\n        }\\n        \\n        int result = INT_MAX;\\n        int currD = INT_MIN;\\n        for(int j=i;j<=n-d;j++)\\n        {\\n            currD = max(currD,jobd[j]);\\n            result = min(result,currD + solve(jobd,n,j+1,d-1));\\n        }\\n        dp[i][d] = result;\\n        return dp[i][d];\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = jobDifficulty.size();\\n        if(n < d){\\n            return -1;\\n        }\\n        return solve(jobDifficulty,n,0,d);\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][11];\\n    int solve(vector<int> &jobd,int n,int i,int d){\\n        if(d == 1)\\n        {\\n            return *max_element(begin(jobd)+i,end(jobd));\\n        }\\n        if(dp[i][d] != -1){\\n            return dp[i][d];\\n        }\\n        \\n        int result = INT_MAX;\\n        int currD = INT_MIN;\\n        for(int j=i;j<=n-d;j++)\\n        {\\n            currD = max(currD,jobd[j]);\\n            result = min(result,currD + solve(jobd,n,j+1,d-1));\\n        }\\n        dp[i][d] = result;\\n        return dp[i][d];\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = jobDifficulty.size();\\n        if(n < d){\\n            return -1;\\n        }\\n        return solve(jobDifficulty,n,0,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708974,
                "title": "python-3-memoized-and-tabulated-solution-credits-striver-dp-series",
                "content": "**The Problem is Same as Partition Array For max Sum, So You can Refer To Striver\\'s DP Series for the Solution of that problem.\\nIn This You Just need to minimize the Sum instead of max and keep track of no of remaining days rest is just the same.**\\n```\\nclass Solution1: # Memoized Solution\\n    def minDifficulty(self, arr: List[int], d: int) -> int:\\n        if d>len(arr): return -1\\n        n = len(arr)\\n        dp = [[-1 for i in range(d+1)] for j in range(n)]\\n        def f(ind,d):\\n            if ind==n: return float(\\'inf\\')\\n            if d==1:   # if we have only one day then we just take max of all remaining jobs\\n                return max(arr[ind:])\\n            if dp[ind][d]!=-1: return dp[ind][d]\\n            ans = float(\\'inf\\')\\n            mx = float(\\'-inf\\')\\n            s = 0\\n            for i in range(ind,n):\\n                mx = max(mx,arr[i])\\n                s=mx+f(i+1,d-1)\\n                ans = min(ans,s)\\n            dp[ind][d] = ans\\n            return dp[ind][d]\\n        return f(0,d)\\nclass Solution:  # Tabulation version\\n    def minDifficulty(self, arr: List[int], d: int) -> int:\\n        if d>len(arr): return -1\\n        n = len(arr)\\n        dp = [[0 for i in range(d+1)] for j in range(n+1)]\\n        for i in range(d+1):                   # Base Cases\\n            dp[n][i] = float(\\'inf\\')\\n        for i in range(n):                       # Base Case\\n            dp[i][1]=max(arr[i:])\\n        for ind in range(n-1,-1,-1):\\n            for days in range(2,d+1):\\n                ans = float(\\'inf\\')\\n                mx = float(\\'-inf\\')\\n                s = 0\\n                for i in range(ind,n):\\n                    mx = max(mx,arr[i])\\n                    s=mx+dp[i+1][days-1]\\n                    ans = min(ans,s)\\n                dp[ind][days] = ans\\n        return dp[0][d]\\n```\\n**Please Upvote if You like this solution.**\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution1: # Memoized Solution\\n    def minDifficulty(self, arr: List[int], d: int) -> int:\\n        if d>len(arr): return -1\\n        n = len(arr)\\n        dp = [[-1 for i in range(d+1)] for j in range(n)]\\n        def f(ind,d):\\n            if ind==n: return float(\\'inf\\')\\n            if d==1:   # if we have only one day then we just take max of all remaining jobs\\n                return max(arr[ind:])\\n            if dp[ind][d]!=-1: return dp[ind][d]\\n            ans = float(\\'inf\\')\\n            mx = float(\\'-inf\\')\\n            s = 0\\n            for i in range(ind,n):\\n                mx = max(mx,arr[i])\\n                s=mx+f(i+1,d-1)\\n                ans = min(ans,s)\\n            dp[ind][d] = ans\\n            return dp[ind][d]\\n        return f(0,d)\\nclass Solution:  # Tabulation version\\n    def minDifficulty(self, arr: List[int], d: int) -> int:\\n        if d>len(arr): return -1\\n        n = len(arr)\\n        dp = [[0 for i in range(d+1)] for j in range(n+1)]\\n        for i in range(d+1):                   # Base Cases\\n            dp[n][i] = float(\\'inf\\')\\n        for i in range(n):                       # Base Case\\n            dp[i][1]=max(arr[i:])\\n        for ind in range(n-1,-1,-1):\\n            for days in range(2,d+1):\\n                ans = float(\\'inf\\')\\n                mx = float(\\'-inf\\')\\n                s = 0\\n                for i in range(ind,n):\\n                    mx = max(mx,arr[i])\\n                    s=mx+dp[i+1][days-1]\\n                    ans = min(ans,s)\\n                dp[ind][days] = ans\\n        return dp[0][d]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708778,
                "title": "python3-dp-dfs-memoziation",
                "content": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        n = len(jobDifficulty)\\n        @lru_cache(None)\\n        def dfs(index, remaining_days):\\n            \\n            if remaining_days == 0:\\n                if index == n: return 0\\n                else: return sys.maxsize\\n            if index == n:\\n                if remaining_days == 0: return 0\\n                else: return sys.maxsize\\n            \\n            ans = sys.maxsize\\n            count_max = 0\\n            for i in range(index, n):\\n                count_max = max(count_max, jobDifficulty[i])\\n                ans = min(ans, count_max + dfs(i+1, remaining_days-1)) \\n            return ans\\n        \\n        if n < d: return -1\\n        return dfs(0, d)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        n = len(jobDifficulty)\\n        @lru_cache(None)\\n        def dfs(index, remaining_days):\\n            \\n            if remaining_days == 0:\\n                if index == n: return 0\\n                else: return sys.maxsize\\n            if index == n:\\n                if remaining_days == 0: return 0\\n                else: return sys.maxsize\\n            \\n            ans = sys.maxsize\\n            count_max = 0\\n            for i in range(index, n):\\n                count_max = max(count_max, jobDifficulty[i])\\n                ans = min(ans, count_max + dfs(i+1, remaining_days-1)) \\n            return ans\\n        \\n        if n < d: return -1\\n        return dfs(0, d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708555,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n   public int minDifficulty(int[] jobDifficulty, int d) {\\n    int n = jobDifficulty.length;\\n    if (d > n) return -1;\\n    int[][] F = new int[d+1][n+1];\\n    for (int i = 1; i <= n; i++) F[1][i] = Math.max(F[1][i-1], jobDifficulty[i-1]);\\n    for (int i = 2; i <= d; i++) {\\n        for (int j = i; j <= n; j++) {\\n            F[i][j] = Integer.MAX_VALUE;\\n            int currMax = 0;\\n            for (int k = j; k >= i; k--) {\\n                currMax = Math.max(currMax, jobDifficulty[k-1]);\\n                F[i][j] = Math.min(F[i][j], F[i-1][k-1] + currMax);\\n            }\\n        }\\n    }\\n    return F[d][n];\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n   public int minDifficulty(int[] jobDifficulty, int d) {\\n    int n = jobDifficulty.length;\\n    if (d > n) return -1;\\n    int[][] F = new int[d+1][n+1];\\n    for (int i = 1; i <= n; i++) F[1][i] = Math.max(F[1][i-1], jobDifficulty[i-1]);\\n    for (int i = 2; i <= d; i++) {\\n        for (int j = i; j <= n; j++) {\\n            F[i][j] = Integer.MAX_VALUE;\\n            int currMax = 0;\\n            for (int k = j; k >= i; k--) {\\n                currMax = Math.max(currMax, jobDifficulty[k-1]);\\n                F[i][j] = Math.min(F[i][j], F[i-1][k-1] + currMax);\\n            }\\n        }\\n    }\\n    return F[d][n];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707908,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} jobs\\n * @param {number} d\\n * @return {number}\\n */\\nconst minDifficulty = (jobs, d) => {\\n    const n = jobs.length;\\n    if (n < d) return -1;\\n        const dp = new Array(n + 1).fill(0);\\n\\n    for (let i = n - 1; i >= 0; i--)\\n        dp[i] = jobs[i] > dp[i + 1] ? jobs[i] : dp[i + 1];\\n\\n    for (let i = 2; i <= d; i++)\\n        for (let j = 0; j <= n - i; j++) {\\n            let max = 0;\\n            dp[j] = Infinity;\\n            for (let k = j; k <= n - i; k++) {\\n                if (jobs[k] > max) max = jobs[k];\\n                if (dp[j] > dp[k + 1] + max) dp[j] = dp[k + 1] + max;\\n            }\\n        }\\n\\n    return dp[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} jobs\\n * @param {number} d\\n * @return {number}\\n */\\nconst minDifficulty = (jobs, d) => {\\n    const n = jobs.length;\\n    if (n < d) return -1;\\n        const dp = new Array(n + 1).fill(0);\\n\\n    for (let i = n - 1; i >= 0; i--)\\n        dp[i] = jobs[i] > dp[i + 1] ? jobs[i] : dp[i + 1];\\n\\n    for (let i = 2; i <= d; i++)\\n        for (let j = 0; j <= n - i; j++) {\\n            let max = 0;\\n            dp[j] = Infinity;\\n            for (let k = j; k <= n - i; k++) {\\n                if (jobs[k] > max) max = jobs[k];\\n                if (dp[j] > dp[k + 1] + max) dp[j] = dp[k + 1] + max;\\n            }\\n        }\\n\\n    return dp[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2508982,
                "title": "java-rec-memoisation",
                "content": "```\\nclass Solution {\\n  public int minDifficulty(int[] job, int d) {\\n      int n = job.length;\\n      if(d>job.length) return -1;\\n      int[][] dp = new int[d+1][n];\\n      for(int[] p: dp) Arrays.fill(p,-1);\\n      return dfs(job, d, dp, 0);\\n  }\\n  private int dfs(int[] job, int d, int[][] dp, int idx){\\n      if(d==1){\\n          int max = 0;\\n          while(idx<job.length) max = Math.max(max, job[idx++]);\\n          return max;\\n      }\\n      if(dp[d][idx]!=-1) return dp[d][idx];\\n      int max = 0; int res = Integer.MAX_VALUE;\\n      for(int i = idx; i<job.length-d+1; i++){\\n          max = Math.max(max, job[i]);\\n          res = Math.min(res, max + dfs(job, d-1, dp, i+1));\\n      }\\n      return dp[d][idx] = res;\\n  }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minDifficulty(int[] job, int d) {\\n      int n = job.length;\\n      if(d>job.length) return -1;\\n      int[][] dp = new int[d+1][n];\\n      for(int[] p: dp) Arrays.fill(p,-1);\\n      return dfs(job, d, dp, 0);\\n  }\\n  private int dfs(int[] job, int d, int[][] dp, int idx){\\n      if(d==1){\\n          int max = 0;\\n          while(idx<job.length) max = Math.max(max, job[idx++]);\\n          return max;\\n      }\\n      if(dp[d][idx]!=-1) return dp[d][idx];\\n      int max = 0; int res = Integer.MAX_VALUE;\\n      for(int i = idx; i<job.length-d+1; i++){\\n          max = Math.max(max, job[i]);\\n          res = Math.min(res, max + dfs(job, d-1, dp, i+1));\\n      }\\n      return dp[d][idx] = res;\\n  }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473660,
                "title": "rust-top-down-and-bottom-up-dp-with-comments",
                "content": "Let\\'s begin with the bottom-up DP solution, and then I\\'ll explain how I got there:\\n\\n```\\nimpl Solution {\\n    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n        let (n, d) = (job_difficulty.len(), d as usize);\\n        if d > n {\\n            return -1;\\n        }\\n        let mut dp = vec![vec![i32::MAX; d + 1]; n + 1];\\n        dp[n][d] = 0;\\n        for j in (0..d).rev() {\\n            for i in (j..=n-(d-j)).rev() {\\n                let mut day_difficulty = 0;\\n                for k in i..=n-(d-j) {\\n                    day_difficulty = day_difficulty.max(job_difficulty[k]);\\n                    dp[i][j] = dp[i][j].min(day_difficulty.saturating_add(dp[k+1][j+1]));\\n                }\\n            }\\n        }\\n        dp[0][0]\\n    }\\n}\\n```\\n\\nI began with this top-down solution, and that wasn\\'t that hard, really. Here, `i` is the next job to be taken, and `d` is the number of days remaining. If there are no jobs and no days remaining, we have reached the base case where we have a valid solution with the minimum difficulty 0. If there are jobs remaining, but no days, We have an invalid solution, and we signal that by returning the sentinel value `i32::MAX`. For all other cases, we loop through doing 1.. jobs, until there are just enough left to have one job for each of the remaining days, and compute the minimum remaining cost using recursion. The result is memoized to avoid duplicate work. In the `min_difficulty` function, we check for unsolvable cases (number of days > number of jobs, since we have to do at least one job per day).\\n\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn dfs(job_difficulty: &[i32], i: usize, d: usize, memo: &mut HashMap<(usize, usize), i32>) -> i32 {\\n        let n = job_difficulty.len();\\n        if i == n && d == 0 {\\n            0\\n        } else if d == 0 {\\n            i32::MAX\\n        } else if let Some(rez) = memo.get(&(i, d)) {\\n            *rez\\n        } else {\\n            let mut day_difficulty = 0;\\n            let mut min_remaining_difficulty = i32::MAX;\\n            for j in i..=n-d {\\n                day_difficulty = day_difficulty.max(job_difficulty[j]);\\n                min_remaining_difficulty = min_remaining_difficulty.min(day_difficulty.saturating_add(Self::dfs(job_difficulty, j+1, d - 1, memo)));\\n            }\\n            memo.insert((i, d), min_remaining_difficulty);\\n            min_remaining_difficulty\\n        }\\n    }\\n\\n    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n        let d = d as usize;\\n        if d > job_difficulty.len() {\\n            -1\\n        } else {\\n            Self::dfs(&job_difficulty, 0, d, &mut HashMap::new())\\n        }\\n    }\\n}\\n```\\n\\nI then realized that I wanted to do the bottom-up solution with a parameterization so that I would be able to retrieve the final result as `dp[0][0]`, so I reparameterized the top-down solution so that `i` still represents the next job to perform (or the number of jobs done so far), and `j` represents the number of days gone. This is a suitable parameterization, since `dp[0][0]` can then be interpreted as the minimum additional cost given that no jobs have been performed, and no days have gone.\\n\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn dfs(job_difficulty: &[i32], n: usize, d: usize, i: usize, j: usize, memo: &mut HashMap<(usize, usize), i32>) -> i32 {\\n        if i == n && j == d {\\n            0\\n        } else if j == d {\\n            i32::MAX\\n        } else if let Some(rez) = memo.get(&(i, j)) {\\n            *rez\\n        } else {\\n            let mut day_difficulty = 0;\\n            let mut min_remaining_difficulty = i32::MAX;\\n            for k in i..=n-(d-j) {\\n                day_difficulty = day_difficulty.max(job_difficulty[k]);\\n                min_remaining_difficulty = min_remaining_difficulty.min(day_difficulty.saturating_add(Self::dfs(job_difficulty, n, d, k + 1, j + 1, memo)));\\n            }\\n            memo.insert((i, j), min_remaining_difficulty);\\n            min_remaining_difficulty\\n        }\\n    }\\n\\n    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n        let d = d as usize;\\n        if d > job_difficulty.len() {\\n            -1\\n        } else {\\n            Self::dfs(&job_difficulty, job_difficulty.len(), d, 0, 0, &mut HashMap::new())\\n        }\\n    }\\n}\\n```\\n\\nWith this parameterization in place, it\\'s pretty easy to transform the `memo` hash map to a 2D table, that is then filled out \"in reverse\", with the base cases set as discussed in the first top-down solution.",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n        let (n, d) = (job_difficulty.len(), d as usize);\\n        if d > n {\\n            return -1;\\n        }\\n        let mut dp = vec![vec![i32::MAX; d + 1]; n + 1];\\n        dp[n][d] = 0;\\n        for j in (0..d).rev() {\\n            for i in (j..=n-(d-j)).rev() {\\n                let mut day_difficulty = 0;\\n                for k in i..=n-(d-j) {\\n                    day_difficulty = day_difficulty.max(job_difficulty[k]);\\n                    dp[i][j] = dp[i][j].min(day_difficulty.saturating_add(dp[k+1][j+1]));\\n                }\\n            }\\n        }\\n        dp[0][0]\\n    }\\n}\\n```\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn dfs(job_difficulty: &[i32], i: usize, d: usize, memo: &mut HashMap<(usize, usize), i32>) -> i32 {\\n        let n = job_difficulty.len();\\n        if i == n && d == 0 {\\n            0\\n        } else if d == 0 {\\n            i32::MAX\\n        } else if let Some(rez) = memo.get(&(i, d)) {\\n            *rez\\n        } else {\\n            let mut day_difficulty = 0;\\n            let mut min_remaining_difficulty = i32::MAX;\\n            for j in i..=n-d {\\n                day_difficulty = day_difficulty.max(job_difficulty[j]);\\n                min_remaining_difficulty = min_remaining_difficulty.min(day_difficulty.saturating_add(Self::dfs(job_difficulty, j+1, d - 1, memo)));\\n            }\\n            memo.insert((i, d), min_remaining_difficulty);\\n            min_remaining_difficulty\\n        }\\n    }\\n\\n    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n        let d = d as usize;\\n        if d > job_difficulty.len() {\\n            -1\\n        } else {\\n            Self::dfs(&job_difficulty, 0, d, &mut HashMap::new())\\n        }\\n    }\\n}\\n```\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn dfs(job_difficulty: &[i32], n: usize, d: usize, i: usize, j: usize, memo: &mut HashMap<(usize, usize), i32>) -> i32 {\\n        if i == n && j == d {\\n            0\\n        } else if j == d {\\n            i32::MAX\\n        } else if let Some(rez) = memo.get(&(i, j)) {\\n            *rez\\n        } else {\\n            let mut day_difficulty = 0;\\n            let mut min_remaining_difficulty = i32::MAX;\\n            for k in i..=n-(d-j) {\\n                day_difficulty = day_difficulty.max(job_difficulty[k]);\\n                min_remaining_difficulty = min_remaining_difficulty.min(day_difficulty.saturating_add(Self::dfs(job_difficulty, n, d, k + 1, j + 1, memo)));\\n            }\\n            memo.insert((i, j), min_remaining_difficulty);\\n            min_remaining_difficulty\\n        }\\n    }\\n\\n    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n        let d = d as usize;\\n        if d > job_difficulty.len() {\\n            -1\\n        } else {\\n            Self::dfs(&job_difficulty, job_difficulty.len(), d, 0, 0, &mut HashMap::new())\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2305626,
                "title": "very-simple-and-easy-to-understand-c-solution-using-recursion-memorization",
                "content": "<b> Up Vote if you like the solution \\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& jobd, int d, int i, vector<vector<int>>& dp){\\n        if(d <= 0 && i >= jobd.size()) return 0;\\n        if(d <= 0 || i >= jobd.size()) return 1e9;\\n        if(dp[i][d] != -1) return dp[i][d];\\n        int mx = 0, res = INT_MAX;\\n        for(int j = i; j < jobd.size(); ++j){\\n            mx = max(mx, jobd[j]);\\n            res = min(res, mx + solve(jobd, d-1, j + 1, dp));\\n        }\\n        return dp[i][d] = res;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        vector<vector<int>> dp(jobDifficulty.size()+1, vector<int> (d+1, -1));\\n        int ans = solve(jobDifficulty, d, 0, dp);  \\n        return ans<1e9?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& jobd, int d, int i, vector<vector<int>>& dp){\\n        if(d <= 0 && i >= jobd.size()) return 0;\\n        if(d <= 0 || i >= jobd.size()) return 1e9;\\n        if(dp[i][d] != -1) return dp[i][d];\\n        int mx = 0, res = INT_MAX;\\n        for(int j = i; j < jobd.size(); ++j){\\n            mx = max(mx, jobd[j]);\\n            res = min(res, mx + solve(jobd, d-1, j + 1, dp));\\n        }\\n        return dp[i][d] = res;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        vector<vector<int>> dp(jobDifficulty.size()+1, vector<int> (d+1, -1));\\n        int ans = solve(jobDifficulty, d, 0, dp);  \\n        return ans<1e9?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152830,
                "title": "bottom-up-dp-beating-95-93-in-python",
                "content": "```\\nclass Solution:\\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\\n        n = len(jobs)\\n        dp = [[inf] * (n+1) for _ in range(d+1)]\\n        dp[0][0] = 0\\n        for i in range(1, d + 1):\\n            for j in range(i, n + 1):\\n                max_job = 0\\n                for k in range(j, i-1, -1):\\n                    if max_job < jobs[k-1]:\\n                        max_job = jobs[k-1]\\n                    if dp[i-1][k-1] + max_job < dp[i][j]:\\n                        dp[i][j] = dp[i-1][k-1] + max_job\\n        return -1 if dp[d][n] == inf else dp[d][n]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\\n        n = len(jobs)\\n        dp = [[inf] * (n+1) for _ in range(d+1)]\\n        dp[0][0] = 0\\n        for i in range(1, d + 1):\\n            for j in range(i, n + 1):\\n                max_job = 0\\n                for k in range(j, i-1, -1):\\n                    if max_job < jobs[k-1]:\\n                        max_job = jobs[k-1]\\n                    if dp[i-1][k-1] + max_job < dp[i][j]:\\n                        dp[i][j] = dp[i-1][k-1] + max_job\\n        return -1 if dp[d][n] == inf else dp[d][n]",
                "codeTag": "Java"
            },
            {
                "id": 2057089,
                "title": "c-memoization-solution",
                "content": "Since the you cannot perform the next task without completing all the previous tasks, we can rephrase the problem as follows:-\\nGiven an array of integers, divide it into d sub arrays such that the sum of maximums of each subarray is minimized.\\nWe will use memoization to solve this problem as follows:-\\n\\nSubproblems: S(index,d)=The minimum sum of maximas when arr[index:] is divided into d subarrays\\n\\nRelation:S(index,d)=min{max(index,nextIndex-1)+S(nextIndex,d-1) **for all** nextIndex **in** [index+1,n)}\\n\\nBase case: S(index,d)=\\n1. INT_MAX **if** (index>=n && d!=0) || d<=0\\n2. 0 **if** index>=n && d==0\\n\\nOriginal problem: S(0,D)\\n\\nTime complexity: O(ND)xO(N)=O((N^2)D)\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int solve(vector<int>&diff,int index,int d){\\n        int n=diff.size();\\n        if(index>=n){\\n            if(d==0){\\n                return 0;\\n            } else {\\n                return INT_MAX;\\n            }\\n        } else if(d<=0){\\n            return INT_MAX;\\n        } else if(mem[index][d]!=-1){\\n            return mem[index][d];\\n        } else {\\n            int ans=INT_MAX,maxi=0;\\n            for(int next=index;next<n;next++){\\n                maxi=max(diff[next],maxi);\\n                int rec=solve(diff,next+1,d-1);\\n                if(rec!=INT_MAX){\\n                    rec+=maxi;\\n                }\\n                ans=min(ans,rec);\\n            }\\n            return mem[index][d]=ans;\\n        }\\n    }\\npublic:\\n    int minDifficulty(vector<int>& diff, int d) {\\n        int n=diff.size();\\n        if(d>n){\\n            return -1;\\n        } else {\\n            mem=vector<vector<int>>(n,vector<int>(d+1,-1));\\n            return solve(diff,0,d);\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int solve(vector<int>&diff,int index,int d){\\n        int n=diff.size();\\n        if(index>=n){\\n            if(d==0){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2026073,
                "title": "top-down-bottom-up",
                "content": "**Try All posible way return minimum**\\nMemoization:  \\n\\n```\\nclass Solution { \\npublic:\\n    int solve(vector<int>& nums,int i,int d, vector<vector<int>> &dp){\\n\\t\\tif(i==nums.size()&&d==0)\\n\\t\\t\\treturn 0;  \\n\\t\\tif(d<0||i==nums.size()) return 1e7;\\n\\t\\tif(dp[i][d]!=-1) return dp[i][d];  \\n\\t\\t\\t\\n\\t\\t\\tint ans=1e7;\\n\\t\\t\\tint mn=INT_MIN;\\n\\t\\t\\tfor(int j=i;j<nums.size();j++){\\n\\t\\t\\t\\t  mn=max(mn,nums[j]); \\n\\t\\t\\t\\t  ans=min(ans,mn+solve(nums,j+1,d-1,dp));\\n\\t\\t\\t }\\n\\t\\t\\t \\n\\t\\treturn dp[i][d]=ans;\\n        }\\n    int minDifficulty(vector<int>& nums, int d) {\\n       int n=nums.size();\\n       vector<vector<int>> dp(n, vector<int> (d+1,-1));\\n       int ans=solve(nums,0,d,dp);\\n       return ans>=1e7?-1:ans;\\n    }\\n}; \\n``` \\n\\nTabulation \\n**CONVERTING IT TO TABULATION (credit-striver)** \\n\\n\\t\\tfollowing steps involve in coverting memoization into tabulation\\n\\t\\t1.Declare same size storage and intialise base case.\\n\\t\\t2.Observe changing paremeter (i,d) i->0,1,2,3,4,5, d->d,d-1,d-2, , , ,  1\\n\\t\\t3.write down the loop of changing parameter in reverse order of change i.e for i and d.\\n\\t\\t4.Copy the recusion.  \\n\\n```\\nclass Solution { \\n    //tabulation\\npublic:\\n    int minDifficulty(vector<int>& nums, int D) {\\n         int n=nums.size();\\n         vector<vector<int>> dp(n+1, vector<int> (D+1,1e7)); \\n         dp[n][0]=0; \\n        \\n            for(int i=n;i>=0;i--){ \\n              for(int d=1;d<=D;d++){\\n                     int ans=1e7;\\n                     int mn=INT_MIN;\\n                       for(int j=i;j<nums.size();j++){\\n                              mn=max(mn,nums[j]);  \\n                              ans=min(ans,mn+dp[j+1][d-1]);\\n                        } \\n                      dp[i][d]=ans;\\n                }\\n             }\\n         return dp[0][D]>=1e7?-1:dp[0][D];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    int solve(vector<int>& nums,int i,int d, vector<vector<int>> &dp){\\n\\t\\tif(i==nums.size()&&d==0)\\n\\t\\t\\treturn 0;  \\n\\t\\tif(d<0||i==nums.size()) return 1e7;\\n\\t\\tif(dp[i][d]!=-1) return dp[i][d];  \\n\\t\\t\\t\\n\\t\\t\\tint ans=1e7;\\n\\t\\t\\tint mn=INT_MIN;\\n\\t\\t\\tfor(int j=i;j<nums.size();j++){\\n\\t\\t\\t\\t  mn=max(mn,nums[j]); \\n\\t\\t\\t\\t  ans=min(ans,mn+solve(nums,j+1,d-1,dp));\\n\\t\\t\\t }\\n\\t\\t\\t \\n\\t\\treturn dp[i][d]=ans;\\n        }\\n    int minDifficulty(vector<int>& nums, int d) {\\n       int n=nums.size();\\n       vector<vector<int>> dp(n, vector<int> (d+1,-1));\\n       int ans=solve(nums,0,d,dp);\\n       return ans>=1e7?-1:ans;\\n    }\\n}; \\n```\n```\\nclass Solution { \\n    //tabulation\\npublic:\\n    int minDifficulty(vector<int>& nums, int D) {\\n         int n=nums.size();\\n         vector<vector<int>> dp(n+1, vector<int> (D+1,1e7)); \\n         dp[n][0]=0; \\n        \\n            for(int i=n;i>=0;i--){ \\n              for(int d=1;d<=D;d++){\\n                     int ans=1e7;\\n                     int mn=INT_MIN;\\n                       for(int j=i;j<nums.size();j++){\\n                              mn=max(mn,nums[j]);  \\n                              ans=min(ans,mn+dp[j+1][d-1]);\\n                        } \\n                      dp[i][d]=ans;\\n                }\\n             }\\n         return dp[0][D]>=1e7?-1:dp[0][D];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946366,
                "title": "java-solution-with-question-simplification",
                "content": "The question seemed to be too difficult because it took me long to understand the question, so I have simplified the question;\\nQ.Cut array into d subarrays with min of 1 element and calculate the sum of max of each subarray and return the minimum of such sum possible.\\n\\nSo the idea is to check all possible combinations.\\nWe do it using depth first search where we calculate the minimum sum which can be generated from indx pos by making d cuts.\\n ![image](https://assets.leetcode.com/users/images/a18f63ad-7088-44cb-a883-8ab4cdf85c71_1649938049.0994859.jpeg)\\n\\nCode:\\n```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if(jobDifficulty.length<d) return -1;\\n        int dp[][] = new int[d+1][jobDifficulty.length];\\n        for(int[] p:dp) Arrays.fill(p, -1);\\n        return dfs(jobDifficulty, dp, d, 0);\\n    }\\n    public int dfs(int[] jobDifficulty, int[][] dp, int d, int indx){\\n        if(d==1){\\n            int max = 0;\\n            while(indx<jobDifficulty.length) max=Math.max(max, jobDifficulty[indx++]);\\n            return max;\\n        }\\n        if(dp[d][indx]!=-1) return dp[d][indx];\\n        int max=0, res=Integer.MAX_VALUE;\\n        for(int i=indx; i<jobDifficulty.length-d+1; i++){\\n            max=Math.max(max, jobDifficulty[i]);\\n            res=Math.min(res, max+dfs(jobDifficulty, dp, d-1, i+1));\\n        }\\n        return dp[d][indx]=res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        if(jobDifficulty.length<d) return -1;\\n        int dp[][] = new int[d+1][jobDifficulty.length];\\n        for(int[] p:dp) Arrays.fill(p, -1);\\n        return dfs(jobDifficulty, dp, d, 0);\\n    }\\n    public int dfs(int[] jobDifficulty, int[][] dp, int d, int indx){\\n        if(d==1){\\n            int max = 0;\\n            while(indx<jobDifficulty.length) max=Math.max(max, jobDifficulty[indx++]);\\n            return max;\\n        }\\n        if(dp[d][indx]!=-1) return dp[d][indx];\\n        int max=0, res=Integer.MAX_VALUE;\\n        for(int i=indx; i<jobDifficulty.length-d+1; i++){\\n            max=Math.max(max, jobDifficulty[i]);\\n            res=Math.min(res, max+dfs(jobDifficulty, dp, d-1, i+1));\\n        }\\n        return dp[d][indx]=res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849407,
                "title": "java-dp-memoization",
                "content": "```\\nclass Solution {\\n    Integer [][]dp;\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        dp = new Integer[jobDifficulty.length][d + 1];\\n        return minDifficulty(jobDifficulty, 0, d);\\n    }\\n    \\n    public int minDifficulty(int[] jobs, int index, int d) {\\n        \\n        if(d <= 0 || index >= jobs.length)\\n            return -1;\\n        \\n        if(dp[index][d] != null)\\n            return dp[index][d];\\n        \\n        int maxDayDifficulty = 0;\\n        int minDifficulty = Integer.MAX_VALUE;\\n        \\n        for(int i = index; i <= jobs.length - d; i++) {\\n            maxDayDifficulty = Math.max(maxDayDifficulty, jobs[i]);\\n            int value = minDifficulty(jobs, i + 1, d - 1);\\n            if(value != -1)\\n                minDifficulty = Math.min(minDifficulty, maxDayDifficulty + value);\\n        }\\n        \\n        if(d == 1)\\n            return maxDayDifficulty;\\n       \\n        \\n        dp[index][d] = minDifficulty == Integer.MAX_VALUE? -1:  minDifficulty;\\n        return dp[index][d];\\n    }\\n}\\n\\n\\n\\n/*\\n\\nfunc(arr, d,  index)\\n\\nif(d == 0)\\n     return -1\\n\\nint maxCurentDay = 0;\\nint currentMin = integer high value\\n\\nif(dp[i][d] != null)\\n    return dp[i][d];\\n\\nfor(i = index; i <= arr.length - d; i++)\\n    maxCurentDay = Math.max(maxCurentDay, arr[i]);\\n    currentMax = Math.min(currentMax, func(arr, d - 1, i + 1) + maxCurentDay)\\n    \\n\\ndp[i][d] = currentMin;\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer [][]dp;\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        dp = new Integer[jobDifficulty.length][d + 1];\\n        return minDifficulty(jobDifficulty, 0, d);\\n    }\\n    \\n    public int minDifficulty(int[] jobs, int index, int d) {\\n        \\n        if(d <= 0 || index >= jobs.length)\\n            return -1;\\n        \\n        if(dp[index][d] != null)\\n            return dp[index][d];\\n        \\n        int maxDayDifficulty = 0;\\n        int minDifficulty = Integer.MAX_VALUE;\\n        \\n        for(int i = index; i <= jobs.length - d; i++) {\\n            maxDayDifficulty = Math.max(maxDayDifficulty, jobs[i]);\\n            int value = minDifficulty(jobs, i + 1, d - 1);\\n            if(value != -1)\\n                minDifficulty = Math.min(minDifficulty, maxDayDifficulty + value);\\n        }\\n        \\n        if(d == 1)\\n            return maxDayDifficulty;\\n       \\n        \\n        dp[index][d] = minDifficulty == Integer.MAX_VALUE? -1:  minDifficulty;\\n        return dp[index][d];\\n    }\\n}\\n\\n\\n\\n/*\\n\\nfunc(arr, d,  index)\\n\\nif(d == 0)\\n     return -1\\n\\nint maxCurentDay = 0;\\nint currentMin = integer high value\\n\\nif(dp[i][d] != null)\\n    return dp[i][d];\\n\\nfor(i = index; i <= arr.length - d; i++)\\n    maxCurentDay = Math.max(maxCurentDay, arr[i]);\\n    currentMax = Math.min(currentMax, func(arr, d - 1, i + 1) + maxCurentDay)\\n    \\n\\ndp[i][d] = currentMin;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820653,
                "title": "java-dp-bottom-up-solution-with-easy-to-under-explanation",
                "content": "\\n```\\n /**\\n     *\\n     *\\n     *\\n\\t *  Say that we have n jobs to finish in d days\\n     * 1. for the first day we can finish 1 job to the n-(d-1) th jobs ( set the last job be finished as lastJobIn1 job)\\n     * 2. for the second day we can finish lastJobIn1+1 job to the n - (d-2) th jobs ( set the last job be finished as lastJobIn2 job)\\n     * 3. for the dth day, we can finish lastJobIn{d-1} +1 job to the n th job\\n     *\\n     *\\n     *  use the dp formula: we need to find the state and the function\\n     *  from above, can see the states are the day `start_day`  and the job we start from that day `start_job`\\n     *  the function dp(start_day,start_job) will represent the total_diff start for `start_day`, start from job `start_job` \\n     *  \\n     *\\n\\t *      dp(1,0) will be the result to the question\\n     *      dp(1,0) = hardest_job_in_day1 + dp(2, start_job_day_2);\\n     *\\n     *      --> actually there is a hidden state, job we finish on that day end_job\\n     *      start_job_day = end_jod_previous_day + 1\\n     *     \\n     *   we can get `total_diff = hardest job of the day + total_diff of the rest days`\\n     *   so our base case is the last day\\n     *\\n     *   because we need to finish at least one job per day:\\n     *   so the maximum job number we can finish in one day is `maxJobsOneDay` = totalJobs -d +1\\n     *\\n     *   we set up a diff_map : ith element in the map stores the min total_diff start from the ith job\\n     *\\n     *   we treat as we do the job with the revers order\\n     *\\n     *   in the last day:\\n     *      we have to finish the last job\\n     *      we at least start last job,\\n     *      at most can start from `maxStartJobIndex` =totalJobs-1-maxJobsOneDay th job\\n     *       so we can easily get the base value of our diff_map[last_job] back to diff_map[maxStartJobIndex]\\n     *\\n     *   after the last day, the logic is sightly different:\\n     *      because for last day, we have the finish the last job.\\n     *      but for the other days, we don\\'t have the job that we have to finish\\n     *      but we have job range\\n     *   for the day before the last day:\\n     *      we have left at least one job for last day\\n     *      so the `maxEndJobIndex` = (totalJobs-1) - 1\\n     *      at most can start from `maxStartJobIndex` =maxEndJobIndex-maxJobsOneDay+1 th job\\n     *      the job range is `maxStartJobIndex` to `maxEndJobIndex`\\n     *\\n     *      so startJobIndex will between maxStartJobIndex and maxEndJobIndex;\\n     *      and endJobIndex will between startJobIndex and maxEndJobIndex;\\n     *\\n     *\\n     *       total_diff = hardest job of the day + total_diff of the rest days\\n     *       for part1, hardest job of the day we can get\\n     *       for part2, total_diff of jobs start from endJobIndex+1 we get from last day, which we stored in diff_map\\n     *       so we can get the total_diff for\\n     *          1. doing startJobIndex-endJobIndex in day before last day\\n     *          2. doing endJobIndex - lastJob in the last day\\n     *\\n     *       we loop the job range, and update `min total_diff start from ith job` in diff_map\\n     *\\n     *  --------------------------------------------------------------------------------------------\\n     *\\n     *    So we can have the logic for the question:\\n     *      1. as our base is the final day, we treat the question as we do the job backward,\\n     *          and build up the diff for the first day\\n     *      2. we have a diff_map, for ith element, it stores the min total_diff start from ith job\\n     *          and we will update it when each day pass\\n     *      3. each day we have a range of job we can do\\n     *      4. calculate the last day total_diff within the job range --> base case\\n     *      5. from day(d-1) to day(1)\\n     *          get the job range for that day\\n     *          for( startIndex : maxStartIndex to maxEndIndex)\\n     *              reset diff_map[startIndex]\\n     *              for(endIndex: startIndex to maxEndIndex)\\n     *                  total_diff = hardest job of the day + total_diff of the rest days\\n     *                  total_diff of the rest days = diff_map[endIndex+1]\\n     *\\n     *       one think need to pay attention, is that we have to go back day by day till day 1\\n     *       so, even if we have smaller value in diff_map from the previous day, we cannot use it.\\n     *       therefore, we have to reset the diff_map[startIndex] in each day\\n     *\\n     *       also before we move the startIndex from smallest to largest,\\n     *       the startIndex we need from previous day will be at least startIndex+1\\n     *       so we can reset the diff_map[startIndex]\\n     *\\n     *\\n     */\\n\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int totalJobs = jobDifficulty.length;\\n        if(totalJobs < d) return -1;\\n\\n        int maxJobsOneDay = totalJobs -d +1;\\n        int[] map = new int[totalJobs];\\n\\n        int maxDiff = Integer.MIN_VALUE;\\n        for(int k = totalJobs-1; k > totalJobs-1-maxJobsOneDay; k--){\\n            maxDiff = Math.max(maxDiff, jobDifficulty[k]);\\n            map[k] = maxDiff;\\n        }\\n\\n        for(int day = d-1 ; day > 0; day--){\\n\\n            int maxEndIndex = (totalJobs-1)-(d -day);\\n            int maxStartIndex = maxEndIndex- maxJobsOneDay +1;\\n\\n            for(int startIndex = maxStartIndex; startIndex <= maxEndIndex; startIndex++){\\n                map[startIndex] = Integer.MAX_VALUE;\\n                int maxDiffOfTheDay = Integer.MIN_VALUE;\\n                for(int endIndex = startIndex; endIndex <= maxEndIndex; endIndex++){\\n                    maxDiffOfTheDay = Math.max(maxDiffOfTheDay, jobDifficulty[endIndex]);\\n\\n                    int totalDiff = maxDiffOfTheDay + map[endIndex+1];\\n\\n                    map[startIndex] = Math.min(map[startIndex], totalDiff);\\n                }\\n            }\\n\\n        }\\n\\n        return map[0];\\n\\n    }\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\n```\\n /**\\n     *\\n     *\\n     *\\n\\t *  Say that we have n jobs to finish in d days\\n     * 1. for the first day we can finish 1 job to the n-(d-1) th jobs ( set the last job be finished as lastJobIn1 job)\\n     * 2. for the second day we can finish lastJobIn1+1 job to the n - (d-2) th jobs ( set the last job be finished as lastJobIn2 job)\\n     * 3. for the dth day, we can finish lastJobIn{d-1} +1 job to the n th job\\n     *\\n     *\\n     *  use the dp formula: we need to find the state and the function\\n     *  from above, can see the states are the day `start_day`  and the job we start from that day `start_job`\\n     *  the function dp(start_day,start_job) will represent the total_diff start for `start_day`, start from job `start_job` \\n     *  \\n     *\\n\\t *      dp(1,0) will be the result to the question\\n     *      dp(1,0) = hardest_job_in_day1 + dp(2, start_job_day_2);\\n     *\\n     *      --> actually there is a hidden state, job we finish on that day end_job\\n     *      start_job_day = end_jod_previous_day + 1\\n     *     \\n     *   we can get `total_diff = hardest job of the day + total_diff of the rest days`\\n     *   so our base case is the last day\\n     *\\n     *   because we need to finish at least one job per day:\\n     *   so the maximum job number we can finish in one day is `maxJobsOneDay` = totalJobs -d +1\\n     *\\n     *   we set up a diff_map : ith element in the map stores the min total_diff start from the ith job\\n     *\\n     *   we treat as we do the job with the revers order\\n     *\\n     *   in the last day:\\n     *      we have to finish the last job\\n     *      we at least start last job,\\n     *      at most can start from `maxStartJobIndex` =totalJobs-1-maxJobsOneDay th job\\n     *       so we can easily get the base value of our diff_map[last_job] back to diff_map[maxStartJobIndex]\\n     *\\n     *   after the last day, the logic is sightly different:\\n     *      because for last day, we have the finish the last job.\\n     *      but for the other days, we don\\'t have the job that we have to finish\\n     *      but we have job range\\n     *   for the day before the last day:\\n     *      we have left at least one job for last day\\n     *      so the `maxEndJobIndex` = (totalJobs-1) - 1\\n     *      at most can start from `maxStartJobIndex` =maxEndJobIndex-maxJobsOneDay+1 th job\\n     *      the job range is `maxStartJobIndex` to `maxEndJobIndex`\\n     *\\n     *      so startJobIndex will between maxStartJobIndex and maxEndJobIndex;\\n     *      and endJobIndex will between startJobIndex and maxEndJobIndex;\\n     *\\n     *\\n     *       total_diff = hardest job of the day + total_diff of the rest days\\n     *       for part1, hardest job of the day we can get\\n     *       for part2, total_diff of jobs start from endJobIndex+1 we get from last day, which we stored in diff_map\\n     *       so we can get the total_diff for\\n     *          1. doing startJobIndex-endJobIndex in day before last day\\n     *          2. doing endJobIndex - lastJob in the last day\\n     *\\n     *       we loop the job range, and update `min total_diff start from ith job` in diff_map\\n     *\\n     *  --------------------------------------------------------------------------------------------\\n     *\\n     *    So we can have the logic for the question:\\n     *      1. as our base is the final day, we treat the question as we do the job backward,\\n     *          and build up the diff for the first day\\n     *      2. we have a diff_map, for ith element, it stores the min total_diff start from ith job\\n     *          and we will update it when each day pass\\n     *      3. each day we have a range of job we can do\\n     *      4. calculate the last day total_diff within the job range --> base case\\n     *      5. from day(d-1) to day(1)\\n     *          get the job range for that day\\n     *          for( startIndex : maxStartIndex to maxEndIndex)\\n     *              reset diff_map[startIndex]\\n     *              for(endIndex: startIndex to maxEndIndex)\\n     *                  total_diff = hardest job of the day + total_diff of the rest days\\n     *                  total_diff of the rest days = diff_map[endIndex+1]\\n     *\\n     *       one think need to pay attention, is that we have to go back day by day till day 1\\n     *       so, even if we have smaller value in diff_map from the previous day, we cannot use it.\\n     *       therefore, we have to reset the diff_map[startIndex] in each day\\n     *\\n     *       also before we move the startIndex from smallest to largest,\\n     *       the startIndex we need from previous day will be at least startIndex+1\\n     *       so we can reset the diff_map[startIndex]\\n     *\\n     *\\n     */\\n\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int totalJobs = jobDifficulty.length;\\n        if(totalJobs < d) return -1;\\n\\n        int maxJobsOneDay = totalJobs -d +1;\\n        int[] map = new int[totalJobs];\\n\\n        int maxDiff = Integer.MIN_VALUE;\\n        for(int k = totalJobs-1; k > totalJobs-1-maxJobsOneDay; k--){\\n            maxDiff = Math.max(maxDiff, jobDifficulty[k]);\\n            map[k] = maxDiff;\\n        }\\n\\n        for(int day = d-1 ; day > 0; day--){\\n\\n            int maxEndIndex = (totalJobs-1)-(d -day);\\n            int maxStartIndex = maxEndIndex- maxJobsOneDay +1;\\n\\n            for(int startIndex = maxStartIndex; startIndex <= maxEndIndex; startIndex++){\\n                map[startIndex] = Integer.MAX_VALUE;\\n                int maxDiffOfTheDay = Integer.MIN_VALUE;\\n                for(int endIndex = startIndex; endIndex <= maxEndIndex; endIndex++){\\n                    maxDiffOfTheDay = Math.max(maxDiffOfTheDay, jobDifficulty[endIndex]);\\n\\n                    int totalDiff = maxDiffOfTheDay + map[endIndex+1];\\n\\n                    map[startIndex] = Math.min(map[startIndex], totalDiff);\\n                }\\n            }\\n\\n        }\\n\\n        return map[0];\\n\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1738311,
                "title": "c-bottom-up-dp-solution-easy-to-understand-with-comments",
                "content": "Time complexity : O(d*(n - d)^2)\\nSpace Complexity: O(n*d)\\n```\\npublic class Solution {\\n    public int MinDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.Length;\\n        //Boundary check\\n        if (d > n)\\n            return -1;\\n        //Initialize DP matrix to store state variables i = current job index & day = current day from d days\\n        int[,] dp = new int[n, d+1];\\n        \\n        //Fill entire DP array with Int.Max value\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < d +1; j++){\\n                dp[i,j] = int.MaxValue;\\n            }\\n        }\\n        \\n        //Base Case where Last job has to be scheduled on Last Day\\n        dp[n-1, d] = jobDifficulty[n-1];\\n        \\n        //All the jobs should have been scheduled on Last Day\\n        //Fill day d and identify Max JobDifficulty job to be scheduled on last day d\\n        for(int i = n - 2; i >= 0; i--)\\n            dp[i, d] = Math.Max(dp[i + 1, d], jobDifficulty[i]);\\n        \\n        //Start to iterate through all the remaining days and calculate minimum job difficulty of job schedule\\n        for(int day = d - 1; day > 0; day--){\\n            //No need to calculate dp[0,1], dp[0,2] or dp[1,2] as each day minimum 1 job has to be scheduled and so start iterating from day - 1\\n            //Maximum job to be scheduled each day is n - (d - day)\\n            for(int i = day - 1; i < n - (d - day); i++){\\n                //Capture hardest job to schedule on current day to calculate maximum job schedule difficulty for current day\\n                int hardest = 0;\\n                //Iterate each possible job to schedule on current day\\n                for(int j = i; j < n - (d - day); j ++){\\n\\t\\t\\t\\t\\t//Calculate hardest job to schedule for given day against previously scheduled jobs for current day\\n                    hardest = Math.Max(hardest, jobDifficulty[j]);\\n\\t\\t\\t\\t\\t//Schedule current job i on given day with minimum job difficulty\\n                    dp[i, day] = Math.Min(dp[i,day], hardest + dp[j+1, day + 1]);\\n                }\\n            }\\n        }\\n        return dp[0, 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.Length;\\n        //Boundary check\\n        if (d > n)\\n            return -1;\\n        //Initialize DP matrix to store state variables i = current job index & day = current day from d days\\n        int[,] dp = new int[n, d+1];\\n        \\n        //Fill entire DP array with Int.Max value\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < d +1; j++){\\n                dp[i,j] = int.MaxValue;\\n            }\\n        }\\n        \\n        //Base Case where Last job has to be scheduled on Last Day\\n        dp[n-1, d] = jobDifficulty[n-1];\\n        \\n        //All the jobs should have been scheduled on Last Day\\n        //Fill day d and identify Max JobDifficulty job to be scheduled on last day d\\n        for(int i = n - 2; i >= 0; i--)\\n            dp[i, d] = Math.Max(dp[i + 1, d], jobDifficulty[i]);\\n        \\n        //Start to iterate through all the remaining days and calculate minimum job difficulty of job schedule\\n        for(int day = d - 1; day > 0; day--){\\n            //No need to calculate dp[0,1], dp[0,2] or dp[1,2] as each day minimum 1 job has to be scheduled and so start iterating from day - 1\\n            //Maximum job to be scheduled each day is n - (d - day)\\n            for(int i = day - 1; i < n - (d - day); i++){\\n                //Capture hardest job to schedule on current day to calculate maximum job schedule difficulty for current day\\n                int hardest = 0;\\n                //Iterate each possible job to schedule on current day\\n                for(int j = i; j < n - (d - day); j ++){\\n\\t\\t\\t\\t\\t//Calculate hardest job to schedule for given day against previously scheduled jobs for current day\\n                    hardest = Math.Max(hardest, jobDifficulty[j]);\\n\\t\\t\\t\\t\\t//Schedule current job i on given day with minimum job difficulty\\n                    dp[i, day] = Math.Min(dp[i,day], hardest + dp[j+1, day + 1]);\\n                }\\n            }\\n        }\\n        return dp[0, 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353798,
                "title": "easiest-python-dp-solution-with-detailed-explanation",
                "content": "```\\nfrom typing import List \\n\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        dp = [[-1] * len(jobDifficulty) for _ in range(d + 1)]\\n        \\n        # Edge Case.\\n        if len(jobDifficulty) < d:\\n            return -1\\n\\n        def dfs(jd, d, dp, i):\\n\\n            # When you have only OneDay left.\\n            # You have no choice but to do all tasks on that day.\\n            # So the difficulty value for that day will be max diffculty of the remaining tasks.\\n            if d == 1:\\n                return max(jd[i:])\\n            \\n            # If we already have the result in DP, just return that.\\n            if dp[d][i] != -1:\\n                return dp[d][i]\\n            \\n            # Lets make a cut at each point in the array and calculate the result.\\n            # Will keep a variable called result which will be updated with minimum result value.\\n            max_jd = 0\\n            res = float(\"inf\")\\n\\n            for jdi in range(i, len(jd) - d + 1):\\n                max_jd = max(max_jd, jd[jdi])\\n                # Just imagine without recursion here.\\n                # This is our first cut. \\n                # Where we just split the array from first position, so the difficulty will obiviously be that value. \\n                # Imagine without recursion here. \\n                # We took the first value from jd list. \\n                # The result will be sum of that + result from rest of the jd list and remaining days.\\n                # So, we just do exactly that. We have one day less ( d -1 ) and one item less to look at ( ie, start looking from the next index for the next iteration - So, it is jdi + 1 )\\n                \\n                res = min(res, max_jd + dfs(jd, d - 1, dp, jdi + 1))\\n            \\n            dp[d][i] = res\\n\\n            return dp[d][i]\\n\\n        result = dfs(jobDifficulty, d, dp, 0)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List \\n\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        dp = [[-1] * len(jobDifficulty) for _ in range(d + 1)]\\n        \\n        # Edge Case.\\n        if len(jobDifficulty) < d:\\n            return -1\\n\\n        def dfs(jd, d, dp, i):\\n\\n            # When you have only OneDay left.\\n            # You have no choice but to do all tasks on that day.\\n            # So the difficulty value for that day will be max diffculty of the remaining tasks.\\n            if d == 1:\\n                return max(jd[i:])\\n            \\n            # If we already have the result in DP, just return that.\\n            if dp[d][i] != -1:\\n                return dp[d][i]\\n            \\n            # Lets make a cut at each point in the array and calculate the result.\\n            # Will keep a variable called result which will be updated with minimum result value.\\n            max_jd = 0\\n            res = float(\"inf\")\\n\\n            for jdi in range(i, len(jd) - d + 1):\\n                max_jd = max(max_jd, jd[jdi])\\n                # Just imagine without recursion here.\\n                # This is our first cut. \\n                # Where we just split the array from first position, so the difficulty will obiviously be that value. \\n                # Imagine without recursion here. \\n                # We took the first value from jd list. \\n                # The result will be sum of that + result from rest of the jd list and remaining days.\\n                # So, we just do exactly that. We have one day less ( d -1 ) and one item less to look at ( ie, start looking from the next index for the next iteration - So, it is jdi + 1 )\\n                \\n                res = min(res, max_jd + dfs(jd, d - 1, dp, jdi + 1))\\n            \\n            dp[d][i] = res\\n\\n            return dp[d][i]\\n\\n        result = dfs(jobDifficulty, d, dp, 0)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318924,
                "title": "python-dp",
                "content": "1. Recursion, Memoization\\n\\n```\\nclass Solution:\\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\t\\tn = len(jobDifficulty)\\n\\t\\t@lru_cache(None)\\n\\t\\tdef helper(index, day, max_difficulty):\\n\\t\\t\\tif index == n - 1:\\n\\t\\t\\t\\treturn max_difficulty if day == d else float(\\'inf\\')\\n\\t\\t\\tif day > d:\\n\\t\\t\\t\\treturn float(\\'inf\\')\\n\\t\\n\\t\\t\\tres = min(max_difficulty + helper(index + 1, day + 1, jobDifficulty[index + 1]), helper(index + 1, day, max(max_difficulty, jobDifficulty[index + 1])))\\n\\t\\t\\treturn res\\n\\t\\tans = helper(0, 1, jobDifficulty[0])\\n\\t\\treturn ans if ans != float(\\'inf\\') else -1\\t\\n\\n```\\n\\n2. DP, bottom up \\n```\\nclass Solution:\\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\t\\tn = len(jobDifficulty)\\n\\t\\tdp = [[float(\\'inf\\')] * n for _ in range(d)]\\n\\t\\tdp[0][0] = jobDifficulty[0]\\n\\t\\tfor i in range(1, n):\\n\\t\\t\\tdp[0][i] = max(jobDifficulty[i], dp[0][i - 1])\\n\\t\\t\\n\\t\\tfor i in range(1, d):\\n\\t\\t\\tfor j in range(i, n):\\n\\t\\t\\t\\tmax_diff = 0\\n\\t\\t\\t\\tfor k in range(j, i - 1, -1):\\n\\t\\t\\t\\t\\tmax_diff = max(jobDifficulty[k], max_diff)\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i - 1][k - 1] + max_diff)\\n\\t\\treturn dp[-1][-1] if dp[-1][-1] != float(\\'inf\\') else -1\\t\\t\\n\\t\\t\\t\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\t\\tn = len(jobDifficulty)\\n\\t\\t@lru_cache(None)\\n\\t\\tdef helper(index, day, max_difficulty):\\n\\t\\t\\tif index == n - 1:\\n\\t\\t\\t\\treturn max_difficulty if day == d else float(\\'inf\\')\\n\\t\\t\\tif day > d:\\n\\t\\t\\t\\treturn float(\\'inf\\')\\n\\t\\n\\t\\t\\tres = min(max_difficulty + helper(index + 1, day + 1, jobDifficulty[index + 1]), helper(index + 1, day, max(max_difficulty, jobDifficulty[index + 1])))\\n\\t\\t\\treturn res\\n\\t\\tans = helper(0, 1, jobDifficulty[0])\\n\\t\\treturn ans if ans != float(\\'inf\\') else -1\\t\\n\\n```\n```\\nclass Solution:\\n\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\t\\tn = len(jobDifficulty)\\n\\t\\tdp = [[float(\\'inf\\')] * n for _ in range(d)]\\n\\t\\tdp[0][0] = jobDifficulty[0]\\n\\t\\tfor i in range(1, n):\\n\\t\\t\\tdp[0][i] = max(jobDifficulty[i], dp[0][i - 1])\\n\\t\\t\\n\\t\\tfor i in range(1, d):\\n\\t\\t\\tfor j in range(i, n):\\n\\t\\t\\t\\tmax_diff = 0\\n\\t\\t\\t\\tfor k in range(j, i - 1, -1):\\n\\t\\t\\t\\t\\tmax_diff = max(jobDifficulty[k], max_diff)\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i - 1][k - 1] + max_diff)\\n\\t\\treturn dp[-1][-1] if dp[-1][-1] != float(\\'inf\\') else -1\\t\\t\\n\\t\\t\\t\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317581,
                "title": "java-94-cut-type",
                "content": "\\tpublic int minDifficulty(int[] job, int d) {\\n\\t\\t\\tint len=job.length;\\n\\t\\t\\tif(d>len)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t\\n\\t\\t\\tint[][] dp=new int[d][len];\\n\\t\\t\\tint max=Integer.MIN_VALUE;\\n\\t\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<d;i++){\\n\\t\\t\\t\\tfor(int j=i;j<len;j++){\\n\\t\\t\\t\\t\\tif(i==0){\\n\\t\\t\\t\\t\\t   max=Math.max(max,job[j]);\\n\\t\\t\\t\\t\\t\\tdp[i][j]=max;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tmax=Integer.MIN_VALUE;\\n\\t\\t\\t\\t\\t\\tmin=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\tfor(int cut=j;cut>=i;cut--){\\n\\t\\t\\t\\t\\t\\t\\tmax=Math.max(max,job[cut]);\\n\\t\\t\\t\\t\\t\\t\\tmin=Math.min(min,max+dp[i-1][cut-1]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdp[i][j]=min;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[d-1][len-1];\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int minDifficulty(int[] job, int d) {\\n\\t\\t\\tint len=job.length;\\n\\t\\t\\tif(d>len)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t\\n\\t\\t\\tint[][] dp=new int[d][len];\\n\\t\\t\\tint max=Integer.MIN_VALUE;\\n\\t\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<d;i++){\\n\\t\\t\\t\\tfor(int j=i;j<len;j++){\\n\\t\\t\\t\\t\\tif(i==0){\\n\\t\\t\\t\\t\\t   max=Math.max(max,job[j]);\\n\\t\\t\\t\\t\\t\\tdp[i][j]=max;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tmax=Integer.MIN_VALUE;\\n\\t\\t\\t\\t\\t\\tmin=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\tfor(int cut=j;cut>=i;cut--){\\n\\t\\t\\t\\t\\t\\t\\tmax=Math.max(max,job[cut]);\\n\\t\\t\\t\\t\\t\\t\\tmin=Math.min(min,max+dp[i-1][cut-1]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdp[i][j]=min;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[d-1][len-1];\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1137473,
                "title": "simple-cpp-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if(d > jobDifficulty.size()) return -1;\\n        vector<vector<int>> dp(d,vector<int>(jobDifficulty.size(),INT_MAX));\\n        dp[0][0] = jobDifficulty[0];\\n        //best you can do at 1 day with i jobs\\n        for(int i=1;i<jobDifficulty.size();i++) dp[0][i] = max(dp[0][i-1], jobDifficulty[i]);\\n        \\n        //best you can do for days=2 to number of days and array of len l\\n        for(int i=1;i<d;i++){\\n            for(int l=i;l<jobDifficulty.size();l++){\\n                int lmax = jobDifficulty[l];\\n                for(int k=l; k>=i; k--){\\n                    lmax = max(lmax, jobDifficulty[k]);\\n                    dp[i][l] = min(dp[i-1][k-1]+lmax,dp[i][l]);\\n                }\\n            }\\n        }\\n        return dp[d-1][jobDifficulty.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        if(d > jobDifficulty.size()) return -1;\\n        vector<vector<int>> dp(d,vector<int>(jobDifficulty.size(),INT_MAX));\\n        dp[0][0] = jobDifficulty[0];\\n        //best you can do at 1 day with i jobs\\n        for(int i=1;i<jobDifficulty.size();i++) dp[0][i] = max(dp[0][i-1], jobDifficulty[i]);\\n        \\n        //best you can do for days=2 to number of days and array of len l\\n        for(int i=1;i<d;i++){\\n            for(int l=i;l<jobDifficulty.size();l++){\\n                int lmax = jobDifficulty[l];\\n                for(int k=l; k>=i; k--){\\n                    lmax = max(lmax, jobDifficulty[k]);\\n                    dp[i][l] = min(dp[i-1][k-1]+lmax,dp[i][l]);\\n                }\\n            }\\n        }\\n        return dp[d-1][jobDifficulty.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125501,
                "title": "python-dp-solution-with-clear-explanation",
                "content": "```\\nclass Solution:\\n  def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n    if d > len(jobDifficulty):\\n      return -1\\n    \\n    # index starts from zero.\\n    # d[i][j]: the minimum job difficulty after i-th cut,\\n    # range within the first j+1 jobs (job at index j)\\n    # totally need to make d-1 cuts, and range within all\\n    # of the len(jobDifficulty) jobs.\\n    \\n    dp = {}\\n    \\n    # initialization\\n    running_max = 0\\n    for k in range(len(jobDifficulty)):\\n      running_max = max(running_max, jobDifficulty[k])\\n      dp[(0, k)] = running_max\\n\\n    # obtain dp[i][j]\\n    for i in range(1, d):\\n      # the i-th cut is at least after the i-th element,\\n      # since each day at least one job has to be scheduled.\\n      # all days can be included in the last day of the current\\n      # schedule, so j is in range(i, length_of_jobs)\\n      for j in range(i, len(jobDifficulty)):\\n        # to obtain dp[i][j], we need to find out all possibilities\\n        # to schedule i+1 days (i cuts) within the first j+1 jobs.\\n        # since we already know dp[i-1][k] for all k, it suffices\\n        # to take the minimum of all \\n        # (dp[i-1][k-1] + max(jobDifficulty[k:j+1])) for i <= k <= j\\n        running_max = 0\\n        # running_min\\n        dp[(i,j)] = 2**16\\n        for k in range(j, i-1, -1):\\n          running_max = max(running_max, jobDifficulty[k])\\n          dp[(i, j)] = min(dp[(i, j)], dp[(i-1, k-1)] + running_max)\\n          \\n          \\n    return dp[(d-1, len(jobDifficulty)-1)]\\n",
                "solutionTags": [],
                "code": "class Solution:\\n  def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n    if d > len(jobDifficulty):\\n      return -1\\n    \\n    # index starts from zero.\\n    # d[i][j]: the minimum job difficulty after i-th cut,\\n    # range within the first j+1 jobs (job at index j)\\n    # totally need to make d-1 cuts, and range within all\\n    # of the len(jobDifficulty) jobs.\\n    \\n    dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 1119790,
                "title": "go-golang-solution-with-memoization",
                "content": "```\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc helper(jobDifficulty []int, d int, start int, memo [][]int) int {\\n    \\n    maxVal := 0\\n    \\n    if memo[d][start] != -1 {\\n        return memo[d][start]\\n    }\\n    \\n    if d == 0 {\\n        for i := start; i < len(jobDifficulty); i++ {\\n            maxVal = max(maxVal, jobDifficulty[i])\\n        }\\n        return maxVal\\n    }\\n    \\n    minVal := 1 << 31\\n    \\n    for i := start; i < len(jobDifficulty)-d; i++ {\\n        maxVal = max(maxVal, jobDifficulty[i])\\n        minVal = min(minVal, maxVal + helper(jobDifficulty, d-1, i+1, memo))\\n    }\\n    \\n    memo[d][start] = minVal\\n    \\n    return minVal\\n}\\n\\nfunc minDifficulty(jobDifficulty []int, d int) int {\\n    \\n    if len(jobDifficulty) < d {\\n        return -1\\n    }\\n    \\n    memo := make([][]int, d)\\n    for i := 0; i < d; i++ {\\n        memo[i] = make([]int, len(jobDifficulty))\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    \\n    return helper(jobDifficulty, d-1, 0, memo)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc helper(jobDifficulty []int, d int, start int, memo [][]int) int {\\n    \\n    maxVal := 0\\n    \\n    if memo[d][start] != -1 {\\n        return memo[d][start]\\n    }\\n    \\n    if d == 0 {\\n        for i := start; i < len(jobDifficulty); i++ {\\n            maxVal = max(maxVal, jobDifficulty[i])\\n        }\\n        return maxVal\\n    }\\n    \\n    minVal := 1 << 31\\n    \\n    for i := start; i < len(jobDifficulty)-d; i++ {\\n        maxVal = max(maxVal, jobDifficulty[i])\\n        minVal = min(minVal, maxVal + helper(jobDifficulty, d-1, i+1, memo))\\n    }\\n    \\n    memo[d][start] = minVal\\n    \\n    return minVal\\n}\\n\\nfunc minDifficulty(jobDifficulty []int, d int) int {\\n    \\n    if len(jobDifficulty) < d {\\n        return -1\\n    }\\n    \\n    memo := make([][]int, d)\\n    for i := 0; i < d; i++ {\\n        memo[i] = make([]int, len(jobDifficulty))\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    \\n    return helper(jobDifficulty, d-1, 0, memo)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114832,
                "title": "python-simple-recursion-memoizaqtion",
                "content": "Did not find a similar solution.\\nThe idea is very simple: for any day we can assume the current job as a one more job for today, or the first job for tomorrow\\n\\n\\n```\\nclass Solution(object):\\n    def minDifficulty(self, jobDifficulty, d):\\n        Max = 100000\\n        c = {}\\n        if len(jobDifficulty) < d: return -1\\n        \\n        def rec(mx, day, index):\\n            if (mx, day, index) in c: return c[(mx, day, index)]\\n            v = -1\\n            if day == d and index == len(jobDifficulty): v = mx\\n            elif index == len(jobDifficulty) or day > d: v = Max\\n            else:\\n                v = min(rec(max(mx, jobDifficulty[index]), day, index+1), mx + rec(jobDifficulty[index], day+1, index+1))\\n                \\n            c[(mx, day, index)] = v\\n            return v\\n        \\n        return rec(jobDifficulty[0], 1, 1)\\n   ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDifficulty(self, jobDifficulty, d):\\n        Max = 100000\\n        c = {}\\n        if len(jobDifficulty) < d: return -1\\n        \\n        def rec(mx, day, index):\\n            if (mx, day, index) in c: return c[(mx, day, index)]\\n            v = -1\\n            if day == d and index == len(jobDifficulty): v = mx\\n            elif index == len(jobDifficulty) or day > d: v = Max\\n            else:\\n                v = min(rec(max(mx, jobDifficulty[index]), day, index+1), mx + rec(jobDifficulty[index], day+1, index+1))\\n                \\n            c[(mx, day, index)] = v\\n            return v\\n        \\n        return rec(jobDifficulty[0], 1, 1)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1079769,
                "title": "concise-dp-94-72-faster-o-n-2-d",
                "content": "```\\n\\tpublic int minDifficulty(int[] jobDifficulty, int d) {\\n        if(d>jobDifficulty.length) return -1;\\n        int[][] dp= new int[d+1][jobDifficulty.length];\\n        dp[1][0]= jobDifficulty[0];\\n        for(int i=1; i<jobDifficulty.length; i++) dp[1][i]= Math.max(dp[1][i-1],jobDifficulty[i]);\\n        for(int day=2; day<=d; day++){\\n            for(int i=day-1; i<jobDifficulty.length; i++){\\n                int currArrayMax= 0; dp[day][i]= Integer.MAX_VALUE;\\n                for(int leftBound= i; leftBound>=day-1; leftBound--){\\n                    currArrayMax= Math.max(currArrayMax,jobDifficulty[leftBound]);\\n                    dp[day][i]= Math.min(dp[day][i],currArrayMax+dp[day-1][leftBound-1]);\\n                }\\n            }\\n        }\\n        return dp[d][jobDifficulty.length-1];\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minDifficulty(int[] jobDifficulty, int d) {\\n        if(d>jobDifficulty.length) return -1;\\n        int[][] dp= new int[d+1][jobDifficulty.length];\\n        dp[1][0]= jobDifficulty[0];\\n        for(int i=1; i<jobDifficulty.length; i++) dp[1][i]= Math.max(dp[1][i-1],jobDifficulty[i]);\\n        for(int day=2; day<=d; day++){\\n            for(int i=day-1; i<jobDifficulty.length; i++){\\n                int currArrayMax= 0; dp[day][i]= Integer.MAX_VALUE;\\n                for(int leftBound= i; leftBound>=day-1; leftBound--){\\n                    currArrayMax= Math.max(currArrayMax,jobDifficulty[leftBound]);\\n                    dp[day][i]= Math.min(dp[day][i],currArrayMax+dp[day-1][leftBound-1]);\\n                }\\n            }\\n        }\\n        return dp[d][jobDifficulty.length-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1023985,
                "title": "java-dfs-pruning-with-explanation",
                "content": "If you are not familiar with dynamic programming, you can also solve this problem with DFS.\\nThe definition of dfs function is: return the **minimum difficulties** if we divide the interval [index, len-1] into **numOfParts**.\\nBecause each unique pair of (index,numOfParts) can determine one unique return value, we can use a 2-D Integer array to do the pruning. \\n\\n\\n```\\nclass Solution { \\n    int[] temp;\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        //corner case\\n        if(jobDifficulty.length<d){\\n            return -1;\\n        }\\n        //pre-processing:temp[i] is the maximum value within [i,len-1]\\n        temp=new int[jobDifficulty.length];\\n        int tempMax=jobDifficulty[jobDifficulty.length-1];\\n        for(int i=jobDifficulty.length-1;i>=0;i--){\\n            tempMax=Math.max(tempMax,jobDifficulty[i]);\\n            temp[i]=tempMax;\\n        }\\n        \\n        Integer[][] mem=new Integer[d+1][jobDifficulty.length];\\n        return dfs(jobDifficulty,d,0,mem);\\n    }\\n    \\n    private int dfs(int[] jobDifficulty,int numOfParts,int index,Integer[][] mem){\\n        //pruning\\n        if(mem[numOfParts][index]!=null){\\n            return mem[numOfParts][index];\\n        }\\n        //base case: if the numOfParts<=1, we directly return the max value in this part instead of dividing this part\\n        if(numOfParts<=1){\\n            mem[numOfParts][index]=temp[index];\\n            return temp[index];\\n        }\\n\\t\\t\\n        int ret=Integer.MAX_VALUE;\\n        int localMax=Integer.MIN_VALUE;//the max value within interval [index,i]\\n        for(int i=index;i<=jobDifficulty.length-numOfParts;i++){\\n            localMax=Math.max(localMax,jobDifficulty[i]);\\n            ret=Math.min(ret,localMax+dfs(jobDifficulty,numOfParts-1,i+1,mem));\\n        }\\n        //fill in the mem array\\n        mem[numOfParts][index]=ret;\\n        return ret;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    int[] temp;\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        //corner case\\n        if(jobDifficulty.length<d){\\n            return -1;\\n        }\\n        //pre-processing:temp[i] is the maximum value within [i,len-1]\\n        temp=new int[jobDifficulty.length];\\n        int tempMax=jobDifficulty[jobDifficulty.length-1];\\n        for(int i=jobDifficulty.length-1;i>=0;i--){\\n            tempMax=Math.max(tempMax,jobDifficulty[i]);\\n            temp[i]=tempMax;\\n        }\\n        \\n        Integer[][] mem=new Integer[d+1][jobDifficulty.length];\\n        return dfs(jobDifficulty,d,0,mem);\\n    }\\n    \\n    private int dfs(int[] jobDifficulty,int numOfParts,int index,Integer[][] mem){\\n        //pruning\\n        if(mem[numOfParts][index]!=null){\\n            return mem[numOfParts][index];\\n        }\\n        //base case: if the numOfParts<=1, we directly return the max value in this part instead of dividing this part\\n        if(numOfParts<=1){\\n            mem[numOfParts][index]=temp[index];\\n            return temp[index];\\n        }\\n\\t\\t\\n        int ret=Integer.MAX_VALUE;\\n        int localMax=Integer.MIN_VALUE;//the max value within interval [index,i]\\n        for(int i=index;i<=jobDifficulty.length-numOfParts;i++){\\n            localMax=Math.max(localMax,jobDifficulty[i]);\\n            ret=Math.min(ret,localMax+dfs(jobDifficulty,numOfParts-1,i+1,mem));\\n        }\\n        //fill in the mem array\\n        mem[numOfParts][index]=ret;\\n        return ret;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008287,
                "title": "lee215-code-explained-and-clarified",
                "content": "The code in [@lee215](https://leetcode.com/lee215) -- [post](https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution) is confusing, because the bottom-up approach is less natural for this problem.  \\nI rewrote it more in \"top-down\" way, so DP solution is now clear.\\nFirst, some explanations:\\ndp(i,j) points to the optimal min splitting of jobs in [j, len(jobDifficulty) ) into i days. Thus, dp(d,0) is the desired answer.\\nRealize that for dp(i+1,j), the job at j must be done on day 1 (given j >= i+1).  The job at j+1 may or may not happen on day 1.\\nTo obtain dp(i+1,j), we must minimize (max(difficulty of jobs j..k done on day 1) + dp(i,k+1)).  \\nHere, k is [j,len(jobDifficulty)-i).  k can not be >= len(jobDifficulty)-i, because for i remaining days, we need at least i jobs.\\n\\nThe python3 code written in a space saving way, since dp(i+1,..) only depends on dp(i,..):\\n```\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        ln = len(jobDifficulty)\\n        if ln < d:\\n            return -1\\n\\n        dp,dp2 = [0]*ln,[math.inf]*ln\\n        # for d=1, the dp(j) is simply the current max between j..ln\\n        for j in range(ln-1,-1,-1):\\n            dp[j] = jobDifficulty[j] if j == ln-1 else max(jobDifficulty[j],dp[j+1])\\n        # For remaining days after d=1\\n        for i in range(1,d):\\n            # When j=ln-i-1, job j can/must be done on day 1. Jobs in [ln-i, ln) must be done in the remaining i days. \\n            # So, in i\\'th iteration, for each dp[j], we are minimizing \\n            # the \"left\" max difficulty on day 1 + the remaining jobs\\' difficulty over i-1 days. \\n            for j in range(ln-i-1,-1,-1):\\n                mx_left = 0\\n                for k in range(j,ln-i):\\n                    # Difficulty of day 1: max over the jobs j..k done on day 1\\n                    mx_left = max(mx_left,jobDifficulty[k])\\n                    # mx_left - possible day 1 difficulty, dp[k+1] - min difficulty of splitting jobs [k+1,ln) into i days\\n                    dp2[j] = min(dp2[j], mx_left + dp[k+1])\\n            dp,dp2 = dp2,[math.inf]*ln\\n        return dp[0]\\n```\\nEg. jobs=[4,3,2,1], d=2\\nFor d=1, dp = [4,3,2,1], which is the reverse running max (1st for loop in the code)\\nFor d=2, we start at j=2, because on the last day we need at least one job jobs[3].  We are going backwards with j.\\nj=2:\\nmin(dp2[2], jobs[2] + dp[2+1])\\nj = 1:\\nk=1: min(dp2[1], jobs[1] + dp[1+1])\\nk=2: min(dp2[1], max(jobs[1],jobs[2]) + dp[2+1])\\n...\\n\\nNow, because of us going backwards in the jobs j-index loop,  it\\'s easier to see the inefficiency and how we arrive at the \"stack\" optimization.\\nWhen job j is easier than the one at j+1 (jobs[j] < jobs[j+1]), job j does not affect the previous dp2 calculations at j+1, because the difficulty of the \"left\"/day1\\ninterval is the max of the interval.  We can simply update dp2[j] = min(dp2[j+1], jobs[j] + dp[j + 1]).\\nWhen job j is harder than the one at j+1 (jobs[j] >= jobs[j+1]), at j+2, etc., we need to recalculate the dp2[j] value from  j..z, where jobs[j] < jobs[j+z].  That\\'s why we need to store the job indices on the stack and pop them for this case.  Note that if jobs[j] >= jobs[j+1], dp2[j+1]=min(dp2[j+1], dp[j+2] + jobs[j+1]) gets updated to dp2[j+1]=min(dp2[j+1], (dp[j+2]+jobs[j+1])_old - jobs[j+1] + jobs[j]).  In my code, instead of stack, I store indices j on deque while jobs[j] < deque[0]; this is more intuitive.  \\n\\n```\\n    # optimized\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n       # Same as previous code\\n        ln = len(jobDifficulty)\\n        if ln < d:\\n            return -1\\n\\n        dp,dp2 = [0]*ln,[math.inf]*ln\\n        # for d=1, the dp(j) is simply the current max between j..ln\\n        for j in range(ln-1,-1,-1):\\n            dp[j] = jobDifficulty[j] if j == ln-1 else max(jobDifficulty[j],dp[j+1])\\n\\n        # Optimized\\n        for i in range(1,d):\\n            dq = deque()\\n            for j in range(ln-i-1,-1,-1):\\n                # Start by initializing dp2[j] to doing only job j on day 1.\\n                dp2[j] = min(dp2[j], jobDifficulty[j] + dp[j + 1])\\n                # while jobs[j] >= jobs[j+z] (or jobDifficulty[dq[0]]), update minimization at dp2[j] as explained above\\n                while dq and jobDifficulty[j] >= jobDifficulty[dq[0]]:\\n                    idx = dq.popleft()   # pop j+z index\\n                    dp2[j] = min(dp2[j], dp2[idx] - jobDifficulty[idx] + jobDifficulty[j])\\n                if dq:\\n                    # At this point, if dq is not empty, jobDifficulty[j] < jobDifficulty[dq[0]].  We need to calculate dp2[j] from dp2[j+z] or dp2[dq[0]].\\n                    dp2[j] = min(dp2[j], dp2[dq[0]])\\n                # if dq is empty or  jobDifficulty[j] < jobDifficulty[dq[0]], prepend j to dq.\\n                dq.appendleft(j)\\n            dp,dp2 = dp2,[math.inf]*ln\\n        return dp[0]\\n```\\nAt first, it looks like that if we store the increasing difficulty jobs on the queue, the while-loop could take up to len(jobs) (no optimization).\\nHowever, if you go through the example: [4,3,2,1], d=2, you will see that the queue never gets really filled and popped many times.\\nInstead, deque is mostly empty and dp2 records, what I call, telescoping results.\\ni=1, dp=[4,3,2,1]\\ni=2, \\n  -- j=2: dp2[2]=min(inf, jobs[2] + dp[3])\\n  -- j=1:  dp2[1] = min(dp2[1], jobs[1]+dp[2], dp2[3] - jobs[2] + jbs[1])  # dp2[1] now stores the correct result. dq becomes = [1]\\n  -- j=0:  The calculation relies on dp2[1] or dp2[dq[0]] already containing the correct minDifficulty from previous step.  We only need to calculate min twice.\\nWe could potentially pop deque ln=len(jobs) times in [1,2,3,4], d=2 example, but those times are spread over the whole j-loop run.  While-loop will get invoked exactly len(jobs) times during each j-loop.  Hence, the run time of the code is O(d\\\\*len(jobs)).",
                "solutionTags": [],
                "code": "```\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        ln = len(jobDifficulty)\\n        if ln < d:\\n            return -1\\n\\n        dp,dp2 = [0]*ln,[math.inf]*ln\\n        # for d=1, the dp(j) is simply the current max between j..ln\\n        for j in range(ln-1,-1,-1):\\n            dp[j] = jobDifficulty[j] if j == ln-1 else max(jobDifficulty[j],dp[j+1])\\n        # For remaining days after d=1\\n        for i in range(1,d):\\n            # When j=ln-i-1, job j can/must be done on day 1. Jobs in [ln-i, ln) must be done in the remaining i days. \\n            # So, in i\\'th iteration, for each dp[j], we are minimizing \\n            # the \"left\" max difficulty on day 1 + the remaining jobs\\' difficulty over i-1 days. \\n            for j in range(ln-i-1,-1,-1):\\n                mx_left = 0\\n                for k in range(j,ln-i):\\n                    # Difficulty of day 1: max over the jobs j..k done on day 1\\n                    mx_left = max(mx_left,jobDifficulty[k])\\n                    # mx_left - possible day 1 difficulty, dp[k+1] - min difficulty of splitting jobs [k+1,ln) into i days\\n                    dp2[j] = min(dp2[j], mx_left + dp[k+1])\\n            dp,dp2 = dp2,[math.inf]*ln\\n        return dp[0]\\n```\n```\\n    # optimized\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n       # Same as previous code\\n        ln = len(jobDifficulty)\\n        if ln < d:\\n            return -1\\n\\n        dp,dp2 = [0]*ln,[math.inf]*ln\\n        # for d=1, the dp(j) is simply the current max between j..ln\\n        for j in range(ln-1,-1,-1):\\n            dp[j] = jobDifficulty[j] if j == ln-1 else max(jobDifficulty[j],dp[j+1])\\n\\n        # Optimized\\n        for i in range(1,d):\\n            dq = deque()\\n            for j in range(ln-i-1,-1,-1):\\n                # Start by initializing dp2[j] to doing only job j on day 1.\\n                dp2[j] = min(dp2[j], jobDifficulty[j] + dp[j + 1])\\n                # while jobs[j] >= jobs[j+z] (or jobDifficulty[dq[0]]), update minimization at dp2[j] as explained above\\n                while dq and jobDifficulty[j] >= jobDifficulty[dq[0]]:\\n                    idx = dq.popleft()   # pop j+z index\\n                    dp2[j] = min(dp2[j], dp2[idx] - jobDifficulty[idx] + jobDifficulty[j])\\n                if dq:\\n                    # At this point, if dq is not empty, jobDifficulty[j] < jobDifficulty[dq[0]].  We need to calculate dp2[j] from dp2[j+z] or dp2[dq[0]].\\n                    dp2[j] = min(dp2[j], dp2[dq[0]])\\n                # if dq is empty or  jobDifficulty[j] < jobDifficulty[dq[0]], prepend j to dq.\\n                dq.appendleft(j)\\n            dp,dp2 = dp2,[math.inf]*ln\\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 958745,
                "title": "java-dp-o-dn2-solution-faster-than-96",
                "content": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len = jobDifficulty.length;\\n        if (len < d) return -1;\\n        if (len == d) {\\n            int sum = 0;\\n            for (int jd : jobDifficulty) {\\n                sum += jd;\\n            }\\n            return sum;\\n        }\\n        int[][] dp = new int[len][d+1];\\n        for (int[] sub : dp)\\n            Arrays.fill(sub, 10000);\\n        int max = 0;\\n        for (int j = 0; j < len; j++) {\\n            max = Math.max(max, jobDifficulty[j]);\\n            dp[j][1] = max;        \\n        }\\n        for (int i = 2; i <= d; i++) {    \\n            for (int j = len-1; j >= i-1; j--) {\\n                int min = 10000; max = 0;\\n                for (int k = j; k >= 1; k--) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    min = Math.min(min, dp[k-1][i-1] + max);\\n                }\\n                dp[j][i] = min;\\n            }\\n        }\\n        return dp[len-1][d];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len = jobDifficulty.length;\\n        if (len < d) return -1;\\n        if (len == d) {\\n            int sum = 0;\\n            for (int jd : jobDifficulty) {\\n                sum += jd;\\n            }\\n            return sum;\\n        }\\n        int[][] dp = new int[len][d+1];\\n        for (int[] sub : dp)\\n            Arrays.fill(sub, 10000);\\n        int max = 0;\\n        for (int j = 0; j < len; j++) {\\n            max = Math.max(max, jobDifficulty[j]);\\n            dp[j][1] = max;        \\n        }\\n        for (int i = 2; i <= d; i++) {    \\n            for (int j = len-1; j >= i-1; j--) {\\n                int min = 10000; max = 0;\\n                for (int k = j; k >= 1; k--) {\\n                    max = Math.max(max, jobDifficulty[k]);\\n                    min = Math.min(min, dp[k-1][i-1] + max);\\n                }\\n                dp[j][i] = min;\\n            }\\n        }\\n        return dp[len-1][d];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944104,
                "title": "easy-python-recursion-and-memoization",
                "content": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        # you should try to make as many jobs as you can in each iteration\\n        # and pick the one with minimum cost\\n        \\n        # recursion - at each point\\n        # base case:\\n        # there will be a point where you will have no days left\\n        # at that point you also have to check if you all the jobs are\\n        # exhausted\\n        # if not , return float(inf) # not valid means infinite \\n        # valid means some value\\n        \\n        if len(jobDifficulty) < d:\\n            return -1\\n        \\n        cache = {}\\n        \\n        def min_difficulty(job_index, days):\\n            if not days:\\n                if job_index <len(jobDifficulty):\\n                    return float(\\'inf\\')\\n                if job_index == len(jobDifficulty):\\n                    return 0 # min cost when no days and no jobs\\n            if job_index >=len(jobDifficulty):\\n                return float(\"inf\")\\n            \\n            if (job_index,days) in cache:\\n                return cache[(job_index,days)]\\n            # this recursion should pick minimum value\\n            # amond \\n            min_cost = float(\\'inf\\')\\n            curr_max = float(\\'-inf\\')\\n            for i in range(job_index, len(jobDifficulty)):\\n                # if we consider this element, our max changes \\n                curr_max = max(jobDifficulty[i], curr_max)\\n                \\n                # let\\'s make a cut here\\n                # consider all elements at this point\\n                ans_from_rest_of_jobs = min_difficulty(i+1, days-1)\\n                if ans_from_rest_of_jobs != float(\"inf\"): # i.e. valid\\n                    min_cost = min(min_cost, curr_max+ans_from_rest_of_jobs)\\n            \\n            # return the ans which provides minimum value\\n            cache[(job_index,days)] = min_cost\\n            return min_cost\\n        \\n        ans = min_difficulty(0,d)\\n        if ans == float(\"inf\"):\\n            return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        # you should try to make as many jobs as you can in each iteration\\n        # and pick the one with minimum cost\\n        \\n        # recursion - at each point\\n        # base case:\\n        # there will be a point where you will have no days left\\n        # at that point you also have to check if you all the jobs are\\n        # exhausted\\n        # if not , return float(inf) # not valid means infinite \\n        # valid means some value\\n        \\n        if len(jobDifficulty) < d:\\n            return -1\\n        \\n        cache = {}\\n        \\n        def min_difficulty(job_index, days):\\n            if not days:\\n                if job_index <len(jobDifficulty):\\n                    return float(\\'inf\\')\\n                if job_index == len(jobDifficulty):\\n                    return 0 # min cost when no days and no jobs\\n            if job_index >=len(jobDifficulty):\\n                return float(\"inf\")\\n            \\n            if (job_index,days) in cache:\\n                return cache[(job_index,days)]\\n            # this recursion should pick minimum value\\n            # amond \\n            min_cost = float(\\'inf\\')\\n            curr_max = float(\\'-inf\\')\\n            for i in range(job_index, len(jobDifficulty)):\\n                # if we consider this element, our max changes \\n                curr_max = max(jobDifficulty[i], curr_max)\\n                \\n                # let\\'s make a cut here\\n                # consider all elements at this point\\n                ans_from_rest_of_jobs = min_difficulty(i+1, days-1)\\n                if ans_from_rest_of_jobs != float(\"inf\"): # i.e. valid\\n                    min_cost = min(min_cost, curr_max+ans_from_rest_of_jobs)\\n            \\n            # return the ans which provides minimum value\\n            cache[(job_index,days)] = min_cost\\n            return min_cost\\n        \\n        ans = min_difficulty(0,d)\\n        if ans == float(\"inf\"):\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921606,
                "title": "c-dp-o-n-d-2-solution",
                "content": "Think this question like a maze problem on a grid where each cell has a value and you are trying to reach to bottom right corner from top left corner while trying to keep the sum of all visited cells to minimum. \\n\\n**Set up the grid**:\\n- Given size` n` and days `d`; within a day you can complete `n-d+1` many jobs.\\n- So your grid dimensions are going to be `n x (n-d+1)`\\n\\nYou can either go right or bottom on your grid.\\n\\n**Find the path with min weight**:\\nLet\\'s call the grid above `vals` type of `vector<vector<int>>` and build the solution vector of same type `sols`. We need to traverse vals from the bottom right corner to the top left corner. `sols[0][0]` is going to be the answer.\\n\\n- If you are on the right bottom cell (base case), the answer is that cell\\n- If you are on a bottom cell, all the remaining jobs need to be done on that same day.\\nThe answer is `max(vals[i][j], sols[i][j+1])`\\n- If you are on a right-most cell; that means all the remaining jobs need to be done on a separate day. \\nSo, the answer is `vals[i][j] + sols[i+1][j]`\\n- Else; we need to find the min path weight based on how many jobs we can finish that day. Let\\'s say the index of the last job finished that day was `k` where `k >= j`\\nThen answer is `max(jobs_done_that_day) + sols[i+1][k]`\\n\\nHere\\'s the code does that:\\n\\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int maxd = jobDifficulty.size()-d+1;  // max num jobs can be done on the same day\\n        if (maxd < 1) { return -1; }\\n        int size = jobDifficulty.size()-maxd+1; \\n        vector<vector<int>> vals;\\n        vector<vector<int>> sols;\\n\\t\\t\\n\\t\\t// set up the grid\\n        for (int i=0; i<size; ++i) {\\n            vals.push_back(vector<int>(maxd, -1));\\n            sols.push_back(vector<int>(maxd, -1));\\n            for (int j=0; j<maxd; ++j) {\\n                vals[i][j] = jobDifficulty[i+j];\\n            }\\n        }\\n        \\n        // build the solution\\n        for (int i=size-1; i>=0; --i) {\\n            for (int j=maxd-1; j>=0; --j) {\\n                if (j == maxd-1 && i == size-1) {\\n                    sols[i][j] = vals[i][j];\\n                } else if (j == maxd-1) {\\n                    sols[i][j] = vals[i][j] + sols[i+1][j];\\n                } else if (i == size-1) {\\n                    sols[i][j] = max(vals[i][j], sols[i][j+1]);\\n                } else {\\n                    int val = numeric_limits<int>::max();\\n                    int temp = 0;\\n                    for (int k=j; k<maxd; ++k) {\\n                        temp = max(temp, vals[i][k]);\\n                        val = min(val, temp + sols[i+1][k]);\\n                    }\\n                    sols[i][j] = val;\\n                }\\n            }\\n        }\\n        \\n        return sols[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int maxd = jobDifficulty.size()-d+1;  // max num jobs can be done on the same day\\n        if (maxd < 1) { return -1; }\\n        int size = jobDifficulty.size()-maxd+1; \\n        vector<vector<int>> vals;\\n        vector<vector<int>> sols;\\n\\t\\t\\n\\t\\t// set up the grid\\n        for (int i=0; i<size; ++i) {\\n            vals.push_back(vector<int>(maxd, -1));\\n            sols.push_back(vector<int>(maxd, -1));\\n            for (int j=0; j<maxd; ++j) {\\n                vals[i][j] = jobDifficulty[i+j];\\n            }\\n        }\\n        \\n        // build the solution\\n        for (int i=size-1; i>=0; --i) {\\n            for (int j=maxd-1; j>=0; --j) {\\n                if (j == maxd-1 && i == size-1) {\\n                    sols[i][j] = vals[i][j];\\n                } else if (j == maxd-1) {\\n                    sols[i][j] = vals[i][j] + sols[i+1][j];\\n                } else if (i == size-1) {\\n                    sols[i][j] = max(vals[i][j], sols[i][j+1]);\\n                } else {\\n                    int val = numeric_limits<int>::max();\\n                    int temp = 0;\\n                    for (int k=j; k<maxd; ++k) {\\n                        temp = max(temp, vals[i][k]);\\n                        val = min(val, temp + sols[i+1][k]);\\n                    }\\n                    sols[i][j] = val;\\n                }\\n            }\\n        }\\n        \\n        return sols[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739493,
                "title": "java-recursive-intuitive-solution-top-down",
                "content": "```\\nstatic int t[][]; // Memorization // Why 2d? since we have 2 parameters which are changing startDay and totalDays left\\n    public static int minDifficulty(int[] difficulty, int d) {\\n        t = new int[difficulty.length+1][d+1];\\n        for (int[] row : t) {\\n            Arrays.fill(row, -1);\\n        }\\n        if (difficulty.length < d) return -1; // In this case not every day will get one job.\\n        int startDayPointer = 0;\\n        return findMinUsingDFS(difficulty, startDayPointer, d);\\n    }\\n\\n    public static int findMinUsingDFS(int[] difficulty, int startDayPointer, int numDaysLeft) {\\n        if (t[startDayPointer][numDaysLeft] != -1) return t[startDayPointer][numDaysLeft];\\n        if (numDaysLeft == 1) {\\n            // If only 1 day is present, then the\\n            // minimum difficulty can\\'t be smaller than the maximum of all days.\\n            int max = Integer.MIN_VALUE;\\n            for (int i = startDayPointer; i < difficulty.length; i++) {\\n                max = Math.max(difficulty[i], max);\\n            }\\n            return t[startDayPointer][numDaysLeft] = max;\\n        }\\n\\n        int maximumForIthDay = 0, answer = Integer.MAX_VALUE;\\n        // From Start pointer you can go max upto (total diff - noOfDays) since every \\n\\t\\t// day has to get some task to do.\\n        for (int i = startDayPointer; i <= difficulty.length - numDaysLeft; i++) {\\n            maximumForIthDay = Math.max(maximumForIthDay, difficulty[i]);\\n            answer = Math.min(answer, maximumForIthDay +\\n                    // Finding Minimum of maximum difficulty for next days.\\n                    findMinUsingDFS(difficulty, i + 1, numDaysLeft - 1)); // subtracting the day.\\n        }\\n        return t[startDayPointer][numDaysLeft] = answer;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int t[][]; // Memorization // Why 2d? since we have 2 parameters which are changing startDay and totalDays left\\n    public static int minDifficulty(int[] difficulty, int d) {\\n        t = new int[difficulty.length+1][d+1];\\n        for (int[] row : t) {\\n            Arrays.fill(row, -1);\\n        }\\n        if (difficulty.length < d) return -1; // In this case not every day will get one job.\\n        int startDayPointer = 0;\\n        return findMinUsingDFS(difficulty, startDayPointer, d);\\n    }\\n\\n    public static int findMinUsingDFS(int[] difficulty, int startDayPointer, int numDaysLeft) {\\n        if (t[startDayPointer][numDaysLeft] != -1) return t[startDayPointer][numDaysLeft];\\n        if (numDaysLeft == 1) {\\n            // If only 1 day is present, then the\\n            // minimum difficulty can\\'t be smaller than the maximum of all days.\\n            int max = Integer.MIN_VALUE;\\n            for (int i = startDayPointer; i < difficulty.length; i++) {\\n                max = Math.max(difficulty[i], max);\\n            }\\n            return t[startDayPointer][numDaysLeft] = max;\\n        }\\n\\n        int maximumForIthDay = 0, answer = Integer.MAX_VALUE;\\n        // From Start pointer you can go max upto (total diff - noOfDays) since every \\n\\t\\t// day has to get some task to do.\\n        for (int i = startDayPointer; i <= difficulty.length - numDaysLeft; i++) {\\n            maximumForIthDay = Math.max(maximumForIthDay, difficulty[i]);\\n            answer = Math.min(answer, maximumForIthDay +\\n                    // Finding Minimum of maximum difficulty for next days.\\n                    findMinUsingDFS(difficulty, i + 1, numDaysLeft - 1)); // subtracting the day.\\n        }\\n        return t[startDayPointer][numDaysLeft] = answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502405,
                "title": "java-top-down-memorization",
                "content": "```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if(d > n) return -1;\\n        memo = new Integer[n][d+1];\\n        return helper(jobDifficulty, 0, d);\\n    }\\n    \\n    private int helper(int[] jobDifficulty, int st, int d){\\n        if(memo[st][d] != null) return memo[st][d];\\n        if(d == 1){\\n            int max = 0;\\n            for(int i = st; i < jobDifficulty.length; i++) max = Math.max(max, jobDifficulty[i]);\\n            memo[st][1] = max;\\n            return memo[st][1];\\n        }else{\\n            int max = 0, ans = Integer.MAX_VALUE;\\n            for(int i = st; i < jobDifficulty.length - d + 1; i++){\\n                max = Math.max(max, jobDifficulty[i]);\\n                ans = Math.min(ans, max + helper(jobDifficulty, i + 1, d - 1));\\n            }\\n            memo[st][d] = ans;\\n            return memo[st][d];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        if(d > n) return -1;\\n        memo = new Integer[n][d+1];\\n        return helper(jobDifficulty, 0, d);\\n    }\\n    \\n    private int helper(int[] jobDifficulty, int st, int d){\\n        if(memo[st][d] != null) return memo[st][d];\\n        if(d == 1){\\n            int max = 0;\\n            for(int i = st; i < jobDifficulty.length; i++) max = Math.max(max, jobDifficulty[i]);\\n            memo[st][1] = max;\\n            return memo[st][1];\\n        }else{\\n            int max = 0, ans = Integer.MAX_VALUE;\\n            for(int i = st; i < jobDifficulty.length - d + 1; i++){\\n                max = Math.max(max, jobDifficulty[i]);\\n                ans = Math.min(ans, max + helper(jobDifficulty, i + 1, d - 1));\\n            }\\n            memo[st][d] = ans;\\n            return memo[st][d];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490995,
                "title": "go-bottom-up-solution-with-explanation",
                "content": "For more golang solutions please check https://github.com/yinfirefire/LeetCode-GoSol\\n\\n```go\\nfunc minDifficulty(jobDifficulty []int, d int) int {\\n    //let dp[i][j] is the result for given i day to finish the [1:j] job\\n    //we need to decide what is the difficulty at the ith day\\n    //if the ith day we finish job[k:j], then ith day difficulty is max(jobDifficulty[k:j])\\n    //then dp[i][j] = dp[i-1][k-1]+max(jobDifficulty[k:j])\\n    length:= len(jobDifficulty)\\n    dp:=make([][]int, d+1)\\n    for i:=range dp{\\n        dp[i] = make([]int, length+1)\\n    }\\n    curMax := 0\\n    for i:=1; i<=length; i++{\\n        curMax = max(jobDifficulty[i-1], curMax)\\n        dp[1][i] = curMax\\n    }\\n    for i:=2; i<=d; i++{\\n        for j:=1; j<=length; j++{\\n            if i>j{\\n                dp[i][j]=-1\\n                continue\\n            }\\n            dp[i][j] = math.MaxInt32\\n            nextDay:=0\\n            for k:=j; k>1; k--{\\n                nextDay = max(jobDifficulty[k-1], nextDay)\\n                if dp[i-1][k-1]!=-1{\\n                    dp[i][j] = min(dp[i][j], dp[i-1][k-1]+nextDay)\\n                }\\n            }\\n        }\\n    }\\n    return dp[d][length]\\n}\\n\\nfunc max (a, b int)int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int)int{\\n    if a>b{\\n        return b\\n    }\\n    return a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minDifficulty(jobDifficulty []int, d int) int {\\n    //let dp[i][j] is the result for given i day to finish the [1:j] job\\n    //we need to decide what is the difficulty at the ith day\\n    //if the ith day we finish job[k:j], then ith day difficulty is max(jobDifficulty[k:j])\\n    //then dp[i][j] = dp[i-1][k-1]+max(jobDifficulty[k:j])\\n    length:= len(jobDifficulty)\\n    dp:=make([][]int, d+1)\\n    for i:=range dp{\\n        dp[i] = make([]int, length+1)\\n    }\\n    curMax := 0\\n    for i:=1; i<=length; i++{\\n        curMax = max(jobDifficulty[i-1], curMax)\\n        dp[1][i] = curMax\\n    }\\n    for i:=2; i<=d; i++{\\n        for j:=1; j<=length; j++{\\n            if i>j{\\n                dp[i][j]=-1\\n                continue\\n            }\\n            dp[i][j] = math.MaxInt32\\n            nextDay:=0\\n            for k:=j; k>1; k--{\\n                nextDay = max(jobDifficulty[k-1], nextDay)\\n                if dp[i-1][k-1]!=-1{\\n                    dp[i][j] = min(dp[i][j], dp[i-1][k-1]+nextDay)\\n                }\\n            }\\n        }\\n    }\\n    return dp[d][length]\\n}\\n\\nfunc max (a, b int)int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int)int{\\n    if a>b{\\n        return b\\n    }\\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490928,
                "title": "python3-top-down-dp",
                "content": "Algorithm:\\nDefine `fn(i, d)` to represent the minimum difficulty of `job[i:]` in `d` days. \\n\\n`fn(i, d) = min(max(job[i:j]) + fn(j, d-1)), j = i+1, ...`\\n\\nImplementation (776ms, 100%):\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        n = len(jobDifficulty)\\n        if n < d: return -1 \\n        \\n        @lru_cache(None)\\n        def fn(i, d): \\n            \"\"\"Return minimum difficulty of job[i:] in d days\"\"\"\\n            if d == 1: return max(jobDifficulty[i:]) #one day\\n            ans, x = float(\"inf\"), 0\\n            for j in range(i, n-d+1):\\n                x = max(x, jobDifficulty[j])\\n                ans = min(ans, x+fn(j+1, d-1))\\n            return ans \\n        \\n        return fn(0, d)\\n```\\nAnalysis:\\nTime complexity `O(N^2 d)`\\nSpace complexity `O(Nd)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        n = len(jobDifficulty)\\n        if n < d: return -1 \\n        \\n        @lru_cache(None)\\n        def fn(i, d): \\n            \"\"\"Return minimum difficulty of job[i:] in d days\"\"\"\\n            if d == 1: return max(jobDifficulty[i:]) #one day\\n            ans, x = float(\"inf\"), 0\\n            for j in range(i, n-d+1):\\n                x = max(x, jobDifficulty[j])\\n                ans = min(ans, x+fn(j+1, d-1))\\n            return ans \\n        \\n        return fn(0, d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490712,
                "title": "python-beats-100-time-and-100-in-space",
                "content": "The idea is to to finish up till i\\'th job in  d - k days and finish rest of the jobs in k days. \\n\\n**f(i,k) = min( f(j,k) + max_job_difficulty_for_i_th_day) for i <= j <= n - k + 1**\\nwhere max_job_difficulty_for_i_th_day is nothing but **max( jobDifficulty[i:j] )**\\n\\n**Base condition:** When we have only 1 day left then we have to finish the rest of the unfinished jobs, i.e. value for that day is **max( jobDifficulty[i:] )**\\n\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        if d > len(jobDifficulty): return -1\\n        arr = jobDifficulty\\n        \\n        @lru_cache(None)\\n        def helper(st, k):           \\n\\t\\t    # only one day left so we have to finish rest of the unfinished jobs \\n            if k == 1: \\n                return max(arr[st:]) \\n            \\n\\t\\t\\t# cur_max is max from i to j\\'th index, which is value on k\\'th day\\n            cur_max, ret = 0, float(\\'inf\\')\\n            for i in range(st,len(arr)-k+1):\\n                cur_max = max(cur_max, arr[i])\\n                ret = min(ret, cur_max + helper(i+1, k - 1))                \\n            return ret\\n        \\n        return helper(0, d)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        if d > len(jobDifficulty): return -1\\n        arr = jobDifficulty\\n        \\n        @lru_cache(None)\\n        def helper(st, k):           \\n\\t\\t    # only one day left so we have to finish rest of the unfinished jobs \\n            if k == 1: \\n                return max(arr[st:]) \\n            \\n\\t\\t\\t# cur_max is max from i to j\\'th index, which is value on k\\'th day\\n            cur_max, ret = 0, float(\\'inf\\')\\n            for i in range(st,len(arr)-k+1):\\n                cur_max = max(cur_max, arr[i])\\n                ret = min(ret, cur_max + helper(i+1, k - 1))                \\n            return ret\\n        \\n        return helper(0, d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490396,
                "title": "java-d-n-n-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len=jobDifficulty.length;\\n        if(jobDifficulty.length<d){\\n            return -1;\\n        }\\n        int allmax[][]=new int[len][len];\\n        for(int i=0;i<jobDifficulty.length;i++){\\n            for(int j=i;j<jobDifficulty.length;j++){\\n                if(i==j){\\n                    allmax[i][j]=jobDifficulty[i];\\n                }else{\\n                    allmax[i][j]=getmax(jobDifficulty,i,j);\\n                }\\n            }   \\n        }\\n        int dp[][]=new int[d+1][jobDifficulty.length];\\n        if(d==1){\\n            return allmax[0][len-1];\\n        }\\n        //day 1\\n        for(int col=0;col<len;col++){\\n            dp[1][col]=allmax[0][col];\\n        }\\n        \\n        for(int day=2;day<dp.length;day++){\\n            for(int col=day-1;col<len;col++){\\n                int min=Integer.MAX_VALUE;\\n                for(int cut=day-1;cut<=col;cut++){\\n                    min=Math.min(min,dp[day-1][cut-1]+allmax[cut][col]);\\n                }\\n                dp[day][col]=min;\\n            }\\n        }\\n        return dp[dp.length-1][len-1];\\n        \\n    }\\n    \\n    public int getmax(int nums[],int l,int r){\\n        int max=Integer.MIN_VALUE;\\n        for(int i=l;i<=r;i++){\\n            max=Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len=jobDifficulty.length;\\n        if(jobDifficulty.length<d){\\n            return -1;\\n        }\\n        int allmax[][]=new int[len][len];\\n        for(int i=0;i<jobDifficulty.length;i++){\\n            for(int j=i;j<jobDifficulty.length;j++){\\n                if(i==j){\\n                    allmax[i][j]=jobDifficulty[i];\\n                }else{\\n                    allmax[i][j]=getmax(jobDifficulty,i,j);\\n                }\\n            }   \\n        }\\n        int dp[][]=new int[d+1][jobDifficulty.length];\\n        if(d==1){\\n            return allmax[0][len-1];\\n        }\\n        //day 1\\n        for(int col=0;col<len;col++){\\n            dp[1][col]=allmax[0][col];\\n        }\\n        \\n        for(int day=2;day<dp.length;day++){\\n            for(int col=day-1;col<len;col++){\\n                int min=Integer.MAX_VALUE;\\n                for(int cut=day-1;cut<=col;cut++){\\n                    min=Math.min(min,dp[day-1][cut-1]+allmax[cut][col]);\\n                }\\n                dp[day][col]=min;\\n            }\\n        }\\n        return dp[dp.length-1][len-1];\\n        \\n    }\\n    \\n    public int getmax(int nums[],int l,int r){\\n        int max=Integer.MIN_VALUE;\\n        for(int i=l;i<=r;i++){\\n            max=Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490308,
                "title": "python-memoization-with-inline-explanation",
                "content": "For those who don\\'t know `lru_cache`, it cache the return value of the decorated function for the given arguments.\\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        # if in one day, do the tasks from `start` (inclusive) to `end` (exclusive),\\n        # then what\\'s the difficulty of the day.\\n\\t\\t# If you want to save space, use segment tree instead fo lru_cache.\\n        @lru_cache(None)\\n        def oneDayDifficulty(start, end):\\n            if start + 1 == end:\\n                return jobDifficulty[start]\\n            mid = (start + end) // 2\\n            return max(oneDayDifficulty(start, mid), oneDayDifficulty(mid, end))\\n        \\n        # if do tasks from `0` to `nextTask` (exclusive) in `days` days,\\n        # then what\\'s the minimum difficulty\\n        @lru_cache(None)\\n        def dp(nextTask, days):\\n            if days == 1:\\n                return oneDayDifficulty(0, nextTask)\\n            res = float(\"inf\")\\n            # if in the current day (the `days`-th day), I do all the tasks from `startTask` (inclusive) to `nextTask` (exclusive),\\n            # then compute minimum difficulty of the first `days` days.\\n            # Use the for-loop to find such minimum for all possible `startTask`.\\n            for startTask in range(days - 1, nextTask):\\n                res = min(res, dp(startTask, days - 1) + oneDayDifficulty(startTask, nextTask))\\n            return res\\n\\n        # if do all tasks in `d` days, what\\'s the minimum difficulty\\n        res = dp(len(jobDifficulty), d)\\n        return -1 if res == float(\\'inf\\') else res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        \\n        # if in one day, do the tasks from `start` (inclusive) to `end` (exclusive),\\n        # then what\\'s the difficulty of the day.\\n\\t\\t# If you want to save space, use segment tree instead fo lru_cache.\\n        @lru_cache(None)\\n        def oneDayDifficulty(start, end):\\n            if start + 1 == end:\\n                return jobDifficulty[start]\\n            mid = (start + end) // 2\\n            return max(oneDayDifficulty(start, mid), oneDayDifficulty(mid, end))\\n        \\n        # if do tasks from `0` to `nextTask` (exclusive) in `days` days,\\n        # then what\\'s the minimum difficulty\\n        @lru_cache(None)\\n        def dp(nextTask, days):\\n            if days == 1:\\n                return oneDayDifficulty(0, nextTask)\\n            res = float(\"inf\")\\n            # if in the current day (the `days`-th day), I do all the tasks from `startTask` (inclusive) to `nextTask` (exclusive),\\n            # then compute minimum difficulty of the first `days` days.\\n            # Use the for-loop to find such minimum for all possible `startTask`.\\n            for startTask in range(days - 1, nextTask):\\n                res = min(res, dp(startTask, days - 1) + oneDayDifficulty(startTask, nextTask))\\n            return res\\n\\n        # if do all tasks in `d` days, what\\'s the minimum difficulty\\n        res = dp(len(jobDifficulty), d)\\n        return -1 if res == float(\\'inf\\') else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490268,
                "title": "python-dp-o-len-jd-2-d",
                "content": "```\\nclass Solution:\\n    def minDifficulty(self, jD: List[int], d: int) -> int:\\n        self.memo = {}\\n        def dp(i,day):\\n            if (i,day) not in self.memo:\\n                if i < day: self.memo[(i,day)] = float(\\'inf\\')\\n                elif day == 1: self.memo[(i,day)] = max(jD[:i])\\n                elif i == day: self.memo[(i,day)] = sum(jD[:i])\\n                else:\\n                    tmp = jD[i-1]\\n                    self.memo[(i,day)] = dp(i-1,day-1) + tmp\\n                    for j in range(i-1,day-3,-1):\\n                        tmp = max(jD[j-1],tmp)\\n                        self.memo[(i,day)] = min(self.memo[(i,day)],dp(j,day-1) + tmp)\\n            return self.memo[(i,day)]\\n        return dp(len(jD),d) if dp(len(jD),d) != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jD: List[int], d: int) -> int:\\n        self.memo = {}\\n        def dp(i,day):\\n            if (i,day) not in self.memo:\\n                if i < day: self.memo[(i,day)] = float(\\'inf\\')\\n                elif day == 1: self.memo[(i,day)] = max(jD[:i])\\n                elif i == day: self.memo[(i,day)] = sum(jD[:i])\\n                else:\\n                    tmp = jD[i-1]\\n                    self.memo[(i,day)] = dp(i-1,day-1) + tmp\\n                    for j in range(i-1,day-3,-1):\\n                        tmp = max(jD[j-1],tmp)\\n                        self.memo[(i,day)] = min(self.memo[(i,day)],dp(j,day-1) + tmp)\\n            return self.memo[(i,day)]\\n        return dp(len(jD),d) if dp(len(jD),d) != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557954,
                "title": "easy-python-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,jobDifficulty,d,n,mx,dct):\\n        if i>=n:\\n            if  d>0:\\n                return float(\"infinity\")\\n            return mx\\n        if (i,d,mx) in dct:\\n            return dct[(i,d,mx)]\\n        x=self.dp(i+1,jobDifficulty,d-1,n,0,dct)+max(mx,jobDifficulty[i])\\n        y=self.dp(i+1,jobDifficulty,d,n,max(mx,jobDifficulty[i]),dct)\\n        dct[(i,d,mx)]=min(x,y)\\n        return min(x,y)\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n=len(jobDifficulty)\\n        if n<d:\\n            return -1\\n        return self.dp(0,jobDifficulty,d,n,0,{})\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self,i,jobDifficulty,d,n,mx,dct):\\n        if i>=n:\\n            if  d>0:\\n                return float(\"infinity\")\\n            return mx\\n        if (i,d,mx) in dct:\\n            return dct[(i,d,mx)]\\n        x=self.dp(i+1,jobDifficulty,d-1,n,0,dct)+max(mx,jobDifficulty[i])\\n        y=self.dp(i+1,jobDifficulty,d,n,max(mx,jobDifficulty[i]),dct)\\n        dct[(i,d,mx)]=min(x,y)\\n        return min(x,y)\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n        n=len(jobDifficulty)\\n        if n<d:\\n            return -1\\n        return self.dp(0,jobDifficulty,d,n,0,{})\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416599,
                "title": "memoized-recursive-solution-dp-o-n-2-d-c",
                "content": "```\\nclass Solution {\\n    int dfs(int last, int d, int n, vector<int> &nums, vector<vector<int>> &dp) {\\n        if(!d) {\\n            int mx = 0;\\n            for(int j=last+1; j<n; j++) mx = max(mx, nums[j]);\\n            return mx;\\n        }\\n        if(last != -1 && dp[last][d] != -1) return dp[last][d];\\n        \\n        int mx = 0, ans = 1e9;\\n        for(int j=last+1; j<n-1; j++) {\\n            mx = max(mx, nums[j]);\\n            ans = min(ans, mx + dfs(j, d - 1, n, nums, dp));\\n        }\\n        if(last != -1) dp[last][d] = ans;\\n        return ans;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n\\n        vector<vector<int>> dp(n, vector<int>(d, -1));\\n        return dfs(-1, d - 1, n, jobDifficulty, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int last, int d, int n, vector<int> &nums, vector<vector<int>> &dp) {\\n        if(!d) {\\n            int mx = 0;\\n            for(int j=last+1; j<n; j++) mx = max(mx, nums[j]);\\n            return mx;\\n        }\\n        if(last != -1 && dp[last][d] != -1) return dp[last][d];\\n        \\n        int mx = 0, ans = 1e9;\\n        for(int j=last+1; j<n-1; j++) {\\n            mx = max(mx, nums[j]);\\n            ans = min(ans, mx + dfs(j, d - 1, n, nums, dp));\\n        }\\n        if(last != -1) dp[last][d] = ans;\\n        return ans;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(n < d) return -1;\\n\\n        vector<vector<int>> dp(n, vector<int>(d, -1));\\n        return dfs(-1, d - 1, n, jobDifficulty, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812707,
                "title": "most-efficient-solution-with-detailed-comments-o-d-n-100-o-n-98-97",
                "content": "![image.png](https://assets.leetcode.com/users/images/942c1718-0a3a-44cf-a8f7-fd498f833c6a_1668398107.3289552.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(d * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDifficulty(self, diff: List[int], d: int) -> int:\\n        n = len(diff)\\n        if n < d:\\n            return -1\\n\\n        today = [None] * n\\n        yesterday = [diff[0]] + [None] * (n - 1)\\n        # Solution for day 0 is just the running maximum\\n        for i in range(1, n):\\n            yesterday[i] = max(yesterday[i - 1], diff[i])\\n        \\n        for day in range(1, d):\\n            # stack contains all index i where today[i] has a solution with diff[i]\\n            # as the biggest\\n            stack = []\\n            for i in range(day, n):\\n                today[i] = yesterday[i - 1] + diff[i]\\n                # Each iteration of the while loop we either add or remove an item.\\n                # Since each job is added and/or removed at most once for each day, \\n                # the time complexity is still O(d*n)\\n                while stack:\\n                    # If the last job in the stack is less difficult than job i\\n                    # then we can have the option to add job j+1 -> i to today[i]\\n                    # Because solution at today[j] has diff[j] as the biggest, \\n                    # so after add job j+1 -> i, the new biggest is diff[i], \\n                    # thus the total diff is inceaseed by (diff[i] + diff[j])\\n                    if diff[stack[-1]] < diff[i]:\\n                        j = stack.pop()\\n                        today[i] = min(today[i], today[j] - diff[j] + diff[i])\\n                    else:\\n                        # If we find a better solution at job i \\n                        # then in this solution diff[i] is the biggest.\\n                        # add it to the stack\\n                        if today[i] < today[stack[-1]]:\\n                            stack.append(i)\\n                        # else job i is a part of the solution at today[stack[-1]]\\n                        else:\\n                            today[i] = today[stack[-1]]\\n                        break\\n                else:\\n                    # If stack is empty then of course we have a new solution at job i\\n                    stack.append(i)\\n\\n            yesterday = today.copy()\\n        \\n        return yesterday[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, diff: List[int], d: int) -> int:\\n        n = len(diff)\\n        if n < d:\\n            return -1\\n\\n        today = [None] * n\\n        yesterday = [diff[0]] + [None] * (n - 1)\\n        # Solution for day 0 is just the running maximum\\n        for i in range(1, n):\\n            yesterday[i] = max(yesterday[i - 1], diff[i])\\n        \\n        for day in range(1, d):\\n            # stack contains all index i where today[i] has a solution with diff[i]\\n            # as the biggest\\n            stack = []\\n            for i in range(day, n):\\n                today[i] = yesterday[i - 1] + diff[i]\\n                # Each iteration of the while loop we either add or remove an item.\\n                # Since each job is added and/or removed at most once for each day, \\n                # the time complexity is still O(d*n)\\n                while stack:\\n                    # If the last job in the stack is less difficult than job i\\n                    # then we can have the option to add job j+1 -> i to today[i]\\n                    # Because solution at today[j] has diff[j] as the biggest, \\n                    # so after add job j+1 -> i, the new biggest is diff[i], \\n                    # thus the total diff is inceaseed by (diff[i] + diff[j])\\n                    if diff[stack[-1]] < diff[i]:\\n                        j = stack.pop()\\n                        today[i] = min(today[i], today[j] - diff[j] + diff[i])\\n                    else:\\n                        # If we find a better solution at job i \\n                        # then in this solution diff[i] is the biggest.\\n                        # add it to the stack\\n                        if today[i] < today[stack[-1]]:\\n                            stack.append(i)\\n                        # else job i is a part of the solution at today[stack[-1]]\\n                        else:\\n                            today[i] = today[stack[-1]]\\n                        break\\n                else:\\n                    # If stack is empty then of course we have a new solution at job i\\n                    stack.append(i)\\n\\n            yesterday = today.copy()\\n        \\n        return yesterday[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736179,
                "title": "bottom-up-top-down-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int topDown(int idx, vector<int>& jobDifficulty, int d, vector<vector<int>> &dp){\\n        int n = jobDifficulty.size();\\n        if(idx == n && d == 0) return 0;\\n        if(idx == n && d != 0) return 1e5;\\n        if(d == 0) return 1e5;\\n        if(dp[idx][d] != -1) return dp[idx][d];\\n        int maxDifficultyOfThatDay = INT_MIN;\\n        int ans = INT_MAX;\\n        for(int i = idx ; i < n ; i++){\\n            maxDifficultyOfThatDay = max(jobDifficulty[i], maxDifficultyOfThatDay);\\n            ans = min(ans, maxDifficultyOfThatDay + topDown(i + 1, jobDifficulty, d - 1, dp));\\n\\n        }\\n        return dp[idx][d] = ans;\\n    }\\n    int bottomUp(vector<int> &jobDifficulty, int days){\\n        int n = jobDifficulty.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(days + 1, 0));\\n        for(int idx = 1 ; idx <= days ; idx++){\\n            dp[n][idx] = 1e5;\\n        }\\n        for(int idx = 0 ; idx < n ; idx++){\\n            dp[idx][0] = 1e5;\\n        }\\n        dp[n][0] = 0;\\n        for(int idx = n - 1 ; idx >= 0 ; idx--){\\n            for(int d = 1 ; d <= days ; d++){\\n                int maxDifficultyOfThatDay = INT_MIN;\\n                int ans = INT_MAX;\\n                for(int i = idx ; i < n ; i++){\\n                    maxDifficultyOfThatDay = max(jobDifficulty[i], maxDifficultyOfThatDay);\\n                    ans = min(ans, maxDifficultyOfThatDay + dp[i + 1][d - 1]);\\n\\n                }\\n                dp[idx][d] = ans;  \\n            }\\n        }\\n        return dp[0][days];\\n        \\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(d > n) return -1;\\n        if(d == 0) return -1;\\n        // vector<vector<int>> dp(n, vector<int>(d + 1, -1));\\n        // return topDown(0, jobDifficulty, d, dp);\\n        return bottomUp(jobDifficulty, d);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int topDown(int idx, vector<int>& jobDifficulty, int d, vector<vector<int>> &dp){\\n        int n = jobDifficulty.size();\\n        if(idx == n && d == 0) return 0;\\n        if(idx == n && d != 0) return 1e5;\\n        if(d == 0) return 1e5;\\n        if(dp[idx][d] != -1) return dp[idx][d];\\n        int maxDifficultyOfThatDay = INT_MIN;\\n        int ans = INT_MAX;\\n        for(int i = idx ; i < n ; i++){\\n            maxDifficultyOfThatDay = max(jobDifficulty[i], maxDifficultyOfThatDay);\\n            ans = min(ans, maxDifficultyOfThatDay + topDown(i + 1, jobDifficulty, d - 1, dp));\\n\\n        }\\n        return dp[idx][d] = ans;\\n    }\\n    int bottomUp(vector<int> &jobDifficulty, int days){\\n        int n = jobDifficulty.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(days + 1, 0));\\n        for(int idx = 1 ; idx <= days ; idx++){\\n            dp[n][idx] = 1e5;\\n        }\\n        for(int idx = 0 ; idx < n ; idx++){\\n            dp[idx][0] = 1e5;\\n        }\\n        dp[n][0] = 0;\\n        for(int idx = n - 1 ; idx >= 0 ; idx--){\\n            for(int d = 1 ; d <= days ; d++){\\n                int maxDifficultyOfThatDay = INT_MIN;\\n                int ans = INT_MAX;\\n                for(int i = idx ; i < n ; i++){\\n                    maxDifficultyOfThatDay = max(jobDifficulty[i], maxDifficultyOfThatDay);\\n                    ans = min(ans, maxDifficultyOfThatDay + dp[i + 1][d - 1]);\\n\\n                }\\n                dp[idx][d] = ans;  \\n            }\\n        }\\n        return dp[0][days];\\n        \\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n        if(d > n) return -1;\\n        if(d == 0) return -1;\\n        // vector<vector<int>> dp(n, vector<int>(d + 1, -1));\\n        // return topDown(0, jobDifficulty, d, dp);\\n        return bottomUp(jobDifficulty, d);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714726,
                "title": "javascript-typescript-explain-detail-dynamic-programing-solution",
                "content": "The ideal is \"In any position You could **leave the day with that position** or **wait for next position**\"\\nWith that ideal you could alway split the solution into two way\\n\\n```\\nfunction minDifficulty(jobDifficulty: number[], d: number): number {\\n    if (d > jobDifficulty.length) return -1;\\n    if (d === 1) return Math.max(...jobDifficulty)\\n    let memo: {[key in string]: number} = {};\\n\\n    const dp = (jobs: number[], days: number, idx: number, globalIndex: number): number => {\\n        if (days > jobs.length - idx) {\\n            memo[`${days}-${idx}-${globalIndex}`] = Number.MAX_SAFE_INTEGER;\\n        };\\n        if (memo[`${days}-${idx}-${globalIndex}`] === undefined) {\\n            switch (days) {\\n                case jobs.length - idx:\\n                    memo[`${days}-${idx}-${globalIndex}`] = Math.max(...jobs.slice(0,idx+1)) + jobs.slice(idx+1).reduce((pre, curr) => pre+curr, 0);\\n                    break;\\n                case 1:\\n                    memo[`${days}-${idx}-${globalIndex}`] = Math.max(...jobs);\\n                    break;\\n\\n                default:\\n                    memo[`${days}-${idx}-${globalIndex}`] = Math.min(\\n                        dp(jobs, days, idx+1, globalIndex+1), //wait for next position\\n                        Math.max(...jobs.slice(0, idx+1)) + dp(jobs.slice(idx+1), days-1, 0, globalIndex+1) //leave the day with that position\\n                    );\\n                    break;\\n            }\\n        }\\n\\n        return memo[`${days}-${idx}-${globalIndex}`];\\n    }\\n\\n    return Math.min(\\n        dp(jobDifficulty, d, 1, 1), //wait for next position\\n        jobDifficulty[0] + dp(jobDifficulty.slice(1), d-1, 0, 1) //leave the day with that position\\n    );\\n};\\n```\\n\\nFor example with the test case `jobDifficulty = [11,111,22,222,33,333,44,444]` and the `d = 6` we could have the tree like this.\\n**Pattern**:\\n\"Level of Node\"\\n(Left Node) Leave the day with that position - last day value, current jobs left, days left, current index, global index\\n(Right Node) Wait for next position - current jobs left, days left, current index, global index.\\n\\n\"lv0\" \\n11,  [111, 22, 222, 33, 333, 44, 444],  5,  0,  1 \\n[11, 111, 22, 222, 33, 333, 44, 444],  6,  1,  1 \\n\"lv1\" \\n[111],  [22, 222, 33, 333, 44, 444],  4,  0,  2 \\n[111, 22, 222, 33, 333, 44, 444],  5,  1,  2 \\n\"lv2\" \\n[22],  [222, 33, 333, 44, 444],  3,  0,  3 \\n[22, 222, 33, 333, 44, 444],  4,  1,  3 \\n\"lv3\" \\n[222],  [33, 333, 44, 444],  2,  0,  4 \\n[222, 33, 333, 44, 444],  3,  1,  4 \\n\"lv4\" \\n[33],  [333, 44, 444],  1,  0,  5 \\n[33, 333, 44, 444],  2,  1,  5 \\n\"lv5\" \\n[33, 333],  [44, 444],  1,  0,  6 \\n[33, 333, 44, 444],  2,  2,  6 \\n\"lv4\" \\n[222, 33],  [333, 44, 444],  2,  0,  5 \\n[222, 33, 333, 44, 444],  3,  2,  5 \\n\"lv5\" \\n[333],  [44, 444],  1,  0,  6 \\n[333, 44, 444],  2,  1,  6 \\n\"lv3\" \\n[22, 222],  [33, 333, 44, 444],  3,  0,  4 \\n[22, 222, 33, 333, 44, 444],  4,  2,  4 \\n\"lv4\" \\n[33],  [333, 44, 444],  2,  0,  5 \\n[33, 333, 44, 444],  3,  1,  5 \\n\"lv2\" \\n[111, 22],  [222, 33, 333, 44, 444],  4,  0,  3 \\n[111, 22, 222, 33, 333, 44, 444],  5,  2,  3 \\n\"lv3\" \\n[222],  [33, 333, 44, 444],  3,  0,  4 \\n[222, 33, 333, 44, 444],  4,  1,  4 \\n\"lv1\" \\n[11, 111],  [22, 222, 33, 333, 44, 444],  5,  0,  2 \\n[11, 111, 22, 222, 33, 333, 44, 444],  6,  2,  2 \\n\"lv2\" \\n[22],  [222, 33, 333, 44, 444],  4,  0,  3 \\n[22, 222, 33, 333, 44, 444],  5,  1,  3 \\n843 \\n\\n\\n```\\nRuntime: 3995 ms\\nMemory Usage: 92.4 MB\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction minDifficulty(jobDifficulty: number[], d: number): number {\\n    if (d > jobDifficulty.length) return -1;\\n    if (d === 1) return Math.max(...jobDifficulty)\\n    let memo: {[key in string]: number} = {};\\n\\n    const dp = (jobs: number[], days: number, idx: number, globalIndex: number): number => {\\n        if (days > jobs.length - idx) {\\n            memo[`${days}-${idx}-${globalIndex}`] = Number.MAX_SAFE_INTEGER;\\n        };\\n        if (memo[`${days}-${idx}-${globalIndex}`] === undefined) {\\n            switch (days) {\\n                case jobs.length - idx:\\n                    memo[`${days}-${idx}-${globalIndex}`] = Math.max(...jobs.slice(0,idx+1)) + jobs.slice(idx+1).reduce((pre, curr) => pre+curr, 0);\\n                    break;\\n                case 1:\\n                    memo[`${days}-${idx}-${globalIndex}`] = Math.max(...jobs);\\n                    break;\\n\\n                default:\\n                    memo[`${days}-${idx}-${globalIndex}`] = Math.min(\\n                        dp(jobs, days, idx+1, globalIndex+1), //wait for next position\\n                        Math.max(...jobs.slice(0, idx+1)) + dp(jobs.slice(idx+1), days-1, 0, globalIndex+1) //leave the day with that position\\n                    );\\n                    break;\\n            }\\n        }\\n\\n        return memo[`${days}-${idx}-${globalIndex}`];\\n    }\\n\\n    return Math.min(\\n        dp(jobDifficulty, d, 1, 1), //wait for next position\\n        jobDifficulty[0] + dp(jobDifficulty.slice(1), d-1, 0, 1) //leave the day with that position\\n    );\\n};\\n```\n```\\nRuntime: 3995 ms\\nMemory Usage: 92.4 MB\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711707,
                "title": "python3-brute-force-dfs-tle-to-top-down-dp-ac-general-tips-for-dp",
                "content": "If you\\'ve been following the October 2022 LC monthly challenge, then this is very similar to string compression 2. At first I realized that it had to be DP, but I wasn\\'t exactly sure how to come up with the recurrence relation. Brute force DFS isn\\'t too hard to come up with. So that\\'s what I started with. I then used some intution to come up woth the rercurrcne releation and threw in a memo to get it AC. \\n\\n##### Tip for DP\\n* If you can\\'t see the recurrence right away. Try backtracking first. Then imagine the recursion tree and ask yourself what do I need to returrn to the parent at the current subproblem (i.e at the current sub root of the tree).\\n* Although I can\\'t exactly prove that all backtracking problems can be degenerated into a recurrence, we are playing LeetCode here and it must surely be the case that a DP solution exsists\\n\\n\\n#### Backtracking (TLE) (O(2^N))\\n* If you\\'ve thought long and hard about the problem, the inution boils down to partioning the jobs array into d-1 partitions such that the difficulty is minimized\\n* Well, lets do exactly that! At one point in the recursion tree, we either include this number to be part of the parition or we don\\'t include it (knapsack should immediatley come into mind).\\n* Keep track of a pointer into the jobs array, the currmax for this parition, the current difficulty, and the remaning splits\\n* Since we are brute force enumerating paths, we just need to return when we are in an invalid state\\n\\n```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\n        self.ans = float(\\'inf\\')\\n        N = len(jobDifficulty)\\n        \\n        def backtrack(i,curr_max,curr_difficulty,d):\\n            #if i have gotten to the end and used up my days\\n            if i == N and d == 0:\\n                self.ans = min(self.ans,curr_difficulty+curr_max)\\n                return\\n            elif d < 0:\\n                return\\n            elif i == N:\\n                return\\n            \\n            #include\\n            backtrack(i+1,max(curr_max,jobDifficulty[i]),curr_difficulty,d)\\n            #don\\'t include\\n            backtrack(i+1,jobDifficulty[i], curr_difficulty + curr_max,d-1)\\n        \\n        backtrack(0,0,0,d)\\n        return -1 if self.ans == float(\\'inf\\') else self.ans\\n```\\n\\n#### Top Down, Recursion with memo (AC) (O(N\\\\*N\\\\*D))\\n* Afer staring at the code long enough (jesus LC really ruined my weekend this weekend), you realize that this is just a 0/1 knapsack\\n* We need to take the minimum of each of the include and dont include parts of the tree\\n* The hard part is trying to figure out what the heck to return\\n* In the backtracking solution, we were updating our answer globally, but if you look we were always adding to it the ```curr_max``` variable\\n* So lets return this as the base case\\n* The other base cases are straight forward.\\n* Now comes the 0/1 knapsack problem:\\n\\t*  if we were to include the current number we are at, the difficulty should not change since we didn\\'t start a new partition\\n\\t*  if were to not include the current number, then we need to increase the current difficulty by the ```curr_max```, do we add ```curr_max``` to the ```dont_include``` part\\n* the rest should be fairly straight forward\\n\\n```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\t\\n\\t\\n        memo ={}\\n        N = len(jobDifficulty)\\n        \\n        def dp(i,curr_max,d):\\n            #if i have gotten to the end and used up my days\\n            if d < 0:\\n                return float(\\'inf\\')\\n            if i == N:\\n                if d == 0:\\n                    return curr_max\\n                else:\\n                    return float(\\'inf\\')\\n            if (i,curr_max,d) in memo:\\n                return memo[(i,curr_max,d)]\\n            \\n            #include\\n            include = dp(i+1,max(curr_max,jobDifficulty[i]),d)\\n            #don\\'t include\\n            dont_include = curr_max + dp(i+1,jobDifficulty[i],d-1)\\n            \\n            curr_difficulty = min(include,dont_include)\\n            memo[(i,curr_max,d)] = curr_difficulty\\n            return curr_difficulty\\n        \\n        ans = dp(0,0,d)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\n        self.ans = float(\\'inf\\')\\n        N = len(jobDifficulty)\\n        \\n        def backtrack(i,curr_max,curr_difficulty,d):\\n            #if i have gotten to the end and used up my days\\n            if i == N and d == 0:\\n                self.ans = min(self.ans,curr_difficulty+curr_max)\\n                return\\n            elif d < 0:\\n                return\\n            elif i == N:\\n                return\\n            \\n            #include\\n            backtrack(i+1,max(curr_max,jobDifficulty[i]),curr_difficulty,d)\\n            #don\\'t include\\n            backtrack(i+1,jobDifficulty[i], curr_difficulty + curr_max,d-1)\\n        \\n        backtrack(0,0,0,d)\\n        return -1 if self.ans == float(\\'inf\\') else self.ans\\n```\n```curr_max```\n```curr_max```\n```curr_max```\n```dont_include```\n```\\nclass Solution:\\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\t\\n\\t\\n        memo ={}\\n        N = len(jobDifficulty)\\n        \\n        def dp(i,curr_max,d):\\n            #if i have gotten to the end and used up my days\\n            if d < 0:\\n                return float(\\'inf\\')\\n            if i == N:\\n                if d == 0:\\n                    return curr_max\\n                else:\\n                    return float(\\'inf\\')\\n            if (i,curr_max,d) in memo:\\n                return memo[(i,curr_max,d)]\\n            \\n            #include\\n            include = dp(i+1,max(curr_max,jobDifficulty[i]),d)\\n            #don\\'t include\\n            dont_include = curr_max + dp(i+1,jobDifficulty[i],d-1)\\n            \\n            curr_difficulty = min(include,dont_include)\\n            memo[(i,curr_max,d)] = curr_difficulty\\n            return curr_difficulty\\n        \\n        ans = dp(0,0,d)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2711599,
                "title": "python-memoized-recursion-simple-and-intuitive",
                "content": "**tl;dr**\\n- Recursion base cases:\\n\\t- `days == 0` when we have jobs without any more days (returns `-1`)\\n\\t- fewer `jobs` than `days` left, violates the problem requirement where each day must have at least 1 `job` (returns `-1`)\\n\\t- `days == 1` where we must do all remaining jobs (returns `max(remaining_jobs)`)\\n- For each job remaining, keep track of all possible difficulties seen and return the minimum\\n- Memoize results to prevent recaculation of minDifficulties\\n\\n**Solution**\\n```py\\nclass Solution:\\n    def minDifficulty(self, jobDifficulties: List[int], days: int) -> int:\\n        n = len(jobDifficulties)\\n        \\n        @cache\\n        def dfs(i: int, days: int) -> int:\\n            if days == 0 or n - i < days:\\n                return -1\\n                \\n            if days == 1:\\n                # we can\\'t partition any more\\n                return max(jobDifficulties[i:])\\n            \\n            res = math.inf\\n            \\n            curr_max = -math.inf\\n            for j in range(i, n - days + 1):\\n                # keep track of max in current \"day\"\\n                curr_max = max(curr_max, jobDifficulties[j])\\n                \\n                # keep track of min difficulty seen\\n                res = min(res, curr_max + dfs(j + 1, days - 1))\\n            \\n            return res\\n        \\n        return dfs(0, days)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```py\\nclass Solution:\\n    def minDifficulty(self, jobDifficulties: List[int], days: int) -> int:\\n        n = len(jobDifficulties)\\n        \\n        @cache\\n        def dfs(i: int, days: int) -> int:\\n            if days == 0 or n - i < days:\\n                return -1\\n                \\n            if days == 1:\\n                # we can\\'t partition any more\\n                return max(jobDifficulties[i:])\\n            \\n            res = math.inf\\n            \\n            curr_max = -math.inf\\n            for j in range(i, n - days + 1):\\n                # keep track of max in current \"day\"\\n                curr_max = max(curr_max, jobDifficulties[j])\\n                \\n                # keep track of min difficulty seen\\n                res = min(res, curr_max + dfs(j + 1, days - 1))\\n            \\n            return res\\n        \\n        return dfs(0, days)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711501,
                "title": "c-dp-memoization-solution-top-down-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[301][11]; \\n\\t\\t//dp[index][days]\\n\\t\\tint solve(vector<int>&jD , int n, int index , int d){\\n\\t\\t\\t//base condition if day is left 1, then find max from that index of JD array to last\\n\\t\\t\\tif(d == 1)\\n\\t\\t\\t\\treturn *max_element(begin(jD)+index, end(jD));\\n\\n\\t\\t\\t//if already value is present then use it\\n\\t\\t\\tif(dp[index][d] != -1)\\n\\t\\t\\t\\treturn dp[index][d];\\n\\n\\t\\t\\tint MaxD = INT_MIN;\\n\\t\\t\\tint result = INT_MAX;\\n\\n\\t\\t\\t//finding value of next pattern by previous pattern\\n\\t\\t\\t// for ex - 6 5 4 3 2 1  and d=2 loop will run for 0 to 4th index as last day should have atleast one element remaining.\\n\\t\\t\\tfor(int i=index; i<=n-d;i++){\\n\\t\\t\\t\\tMaxD = max(MaxD, jD[i]);\\n\\t\\t\\t\\tresult = min(result , MaxD + solve(jD, n , i+1 , d-1));\\n\\n\\t\\t\\t}\\n\\t\\t\\t//keep the value at dp matrix\\n\\t\\t\\treturn dp[index][d]=result;\\n\\t\\t}\\n\\t\\tint minDifficulty(vector<int>& jD, int d) {\\n\\t\\t\\tint n=jD.size();\\n\\t\\t\\tif(n<d)\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tmemset(dp , -1 , sizeof(dp));   // cache of specific value i.e -1\\n\\t\\t\\treturn solve(jD, n , 0 , d);\\n\\n\\t\\t}\\n\\t};\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[301][11]; \\n\\t\\t//dp[index][days]\\n\\t\\tint solve(vector<int>&jD , int n, int index , int d){\\n\\t\\t\\t//base condition if day is left 1, then find max from that index of JD array to last\\n\\t\\t\\tif(d == 1)\\n\\t\\t\\t\\treturn *max_element(begin(jD)+index, end(jD));\\n\\n\\t\\t\\t//if already value is present then use it\\n\\t\\t\\tif(dp[index][d] != -1)\\n\\t\\t\\t\\treturn dp[index][d];\\n\\n\\t\\t\\tint MaxD = INT_MIN;\\n\\t\\t\\tint result = INT_MAX;\\n\\n\\t\\t\\t//finding value of next pattern by previous pattern\\n\\t\\t\\t// for ex - 6 5 4 3 2 1  and d=2 loop will run for 0 to 4th index as last day should have atleast one element remaining.\\n\\t\\t\\tfor(int i=index; i<=n-d;i++){\\n\\t\\t\\t\\tMaxD = max(MaxD, jD[i]);\\n\\t\\t\\t\\tresult = min(result , MaxD + solve(jD, n , i+1 , d-1));\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2711174,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(idx,d,curr):\\n\\n\\t\\t\\t\\tif idx == len(jobDifficulty) and d == 0: return curr\\n\\t\\t\\t\\tif idx >= len(jobDifficulty) or  d <= 0: return inf\\n\\n\\t\\t\\t\\treturn min(dp(idx+1,d,max(curr,jobDifficulty[idx])),\\n\\t\\t\\t\\t\\t\\t   max(curr,jobDifficulty[idx])+dp(idx+1,d-1,0))\\n\\n\\t\\t\\tans = dp(0,d,0)\\n\\n\\t\\t\\treturn ans if ans != inf else -1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(idx,d,curr):\\n\\n\\t\\t\\t\\tif idx == len(jobDifficulty) and d == 0: return curr\\n\\t\\t\\t\\tif idx >= len(jobDifficulty) or  d <= 0: return inf\\n\\n\\t\\t\\t\\treturn min(dp(idx+1,d,max(curr,jobDifficulty[idx])),\\n\\t\\t\\t\\t\\t\\t   max(curr,jobDifficulty[idx])+dp(idx+1,d-1,0))\\n\\n\\t\\t\\tans = dp(0,d,0)\\n\\n\\t\\t\\treturn ans if ans != inf else -1",
                "codeTag": "Java"
            },
            {
                "id": 2710973,
                "title": "easy-recusion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][12];\\n    int helper(vector<int>& arr,int left,int right,int d){\\n        if(d == 1){\\n            return *max_element(arr.begin()+left,arr.end());\\n        }\\n        if(dp[left][d] != -1)return dp[left][d];\\n        int curr = INT_MIN;\\n        int res = INT_MAX;\\n        for(int i = left;i<=right-d;i++){\\n            curr = max(curr,arr[i]);\\n            res = min(res,curr+helper(arr,i+1,right,d-1));\\n        }\\n        return dp[left][d] = res;\\n    }\\n    int minDifficulty(vector<int>& arr, int d) {\\n        int n = arr.size();\\n        if(n<d)return -1;\\n        memset(dp,-1,sizeof(dp));\\n        return helper(arr,0,n,d);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][12];\\n    int helper(vector<int>& arr,int left,int right,int d){\\n        if(d == 1){\\n            return *max_element(arr.begin()+left,arr.end());\\n        }\\n        if(dp[left][d] != -1)return dp[left][d];\\n        int curr = INT_MIN;\\n        int res = INT_MAX;\\n        for(int i = left;i<=right-d;i++){\\n            curr = max(curr,arr[i]);\\n            res = min(res,curr+helper(arr,i+1,right,d-1));\\n        }\\n        return dp[left][d] = res;\\n    }\\n    int minDifficulty(vector<int>& arr, int d) {\\n        int n = arr.size();\\n        if(n<d)return -1;\\n        memset(dp,-1,sizeof(dp));\\n        return helper(arr,0,n,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710652,
                "title": "bottom-down-100",
                "content": "```\\nclass Solution {\\n    public int maxa(int a,int b){\\n        if(a>b)return b;\\n        return a;\\n    }\\n    public int minDifficul(int[] job, int d,int[][] dp,int[][] maxvi, int n,int ma){\\n        int l=ma;\\n        if(n==0 &&d==1) return Math.max(ma,job[0]);\\n        if(dp[n][d]!=-1 && maxvi[n][d]==ma)return dp[n][d];\\n        int ans;\\n        if(d==1){\\n            if(ma<job[n])ma=job[n];\\n            for(int i=0;i<n;i++){\\n               if(ma<job[i]) ma = job[i];\\n            }\\n            ans= ma;\\n        }else if(n>=d){\\n            if(ma<job[n]){\\n                ma=job[n];\\n                }\\n        ans=maxa(ma + minDifficul(job,d-1,dp,maxvi,n-1,-1),minDifficul(job, d,dp,maxvi, n-1,ma)); \\n        }else{     \\n            if(ma<job[n])ma=job[n];\\n            for(int i=0;i<n;i++){\\n                ma =ma+job[i];\\n            }\\n            ans= ma;\\n        }\\n        maxvi[n][d]=l;\\n        return dp[n][d]=ans;\\n    }\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n=jobDifficulty.length;\\n        if(n<d)return -1;\\n        if(n==d){\\n            int s=0;\\n            for(int p: jobDifficulty){\\n               s +=p; \\n            }\\n            return s;\\n        }\\n        int[][] dp=new int[n][d+1];\\n        for(int[] v:dp) {\\n            Arrays.fill(v,-1);\\n        }\\n        int[][] maxvi=new int[n][d+1];\\n        for(int[] v:maxvi) {\\n            Arrays.fill(v,-1);\\n        }\\n        \\n        return minDifficul(jobDifficulty,  d,dp,maxvi, n-1,-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxa(int a,int b){\\n        if(a>b)return b;\\n        return a;\\n    }\\n    public int minDifficul(int[] job, int d,int[][] dp,int[][] maxvi, int n,int ma){\\n        int l=ma;\\n        if(n==0 &&d==1) return Math.max(ma,job[0]);\\n        if(dp[n][d]!=-1 && maxvi[n][d]==ma)return dp[n][d];\\n        int ans;\\n        if(d==1){\\n            if(ma<job[n])ma=job[n];\\n            for(int i=0;i<n;i++){\\n               if(ma<job[i]) ma = job[i];\\n            }\\n            ans= ma;\\n        }else if(n>=d){\\n            if(ma<job[n]){\\n                ma=job[n];\\n                }\\n        ans=maxa(ma + minDifficul(job,d-1,dp,maxvi,n-1,-1),minDifficul(job, d,dp,maxvi, n-1,ma)); \\n        }else{     \\n            if(ma<job[n])ma=job[n];\\n            for(int i=0;i<n;i++){\\n                ma =ma+job[i];\\n            }\\n            ans= ma;\\n        }\\n        maxvi[n][d]=l;\\n        return dp[n][d]=ans;\\n    }\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n=jobDifficulty.length;\\n        if(n<d)return -1;\\n        if(n==d){\\n            int s=0;\\n            for(int p: jobDifficulty){\\n               s +=p; \\n            }\\n            return s;\\n        }\\n        int[][] dp=new int[n][d+1];\\n        for(int[] v:dp) {\\n            Arrays.fill(v,-1);\\n        }\\n        int[][] maxvi=new int[n][d+1];\\n        for(int[] v:maxvi) {\\n            Arrays.fill(v,-1);\\n        }\\n        \\n        return minDifficul(jobDifficulty,  d,dp,maxvi, n-1,-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710558,
                "title": "c-dp-301-11-easy-and-beginner-friendly-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // max size 301*11\\n    vector<vector<int>> dp;\\n    \\n    int solve(vector<int>& jobDifficulty, int n, int i, int d){\\n        //base case\\n        if(d==1){\\n            return *max_element(jobDifficulty.begin()+i, jobDifficulty.end());\\n        }\\n        if(dp[i][d] != -1) return dp[i][d];\\n        \\n        //Solve\\n        int res = INT_MAX;\\n        int curr = INT_MIN;\\n        for(int j=i; j<=n-d; j++){\\n            curr = max(curr, jobDifficulty[j]);\\n            res = min(res, curr + solve(jobDifficulty, n, j+1, d-1));\\n        }\\n        //return\\n        return dp[i][d] = res;\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        dp.resize(301, vector<int>(11, -1));\\n        int n = jobDifficulty.size();\\n        \\n        if(n<d) return -1;\\n        return solve(jobDifficulty, n, 0, d);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // max size 301*11\\n    vector<vector<int>> dp;\\n    \\n    int solve(vector<int>& jobDifficulty, int n, int i, int d){\\n        //base case\\n        if(d==1){\\n            return *max_element(jobDifficulty.begin()+i, jobDifficulty.end());\\n        }\\n        if(dp[i][d] != -1) return dp[i][d];\\n        \\n        //Solve\\n        int res = INT_MAX;\\n        int curr = INT_MIN;\\n        for(int j=i; j<=n-d; j++){\\n            curr = max(curr, jobDifficulty[j]);\\n            res = min(res, curr + solve(jobDifficulty, n, j+1, d-1));\\n        }\\n        //return\\n        return dp[i][d] = res;\\n    }\\n    \\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        dp.resize(301, vector<int>(11, -1));\\n        int n = jobDifficulty.size();\\n        \\n        if(n<d) return -1;\\n        return solve(jobDifficulty, n, 0, d);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710451,
                "title": "java-recursive-memoization-solution-easy-explained-with-comments",
                "content": "```\\n\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        Integer [][][] dp = new Integer[n+1][d+1][1001];\\n\\n        if(n<d){\\n            return -1;\\n        }\\n        return f(jobDifficulty, 0, d, 0, dp);\\n    }\\n\\n//Recursive solution With Memoization\\n    public int f(int[] jobDifficulty,int i, int d, int max, Integer [][] dp) {\\n        if(i==jobDifficulty.length && d==0){\\n            return 0;\\n        }\\n\\n        if(i==jobDifficulty.length || d==0){\\n            return (int)10e4+1;\\n        }\\n\\n        if(dp[i][d][max]!=null) return dp[i][d][max];\\n\\n        max = Math.max(max, jobDifficulty[i]);\\n\\n        //options to explore ways\\n\\n        int way1 = max + f(jobDifficulty, i+1, d-1 ,0 , dp); //we are done on d day so move on to next day but we have to add max which we were maitaining\\n        \\n        int way2 = f(jobDifficulty, i+1, d, max, dp); \\n        //be on the same day and we are maitaining max\\n\\n        return dp[i][d][max] = Math.min(way1,way2);\\n    }\\n}\\n\\n\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n = jobDifficulty.length;\\n        Integer [][][] dp = new Integer[n+1][d+1][1001];\\n\\n        if(n<d){\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2710113,
                "title": "memoized-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have to try out all possibilities we will go with recursion and then memoization.\\nAs we have to do tasks in some specific order and not any way we like thus this makes it a bit simpler.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we reach a point where we require more days than given number d theis means we wont get an ans thus we retuen INT_MAX.\\n\\nIf the index is past the end of array and still our days are not completed this means no ans thus return INT_MAX else return 0.\\nReturn 0 beacause we get one answer .\\n\\nNow we try out different number of jobs and take out make difficulty from them and make a minimum answer .\\n\\nreturn minimum answer .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor Memoized code the time complexity is O(n * d).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFor Memoized code the space complexity is O(n * d).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int day,int index,vector<int> &jobs,vector<vector<int> > &dp){\\n        if(day < 0) return 1e7;\\n\\n        if(index >= jobs.size()){\\n            if(day > 0) return 1e7;\\n\\n            return 0;\\n        }\\n\\n        if(dp[day][index] != -1) return dp[day][index];\\n\\n        int diff = jobs[index];\\n        int val = INT_MAX;\\n\\n        for(int i= index ;i < jobs.size() ;i++){\\n            diff = max(diff , jobs[i]);\\n            val = min(val , diff + solve(day -1,i+1 , jobs ,dp));\\n        }\\n        return dp[day][index] = val;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n\\n        vector<vector<int> > dp(d+1 ,vector<int> (n+1 , -1));\\n        int ans = solve(d,0,jobDifficulty,dp);\\n        if(ans >= 10000007) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int day,int index,vector<int> &jobs,vector<vector<int> > &dp){\\n        if(day < 0) return 1e7;\\n\\n        if(index >= jobs.size()){\\n            if(day > 0) return 1e7;\\n\\n            return 0;\\n        }\\n\\n        if(dp[day][index] != -1) return dp[day][index];\\n\\n        int diff = jobs[index];\\n        int val = INT_MAX;\\n\\n        for(int i= index ;i < jobs.size() ;i++){\\n            diff = max(diff , jobs[i]);\\n            val = min(val , diff + solve(day -1,i+1 , jobs ,dp));\\n        }\\n        return dp[day][index] = val;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\\n        int n = jobDifficulty.size();\\n\\n        vector<vector<int> > dp(d+1 ,vector<int> (n+1 , -1));\\n        int ans = solve(d,0,jobDifficulty,dp);\\n        if(ans >= 10000007) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709966,
                "title": "can-anyone-find-misatke-in-my-code-while-memorizing",
                "content": "class Solution {\\n    public int maxa(int a,int b){\\n        if(a>b)return b;\\n        return a;\\n    }\\n    public int minDifficul(int[] job, int d,int[][] dp, int n,int ma){\\n        if(n==0 &&d==1) return Math.max(ma,job[0]);\\n        if(dp[n][d]!=-1)return dp[n][d];\\n        int ans;\\n        if(d==1){\\n            if(ma<job[n])ma=job[n];\\n            for(int i=0;i<n;i++){\\n               if(ma<job[i]) ma = job[i];\\n            }\\n            ans= ma;\\n        }else if(n>=d){\\n            if(ma<job[n]){\\n                ma=job[n];\\n                }\\n        ans=maxa(ma + minDifficul(job,d-1,dp,n-1,-1),minDifficul(job, d,dp, n-1,ma)); \\n        }else{     \\n            if(ma<job[n])ma=job[n];\\n            for(int i=0;i<n;i++){\\n                ma =ma+job[i];\\n            }\\n            ans= ma;\\n        }\\n        return dp[n][d]=ans;\\n    }\\n    \\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int n=jobDifficulty.length;\\n        if(n<d)return -1;\\n        if(n==d){\\n            int s=0;\\n            for(int p: jobDifficulty){\\n               s +=p; \\n            }\\n            return s;\\n        }\\n        int[][] dp=new int[n][d+1];\\n        for(int[] v:dp) {\\n            Arrays.fill(v,-1);\\n        }\\n        \\n        return minDifficul(jobDifficulty,  d,dp, n-1,-1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxa(int a,int b){\\n        if(a>b)return b;\\n        return a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2709859,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\n    int n;\\n    int dp[302][15];\\n    int INF = 10000;\\n    int dfs(int i,int d,vector<int>& jobDifficulty)\\n    {\\n        if(i==n && d==0)\\n            return 0;\\n        if(i==n || d==0)\\n            return INF;\\n        if(n-i<d)\\n            return INF;\\n        if(dp[i][d]!=-1)\\n            return dp[i][d];\\n        int ans=INF;\\n        int maxi=-INF;\\n        for(int j=i;j<n;j++)\\n        {\\n            maxi = max(maxi,jobDifficulty[j]);   //max from i to j\\n            ans = min(ans,maxi+dfs(j+1,d-1,jobDifficulty));  //min of all possible answers\\n        }\\n        return dp[i][d]=ans;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) \\n    {\\n        n=jobDifficulty.size();\\n        if(n<d)\\n            return -1;\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0,d,jobDifficulty);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int dp[302][15];\\n    int INF = 10000;\\n    int dfs(int i,int d,vector<int>& jobDifficulty)\\n    {\\n        if(i==n && d==0)\\n            return 0;\\n        if(i==n || d==0)\\n            return INF;\\n        if(n-i<d)\\n            return INF;\\n        if(dp[i][d]!=-1)\\n            return dp[i][d];\\n        int ans=INF;\\n        int maxi=-INF;\\n        for(int j=i;j<n;j++)\\n        {\\n            maxi = max(maxi,jobDifficulty[j]);   //max from i to j\\n            ans = min(ans,maxi+dfs(j+1,d-1,jobDifficulty));  //min of all possible answers\\n        }\\n        return dp[i][d]=ans;\\n    }\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int d) \\n    {\\n        n=jobDifficulty.size();\\n        if(n<d)\\n            return -1;\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0,d,jobDifficulty);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709788,
                "title": "fastest-0-ms-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len = jobDifficulty.length;\\n        if (d > len) return -1;\\n        int[][] minDifficulty = new int[d][len];\\n        for (int i = 1; i < d; i++) {\\n            Arrays.fill(minDifficulty[i], Integer.MAX_VALUE);\\n        }\\n        int maxDifficulty = 0;\\n        for (int i = 0; i <= len - d; i++) {\\n            maxDifficulty = Math.max(maxDifficulty, jobDifficulty[i]);\\n            minDifficulty[0][i] = maxDifficulty;\\n        }\\n        for (int day = 1; day < d; day++) {\\n            for (int to = day; to <= len - d + day; to++) {\\n                int currentDayDifficulty = jobDifficulty[to];\\n                int result = Integer.MAX_VALUE;\\n                for (int j = to - 1; j >= day - 1; j--) {\\n                    result = Math.min(result, minDifficulty[day - 1][j] + currentDayDifficulty);\\n                    currentDayDifficulty = Math.max(currentDayDifficulty, jobDifficulty[j]);\\n                }\\n                minDifficulty[day][to] = result;\\n            }   \\n        }\\n        return minDifficulty[d - 1][len - 1];\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.\\nCredit goes to YT channel @LearnOverflow.\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDifficulty(int[] jobDifficulty, int d) {\\n        int len = jobDifficulty.length;\\n        if (d > len) return -1;\\n        int[][] minDifficulty = new int[d][len];\\n        for (int i = 1; i < d; i++) {\\n            Arrays.fill(minDifficulty[i], Integer.MAX_VALUE);\\n        }\\n        int maxDifficulty = 0;\\n        for (int i = 0; i <= len - d; i++) {\\n            maxDifficulty = Math.max(maxDifficulty, jobDifficulty[i]);\\n            minDifficulty[0][i] = maxDifficulty;\\n        }\\n        for (int day = 1; day < d; day++) {\\n            for (int to = day; to <= len - d + day; to++) {\\n                int currentDayDifficulty = jobDifficulty[to];\\n                int result = Integer.MAX_VALUE;\\n                for (int j = to - 1; j >= day - 1; j--) {\\n                    result = Math.min(result, minDifficulty[day - 1][j] + currentDayDifficulty);\\n                    currentDayDifficulty = Math.max(currentDayDifficulty, jobDifficulty[j]);\\n                }\\n                minDifficulty[day][to] = result;\\n            }   \\n        }\\n        return minDifficulty[d - 1][len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709728,
                "title": "my-python-solution",
                "content": "**Plzzz upvote the code**\\n\\n```\\nimport functools\\nclass Solution:\\n\\n    def minDifficulty(self, A, d):\\n        n = len(A)\\n        if n < d: return -1\\n\\n        @functools.lru_cache(None)\\n        def dfs(i, d):\\n            if d == 1:\\n                return max(A[i:])\\n            res, maxd = float(\\'inf\\'), 0\\n            for j in range(i, n - d + 1):\\n                maxd = max(maxd, A[j])\\n                res = min(res, maxd + dfs(j + 1, d - 1))\\n            return res\\n        return dfs(0, d)\\n```\\n\\n#This code is contributed by Parul Sharma",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport functools\\nclass Solution:\\n\\n    def minDifficulty(self, A, d):\\n        n = len(A)\\n        if n < d: return -1\\n\\n        @functools.lru_cache(None)\\n        def dfs(i, d):\\n            if d == 1:\\n                return max(A[i:])\\n            res, maxd = float(\\'inf\\'), 0\\n            for j in range(i, n - d + 1):\\n                maxd = max(maxd, A[j])\\n                res = min(res, maxd + dfs(j + 1, d - 1))\\n            return res\\n        return dfs(0, d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709680,
                "title": "c-2-approach-recursion-memoization-o-nd-solution",
                "content": "\\tclass Solution {\\n\\t\\t/**************************/\\n\\t\\t //Memoization approach\\n\\t\\t//time: O(nd)\\n\\t\\tint dp[301][11]; //bcz start and d are changing\\n\\t\\tint solve_memo(vector<int>& jd, int d, int start, int n){\\n\\n\\t\\t\\tif(d == 1)\\n\\t\\t\\t\\treturn *max_element(jd.begin() + start, jd.end());\\n\\t\\t\\tif(dp[start][d] != -1)\\n\\t\\t\\t\\treturn dp[start][d];\\n\\n\\t\\t\\tint minDiffTaskOfJobSchedule = INT_MAX;\\n\\t\\t\\tint diffTaskOfDay = INT_MIN; //bcz it has to be max\\n\\n\\t\\t\\tfor(int i=start; i<=n-d; i++){\\n\\t\\t\\t\\tdiffTaskOfDay = max(diffTaskOfDay, jd[i]);\\n\\t\\t\\t\\tminDiffTaskOfJobSchedule = min(minDiffTaskOfJobSchedule, diffTaskOfDay + solve_memo(jd, d-1, i+1, n));\\n\\t\\t\\t}\\n\\t\\t\\tdp[start][d] = minDiffTaskOfJobSchedule;\\n\\t\\t\\treturn dp[start][d];\\n\\t\\t}\\n\\n\\t\\tint solve_memoHelper(vector<int>& jd, int d){\\n\\t\\t\\tint n = jd.size();\\n\\t\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\t\\treturn solve_memo(jd, d, 0, n);\\n\\n\\t\\t}\\n\\n\\n\\t\\t/****************************/\\n\\n\\t\\t/************************/\\n\\t\\t// Recurison Approach-->TLE\\n\\t\\t//time Complexity: for *max_ele..   is O(n),  for loop is O(n) and solve is running O(d-1) ~ O(d)\\n\\t\\tint solve(vector<int>& jd, int d, int start, int n){\\n\\n\\t\\t\\tif(d == 1)\\n\\t\\t\\t\\treturn *max_element(jd.begin() + start, jd.end());\\n\\n\\t\\t\\tint minDiffTaskOfJobSchedule = INT_MAX;\\n\\t\\t\\tint diffTaskOfDay = INT_MIN; //bcz it has to be max\\n\\n\\t\\t\\tfor(int i=start; i<=n-d; i++){\\n\\t\\t\\t\\tdiffTaskOfDay = max(diffTaskOfDay, jd[i]);\\n\\t\\t\\t\\tminDiffTaskOfJobSchedule = min(minDiffTaskOfJobSchedule, diffTaskOfDay + solve(jd, d-1, i+1, n));\\n\\t\\t\\t}\\n\\t\\t\\treturn minDiffTaskOfJobSchedule;\\n\\t\\t}\\n\\n\\t\\t/****************************/\\n\\n\\tpublic:\\n\\t\\tint minDifficulty(vector<int>& jd, int d) {\\n\\t\\t\\tint n = jd.size();\\n\\t\\t\\tif(n < d)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\treturn solve_memoHelper(jd, d);   \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\t/**************************/\\n\\t\\t //Memoization approach\\n\\t\\t//time: O(nd)\\n\\t\\tint dp[301][11]; //bcz start and d are changing\\n\\t\\tint solve_memo(vector<int>& jd, int d, int start, int n){\\n\\n\\t\\t\\tif(d == 1)\\n\\t\\t\\t\\treturn *max_element(jd.begin() + start, jd.end());\\n\\t\\t\\tif(dp[start][d] != -1)\\n\\t\\t\\t\\treturn dp[start][d];\\n\\n\\t\\t\\tint minDiffTaskOfJobSchedule = INT_MAX;\\n\\t\\t\\tint diffTaskOfDay = INT_MIN; //bcz it has to be max\\n\\n\\t\\t\\tfor(int i=start; i<=n-d; i++){\\n\\t\\t\\t\\tdiffTaskOfDay = max(diffTaskOfDay, jd[i]);\\n\\t\\t\\t\\tminDiffTaskOfJobSchedule = min(minDiffTaskOfJobSchedule, diffTaskOfDay + solve_memo(jd, d-1, i+1, n));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2709668,
                "title": "ruby-recursion-with-memoization",
                "content": "```ruby\\nclass Solver\\n    attr_reader :jd, :mem\\n    \\n    def initialize(jd, d)\\n        @jd, @d, @mem = jd, d, Array.new(jd.size + 1) {|i| Array.new(d + 1) }\\n    end\\n    \\n    def solve(idx = 0, d = @d)\\n        mem[idx][d] ||= (d == 1) ? \\n                        jd[idx..-1].max : \\n                        jd[idx+1..-d].each_with_index.inject([jd[idx], jd[idx] + solve(idx+1, d-1)]) {|(vmax, res), (v, jdx)|\\n                            vmax = [vmax, v].max\\n                            [vmax, [res, vmax + solve(idx+jdx+2, d-1)].min]\\n                        }.last\\n    end\\nend\\n\\ndef min_difficulty(job_difficulty, d)\\n    return -1 if d > job_difficulty.size\\n    Solver.new(job_difficulty, d).solve\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```ruby\\nclass Solver\\n    attr_reader :jd, :mem\\n    \\n    def initialize(jd, d)\\n        @jd, @d, @mem = jd, d, Array.new(jd.size + 1) {|i| Array.new(d + 1) }\\n    end\\n    \\n    def solve(idx = 0, d = @d)\\n        mem[idx][d] ||= (d == 1) ? \\n                        jd[idx..-1].max : \\n                        jd[idx+1..-d].each_with_index.inject([jd[idx], jd[idx] + solve(idx+1, d-1)]) {|(vmax, res), (v, jdx)|\\n                            vmax = [vmax, v].max\\n                            [vmax, [res, vmax + solve(idx+jdx+2, d-1)].min]\\n                        }.last\\n    end\\nend\\n\\ndef min_difficulty(job_difficulty, d)\\n    return -1 if d > job_difficulty.size\\n    Solver.new(job_difficulty, d).solve\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709471,
                "title": "c-top-down-dp-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int solve(vector<int>& jobDifficulty, int index, int d, vector<vector<int>> &dp)\\n    {\\n        int n = jobDifficulty.size();\\n        if(n<d)\\n            return -1;\\n        if(n==d)\\n        {\\n            int s = 0;\\n            for(int i=0;i<n;i++)\\n                s += jobDifficulty[i];\\n            return s;\\n        }\\n        if(d == 1)\\n            return *max_element(jobDifficulty.begin()+index, jobDifficulty.end());\\n        if(dp[index][d]!=-1)\\n            return dp[index][d];\\n        int maxi = INT_MIN;\\n        int sum = INT_MAX;\\n        for(int i=index; i<=n-d; i++) \\n        {\\n            maxi = max(maxi, jobDifficulty[i]);\\n            sum = min(sum, maxi + solve(jobDifficulty, i+1, d-1, dp));\\n        }\\n        return dp[index][d] = sum;\\n    }\\n    int minDifficulty(vector<int>& jobDifficulty, int d) \\n    {\\n        vector<vector<int> >dp(301, vector<int>(11, -1));\\n        return solve(jobDifficulty, 0, d, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<int>& jobDifficulty, int index, int d, vector<vector<int>> &dp)\\n    {\\n        int n = jobDifficulty.size();\\n        if(n<d)\\n            return -1;\\n        if(n==d)\\n        {\\n            int s = 0;\\n            for(int i=0;i<n;i++)\\n                s += jobDifficulty[i];\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2709395,
                "title": "simple-c-solution",
                "content": "```\\n#define min(x,y) (((x) < (y))?(x):(y))\\n#define max(x,y) (((x) > (y))?(x):(y))\\n#define MAX_LIMIT 10000          //As per contraints; 0 <= jobDifficulty[i] <= 1000\\nint minDifficulty(int* jobDifficulty, int jobDifficultySize, int d){\\n    int maxValue = MAX_LIMIT+1;\\n    int maxDifficulty = 0;      //Maximum difficulty of a job done on particular day \\'day\\'.\\n    if (jobDifficultySize < d){\\n        return -1;\\n    }\\n    if(d == 1){\\n        for (int i = 0 ; i < jobDifficultySize ; i++){\\n            maxDifficulty = max(maxDifficulty, jobDifficulty[i]);\\n        }\\n        return maxDifficulty;\\n    }\\n    maxDifficulty = 0;\\n    int minJobDiff[jobDifficultySize + 1];      //Total minimum difficulty for total days \\'d\\'\\n    for(int i=0; i<jobDifficultySize; i++){\\n        minJobDiff[i] = maxValue;\\n    }\\n    minJobDiff[jobDifficultySize] = 0;\\n    \\n    for (int day = 1; day <= d; ++day) {\\n        for (int i = 0; i <= jobDifficultySize - day; i++) {    //Check for the i\\'th job per day\\n            maxDifficulty = 0, minJobDiff[i] = maxValue;\\n            for (int j = i; j <= jobDifficultySize - day; j++) { //Check for all job lists for i\\'th job per day\\n                maxDifficulty = max(maxDifficulty, jobDifficulty[j]);\\n                minJobDiff[i] = min(minJobDiff[i], maxDifficulty + minJobDiff[j + 1]);\\n            }\\n        }\\n    }\\n    return minJobDiff[0];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define min(x,y) (((x) < (y))?(x):(y))\\n#define max(x,y) (((x) > (y))?(x):(y))\\n#define MAX_LIMIT 10000          //As per contraints; 0 <= jobDifficulty[i] <= 1000\\nint minDifficulty(int* jobDifficulty, int jobDifficultySize, int d){\\n    int maxValue = MAX_LIMIT+1;\\n    int maxDifficulty = 0;      //Maximum difficulty of a job done on particular day \\'day\\'.\\n    if (jobDifficultySize < d){\\n        return -1;\\n    }\\n    if(d == 1){\\n        for (int i = 0 ; i < jobDifficultySize ; i++){\\n            maxDifficulty = max(maxDifficulty, jobDifficulty[i]);\\n        }\\n        return maxDifficulty;\\n    }\\n    maxDifficulty = 0;\\n    int minJobDiff[jobDifficultySize + 1];      //Total minimum difficulty for total days \\'d\\'\\n    for(int i=0; i<jobDifficultySize; i++){\\n        minJobDiff[i] = maxValue;\\n    }\\n    minJobDiff[jobDifficultySize] = 0;\\n    \\n    for (int day = 1; day <= d; ++day) {\\n        for (int i = 0; i <= jobDifficultySize - day; i++) {    //Check for the i\\'th job per day\\n            maxDifficulty = 0, minJobDiff[i] = maxValue;\\n            for (int j = i; j <= jobDifficultySize - day; j++) { //Check for all job lists for i\\'th job per day\\n                maxDifficulty = max(maxDifficulty, jobDifficulty[j]);\\n                minJobDiff[i] = min(minJobDiff[i], maxDifficulty + minJobDiff[j + 1]);\\n            }\\n        }\\n    }\\n    return minJobDiff[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709315,
                "title": "c-memoized-solution-simple-pick-or-not-pick-logic-o-n-2-d",
                "content": "#define vi vector<int>\\n#define vvi vector<vi>\\n\\n\\tclass Solution \\n\\t{\\n\\tpublic:\\n\\n\\t\\tint calc(int i, vi &arr, vector<vvi> &dp, int d, int maxi)\\n\\t\\t{\\n\\t\\t  if(i == arr.size())\\n\\t\\t  {\\n\\t\\t\\tif(d == 0) return arr[maxi];\\n\\t\\t\\telse return 1e9;\\n\\t\\t  }\\n\\n\\t\\t  if(dp[i][maxi][d] != -1) return dp[i][maxi][d];\\n\\n\\t\\t  int pick = 1e9;\\n\\t\\t  if(d>0) pick = arr[maxi] + calc(i+1, arr, dp, d-1, i);\\n\\n\\t\\t  int not_pick;\\n\\t\\t  if(arr[maxi]<arr[i]) not_pick = calc(i+1, arr, dp, d, i);\\n\\t\\t  else not_pick = calc(i+1, arr, dp, d, maxi);\\n\\n\\t\\t  return dp[i][maxi][d] = min(pick, not_pick);\\n\\t\\t}\\n\\n\\t\\tint minDifficulty(vector<int>& arr, int d)\\n\\t\\t{\\n\\t\\t\\tint n = arr.size();\\n\\t\\t\\tvector<vvi> dp(n, vvi(n, vi(d, -1)) );\\n\\n\\t\\t\\tif(d>n) return -1;\\n\\t\\t\\telse return calc(1, arr, dp, d-1, 0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution \\n\\t{\\n\\tpublic:\\n\\n\\t\\tint calc(int i, vi &arr, vector<vvi> &dp, int d, int maxi)\\n\\t\\t{\\n\\t\\t  if(i == arr.size())\\n\\t\\t  {\\n\\t\\t\\tif(d == 0) return arr[maxi];\\n\\t\\t\\telse return 1e9;\\n\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 2709231,
                "title": "dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(int i,int d,vector<int>&dif,vector<vector<int>>&dp){\\n        int size=dif.size();\\n        if(i==size && d==0)return 0;\\n        if(i==size||d==0)return 1e9;\\n        if(dp[i][d]!=-1)return dp[i][d];\\n        int ans=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int j=i;j<size;j++){\\n            maxi=max(maxi,dif[j]);\\n            ans=min(ans,maxi+helper(j+1,d-1,dif,dp));\\n            \\n        }\\n        return dp[i][d]=ans;\\n        \\n        \\n    }\\n    int minDifficulty(vector<int>& jD, int d) {\\n        int n=jD.size();\\n        if(n<d)      \\n            return -1;\\n        vector<vector<int>>dp(n,vector<int>(d+1,-1));\\n        return helper(0,d,jD,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i,int d,vector<int>&dif,vector<vector<int>>&dp){\\n        int size=dif.size();\\n        if(i==size && d==0)return 0;\\n        if(i==size||d==0)return 1e9;\\n        if(dp[i][d]!=-1)return dp[i][d];\\n        int ans=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int j=i;j<size;j++){\\n            maxi=max(maxi,dif[j]);\\n            ans=min(ans,maxi+helper(j+1,d-1,dif,dp));\\n            \\n        }\\n        return dp[i][d]=ans;\\n        \\n        \\n    }\\n    int minDifficulty(vector<int>& jD, int d) {\\n        int n=jD.size();\\n        if(n<d)      \\n            return -1;\\n        vector<vector<int>>dp(n,vector<int>(d+1,-1));\\n        return helper(0,d,jD,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709019,
                "title": "c-dp-bottom-up-tc-o-n-n-d-fast-and-accepted",
                "content": "CODE : \\n-----------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int days) {\\n        int n=jobDifficulty.size();\\n        vector<vector<int>> dp(n+1,vector<int>(days+1,INT_MAX));\\n        dp[0][0]=0;\\n        for(int i=1;i<=n;i++){\\n            int maxi=jobDifficulty[i-1];\\n            for(int j=i-1;j>=0;j--){\\n                for(int d=1;d<=days;d++)\\n                    if(dp[j][d-1]!=INT_MAX)\\n                        dp[i][d]=min(dp[i][d],dp[j][d-1]+maxi);\\n                \\n                if(j-1>=0)\\n                    maxi=max(maxi,jobDifficulty[j-1]);\\n            }\\n        }\\n        \\n        return dp[n][days]==INT_MAX?-1:dp[n][days];\\n    }\\n};\\n```\\n\\nplz upvote; happy coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDifficulty(vector<int>& jobDifficulty, int days) {\\n        int n=jobDifficulty.size();\\n        vector<vector<int>> dp(n+1,vector<int>(days+1,INT_MAX));\\n        dp[0][0]=0;\\n        for(int i=1;i<=n;i++){\\n            int maxi=jobDifficulty[i-1];\\n            for(int j=i-1;j>=0;j--){\\n                for(int d=1;d<=days;d++)\\n                    if(dp[j][d-1]!=INT_MAX)\\n                        dp[i][d]=min(dp[i][d],dp[j][d-1]+maxi);\\n                \\n                if(j-1>=0)\\n                    maxi=max(maxi,jobDifficulty[j-1]);\\n            }\\n        }\\n        \\n        return dp[n][days]==INT_MAX?-1:dp[n][days];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708959,
                "title": "rust-dp-solution",
                "content": "```dp[n][k]```: ```n``` is the number of jobs; ```k``` means the number of days\\n\\n```rust\\nimpl Solution {\\n\\tpub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n\\t\\tlet (n, d) = (job_difficulty.len(), d as usize);\\n\\t\\tif n < d as usize { return -1; }\\n\\t\\tlet mut dp = vec![vec![i32::MAX;d + 1];n + 1];\\n\\t\\tdp[0][0] = 0;\\n\\t\\tfor i in 1..=n {\\n\\t\\t\\tlet mut max = 0;\\n\\t\\t\\tfor j in (0..i).rev() {\\n\\t\\t\\t\\tmax = max.max(job_difficulty[j]);\\n\\t\\t\\t\\tfor k in 0..d {\\n\\t\\t\\t\\t\\tif dp[j][k] < i32::MAX {\\n\\t\\t\\t\\t\\t\\tdp[i][k + 1] = dp[i][k + 1].min(dp[j][k] + max);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[n][d]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```dp[n][k]```\n```n```\n```k```\n```rust\\nimpl Solution {\\n\\tpub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\\n\\t\\tlet (n, d) = (job_difficulty.len(), d as usize);\\n\\t\\tif n < d as usize { return -1; }\\n\\t\\tlet mut dp = vec![vec![i32::MAX;d + 1];n + 1];\\n\\t\\tdp[0][0] = 0;\\n\\t\\tfor i in 1..=n {\\n\\t\\t\\tlet mut max = 0;\\n\\t\\t\\tfor j in (0..i).rev() {\\n\\t\\t\\t\\tmax = max.max(job_difficulty[j]);\\n\\t\\t\\t\\tfor k in 0..d {\\n\\t\\t\\t\\t\\tif dp[j][k] < i32::MAX {\\n\\t\\t\\t\\t\\t\\tdp[i][k + 1] = dp[i][k + 1].min(dp[j][k] + max);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[n][d]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708923,
                "title": "minimum-difficulty-of-a-job-schedule-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Minimum Difficulty of a Job Schedule \\uD83D\\uDD25 || Simple Fast and Easy || with Explanation\\n\\n## Solution - 1 Dp Bottom UP\\n\\n### Bottom-up DP\\n\\nState f(i,j):= minimized sum of sub-array maximum when splitting A[0..j] into i sub-arrays. (Use a shorter name A for jobDifficulty)\\nFunction f(i,j) = min{f(i-1,k) + max(A[k+1..j]), i - 2 <= k < j\\nInitialization f(1,j) = max(A[0..j]), f(i,j) = -1 if i > j + 1\\nAnswer is f(d,n-1)\\n\\n```dart\\nclass Solution {\\n// Runtime: 1382 ms, faster than 100.00% of Dart online submissions for Minimum Difficulty of a Job Schedule.\\n// Memory Usage: 152.5 MB, less than 100.00% of Dart online submissions for Minimum Difficulty of a Job Schedule.\\n\\n  int minDifficulty(List<int> jobDifficulty, int d) {\\n    if (jobDifficulty.length < d || d <= 0) {\\n      return -1;\\n    }\\n    int n = jobDifficulty.length;\\n    List<int> dp = List.filled(n, 0);\\n\\n    // initialization for d = 1\\n    dp[0] = jobDifficulty[0];\\n    for (int i = 1; i < n; i++) {\\n      dp[i] = max(dp[i - 1], jobDifficulty[i]);\\n    }\\n\\n    for (int i = 2; i <= d; i++) {\\n      for (int j = n - 1; j >= i - 1; j--) {\\n        // space optimization requires this\\n        dp[j] = double.maxFinite.toInt();\\n\\n        int lastMax = jobDifficulty[j]; // last sub-array\\'s max difficulty\\n        for (int k = j - 1; k >= i - 2; k--) {\\n          // assume second last sub-array ends at A[k]\\n          lastMax = max(lastMax, jobDifficulty[k + 1]); // max(A[k+1..j])\\n          dp[j] = min(dp[j], lastMax + dp[k]);\\n        }\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n}\\n```\\n\\n### Disclaimer - DART\\n\\nThere are many solution that i implemented Like Recursion, DP Top to Bottom and one and two others but most of them are end up with `TIME LIMIT EXCEED` error. Maybe the things are not very optimized. Only one solution work in my case Bottom Up DP.\\n\\n## Solution - 2 - Golang\\n\\n```go\\nvar mem [][]int\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minDifficulty(jd []int, d int) int {\\n\\tif d > len(jd) {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tmem = make([][]int, len(jd))\\n\\tfor i := 0; i < len(mem); i++ {\\n\\t\\tmem[i] = make([]int, d+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp(jd, 0, d)\\n}\\n\\nfunc dp(jd []int, start, day int) (ans int) {\\n\\tif mem[start][day] != -1 {\\n\\t\\treturn mem[start][day]\\n\\t}\\n\\tdefer func() { mem[start][day] = ans }()\\n\\n\\tif day == 1 {\\n\\t\\tans = jd[start]\\n\\t\\tfor i := start; i < len(jd); i++ {\\n\\t\\t\\tans = max(jd[i], ans)\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tcurMax := -1\\n\\tans = math.MaxInt32\\n\\tfor i := start; len(jd)-i > day-1; i++ {\\n\\t\\tcurMax = max(curMax, jd[i])\\n\\t\\tresult := curMax + dp(jd, i+1, day-1)\\n\\t\\tans = min(ans, result)\\n\\t}\\n\\treturn ans\\n}\\n\\n```\\n## [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```dart\\nclass Solution {\\n// Runtime: 1382 ms, faster than 100.00% of Dart online submissions for Minimum Difficulty of a Job Schedule.\\n// Memory Usage: 152.5 MB, less than 100.00% of Dart online submissions for Minimum Difficulty of a Job Schedule.\\n\\n  int minDifficulty(List<int> jobDifficulty, int d) {\\n    if (jobDifficulty.length < d || d <= 0) {\\n      return -1;\\n    }\\n    int n = jobDifficulty.length;\\n    List<int> dp = List.filled(n, 0);\\n\\n    // initialization for d = 1\\n    dp[0] = jobDifficulty[0];\\n    for (int i = 1; i < n; i++) {\\n      dp[i] = max(dp[i - 1], jobDifficulty[i]);\\n    }\\n\\n    for (int i = 2; i <= d; i++) {\\n      for (int j = n - 1; j >= i - 1; j--) {\\n        // space optimization requires this\\n        dp[j] = double.maxFinite.toInt();\\n\\n        int lastMax = jobDifficulty[j]; // last sub-array\\'s max difficulty\\n        for (int k = j - 1; k >= i - 2; k--) {\\n          // assume second last sub-array ends at A[k]\\n          lastMax = max(lastMax, jobDifficulty[k + 1]); // max(A[k+1..j])\\n          dp[j] = min(dp[j], lastMax + dp[k]);\\n        }\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n}\\n```\n```go\\nvar mem [][]int\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minDifficulty(jd []int, d int) int {\\n\\tif d > len(jd) {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tmem = make([][]int, len(jd))\\n\\tfor i := 0; i < len(mem); i++ {\\n\\t\\tmem[i] = make([]int, d+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp(jd, 0, d)\\n}\\n\\nfunc dp(jd []int, start, day int) (ans int) {\\n\\tif mem[start][day] != -1 {\\n\\t\\treturn mem[start][day]\\n\\t}\\n\\tdefer func() { mem[start][day] = ans }()\\n\\n\\tif day == 1 {\\n\\t\\tans = jd[start]\\n\\t\\tfor i := start; i < len(jd); i++ {\\n\\t\\t\\tans = max(jd[i], ans)\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tcurMax := -1\\n\\tans = math.MaxInt32\\n\\tfor i := start; len(jd)-i > day-1; i++ {\\n\\t\\tcurMax = max(curMax, jd[i])\\n\\t\\tresult := curMax + dp(jd, i+1, day-1)\\n\\t\\tans = min(ans, result)\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708792,
                "title": "dp-optimal-solution-w-complete-explanation-c-easy-to-understand",
                "content": "##  Minimum Difficulty of a Job Schedule - OPTIMAL SOLUTION w/ COMPLETE EXPLANATION ||  \\u2705[ C++ ] \\u2705|| EASY TO UNDERSTAND || \\n\\n***Please upvote if you like it.***\\n\\n### EXPLANATION:\\n![image](https://assets.leetcode.com/users/images/75073a83-5035-4150-8983-4957c253f9fa_1665899038.5160427.png)\\n![image](https://assets.leetcode.com/users/images/d07b3d16-9205-41cb-94a0-1c4075c6cd1a_1665899070.2181025.png)\\n![image](https://assets.leetcode.com/users/images/9539bc87-5770-411a-8a24-7432f9d139e8_1665899083.5413651.png)\\n![image](https://assets.leetcode.com/users/images/e9798814-fd2a-4f78-a182-50bcad769b5f_1665899095.3326905.png)\\n\\n\\n\\n##### Time Complexity : O(N*N)  ---- For each index recursion function calls (Explained in explanation -- must see)\\n#### Space Complexity : O(N x d) + O(N x N) ---dp vector and auxiliary space for recursion\\n##\\n### </>CODE :\\n### \\n```\\n #define ll long long\\n\\nclass Solution\\n{\\n    ll dp[301][1002];\\n    ll utility(int i, int d, vector<int> &a)\\n    {\\n        if (d <= 0 && i >= a.size()) // CASE 1\\n        {\\n            return 0;\\n        }\\n        if (d <= 0) // CASE 2\\n        {\\n            return 1e8;\\n        }\\n\\n        if (i >= a.size()) // CASE 3\\n        {\\n            return 1e8;\\n        }\\n\\n        if (dp[i][d] != -1)\\n        {\\n            return dp[i][d];\\n        }\\n\\n        ll maxi = -1;\\n        ll ans = 1e8;\\n\\n        for (int j = i; j < a.size(); j++)\\n        {\\n            maxi = max((ll)a[j], maxi);\\n            ll take = maxi + utility(j + 1, d - 1, a);\\n            ans = min(ans, take);\\n        }\\n\\n        return dp[i][d] = ans;\\n    }\\n\\npublic:\\n    int minDifficulty(vector<int> &jobDifficulty, int d)\\n    {\\n        memset(dp, -1, sizeof dp);\\n        int n = jobDifficulty.size();\\n        if (d > n)\\n        {\\n            return -1;\\n        }\\n\\n        return utility(0, d, jobDifficulty);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/800209cd-0e22-4f85-9ec4-7c27f37afc0e_1665899307.7445788.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n #define ll long long\\n\\nclass Solution\\n{\\n    ll dp[301][1002];\\n    ll utility(int i, int d, vector<int> &a)\\n    {\\n        if (d <= 0 && i >= a.size()) // CASE 1\\n        {\\n            return 0;\\n        }\\n        if (d <= 0) // CASE 2\\n        {\\n            return 1e8;\\n        }\\n\\n        if (i >= a.size()) // CASE 3\\n        {\\n            return 1e8;\\n        }\\n\\n        if (dp[i][d] != -1)\\n        {\\n            return dp[i][d];\\n        }\\n\\n        ll maxi = -1;\\n        ll ans = 1e8;\\n\\n        for (int j = i; j < a.size(); j++)\\n        {\\n            maxi = max((ll)a[j], maxi);\\n            ll take = maxi + utility(j + 1, d - 1, a);\\n            ans = min(ans, take);\\n        }\\n\\n        return dp[i][d] = ans;\\n    }\\n\\npublic:\\n    int minDifficulty(vector<int> &jobDifficulty, int d)\\n    {\\n        memset(dp, -1, sizeof dp);\\n        int n = jobDifficulty.size();\\n        if (d > n)\\n        {\\n            return -1;\\n        }\\n\\n        return utility(0, d, jobDifficulty);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708635,
                "title": "swift-dp-solution-base-on-hints",
                "content": "dp[x][y] stands for the best solution to separate first (x + 1) tasks into (y + 1) days.\\n```\\nclass Solution {\\n    func minDifficulty(_ jobDifficulty: [Int], _ d: Int) -> Int {\\n        guard jobDifficulty.count >= d else { return -1}\\n        guard jobDifficulty.count > 1 else { return jobDifficulty[0] }\\n        let dpRow = Array(repeating: Int.max, count: d)\\n        var dp = Array(repeating: dpRow, count: jobDifficulty.count)\\n        dp[0][0] = jobDifficulty[0]\\n        for i in 1..<jobDifficulty.count {\\n            let minD = max(0, d - jobDifficulty.count + i)\\n            let maxD = min(d - 1, i)\\n            for j in minD...maxD {\\n                if j == 0 {\\n                    dp[i][j] = max(dp[i - 1][j], jobDifficulty[i])\\n                    continue\\n                }\\n                var maxDifficulty = 0\\n                for k in stride(from: i, through: j, by: -1) {\\n                    maxDifficulty = max(maxDifficulty, jobDifficulty[k])\\n                    dp[i][j] = min(dp[i][j], dp[k - 1][j - 1] + maxDifficulty)\\n                }\\n            }\\n        }\\n        return dp[jobDifficulty.count - 1][d - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func minDifficulty(_ jobDifficulty: [Int], _ d: Int) -> Int {\\n        guard jobDifficulty.count >= d else { return -1}\\n        guard jobDifficulty.count > 1 else { return jobDifficulty[0] }\\n        let dpRow = Array(repeating: Int.max, count: d)\\n        var dp = Array(repeating: dpRow, count: jobDifficulty.count)\\n        dp[0][0] = jobDifficulty[0]\\n        for i in 1..<jobDifficulty.count {\\n            let minD = max(0, d - jobDifficulty.count + i)\\n            let maxD = min(d - 1, i)\\n            for j in minD...maxD {\\n                if j == 0 {\\n                    dp[i][j] = max(dp[i - 1][j], jobDifficulty[i])\\n                    continue\\n                }\\n                var maxDifficulty = 0\\n                for k in stride(from: i, through: j, by: -1) {\\n                    maxDifficulty = max(maxDifficulty, jobDifficulty[k])\\n                    dp[i][j] = min(dp[i][j], dp[k - 1][j - 1] + maxDifficulty)\\n                }\\n            }\\n        }\\n        return dp[jobDifficulty.count - 1][d - 1]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708545,
                "title": "passed-but-slow-sometimes-it-get-tle-an-easy-and-short-implementation-to-me",
                "content": "Passed but slow, sometimes it gets TLE... has room to imporve.\\nHowever, I just use a easier implementaion to me ,  the idea is cut or not cut at this moment.\\n\\nif not use the cache there will be a 3 nested for loop.\\n\\nAlso the max(J[start:n]) could be precaculated .\\n```\\nclass Solution:\\n    def minDifficulty(self, J: List[int], d: int) -> int:\\n        @cache\\n        def dp(cut, start, p):\\n            if cut==d-1:\\n                if start<n: \\n                    return max(J[start:n])\\n                return inf\\n            if cut >= d or start>=n or p>n:\\n                return inf\\n                 \\n            not_cut = dp(cut, start, p+1)\\n            do_cut = dp(cut+1, p, p+1) +  max(J[start:p])\\n            return min(not_cut, do_cut)\\n        \\n        n = len(J)\\n        ans = dp(0, 0, 1) \\n        return ans if ans!=inf else -1\\n```\\n![image](https://assets.leetcode.com/users/images/12865d7b-16d4-4d70-bd60-1f9bf976f079_1665896297.9105372.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDifficulty(self, J: List[int], d: int) -> int:\\n        @cache\\n        def dp(cut, start, p):\\n            if cut==d-1:\\n                if start<n: \\n                    return max(J[start:n])\\n                return inf\\n            if cut >= d or start>=n or p>n:\\n                return inf\\n                 \\n            not_cut = dp(cut, start, p+1)\\n            do_cut = dp(cut+1, p, p+1) +  max(J[start:p])\\n            return min(not_cut, do_cut)\\n        \\n        n = len(J)\\n        ans = dp(0, 0, 1) \\n        return ans if ans!=inf else -1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1647236,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1570289,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1566171,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1568715,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1570377,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1575316,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1574729,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1573385,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1574447,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1573387,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1647236,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1570289,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1566171,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1568715,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1570377,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1575316,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1574729,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1573385,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1574447,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 1573387,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "talk about daily streak enders"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "was that too hard for you?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "my current daily streak is 187"
                    },
                    {
                        "username": "drmyr",
                        "content": "Can someone provide additional instructions for this prompt? I have read it a number of times, but as near as I can tell the instructions are incorrect and incomplete. The instructions do not describe any condition for determining what amount of work can be done on a given day. In example 1, [6,5,4,3,2] was allocated to day 1, and [1] was allocated to day 2, but why? Why could not all tasks be allocated to day 1 (nothing in the input limits work-units per day)? Example 1 also indicates that the total difficulty was \\'6\\', but the instructions say that \"difficulty of a job schedule is the sum of difficulties of each day\", so Example 1\\'s difficulty should be 6+5+4+3+2=20."
                    },
                    {
                        "username": "jukov",
                        "content": "Typical leetcode problem description"
                    },
                    {
                        "username": "vkmaurya",
                        "content": "firstly thing to understand - you have to take d subarray from the array and then add max values of subarray \\nmain approach is we have to split or we can say we have to choose that subarrays where all max values Sum is Minimum\\nso clearly you can se in [6,5,4,3,2,1] this minimum sum of 2 subarray is max[6,5,4,3,2] + max[1] = 6+1 = 7 "
                    },
                    {
                        "username": "jayant2k1",
                        "content": "Problem - you have to divide jobs into d days and pick job with maximum difficulty for each day and sum all picked difficulty and that sum should be minimum.\n\n# -> You can't leave any day without scheduling any task on that day.\n\nEg. jobDifficulty = [6,5,4,3,2,1], d = 2\n\nYou can divide it like,\n\nday 1 = [6], day2 = [5,4,3,2,1] maximum in both days is 6, 5 and sum = 11.\n\nAnother division\nday 1 = [6,5,4], day 2 = [3,2,1] maximum in both days is  6 + 3 = 9\n\nAnother optimal division of jobs\nday 1 = [6,5,4,3,2], day 2 = [1] maximum in day 1 = 6, and maximum in day 2 = 1, and sum of both is 6+1 = 7(this is the minimum sum that you can achieve).\n\nHope it will help."
                    },
                    {
                        "username": "darkpotter",
                        "content": "Hi Guys,\\n\\nI wanted to ask if this problem can be solved by binary search? like 1011. Capacity To Ship Packages Within D Days\\n\\nSince, it also looks like similar problem.\\n\\nCan anyone tell, why it cannot be done ?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "The index of the element is playing a part , so if you sort the array , you will lose the index info on them. "
                    },
                    {
                        "username": "Shriprasad18",
                        "content": "1. **First day you can finish the first 5 jobs, total difficulty = 6.** \\nHow this is calculated in Example 1 ?\\n2. What is difference between Job and Task ?\\n3. **The difficulty of a job schedule is the sum of difficulties of each day of the d days** - What does it mean? Can someone explain me with Example 1 or any example\\n"
                    },
                    {
                        "username": "official_mrads",
                        "content": "1. Because max difficulty of job in array (Day 1 ) -> [6,5,4,3,2] is 6, and similarly in(Day2 ) [1] is 1.\\n\\n2. Now you have 6 , 1 (Max difficulty of job in Day1 , Day2)\\n3. Difficulty of job scheduled = Day1 + Day2 => 6\\n"
                    },
                    {
                        "username": "rwagdyrizkalla",
                        "content": "Why is the output of this testcase is 1803? Shouldn\\'t it be 1876?\\n\\n[186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360]\\n4"
                    },
                    {
                        "username": "LordShubham",
                        "content": "[@Firebelias12](/Firebelias12) [@rikkiprince](/rikkiprince) [@BamesJorn](/BamesJorn)  Ah, I get it now."
                    },
                    {
                        "username": "rikkiprince",
                        "content": "[@LordShubham](/LordShubham) Nah, you have to do them in order. There\\'s no two 1s next to each other, so you can only do one day of 1.\\n\\nThe split would be: `[7,1,7,1], [7], [1]` which derives down to `7 + 7+ 1`"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "[@LordShubham](/LordShubham) you can\\'t shuffle the numbers in original list "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "[@LordShubham](/LordShubham) You have to do tasks in order of index."
                    },
                    {
                        "username": "LordShubham",
                        "content": "Take a look at this test case too\\n [7, 1, 7, 1, 7, 1]       d = 3\\nExpected result is: 15\\nWhat it should be actually is: 9\\n\\nExplaintion: You can do 2 jobs of [1] in 2 days and on the third day you can do the rest and the minimum difficulty is:  1 + 1 + 7 = 9\\n\\nHow did they fuck up the test case so badly?"
                    },
                    {
                        "username": "yelun",
                        "content": "It makes sense that for a DP matrix with  N * D states, we will need N tries to find the optimal state each try, resulting in NND.\\n\\nBut from looking at the code, how can this be inferred or deduced?\\n\\nThanks!"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "by NND do you mean the complexity ? "
                    },
                    {
                        "username": "skandari",
                        "content": "we store two values in each DP cell.\\n**dp[i][j] = minimum difficulty till ith day with jth job | (difficulty till previous day, today\\'s difficulty)**\\n\\n\\n\\ndp[i][j] = min(dp[i-1][j-1][0] + dp[i-1][j-1][1] + jobDifficulty[j], dp[i] [j-1],\\n\\t\\t\\t\\t\\t  dp[i][j-1][0] + max(dp[i][j-1][1], jobDifficulty[j])\\n\\t\\t\\t\\t\\t  )\\nThis is Basic Knapsack with two possibilities:\\n1. Jth job is the first job of the day (we look in previous row)\\n2. Jth job is not first job of the day (we look in same row)\\n\\nThis is passing 15/32 test cases can someone please point out whats the flaw."
                    },
                    {
                        "username": "sharmasbeta",
                        "content": "Question never mentions that scheduling all the jobs is necessary. If d=3 and array is [1,1,1,4] then the answer should be 3, right?"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "nope you have to schedule all jobs"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Example 1 implies that all the jobs should get scheduled, doesn\\'t it?"
                    },
                    {
                        "username": "hpreethi",
                        "content": "For the below input, can you explain how the output is 1803?\\n\\n186,398,479,206,885,423,805,112,925,656,16,932,740,292,671,360\\n\\nCan you explain what tasks to combine on which days?\\n"
                    },
                    {
                        "username": "emdadul_islam",
                        "content": "max(186) + max(398, 479) + max(206) + max(all the rest of the items, which is 932)\\n= 186 + 479 + 206 + 932\\n= 1803\\n"
                    },
                    {
                        "username": "c8b2b9ef",
                        "content": "I bet should be possible, if we can store just one other piece of information:  the number of jobs in last day that led to optimal solution. \\n\\nIf our dp defnition is  `dp[d, n]` := minimum difficulty schedule to do `n` jobs in `d` days, then\\n\\n\\n1) if we do all prior `n-1` jobs in prior `d-1` days, and then do just `n`\\'th job on the last `d`\\'th day, recurrence becomes:\\n`dp[d,n] = d[d-1,n-1] + jobDifficulty[n];`\\neasy;\\n\\n\\nalternatively,\\n\\n2) if we try do the last `n`\\'th job also in the same last day `d`, \\nthen it will depend on whether last job\\'s difficulty is greater than any other job\\'s difficulty in that last day, \\nhence we get two cases:\\n\\n\\t2a) `jobDifficulty[n]  >  jobDifficulty[j]`   for *any* job `j` from the last day, \\n\\tthen recurrence becomes:  `dp[d, n] = dp[d-1, n - <# jobs last day>] + jobDifficulty[n];`\\n\\t\\n\\t2b) `jobDifficulty[n] <= jobDifficulty[j]` for *some* job `j` from the last day, \\n\\tthen the last job does not matter, and minimum difficulty schedule remains the same, i.e. `dp[d,n] = dp[d, n-1]`\\n\\teasy\\n\\nI think should be possible to code this up bottom-up. Thoughts?\\n\\n"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "yes"
                    }
                ]
            }
        ]
    },
    {
        "title": "Latest Time by Replacing Hidden Digits",
        "question_content": "<p>You are given a string <code>time</code> in the form of <code> hh:mm</code>, where some of the digits in the string are hidden (represented by <code>?</code>).</p>\n\n<p>The valid times are those inclusively between <code>00:00</code> and <code>23:59</code>.</p>\n\n<p>Return <em>the latest valid time you can get from</em> <code>time</code><em> by replacing the hidden</em> <em>digits</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = &quot;2?:?0&quot;\n<strong>Output:</strong> &quot;23:50&quot;\n<strong>Explanation:</strong> The latest hour beginning with the digit &#39;2&#39; is 23 and the latest minute ending with the digit &#39;0&#39; is 50.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = &quot;0?:3?&quot;\n<strong>Output:</strong> &quot;09:39&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = &quot;1?:22&quot;\n<strong>Output:</strong> &quot;19:22&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>time</code> is in the format <code>hh:mm</code>.</li>\n\t<li>It is guaranteed that you can produce a valid time from the given string.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1032018,
                "title": "c-4-rules",
                "content": "```cpp\\nstring maximumTime(string time) {\\n    time[0] = time[0] != \\'?\\' ? time[0] : (time[1] == \\'?\\' || time[1] <= \\'3\\') ? \\'2\\' : \\'1\\';\\n    time[1] = time[1] != \\'?\\' ? time[1] : time[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n    time[3] = time[3] != \\'?\\' ? time[3] : \\'5\\';\\n    time[4] = time[4] != \\'?\\' ? time[4] : \\'9\\';\\n    return time;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring maximumTime(string time) {\\n    time[0] = time[0] != \\'?\\' ? time[0] : (time[1] == \\'?\\' || time[1] <= \\'3\\') ? \\'2\\' : \\'1\\';\\n    time[1] = time[1] != \\'?\\' ? time[1] : time[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n    time[3] = time[3] != \\'?\\' ? time[3] : \\'5\\';\\n    time[4] = time[4] != \\'?\\' ? time[4] : \\'9\\';\\n    return time;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032093,
                "title": "java-very-elegant-solution-o-1",
                "content": "```\\n\\nclass Solution {\\n    public String maximumTime(String time) {     \\n        char[] times = time.toCharArray();\\n        if(times[0] == \\'?\\') {\\n            times[0] = times[1] <= \\'3\\' || times[1] == \\'?\\' ? \\'2\\' : \\'1\\';\\n        }\\n        \\n        if(times[1] == \\'?\\') {\\n            times[1] = times[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n        \\n        if(times[3] == \\'?\\') {\\n            times[3] = \\'5\\';\\n        }\\n        \\n        if(times[4] == \\'?\\') {\\n            times[4] = \\'9\\';\\n        }\\n        \\n        return new String(times);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public String maximumTime(String time) {     \\n        char[] times = time.toCharArray();\\n        if(times[0] == \\'?\\') {\\n            times[0] = times[1] <= \\'3\\' || times[1] == \\'?\\' ? \\'2\\' : \\'1\\';\\n        }\\n        \\n        if(times[1] == \\'?\\') {\\n            times[1] = times[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n        \\n        if(times[3] == \\'?\\') {\\n            times[3] = \\'5\\';\\n        }\\n        \\n        if(times[4] == \\'?\\') {\\n            times[4] = \\'9\\';\\n        }\\n        \\n        return new String(times);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032030,
                "title": "python3-if-elif",
                "content": "**Algo**\\nReplace `?` based on its location and value. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n        for i in range(len(time)): \\n            if time[i] == \"?\": \\n                if i == 0: time[i] = \"2\" if time[i+1] in \"?0123\" else \"1\"\\n                elif i == 1: time[i] = \"3\" if time[0] == \"2\" else \"9\"\\n                elif i == 3: time[i] = \"5\"\\n                else: time[i] = \"9\"\\n        return \"\".join(time)\\n```\\n\\n**Analysis**\\n`O(1)` for fixed size problem",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n        for i in range(len(time)): \\n            if time[i] == \"?\": \\n                if i == 0: time[i] = \"2\" if time[i+1] in \"?0123\" else \"1\"\\n                elif i == 1: time[i] = \"3\" if time[0] == \"2\" else \"9\"\\n                elif i == 3: time[i] = \"5\"\\n                else: time[i] = \"9\"\\n        return \"\".join(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032285,
                "title": "java-python-3-convert-to-char-array-list-then-process",
                "content": "\\n```java\\n    public String maximumTime(String time) {\\n        char[] a = time.toCharArray();\\n        for (int i = 0; i < 5; ++i) {\\n            if (a[i] == \\'?\\') {\\n                if (i == 0) {\\n                    a[i] = a[1] <= \\'3\\' || a[1] == \\'?\\' ? \\'2\\' : \\'1\\';\\n                }else if (i == 1) {\\n                    a[i] = a[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n                }else if (i == 3) {\\n                    a[i] = \\'5\\';\\n                }else if (i == 4) {\\n                    a[i] = \\'9\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(a);\\n    }\\n```\\n```python\\n    def maximumTime(self, time: str) -> str:\\n        ls = list(time)\\n        for i, c in enumerate(ls):\\n            if c == \\'?\\':\\n                if i == 0:\\n                    ls[i] = \\'2\\' if ls[1] <= \\'3\\' or ls[1] == \\'?\\' else \\'1\\'\\n                elif i == 1:\\n                    ls[i] = \\'3\\' if ls[0] == \\'2\\' else \\'9\\'\\n                elif i == 3:\\n                    ls[i] = \\'5\\'\\n                elif i == 4:\\n                    ls[i] = \\'9\\'\\n        return \\'\\'.join(ls) \\n```",
                "solutionTags": [],
                "code": "```java\\n    public String maximumTime(String time) {\\n        char[] a = time.toCharArray();\\n        for (int i = 0; i < 5; ++i) {\\n            if (a[i] == \\'?\\') {\\n                if (i == 0) {\\n                    a[i] = a[1] <= \\'3\\' || a[1] == \\'?\\' ? \\'2\\' : \\'1\\';\\n                }else if (i == 1) {\\n                    a[i] = a[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n                }else if (i == 3) {\\n                    a[i] = \\'5\\';\\n                }else if (i == 4) {\\n                    a[i] = \\'9\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(a);\\n    }\\n```\n```python\\n    def maximumTime(self, time: str) -> str:\\n        ls = list(time)\\n        for i, c in enumerate(ls):\\n            if c == \\'?\\':\\n                if i == 0:\\n                    ls[i] = \\'2\\' if ls[1] <= \\'3\\' or ls[1] == \\'?\\' else \\'1\\'\\n                elif i == 1:\\n                    ls[i] = \\'3\\' if ls[0] == \\'2\\' else \\'9\\'\\n                elif i == 3:\\n                    ls[i] = \\'5\\'\\n                elif i == 4:\\n                    ls[i] = \\'9\\'\\n        return \\'\\'.join(ls) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1032518,
                "title": "java-c-explained-faster-than-100",
                "content": "# **CPP**\\n\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions\\nMemory Usage: 5.9 MB, less than 75.00% of C++ online submissions**\\n\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        //for time[0]\\n        //if both characters of hour is ?, then hour is 23 then time[0] should be \\'2\\'(\"??:3?)\".\\n        //if 2nd character of hour is <= 3, then hour can be in 20s  then time[0] should be \\'2\\'.\\n        //if 2nd character of hour is >3, then hour can only be in 10s  then time[0] should be \\'1\\'.\\n        if(time[0]==\\'?\\')\\n            time[0]= (time[1]<=\\'3\\' || time[1]==\\'?\\') ? \\'2\\' : \\'1\\';\\n        //if 1st character of hour is 0 or 1, then hour can be 09 or 19 then time[1] should be \\'9\\'.\\n        //if 1st character of hour is 2, then hour can be 23 then time[1] should be \\'3\\'.\\n        if(time[1]==\\'?\\')\\n            time[1]= time[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n        //if both characters of minute is ? then minute is 59, or only 4th character is ? then 5_ so time[3] is always \\'5\\'.\\n        if(time[3]==\\'?\\')\\n            time[3]=\\'5\\';\\n        //if 2nd character of minute is ?, then time[4] is \\'9\\'.\\n        if(time[4]==\\'?\\')\\n            time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```\\n\\n# **JAVA**\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions\\nMemory Usage: 37.2 MB, less than 75.00% of Java online submissions**\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] times = time.toCharArray();\\n        //for times[0]\\n        //if both characters of hour is ?, then hour is 23 then times[0] should be \\'2\\'(\"??:3?)\".\\n        //if 2nd character of hour is <= 3, then hour can be in 20s  then times[0] should be \\'2\\'.\\n        //if 2nd character of hour is >3, then hour can only be in 10s  then times[0] should be \\'1\\'.\\n        if(times[0]==\\'?\\')\\n            times[0]= (times[1]<=\\'3\\' || times[1]==\\'?\\') ? \\'2\\' : \\'1\\';\\n        //if 1st character of hour is 0 or 1, then hour can be 09 or 19 then times[1] should be \\'9\\'.\\n        //if 1st character of hour is 2, then hour can be 23 then times[1] should be \\'3\\'.\\n        if(times[1]==\\'?\\')\\n            times[1]= times[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n        //if both characters of minute is ? then minute is 59, or only 4th character is ? then 5_ so times[3] is always \\'5\\'.\\n        if(times[3]==\\'?\\')\\n            times[3]=\\'5\\';\\n        //if 2nd character of minute is ?, then times[4] is \\'9\\'.\\n        if(times[4]==\\'?\\')\\n            times[4]=\\'9\\';\\n        return new String(times);\\n    }\\n}\\n```\\n\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        //for time[0]\\n        //if both characters of hour is ?, then hour is 23 then time[0] should be \\'2\\'(\"??:3?)\".\\n        //if 2nd character of hour is <= 3, then hour can be in 20s  then time[0] should be \\'2\\'.\\n        //if 2nd character of hour is >3, then hour can only be in 10s  then time[0] should be \\'1\\'.\\n        if(time[0]==\\'?\\')\\n            time[0]= (time[1]<=\\'3\\' || time[1]==\\'?\\') ? \\'2\\' : \\'1\\';\\n        //if 1st character of hour is 0 or 1, then hour can be 09 or 19 then time[1] should be \\'9\\'.\\n        //if 1st character of hour is 2, then hour can be 23 then time[1] should be \\'3\\'.\\n        if(time[1]==\\'?\\')\\n            time[1]= time[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n        //if both characters of minute is ? then minute is 59, or only 4th character is ? then 5_ so time[3] is always \\'5\\'.\\n        if(time[3]==\\'?\\')\\n            time[3]=\\'5\\';\\n        //if 2nd character of minute is ?, then time[4] is \\'9\\'.\\n        if(time[4]==\\'?\\')\\n            time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] times = time.toCharArray();\\n        //for times[0]\\n        //if both characters of hour is ?, then hour is 23 then times[0] should be \\'2\\'(\"??:3?)\".\\n        //if 2nd character of hour is <= 3, then hour can be in 20s  then times[0] should be \\'2\\'.\\n        //if 2nd character of hour is >3, then hour can only be in 10s  then times[0] should be \\'1\\'.\\n        if(times[0]==\\'?\\')\\n            times[0]= (times[1]<=\\'3\\' || times[1]==\\'?\\') ? \\'2\\' : \\'1\\';\\n        //if 1st character of hour is 0 or 1, then hour can be 09 or 19 then times[1] should be \\'9\\'.\\n        //if 1st character of hour is 2, then hour can be 23 then times[1] should be \\'3\\'.\\n        if(times[1]==\\'?\\')\\n            times[1]= times[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n        //if both characters of minute is ? then minute is 59, or only 4th character is ? then 5_ so times[3] is always \\'5\\'.\\n        if(times[3]==\\'?\\')\\n            times[3]=\\'5\\';\\n        //if 2nd character of minute is ?, then times[4] is \\'9\\'.\\n        if(times[4]==\\'?\\')\\n            times[4]=\\'9\\';\\n        return new String(times);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032084,
                "title": "python3-5-lines-easy-solution-o-1",
                "content": "match time from 23:59 to 00:00\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        for h in range(24)[::-1]:\\n            for m in range(60)[::-1]:\\n                s = f\\'{h:02d}:{m:02d}\\'\\n                if all(a == b or b == \\'?\\' for a, b in zip(s, time)):\\n                       return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def maximumTime(self, time: str) -> str:\\n        for h in range(24)[::-1]:\\n            for m in range(60)[::-1]:\\n                s = f\\'{h:02d}",
                "codeTag": "Java"
            },
            {
                "id": 1032173,
                "title": "python-short",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        maxTime = \"23:59\" if time[0] in \"?2\" and time[1] in \"?0123\" else \"19:59\"\\n        return \"\".join(t if t != \"?\" else m for t, m in zip(time, maxTime))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        maxTime = \"23:59\" if time[0] in \"?2\" and time[1] in \"?0123\" else \"19:59\"\\n        return \"\".join(t if t != \"?\" else m for t, m in zip(time, maxTime))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915764,
                "title": "easiest-simplest-python3-solution-with-if-conditions-100-faster-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        s=list(time)\\n        for i in range(len(s)):\\n            if s[i]==\\'?\\':\\n                if i==0:\\n                    if s[i+1] in [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'?\\']:\\n                        s[i]=\\'2\\'\\n                    else:\\n                        s[i]=\\'1\\'\\n                elif i==1:\\n                    if s[i-1]==\\'1\\' or s[i-1]==\\'0\\':\\n                        s[i]=\\'9\\'\\n                    else:\\n                        s[i]=\\'3\\'\\n                elif i==3:\\n                    s[i]=\\'5\\'\\n                elif i==4:\\n                    s[i]=\\'9\\'\\n        return \\'\\'.join(s)\\n```\\n***Please Upvote, if you found my solution helpful***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        s=list(time)\\n        for i in range(len(s)):\\n            if s[i]==\\'?\\':\\n                if i==0:\\n                    if s[i+1] in [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'?\\']:\\n                        s[i]=\\'2\\'\\n                    else:\\n                        s[i]=\\'1\\'\\n                elif i==1:\\n                    if s[i-1]==\\'1\\' or s[i-1]==\\'0\\':\\n                        s[i]=\\'9\\'\\n                    else:\\n                        s[i]=\\'3\\'\\n                elif i==3:\\n                    s[i]=\\'5\\'\\n                elif i==4:\\n                    s[i]=\\'9\\'\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032214,
                "title": "javascript-simple-solution",
                "content": "```\\nvar maximumTime = function(time) {\\n    time = time.split(\\'\\')\\n    if (time[0] === \"?\") time[0] = time[1] > 3 ? \"1\" : \"2\"\\n    if (time[1] === \"?\") time[1] = time[0] > 1 ? \"3\" : \"9\"\\n    if (time[3] === \"?\") time[3] = \"5\"\\n    if (time[4] === \"?\") time[4] = \"9\"\\n    return time.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTime = function(time) {\\n    time = time.split(\\'\\')\\n    if (time[0] === \"?\") time[0] = time[1] > 3 ? \"1\" : \"2\"\\n    if (time[1] === \"?\") time[1] = time[0] > 1 ? \"3\" : \"9\"\\n    if (time[3] === \"?\") time[3] = \"5\"\\n    if (time[4] === \"?\") time[4] = \"9\"\\n    return time.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032182,
                "title": "java-self-explained-solution",
                "content": "```\\n    public String maximumTime(String time) {\\n        char[] c = time.toCharArray();\\n        for (int i = 4; i >= 0; i--) {\\n\\t\\t\\t if (c[i] == \\'?\\') {\\n                if (i == 0) {\\n                    if (c[1] - \\'0\\' >= 4) {\\n                        c[0] = \\'1\\';\\n                    } else {\\n                        c[0] = \\'2\\';\\n                    }\\n                } else if (i == 1) {\\n                    if (c[0] - \\'0\\' < 2) {\\n                        c[i] = \\'9\\';\\n                    } else {\\n                        c[i] = \\'3\\';\\n                    }\\n                } else if (i == 3) {\\n                    c[i] = \\'5\\';\\n                } else if (i == 4) {\\n                    c[i] = \\'9\\';\\n                }\\n                    \\n            }\\n        }\\n        return String.valueOf(c);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String maximumTime(String time) {\\n        char[] c = time.toCharArray();\\n        for (int i = 4; i >= 0; i--) {\\n\\t\\t\\t if (c[i] == \\'?\\') {\\n                if (i == 0) {\\n                    if (c[1] - \\'0\\' >= 4) {\\n                        c[0] = \\'1\\';\\n                    } else {\\n                        c[0] = \\'2\\';\\n                    }\\n                } else if (i == 1) {\\n                    if (c[0] - \\'0\\' < 2) {\\n                        c[i] = \\'9\\';\\n                    } else {\\n                        c[i] = \\'3\\';\\n                    }\\n                } else if (i == 3) {\\n                    c[i] = \\'5\\';\\n                } else if (i == 4) {\\n                    c[i] = \\'9\\';\\n                }\\n                    \\n            }\\n        }\\n        return String.valueOf(c);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711217,
                "title": "c-easy-if-else",
                "content": "Simple If-else\\napproch is first make the hour as big as possible\\nthen same for the minutes\\n\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string t) {\\n        if(t[0]==\\'?\\' && t[1]==\\'?\\')\\n        {\\n            t[0]=\\'2\\';\\n            t[1]=\\'3\\';\\n        }\\n        if(t[0]==\\'?\\')\\n        {\\n            if(t[1]<=\\'0\\')\\n                t[0]=\\'2\\';\\n            else if(t[1]<=\\'1\\')\\n                t[0]=\\'2\\';\\n            else if(t[1]<=\\'2\\')\\n                t[0]=\\'2\\';\\n            else if(t[1]<=\\'3\\')\\n                t[0]=\\'2\\';\\n            else \\n                t[0]=\\'1\\';\\n        }\\n        if(t[1]==\\'?\\')\\n        {\\n            if(t[0]==\\'2\\')\\n                t[1]=\\'3\\';\\n            else \\n                t[1]=\\'9\\';\\n        }\\n        if(t[3]==\\'?\\' && t[4]==\\'?\\')\\n        {\\n            t[3]=\\'5\\';\\n            t[4]=\\'9\\';\\n        }\\n        if(t[3]==\\'?\\')\\n        {\\n            t[3]=\\'5\\';\\n        }\\n        if(t[4]==\\'?\\')\\n        {\\n            t[4]=\\'9\\';\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string t) {\\n        if(t[0]==\\'?\\' && t[1]==\\'?\\')\\n        {\\n            t[0]=\\'2\\';\\n            t[1]=\\'3\\';\\n        }\\n        if(t[0]==\\'?\\')\\n        {\\n            if(t[1]<=\\'0\\')\\n                t[0]=\\'2\\';\\n            else if(t[1]<=\\'1\\')\\n                t[0]=\\'2\\';\\n            else if(t[1]<=\\'2\\')\\n                t[0]=\\'2\\';\\n            else if(t[1]<=\\'3\\')\\n                t[0]=\\'2\\';\\n            else \\n                t[0]=\\'1\\';\\n        }\\n        if(t[1]==\\'?\\')\\n        {\\n            if(t[0]==\\'2\\')\\n                t[1]=\\'3\\';\\n            else \\n                t[1]=\\'9\\';\\n        }\\n        if(t[3]==\\'?\\' && t[4]==\\'?\\')\\n        {\\n            t[3]=\\'5\\';\\n            t[4]=\\'9\\';\\n        }\\n        if(t[3]==\\'?\\')\\n        {\\n            t[3]=\\'5\\';\\n        }\\n        if(t[4]==\\'?\\')\\n        {\\n            t[4]=\\'9\\';\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341169,
                "title": "java-0ms-100-fast-and-easy-to-understand-solution-using-switch",
                "content": "Assume given time format is in the form **H1H2:M1M2**\\nH1 and H2 are the only digits whose max value is dependent on each other.\\nFor rest of the digits max value can be decided independently.\\n```\\npublic String maximumTime(String time) {\\n        char[] timeArr = time.toCharArray();\\n        for (int i = 0; i < timeArr.length; i++) {\\n            if (timeArr[i] == \\'?\\') {\\n                timeArr[i] = resolveLatest(i, timeArr);\\n            }\\n        }\\n        return new String(timeArr);\\n }\\n\\n private char resolveLatest(int position, char[] timeArr) {\\n        char resolvedDigit = 0;\\n        switch (position) {\\n            case 0: // H1\\n                char nextDigit = timeArr[position + 1];\\n                resolvedDigit = Character.isDigit(nextDigit) && nextDigit - \\'0\\' > 3 ? \\'1\\' : \\'2\\';\\n                // If next digit is hidden or less than equal to 3 then max value of H1 will be 2\\n                break;\\n            case 1: // H2\\n                resolvedDigit = timeArr[position - 1] - \\'0\\' <= 1 ? \\'9\\' : \\'3\\';\\n                break;\\n            case 3: // M1\\n                resolvedDigit = \\'5\\';\\n                break;\\n            case 4: // M2\\n                resolvedDigit = \\'9\\';\\n                break;\\n        }\\n        return resolvedDigit;\\n  }\\n```\\nPlease do upvote if you liked the solution or comment incase any doubt :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String maximumTime(String time) {\\n        char[] timeArr = time.toCharArray();\\n        for (int i = 0; i < timeArr.length; i++) {\\n            if (timeArr[i] == \\'?\\') {\\n                timeArr[i] = resolveLatest(i, timeArr);\\n            }\\n        }\\n        return new String(timeArr);\\n }\\n\\n private char resolveLatest(int position, char[] timeArr) {\\n        char resolvedDigit = 0;\\n        switch (position) {\\n            case 0: // H1\\n                char nextDigit = timeArr[position + 1];\\n                resolvedDigit = Character.isDigit(nextDigit) && nextDigit - \\'0\\' > 3 ? \\'1\\' : \\'2\\';\\n                // If next digit is hidden or less than equal to 3 then max value of H1 will be 2\\n                break;\\n            case 1: // H2\\n                resolvedDigit = timeArr[position - 1] - \\'0\\' <= 1 ? \\'9\\' : \\'3\\';\\n                break;\\n            case 3: // M1\\n                resolvedDigit = \\'5\\';\\n                break;\\n            case 4: // M2\\n                resolvedDigit = \\'9\\';\\n                break;\\n        }\\n        return resolvedDigit;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249646,
                "title": "golang-o-1-solution",
                "content": "```\\nfunc maximumTime(time string) string {\\n\\tres := strings.Split(time, \"\")\\n\\t\\n\\tif (res[1] == \"?\" || res[1] <= \"3\") && res[0] == \"?\" {\\n\\t\\tres[0] = \"2\"\\n\\t} else if res[0] == \"?\" {\\n\\t\\tres[0] = \"1\"\\n\\t}\\n\\n\\tif res[0] == \"2\" && res[1] == \"?\" {\\n\\t\\tres[1] = \"3\"\\n\\t} else if res[1] == \"?\" {\\n\\t\\tres[1] = \"9\"\\n\\t}\\n\\n\\tif res[3] == \"?\" { res[3] = \"5\" }\\n\\n\\tif res[4] == \"?\" { res[4] = \"9\" }\\n\\n\\treturn strings.Join(res, \"\")\\n}\\n```\\n\\n*(Since I have not writen a solution feel free to ask questions in the comment section)*",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumTime(time string) string {\\n\\tres := strings.Split(time, \"\")\\n\\t\\n\\tif (res[1] == \"?\" || res[1] <= \"3\") && res[0] == \"?\" {\\n\\t\\tres[0] = \"2\"\\n\\t} else if res[0] == \"?\" {\\n\\t\\tres[0] = \"1\"\\n\\t}\\n\\n\\tif res[0] == \"2\" && res[1] == \"?\" {\\n\\t\\tres[1] = \"3\"\\n\\t} else if res[1] == \"?\" {\\n\\t\\tres[1] = \"9\"\\n\\t}\\n\\n\\tif res[3] == \"?\" { res[3] = \"5\" }\\n\\n\\tif res[4] == \"?\" { res[4] = \"9\" }\\n\\n\\treturn strings.Join(res, \"\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118360,
                "title": "weeb-does-python-with-97-70-runtime",
                "content": "Runtime: 24 ms, faster than 97.70% of Python3 online submissions for Latest Time by Replacing Hidden Digits.\\nMemory Usage: 14.3 MB, less than 23.06% of Python3 online submissions for Latest Time by Replacing Hidden\\n\\n\\tclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        memo = {\"0\":\"9\",\\n                \"1\":\"9\",\\n                \"?\":\"3\", \\n                \"2\":\"3\"}\\n        \\n        answer = \"\"\\n        for idx, val in enumerate(time):\\n            if val == \"?\":\\n                if idx == 0:\\n                    if time[idx+1] == \"?\":\\n                        answer += \"2\"\\n                        \\n                    else:\\n                        if int(time[idx+1]) >= 4:\\n                            answer += \"1\"\\n                    \\n                        else: answer += \"2\"\\n                    \\n                if idx == 1:\\n                    answer += memo[time[idx-1]]\\n                \\n                if idx == 3:\\n                    answer += \"5\"   \\n                    \\n                if idx == 4:\\n                    answer += \"9\"\\n            \\n            else:\\n                answer += val\\n        \\n        return answer\\n\\t\\t\\n# Aight coders, take a break. \\n# its time to watch some anime.\\n# This time my fellow coders, go ahead and check out ***Dororo***\\n# \\n###########################################################################################\\n#  Genres: Action fiction, Dark fantasy, Historical fantasy\\n## Episodes: 24\\n###########################################################################################\\n# \\n# Im warning you, this anime will induce some strong feelings and thoughts. But I can say this for sure, you will realise that you are born in right generation after watching this anime.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def maximumTime(self, time: str) -> str:\\n        memo = {\"0\":\"9\",\\n                \"1\":\"9\",\\n                \"?\":\"3\", \\n                \"2\":\"3\"}",
                "codeTag": "Java"
            },
            {
                "id": 1095834,
                "title": "simple-js-solution",
                "content": "```\\nvar maximumTime = function(time) {\\n    let [a,b,_,c,d] = time.split(\\'\\')\\n    if(a===\\'?\\'){\\n        if(b>3) a = \\'1\\'; else a = \\'2\\'\\n    } \\n    if(b===\\'?\\') {\\n        if(a===\\'2\\') b = 3; else b = 9 ;\\n    }\\n    if(c===\\'?\\') c=5\\n    if(d===\\'?\\') d=9\\n    return `${a}${b}:${c}${d}`\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTime = function(time) {\\n    let [a,b,_,c,d] = time.split(\\'\\')\\n    if(a===\\'?\\'){\\n        if(b>3) a = \\'1\\'; else a = \\'2\\'\\n    } \\n    if(b===\\'?\\') {\\n        if(a===\\'2\\') b = 3; else b = 9 ;\\n    }\\n    if(c===\\'?\\') c=5\\n    if(d===\\'?\\') d=9\\n    return `${a}${b}:${c}${d}`\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049976,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\') time[0]=time[1]>\\'3\\' and time[1]!=\\'?\\'?\\'1\\':\\'2\\';\\n        if(time[1]==\\'?\\') time[1]=time[0]>\\'1\\'?\\'3\\':\\'9\\';\\n        if(time[3]==\\'?\\') time[3]=\\'5\\';\\n        if(time[4]==\\'?\\') time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\') time[0]=time[1]>\\'3\\' and time[1]!=\\'?\\'?\\'1\\':\\'2\\';\\n        if(time[1]==\\'?\\') time[1]=time[0]>\\'1\\'?\\'3\\':\\'9\\';\\n        if(time[3]==\\'?\\') time[3]=\\'5\\';\\n        if(time[4]==\\'?\\') time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038377,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {       \\n        var t = time.toCharArray();\\n        if (t[0] == \\'?\\')\\n            t[0] = (\\'0\\' <= t[1] && t[1] < \\'4\\' || t[1] == \\'?\\') ? \\'2\\' : \\'1\\';\\n        if (t[1] == \\'?\\')\\n            t[1] = t[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        if (t[3] == \\'?\\')\\n            t[3] = \\'5\\';\\n        if (t[4] == \\'?\\')\\n            t[4] = \\'9\\';\\n\\n        return new String(t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {       \\n        var t = time.toCharArray();\\n        if (t[0] == \\'?\\')\\n            t[0] = (\\'0\\' <= t[1] && t[1] < \\'4\\' || t[1] == \\'?\\') ? \\'2\\' : \\'1\\';\\n        if (t[1] == \\'?\\')\\n            t[1] = t[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        if (t[3] == \\'?\\')\\n            t[3] = \\'5\\';\\n        if (t[4] == \\'?\\')\\n            t[4] = \\'9\\';\\n\\n        return new String(t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032352,
                "title": "clean-python-3-generalization-without-magic-numbers",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        def parse(sig: str, bound: int, base: int = 10):\\n            first, second = divmod(bound, base)\\n            if sig[0] == \\'?\\':\\n                if sig[1] == \\'?\\': return str(bound)\\n                first -= int(sig[1]) > second\\n                second = int(sig[1])\\n            else:\\n                if sig[1] != \\'?\\': return sig\\n                if int(sig[0]) < first: second = base - 1\\n                first = int(sig[0])\\n            return f\\'{first}{second}\\'\\n\\n        return \\':\\'.join(map(parse, time.split(\\':\\'), (23, 59)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        def parse(sig: str, bound: int, base: int = 10):\\n            first, second = divmod(bound, base)\\n            if sig[0] == \\'?\\':\\n                if sig[1] == \\'?\\': return str(bound)\\n                first -= int(sig[1]) > second\\n                second = int(sig[1])\\n            else:\\n                if sig[1] != \\'?\\': return sig\\n                if int(sig[0]) < first: second = base - 1\\n                first = int(sig[0])\\n            return f\\'{first}{second}\\'\\n\\n        return \\':\\'.join(map(parse, time.split(\\':\\'), (23, 59)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357936,
                "title": "very-fast-90-58-and-easy-solution",
                "content": "class Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time_l = list(time)\\n        new_str = \\'\\'\\n\\n        if time[0] == \\'?\\' and time[1] == \\'?\\':\\n            time_l[0] = time[0].replace(time[0], \\'2\\')\\n            time_l[1] = time[1].replace(time[1], \\'3\\')\\n        if time[3] == \\'?\\' and time[4] == \\'?\\':\\n            time_l[3] = time[3].replace(time[3], \\'5\\')\\n            time_l[4] = time[4].replace(time[4], \\'9\\')\\n        if time[0] == \\'?\\' and time[1] != \\'?\\':\\n            if int(time[1]) < 4:\\n                time_l[0] = time[0].replace(time[0], \\'2\\')\\n            elif int(time[1]) > 3:\\n                time_l[0] = time[0].replace(time[0], \\'1\\')\\n        if time[1] == \\'?\\' and time[0] != \\'?\\':\\n            if int(time[0]) < 2:\\n                time_l[1] = time[1].replace(time[1], \\'9\\')\\n            elif int(time[0]) == 2:\\n                time_l[1] = time[1].replace(time[1], \\'3\\')\\n        if time[3] == \\'?\\' and time[4] != \\'?\\':\\n            time_l[3] = time[3].replace(time[3], \\'5\\')\\n        if time[4] == \\'?\\' and time[3] != \\'?\\':\\n            time_l[4] = time[4].replace(time[4], \\'9\\')\\n\\n        for i in time_l:\\n            new_str += i\\n        return new_str\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time_l = list(time)\\n        new_str = \\'\\'\\n\\n        if time[0] == \\'?\\' and time[1] == \\'?\\':\\n            time_l[0] = time[0].replace(time[0], \\'2\\')\\n            time_l[1] = time[1].replace(time[1], \\'3\\')\\n        if time[3] == \\'?\\' and time[4] == \\'?\\':\\n            time_l[3] = time[3].replace(time[3], \\'5\\')\\n            time_l[4] = time[4].replace(time[4], \\'9\\')\\n        if time[0] == \\'?\\' and time[1] != \\'?\\':\\n            if int(time[1]) < 4:\\n                time_l[0] = time[0].replace(time[0], \\'2\\')\\n            elif int(time[1]) > 3:\\n                time_l[0] = time[0].replace(time[0], \\'1\\')\\n        if time[1] == \\'?\\' and time[0] != \\'?\\':\\n            if int(time[0]) < 2:\\n                time_l[1] = time[1].replace(time[1], \\'9\\')\\n            elif int(time[0]) == 2:\\n                time_l[1] = time[1].replace(time[1], \\'3\\')\\n        if time[3] == \\'?\\' and time[4] != \\'?\\':\\n            time_l[3] = time[3].replace(time[3], \\'5\\')\\n        if time[4] == \\'?\\' and time[3] != \\'?\\':\\n            time_l[4] = time[4].replace(time[4], \\'9\\')\\n\\n        for i in time_l:\\n            new_str += i\\n        return new_str\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221938,
                "title": "c-solution-beats-100-o-1-time-complexity-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\' && time[1]==\\'?\\')time[0]=\\'2\\',time[1]=\\'3\\';\\n        else if(time[0]==\\'?\\' && time[1]>\\'3\\') time[0]=\\'1\\';\\n        else if(time[0]==\\'?\\' && time[1]<=\\'3\\') time[0]=\\'2\\'; \\n        else if(time[1]==\\'?\\' && (time[0]==\\'0\\'||time[0]==\\'1\\')) time[1]=\\'9\\';\\n        else if(time[1]==\\'?\\' && time[0]==\\'2\\') time[1]=\\'3\\';\\n\\n        if(time[3]==\\'?\\' && time[4]==\\'?\\') time[3]=\\'5\\', time[4]=\\'9\\';\\n        else if(time[3]==\\'?\\')time[3]=\\'5\\';\\n        else if(time[4]==\\'?\\')time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\' && time[1]==\\'?\\')time[0]=\\'2\\',time[1]=\\'3\\';\\n        else if(time[0]==\\'?\\' && time[1]>\\'3\\') time[0]=\\'1\\';\\n        else if(time[0]==\\'?\\' && time[1]<=\\'3\\') time[0]=\\'2\\'; \\n        else if(time[1]==\\'?\\' && (time[0]==\\'0\\'||time[0]==\\'1\\')) time[1]=\\'9\\';\\n        else if(time[1]==\\'?\\' && time[0]==\\'2\\') time[1]=\\'3\\';\\n\\n        if(time[3]==\\'?\\' && time[4]==\\'?\\') time[3]=\\'5\\', time[4]=\\'9\\';\\n        else if(time[3]==\\'?\\')time[3]=\\'5\\';\\n        else if(time[4]==\\'?\\')time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973812,
                "title": "c-constant-time-complexity",
                "content": "# Intuition\\nThe length is fixed of the string and can be considered as 2 questions left part have conditions while other half is not bounded with any condition and hence can be solved in constant time complexity.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n       if((time[0]==\\'?\\' && time[1]==\\'?\\')|| (time[0]==\\'?\\' && time[1]<=\\'3\\') ){\\n           time[0]=\\'2\\';\\n       }\\n       else if( (time[0]==\\'?\\' && time[1]>\\'3\\') ){\\n           time[0]=\\'1\\';\\n       }\\n       if(time[0]==\\'2\\' && time[1]==\\'?\\'){\\n           time[1]=\\'3\\';\\n       }\\n        if(time[0]==\\'1\\' && time[1]==\\'?\\'){\\n            time[1]=\\'9\\';\\n       }\\n       if(time[0]==\\'0\\' && time[1]==\\'?\\'){\\n            time[1]=\\'9\\';\\n       }\\n        \\n        if(time[3]==\\'?\\'){\\n            time[3]=\\'5\\';\\n        }\\n        if(time[4]==\\'?\\'  ){\\n            time[4]=\\'9\\';\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n       if((time[0]==\\'?\\' && time[1]==\\'?\\')|| (time[0]==\\'?\\' && time[1]<=\\'3\\') ){\\n           time[0]=\\'2\\';\\n       }\\n       else if( (time[0]==\\'?\\' && time[1]>\\'3\\') ){\\n           time[0]=\\'1\\';\\n       }\\n       if(time[0]==\\'2\\' && time[1]==\\'?\\'){\\n           time[1]=\\'3\\';\\n       }\\n        if(time[0]==\\'1\\' && time[1]==\\'?\\'){\\n            time[1]=\\'9\\';\\n       }\\n       if(time[0]==\\'0\\' && time[1]==\\'?\\'){\\n            time[1]=\\'9\\';\\n       }\\n        \\n        if(time[3]==\\'?\\'){\\n            time[3]=\\'5\\';\\n        }\\n        if(time[4]==\\'?\\'  ){\\n            time[4]=\\'9\\';\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684066,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string maximumTime(string s) \\n    {\\n        if(s[0]==\\'?\\')\\n        {\\n            if(s[1]==\\'?\\')\\n            {\\n                s[0]=\\'2\\';\\n            }\\n            else if(s[1]-\\'0\\'>3)\\n            {\\n                s[0]=\\'1\\';\\n            }\\n            else\\n            {\\n                s[0]=\\'2\\';\\n            }\\n        }\\n         if(s[1]==\\'?\\')\\n        {\\n            if(s[0]-\\'0\\'==2)\\n            {\\n                s[1]=\\'3\\';\\n            }\\n            else\\n            {\\n                s[1]=\\'9\\';\\n            }\\n        }\\n        if(s[3]==\\'?\\')\\n        {\\n            s[3]=\\'5\\';\\n        }\\n         if(s[4]==\\'?\\')\\n        {\\n            s[4]=\\'9\\';\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string maximumTime(string s) \\n    {\\n        if(s[0]==\\'?\\')\\n        {\\n            if(s[1]==\\'?\\')\\n            {\\n                s[0]=\\'2\\';\\n            }\\n            else if(s[1]-\\'0\\'>3)\\n            {\\n                s[0]=\\'1\\';\\n            }\\n            else\\n            {\\n                s[0]=\\'2\\';\\n            }\\n        }\\n         if(s[1]==\\'?\\')\\n        {\\n            if(s[0]-\\'0\\'==2)\\n            {\\n                s[1]=\\'3\\';\\n            }\\n            else\\n            {\\n                s[1]=\\'9\\';\\n            }\\n        }\\n        if(s[3]==\\'?\\')\\n        {\\n            s[3]=\\'5\\';\\n        }\\n         if(s[4]==\\'?\\')\\n        {\\n            s[4]=\\'9\\';\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586535,
                "title": "c-if",
                "content": "```\\n\\tstring maximumTime(string time) {\\n        if(time[0] == \\'?\\') time[0] = (time[1] <= \\'3\\' || time[1] == \\'?\\' ? \\'2\\' : \\'1\\');\\n        if(time[1] == \\'?\\') time[1] = (time[0] == \\'2\\' ? \\'3\\' : \\'9\\');\\n        if(time[3] == \\'?\\') time[3] = \\'5\\';\\n        if(time[4] == \\'?\\') time[4] = \\'9\\';\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tstring maximumTime(string time) {\\n        if(time[0] == \\'?\\') time[0] = (time[1] <= \\'3\\' || time[1] == \\'?\\' ? \\'2\\' : \\'1\\');\\n        if(time[1] == \\'?\\') time[1] = (time[0] == \\'2\\' ? \\'3\\' : \\'9\\');\\n        if(time[3] == \\'?\\') time[3] = \\'5\\';\\n        if(time[4] == \\'?\\') time[4] = \\'9\\';\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2467106,
                "title": "c-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string s) \\n    {\\n        if(s[0]==\\'?\\')\\n        {\\n            if(s[1]==\\'?\\')\\n            {\\n                s[0]=\\'2\\';\\n            }\\n            else if(s[1]-\\'0\\'>3)\\n            {\\n                s[0]=\\'1\\';\\n            }\\n            else\\n            {\\n                s[0]=\\'2\\';\\n            }\\n        }\\n         if(s[1]==\\'?\\')\\n        {\\n            if(s[0]-\\'0\\'==2)\\n            {\\n                s[1]=\\'3\\';\\n            }\\n            else\\n            {\\n                s[1]=\\'9\\';\\n            }\\n        }\\n        if(s[3]==\\'?\\')\\n        {\\n            s[3]=\\'5\\';\\n        }\\n         if(s[4]==\\'?\\')\\n        {\\n            s[4]=\\'9\\';\\n        }\\n        return s;\\n        \\n    }\\n};\\n//if you find the solution useful plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string maximumTime(string s) \\n    {\\n        if(s[0]==\\'?\\')\\n        {\\n            if(s[1]==\\'?\\')\\n            {\\n                s[0]=\\'2\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1591577,
                "title": "beautiful-c-solution-can-be-implemented-in-any-language",
                "content": "The solution is pretty self-explanatory\\n```\\nclass Solution {\\n   public:\\n    string maximumTime(string time)\\n    {\\n        const string maxPossible = (time[0] == \\'2\\' || time[0] == \\'?\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t&& (time[1] == \\'?\\' || time[1] < \\'4\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t? \"23:59\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: \"19:59\";\\n\\n         for (int i = 0; i < 5; i++)\\n             if (time[i] == \\'?\\')\\n                 time[i] = maxPossible[i];\\n\\t\\t\\t\\t \\n         return time;\\n    }\\n};\\n```\\n**If you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    string maximumTime(string time)\\n    {\\n        const string maxPossible = (time[0] == \\'2\\' || time[0] == \\'?\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t&& (time[1] == \\'?\\' || time[1] < \\'4\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t? \"23:59\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: \"19:59\";\\n\\n         for (int i = 0; i < 5; i++)\\n             if (time[i] == \\'?\\')\\n                 time[i] = maxPossible[i];\\n\\t\\t\\t\\t \\n         return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037683,
                "title": "java-solution-switch-case-with-comments",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 5; i++){\\n            if(time.charAt(i) == \\'?\\'){\\n                switch (i){\\n                    case 0:\\n\\t\\t\\t\\t\\t\\t// Check after to avoid > 23 case\\n                        if(Character.getNumericValue(time.charAt(1)) >= 4){\\n                            sb.append(1); \\n                        } else {\\n                           sb.append(2);    \\n                        }\\n                        break;\\n                    case 1:\\n\\t\\t\\t\\t\\t    // Check before to avoid > 23 case \\n                        if(sb.toString().charAt(0) == \\'2\\'){\\n                            sb.append(3);\\n                        } else {\\n                            sb.append(9);\\n                        }\\n                        break;\\n                    case 3:\\n                        sb.append(5);\\n                        break;\\n                    case 4:\\n                        sb.append(9);\\n                        break;\\n                }\\n            } else {\\n                sb.append(time.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String maximumTime(String time) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < 5; i++){\\n            if(time.charAt(i) == \\'?\\'){\\n                switch (i){\\n                    case 0:\\n\\t\\t\\t\\t\\t\\t// Check after to avoid > 23 case\\n                        if(Character.getNumericValue(time.charAt(1)) >= 4){\\n                            sb.append(1); \\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1033665,
                "title": "java-weird-but-relatively-concise-solution",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        return findNumbers(2,3, time, 0,1)+\":\"+findNumbers(5,9,time,3,4);\\n    }\\n    \\n    public String findNumbers(int max1, int max2, String time, int ind1, int ind2){\\n        char t = time.charAt(ind1);\\n        char tt = time.charAt(ind2);\\n        int a=0,b=0;\\n        if (t==\\'?\\'){\\n            if (tt==\\'?\\'){a=max1;b=max2;}\\n            else {\\n                b=tt-48;\\n                if (b<=max2) a=max1;\\n                else a=max1-1;\\n            }\\n        } else {\\n            a=t-48;\\n            if (tt==\\'?\\'){if (a<max1)b=9; else b=max2;}\\n            else {b=tt-48;}\\n        }\\n        return a+\"\"+b;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        return findNumbers(2,3, time, 0,1)+\":\"+findNumbers(5,9,time,3,4);\\n    }\\n    \\n    public String findNumbers(int max1, int max2, String time, int ind1, int ind2){\\n        char t = time.charAt(ind1);\\n        char tt = time.charAt(ind2);\\n        int a=0,b=0;\\n        if (t==\\'?\\'){\\n            if (tt==\\'?\\'){a=max1;b=max2;}\\n            else {\\n                b=tt-48;\\n                if (b<=max2) a=max1;\\n                else a=max1-1;\\n            }\\n        } else {\\n            a=t-48;\\n            if (tt==\\'?\\'){if (a<max1)b=9; else b=max2;}\\n            else {b=tt-48;}\\n        }\\n        return a+\"\"+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032426,
                "title": "java-clean-solution-with-examples",
                "content": "The only trick is that digit 0 and 1 depend on one another. Checking if both digit 0 and 1 are hidden can simplify our code so that we don\\'t have to use too many nested if/else/or/ternary operators.\\n\\n- `??:50`: If both are hidden, turn them into 23\\n- `?2:12` and `?9:15`: If only digit 0 is hidden, check digit 1\\n- `1?:12` and `2?:15`: If only digit 1 is hidden, check digit 0\\n- `12:?5` and `12:??`: digit 3 is at most 5\\n- `12:5?` and `12:??`: digit 4 is at most 9\\n\\n```\\npublic String maximumTime(String time) {\\n    char[] nums = time.toCharArray();\\n\\n    if (nums[0] == \\'?\\' && nums[1] == \\'?\\') {\\n        nums[0] = \\'2\\'; nums[1] = \\'3\\';\\n    } else if (nums[0] == \\'?\\') {\\n        nums[0] = (nums[1] > \\'3\\') ? \\'1\\' : \\'2\\';\\n    } else if (nums[1] == \\'?\\') {\\n        nums[1] = (nums[0] < \\'2\\') ? \\'9\\' : \\'3\\';\\n    }\\n\\n    if (nums[3] == \\'?\\') nums[3] = \\'5\\';\\n    if (nums[4] == \\'?\\') nums[4] = \\'9\\';\\n\\n    return new String(nums);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String maximumTime(String time) {\\n    char[] nums = time.toCharArray();\\n\\n    if (nums[0] == \\'?\\' && nums[1] == \\'?\\') {\\n        nums[0] = \\'2\\'; nums[1] = \\'3\\';\\n    } else if (nums[0] == \\'?\\') {\\n        nums[0] = (nums[1] > \\'3\\') ? \\'1\\' : \\'2\\';\\n    } else if (nums[1] == \\'?\\') {\\n        nums[1] = (nums[0] < \\'2\\') ? \\'9\\' : \\'3\\';\\n    }\\n\\n    if (nums[3] == \\'?\\') nums[3] = \\'5\\';\\n    if (nums[4] == \\'?\\') nums[4] = \\'9\\';\\n\\n    return new String(nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669510,
                "title": "100-beat-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0] == \\'?\\'){\\n            if(time[1] == \\'?\\' || (time[1] >= \\'0\\' && time[1] <= \\'3\\')) time[0] = \\'2\\';\\n            else time[0] = \\'1\\';\\n        }\\n        if(time[1] == \\'?\\'){\\n            if(time[0] == \\'2\\') time[1] = \\'3\\';\\n            else time[1] = \\'9\\';\\n        }\\n        if(time[3] == \\'?\\') time[3] = \\'5\\';\\n        if(time[4] == \\'?\\') time[4] = \\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0] == \\'?\\'){\\n            if(time[1] == \\'?\\' || (time[1] >= \\'0\\' && time[1] <= \\'3\\')) time[0] = \\'2\\';\\n            else time[0] = \\'1\\';\\n        }\\n        if(time[1] == \\'?\\'){\\n            if(time[0] == \\'2\\') time[1] = \\'3\\';\\n            else time[1] = \\'9\\';\\n        }\\n        if(time[3] == \\'?\\') time[3] = \\'5\\';\\n        if(time[4] == \\'?\\') time[4] = \\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998674,
                "title": "my-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n         if (time.charAt(0) == \\'?\\') {\\n            if (time.charAt(1) != \\'?\\' && time.charAt(1) - \\'0\\' > 3) {\\n                time = time.substring(0, 0) + \\'1\\' + time.substring(1);\\n            } else {\\n                time = time.substring(0, 0) + \\'2\\' + time.substring(1);\\n            }\\n        }\\n        if (time.charAt(1) == \\'?\\') {\\n            if (time.charAt(0) == \\'1\\' || time.charAt(0) == \\'0\\') {\\n                time = time.substring(0, 1) + \\'9\\' + time.substring(2);\\n            } else {\\n                time = time.substring(0, 1) + \\'3\\' + time.substring(2);\\n            }\\n        }\\n        if (time.charAt(3) == \\'?\\') {\\n            time = time.substring(0, 3) + \\'5\\' + time.substring(4);\\n        }\\n        if (time.charAt(4) == \\'?\\') {\\n            time = time.substring(0, 4) + \\'9\\';\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n         if (time.charAt(0) == \\'?\\') {\\n            if (time.charAt(1) != \\'?\\' && time.charAt(1) - \\'0\\' > 3) {\\n                time = time.substring(0, 0) + \\'1\\' + time.substring(1);\\n            } else {\\n                time = time.substring(0, 0) + \\'2\\' + time.substring(1);\\n            }\\n        }\\n        if (time.charAt(1) == \\'?\\') {\\n            if (time.charAt(0) == \\'1\\' || time.charAt(0) == \\'0\\') {\\n                time = time.substring(0, 1) + \\'9\\' + time.substring(2);\\n            } else {\\n                time = time.substring(0, 1) + \\'3\\' + time.substring(2);\\n            }\\n        }\\n        if (time.charAt(3) == \\'?\\') {\\n            time = time.substring(0, 3) + \\'5\\' + time.substring(4);\\n        }\\n        if (time.charAt(4) == \\'?\\') {\\n            time = time.substring(0, 4) + \\'9\\';\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411132,
                "title": "simple-if-else-condition",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\tstring maximumTime(string time) {\\n\\t\\t\\n\\t\\t\\tif(time[0] == \\'?\\'){\\n\\t\\t\\t\\tif(time[1] > \\'3\\' && time[1] <= \\'9\\')\\n\\t\\t\\t\\t\\ttime[0] = \\'1\\';\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttime[0]= \\'2\\';\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(time[1] == \\'?\\'){\\n\\t\\t\\t\\tif(time[0] == \\'2\\')\\n\\t\\t\\t\\t\\ttime[1] = \\'3\\';\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttime[1] = \\'9\\';\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(time[3] == \\'?\\')\\n\\t\\t\\t\\ttime[3]=\\'5\\';\\n\\n\\t\\t\\tif(time[4] == \\'?\\')\\n\\t\\t\\t\\ttime[4]=\\'9\\';\\n\\n\\t\\t\\tif(time[0] > \\'2\\' || time[3] > \\'5\\')\\n\\t\\t\\t\\treturn \"\";\\n\\n\\t\\t\\treturn time;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'\\n\\n//\\uD83D\\uDC4D : )",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\tstring maximumTime(string time) {\\n\\t\\t\\n\\t\\t\\tif(time[0] == \\'?\\'){\\n\\t\\t\\t\\tif(time[1] > \\'3\\' && time[1] <= \\'9\\')\\n\\t\\t\\t\\t\\ttime[0] = \\'1\\';\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttime[0]= \\'2\\';\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2391862,
                "title": "easiest-java-straight-forward-sol",
                "content": "```\\n\\nclass Solution {\\n    public String maximumTime(String time) {\\n    \\n        char[] ans= time.toCharArray();\\n        if(ans[0]==\\'?\\'){\\n            ans[0]= (ans[1]<=\\'3\\' || ans[1]==\\'?\\') ? \\'2\\' : \\'1\\';\\n        }\\n        \\n        if(ans[1]==\\'?\\') {\\n            ans[1]=ans[0]==\\'2\\' ? \\'3\\':\\'9\\';\\n        }\\n        \\n        if(ans[3]==\\'?\\') ans[3]=\\'5\\';\\n        \\n        if(ans[4]==\\'?\\') ans[4]=\\'9\\';\\n    \\n            return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String maximumTime(String time) {\\n    \\n        char[] ans= time.toCharArray();\\n        if(ans[0]==\\'?\\'){\\n            ans[0]= (ans[1]<=\\'3\\' || ans[1]==\\'?\\') ? \\'2\\' : \\'1\\';\\n        }\\n        \\n        if(ans[1]==\\'?\\') {\\n            ans[1]=ans[0]==\\'2\\' ? \\'3\\':\\'9\\';\\n        }\\n        \\n        if(ans[3]==\\'?\\') ans[3]=\\'5\\';\\n        \\n        if(ans[4]==\\'?\\') ans[4]=\\'9\\';\\n    \\n            return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341831,
                "title": "java-100-faster",
                "content": "```\\n\\tpublic String maximumTime(String time) {\\n        char[] t = time.toCharArray();\\n        if(t[0] == \\'?\\') {\\n            t[0] = t[1] == \\'?\\' || t[1] <= \\'3\\' ? \\'2\\' : \\'1\\';\\n        }\\n        if(t[1] == \\'?\\') {\\n            t[1] = t[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        } \\n        if(t[3] == \\'?\\') {\\n            t[3] = \\'5\\';\\n        } \\n        if(t[4] == \\'?\\') {\\n            t[4] = \\'9\\';\\n        }\\n        return new String(t);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic String maximumTime(String time) {\\n        char[] t = time.toCharArray();\\n        if(t[0] == \\'?\\') {\\n            t[0] = t[1] == \\'?\\' || t[1] <= \\'3\\' ? \\'2\\' : \\'1\\';\\n        }\\n        if(t[1] == \\'?\\') {\\n            t[1] = t[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        } \\n        if(t[3] == \\'?\\') {\\n            t[3] = \\'5\\';\\n        } \\n        if(t[4] == \\'?\\') {\\n            t[4] = \\'9\\';\\n        }\\n        return new String(t);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267295,
                "title": "c-if-else",
                "content": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string s) {\\n        int n=s.length();\\n        if(s[0]==\\'?\\' && s[1]==\\'?\\')\\n            s[0]=\\'2\\';\\n        \\n        if(s[0]==\\'?\\' && s[1]>=\\'4\\')\\n            s[0]=\\'1\\';\\n        \\n        if(s[0]==\\'?\\' && s[1]<\\'4\\')\\n            s[0]=\\'2\\';\\n        \\n        if(s[1]==\\'?\\' && s[0]==\\'0\\')\\n            s[1]=\\'9\\';\\n        \\n        if(s[1]==\\'?\\' && s[0]==\\'1\\')\\n            s[1]=\\'9\\';\\n        \\n        if(s[1]==\\'?\\' && s[0]==\\'2\\')\\n            s[1]=\\'3\\';\\n        \\n        if(s[3]==\\'?\\')\\n            s[3]=\\'5\\';\\n        \\n        if(s[4]==\\'?\\')\\n            s[4]=\\'9\\';\\n        \\n        return s;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string s) {\\n        int n=s.length();\\n        if(s[0]==\\'?\\' && s[1]==\\'?\\')\\n            s[0]=\\'2\\';\\n        \\n        if(s[0]==\\'?\\' && s[1]>=\\'4\\')\\n            s[0]=\\'1\\';\\n        \\n        if(s[0]==\\'?\\' && s[1]<\\'4\\')\\n            s[0]=\\'2\\';\\n        \\n        if(s[1]==\\'?\\' && s[0]==\\'0\\')\\n            s[1]=\\'9\\';\\n        \\n        if(s[1]==\\'?\\' && s[0]==\\'1\\')\\n            s[1]=\\'9\\';\\n        \\n        if(s[1]==\\'?\\' && s[0]==\\'2\\')\\n            s[1]=\\'3\\';\\n        \\n        if(s[3]==\\'?\\')\\n            s[3]=\\'5\\';\\n        \\n        if(s[4]==\\'?\\')\\n            s[4]=\\'9\\';\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068046,
                "title": "python-if-else-bloodbath-simplified",
                "content": "A lot of brave atempets failed for me to nail this one.\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)         \\n        if time[0] == \\'?\\': time[0] = \\'1\\' if time[1] in \\'456789\\' else \\'2\\'            \\n        if time[1] == \\'?\\': time[1] = \\'9\\' if time[0] in \\'01\\' else \\'3\\'                        \\n        if time[3] == \\'?\\': time[3] = \\'5\\'\\n        if time[4] == \\'?\\': time[4] = \\'9\\'            \\n        return \\'\\'.join(time)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)         \\n        if time[0] == \\'?\\': time[0] = \\'1\\' if time[1] in \\'456789\\' else \\'2\\'            \\n        if time[1] == \\'?\\': time[1] = \\'9\\' if time[0] in \\'01\\' else \\'3\\'                        \\n        if time[3] == \\'?\\': time[3] = \\'5\\'\\n        if time[4] == \\'?\\': time[4] = \\'9\\'            \\n        return \\'\\'.join(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041524,
                "title": "python-o-1-solution",
                "content": "Code:\\n```\\n        ho,mi,res=time[:2],time[3:],[]\\n        if ho==\\'??\\': res.append(\\'23\\')\\n        elif ho[0]==\\'?\\':\\n            if int(ho[1])<=3: res.append(\\'2\\'+ho[1])\\n            else : res.append(\\'1\\'+ho[1])\\n        elif ho[1]==\"?\":\\n            if int(ho[0])<=1: res.append(ho[0]+\\'9\\')\\n            else: res.append(ho[0]+\\'3\\')\\n        else: res.append(ho)\\n            \\n        if mi==\\'??\\': res.append(\\'59\\')\\n        elif mi[0]==\\'?\\': res.append(\\'5\\'+mi[1])\\n        elif mi[1]==\\'?\\': res.append(mi[0]+\\'9\\')\\n        else: res.append(mi)\\n            \\n        return \\':\\'.join(res)\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n        ho,mi,res=time[:2],time[3:],[]\\n        if ho==\\'??\\': res.append(\\'23\\')\\n        elif ho[0]==\\'?\\':\\n            if int(ho[1])<=3: res.append(\\'2\\'+ho[1])\\n            else : res.append(\\'1\\'+ho[1])\\n        elif ho[1]==\"?\":\\n            if int(ho[0])<=1: res.append(ho[0]+\\'9\\')\\n            else: res.append(ho[0]+\\'3\\')\\n        else: res.append(ho)\\n            \\n        if mi==\\'??\\': res.append(\\'59\\')\\n        elif mi[0]==\\'?\\': res.append(\\'5\\'+mi[1])\\n        elif mi[1]==\\'?\\': res.append(mi[0]+\\'9\\')\\n        else: res.append(mi)\\n            \\n        return \\':\\'.join(res)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008770,
                "title": "c-clean-and-straightforward",
                "content": "```\\npublic class Solution\\n{\\n    public string MaximumTime(string time)\\n    {\\n        char[] characters = time.ToCharArray();\\n        if (characters[4] is \\'?\\') characters[4] = \\'9\\';\\n        if (characters[3] is \\'?\\') characters[3] = \\'5\\';\\n        if (characters[1] is \\'?\\') characters[1] = characters[0] is \\'?\\' or \\'2\\' ? \\'3\\' : \\'9\\';\\n        if (characters[0] is \\'?\\') characters[0] = characters[1] > \\'3\\' ? \\'1\\' : \\'2\\';\\n        return new string(characters);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string MaximumTime(string time)\\n    {\\n        char[] characters = time.ToCharArray();\\n        if (characters[4] is \\'?\\') characters[4] = \\'9\\';\\n        if (characters[3] is \\'?\\') characters[3] = \\'5\\';\\n        if (characters[1] is \\'?\\') characters[1] = characters[0] is \\'?\\' or \\'2\\' ? \\'3\\' : \\'9\\';\\n        if (characters[0] is \\'?\\') characters[0] = characters[1] > \\'3\\' ? \\'1\\' : \\'2\\';\\n        return new string(characters);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835966,
                "title": "python-direct-solution-and-explanation-28ms",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n \\n        #Create a list to change values of time\\n        newTime = [None for _ in range( 5 )];\\n        \\n        \\n        #Put the \\':\\' in the second index for formatting\\n        newTime[ 2 ] = \\':\\';\\n        \\n        #For changing the _X:XX position, we need to check\\n        #to see what its neighbor at X_:XX is\\n        #We can make it a 20th hour if it is 0, 1, 2, 3, or wild\\n        if time[ 1 ] in \\'0123?\\':\\n            self.updateTime( time, newTime, \\'2\\', 0 );\\n            \\n        #Otherwise, we have to make the time a \\'1\\'\\n        #This is because we can have say 19:XX but not 29:XX\\n        else:\\n            self.updateTime( time, newTime, \\'1\\', 0 );\\n            \\n        #Same thing for the next hour slot at X_:XX\\n        #We need to see what its neighbor is at _X:XX\\n        \\n        #If the neighbor is one or zero,\\n        #We can use 9 like in 09:XX or  19:XX\\n        if time[ 0 ] in \\'01\\':\\n            self.updateTime( time, newTime, \\'9\\', 1 );\\n            \\n        #Otherwise, we are forced to use \\'3\\'\\n        #For 23:XX  \\n        else:\\n            self.updateTime( time, newTime, \\'3\\', 1 );\\n            \\n        #The minute slots are straightforeward\\n        #They can always be maxed to 5 and 9 respectively\\n        #To achieve the latest time\\n        self.updateTime( time, newTime, \\'5\\', 3 );\\n        self.updateTime( time, newTime, \\'9\\', 4 );\\n        \\n        \\n        #Last, we return the joined updated list\\n        return \"\".join( newTime );\\n            \\n        #Update time is simple\\n        #It checks the original time at the index passed in\\n        #And updates the index at newTime with the appropriate time\\n\\t\\t#Base on our rules\\n    def updateTime ( self, time, newTime , maxChar , index ):\\n\\t\\t\\n\\t\\t#If it is wild, \\'?\\', we assign the maxChar\\n        if time[ index ] == \\'?\\':\\n            newTime[ index ] = maxChar;\\n            \\n        #Otherwise, we keep the original character at the index\\n        else:\\n            newTime[ index ] = time[ index ];\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n \\n        #Create a list to change values of time\\n        newTime = [None for _ in range( 5 )];\\n        \\n        \\n        #Put the \\':\\' in the second index for formatting\\n        newTime[ 2 ] = \\':\\';\\n        \\n        #For changing the _X:XX position, we need to check\\n        #to see what its neighbor at X_:XX is\\n        #We can make it a 20th hour if it is 0, 1, 2, 3, or wild\\n        if time[ 1 ] in \\'0123?\\':\\n            self.updateTime( time, newTime, \\'2\\', 0 );\\n            \\n        #Otherwise, we have to make the time a \\'1\\'\\n        #This is because we can have say 19:XX but not 29:XX\\n        else:\\n            self.updateTime( time, newTime, \\'1\\', 0 );\\n            \\n        #Same thing for the next hour slot at X_:XX\\n        #We need to see what its neighbor is at _X:XX\\n        \\n        #If the neighbor is one or zero,\\n        #We can use 9 like in 09:XX or  19:XX\\n        if time[ 0 ] in \\'01\\':\\n            self.updateTime( time, newTime, \\'9\\', 1 );\\n            \\n        #Otherwise, we are forced to use \\'3\\'\\n        #For 23:XX  \\n        else:\\n            self.updateTime( time, newTime, \\'3\\', 1 );\\n            \\n        #The minute slots are straightforeward\\n        #They can always be maxed to 5 and 9 respectively\\n        #To achieve the latest time\\n        self.updateTime( time, newTime, \\'5\\', 3 );\\n        self.updateTime( time, newTime, \\'9\\', 4 );\\n        \\n        \\n        #Last, we return the joined updated list\\n        return \"\".join( newTime );\\n            \\n        #Update time is simple\\n        #It checks the original time at the index passed in\\n        #And updates the index at newTime with the appropriate time\\n\\t\\t#Base on our rules\\n    def updateTime ( self, time, newTime , maxChar , index ):\\n\\t\\t\\n\\t\\t#If it is wild, \\'?\\', we assign the maxChar\\n        if time[ index ] == \\'?\\':\\n            newTime[ index ] = maxChar;\\n            \\n        #Otherwise, we keep the original character at the index\\n        else:\\n            newTime[ index ] = time[ index ];\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819359,
                "title": "simple-if-statements-no-loops-required",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char arr[] = time.toCharArray();\\n        \\n        \\n            if( arr[0] == \\'?\\'){\\n                arr[0] =  (arr[1] <= \\'3\\' || arr[1] == \\'?\\') ? \\'2\\' : \\'1\\';\\n            }\\n            if(arr[1] == \\'?\\'){\\n                arr[1] =  (arr[0] == \\'2\\') ? \\'3\\' : \\'9\\';\\n            }\\n            if(arr[3] == \\'?\\'){\\n                arr[3] = \\'5\\';\\n            }\\n            if(arr[4] == \\'?\\'){\\n                arr[4] = \\'9\\';\\n            }\\n        \\n        return String.valueOf(arr);\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char arr[] = time.toCharArray();\\n        \\n        \\n            if( arr[0] == \\'?\\'){\\n                arr[0] =  (arr[1] <= \\'3\\' || arr[1] == \\'?\\') ? \\'2\\' : \\'1\\';\\n            }\\n            if(arr[1] == \\'?\\'){\\n                arr[1] =  (arr[0] == \\'2\\') ? \\'3\\' : \\'9\\';\\n            }\\n            if(arr[3] == \\'?\\'){\\n                arr[3] = \\'5\\';\\n            }\\n            if(arr[4] == \\'?\\'){\\n                arr[4] = \\'9\\';\\n            }\\n        \\n        return String.valueOf(arr);\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780790,
                "title": "2-lines-python-solution-faster-than-50-memory-less-than-75",
                "content": "```\\ndef maximumTime(self, time: str) -> str:\\n        maxChar = lambda x: \"23:59\"[x] if time[0] in \"2?\" and time[1] in \"0123?\" else \"19:59\"[x]\\n        return \"\".join(t if t != \"?\" else maxChar(x)  for x, t in enumerate(time))\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maximumTime(self, time: str) -> str:\\n        maxChar = lambda x: \"23:59\"[x] if time[0] in \"2?\" and time[1] in \"0123?\" else \"19:59\"[x]\\n        return \"\".join(t if t != \"?\" else maxChar(x)  for x, t in enumerate(time))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1754410,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n\\n        for i, ch in enumerate(time):\\n            if ch == \\'?\\':\\n                if i == 0:\\n                    time[i] = \\'2\\' if time[1] in \\'0123?\\' else \\'1\\'\\n                elif i == 1:\\n                    time[i] = \\'9\\' if time[0] in \\'01\\' else \\'3\\'\\n                elif i == 3:\\n                    time[i] = \\'5\\'\\n                elif i == 4:\\n                    time[i] = \\'9\\'\\n\\n        return \\'\\'.join(time)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n\\n        for i, ch in enumerate(time):\\n            if ch == \\'?\\':\\n                if i == 0:\\n                    time[i] = \\'2\\' if time[1] in \\'0123?\\' else \\'1\\'\\n                elif i == 1:\\n                    time[i] = \\'9\\' if time[0] in \\'01\\' else \\'3\\'\\n                elif i == 3:\\n                    time[i] = \\'5\\'\\n                elif i == 4:\\n                    time[i] = \\'9\\'\\n\\n        return \\'\\'.join(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701829,
                "title": "python-3-solution-easy-and-understandable",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hr,mn = time.split(\\':\\')\\n        hr = list(hr)\\n        mn = list(mn)\\n        if hr[0]==\\'?\\' and hr[1]!=\\'?\\':\\n            if 4<= int(hr[1]) <=9:\\n                hr[0] = \"1\"\\n            else:\\n                hr[0] = \"2\"\\n        if hr[1]==\\'?\\' and hr[0]!=\\'?\\':\\n            if hr[0] == \"2\":\\n                hr[1] = \"3\"\\n            else:\\n                hr[1] = \"9\"\\n                \\n        if hr[0]==\\'?\\' and hr[1]==\\'?\\':\\n            hr[0] = \"2\"\\n            hr[1] = \"3\"\\n        \\n        if mn[0] == \\'?\\' and mn[1]!=\\'?\\':\\n            mn[0] = \"5\"\\n        if mn[1] == \\'?\\' and mn[0]!=\\'?\\':\\n            mn[1] = \"9\"\\n        if mn[0] == \\'?\\' and mn[1]==\\'?\\':\\n            mn[0] = \"5\"\\n            mn[1] = \"9\"\\n        hr.append(\\':\\')\\n        return \"\".join(hr+mn)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hr,mn = time.split(\\':\\')\\n        hr = list(hr)\\n        mn = list(mn)\\n        if hr[0]==\\'?\\' and hr[1]!=\\'?\\':\\n            if 4<= int(hr[1]) <=9:\\n                hr[0] = \"1\"\\n            else:\\n                hr[0] = \"2\"\\n        if hr[1]==\\'?\\' and hr[0]!=\\'?\\':\\n            if hr[0] == \"2\":\\n                hr[1] = \"3\"\\n            else:\\n                hr[1] = \"9\"\\n                \\n        if hr[0]==\\'?\\' and hr[1]==\\'?\\':\\n            hr[0] = \"2\"\\n            hr[1] = \"3\"\\n        \\n        if mn[0] == \\'?\\' and mn[1]!=\\'?\\':\\n            mn[0] = \"5\"\\n        if mn[1] == \\'?\\' and mn[0]!=\\'?\\':\\n            mn[1] = \"9\"\\n        if mn[0] == \\'?\\' and mn[1]==\\'?\\':\\n            mn[0] = \"5\"\\n            mn[1] = \"9\"\\n        hr.append(\\':\\')\\n        return \"\".join(hr+mn)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527287,
                "title": "java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        StringBuffer sb = new StringBuffer(time);\\n        if (sb.charAt(0) == \\'?\\' && sb.charAt(1) == \\'?\\') {\\n            sb.setCharAt(0, \\'2\\');\\n            sb.setCharAt(1, \\'3\\');\\n        }\\n        if (sb.charAt(0) == \\'?\\') {\\n            sb.setCharAt(0, (sb.charAt(1) > \\'3\\' ? \\'1\\' : \\'2\\'));\\n        } \\n        if (sb.charAt(1) == \\'?\\') {\\n            sb.setCharAt(1, (sb.charAt(0) == \\'2\\' ? \\'3\\' : \\'9\\'));\\n        } \\n        if (sb.charAt(3) == \\'?\\') {\\n            sb.setCharAt(3, \\'5\\');\\n        }\\n        if (sb.charAt(4) == \\'?\\') {\\n            sb.setCharAt(4,\\'9\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        StringBuffer sb = new StringBuffer(time);\\n        if (sb.charAt(0) == \\'?\\' && sb.charAt(1) == \\'?\\') {\\n            sb.setCharAt(0, \\'2\\');\\n            sb.setCharAt(1, \\'3\\');\\n        }\\n        if (sb.charAt(0) == \\'?\\') {\\n            sb.setCharAt(0, (sb.charAt(1) > \\'3\\' ? \\'1\\' : \\'2\\'));\\n        } \\n        if (sb.charAt(1) == \\'?\\') {\\n            sb.setCharAt(1, (sb.charAt(0) == \\'2\\' ? \\'3\\' : \\'9\\'));\\n        } \\n        if (sb.charAt(3) == \\'?\\') {\\n            sb.setCharAt(3, \\'5\\');\\n        }\\n        if (sb.charAt(4) == \\'?\\') {\\n            sb.setCharAt(4,\\'9\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520020,
                "title": "java-simplest-solution-time-100-faster-memory-44-57",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        \\n        char[] ch=time.toCharArray();\\n        \\n        if (ch[0]==\\'?\\') {\\n            if (ch[1]==\\'?\\') {\\n                ch[0]=\\'2\\';\\n                ch[1]=\\'3\\';\\n            } else {\\n                if (ch[1]>\\'3\\') {\\n                    ch[0]=\\'1\\';\\n                } else {\\n                    ch[0]=\\'2\\';\\n                }\\n            }\\n        }\\n        \\n        if (ch[1]==\\'?\\') {\\n            if (ch[0]<\\'2\\') {\\n                ch[1]=\\'9\\';\\n            } else {\\n                ch[1]=\\'3\\';\\n            }\\n        }\\n        \\n        if (ch[3]==\\'?\\') {\\n            ch[3]=\\'5\\';\\n        }\\n        \\n        if (ch[4]==\\'?\\') {\\n            ch[4]=\\'9\\';\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        \\n        char[] ch=time.toCharArray();\\n        \\n        if (ch[0]==\\'?\\') {\\n            if (ch[1]==\\'?\\') {\\n                ch[0]=\\'2\\';\\n                ch[1]=\\'3\\';\\n            } else {\\n                if (ch[1]>\\'3\\') {\\n                    ch[0]=\\'1\\';\\n                } else {\\n                    ch[0]=\\'2\\';\\n                }\\n            }\\n        }\\n        \\n        if (ch[1]==\\'?\\') {\\n            if (ch[0]<\\'2\\') {\\n                ch[1]=\\'9\\';\\n            } else {\\n                ch[1]=\\'3\\';\\n            }\\n        }\\n        \\n        if (ch[3]==\\'?\\') {\\n            ch[3]=\\'5\\';\\n        }\\n        \\n        if (ch[4]==\\'?\\') {\\n            ch[4]=\\'9\\';\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450174,
                "title": "java-100-o-1-constant-time",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char t[] = time.toCharArray();\\n        if(t[0]==\\'?\\')\\n            t[0] = t[1]==\\'?\\'?\\'2\\':t[1]>\\'3\\'?\\'1\\':\\'2\\'; \\n            \\n        if(t[1]==\\'?\\')\\n            t[1] = t[0]==\\'2\\'?\\'3\\':\\'9\\';\\n        \\n        if(t[3]==\\'?\\')\\n            t[3] = \\'5\\';\\n        \\n        if(t[4]==\\'?\\')\\n            t[4] = \\'9\\';\\n        \\n        return String.valueOf(t);\\n    }\\n}\\n```\\n**Upvote if helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char t[] = time.toCharArray();\\n        if(t[0]==\\'?\\')\\n            t[0] = t[1]==\\'?\\'?\\'2\\':t[1]>\\'3\\'?\\'1\\':\\'2\\'; \\n            \\n        if(t[1]==\\'?\\')\\n            t[1] = t[0]==\\'2\\'?\\'3\\':\\'9\\';\\n        \\n        if(t[3]==\\'?\\')\\n            t[3] = \\'5\\';\\n        \\n        if(t[4]==\\'?\\')\\n            t[4] = \\'9\\';\\n        \\n        return String.valueOf(t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447074,
                "title": "py-latest-time-regex",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hh, mm = time.replace(\"?\",\"\\\\d\").split(\":\")\\n        H = re.search(hh, \\' \\'.join([str(h).zfill(2) for h in range(23,-1,-1)]))\\n        M = re.search(mm, \\' \\'.join([str(m).zfill(2) for m in range(59,-1,-1)]))\\n        return H[0] + \":\" + M[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hh, mm = time.replace(\"?\",\"\\\\d\").split(\":\")\\n        H = re.search(hh, \\' \\'.join([str(h).zfill(2) for h in range(23,-1,-1)]))\\n        M = re.search(mm, \\' \\'.join([str(m).zfill(2) for m in range(59,-1,-1)]))\\n        return H[0] + \":\" + M[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413621,
                "title": "python3-simplest-solution",
                "content": "```\\ndef maximumTime(self, time: str) -> str:\\n        Time = list(time)\\n        if Time[0]==\"?\":\\n            if Time[1] in \"?0123\":\\n                Time[0]=\"2\"\\n            else:\\n                Time[0]=\"1\"\\n        if Time[1]==\"?\":\\n            if Time[0] in \"01\":\\n                Time[1]=\"9\"\\n            else:\\n                Time[1]=\"3\"\\n        if Time[3]==\"?\":\\n            Time[3]=\"5\"\\n        if Time[4]==\"?\":\\n            Time[4]=\"9\"\\n        return \\'\\'.join(Time)",
                "solutionTags": [],
                "code": "```\\ndef maximumTime(self, time: str) -> str:\\n        Time = list(time)\\n        if Time[0]==\"?\":\\n            if Time[1] in \"?0123\":\\n                Time[0]=\"2\"\\n            else:\\n                Time[0]=\"1\"\\n        if Time[1]==\"?\":\\n            if Time[0] in \"01\":\\n                Time[1]=\"9\"\\n            else:\\n                Time[1]=\"3\"\\n        if Time[3]==\"?\":\\n            Time[3]=\"5\"\\n        if Time[4]==\"?\":\\n            Time[4]=\"9\"\\n        return \\'\\'.join(Time)",
                "codeTag": "Python3"
            },
            {
                "id": 1394209,
                "title": "python-looping-through-all-minutes-slow-but-neat",
                "content": "```\\n\\t\\tmax_time = \\'00:00\\'\\n     \\n        # Skip all the if statements that people are using and loop through \\n\\t\\t# all minutes between the hours of 00:00 and 23:59 \\n\\t\\t# by looping minutes variable from 0 to 59 and hours variable\\n\\t\\t# from 0 to 23 (inclusive): \\n        for hour in range(24):\\n            for minute in range(60):\\n               \\n                temp_time = (2-len(str(hour)))*\\'0\\' + str(hour) + \\':\\' + (2-len(str(minute)))*\\'0\\' + str(minute)\\n                \\n                # check whether or not the new/updated time\\n                # is compatible with the time variable/format. If so, update\\n                # it as the new max_time:\\n                new_time = True\\n                for kk in range(5):\\n                    if time[kk] != \\'?\\' and time[kk] != temp_time[kk]:\\n                        new_time = False\\n                        break\\n                        \\n                if new_time:\\n                    max_time = temp_time\\n\\t\\t\\n\\t\\t# return the last time to satisfy the time pattern:\\n        return(max_time)",
                "solutionTags": [],
                "code": "```\\n\\t\\tmax_time = \\'00:00\\'\\n     \\n        # Skip all the if statements that people are using and loop through \\n\\t\\t# all minutes between the hours of 00:00 and 23:59 \\n\\t\\t# by looping minutes variable from 0 to 59 and hours variable\\n\\t\\t# from 0 to 23 (inclusive): \\n        for hour in range(24):\\n            for minute in range(60):\\n               \\n                temp_time = (2-len(str(hour)))*\\'0\\' + str(hour) + \\':\\' + (2-len(str(minute)))*\\'0\\' + str(minute)\\n                \\n                # check whether or not the new/updated time\\n                # is compatible with the time variable/format. If so, update\\n                # it as the new max_time:\\n                new_time = True\\n                for kk in range(5):\\n                    if time[kk] != \\'?\\' and time[kk] != temp_time[kk]:\\n                        new_time = False\\n                        break\\n                        \\n                if new_time:\\n                    max_time = temp_time\\n\\t\\t\\n\\t\\t# return the last time to satisfy the time pattern:\\n        return(max_time)",
                "codeTag": "Unknown"
            },
            {
                "id": 1388320,
                "title": "easy-to-understand-javascript-solution-replaceall",
                "content": "\\tvar maximumTime = function(time) {\\n\\t\\tlet [hour, minute] = time.split(\\':\\');\\n\\n\\t\\thour = hour == \\'??\\' \\n\\t\\t\\t? 23\\n\\t\\t\\t: hour.replaceAll(\\'?\\', (str, index) => {\\n\\t\\t\\t\\treturn index === 0 ? +hour[1] <= 3 ? 2 : 1 : hour[0] == 2 ? 3 : 9;\\n\\t\\t\\t})\\n\\n\\t\\tminute = minute.replaceAll(\\'?\\', (str, index) => index === 0 ? 5 : 9);\\n\\n\\t\\treturn `${hour}:${minute}`;\\n\\t}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar maximumTime = function(time) {\\n\\t\\tlet [hour, minute] = time.split(\\':\\');\\n\\n\\t\\thour = hour == \\'??\\' \\n\\t\\t\\t? 23\\n\\t\\t\\t: hour.replaceAll(\\'?\\', (str, index) => {\\n\\t\\t\\t\\treturn index === 0 ? +hour[1] <= 3 ? 2 : 1 : hour[0] == 2 ? 3 : 9;\\n\\t\\t\\t})\\n\\n\\t\\tminute = minute.replaceAll(\\'?\\', (str, index) => index === 0 ? 5 : 9);\\n\\n\\t\\treturn `${hour}:${minute}`;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1226337,
                "title": "rust-greedy-o-1-with-explanation",
                "content": "```rs\\nimpl Solution {\\n    pub fn maximum_time(time: String) -> String {\\n        let second = time.chars().nth(1).unwrap(); // extract the character at index 1\\n        let third = time.chars().nth(3).unwrap(); // extract the character at index 3\\n        let fourth = time.chars().nth(4).unwrap();\\n        let mut accumulator = String::new(); // initialize string builder\\n        // set tens digit of hour\\n        if time.starts_with(\\'?\\') { // do we need to replace the first character?\\n            if \\'?\\' != second && second.to_digit(10).unwrap() > 3 { // if so, what do we replace with?\\n                accumulator.push(\\'1\\');\\n            } else {\\n                accumulator.push(\\'2\\');\\n            }\\n        } else {\\n            accumulator.push(time.chars().next().unwrap());\\n        }\\n        // set ones digit of hour\\n        if \\'?\\' == second { // do we need to replace the second character?\\n            if \"2\" == accumulator { //  if the first character is \"2\" then \"29\" isn\\'t a valid hour, so greedy strategy would fail\\n                accumulator.push(\\'3\\'); // instead \"23\" is the max hour\\n            } else {\\n                accumulator.push(\\'9\\');\\n            }\\n        } else {\\n            accumulator.push(second); // if no altering is needed, push the original number to our stringbuilder\\n        }\\n        accumulator.push(\\':\\'); // add hours -> minutes separator\\n        // set tens digit of minutes\\n        if \\'?\\' == third {\\n            accumulator.push(\\'5\\');\\n        } else {\\n            accumulator.push(third);\\n        }\\n        // set ones digit of minutes\\n        if \\'?\\' == fourth {\\n            accumulator.push(\\'9\\');\\n        } else {\\n            accumulator.push(fourth);\\n        }\\n        return accumulator;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```rs\\nimpl Solution {\\n    pub fn maximum_time(time: String) -> String {\\n        let second = time.chars().nth(1).unwrap(); // extract the character at index 1\\n        let third = time.chars().nth(3).unwrap(); // extract the character at index 3\\n        let fourth = time.chars().nth(4).unwrap();\\n        let mut accumulator = String::new(); // initialize string builder\\n        // set tens digit of hour\\n        if time.starts_with(\\'?\\') { // do we need to replace the first character?\\n            if \\'?\\' != second && second.to_digit(10).unwrap() > 3 { // if so, what do we replace with?\\n                accumulator.push(\\'1\\');\\n            } else {\\n                accumulator.push(\\'2\\');\\n            }\\n        } else {\\n            accumulator.push(time.chars().next().unwrap());\\n        }\\n        // set ones digit of hour\\n        if \\'?\\' == second { // do we need to replace the second character?\\n            if \"2\" == accumulator { //  if the first character is \"2\" then \"29\" isn\\'t a valid hour, so greedy strategy would fail\\n                accumulator.push(\\'3\\'); // instead \"23\" is the max hour\\n            } else {\\n                accumulator.push(\\'9\\');\\n            }\\n        } else {\\n            accumulator.push(second); // if no altering is needed, push the original number to our stringbuilder\\n        }\\n        accumulator.push(\\':\\'); // add hours -> minutes separator\\n        // set tens digit of minutes\\n        if \\'?\\' == third {\\n            accumulator.push(\\'5\\');\\n        } else {\\n            accumulator.push(third);\\n        }\\n        // set ones digit of minutes\\n        if \\'?\\' == fourth {\\n            accumulator.push(\\'9\\');\\n        } else {\\n            accumulator.push(fourth);\\n        }\\n        return accumulator;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206046,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        switch (time[0]) {\\n            case \\'0\\':\\n            case \\'1\\':\\n                if (\\'?\\' == time[1])\\n                    time[1] = \\'9\\';\\n                break;\\n            case \\'2\\':\\n                if (\\'?\\' == time[1])\\n                    time[1] = \\'3\\';\\n                break;\\n            case \\'?\\':\\n                if (\\'?\\' == time[1])\\n                    time[1] = \\'3\\';\\n                time[0] = \\'0\\' <= time[1] && time[1] <= \\'3\\' ? \\'2\\' : \\'1\\';\\n                break;\\n        }\\n        \\n        if (time[3] == \\'?\\')\\n            time[3] = \\'5\\';\\n        \\n        if (time[4] == \\'?\\')\\n            time[4] = \\'9\\';\\n        \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        switch (time[0]) {\\n            case \\'0\\':\\n            case \\'1\\':\\n                if (\\'?\\' == time[1])\\n                    time[1] = \\'9\\';\\n                break;\\n            case \\'2\\':\\n                if (\\'?\\' == time[1])\\n                    time[1] = \\'3\\';\\n                break;\\n            case \\'?\\':\\n                if (\\'?\\' == time[1])\\n                    time[1] = \\'3\\';\\n                time[0] = \\'0\\' <= time[1] && time[1] <= \\'3\\' ? \\'2\\' : \\'1\\';\\n                break;\\n        }\\n        \\n        if (time[3] == \\'?\\')\\n            time[3] = \\'5\\';\\n        \\n        if (time[4] == \\'?\\')\\n            time[4] = \\'9\\';\\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183793,
                "title": "if-else",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        x = [char for char in time]\\n        for i, char in enumerate(x):\\n            if char == \\'?\\':\\n                if i == 0:\\n                    x[i] = \\'2\\' if x[1] == \\'?\\' or int(x[1]) <= 3 else \\'1\\'\\n                elif i == 1:\\n                    x[i] = \\'9\\' if not x[0] == \\'2\\' else \\'3\\'\\n                elif i == 3:\\n                    x[i] = \\'5\\'\\n                else:\\n                    x[i] = \\'9\\'\\n        return \\'\\'.join(x)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        x = [char for char in time]\\n        for i, char in enumerate(x):\\n            if char == \\'?\\':\\n                if i == 0:\\n                    x[i] = \\'2\\' if x[1] == \\'?\\' or int(x[1]) <= 3 else \\'1\\'\\n                elif i == 1:\\n                    x[i] = \\'9\\' if not x[0] == \\'2\\' else \\'3\\'\\n                elif i == 3:\\n                    x[i] = \\'5\\'\\n                else:\\n                    x[i] = \\'9\\'\\n        return \\'\\'.join(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176200,
                "title": "97-87-faster-o-1-soln",
                "content": "![image](https://assets.leetcode.com/users/images/c52dc16c-eef0-4da8-b34e-e9ae970a3736_1619368648.5075634.png)\\n```\\npublic class Solution {\\n    // Time = Space = O(1)\\n    public string MaximumTime(string time) {\\n        char[] ans = time.ToCharArray();\\n        if(ans[4]==\\'?\\') ans[4] = \\'9\\';\\n        if(ans[3]==\\'?\\') ans[3] = \\'5\\';\\n        \\n        if(ans[0]==\\'?\\' && ans[1]==\\'?\\') {   ans[0]=\\'2\\';  ans[1]=\\'3\\';   }\\n        else if(ans[1]==\\'?\\') ans[1] = (ans[0]==\\'2\\') ? \\'3\\' : \\'9\\';\\n        else if(ans[0]==\\'?\\') ans[0] = (ans[1]-\\'0\\'>3) ? \\'1\\' : \\'2\\';\\n        \\n        return new string(ans);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time = Space = O(1)\\n    public string MaximumTime(string time) {\\n        char[] ans = time.ToCharArray();\\n        if(ans[4]==\\'?\\') ans[4] = \\'9\\';\\n        if(ans[3]==\\'?\\') ans[3] = \\'5\\';\\n        \\n        if(ans[0]==\\'?\\' && ans[1]==\\'?\\') {   ans[0]=\\'2\\';  ans[1]=\\'3\\';   }\\n        else if(ans[1]==\\'?\\') ans[1] = (ans[0]==\\'2\\') ? \\'3\\' : \\'9\\';\\n        else if(ans[0]==\\'?\\') ans[0] = (ans[1]-\\'0\\'>3) ? \\'1\\' : \\'2\\';\\n        \\n        return new string(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167444,
                "title": "java-pure-implementation",
                "content": "\\tclass Solution {\\n\\t\\tpublic String maximumTime(String time) {\\n\\t\\t\\tchar[] input = time.toCharArray();\\n\\n\\t\\t\\tif (input[0] == \\'?\\') {\\n\\t\\t\\t\\tif (input[1] != \\'?\\' && input[1] >= \\'4\\') {\\n\\t\\t\\t\\t\\tinput[0] = \\'1\\';\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tinput[0] = \\'2\\';\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tif (input[1] == \\'?\\') {\\n\\t\\t\\t\\tif (input[0] == \\'2\\') {\\n\\t\\t\\t\\t\\tinput[1] = \\'3\\';\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tinput[1] = \\'9\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (input[3] == \\'?\\') {\\n\\t\\t\\t\\tinput[3] = \\'5\\';\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (input[4] == \\'?\\') {\\n\\t\\t\\t\\tinput[4] = \\'9\\';\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new String(input);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic String maximumTime(String time) {\\n\\t\\t\\tchar[] input = time.toCharArray();\\n\\n\\t\\t\\tif (input[0] == \\'?\\') {\\n\\t\\t\\t\\tif (input[1] != \\'?\\' && input[1] >= \\'4\\') {\\n\\t\\t\\t\\t\\tinput[0] = \\'1\\';\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1160456,
                "title": "python-solution-with-constraint-satisfaction",
                "content": "\\tfrom itertools import product\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maximumTime(self, time: str) -> str:\\n\\t\\t\\tCONSTRAINTS = lambda a, b, c, d:  [int(a+b) <= 23, int(c+d) <= 59]\\n\\n\\t\\t\\ta,b,_,c,d = time\\n\\n\\t\\t\\taX = [str(i) for i in range(2,-1,-1)] if a == \"?\" else [a]\\n\\t\\t\\tbX = [str(i) for i in range(9,-1,-1)] if b == \"?\" else [b]\\n\\t\\t\\tcX = [str(i) for i in range(5,-1,-1)] if c == \"?\" else [c]\\n\\t\\t\\tdX = [str(i) for i in range(9,-1,-1)] if d == \"?\" else [d]\\n\\n\\t\\t\\tp = product(aX, bX, cX, dX)\\n\\t\\t\\tfor guess in p:\\n\\t\\t\\t\\tif all(CONSTRAINTS(*guess)):\\n\\t\\t\\t\\t\\treturn \"{}{}:{}{}\".format(*guess)\\n                \\nBasic idea: there are in the worst case 3 * 10 * 6 * 10  legal combinations (which corresponds to ??:??), which means we can use \\'brute force\\' enumeration of all cases and the code is still O(1). \\n\\nThere are a few small optimisations regarding the use of product; firstly we setup the strings aX, bX, ... in reverse order, meaning that sequences are generated largest to smallest. Given this ordering, we can break the moment we find the first sequence that satifies all constraints. Also the fact the product returns a generator means we are fairly efficient in terms of memory too.\\n\\nThis isn\\'t the most efficient way to solve the problem, but I thought I\\'d share my solution because I personally thought it was kinda neat ;)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef maximumTime(self, time: str) -> str:\\n\\t\\t\\tCONSTRAINTS = lambda a, b, c, d:  [int(a+b) <= 23, int(c+d) <= 59]\\n\\n\\t\\t\\ta,b,_,c,d = time\\n\\n\\t\\t\\taX = [str(i) for i in range(2,-1,-1)] if a == \"?\" else [a]\\n\\t\\t\\tbX = [str(i) for i in range(9,-1,-1)] if b == \"?\" else [b]\\n\\t\\t\\tcX = [str(i) for i in range(5,-1,-1)] if c == \"?\" else [c]\\n\\t\\t\\tdX = [str(i) for i in range(9,-1,-1)] if d == \"?\" else [d]\\n\\n\\t\\t\\tp = product(aX, bX, cX, dX)\\n\\t\\t\\tfor guess in p:\\n\\t\\t\\t\\tif all(CONSTRAINTS(*guess)):\\n\\t\\t\\t\\t\\treturn \"{}",
                "codeTag": "Java"
            },
            {
                "id": 1153935,
                "title": "simple-java-soln",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        \\n        String result = \"\";\\n        for(int i=0;i<time.length();i++)\\n        {\\n            if(time.charAt(i) == \\'?\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(time.charAt(i+1)!=\\'?\\')\\n                    {\\n                        if(time.charAt(i+1)-\\'0\\' >=4)\\n                            result = \"1\";\\n                        else\\n                            result = \"2\";\\n                    }\\n                    else\\n                        result = \"2\";\\n                }\\n                if(i==1)\\n                {\\n                    if(result.charAt(0)==\\'2\\')\\n                        result = result+\"3\";\\n                    else\\n                        result = result+\"9\";\\n                }\\n                if(i==3)\\n                    result = result+\"5\";\\n                if(i==4)\\n                    result = result+\"9\";\\n            }\\n            else\\n                result = result+time.charAt(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        \\n        String result = \"\";\\n        for(int i=0;i<time.length();i++)\\n        {\\n            if(time.charAt(i) == \\'?\\')\\n            {\\n                if(i==0)\\n                {\\n                    if(time.charAt(i+1)!=\\'?\\')\\n                    {\\n                        if(time.charAt(i+1)-\\'0\\' >=4)\\n                            result = \"1\";\\n                        else\\n                            result = \"2\";\\n                    }\\n                    else\\n                        result = \"2\";\\n                }\\n                if(i==1)\\n                {\\n                    if(result.charAt(0)==\\'2\\')\\n                        result = result+\"3\";\\n                    else\\n                        result = result+\"9\";\\n                }\\n                if(i==3)\\n                    result = result+\"5\";\\n                if(i==4)\\n                    result = result+\"9\";\\n            }\\n            else\\n                result = result+time.charAt(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083680,
                "title": "turn-to-character-array-and-replace-each-character",
                "content": "```\\n/**\\n * Problem\\n *     1736.Latest Time by Replacing Hidden Digits\\n *     https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/\\n *     https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/\\n *     https://github.com/cartoonYu/LeetCodeSolution/blob/master/src/main/java/org/LeetcodeSolution/Greedy/Solution1736.java\\n * Grade of difficulty\\n *     Easy\\n * Related topics\\n * @author cartoon\\n * @version 1.0\\n */\\npublic class Solution1736 {\\n\\n    /**\\n     * 1.About Complexity\\n     *     1.1 Time Complexity is O(1)\\n     *     1.2 Space Complexity is O(n)\\n     * 2.how I solve\\n     *     2.1 turn income string to character array\\n     *         2.1.1 replace first character according to second character\\n     *         2.1.2 replace second character according to first character\\n     *         2.1.3 replace third character as bigger as possible\\n     *         2.1.4 replace forth character according to third character\\n     * 3.About submit record\\n     *     3.1 0ms and 36.7MB memory in LeetCode China\\n     *     3.2 0ms and 37.3MB memory in LeetCode\\n     * 4.Q&A\\n     * @param time\\n     * @return\\n     */\\n    public String maximumTime(String time) {\\n        char[] chars = time.toCharArray();\\n        if(chars[0] == \\'?\\'){\\n            if(chars[1] == \\'?\\' || chars[1] < \\'4\\'){\\n                chars[0] = \\'2\\';\\n            } else{\\n                chars[0] = \\'1\\';\\n            }\\n        }\\n        if(chars[1] == \\'?\\'){\\n            if(chars[0] == \\'2\\'){\\n                chars[1] = \\'3\\';\\n            } else{\\n                chars[1] = \\'9\\';\\n            }\\n        }\\n        if(chars[3] == \\'?\\'){\\n            chars[3] = \\'5\\';\\n        }\\n        if(chars[4] == \\'?\\'){\\n            chars[4] = \\'9\\';\\n        }\\n        return new String(chars);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Problem\\n *     1736.Latest Time by Replacing Hidden Digits\\n *     https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/\\n *     https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/\\n *     https://github.com/cartoonYu/LeetCodeSolution/blob/master/src/main/java/org/LeetcodeSolution/Greedy/Solution1736.java\\n * Grade of difficulty\\n *     Easy\\n * Related topics\\n * @author cartoon\\n * @version 1.0\\n */\\npublic class Solution1736 {\\n\\n    /**\\n     * 1.About Complexity\\n     *     1.1 Time Complexity is O(1)\\n     *     1.2 Space Complexity is O(n)\\n     * 2.how I solve\\n     *     2.1 turn income string to character array\\n     *         2.1.1 replace first character according to second character\\n     *         2.1.2 replace second character according to first character\\n     *         2.1.3 replace third character as bigger as possible\\n     *         2.1.4 replace forth character according to third character\\n     * 3.About submit record\\n     *     3.1 0ms and 36.7MB memory in LeetCode China\\n     *     3.2 0ms and 37.3MB memory in LeetCode\\n     * 4.Q&A\\n     * @param time\\n     * @return\\n     */\\n    public String maximumTime(String time) {\\n        char[] chars = time.toCharArray();\\n        if(chars[0] == \\'?\\'){\\n            if(chars[1] == \\'?\\' || chars[1] < \\'4\\'){\\n                chars[0] = \\'2\\';\\n            } else{\\n                chars[0] = \\'1\\';\\n            }\\n        }\\n        if(chars[1] == \\'?\\'){\\n            if(chars[0] == \\'2\\'){\\n                chars[1] = \\'3\\';\\n            } else{\\n                chars[1] = \\'9\\';\\n            }\\n        }\\n        if(chars[3] == \\'?\\'){\\n            chars[3] = \\'5\\';\\n        }\\n        if(chars[4] == \\'?\\'){\\n            chars[4] = \\'9\\';\\n        }\\n        return new String(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075997,
                "title": "100-00-faster-c-solution",
                "content": "class Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\' && time[1]==\\'?\\'){\\n            time[0]=\\'2\\';\\n            time[1]=\\'3\\';\\n        }\\n        if(time[0]==\\'?\\' && time[1]!=\\'?\\' && time[1]<=\\'3\\'){\\n            time[0]=\\'2\\';\\n        }\\n        if(time[0]==\\'?\\' && time[1]!=\\'?\\' && time[1]>\\'3\\'){\\n            time[0]=\\'1\\';\\n        }\\n        if(time[0]!=\\'?\\' && time[1]==\\'?\\'){\\n            if(time[0]==\\'0\\'){\\n                time[1]=\\'9\\';\\n            }\\n            if(time[0]==\\'1\\'){\\n                time[1]=\\'9\\';\\n            }\\n            if(time[0]==\\'2\\'){\\n                time[1]=\\'3\\';\\n            }\\n        }\\n        if(time[3]==\\'?\\' && time[4]==\\'?\\'){\\n            time[3]=\\'5\\';\\n            time[4]=\\'9\\';\\n        }\\n        if(time[3]==\\'?\\' && time[4]!=\\'?\\'){\\n            time[3]=\\'5\\';\\n        }\\n        if(time[3]!=\\'?\\' && time[4]==\\'?\\'){\\n            time[4]=\\'9\\';\\n        }\\n        return time;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\' && time[1]==\\'?\\'){\\n            time[0]=\\'2\\';\\n            time[1]=\\'3\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1060907,
                "title": "c-using-branches-for-the-rules-rather-than-ternary-operators",
                "content": "We copy the input string and look at each digit to see if it has a question mark that needs replacing.\\nThe hour digits are coupled to each other but the minutes are independent and so trivial. For the first hour digit we need to look ahead to the second and for the second we need to look back to the first. We also need to do the hour digits from most to least significant.\\n\\n```c++\\n    const static string maximumTime(string time)\\n    {\\n        if(time[0] == \\'?\\') {\\n            // By default let\\'s make the first digit a one to avoid an else\\n            // to the branch below:\\n            time[0] = \\'1\\';\\n            // Look ahead to the next digit. If it is undefined or less than 4,\\n            // we can increase our first digit to a 2:\\n            if((time[1] == \\'?\\') || (time[1] - \\'0\\' < 4)){\\n                time[0] = \\'2\\';\\n            }\\n        }\\n        \\n        // The second hour digit depends on whether the first is a 2.\\n        // if it is we can only go up to a 3 here, but if it is a 0 or a 1,\\n        // we can go all the way to a 9:\\n        if(time[1] == \\'?\\'){\\n            // Default to setting to nine:\\n            time[1] = \\'9\\';\\n            // Adjust down to a three if necessary:\\n            if(time[0] == \\'2\\'){\\n                time[1] = \\'3\\';\\n            }\\n        }\\n        \\n        // The last two digits are trivial. We can always set either minute digit to the maximum:\\n        if(time[3] == \\'?\\') time[3] = \\'5\\';\\n        if(time[4] == \\'?\\') time[4] = \\'9\\';\\n        \\n        return time;\\n    }\\n```\\n\\nFor a denser (four line) presentation of the same logic, look here: https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/discuss/1060917/C%2B%2B-Four-Lines",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n    const static string maximumTime(string time)\\n    {\\n        if(time[0] == \\'?\\') {\\n            // By default let\\'s make the first digit a one to avoid an else\\n            // to the branch below:\\n            time[0] = \\'1\\';\\n            // Look ahead to the next digit. If it is undefined or less than 4,\\n            // we can increase our first digit to a 2:\\n            if((time[1] == \\'?\\') || (time[1] - \\'0\\' < 4)){\\n                time[0] = \\'2\\';\\n            }\\n        }\\n        \\n        // The second hour digit depends on whether the first is a 2.\\n        // if it is we can only go up to a 3 here, but if it is a 0 or a 1,\\n        // we can go all the way to a 9:\\n        if(time[1] == \\'?\\'){\\n            // Default to setting to nine:\\n            time[1] = \\'9\\';\\n            // Adjust down to a three if necessary:\\n            if(time[0] == \\'2\\'){\\n                time[1] = \\'3\\';\\n            }\\n        }\\n        \\n        // The last two digits are trivial. We can always set either minute digit to the maximum:\\n        if(time[3] == \\'?\\') time[3] = \\'5\\';\\n        if(time[4] == \\'?\\') time[4] = \\'9\\';\\n        \\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042802,
                "title": "simple-easy-c-faster-than-100-solution",
                "content": "```\\nstring maximumTime(string time) {\\nif(time[0] == \\'?\\')\\n\\t\\ttime[0] = (time[1] > \\'3\\' && time[1] != \\'?\\') ? \\'1\\' : \\'2\\';\\n\\t\\t\\n\\tif(time[1] == \\'?\\')\\n\\t\\ttime[1] = (time[0] != \\'2\\') ? \\'9\\' : \\'3\\';\\n\\t\\t\\n\\tif(time[3] == \\'?\\')\\n\\t\\ttime[3] = \\'5\\';\\n\\t\\t\\n\\tif(time[4] == \\'?\\')\\n\\t\\ttime[4] = \\'9\\';\\n\\n\\treturn time;\\n    }\\n```\\nIf you have any questions drop them below \\u2B07 and if you liked the solution, smash that **Upvote** button",
                "solutionTags": [],
                "code": "```\\nstring maximumTime(string time) {\\nif(time[0] == \\'?\\')\\n\\t\\ttime[0] = (time[1] > \\'3\\' && time[1] != \\'?\\') ? \\'1\\' : \\'2\\';\\n\\t\\t\\n\\tif(time[1] == \\'?\\')\\n\\t\\ttime[1] = (time[0] != \\'2\\') ? \\'9\\' : \\'3\\';\\n\\t\\t\\n\\tif(time[3] == \\'?\\')\\n\\t\\ttime[3] = \\'5\\';\\n\\t\\t\\n\\tif(time[4] == \\'?\\')\\n\\t\\ttime[4] = \\'9\\';\\n\\n\\treturn time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041829,
                "title": "c-simple-o-1-100-time-enjoy",
                "content": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        int h1,h2,m1,m2;\\n        h1=time[0]==\\'?\\'?-1:time[0]-\\'0\\';\\n        h2=time[1]==\\'?\\'?-1:time[1]-\\'0\\';\\n        m1=time[3]==\\'?\\'?-1:time[3]-\\'0\\';\\n        m2=time[4]==\\'?\\'?-1:time[4]-\\'0\\';\\n        if(h1==-1){\\n            if(h2==-1){\\n                h1=2,h2=3;\\n            }\\n            else if(h2<4){\\n                h1=2;\\n            }\\n            else\\n                h1=1;\\n        }\\n        else if(h2==-1){\\n            if(h1==2){\\n                h2=3;\\n            }\\n            else\\n                h2=9;\\n        }\\n        if(m1==-1){\\n            if(m2==-1){\\n                m1=5,m2=9;\\n            }\\n            else\\n                m1=5;\\n        }\\n        else if(m2==-1){\\n                m2=9;\\n        }\\n        return to_string(h1)+to_string(h2)+\":\"+to_string(m1)+to_string(m2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        int h1,h2,m1,m2;\\n        h1=time[0]==\\'?\\'?-1:time[0]-\\'0\\';\\n        h2=time[1]==\\'?\\'?-1:time[1]-\\'0\\';\\n        m1=time[3]==\\'?\\'?-1:time[3]-\\'0\\';\\n        m2=time[4]==\\'?\\'?-1:time[4]-\\'0\\';\\n        if(h1==-1){\\n            if(h2==-1){\\n                h1=2,h2=3;\\n            }\\n            else if(h2<4){\\n                h1=2;\\n            }\\n            else\\n                h1=1;\\n        }\\n        else if(h2==-1){\\n            if(h1==2){\\n                h2=3;\\n            }\\n            else\\n                h2=9;\\n        }\\n        if(m1==-1){\\n            if(m2==-1){\\n                m1=5,m2=9;\\n            }\\n            else\\n                m1=5;\\n        }\\n        else if(m2==-1){\\n                m2=9;\\n        }\\n        return to_string(h1)+to_string(h2)+\":\"+to_string(m1)+to_string(m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035580,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Latest Time by Replacing Hidden Digits.\\nMemory Usage: 2 MB, less than 78.43% of Go online submissions for Latest Time by Replacing Hidden Digits.\\n\\n```go\\nfunc maximumTime(time string) string {\\n    tmp := []byte(time)\\n    if tmp[3] == \\'?\\' { tmp[3] = \\'5\\' }\\n    if tmp[4] == \\'?\\' { tmp[4] = \\'9\\' }\\n    if tmp[0] == \\'?\\' {\\n        if int(tmp[1] - \\'0\\') > 3 && int(tmp[1] - \\'0\\') < 10 {\\n            tmp[0] = \\'1\\'\\n        } else {\\n            tmp[0] = \\'2\\'\\n        }\\n    }\\n    if tmp[1] == \\'?\\' { tmp[1] = \\'9\\' }\\n    if tmp[0] == \\'2\\' && tmp[1] == \\'9\\' { tmp[1] = \\'3\\' }\\n    return string(tmp)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maximumTime(time string) string {\\n    tmp := []byte(time)\\n    if tmp[3] == \\'?\\' { tmp[3] = \\'5\\' }\\n    if tmp[4] == \\'?\\' { tmp[4] = \\'9\\' }\\n    if tmp[0] == \\'?\\' {\\n        if int(tmp[1] - \\'0\\') > 3 && int(tmp[1] - \\'0\\') < 10 {\\n            tmp[0] = \\'1\\'\\n        } else {\\n            tmp[0] = \\'2\\'\\n        }\\n    }\\n    if tmp[1] == \\'?\\' { tmp[1] = \\'9\\' }\\n    if tmp[0] == \\'2\\' && tmp[1] == \\'9\\' { tmp[1] = \\'3\\' }\\n    return string(tmp)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034670,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func maximumTime(_ time: String) -> String {\\n        let t = Array(time).map({ Int(String($0)) ?? -1 })\\n        return \"\\\\(t[0] >= 0 ? t[0] : (t[1] < 4 ? 2 : 1))\\\\(t[1] >= 0 ? t[1] : (t[0] == -1 || t[0] == 2 ? 3 : 9)):\\\\(t[3] >= 0 ? t[3] : 5)\\\\(t[4] >= 0 ? t[4] : 9)\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumTime(_ time: String) -> String {\\n        let t = Array(time).map({ Int(String($0)) ?? -1 })\\n        return \"\\\\(t[0] >= 0 ? t[0] : (t[1] < 4 ? 2 : 1))\\\\(t[1] >= 0 ? t[1] : (t[0] == -1 || t[0] == 2 ? 3 : 9)):\\\\(t[3] >= 0 ? t[3] : 5)\\\\(t[4] >= 0 ? t[4] : 9)\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034096,
                "title": "very-easy-just-using-if-else-statements-in-c-100-faster",
                "content": "class Solution {\\npublic:\\n    string maximumTime(string s) {\\n        int n=s.size();\\n        if(s[0]==\\'?\\'&&(s[1]==\\'1\\'||s[1]==\\'2\\'||s[1]==\\'3\\'||s[1]==\\'0\\'||s[1]==\\'?\\'))\\n        {\\n            s[0]=\\'2\\';\\n        }\\n        else if(s[0]==\\'?\\')\\n        {\\n            s[0]=\\'1\\';\\n        }\\n         if(s[1]==\\'?\\')\\n        {\\n            if(s[0]==\\'1\\'||s[0]==\\'0\\')\\n            {\\n                s[1]=\\'9\\';\\n            }\\n            else if(s[0]==\\'2\\')\\n            {\\n                s[1]=\\'3\\';\\n            }\\n           \\n        }\\n        if(s[n-1]==\\'?\\')\\n        {\\n            s[n-1]=\\'9\\';\\n        }\\n         if(s[n-2]==\\'?\\')\\n        {\\n           s[n-2]=\\'5\\';\\n        }\\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string maximumTime(string s) {\\n        int n=s.size();\\n        if(s[0]==\\'?\\'&&(s[1]==\\'1\\'||s[1]==\\'2\\'||s[1]==\\'3\\'||s[1]==\\'0\\'||s[1]==\\'?\\'))\\n        {\\n            s[0]=\\'2\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1033214,
                "title": "easy-java-solution-super-fast",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] times = time.toCharArray();\\n        if(times[0] == \\'?\\') {\\n            if(times[1] <= \\'3\\') {\\n                times[0] = \\'2\\';\\n                }\\n            else if(times[1] == \\'?\\'){\\n                times[0] = \\'2\\';\\n            }\\n            else{\\n                times[0] = \\'1\\';\\n            }\\n        }\\n        if(times[1] == \\'?\\') {\\n            if(times[0] == \\'2\\') {\\n                times[1] = \\'3\\';\\n            }\\n            else{\\n                times[1] = \\'9\\';\\n            }\\n        }\\n        if(times[3] == \\'?\\') {\\n            times[3] = \\'5\\';\\n        }\\n        if(times[4] == \\'?\\') {\\n            times[4] = \\'9\\';\\n        }\\n        return new String(times);\\n    }\\n}\\n```\\nKindly comment for any doubts :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] times = time.toCharArray();\\n        if(times[0] == \\'?\\') {\\n            if(times[1] <= \\'3\\') {\\n                times[0] = \\'2\\';\\n                }\\n            else if(times[1] == \\'?\\'){\\n                times[0] = \\'2\\';\\n            }\\n            else{\\n                times[0] = \\'1\\';\\n            }\\n        }\\n        if(times[1] == \\'?\\') {\\n            if(times[0] == \\'2\\') {\\n                times[1] = \\'3\\';\\n            }\\n            else{\\n                times[1] = \\'9\\';\\n            }\\n        }\\n        if(times[3] == \\'?\\') {\\n            times[3] = \\'5\\';\\n        }\\n        if(times[4] == \\'?\\') {\\n            times[4] = \\'9\\';\\n        }\\n        return new String(times);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032949,
                "title": "java-100-easy-with-comments",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {  \\n    char [] sa = time.toCharArray();\\n        if( sa[0] == \\'?\\')  //  if second  digit >3 , this this should \\'1\\', else hour will go above 24 hrs format\\n        {\\n            sa[0]  = (sa[1] != \\'?\\' && sa[1] > \\'3\\') ? \\'1\\': \\'2\\' ;\\n        }\\n        if( sa[1] == \\'?\\')  // if first digit is 2 , this can be atmost \\'3\\', else  at most \\'9\\'\\n        {\\n            sa[1] = (sa[0] == \\'2\\') ? \\'3\\' : \\'9\\';\\n        }\\n        if( sa[3] == \\'?\\')  sa[3] = \\'5\\';\\n        if( sa[4] == \\'?\\')  sa[4] = \\'9\\';\\n    return(new String(sa));    \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {  \\n    char [] sa = time.toCharArray();\\n        if( sa[0] == \\'?\\')  //  if second  digit >3 , this this should \\'1\\', else hour will go above 24 hrs format\\n        {\\n            sa[0]  = (sa[1] != \\'?\\' && sa[1] > \\'3\\') ? \\'1\\': \\'2\\' ;\\n        }\\n        if( sa[1] == \\'?\\')  // if first digit is 2 , this can be atmost \\'3\\', else  at most \\'9\\'\\n        {\\n            sa[1] = (sa[0] == \\'2\\') ? \\'3\\' : \\'9\\';\\n        }\\n        if( sa[3] == \\'?\\')  sa[3] = \\'5\\';\\n        if( sa[4] == \\'?\\')  sa[4] = \\'9\\';\\n    return(new String(sa));    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032098,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string s) {\\n        \\n        char a[]={\\'2\\',\\'9\\',\\'0\\',\\'5\\',\\'9\\'};\\n        \\n        for(int i=0;i<5;i++){\\n            if(s[i]==\\'?\\'){\\n                \\n                if(i==0){\\n                    if(s[i+1]!=\\'?\\' && s[i+1]>=\\'4\\')s[i]=\\'1\\';\\n                    else s[i]=a[i];\\n                }else if(i==1){\\n                    if(s[i-1]==\\'2\\')s[i]=\\'3\\';\\n                    else s[i]=a[i];\\n                }else{\\n                    s[i]=a[i];\\n                }\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string s) {\\n        \\n        char a[]={\\'2\\',\\'9\\',\\'0\\',\\'5\\',\\'9\\'};\\n        \\n        for(int i=0;i<5;i++){\\n            if(s[i]==\\'?\\'){\\n                \\n                if(i==0){\\n                    if(s[i+1]!=\\'?\\' && s[i+1]>=\\'4\\')s[i]=\\'1\\';\\n                    else s[i]=a[i];\\n                }else if(i==1){\\n                    if(s[i-1]==\\'2\\')s[i]=\\'3\\';\\n                    else s[i]=a[i];\\n                }else{\\n                    s[i]=a[i];\\n                }\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032092,
                "title": "6-line-javascript",
                "content": "The max hour depends on both hour digits:\\n1. If we see \\'?x\\', there are two possibilities:\\n  a. x is \\'?\\' or between 0-3, then max is 23\\n  b. x > 3, than max is 1x. For example, if x=8, max hour is 18, not 28\\n2. if we see \\'x?\\', there are two possibilities:\\n  a. x is 2, then max is 23\\n  b. x is 0-1, then max hour digits are x9\\n\\nThe max minute is always 59.  \\n\\n```\\nvar maximumTime = function(time) {\\n  const t = time.split(\\'\\')\\n  if (t[0] === \\'?\\') t[0] = \\'0123?\\'.includes(t[1]) ? \\'2\\' : \\'1\\'\\n  if (t[1] === \\'?\\') t[1] = t[0] === \\'2\\' ? \\'3\\' : \\'9\\'\\n  if (t[3] === \\'?\\') t[3] = \\'5\\'\\n  if (t[4] === \\'?\\') t[4] = \\'9\\'\\n  return t.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTime = function(time) {\\n  const t = time.split(\\'\\')\\n  if (t[0] === \\'?\\') t[0] = \\'0123?\\'.includes(t[1]) ? \\'2\\' : \\'1\\'\\n  if (t[1] === \\'?\\') t[1] = t[0] === \\'2\\' ? \\'3\\' : \\'9\\'\\n  if (t[3] === \\'?\\') t[3] = \\'5\\'\\n  if (t[4] === \\'?\\') t[4] = \\'9\\'\\n  return t.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032033,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {        \\n        char[] times = time.toCharArray();\\n        if(times[0] == \\'?\\') {\\n            times[0] = times[1] <= \\'3\\' || times[1] == \\'?\\' ? \\'2\\' : \\'1\\';\\n        }\\n        \\n        if(times[1] == \\'?\\') {\\n            times[1] = times[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n        \\n        if(times[3] == \\'?\\') {\\n            times[3] = \\'5\\';\\n        }\\n        \\n        if(times[4] == \\'?\\') {\\n            times[4] = \\'9\\';\\n        }\\n        \\n        return new String(times);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {        \\n        char[] times = time.toCharArray();\\n        if(times[0] == \\'?\\') {\\n            times[0] = times[1] <= \\'3\\' || times[1] == \\'?\\' ? \\'2\\' : \\'1\\';\\n        }\\n        \\n        if(times[1] == \\'?\\') {\\n            times[1] = times[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n        \\n        if(times[3] == \\'?\\') {\\n            times[3] = \\'5\\';\\n        }\\n        \\n        if(times[4] == \\'?\\') {\\n            times[4] = \\'9\\';\\n        }\\n        \\n        return new String(times);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101720,
                "title": "worst-solution-most-complicated-way-do-not-use-in-an-interview",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        std::unordered_map<int,int> maximums_set1{{0,2},{1,3},{3,5},{4,9}};\\n        std::unordered_map<int,int> maximums_set2{{0,1},{1,9},{3,5},{4,9}};\\n        std::string result1{find_max_time(maximums_set1,time)};\\n        std::string result2{find_max_time(maximums_set2,time)};\\n        std::string result1_ = remove_colon(result1);\\n        std::string result2_ = remove_colon(result2);\\n        int result1_int = std::stoi(result1_);\\n        int result2_int = std::stoi(result2_);\\n        result1_int%=2400;\\n        result2_int%=2400;\\n        return result1_int>result2_int?result1:result2;\\n    }\\n\\n    std::string find_max_time(std::unordered_map<int,int>& maximums,std::string time){\\n        std::string result{};\\n        for(int i{};i<time.size();i++){\\n            char c = time[i];\\n            if(c==\\'?\\'){\\n                auto found = maximums.find(i);\\n                if(found!=maximums.end()){\\n                    char k = found->second +\\'0\\';\\n                    result.push_back(k);\\n                }\\n            }\\n            else{\\n                result.push_back(c);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    std::string remove_colon(std::string s){\\n        std::string result{s};\\n        // Remove colon from the string\\n        size_t colonPos = result.find(\\':\\');\\n        if (colonPos != std::string::npos) {\\n            result.erase(colonPos, 1);\\n        }\\n        return result;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        std::unordered_map<int,int> maximums_set1{{0,2},{1,3},{3,5},{4,9}};\\n        std::unordered_map<int,int> maximums_set2{{0,1},{1,9},{3,5},{4,9}};\\n        std::string result1{find_max_time(maximums_set1,time)};\\n        std::string result2{find_max_time(maximums_set2,time)};\\n        std::string result1_ = remove_colon(result1);\\n        std::string result2_ = remove_colon(result2);\\n        int result1_int = std::stoi(result1_);\\n        int result2_int = std::stoi(result2_);\\n        result1_int%=2400;\\n        result2_int%=2400;\\n        return result1_int>result2_int?result1:result2;\\n    }\\n\\n    std::string find_max_time(std::unordered_map<int,int>& maximums,std::string time){\\n        std::string result{};\\n        for(int i{};i<time.size();i++){\\n            char c = time[i];\\n            if(c==\\'?\\'){\\n                auto found = maximums.find(i);\\n                if(found!=maximums.end()){\\n                    char k = found->second +\\'0\\';\\n                    result.push_back(k);\\n                }\\n            }\\n            else{\\n                result.push_back(c);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    std::string remove_colon(std::string s){\\n        std::string result{s};\\n        // Remove colon from the string\\n        size_t colonPos = result.find(\\':\\');\\n        if (colonPos != std::string::npos) {\\n            result.erase(colonPos, 1);\\n        }\\n        return result;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101489,
                "title": "simple-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please Upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        StringBuilder sb = new StringBuilder();\\n        if(time.charAt(4) == \\'?\\')sb.append(9);\\n        else sb.append(time.charAt(4));\\n        if(time.charAt(3) == \\'?\\')sb.append(5);\\n        else sb.append(time.charAt(3));\\n        sb.append(\\':\\');\\n        if(time.charAt(1) == \\'?\\' && time.charAt(0)-\\'0\\' <2) sb.append(9);\\n        else if(time.charAt(1) == \\'?\\') {\\n            sb.append(3);\\n        }\\n        else sb.append(time.charAt(1));\\n        if(time.charAt(0) == \\'?\\' && (time.charAt(1)-\\'0\\' < 4 || time.charAt(1) ==\\'?\\'))sb.append(2);\\n        else if(time.charAt(0) == \\'?\\'){\\n            sb.append(1);\\n        }\\n        else sb.append(time.charAt(0));\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        StringBuilder sb = new StringBuilder();\\n        if(time.charAt(4) == \\'?\\')sb.append(9);\\n        else sb.append(time.charAt(4));\\n        if(time.charAt(3) == \\'?\\')sb.append(5);\\n        else sb.append(time.charAt(3));\\n        sb.append(\\':\\');\\n        if(time.charAt(1) == \\'?\\' && time.charAt(0)-\\'0\\' <2) sb.append(9);\\n        else if(time.charAt(1) == \\'?\\') {\\n            sb.append(3);\\n        }\\n        else sb.append(time.charAt(1));\\n        if(time.charAt(0) == \\'?\\' && (time.charAt(1)-\\'0\\' < 4 || time.charAt(1) ==\\'?\\'))sb.append(2);\\n        else if(time.charAt(0) == \\'?\\'){\\n            sb.append(1);\\n        }\\n        else sb.append(time.charAt(0));\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098377,
                "title": "solve-with-the-least-amount-of-if-statement-23ms-beats-99-6-runtime",
                "content": "# Intuition\\nTo make the code less cumbersome\\n\\n# Approach\\nTake advantage of the bool value in math formula, where True == 1 and False == 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n), n==5\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n        for i in range(len(time)):\\n            if time[i] == \\'?\\':\\n                if not i:\\n                    time[i] = 1 + (time[1] == \\'?\\' or time[1] < \\'4\\')\\n                else:\\n                    time[i] = 3 + 6*(time[0] < \\'2\\') if i == 1 else i*2 + (-1)**i\\n                time[i] = str(time[i])\\n\\n        return \\'\\'.join(time)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n        for i in range(len(time)):\\n            if time[i] == \\'?\\':\\n                if not i:\\n                    time[i] = 1 + (time[1] == \\'?\\' or time[1] < \\'4\\')\\n                else:\\n                    time[i] = 3 + 6*(time[0] < \\'2\\') if i == 1 else i*2 + (-1)**i\\n                time[i] = str(time[i])\\n\\n        return \\'\\'.join(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087788,
                "title": "my-soultion-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used to make validation for every single digit \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n        char h1 = time[0]; \\n        char h2 = time[1]; \\n        char m1 = time[3];\\n        char m2 = time[4]; \\n        string newTime = \"\"; \\n        if(h1 == \\'?\\' && h2 != \\'?\\' && (int)h2 < 52){ \\n            newTime += \\'2\\';\\n        }else if (h1 == \\'?\\' && h2 != \\'?\\' && (int)h2 >= 52){\\n            newTime += \\'1\\';\\n        }else if (h1 == \\'?\\' && h2 == \\'?\\'){\\n            newTime += 2;\\n        }\\n        else{ \\n            newTime += h1;\\n        }\\n      \\n        if(h2 == \\'?\\' && (h1 == \\'?\\' || (int)h1 > 49 ) ){ \\n            newTime += \\'3\\';\\n        }\\n        else if(h2 == \\'?\\'){ \\n            newTime += \\'9\\';\\n        }else{ \\n            newTime += h2;\\n        }\\n        newTime += \\':\\';\\n\\n        if(m1 == \\'?\\'){ \\n            newTime += \\'5\\';\\n        }else{\\n            newTime += m1; \\n        }\\n        if(m2 == \\'?\\'){ \\n            newTime += \\'9\\';\\n        }else{ \\n            newTime += m2;\\n        }\\n        return newTime ; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n        char h1 = time[0]; \\n        char h2 = time[1]; \\n        char m1 = time[3];\\n        char m2 = time[4]; \\n        string newTime = \"\"; \\n        if(h1 == \\'?\\' && h2 != \\'?\\' && (int)h2 < 52){ \\n            newTime += \\'2\\';\\n        }else if (h1 == \\'?\\' && h2 != \\'?\\' && (int)h2 >= 52){\\n            newTime += \\'1\\';\\n        }else if (h1 == \\'?\\' && h2 == \\'?\\'){\\n            newTime += 2;\\n        }\\n        else{ \\n            newTime += h1;\\n        }\\n      \\n        if(h2 == \\'?\\' && (h1 == \\'?\\' || (int)h1 > 49 ) ){ \\n            newTime += \\'3\\';\\n        }\\n        else if(h2 == \\'?\\'){ \\n            newTime += \\'9\\';\\n        }else{ \\n            newTime += h2;\\n        }\\n        newTime += \\':\\';\\n\\n        if(m1 == \\'?\\'){ \\n            newTime += \\'5\\';\\n        }else{\\n            newTime += m1; \\n        }\\n        if(m2 == \\'?\\'){ \\n            newTime += \\'9\\';\\n        }else{ \\n            newTime += m2;\\n        }\\n        return newTime ; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065443,
                "title": "jebas-raja-veryeasy",
                "content": "# Intuition::KARUNYA UNIVERSITY::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) \\n    {\\n        String finalanswer=\"\";\\n//int hours=1;\\n\\n//hours\\n//??\\n if (time.charAt(0)==\\'?\\' && time.charAt(1)==\\'?\\') \\n { \\n    finalanswer=\"23\"; \\n }\\n\\n //?n\\n else if(time.charAt(0)==\\'?\\')\\n {  \\n    if (time.charAt(1)<=\\'3\\') \\n    {\\n    finalanswer=\"2\"+time.charAt(1);  \\n    }\\n    else\\n    {  \\n        finalanswer=\"1\"+time.charAt(1);\\n    }\\n }\\n\\n //n?\\n else if(time.charAt(1)==\\'?\\')\\n {  \\n    if (time.charAt(0)==\\'2\\') \\n    {\\n      finalanswer=time.charAt(0)+\"3\";  \\n    }\\n    else \\n    {\\n    finalanswer=time.charAt(0)+\"9\";  \\n    }\\n }\\n else\\n {\\n    finalanswer+=time.substring(0, 2);\\n }\\n\\n\\n //System.out.println(\"hours--\"+finalanswer);\\n\\n \\n //minutes\\n //??\\n if (time.charAt(3)==\\'?\\' && time.charAt(4)==\\'?\\') \\n {\\n  finalanswer+=\":59\";\\n }\\n\\n //?n\\nelse if (time.charAt(3)==\\'?\\') \\n{\\n  finalanswer+=\":5\"+time.charAt(4);   \\n}\\n\\n//n?\\n else if (time.charAt(4)==\\'?\\') \\n{\\n    finalanswer+=\":\"+time.charAt(3)+\"9\";\\n}\\nelse\\n{\\n    finalanswer+=time.substring(2,time.length());\\n}\\n\\n//System.out.println(finalanswer);\\n\\nreturn finalanswer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) \\n    {\\n        String finalanswer=\"\";\\n//int hours=1;\\n\\n//hours\\n//??\\n if (time.charAt(0)==\\'?\\' && time.charAt(1)==\\'?\\') \\n { \\n    finalanswer=\"23\"; \\n }\\n\\n //?n\\n else if(time.charAt(0)==\\'?\\')\\n {  \\n    if (time.charAt(1)<=\\'3\\') \\n    {\\n    finalanswer=\"2\"+time.charAt(1);  \\n    }\\n    else\\n    {  \\n        finalanswer=\"1\"+time.charAt(1);\\n    }\\n }\\n\\n //n?\\n else if(time.charAt(1)==\\'?\\')\\n {  \\n    if (time.charAt(0)==\\'2\\') \\n    {\\n      finalanswer=time.charAt(0)+\"3\";  \\n    }\\n    else \\n    {\\n    finalanswer=time.charAt(0)+\"9\";  \\n    }\\n }\\n else\\n {\\n    finalanswer+=time.substring(0, 2);\\n }\\n\\n\\n //System.out.println(\"hours--\"+finalanswer);\\n\\n \\n //minutes\\n //??\\n if (time.charAt(3)==\\'?\\' && time.charAt(4)==\\'?\\') \\n {\\n  finalanswer+=\":59\";\\n }\\n\\n //?n\\nelse if (time.charAt(3)==\\'?\\') \\n{\\n  finalanswer+=\":5\"+time.charAt(4);   \\n}\\n\\n//n?\\n else if (time.charAt(4)==\\'?\\') \\n{\\n    finalanswer+=\":\"+time.charAt(3)+\"9\";\\n}\\nelse\\n{\\n    finalanswer+=time.substring(2,time.length());\\n}\\n\\n//System.out.println(finalanswer);\\n\\nreturn finalanswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051557,
                "title": "easiest-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] ch = time.toCharArray();\\n        if(ch[0] == \\'?\\') ch[0] = (ch[1] > \\'3\\' && ch[1] <= \\'9\\')? \\'1\\': \\'2\\';\\n        if(ch[1] == \\'?\\') ch[1] = (ch[0] == \\'2\\')?\\'3\\':\\'9\\';\\n        if(ch[3] == \\'?\\') ch[3] = \\'5\\';\\n        if(ch[4] == \\'?\\') ch[4] = \\'9\\';\\n\\n        return new String(ch);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] ch = time.toCharArray();\\n        if(ch[0] == \\'?\\') ch[0] = (ch[1] > \\'3\\' && ch[1] <= \\'9\\')? \\'1\\': \\'2\\';\\n        if(ch[1] == \\'?\\') ch[1] = (ch[0] == \\'2\\')?\\'3\\':\\'9\\';\\n        if(ch[3] == \\'?\\') ch[3] = \\'5\\';\\n        if(ch[4] == \\'?\\') ch[4] = \\'9\\';\\n\\n        return new String(ch);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045135,
                "title": "only-one-line-runtime-97",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-09-14 \\u0432 21.00.44.png](https://assets.leetcode.com/users/images/73c25195-deb5-471d-b816-27fc08bcdba9_1694714561.7307875.png)\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        return f\"{({\\'0?\\':\\'09\\', \\'1?\\':\\'19\\', \\'2?\\':\\'23\\', \\'?0\\':\\'20\\', \\'?1\\':\\'21\\', \\'?2\\':\\'22\\', \\'?3\\':\\'23\\', \\'?4\\':\\'14\\', \\'?5\\':\\'15\\', \\'?6\\':\\'16\\', \\'?7\\':\\'17\\', \\'?8\\':\\'18\\', \\'?9\\':\\'19\\', \\'??\\': \\'23\\'}.get(time[:2], time[:2]))}:{5 if time[3] == \\'?\\' else time[3]}{9 if time[4] == \\'?\\' else time[4]}\"      \\n```\\n> More readable\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        dic_h = {\\'0?\\':\\'09\\', \\'1?\\':\\'19\\', \\'2?\\':\\'23\\', \\'?0\\':\\'20\\', \\'?1\\':\\'21\\', \\'?2\\':\\'22\\', \\'?3\\':\\'23\\', \\'?4\\':\\'14\\', \\'?5\\':\\'15\\', \\'?6\\':\\'16\\', \\'?7\\':\\'17\\', \\'?8\\':\\'18\\', \\'?9\\':\\'19\\', \\'??\\': \\'23\\'}\\n        return f\"{dic_h.get(time[:2], time[:2])}:{5 if time[3] == \\'?\\' else time[3]}{9 if time[4] == \\'?\\' else time[4]}\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        return f\"{({\\'0?\\':\\'09\\', \\'1?\\':\\'19\\', \\'2?\\':\\'23\\', \\'?0\\':\\'20\\', \\'?1\\':\\'21\\', \\'?2\\':\\'22\\', \\'?3\\':\\'23\\', \\'?4\\':\\'14\\', \\'?5\\':\\'15\\', \\'?6\\':\\'16\\', \\'?7\\':\\'17\\', \\'?8\\':\\'18\\', \\'?9\\':\\'19\\', \\'??\\': \\'23\\'}.get(time[:2], time[:2]))}:{5 if time[3] == \\'?\\' else time[3]}{9 if time[4] == \\'?\\' else time[4]}\"      \\n```\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        dic_h = {\\'0?\\':\\'09\\', \\'1?\\':\\'19\\', \\'2?\\':\\'23\\', \\'?0\\':\\'20\\', \\'?1\\':\\'21\\', \\'?2\\':\\'22\\', \\'?3\\':\\'23\\', \\'?4\\':\\'14\\', \\'?5\\':\\'15\\', \\'?6\\':\\'16\\', \\'?7\\':\\'17\\', \\'?8\\':\\'18\\', \\'?9\\':\\'19\\', \\'??\\': \\'23\\'}\\n        return f\"{dic_h.get(time[:2], time[:2])}:{5 if time[3] == \\'?\\' else time[3]}{9 if time[4] == \\'?\\' else time[4]}\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037017,
                "title": "c-kotlin-easy-to-understand-solution-beats-runtime-94-80-memory-72-80",
                "content": "# C#\\n![image.png](https://assets.leetcode.com/users/images/4bd9f645-2f77-48ba-821b-4e21ff982744_1694545028.2506907.png)\\n\\n\\n# Kotlin\\n![image.png](https://assets.leetcode.com/users/images/bcfdf8f6-e1c4-4182-9f7b-d5ead57ecdd7_1694545023.4543974.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```C# []\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n      StringBuilder timeBuilder = new StringBuilder(time);\\n\\n    // Determine the maximum possible hour\\n    if (timeBuilder[0] == \\'?\\') {\\n        timeBuilder[0] = (timeBuilder[1] <= \\'3\\' || timeBuilder[1] == \\'?\\') ? \\'2\\' : \\'1\\';\\n    }\\n\\n    if (timeBuilder[1] == \\'?\\') {\\n        timeBuilder[1] = (timeBuilder[0] == \\'2\\') ? \\'3\\' : \\'9\\';\\n    }\\n\\n    // Determine the maximum possible minute\\n    timeBuilder[3] = (timeBuilder[3] == \\'?\\') ? \\'5\\' : timeBuilder[3];\\n    timeBuilder[4] = (timeBuilder[4] == \\'?\\') ? \\'9\\' : timeBuilder[4];\\n\\n    return timeBuilder.ToString();\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n    fun maximumTime(time: String): String {\\n        var stringBuilder = StringBuilder(time)\\n        if (stringBuilder[0] == \\'?\\') {\\n            stringBuilder[0] = if (stringBuilder[1] <= \\'3\\' || stringBuilder[1] == \\'?\\') \\'2\\' else \\'1\\'\\n        }\\n\\n        if (stringBuilder[1] == \\'?\\') {\\n            stringBuilder[1] = if (stringBuilder[0] == \\'2\\') \\'3\\' else \\'9\\'\\n        }\\n\\n        stringBuilder[3] = if (stringBuilder[3] === \\'?\\') \\'5\\' else stringBuilder[3]\\n        stringBuilder[4] = if (stringBuilder[4] === \\'?\\') \\'9\\' else stringBuilder[4]\\n        return  stringBuilder.toString()\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#",
                    "Kotlin",
                    "String",
                    "Greedy"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n      StringBuilder timeBuilder = new StringBuilder(time);\\n\\n    // Determine the maximum possible hour\\n    if (timeBuilder[0] == \\'?\\') {\\n        timeBuilder[0] = (timeBuilder[1] <= \\'3\\' || timeBuilder[1] == \\'?\\') ? \\'2\\' : \\'1\\';\\n    }\\n\\n    if (timeBuilder[1] == \\'?\\') {\\n        timeBuilder[1] = (timeBuilder[0] == \\'2\\') ? \\'3\\' : \\'9\\';\\n    }\\n\\n    // Determine the maximum possible minute\\n    timeBuilder[3] = (timeBuilder[3] == \\'?\\') ? \\'5\\' : timeBuilder[3];\\n    timeBuilder[4] = (timeBuilder[4] == \\'?\\') ? \\'9\\' : timeBuilder[4];\\n\\n    return timeBuilder.ToString();\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n    fun maximumTime(time: String): String {\\n        var stringBuilder = StringBuilder(time)\\n        if (stringBuilder[0] == \\'?\\') {\\n            stringBuilder[0] = if (stringBuilder[1] <= \\'3\\' || stringBuilder[1] == \\'?\\') \\'2\\' else \\'1\\'\\n        }\\n\\n        if (stringBuilder[1] == \\'?\\') {\\n            stringBuilder[1] = if (stringBuilder[0] == \\'2\\') \\'3\\' else \\'9\\'\\n        }\\n\\n        stringBuilder[3] = if (stringBuilder[3] === \\'?\\') \\'5\\' else stringBuilder[3]\\n        stringBuilder[4] = if (stringBuilder[4] === \\'?\\') \\'9\\' else stringBuilder[4]\\n        return  stringBuilder.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005430,
                "title": "beginner-friendly-solution-for-java-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String min=time.substring(3);\\n        String hrs=time.substring(0,2);\\n        String hr1=checkHr(hrs);\\n        String min1=checkMin(min);\\n        return hr1+\":\"+min1;\\n    }\\n    String checkMin(String min){\\n        \\n        if(min.charAt(0)==\\'?\\'){\\n            if(min.charAt(1)==\\'?\\'){\\n                return \"59\";\\n            }\\n            if(min.charAt(1)==\\'0\\'){\\n                return \"50\";\\n            }\\n            else{\\n                return \"5\"+min.charAt(1);\\n            }\\n        }\\n        if(min.charAt(1)==\\'?\\'){\\n            return min.charAt(0)+\"9\";\\n        }\\n        return min;\\n    }\\n    String checkHr(String hr){\\n        if(hr.charAt(0)==\\'?\\'){\\n            if(hr.charAt(1)==\\'?\\'){\\n                return \"23\";\\n            }\\n            if(hr.charAt(1)>\\'3\\'){\\n                return \"1\"+hr.charAt(1);\\n            }\\n            else{\\n                return \"2\"+hr.charAt(1);\\n            }\\n        }\\n        if(hr.charAt(1)==\\'?\\'){\\n            if(hr.charAt(0)<\\'2\\'){\\n                return hr.charAt(0)+\"9\";\\n            }\\n            else{\\n                return hr.charAt(0)+\"3\";\\n            }\\n        }\\n        return hr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String min=time.substring(3);\\n        String hrs=time.substring(0,2);\\n        String hr1=checkHr(hrs);\\n        String min1=checkMin(min);\\n        return hr1+\":\"+min1;\\n    }\\n    String checkMin(String min){\\n        \\n        if(min.charAt(0)==\\'?\\'){\\n            if(min.charAt(1)==\\'?\\'){\\n                return \"59\";\\n            }\\n            if(min.charAt(1)==\\'0\\'){\\n                return \"50\";\\n            }\\n            else{\\n                return \"5\"+min.charAt(1);\\n            }\\n        }\\n        if(min.charAt(1)==\\'?\\'){\\n            return min.charAt(0)+\"9\";\\n        }\\n        return min;\\n    }\\n    String checkHr(String hr){\\n        if(hr.charAt(0)==\\'?\\'){\\n            if(hr.charAt(1)==\\'?\\'){\\n                return \"23\";\\n            }\\n            if(hr.charAt(1)>\\'3\\'){\\n                return \"1\"+hr.charAt(1);\\n            }\\n            else{\\n                return \"2\"+hr.charAt(1);\\n            }\\n        }\\n        if(hr.charAt(1)==\\'?\\'){\\n            if(hr.charAt(0)<\\'2\\'){\\n                return hr.charAt(0)+\"9\";\\n            }\\n            else{\\n                return hr.charAt(0)+\"3\";\\n            }\\n        }\\n        return hr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000653,
                "title": "simple-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        a=[]\\n        b=[]\\n        s=\\'\\'\\n        p=\\'\\'\\n        a.append(time[0])\\n        a.append(time[1])\\n        b.append(time[3])\\n        b.append(time[4])\\n        if a[0]==\"?\" and a[1]!=\\'?\\':\\n            if int(a[1]) in range(0,4):\\n                a[0]=\\'2\\'\\n            elif int(a[1]) in range(4,10):\\n                a[0]=\\'1\\'\\n        if a[1]==\\'?\\' and a[0]==\\'?\\':\\n            a[0]=\\'2\\'\\n            a[1]=\\'3\\'\\n        if a[1]==\\'?\\':\\n                if a[0]==\\'2\\':\\n                    a[1]=\\'3\\'\\n                elif a[0]==\\'1\\' or a[0]==\\'0\\':\\n                    a[1]=\\'9\\'\\n        if b[0]==\\'?\\':\\n            b[0]=\\'5\\'\\n        if b[1]==\\'?\\':\\n            b[1]=\\'9\\'\\n        for i in a:\\n            s=s+i\\n        for i in b:\\n            p=p+i\\n        return s+\\':\\'+p\\n        \\n                \\n        \\n        \\n                \\n           \\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        a=[]\\n        b=[]\\n        s=\\'\\'\\n        p=\\'\\'\\n        a.append(time[0])\\n        a.append(time[1])\\n        b.append(time[3])\\n        b.append(time[4])\\n        if a[0]==\"?\" and a[1]!=\\'?\\':\\n            if int(a[1]) in range(0,4):\\n                a[0]=\\'2\\'\\n            elif int(a[1]) in range(4,10):\\n                a[0]=\\'1\\'\\n        if a[1]==\\'?\\' and a[0]==\\'?\\':\\n            a[0]=\\'2\\'\\n            a[1]=\\'3\\'\\n        if a[1]==\\'?\\':\\n                if a[0]==\\'2\\':\\n                    a[1]=\\'3\\'\\n                elif a[0]==\\'1\\' or a[0]==\\'0\\':\\n                    a[1]=\\'9\\'\\n        if b[0]==\\'?\\':\\n            b[0]=\\'5\\'\\n        if b[1]==\\'?\\':\\n            b[1]=\\'9\\'\\n        for i in a:\\n            s=s+i\\n        for i in b:\\n            p=p+i\\n        return s+\\':\\'+p\\n        \\n                \\n        \\n        \\n                \\n           \\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972215,
                "title": "beats-100-00-runtime-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if (time[0] == \\'0\\' || time[0] == \\'1\\') {\\n            if (time[1] == \\'?\\') time[1] = \\'9\\';\\n        }\\n        else if (time[0] == \\'2\\') {\\n            if (time[1] == \\'?\\') time[1] = \\'3\\';\\n        }\\n        else {\\n            if (time[1] == \\'?\\') {\\n                time[0] = \\'2\\';\\n                time[1] = \\'3\\';\\n            }\\n            else if (time[1] > \\'3\\') time[0] = \\'1\\';\\n            else time[0] = \\'2\\';\\n        }\\n\\n        if (time[3] == \\'?\\') {\\n            if (time[4] == \\'?\\') {\\n                time[3] = \\'5\\';\\n                time[4] = \\'9\\';\\n            }\\n            else time[3] = \\'5\\';\\n        }\\n        else if (time[4] == \\'?\\') time[4] = \\'9\\';\\n\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if (time[0] == \\'0\\' || time[0] == \\'1\\') {\\n            if (time[1] == \\'?\\') time[1] = \\'9\\';\\n        }\\n        else if (time[0] == \\'2\\') {\\n            if (time[1] == \\'?\\') time[1] = \\'3\\';\\n        }\\n        else {\\n            if (time[1] == \\'?\\') {\\n                time[0] = \\'2\\';\\n                time[1] = \\'3\\';\\n            }\\n            else if (time[1] > \\'3\\') time[0] = \\'1\\';\\n            else time[0] = \\'2\\';\\n        }\\n\\n        if (time[3] == \\'?\\') {\\n            if (time[4] == \\'?\\') {\\n                time[3] = \\'5\\';\\n                time[4] = \\'9\\';\\n            }\\n            else time[3] = \\'5\\';\\n        }\\n        else if (time[4] == \\'?\\') time[4] = \\'9\\';\\n\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948801,
                "title": "python-simple-and-faster-100-6ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n        res = \\'\\'\\n        for i in range(len(time)):\\n            if time[i] != \\'?\\': \\n                res += time[i]\\n                continue\\n            if i == 0:\\n                if time[1] != \\'?\\' and time[1] > \\'3\\': res += \\'1\\' \\n                else: res += \\'2\\'\\n            elif i == 1:\\n                if res[0] == \\'2\\': res += \\'3\\'\\n                else: res += \\'9\\'\\n            elif i == 3: res += \\'5\\'\\n            else: res += \\'9\\'\\n        return res\\n            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n        res = \\'\\'\\n        for i in range(len(time)):\\n            if time[i] != \\'?\\': \\n                res += time[i]\\n                continue\\n            if i == 0:\\n                if time[1] != \\'?\\' and time[1] > \\'3\\': res += \\'1\\' \\n                else: res += \\'2\\'\\n            elif i == 1:\\n                if res[0] == \\'2\\': res += \\'3\\'\\n                else: res += \\'9\\'\\n            elif i == 3: res += \\'5\\'\\n            else: res += \\'9\\'\\n        return res\\n            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921942,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] chars = time.toCharArray();\\n\\n        if(chars[0] == \\'?\\') chars[0] = (chars[1] != \\'?\\' && chars[1] > \\'3\\') ? \\'1\\' :\\'2\\';\\n        if(chars[1] == \\'?\\') chars[1] = (chars[0] ==\\'2\\') ? \\'3\\' : \\'9\\';\\n\\n        if(chars[3] == \\'?\\') chars[3] = \\'5\\';\\n        if(chars[4] == \\'?\\') chars[4] = \\'9\\';\\n\\n        return new String(chars);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] chars = time.toCharArray();\\n\\n        if(chars[0] == \\'?\\') chars[0] = (chars[1] != \\'?\\' && chars[1] > \\'3\\') ? \\'1\\' :\\'2\\';\\n        if(chars[1] == \\'?\\') chars[1] = (chars[0] ==\\'2\\') ? \\'3\\' : \\'9\\';\\n\\n        if(chars[3] == \\'?\\') chars[3] = \\'5\\';\\n        if(chars[4] == \\'?\\') chars[4] = \\'9\\';\\n\\n        return new String(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886845,
                "title": "java-solution",
                "content": "# Intuition\\n// split string in hh and mm\\n        // check which digit is missing\\n        // if the first digit of the hh is missing, replace it with 2\\n        // if the second digit of the first hh is missing, replace is with 3\\n        // if the first digit of the mm is missing replace is with 5\\n        // if the second digit of the mm is missing replace is with 9\\n        // put them together in a new string and return\\n\\n# Approach\\n// split string in hh and mm\\n        // check which digit is missing\\n        // if the first digit of the hh is missing, replace it with 2\\n        // if the second digit of the first hh is missing, replace is with 3\\n        // if the first digit of the mm is missing replace is with 5\\n        // if the second digit of the mm is missing replace is with 9\\n        // put them together in a new string and return\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        // split string in hh and mm\\n        // check which digit is missing\\n        // if the first digit of the hh is missing, replace it with 2\\n        // if the second digit of the first hh is missing, replace is with 3\\n        // if the first digit of the mm is missing replace is with 5\\n        // if the second digit of the mm is missing replace is with 9\\n        // put them together in a new string and return\\n\\n        String[] timeArray = time.split(\":\");\\n        String hours = \"\";\\n        String minutes = \"\";\\n\\n        // work on hours\\n        for(int i = 0; i < 2; i++) {\\n            String hours1 = \"\";\\n            String hours2 = \"\";  \\n\\n            // two digits of hours\\n            // first digit\\n            if(i == 0) {\\n                if(timeArray[0].charAt(i) == \\'?\\') {\\n                    if(Character.getNumericValue(timeArray[0].charAt(1)) > 3) hours1 = \"1\";\\n                    else hours1 = \"2\";\\n                }\\n                else if(timeArray[0].charAt(i) != \\'?\\'){\\n                    hours1 += timeArray[0].charAt(i);\\n                }\\n                hours += hours1;\\n            }\\n            // second digit\\n            if(i == 1){\\n                if(timeArray[0].charAt(i) == \\'?\\') {\\n                    if(hours.charAt(0) == \\'0\\' || hours.charAt(0) == \\'1\\') hours2 = \"9\";\\n                    else if(hours.charAt(0) == \\'2\\') hours2 = \"3\";\\n                    \\n                }\\n                else if(timeArray[0].charAt(i) != \\'?\\'){\\n                    hours2 += timeArray[0].charAt(i);\\n                }\\n                hours += hours2;\\n            }\\n        }\\n\\n        hours += \":\";\\n\\n         // work on minutes\\n        for(int j = 0; j < 2; j++) {\\n            String minutes1 = \"\";\\n            String minutes2 = \"\"; \\n\\n            // two digits of hours\\n            // first digit\\n            if(j == 0) {\\n                if(timeArray[1].charAt(j) == \\'?\\') {\\n                minutes1 = \"5\";\\n                }\\n                else if(timeArray[1].charAt(j) != \\'?\\'){\\n                minutes1 += timeArray[1].charAt(j);\\n                }\\n                minutes += minutes1;\\n            }\\n            // second digit\\n            if(j == 1){\\n                if(timeArray[1].charAt(j) == \\'?\\') {\\n                    minutes2 = \"9\";\\n                }\\n                else if(timeArray[1].charAt(j) != \\'?\\'){\\n                    minutes2 += timeArray[1].charAt(j);\\n                }\\n                minutes += minutes2;\\n            }\\n        }\\n        String finalString = hours + minutes;\\n        return finalString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        // split string in hh and mm\\n        // check which digit is missing\\n        // if the first digit of the hh is missing, replace it with 2\\n        // if the second digit of the first hh is missing, replace is with 3\\n        // if the first digit of the mm is missing replace is with 5\\n        // if the second digit of the mm is missing replace is with 9\\n        // put them together in a new string and return\\n\\n        String[] timeArray = time.split(\":\");\\n        String hours = \"\";\\n        String minutes = \"\";\\n\\n        // work on hours\\n        for(int i = 0; i < 2; i++) {\\n            String hours1 = \"\";\\n            String hours2 = \"\";  \\n\\n            // two digits of hours\\n            // first digit\\n            if(i == 0) {\\n                if(timeArray[0].charAt(i) == \\'?\\') {\\n                    if(Character.getNumericValue(timeArray[0].charAt(1)) > 3) hours1 = \"1\";\\n                    else hours1 = \"2\";\\n                }\\n                else if(timeArray[0].charAt(i) != \\'?\\'){\\n                    hours1 += timeArray[0].charAt(i);\\n                }\\n                hours += hours1;\\n            }\\n            // second digit\\n            if(i == 1){\\n                if(timeArray[0].charAt(i) == \\'?\\') {\\n                    if(hours.charAt(0) == \\'0\\' || hours.charAt(0) == \\'1\\') hours2 = \"9\";\\n                    else if(hours.charAt(0) == \\'2\\') hours2 = \"3\";\\n                    \\n                }\\n                else if(timeArray[0].charAt(i) != \\'?\\'){\\n                    hours2 += timeArray[0].charAt(i);\\n                }\\n                hours += hours2;\\n            }\\n        }\\n\\n        hours += \":\";\\n\\n         // work on minutes\\n        for(int j = 0; j < 2; j++) {\\n            String minutes1 = \"\";\\n            String minutes2 = \"\"; \\n\\n            // two digits of hours\\n            // first digit\\n            if(j == 0) {\\n                if(timeArray[1].charAt(j) == \\'?\\') {\\n                minutes1 = \"5\";\\n                }\\n                else if(timeArray[1].charAt(j) != \\'?\\'){\\n                minutes1 += timeArray[1].charAt(j);\\n                }\\n                minutes += minutes1;\\n            }\\n            // second digit\\n            if(j == 1){\\n                if(timeArray[1].charAt(j) == \\'?\\') {\\n                    minutes2 = \"9\";\\n                }\\n                else if(timeArray[1].charAt(j) != \\'?\\'){\\n                    minutes2 += timeArray[1].charAt(j);\\n                }\\n                minutes += minutes2;\\n            }\\n        }\\n        String finalString = hours + minutes;\\n        return finalString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885273,
                "title": "python-boring-solution-if-else",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def maximumTime(self, time: str) -> str:\\n    time = list(time)\\n    for i in range(len(time)):\\n      if time[i] == \\'?\\':\\n        if i == 0:\\n          time[i] = \\'2\\' if time[i + 1] in \\'?0123\\' else \\'1\\'\\n        elif i == 1:\\n          time[i] = \\'3\\' if time[0] == \\'2\\' else \\'9\\'\\n        elif i == 3:\\n          time[i] = \\'5\\'\\n        else:\\n          time[i] = \\'9\\'\\n    return \\'\\'.join(time)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def maximumTime(self, time: str) -> str:\\n    time = list(time)\\n    for i in range(len(time)):\\n      if time[i] == \\'?\\':\\n        if i == 0:\\n          time[i] = \\'2\\' if time[i + 1] in \\'?0123\\' else \\'1\\'\\n        elif i == 1:\\n          time[i] = \\'3\\' if time[0] == \\'2\\' else \\'9\\'\\n        elif i == 3:\\n          time[i] = \\'5\\'\\n        else:\\n          time[i] = \\'9\\'\\n    return \\'\\'.join(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867109,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/0525bf53-9021-4b5c-979e-da4e027bfed9_1691237486.8396401.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        string ans = time;\\n        if(ans[0] == \\'?\\'){\\n            if(ans[1] != \\'?\\' && ans[1] > \\'3\\')\\n                ans[0] = \\'1\\';\\n            else ans[0] = \\'2\\';\\n        }\\n        if(ans[1] == \\'?\\'){\\n            if(ans[0] != \\'?\\' && ans[0] < \\'2\\')\\n                ans[1] = \\'9\\';\\n            else ans[1] = \\'3\\';\\n        }\\n        if(ans[3] == \\'?\\')\\n            ans[3] = \\'5\\';\\n        if(ans[4] == \\'?\\')\\n            ans[4] = \\'9\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        string ans = time;\\n        if(ans[0] == \\'?\\'){\\n            if(ans[1] != \\'?\\' && ans[1] > \\'3\\')\\n                ans[0] = \\'1\\';\\n            else ans[0] = \\'2\\';\\n        }\\n        if(ans[1] == \\'?\\'){\\n            if(ans[0] != \\'?\\' && ans[0] < \\'2\\')\\n                ans[1] = \\'9\\';\\n            else ans[1] = \\'3\\';\\n        }\\n        if(ans[3] == \\'?\\')\\n            ans[3] = \\'5\\';\\n        if(ans[4] == \\'?\\')\\n            ans[4] = \\'9\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841871,
                "title": "python-code-for-reference",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        ans=\\'\\'\\n        for i in range(len(time)):\\n            if time[i]!=\\'?\\':\\n                ans=ans+time[i]\\n            else:\\n                if i==0:\\n                    if time[i+1]==\\'?\\':\\n                        ans=ans+\\'2\\'\\n                    else:\\n                        if time[i+1] not in [\\'0\\',\\'1\\',\\'2\\',\\'3\\']:\\n                            ans=ans+\\'1\\'\\n                        else:\\n                            ans=ans+\\'2\\'\\n                elif i==1:\\n                    if time[i-1]==\\'?\\':\\n                        ans=ans+\\'3\\'\\n                    else:\\n                        if time[i-1] in [\\'0\\',\\'1\\']:\\n                            ans=ans+\\'9\\'\\n                        else:\\n                            ans=ans+\\'3\\'\\n                elif i==3:\\n                    ans=ans+\\'5\\'\\n                elif i==4:\\n                    ans=ans+\\'9\\'\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        ans=\\'\\'\\n        for i in range(len(time)):\\n            if time[i]!=\\'?\\':\\n                ans=ans+time[i]\\n            else:\\n                if i==0:\\n                    if time[i+1]==\\'?\\':\\n                        ans=ans+\\'2\\'\\n                    else:\\n                        if time[i+1] not in [\\'0\\',\\'1\\',\\'2\\',\\'3\\']:\\n                            ans=ans+\\'1\\'\\n                        else:\\n                            ans=ans+\\'2\\'\\n                elif i==1:\\n                    if time[i-1]==\\'?\\':\\n                        ans=ans+\\'3\\'\\n                    else:\\n                        if time[i-1] in [\\'0\\',\\'1\\']:\\n                            ans=ans+\\'9\\'\\n                        else:\\n                            ans=ans+\\'3\\'\\n                elif i==3:\\n                    ans=ans+\\'5\\'\\n                elif i==4:\\n                    ans=ans+\\'9\\'\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829781,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        string ans = \"\";\\n\\n        stringstream s(time);\\n        string str;\\n        getline(s , str , \\':\\');\\n         \\n        if (str[0] == \\'?\\' && (str[1]-\\'0\\' < 4 || str[1] == \\'?\\'))\\n            ans += \\'2\\';      \\n        else if (str[0] == \\'?\\')\\n            ans += \\'1\\';\\n        else\\n            ans += str[0];\\n\\n        if (str[1] == \\'?\\' && ans[0] == \\'2\\')\\n            ans += \\'3\\';\\n        else if (str[1] == \\'?\\')\\n            ans += \\'9\\';\\n        else\\n            ans += str[1];\\n\\n        ans += \\':\\';\\n        getline(s , str , \\'\\\\0\\');\\n        if (str[0] == \\'?\\')\\n            ans += \\'5\\';\\n        else\\n            ans += str[0];\\n        \\n        if (str[1] == \\'?\\')\\n            ans += \\'9\\';\\n        else\\n            ans += str[1];\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        string ans = \"\";\\n\\n        stringstream s(time);\\n        string str;\\n        getline(s , str , \\':\\');\\n         \\n        if (str[0] == \\'?\\' && (str[1]-\\'0\\' < 4 || str[1] == \\'?\\'))\\n            ans += \\'2\\';      \\n        else if (str[0] == \\'?\\')\\n            ans += \\'1\\';\\n        else\\n            ans += str[0];\\n\\n        if (str[1] == \\'?\\' && ans[0] == \\'2\\')\\n            ans += \\'3\\';\\n        else if (str[1] == \\'?\\')\\n            ans += \\'9\\';\\n        else\\n            ans += str[1];\\n\\n        ans += \\':\\';\\n        getline(s , str , \\'\\\\0\\');\\n        if (str[0] == \\'?\\')\\n            ans += \\'5\\';\\n        else\\n            ans += str[0];\\n        \\n        if (str[1] == \\'?\\')\\n            ans += \\'9\\';\\n        else\\n            ans += str[1];\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823208,
                "title": "simple-java-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] ct = time.toCharArray();\\n        char[] missing = new char[5];\\n        missing[0] = ct[1]>\\'3\\' && ct[1]!=\\'?\\' ? \\'1\\' : \\'2\\';\\n        missing[1] = ct[0]==\\'?\\' || ct[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n        missing[3] = \\'5\\';\\n        missing[4] = \\'9\\';\\n        \\n        for(int i=0; i<ct.length; i++) {\\n            if(ct[i]==\\'?\\') {\\n                ct[i] = missing[i];\\n            }\\n        }\\n        \\n        return new String(ct);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] ct = time.toCharArray();\\n        char[] missing = new char[5];\\n        missing[0] = ct[1]>\\'3\\' && ct[1]!=\\'?\\' ? \\'1\\' : \\'2\\';\\n        missing[1] = ct[0]==\\'?\\' || ct[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n        missing[3] = \\'5\\';\\n        missing[4] = \\'9\\';\\n        \\n        for(int i=0; i<ct.length; i++) {\\n            if(ct[i]==\\'?\\') {\\n                ct[i] = missing[i];\\n            }\\n        }\\n        \\n        return new String(ct);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808133,
                "title": "must-watch-this-once-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string t){\\n        if(t[4]==\\'?\\'){\\n            t[4]=\\'9\\';\\n        }\\n        if(t[3]==\\'?\\'){\\n            t[3]=\\'5\\';\\n        }\\n        if(t[1]==\\'?\\' && t[0]==\\'?\\'){\\n            t[0]=\\'2\\';\\n            t[1]=\\'3\\';\\n        }\\n        else{\\n            if(t[0]==\\'?\\'){\\n                if(t[1]<\\'4\\'){\\n                    t[0]=\\'2\\';\\n                }\\n                else{\\n                    t[0]=\\'1\\';\\n                }\\n            }\\n            else if(t[1]==\\'?\\'){\\n                if(t[0]==\\'2\\'){\\n                    t[1]=\\'3\\';\\n                }\\n                else{\\n                    t[1]=\\'9\\';\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string t){\\n        if(t[4]==\\'?\\'){\\n            t[4]=\\'9\\';\\n        }\\n        if(t[3]==\\'?\\'){\\n            t[3]=\\'5\\';\\n        }\\n        if(t[1]==\\'?\\' && t[0]==\\'?\\'){\\n            t[0]=\\'2\\';\\n            t[1]=\\'3\\';\\n        }\\n        else{\\n            if(t[0]==\\'?\\'){\\n                if(t[1]<\\'4\\'){\\n                    t[0]=\\'2\\';\\n                }\\n                else{\\n                    t[0]=\\'1\\';\\n                }\\n            }\\n            else if(t[1]==\\'?\\'){\\n                if(t[0]==\\'2\\'){\\n                    t[1]=\\'3\\';\\n                }\\n                else{\\n                    t[1]=\\'9\\';\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806778,
                "title": "java-straight-forward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n      char[] times = time.toCharArray();\\n       if(times[0]==\\'?\\'){\\n           times[0]=(times[1]<=\\'3\\' ||times[1]==\\'?\\')?\\'2\\':\\'1\\';\\n       }\\n       if(times[1]==\\'?\\'){\\n            times[1]= times[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n       }\\n        if(times[3]==\\'?\\'){\\n            times[3]=\\'5\\';  \\n       }\\n        if(times[4]==\\'?\\'){\\n         times[4]=\\'9\\';\\n    }\\n\\n          return new String(times);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n      char[] times = time.toCharArray();\\n       if(times[0]==\\'?\\'){\\n           times[0]=(times[1]<=\\'3\\' ||times[1]==\\'?\\')?\\'2\\':\\'1\\';\\n       }\\n       if(times[1]==\\'?\\'){\\n            times[1]= times[0]==\\'2\\' ? \\'3\\' : \\'9\\';\\n       }\\n        if(times[3]==\\'?\\'){\\n            times[3]=\\'5\\';  \\n       }\\n        if(times[4]==\\'?\\'){\\n         times[4]=\\'9\\';\\n    }\\n\\n          return new String(times);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785386,
                "title": "python-pattern-matching",
                "content": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hh, mm = time.split(\\':\\')\\n        return f\"{self.fill_hour(hh)}:{self.fill_minute(mm)}\"\\n\\n    @staticmethod\\n    def fill_hour(hour: str) -> str:\\n        first, second = hour\\n        match (first, second):\\n            case (\\'?\\', \\'?\\'):\\n                return \\'23\\'\\n            case (\\'?\\', digit):\\n                return \\'2\\' + digit if digit <= \\'3\\' else \\'1\\' + digit\\n            case (digit, \\'?\\'):\\n                return digit + \\'3\\' if digit == \\'2\\' else digit + \\'9\\'\\n            case _:\\n                return hour\\n\\n    @staticmethod\\n    def fill_minute(minute: str) -> str:\\n        first, second = minute\\n        match (first, second):\\n            case (\\'?\\', \\'?\\'):\\n                return \\'59\\'\\n            case (\\'?\\', digit):\\n                return \\'5\\' + digit\\n            case (digit, \\'?\\'):\\n                return digit + \\'9\\'\\n            case _:\\n                return minute\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hh, mm = time.split(\\':\\')\\n        return f\"{self.fill_hour(hh)}:{self.fill_minute(mm)}\"\\n\\n    @staticmethod\\n    def fill_hour(hour: str) -> str:\\n        first, second = hour\\n        match (first, second):\\n            case (\\'?\\', \\'?\\'):\\n                return \\'23\\'\\n            case (\\'?\\', digit):\\n                return \\'2\\' + digit if digit <= \\'3\\' else \\'1\\' + digit\\n            case (digit, \\'?\\'):\\n                return digit + \\'3\\' if digit == \\'2\\' else digit + \\'9\\'\\n            case _:\\n                return hour\\n\\n    @staticmethod\\n    def fill_minute(minute: str) -> str:\\n        first, second = minute\\n        match (first, second):\\n            case (\\'?\\', \\'?\\'):\\n                return \\'59\\'\\n            case (\\'?\\', digit):\\n                return \\'5\\' + digit\\n            case (digit, \\'?\\'):\\n                return digit + \\'9\\'\\n            case _:\\n                return minute\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769899,
                "title": "runtime-7ms-memory-19-55mb",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $time\\n     * @return String\\n     */\\n    function maximumTime($time) {\\n        ($time[0] === \\'?\\') && $time[0] = ((int)$time[1] <= 3) ? \\'2\\' : \\'1\\';\\n        ($time[1] === \\'?\\') && $time[1] = ((int)$time[0] === 2) ? \\'3\\' : \\'9\\';\\n        ($time[3] === \\'?\\') && $time[3] = \\'5\\';\\n        ($time[4] === \\'?\\') && $time[4] = \\'9\\';\\n \\n        return $time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $time\\n     * @return String\\n     */\\n    function maximumTime($time) {\\n        ($time[0] === \\'?\\') && $time[0] = ((int)$time[1] <= 3) ? \\'2\\' : \\'1\\';\\n        ($time[1] === \\'?\\') && $time[1] = ((int)$time[0] === 2) ? \\'3\\' : \\'9\\';\\n        ($time[3] === \\'?\\') && $time[3] = \\'5\\';\\n        ($time[4] === \\'?\\') && $time[4] = \\'9\\';\\n \\n        return $time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754007,
                "title": "python-concise-easiest-solution",
                "content": "\\n# Time complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        if time[0] == \"?\": \\n            if time[1] == \"?\" or int(time[1]) < 4:\\n                time = \\'2\\' + time[1 : ]\\n            else:\\n                time = \\'1\\' + time[1 : ]\\n\\n        for i in range(1, len(time)):\\n            if time[i] == \"?\":\\n                part1, part2 = time[ : i], time[i + 1 : ]\\n\\n                if i == 1:\\n                    if time[0] == \"2\":\\n                        time = part1 + \"3\" + part2\\n                    else:\\n                        time = part1 + \\'9\\' + part2\\n                elif i == 3:\\n                    time = part1 + \"5\" + part2\\n                else:\\n                    time = part1 + \"9\" + part2\\n\\n        return time\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        if time[0] == \"?\": \\n            if time[1] == \"?\" or int(time[1]) < 4:\\n                time = \\'2\\' + time[1 : ]\\n            else:\\n                time = \\'1\\' + time[1 : ]\\n\\n        for i in range(1, len(time)):\\n            if time[i] == \"?\":\\n                part1, part2 = time[ : i], time[i + 1 : ]\\n\\n                if i == 1:\\n                    if time[0] == \"2\":\\n                        time = part1 + \"3\" + part2\\n                    else:\\n                        time = part1 + \\'9\\' + part2\\n                elif i == 3:\\n                    time = part1 + \"5\" + part2\\n                else:\\n                    time = part1 + \"9\" + part2\\n\\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752009,
                "title": "0ms-o-1-most-intuitive-solution-works-for-general-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt boils down to a problem:\\n`SetMax` a two digits number with `?` inside to as large as possible but not exceeding a given limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply do `if-else` for general cases and apply that to both hours and minutes.\\n\\n# Complexity\\n- Time complexity:\\n$$\\\\Theta(1)$$\\n\\n- Space complexity:\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\n// Sets the two digits number {a, b} to as close to {a_max, b_max} as possible\\n// by replacing the `?` in a and b.\\nvoid SetMax(char& a, char& b, char a_max, char b_max) {\\n  if (a == \\'?\\') {\\n    if (b == \\'?\\' || b <= b_max) {\\n      a = a_max;\\n    } else {\\n      a = a_max - 1;\\n    }\\n  }\\n  if (b == \\'?\\') {\\n    if (a == a_max) {\\n      b = b_max;\\n    } else {\\n      b = \\'9\\';\\n    }\\n  }\\n}\\n\\nclass Solution {\\npublic:\\n  string maximumTime(string time) {\\n    SetMax(time[0], time[1], \\'2\\', \\'3\\');\\n    SetMax(time[3], time[4], \\'5\\', \\'9\\');\\n    return time;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Sets the two digits number {a, b} to as close to {a_max, b_max} as possible\\n// by replacing the `?` in a and b.\\nvoid SetMax(char& a, char& b, char a_max, char b_max) {\\n  if (a == \\'?\\') {\\n    if (b == \\'?\\' || b <= b_max) {\\n      a = a_max;\\n    } else {\\n      a = a_max - 1;\\n    }\\n  }\\n  if (b == \\'?\\') {\\n    if (a == a_max) {\\n      b = b_max;\\n    } else {\\n      b = \\'9\\';\\n    }\\n  }\\n}\\n\\nclass Solution {\\npublic:\\n  string maximumTime(string time) {\\n    SetMax(time[0], time[1], \\'2\\', \\'3\\');\\n    SetMax(time[3], time[4], \\'5\\', \\'9\\');\\n    return time;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743378,
                "title": "a-purely-if-statement-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] nums = time.toCharArray();\\n        if(nums[0] == \\'?\\') nums[0] = (nums[1] == \\'?\\') ? \\'2\\': (nums[1] <= \\'3\\' ? \\'2\\' : \\'1\\');\\n        if(nums[1] == \\'?\\') nums[1] = (nums[0] == \\'2\\') ? \\'3\\': \\'9\\';\\n        if(nums[3] == \\'?\\') nums[3] = \\'5\\';\\n        if(nums[4] == \\'?\\') nums[4] = \\'9\\';\\n        return String.valueOf(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] nums = time.toCharArray();\\n        if(nums[0] == \\'?\\') nums[0] = (nums[1] == \\'?\\') ? \\'2\\': (nums[1] <= \\'3\\' ? \\'2\\' : \\'1\\');\\n        if(nums[1] == \\'?\\') nums[1] = (nums[0] == \\'2\\') ? \\'3\\': \\'9\\';\\n        if(nums[3] == \\'?\\') nums[3] = \\'5\\';\\n        if(nums[4] == \\'?\\') nums[4] = \\'9\\';\\n        return String.valueOf(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739339,
                "title": "o-1-time-o-1-space-c",
                "content": "# Intuition\\nIt\\'s a condition based question.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        //hr\\n        if(time[0] == \\'?\\'){\\n            if(time[1]!=\\'?\\' && time[1]>=\\'0\\' && time[1] <=\\'3\\'){\\n               time[0] = \\'2\\';\\n            }    \\n            else if(time[1]!=\\'?\\' && time[1]>\\'3\\')\\n                time[0] = \\'1\\';\\n            else if(time[1] == \\'?\\')\\n                time[0] = \\'2\\';\\n        }\\n        if(time[1] == \\'?\\'){    \\n            if(time[0] == \\'2\\')\\n                time[1] = \\'3\\';\\n            else\\n                time[1] = \\'9\\';\\n        }\\n        //min\\n        if(time[3] == \\'?\\')\\n            time[3] = \\'5\\';\\n        if(time[4] == \\'?\\')\\n            time[4] = \\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        //hr\\n        if(time[0] == \\'?\\'){\\n            if(time[1]!=\\'?\\' && time[1]>=\\'0\\' && time[1] <=\\'3\\'){\\n               time[0] = \\'2\\';\\n            }    \\n            else if(time[1]!=\\'?\\' && time[1]>\\'3\\')\\n                time[0] = \\'1\\';\\n            else if(time[1] == \\'?\\')\\n                time[0] = \\'2\\';\\n        }\\n        if(time[1] == \\'?\\'){    \\n            if(time[0] == \\'2\\')\\n                time[1] = \\'3\\';\\n            else\\n                time[1] = \\'9\\';\\n        }\\n        //min\\n        if(time[3] == \\'?\\')\\n            time[3] = \\'5\\';\\n        if(time[4] == \\'?\\')\\n            time[4] = \\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738128,
                "title": "o-1-using-only-if-else-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n       \\n       if(time[0]==\\'?\\' && time[1]==\\'?\\')\\n       {\\n           time[0]=\\'2\\';\\n           time[1]=\\'3\\';\\n       }\\n       else if(time[0]==\\'?\\')\\n       {\\n           if(time[1]<=\\'3\\')  time[0]=\\'2\\';\\n           else            time[0]=\\'1\\';\\n       }\\n       else  if(time[1]==\\'?\\')\\n       {\\n          if(time[0]<\\'2\\')  time[1]=\\'9\\';\\n          else           time[1]=\\'3\\';\\n       }\\n\\n       if(time[3]==\\'?\\' && time[4]==\\'?\\')\\n       {\\n           time[3]=\\'5\\';\\n           time[4]=\\'9\\';\\n       }\\n       else if(time[3]==\\'?\\')\\n       {\\n           time[3]=\\'5\\';\\n       }\\n       else if(time[4]==\\'?\\')\\n       {\\n           time[4]=\\'9\\';\\n       }\\n       return time;\\n    \\n    }\\n};\\n/* PLEASE UPVOTE IF IT HELPS PLZZZZZ*/\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n       \\n       if(time[0]==\\'?\\' && time[1]==\\'?\\')\\n       {\\n           time[0]=\\'2\\';\\n           time[1]=\\'3\\';\\n       }\\n       else if(time[0]==\\'?\\')\\n       {\\n           if(time[1]<=\\'3\\')  time[0]=\\'2\\';\\n           else            time[0]=\\'1\\';\\n       }\\n       else  if(time[1]==\\'?\\')\\n       {\\n          if(time[0]<\\'2\\')  time[1]=\\'9\\';\\n          else           time[1]=\\'3\\';\\n       }\\n\\n       if(time[3]==\\'?\\' && time[4]==\\'?\\')\\n       {\\n           time[3]=\\'5\\';\\n           time[4]=\\'9\\';\\n       }\\n       else if(time[3]==\\'?\\')\\n       {\\n           time[3]=\\'5\\';\\n       }\\n       else if(time[4]==\\'?\\')\\n       {\\n           time[4]=\\'9\\';\\n       }\\n       return time;\\n    \\n    }\\n};\\n/* PLEASE UPVOTE IF IT HELPS PLZZZZZ*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737492,
                "title": "chatgpt-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hours = list(time[:2])\\n        minutes = list(time[3:])\\n\\n        if hours[0] == \\'?\\':\\n            if hours[1] == \\'?\\' or int(hours[1]) <= 3 :\\n                hours[0] = \\'2\\'\\n            else:\\n                hours[0] = \\'1\\'\\n        if hours[1] == \\'?\\':\\n            if hours[0] == \\'?\\' or hours[0] == \\'2\\':\\n                hours[1] = \\'3\\'\\n            else:\\n                hours[1] = \\'9\\'\\n        if minutes[0] == \\'?\\':\\n            minutes[0] = \\'5\\'\\n        if minutes[1] == \\'?\\':\\n            minutes[1] = \\'9\\'\\n\\n        return \\'\\'.join(hours)+\\':\\'+\\'\\'.join(minutes)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hours = list(time[:2])\\n        minutes = list(time[3:])\\n\\n        if hours[0] == \\'?\\':\\n            if hours[1] == \\'?\\' or int(hours[1]) <= 3 :\\n                hours[0] = \\'2\\'\\n            else:\\n                hours[0] = \\'1\\'\\n        if hours[1] == \\'?\\':\\n            if hours[0] == \\'?\\' or hours[0] == \\'2\\':\\n                hours[1] = \\'3\\'\\n            else:\\n                hours[1] = \\'9\\'\\n        if minutes[0] == \\'?\\':\\n            minutes[0] = \\'5\\'\\n        if minutes[1] == \\'?\\':\\n            minutes[1] = \\'9\\'\\n\\n        return \\'\\'.join(hours)+\\':\\'+\\'\\'.join(minutes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729181,
                "title": "simple-typescript-solution",
                "content": "# Code\\n- Develop a function that substitutes a specific index with a `replacingStr`, but only if the character is `?` and not a numeric digit.\\n- The initial digit is crucial for setting the correct time, so we need to establish the first digit with the following rules:\\n    - If the time is \"??:55\", it should always be reset to \"23:55\".\\n    - If the first digit is \\'?\\', it can only be replaced by 2 or 1.\\n- The remaining time digits can be logically deduced from the first digit, so further explanation is not required.\\n```ts\\nfunction maximumTime(time: string): string {\\n    const replaceWith = (index: number, replacingStr: string) => {\\n        if (time[index] !== \"?\") return\\n        time = time.slice(0, index) + replacingStr + time.slice(index + 1)\\n    }\\n\\n    // The first digit is guaranteed set \\n    if (time.slice(0, 2) === \"??\") replaceWith(0, \"2\"), replaceWith(1, \"3\")\\n    if (time[0] === \"?\") {\\n        parseInt(time[1]) < 4 ? replaceWith(0, \"2\") : replaceWith(0, \"1\")\\n    }\\n\\n    // Set the rest of the digits.\\n    time[0] === \"2\" ? replaceWith(1, \"3\") : replaceWith(1, \"9\")\\n    replaceWith(3, \"5\")\\n    replaceWith(4, \"9\")\\n    return time\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction maximumTime(time: string): string {\\n    const replaceWith = (index: number, replacingStr: string) => {\\n        if (time[index] !== \"?\") return\\n        time = time.slice(0, index) + replacingStr + time.slice(index + 1)\\n    }\\n\\n    // The first digit is guaranteed set \\n    if (time.slice(0, 2) === \"??\") replaceWith(0, \"2\"), replaceWith(1, \"3\")\\n    if (time[0] === \"?\") {\\n        parseInt(time[1]) < 4 ? replaceWith(0, \"2\") : replaceWith(0, \"1\")\\n    }\\n\\n    // Set the rest of the digits.\\n    time[0] === \"2\" ? replaceWith(1, \"3\") : replaceWith(1, \"9\")\\n    replaceWith(3, \"5\")\\n    replaceWith(4, \"9\")\\n    return time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3727358,
                "title": "error-correcting-code-and-decorators-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe following intuition lays out the process generally. If you want to attempt it on your own, or are doing this for class as extra credit, you should read ONLY the Intuition. It should be enough to cover your problem.\\n\\nRemember, extra credit is on the honor system somewhat, as I\\'m judging your code against any fundamental differences to mine. You should either try to improve it for extra credit, or show that you did implement it in a non-improved fashion for extra credit. Improvements are above and beyond, while non-improved fashion is meant to show honest work. You decide which matters more to you as part of the process.\\n\\nIt must also use the two stated ideas in the title, in this case Error Correcting Code and Decorators. \\n\\nFrom the [wiki](https://en.wikipedia.org/wiki/Error_correction_code) on Error Correction Code : \\n> In computing, telecommunication, information theory, and coding  \\n> theory, forward error correction (FEC) or channel coding[1][2][3] is a \\n> technique used for controlling errors in data transmission over \\n> unreliable or noisy communication channels.\\n> \\n> The central idea is that the sender encodes the message in a redundant \\n> way, most often by using an error correction code or error correcting \\n> code, (ECC).[4][5] The redundancy allows the receiver not only to detect \\n> errors that may occur anywhere in the message, but often to correct a \\n> limited number of errors. Therefore a reverse channel to request \\n> re-transmission may not be needed. The cost is a fixed, higher forward \\n> channel bandwidth.\\n\\nThis shows us a path forward for the current problem. From the initial description above, note that this is something that can be accomplished with descriptor functions and this idea as a key part of your intuitive solution. \\n\\nDecorators are functions in python that take another function and extends the behavior of that function without explicitly changing it. [Another way to say this](https://pbs.twimg.com/media/Dl5B9dGUcAEmoGV.jpg) is that a decorator function is a function inside another function. \\n\\nWith this in mind, consider the problem statement again. We are looking for the latest time by replacing hidden digits. We thus are looking to repair a message sent based on conditioned relationships between the timing. \\n\\n- The first value for the timing currently can be 0, 1, 2, or ? \\n- The second value for the timing currently can be 0-9 and ? \\n    - However the second value for the timing can only be 0-3 and ? if the first value is 2 or ? \\n    - Similarly, the second value for the timing can be 0-9 or ? if the first value is 0 or 1 \\n- The third value is the colon, no change needed there \\n- The fourth value for the timing currently can be 0-5 or ? \\n- The fifth value for the timing currently can be 0-9 or ? \\n\\nBased on all this, to kick off your decorating, which timing can you absolutely modify first to maximum or itself? Think back on our work on recursion before reading further if you are going to attempt it on your own, otherwise read on! \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a recursive decorator approach to solving the problem. \\n\\nFirst make a function to replace the last entry in time, which I call replace_last_place(time)\\nIf time[-1] is not ? \\n- return time \\n- otherwise, return time[:-1] + \"9\"  \\n\\nThen, make a function to replace second to last entry, which I call replace_second_to_last(time) \\nIf time[-2] is not ? \\n- return replace_last_place(time) \\n- otherwise, return replace_last_place(time[:-2]+\"5\"+time[-1])\\n\\nHere\\'s the start of our error correction code next then. We need a way to consider the second hour relative to the first. However, we may have made a mistake while dealing with the first that we need to address here. In this case, let\\'s consider hours as two parts, hour and demi hour. The demi hour is the second of the hours, and our limited factor. As such, we make a replace demi hour function that uses time and the lead hour value before replacement. \\nHere\\'s the layout for replace_demi_hour(time, lead_hour) \\n- If lead hour is \"?\" \\n    - if time[1] in \"456789\" \\n        - time = \"1\" + time[1:], since we made a mistake setting lead hour to \"2\" (since we maximize on \"?\" based on place -> hint for modification using dictionaries there...) \\n        - time is then replace_second_to_last(time) \\n- otherwise if lead hour is not \"?\" \\n    - if lead hour is in \"01\" \\n        - time is replace_second_to_last(time) if time[1] != \"?\"\\n        - else time is replace_second_to_last(time[0]+\"9\"+time[2:])    \\n        - we can do this since we have time[0] as something that can stand 0-9 in the second place value \\n    - otherwise lead hour is strictly \"2\" \\n        - time is replace_second_to_last(time) if time[1] != \"?\"  \\n        - else time is repalce_second_to_last(time[0]+\"3\"+time[2:])\\n        - we are limited by time[0] at this point \\n- return time when done \\n\\nOur initial method replace hours then only needs the time parameter. Here\\'s replace_hours(time) \\n- return replace_demi_hour(time, time[0]) if time[0] != \"?\" \\n- otherwise return replace_demi_hour(\"2\"+time[1:], time[0]) \\n- notice that we do not need to correct for the second hour here, as demi-hour has that handled. \\n- this is similar to other professional implementations where the method of replace_demi_hour is likely kept off site, away from the prying eyes of others when they use your code in a database. \\n\\nTo complete our method, the return for maximumTime is return replace_hours(time)  \\n\\n# Complexity\\n- Time complexity : O(1) or O(S) \\n    - All comparisons are O(1) \\n    - All comparisons are done with relation to the next down the line and have no loop based considerations \\n    - Alternately, you can argue we need to progress through the call stack, so the time is O(S) where S is the call stack size. \\n\\n- Space complexity : O(1) or O(S) \\n    - As above \\n     \\n# Code\\n```\\nclass Solution :\\n    # fun with decorators\\n    def maximumTime(self, time: str) -> str :\\n        def replace_last_place(time) : \\n            # if time[-1] is not ? return time, otherwise max to 9 \\n            return time if time[-1] != \"?\" else time[:-1] + \"9\"\\n        \\n        def replace_second_to_last(time) : \\n            # if time[-2] is not ? return replace_last_place(time), otherwise max time[-2] to 5 and then replace_last_place(time)\\n            return replace_last_place(time) if time[-2] != \"?\" else replace_last_place(time[:-2] + \"5\" + time[-1])\\n\\n        def replace_demi_hour(time, lead_hour) : \\n            # if lead hour is ? and time[1] in 4-9\\n            if lead_hour == \"?\" : \\n                if time[1] in \"456789\" : \\n                    # we made a mistake, reset time\\n                    time = \"1\" + time[1:]\\n                    # set time to replace second to last\\n                    # we can skip the check here since we know time[1] is also not ?  \\n                    time = replace_second_to_last(time)\\n                else : \\n                    # else if time[1] not in 4-9, it might be ?. If it\\'s not ?, normal return. Otherwise, alternate \\n                    # note that since lead hour is ?, lead hour is actually 2. So, we have max of 3. \\n                    time = replace_second_to_last(time) if time[1] != \"?\" else replace_second_to_last(time[0]+\"3\"+time[2:])\\n            elif lead_hour != \"?\" : \\n                # if lead hour is not ?\\n                # determine if in 01 \\n                if lead_hour in \"01\" : \\n                    # if lead hour is not ? or 2, \\n                    # return replace second to last if time[1] is not ?, otherwise max second digit to 9 \\n                    time = replace_second_to_last(time) if time[1] != \"?\" else replace_second_to_last(time[0] + \"9\" + time[2:])\\n                else : \\n                    # otherwise lead hour is 2, \\n                    # return replace second to last if time[1] is not ?, otherwise max second digit to 3 \\n                    time = replace_second_to_last(time) if time[1] != \"?\" else replace_second_to_last(time[0] + \"3\" + time[2:])\\n            # when done with all return time \\n            return time\\n        \\n        def replace_hours(time) : \\n            # replace demi hour uses time and time[0] if not ?, otherwise, set to 2 initially and pass current as lead hour \\n            # this lets us use lead hour as a check against our mistake potential here. This is similar to error correcting code!\\n            return replace_demi_hour(time, time[0]) if time[0] != \"?\" else replace_demi_hour(\"2\"+time[1:], time[0])\\n            \\n        # return replace hours using time \\n        return replace_hours(time)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution :\\n    # fun with decorators\\n    def maximumTime(self, time: str) -> str :\\n        def replace_last_place(time) : \\n            # if time[-1] is not ? return time, otherwise max to 9 \\n            return time if time[-1] != \"?\" else time[:-1] + \"9\"\\n        \\n        def replace_second_to_last(time) : \\n            # if time[-2] is not ? return replace_last_place(time), otherwise max time[-2] to 5 and then replace_last_place(time)\\n            return replace_last_place(time) if time[-2] != \"?\" else replace_last_place(time[:-2] + \"5\" + time[-1])\\n\\n        def replace_demi_hour(time, lead_hour) : \\n            # if lead hour is ? and time[1] in 4-9\\n            if lead_hour == \"?\" : \\n                if time[1] in \"456789\" : \\n                    # we made a mistake, reset time\\n                    time = \"1\" + time[1:]\\n                    # set time to replace second to last\\n                    # we can skip the check here since we know time[1] is also not ?  \\n                    time = replace_second_to_last(time)\\n                else : \\n                    # else if time[1] not in 4-9, it might be ?. If it\\'s not ?, normal return. Otherwise, alternate \\n                    # note that since lead hour is ?, lead hour is actually 2. So, we have max of 3. \\n                    time = replace_second_to_last(time) if time[1] != \"?\" else replace_second_to_last(time[0]+\"3\"+time[2:])\\n            elif lead_hour != \"?\" : \\n                # if lead hour is not ?\\n                # determine if in 01 \\n                if lead_hour in \"01\" : \\n                    # if lead hour is not ? or 2, \\n                    # return replace second to last if time[1] is not ?, otherwise max second digit to 9 \\n                    time = replace_second_to_last(time) if time[1] != \"?\" else replace_second_to_last(time[0] + \"9\" + time[2:])\\n                else : \\n                    # otherwise lead hour is 2, \\n                    # return replace second to last if time[1] is not ?, otherwise max second digit to 3 \\n                    time = replace_second_to_last(time) if time[1] != \"?\" else replace_second_to_last(time[0] + \"3\" + time[2:])\\n            # when done with all return time \\n            return time\\n        \\n        def replace_hours(time) : \\n            # replace demi hour uses time and time[0] if not ?, otherwise, set to 2 initially and pass current as lead hour \\n            # this lets us use lead hour as a check against our mistake potential here. This is similar to error correcting code!\\n            return replace_demi_hour(time, time[0]) if time[0] != \"?\" else replace_demi_hour(\"2\"+time[1:], time[0])\\n            \\n        # return replace hours using time \\n        return replace_hours(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705138,
                "title": "full-of-if-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCompletely naive\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]>=\\'4\\'&&time[1]<=\\'9\\')\\n            time[0]=\\'1\\';\\n            else\\n            time[0]=\\'2\\';\\n\\n        }\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'0\\'||time[0]==\\'1\\')\\n            time[1]=\\'9\\';\\n            else time[1]=\\'3\\';\\n        }\\n        if(time[3]==\\'?\\'){\\n            time[3]=\\'5\\';\\n        }\\n        if(time[4]==\\'?\\'){\\n            time[4]=\\'9\\';\\n        }\\n        \\n        return time;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]>=\\'4\\'&&time[1]<=\\'9\\')\\n            time[0]=\\'1\\';\\n            else\\n            time[0]=\\'2\\';\\n\\n        }\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'0\\'||time[0]==\\'1\\')\\n            time[1]=\\'9\\';\\n            else time[1]=\\'3\\';\\n        }\\n        if(time[3]==\\'?\\'){\\n            time[3]=\\'5\\';\\n        }\\n        if(time[4]==\\'?\\'){\\n            time[4]=\\'9\\';\\n        }\\n        \\n        return time;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700353,
                "title": "greedy-java-solution-2-ms",
                "content": "# Greedy Solution\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] timeArr = time.toCharArray();\\n        if (timeArr[0] == \\'?\\') {\\n            timeArr[0] = (timeArr[1] == \\'?\\' || timeArr[1] < \\'4\\') ? \\'2\\' : \\'1\\'; \\n        }\\n        if (timeArr[1] == \\'?\\') {\\n            timeArr[1] = (timeArr[0] == \\'2\\') ? \\'3\\' : \\'9\\'; \\n        }\\n        if (timeArr[3] == \\'?\\') {\\n            timeArr[3] = \\'5\\'; \\n        }\\n        if (timeArr[4] == \\'?\\') {\\n            timeArr[4] = \\'9\\'; \\n        }       \\n        return new String(timeArr);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] timeArr = time.toCharArray();\\n        if (timeArr[0] == \\'?\\') {\\n            timeArr[0] = (timeArr[1] == \\'?\\' || timeArr[1] < \\'4\\') ? \\'2\\' : \\'1\\'; \\n        }\\n        if (timeArr[1] == \\'?\\') {\\n            timeArr[1] = (timeArr[0] == \\'2\\') ? \\'3\\' : \\'9\\'; \\n        }\\n        if (timeArr[3] == \\'?\\') {\\n            timeArr[3] = \\'5\\'; \\n        }\\n        if (timeArr[4] == \\'?\\') {\\n            timeArr[4] = \\'9\\'; \\n        }       \\n        return new String(timeArr);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689874,
                "title": "0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]==\\'?\\' || time[1]<\\'4\\') time[0] = \\'2\\';\\n            else time[0] = \\'1\\';\\n        } \\n        if(time[3]==\\'?\\') time[3] = \\'5\\';\\n        if(time[4]==\\'?\\') time[4] = \\'9\\';\\n        if(time[1]==\\'?\\') {\\n            if(time[0]!=\\'2\\') time[1] = \\'9\\';\\n            else time[1] = \\'3\\';\\n        };\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]==\\'?\\' || time[1]<\\'4\\') time[0] = \\'2\\';\\n            else time[0] = \\'1\\';\\n        } \\n        if(time[3]==\\'?\\') time[3] = \\'5\\';\\n        if(time[4]==\\'?\\') time[4] = \\'9\\';\\n        if(time[1]==\\'?\\') {\\n            if(time[0]!=\\'2\\') time[1] = \\'9\\';\\n            else time[1] = \\'3\\';\\n        };\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681470,
                "title": "c-easy-and-readable-solution-faster-than-72-less-than-85",
                "content": "![image.png](https://assets.leetcode.com/users/images/d3174587-f095-4620-b344-740538bdb9b0_1687702527.6987026.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n        StringBuilder sb = new();\\n        if (time[0] == \\'?\\')\\n        {\\n            if (time[1] == \\'?\\')\\n                sb.Append(\"23\");\\n            else\\n                sb.Append(time[1] <= \\'3\\' ? \"2\" : \"1\").Append(time[1].ToString());\\n        }\\n        else\\n            sb.Append(time[0].ToString()).Append(time[1] == \\'?\\' ? (time[0] == \\'2\\' ? \"3\" : \"9\") : time[1].ToString());\\n        sb.Append(\":\").Append(time[3] == \\'?\\' ? \"5\" : time[3].ToString());\\n        sb.Append(time[4] == \\'?\\' ? \"9\" : time[4].ToString());\\n        return sb.ToString();\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n        StringBuilder sb = new();\\n        if (time[0] == \\'?\\')\\n        {\\n            if (time[1] == \\'?\\')\\n                sb.Append(\"23\");\\n            else\\n                sb.Append(time[1] <= \\'3\\' ? \"2\" : \"1\").Append(time[1].ToString());\\n        }\\n        else\\n            sb.Append(time[0].ToString()).Append(time[1] == \\'?\\' ? (time[0] == \\'2\\' ? \"3\" : \"9\") : time[1].ToString());\\n        sb.Append(\":\").Append(time[3] == \\'?\\' ? \"5\" : time[3].ToString());\\n        sb.Append(time[4] == \\'?\\' ? \"9\" : time[4].ToString());\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660702,
                "title": "python-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        res=\\'\\'\\n        hr,mn=time.split(\":\")\\n        if hr[0]!=\\'?\\' and hr[1]!=\\'?\\':\\n            res=res+hr[0]+hr[1]\\n        if hr[0]==\\'?\\' and hr[1]==\\'?\\':\\n            res=res+\\'23\\'\\n        if hr[0]==\\'?\\' and hr[1]<=\\'3\\':\\n            res=res+\\'2\\'+hr[1]\\n        if hr[0]==\\'?\\' and hr[1]>\\'3\\':\\n            res=res+\\'1\\'+hr[1]\\n        if hr[0]<=\\'1\\' and hr[1]==\\'?\\':\\n            res=res+hr[0]+\\'9\\'      \\n        if hr[0]==\\'2\\' and hr[1]==\\'?\\':\\n            res=res+\\'23\\'\\n        res=res[:2]\\n        res=res+\\':\\'\\n        if mn[0]==\\'?\\' and mn[1]==\\'?\\':\\n            res=res+\\'59\\'\\n        if mn[0]!=\\'?\\' and mn[1]!=\\'?\\':\\n            res=res+mn[0]+mn[1]\\n        if mn[0]==\\'?\\' and mn[1]!=\\'?\\':\\n            res=res+\\'5\\'+mn[1]\\n        if mn[0]!=\\'?\\' and mn[1]==\\'?\\':\\n            res=res+mn[0]+\\'9\\'\\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        res=\\'\\'\\n        hr,mn=time.split(\":\")\\n        if hr[0]!=\\'?\\' and hr[1]!=\\'?\\':\\n            res=res+hr[0]+hr[1]\\n        if hr[0]==\\'?\\' and hr[1]==\\'?\\':\\n            res=res+\\'23\\'\\n        if hr[0]==\\'?\\' and hr[1]<=\\'3\\':\\n            res=res+\\'2\\'+hr[1]\\n        if hr[0]==\\'?\\' and hr[1]>\\'3\\':\\n            res=res+\\'1\\'+hr[1]\\n        if hr[0]<=\\'1\\' and hr[1]==\\'?\\':\\n            res=res+hr[0]+\\'9\\'      \\n        if hr[0]==\\'2\\' and hr[1]==\\'?\\':\\n            res=res+\\'23\\'\\n        res=res[:2]\\n        res=res+\\':\\'\\n        if mn[0]==\\'?\\' and mn[1]==\\'?\\':\\n            res=res+\\'59\\'\\n        if mn[0]!=\\'?\\' and mn[1]!=\\'?\\':\\n            res=res+mn[0]+mn[1]\\n        if mn[0]==\\'?\\' and mn[1]!=\\'?\\':\\n            res=res+\\'5\\'+mn[1]\\n        if mn[0]!=\\'?\\' and mn[1]==\\'?\\':\\n            res=res+mn[0]+\\'9\\'\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656843,
                "title": "got-100-somehow",
                "content": "# Intuition\\nIt was the most basic and naive approach. Weirded out on why I got 100%... oh well anyways here is the code feel free to comment and upvote. I don\\'t often get score like this \\uD83D\\uDE05\\n\\n![Capture1.PNG](https://assets.leetcode.com/users/images/d9a8bbcc-e5dc-4f7f-8e32-4b6d14c14b27_1687177612.101801.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n        t = []\\n        for i in range(len(time)):\\n            t.append(time[i])\\n            if time[i] == \"?\":\\n                if i == 0:\\n                    if time[i+1] == \"?\":\\n                        t[i] = \"2\"\\n                    elif int(time[i+1]) <= 3:\\n                        t[i] = \"2\"\\n                    else:\\n                        t[i] = \"1\"\\n                elif t[i - 1] == \"2\" and i - 1 == 0:\\n                    t[i] = \"3\"\\n                elif time[i-1] == \":\":\\n                    t[i] = \"5\"\\n                else:\\n                    t[i] = \"9\"\\n\\n        return \\'\\'.join(t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n        t = []\\n        for i in range(len(time)):\\n            t.append(time[i])\\n            if time[i] == \"?\":\\n                if i == 0:\\n                    if time[i+1] == \"?\":\\n                        t[i] = \"2\"\\n                    elif int(time[i+1]) <= 3:\\n                        t[i] = \"2\"\\n                    else:\\n                        t[i] = \"1\"\\n                elif t[i - 1] == \"2\" and i - 1 == 0:\\n                    t[i] = \"3\"\\n                elif time[i-1] == \":\":\\n                    t[i] = \"5\"\\n                else:\\n                    t[i] = \"9\"\\n\\n        return \\'\\'.join(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655866,
                "title": "if-it-work-it-work",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLiterally tried to brute force this by changing each word one at a time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSmash the solution into the submit button until there is no more error\\n\\n# Complexity\\n- Time complexity: O(1) i believe ?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1) i believe ?\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time=list(time)\\n        if time[0] == \\'?\\':\\n            if time[1] != \\'?\\':\\n                if int(time[1]) >= 4:\\n                    time[0] = \\'1\\'\\n                else: time[0] = \\'2\\'\\n            else: time[0] = \\'2\\'\\n        if time[1] == \\'?\\':\\n            if time[0]== \\'2\\':\\n                time[1] = \\'3\\'\\n            else: time[1] = \\'9\\'\\n        if time[3] == \\'?\\':\\n            time[3] = \\'5\\'\\n        if time[4] == \\'?\\':\\n            time[4] = \\'9\\'\\n        return \\'\\'.join(time)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time=list(time)\\n        if time[0] == \\'?\\':\\n            if time[1] != \\'?\\':\\n                if int(time[1]) >= 4:\\n                    time[0] = \\'1\\'\\n                else: time[0] = \\'2\\'\\n            else: time[0] = \\'2\\'\\n        if time[1] == \\'?\\':\\n            if time[0]== \\'2\\':\\n                time[1] = \\'3\\'\\n            else: time[1] = \\'9\\'\\n        if time[3] == \\'?\\':\\n            time[3] = \\'5\\'\\n        if time[4] == \\'?\\':\\n            time[4] = \\'9\\'\\n        return \\'\\'.join(time)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654991,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maximumTime(time: String): String = {\\n      val hour = if (time(0) == \\'?\\' && time(1) == \\'?\\') \"23\"\\n                  else if (time(0) == \\'?\\' && time(1) <= \\'3\\') \"2\" + time(1)\\n                  else if (time(0) == \\'?\\' && time(1) > \\'3\\') \"1\" + time(1)\\n                  else if (time(1) == \\'?\\' && time(0) <= \\'1\\') time(0) + \"9\"\\n                  else if (time(1) == \\'?\\' && time(0) == \\'2\\') \"23\"\\n                  else time.take(2)\\n      val minute = if (time(3) == \\'?\\' && time(4) == \\'?\\') \"59\"\\n                    else if (time(3) == \\'?\\' && time(4) <= \\'9\\') \"5\" + time(4)\\n                    else if (time(4) == \\'?\\' && time(3) <= \\'5\\') time(3) + \"9\"\\n                    else time.takeRight(2)\\n      s\"$hour:$minute\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maximumTime(time: String): String = {\\n      val hour = if (time(0) == \\'?\\' && time(1) == \\'?\\') \"23\"\\n                  else if (time(0) == \\'?\\' && time(1) <= \\'3\\') \"2\" + time(1)\\n                  else if (time(0) == \\'?\\' && time(1) > \\'3\\') \"1\" + time(1)\\n                  else if (time(1) == \\'?\\' && time(0) <= \\'1\\') time(0) + \"9\"\\n                  else if (time(1) == \\'?\\' && time(0) == \\'2\\') \"23\"\\n                  else time.take(2)\\n      val minute = if (time(3) == \\'?\\' && time(4) == \\'?\\') \"59\"\\n                    else if (time(3) == \\'?\\' && time(4) <= \\'9\\') \"5\" + time(4)\\n                    else if (time(4) == \\'?\\' && time(3) <= \\'5\\') time(3) + \"9\"\\n                    else time.takeRight(2)\\n      s\"$hour:$minute\"\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3648817,
                "title": "simple-approach-using-a-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maximumTime(time string) string {\\n\\tmapper := map[string]string{\\n\\t\\t\"2?h\": \"23\",\\n\\t\\t\"1?h\": \"19\",\\n\\t\\t\"0?h\": \"09\",\\n\\t\\t\"?1h\": \"21\",\\n\\t\\t\"?2h\": \"22\",\\n\\t\\t\"?3h\": \"23\",\\n\\t\\t\"?4h\": \"14\",\\n\\t\\t\"?5h\": \"15\",\\n\\t\\t\"?6h\": \"16\",\\n\\t\\t\"?7h\": \"17\",\\n\\t\\t\"?8h\": \"18\",\\n\\t\\t\"?9h\": \"19\",\\n\\t\\t\"?0h\": \"20\",\\n\\t\\t\"??h\": \"23\",\\n\\t\\t\"0?m\" : \"09\",\\n\\t\\t\"1?m\" : \"19\",\\n\\t\\t\"2?m\" : \"29\",\\n\\t\\t\"3?m\" : \"39\",\\n\\t\\t\"4?m\" : \"49\",\\n\\t\\t\"5?m\" : \"59\",\\n\\t\\t\"?0m\" : \"50\",\\n\\t\\t\"?1m\" : \"51\",\\n\\t\\t\"?2m\" : \"52\",\\n\\t\\t\"?3m\" : \"53\",\\n\\t\\t\"?4m\" : \"54\",\\n\\t\\t\"?5m\" : \"55\",\\n\\t\\t\"?6m\" : \"56\",\\n\\t\\t\"?7m\" : \"57\",\\n\\t\\t\"?8m\" : \"58\",\\n\\t\\t\"?9m\" : \"59\",\\n\\t\\t\"??m\" : \"59\",\\n\\t}\\n\\n\\tindx, indx2 := mapper[time[0:2] + \"h\"], mapper[time[3:5]+\"m\"]\\n\\n\\tif indx == \"\" {\\n\\t\\tindx = time[0:2]\\n\\t}\\n\\n\\tif indx2 == \"\" {\\n\\t\\tindx2 = time[3:5]\\n\\t}\\n\\n\\treturn indx + \":\" + indx2\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumTime(time string) string {\\n\\tmapper := map[string]string{\\n\\t\\t\"2?h\": \"23\",\\n\\t\\t\"1?h\": \"19\",\\n\\t\\t\"0?h\": \"09\",\\n\\t\\t\"?1h\": \"21\",\\n\\t\\t\"?2h\": \"22\",\\n\\t\\t\"?3h\": \"23\",\\n\\t\\t\"?4h\": \"14\",\\n\\t\\t\"?5h\": \"15\",\\n\\t\\t\"?6h\": \"16\",\\n\\t\\t\"?7h\": \"17\",\\n\\t\\t\"?8h\": \"18\",\\n\\t\\t\"?9h\": \"19\",\\n\\t\\t\"?0h\": \"20\",\\n\\t\\t\"??h\": \"23\",\\n\\t\\t\"0?m\" : \"09\",\\n\\t\\t\"1?m\" : \"19\",\\n\\t\\t\"2?m\" : \"29\",\\n\\t\\t\"3?m\" : \"39\",\\n\\t\\t\"4?m\" : \"49\",\\n\\t\\t\"5?m\" : \"59\",\\n\\t\\t\"?0m\" : \"50\",\\n\\t\\t\"?1m\" : \"51\",\\n\\t\\t\"?2m\" : \"52\",\\n\\t\\t\"?3m\" : \"53\",\\n\\t\\t\"?4m\" : \"54\",\\n\\t\\t\"?5m\" : \"55\",\\n\\t\\t\"?6m\" : \"56\",\\n\\t\\t\"?7m\" : \"57\",\\n\\t\\t\"?8m\" : \"58\",\\n\\t\\t\"?9m\" : \"59\",\\n\\t\\t\"??m\" : \"59\",\\n\\t}\\n\\n\\tindx, indx2 := mapper[time[0:2] + \"h\"], mapper[time[3:5]+\"m\"]\\n\\n\\tif indx == \"\" {\\n\\t\\tindx = time[0:2]\\n\\t}\\n\\n\\tif indx2 == \"\" {\\n\\t\\tindx2 = time[3:5]\\n\\t}\\n\\n\\treturn indx + \":\" + indx2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643133,
                "title": "c-o-1-short",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public string MaximumTime(string time) \\n    {\\n        char t0;\\n        char t1;\\n        char t2;\\n        char t3;\\n\\n        if (time[0] == \\'?\\')\\n        {\\n            if (time[1] == \\'?\\')\\n            {\\n                t0 = \\'2\\';\\n                t1 = \\'3\\';\\n            }\\n            else\\n            {\\n                t0 = time[1] > \\'3\\' ? \\'1\\' : \\'2\\';\\n                t1 = time[1];\\n            }\\n        }\\n        else\\n        {\\n            t0 = time[0];\\n            t1 = (time[1] == \\'?\\' ? (time[0] == \\'2\\' ?\\'3\\':\\'9\\') : time[1]);\\n        }\\n\\n        t2 = time[3] == \\'?\\' ? \\'5\\' : time[3];\\n        t3 = time[4] == \\'?\\' ? \\'9\\' : time[4];\\n\\n        return $\"{t0}{t1}:{t2}{t3}\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string MaximumTime(string time) \\n    {\\n        char t0;\\n        char t1;\\n        char t2;\\n        char t3;\\n\\n        if (time[0] == \\'?\\')\\n        {\\n            if (time[1] == \\'?\\')\\n            {\\n                t0 = \\'2\\';\\n                t1 = \\'3\\';\\n            }\\n            else\\n            {\\n                t0 = time[1] > \\'3\\' ? \\'1\\' : \\'2\\';\\n                t1 = time[1];\\n            }\\n        }\\n        else\\n        {\\n            t0 = time[0];\\n            t1 = (time[1] == \\'?\\' ? (time[0] == \\'2\\' ?\\'3\\':\\'9\\') : time[1]);\\n        }\\n\\n        t2 = time[3] == \\'?\\' ? \\'5\\' : time[3];\\n        t3 = time[4] == \\'?\\' ? \\'9\\' : time[4];\\n\\n        return $\"{t0}{t1}:{t2}{t3}\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639301,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} time\\n * @return {string}\\n */\\nvar maximumTime = function(time) {\\n    let result = time.split(\"\");\\n    if (result[0] === \"?\") result[0] = result[1] > 3 ? \"1\" : \"2\";\\n    if (result[1] === \"?\") result[1] = result[0] > 1 ? \"3\" : \"9\";\\n    if (result[3] === \"?\") result[3] = \"5\";\\n    if (result[4] === \"?\") result[4] = \"9\";\\n    return result.join(\"\");\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} time\\n * @return {string}\\n */\\nvar maximumTime = function(time) {\\n    let result = time.split(\"\");\\n    if (result[0] === \"?\") result[0] = result[1] > 3 ? \"1\" : \"2\";\\n    if (result[1] === \"?\") result[1] = result[0] > 1 ? \"3\" : \"9\";\\n    if (result[3] === \"?\") result[3] = \"5\";\\n    if (result[4] === \"?\") result[4] = \"9\";\\n    return result.join(\"\");\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615029,
                "title": "a-good-beginner-level-intro-to-corner-cases",
                "content": "# Intuition\\nJust try to maximize the values.\\n\\n\\n# Complexity\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'?\\'){\\n                time[0]=\\'2\\';\\n                time[1]=\\'3\\';\\n            }else{\\n                if(time[0]==\\'2\\')\\n                    time[1]=\\'3\\';\\n                else\\n                    time[1]=\\'9\\';\\n            }\\n        }else if(time[0]==\\'?\\'){\\n            if(time[1]>\\'3\\')\\n                time[0]=\\'1\\';\\n            else\\n                time[0]=\\'2\\';\\n        }\\n        if(time[4]==\\'?\\')\\n            time[4]=\\'9\\';\\n        if(time[3]==\\'?\\')\\n            time[3]=\\'5\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'?\\'){\\n                time[0]=\\'2\\';\\n                time[1]=\\'3\\';\\n            }else{\\n                if(time[0]==\\'2\\')\\n                    time[1]=\\'3\\';\\n                else\\n                    time[1]=\\'9\\';\\n            }\\n        }else if(time[0]==\\'?\\'){\\n            if(time[1]>\\'3\\')\\n                time[0]=\\'1\\';\\n            else\\n                time[0]=\\'2\\';\\n        }\\n        if(time[4]==\\'?\\')\\n            time[4]=\\'9\\';\\n        if(time[3]==\\'?\\')\\n            time[3]=\\'5\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594146,
                "title": "easy-solution-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck all possible position of \\'?\\' and replace it with greatest number possible. First two places have conditions for greatest value and last two places have greatest value 5 and 9.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]==\\'?\\')\\n            time[0]=\\'2\\';\\n            else{\\n                if(int(time[1]-\\'0\\')<=3)\\n                time[0]=\\'2\\';\\n                else\\n                time[0]=\\'1\\';\\n            }\\n        }\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'2\\')\\n            time[1]=\\'3\\';\\n            else\\n            time[1]=\\'9\\';\\n        }\\n        if(time[3]==\\'?\\')\\n        time[3]=\\'5\\';\\n        if(time[4]==\\'?\\')\\n        time[4]=\\'9\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]==\\'?\\')\\n            time[0]=\\'2\\';\\n            else{\\n                if(int(time[1]-\\'0\\')<=3)\\n                time[0]=\\'2\\';\\n                else\\n                time[0]=\\'1\\';\\n            }\\n        }\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'2\\')\\n            time[1]=\\'3\\';\\n            else\\n            time[1]=\\'9\\';\\n        }\\n        if(time[3]==\\'?\\')\\n        time[3]=\\'5\\';\\n        if(time[4]==\\'?\\')\\n        time[4]=\\'9\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559775,
                "title": "simple-approach-beats-98",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n        hhmm = [i for i in time.split(\\':\\')]\\n        hh,mm = [i for i in hhmm[0]],[i for i in hhmm[1]]\\n\\n        if hh[0] == \\'?\\' and hh[1] != \\'?\\':\\n            if hh[1] > \\'3\\':\\n                hh[0] = \\'1\\'\\n            else:\\n                hh[0] = \\'2\\'\\n        elif hh[1] == \\'?\\' and hh[0] != \\'?\\':\\n            if hh[0] > \\'1\\':\\n                hh[1] = \\'3\\'\\n            else:\\n                hh[1] = \\'9\\'\\n        elif hh[0] == \\'?\\' and hh[1] == \\'?\\':\\n            hh[0],hh[1] = \\'2\\',\\'3\\'\\n\\n        if mm[0] == \\'?\\' and mm[1] != \\'?\\':\\n            mm[0] = \\'5\\'\\n        elif mm[1] == \\'?\\' and mm[0] != \\'?\\':\\n            mm[1] = \\'9\\'\\n        elif mm[0] == \\'?\\' and mm[1] == \\'?\\':\\n            mm[0],mm[1] = \\'5\\',\\'9\\'\\n        \\n        hour = hh[0] + hh[1]\\n        minute = mm[0] + mm[1]\\n        latest_time = hour + \\':\\' + minute\\n        return latest_time\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n        hhmm = [i for i in time.split(\\':\\')]\\n        hh,mm = [i for i in hhmm[0]],[i for i in hhmm[1]]\\n\\n        if hh[0] == \\'?\\' and hh[1] != \\'?\\':\\n            if hh[1] > \\'3\\':\\n                hh[0] = \\'1\\'\\n            else:\\n                hh[0] = \\'2\\'\\n        elif hh[1] == \\'?\\' and hh[0] != \\'?\\':\\n            if hh[0] > \\'1\\':\\n                hh[1] = \\'3\\'\\n            else:\\n                hh[1] = \\'9\\'\\n        elif hh[0] == \\'?\\' and hh[1] == \\'?\\':\\n            hh[0],hh[1] = \\'2\\',\\'3\\'\\n\\n        if mm[0] == \\'?\\' and mm[1] != \\'?\\':\\n            mm[0] = \\'5\\'\\n        elif mm[1] == \\'?\\' and mm[0] != \\'?\\':\\n            mm[1] = \\'9\\'\\n        elif mm[0] == \\'?\\' and mm[1] == \\'?\\':\\n            mm[0],mm[1] = \\'5\\',\\'9\\'\\n        \\n        hour = hh[0] + hh[1]\\n        minute = mm[0] + mm[1]\\n        latest_time = hour + \\':\\' + minute\\n        return latest_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534825,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public String maximumTime(String time) {\\n\\n        if (time.equals(\"??:??\")) return \"23:59\";\\n\\n        char[] arr = time.toCharArray();\\n\\n        if (arr[0] == \\'?\\' && arr[1] == \\'?\\') {\\n            arr[0] = \\'2\\'; arr[1] = \\'3\\';\\n        }\\n\\n        if (arr[1] == \\'?\\') arr[1] = arr[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n\\n        if (arr[0] == \\'?\\') arr[0] = arr[1] <= \\'3\\' ? \\'2\\' : \\'1\\';\\n\\n        if (arr[4] == \\'?\\') arr[4] = \\'9\\';\\n\\n        if (arr[3] == \\'?\\') arr[3] = \\'5\\';\\n\\n        return new String(arr);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String maximumTime(String time) {\\n\\n        if (time.equals(\"??:??\")) return \"23:59\";\\n\\n        char[] arr = time.toCharArray();\\n\\n        if (arr[0] == \\'?\\' && arr[1] == \\'?\\') {\\n            arr[0] = \\'2\\'; arr[1] = \\'3\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3528626,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n\\n        if time[0] == \\'?\\':\\n            if time[1] not in \\'?0123\\':\\n                time[0] = \\'1\\'\\n            else:\\n                time[0] = \\'2\\'\\n        if time[1] == \\'?\\':\\n            if time[0] == \\'2\\':\\n                time[1] = \\'3\\'\\n            else:\\n                time[1] = \\'9\\'\\n        if time[3] == \\'?\\':\\n            time[3] = \\'5\\'\\n        if time[4] == \\'?\\':\\n            time[4] = \\'9\\'\\n        \\n        return \\'\\'.join(time)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = list(time)\\n\\n        if time[0] == \\'?\\':\\n            if time[1] not in \\'?0123\\':\\n                time[0] = \\'1\\'\\n            else:\\n                time[0] = \\'2\\'\\n        if time[1] == \\'?\\':\\n            if time[0] == \\'2\\':\\n                time[1] = \\'3\\'\\n            else:\\n                time[1] = \\'9\\'\\n        if time[3] == \\'?\\':\\n            time[3] = \\'5\\'\\n        if time[4] == \\'?\\':\\n            time[4] = \\'9\\'\\n        \\n        return \\'\\'.join(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513397,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String str = time.substring(0, 2);  //0?  //1?  //2?\\n        String str2 = time.substring(3);\\n\\n        if((str.charAt(0)!=\\'?\\' && str.charAt(0)!=\\'2\\') && str.charAt(1)==\\'?\\'){\\n            str = str.charAt(0) + \"9\";  //1? -> 19  //0? -> 09\\n        }\\n\\n        if((str.charAt(0)==\\'?\\' && str.charAt(1)!=\\'?\\') && Integer.parseInt(str.charAt(1)+\"\")>3){\\n            str = \"1\" + str.charAt(1);\\n        }\\n        if((str.charAt(0)==\\'?\\' && str.charAt(1)!=\\'?\\') && Integer.parseInt(str.charAt(1)+\"\")<4){\\n            str = \"2\" + str.charAt(1);\\n        } \\n        if(str.charAt(0)==\\'2\\' && str.charAt(1)==\\'?\\') str = \"2\" + \"3\";  //2? -> 23\\n\\n        if(str.equals(\"??\")) str = \"23\";    //??\\n        \\n        if(str2.charAt(0)!=\\'?\\' && str2.charAt(1)==\\'?\\'){\\n            str2 = str2.charAt(0) + \"9\";  //5? -> 59  //0? -> 09\\n        }\\n\\n        if(str2.charAt(0)==\\'?\\' && str2.charAt(1) != \\'?\\'){  //?9 -> 59\\n            str2 = \"5\" + str2.charAt(1);\\n        }\\n\\n        if(str2.equals(\"??\")) str2 = \"59\";\\n\\n        return str + \":\" + str2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String str = time.substring(0, 2);  //0?  //1?  //2?\\n        String str2 = time.substring(3);\\n\\n        if((str.charAt(0)!=\\'?\\' && str.charAt(0)!=\\'2\\') && str.charAt(1)==\\'?\\'){\\n            str = str.charAt(0) + \"9\";  //1? -> 19  //0? -> 09\\n        }\\n\\n        if((str.charAt(0)==\\'?\\' && str.charAt(1)!=\\'?\\') && Integer.parseInt(str.charAt(1)+\"\")>3){\\n            str = \"1\" + str.charAt(1);\\n        }\\n        if((str.charAt(0)==\\'?\\' && str.charAt(1)!=\\'?\\') && Integer.parseInt(str.charAt(1)+\"\")<4){\\n            str = \"2\" + str.charAt(1);\\n        } \\n        if(str.charAt(0)==\\'2\\' && str.charAt(1)==\\'?\\') str = \"2\" + \"3\";  //2? -> 23\\n\\n        if(str.equals(\"??\")) str = \"23\";    //??\\n        \\n        if(str2.charAt(0)!=\\'?\\' && str2.charAt(1)==\\'?\\'){\\n            str2 = str2.charAt(0) + \"9\";  //5? -> 59  //0? -> 09\\n        }\\n\\n        if(str2.charAt(0)==\\'?\\' && str2.charAt(1) != \\'?\\'){  //?9 -> 59\\n            str2 = \"5\" + str2.charAt(1);\\n        }\\n\\n        if(str2.equals(\"??\")) str2 = \"59\";\\n\\n        return str + \":\" + str2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504523,
                "title": "99-99-if-if-if",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} time\\n * @return {string}\\n */\\nvar maximumTime = function(time) {\\n    const arr = [...time]\\n    if (arr[0] === \\'?\\' && +arr[1] >= 4) arr[0] = \\'1\\'\\n    if (arr[0] === \\'?\\') arr[0] = \\'2\\'\\n    if (arr[1] === \\'?\\' && arr[0] === \\'2\\') arr[1] = \\'3\\'\\n    if (arr[1] === \\'?\\' && (arr[0] === \\'1\\' || arr[0] === \\'0\\')) arr[1] = \\'9\\'\\n    if (arr[3] === \\'?\\') arr[3] = \\'5\\'\\n    if (arr[4] === \\'?\\') arr[4] = \\'9\\'\\n\\n    return arr.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} time\\n * @return {string}\\n */\\nvar maximumTime = function(time) {\\n    const arr = [...time]\\n    if (arr[0] === \\'?\\' && +arr[1] >= 4) arr[0] = \\'1\\'\\n    if (arr[0] === \\'?\\') arr[0] = \\'2\\'\\n    if (arr[1] === \\'?\\' && arr[0] === \\'2\\') arr[1] = \\'3\\'\\n    if (arr[1] === \\'?\\' && (arr[0] === \\'1\\' || arr[0] === \\'0\\')) arr[1] = \\'9\\'\\n    if (arr[3] === \\'?\\') arr[3] = \\'5\\'\\n    if (arr[4] === \\'?\\') arr[4] = \\'9\\'\\n\\n    return arr.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497010,
                "title": "most-most-simple-solution-in-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        int n=time.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(time[i]==\\'?\\' )\\n            { \\n                if(i==0 && time[i+1]==\\'?\\')\\n                {\\n                    time[i]=\\'2\\';\\n                    time[i+1]=\\'3\\';\\n                    i=i+1;\\n                    continue;\\n                }\\n                if(i==0 && time[i+1]<=\\'3\\')time[i]=\\'2\\';\\n                else if(i==0 && time[i+1]>\\'3\\')time[i]=\\'1\\';\\n                else if(i==1 && time[i-1]==\\'0\\')\\n                {\\n                    time[i]=\\'9\\';\\n                }\\n                else if(i==1 && time[i-1]==\\'1\\')time[i]=\\'9\\';\\n                else if(i==1 && time[i-1]==\\'2\\')time[i]=\\'3\\';\\n                else if(i==3)time[i]=\\'5\\';\\n                else time[i]=\\'9\\';\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        int n=time.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(time[i]==\\'?\\' )\\n            { \\n                if(i==0 && time[i+1]==\\'?\\')\\n                {\\n                    time[i]=\\'2\\';\\n                    time[i+1]=\\'3\\';\\n                    i=i+1;\\n                    continue;\\n                }\\n                if(i==0 && time[i+1]<=\\'3\\')time[i]=\\'2\\';\\n                else if(i==0 && time[i+1]>\\'3\\')time[i]=\\'1\\';\\n                else if(i==1 && time[i-1]==\\'0\\')\\n                {\\n                    time[i]=\\'9\\';\\n                }\\n                else if(i==1 && time[i-1]==\\'1\\')time[i]=\\'9\\';\\n                else if(i==1 && time[i-1]==\\'2\\')time[i]=\\'3\\';\\n                else if(i==3)time[i]=\\'5\\';\\n                else time[i]=\\'9\\';\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494089,
                "title": "c-easy-logical-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        string ans=\"\";\\n       \\n        for(int i=0;i<time.length();i++){\\n           \\n            if(time[i]==\\'?\\'){\\n                if(i==0){\\n                    if(time[i+1]==\\'0\\' || time[i+1]==\\'1\\' || time[i+1]==\\'2\\' || time[i+1]==\\'3\\' || time[i+1]==\\'?\\'){\\n                        ans+=\\'2\\';\\n                    }\\n                   \\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n                if(i==3){\\n                    ans+=\\'5\\';\\n                }\\n\\n                if(i==1){\\n                    if(time[i-1]==\\'0\\' || time[i-1]==\\'1\\'){\\n                        ans+=\\'9\\';\\n                    }\\n                    else{\\n                        ans+=\\'3\\';\\n                    }\\n                }\\n                if(i==4){\\n                    ans+=\\'9\\';\\n                }\\n\\n            }\\n            else{\\n                ans+=time[i];\\n            }\\n        \\n       \\n    }\\n    \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        string ans=\"\";\\n       \\n        for(int i=0;i<time.length();i++){\\n           \\n            if(time[i]==\\'?\\'){\\n                if(i==0){\\n                    if(time[i+1]==\\'0\\' || time[i+1]==\\'1\\' || time[i+1]==\\'2\\' || time[i+1]==\\'3\\' || time[i+1]==\\'?\\'){\\n                        ans+=\\'2\\';\\n                    }\\n                   \\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n                if(i==3){\\n                    ans+=\\'5\\';\\n                }\\n\\n                if(i==1){\\n                    if(time[i-1]==\\'0\\' || time[i-1]==\\'1\\'){\\n                        ans+=\\'9\\';\\n                    }\\n                    else{\\n                        ans+=\\'3\\';\\n                    }\\n                }\\n                if(i==4){\\n                    ans+=\\'9\\';\\n                }\\n\\n            }\\n            else{\\n                ans+=time[i];\\n            }\\n        \\n       \\n    }\\n    \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470354,
                "title": "math-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        timef = \\'\\'\\n        if time[0]==\\'?\\' and time[1] in [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'?\\']:\\n            timef += \\'2\\'\\n        elif time[0]==\\'?\\' and time[1] not in [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'?\\']:\\n            timef += \\'1\\'\\n        else:\\n            timef += time[0]\\n        if time[1] == \\'?\\' and time[0] != \\'2\\' and time[0] != \\'?\\':\\n            timef += \\'9\\'\\n        elif time[1] == \\'?\\' and (time[0] == \\'2\\' or time[0] == \\'?\\'):\\n            timef += \\'3\\'\\n        else:\\n            timef += time[1]\\n        if time[3] == \\'?\\':\\n            timef += \\':\\'+\\'5\\'\\n        else:\\n            timef += \\':\\' + time[3]\\n        if time[4] == \\'?\\':\\n            timef += \\'9\\'\\n        else:\\n            timef += time[4]\\n        return timef\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        timef = \\'\\'\\n        if time[0]==\\'?\\' and time[1] in [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'?\\']:\\n            timef += \\'2\\'\\n        elif time[0]==\\'?\\' and time[1] not in [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'?\\']:\\n            timef += \\'1\\'\\n        else:\\n            timef += time[0]\\n        if time[1] == \\'?\\' and time[0] != \\'2\\' and time[0] != \\'?\\':\\n            timef += \\'9\\'\\n        elif time[1] == \\'?\\' and (time[0] == \\'2\\' or time[0] == \\'?\\'):\\n            timef += \\'3\\'\\n        else:\\n            timef += time[1]\\n        if time[3] == \\'?\\':\\n            timef += \\':\\'+\\'5\\'\\n        else:\\n            timef += \\':\\' + time[3]\\n        if time[4] == \\'?\\':\\n            timef += \\'9\\'\\n        else:\\n            timef += time[4]\\n        return timef\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441438,
                "title": "long-code-but-beats-99-6-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        matchtime = {\\'1\\':\\'9\\',\\'2\\':\\'3\\',\\'0\\':\\'9\\'}\\n        result = \\'\\'\\n        if time[0] == \"?\" and time[1] == \\'?\\':\\n            result +=  \"23\"\\n        else:\\n            for i in range(0,2):\\n                if time[i] != \"?\":\\n                    result += time[i]\\n                else:\\n                    if i == 0:\\n                        if int(time[1]) <= 3:\\n                            result += \\'2\\'\\n                        else:\\n                            result += \\'1\\'\\n                    else:\\n                        result += matchtime[time[0]]\\n        result += \\':\\'\\n        if time[3] == \"?\" and time[4] == \\'?\\':\\n            result +=  \"59\"\\n        else:\\n            for i in range(3,len(time)):\\n                if time[i] != \"?\":\\n                    result += time[i]\\n                else:\\n                    if i == 3:\\n                        result += \\'5\\'\\n                    else:\\n                        result += \\'9\\'\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        matchtime = {\\'1\\':\\'9\\',\\'2\\':\\'3\\',\\'0\\':\\'9\\'}\\n        result = \\'\\'\\n        if time[0] == \"?\" and time[1] == \\'?\\':\\n            result +=  \"23\"\\n        else:\\n            for i in range(0,2):\\n                if time[i] != \"?\":\\n                    result += time[i]\\n                else:\\n                    if i == 0:\\n                        if int(time[1]) <= 3:\\n                            result += \\'2\\'\\n                        else:\\n                            result += \\'1\\'\\n                    else:\\n                        result += matchtime[time[0]]\\n        result += \\':\\'\\n        if time[3] == \"?\" and time[4] == \\'?\\':\\n            result +=  \"59\"\\n        else:\\n            for i in range(3,len(time)):\\n                if time[i] != \"?\":\\n                    result += time[i]\\n                else:\\n                    if i == 3:\\n                        result += \\'5\\'\\n                    else:\\n                        result += \\'9\\'\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424834,
                "title": "using-nested-if-else",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\ne.g. $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        if(time.charAt(0) == \\'?\\'){\\n            if(time.charAt(1) < \\'4\\' || time.charAt(1) == \\'?\\')\\n                sb.append(\"2\");\\n            else\\n                sb.append(\"1\");\\n        }\\n        else\\n            sb.append(time.charAt(0));\\n        if((time.charAt(0) == \\'1\\' || time.charAt(0) == \\'0\\') && time.charAt(1) == \\'?\\')\\n            sb.append(\"9\");\\n        else if((time.charAt(0) == \\'2\\' || time.charAt(0) == \\'?\\') && time.charAt(1) == \\'?\\')\\n            sb.append(\"3\");\\n        else\\n            sb.append(time.charAt(1));\\n        sb.append(\":\");\\n\\n        if(time.charAt(3) == \\'?\\')\\n            sb.append(\"5\");\\n        else\\n            sb.append(time.charAt(3));\\n        if(time.charAt(4) == \\'?\\')\\n            sb.append(\"9\");\\n        else\\n            sb.append(time.charAt(4));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        if(time.charAt(0) == \\'?\\'){\\n            if(time.charAt(1) < \\'4\\' || time.charAt(1) == \\'?\\')\\n                sb.append(\"2\");\\n            else\\n                sb.append(\"1\");\\n        }\\n        else\\n            sb.append(time.charAt(0));\\n        if((time.charAt(0) == \\'1\\' || time.charAt(0) == \\'0\\') && time.charAt(1) == \\'?\\')\\n            sb.append(\"9\");\\n        else if((time.charAt(0) == \\'2\\' || time.charAt(0) == \\'?\\') && time.charAt(1) == \\'?\\')\\n            sb.append(\"3\");\\n        else\\n            sb.append(time.charAt(1));\\n        sb.append(\":\");\\n\\n        if(time.charAt(3) == \\'?\\')\\n            sb.append(\"5\");\\n        else\\n            sb.append(time.charAt(3));\\n        if(time.charAt(4) == \\'?\\')\\n            sb.append(\"9\");\\n        else\\n            sb.append(time.charAt(4));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424097,
                "title": "python-explained-runtime-11-ms-beats-96-43",
                "content": "![Screenshot 2023-04-16 9.39.50 PM.png](https://assets.leetcode.com/users/images/a4b0c875-a888-4507-9dc3-66ba61cc103c_1681661524.0048146.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # If no \\'?\\' in time str.\\n        if \\'?\\' not in time:\\n            return time\\n\\n        # Splitting hour & minute, h & m respectively.\\n        h, m = time.split(\\':\\')\\n\\n        # Empty str to append new time to.\\n        a = b = \\'\\'\\n\\n        # \\'?\\' in hour.\\n        if \\'?\\' in h:\\n\\n            # \\'?3\\' -> hour like this.\\n            if \\'?\\' in h[0] and \\'?\\' not in h[1]:\\n\\n                # If second digit is less than 4.\\n                if h[1] < \\'4\\':\\n\\n                    # First digit is \\'2\\'.\\n                    a += (\\'2\\' + h[1])\\n\\n                # If second digit is greater than or equal to 4.\\n                elif h[1] >= \\'4\\':\\n\\n                    # First digit is \\'1\\'.\\n                    a += (\\'1\\' + h[1])\\n\\n            # \\'3?\\' -> hour like this.\\n            elif \\'?\\' in h[1] and \\'?\\' not in h[0]:\\n\\n                # First digit is \\'2\\'.\\n                if h[0] == \\'2\\':\\n\\n                    # Second digit is \\'3\\'\\n                    a += (h[0] + \\'3\\')\\n\\n                # First digit is less than 2.\\n                elif h[0] in [\\'0\\', \\'1\\']:\\n\\n                    # Second digit is \\'9\\'.\\n                    a += (h[0] + \\'9\\')\\n\\n            # \\'??\\' -> hour like this.\\n            else:\\n\\n                # New hour.\\n                a += (\\'23\\')\\n\\n        # \\'?\\' in minute.\\n        if \\'?\\' in m:\\n\\n            # \\'?3\\' -> minute like this.\\n            if \\'?\\' in m[0] and \\'?\\' not in m[1]:\\n\\n                # First digit is \\'5\\'.\\n                b += (\\'5\\' + m[1])\\n\\n            # \\'3?\\' -> minute like this.\\n            elif \\'?\\' in m[1] and \\'?\\' not in m[0]:\\n\\n                # Second digit is \\'9\\'.\\n                b += (m[0] + \\'9\\')\\n\\n            # \\'??\\' -> minute like this.\\n            else:\\n\\n                # New minute.\\n                b += (\\'59\\')\\n\\n        # If nothing in a.\\n        if a == \\'\\':\\n\\n            # Returning h as it is with b.\\n            return h + \\':\\' + b\\n\\n        # If nothing in b.\\n        elif b == \\'\\':\\n\\n            # Returning m as it is with a.\\n            return a + \\':\\' + m\\n\\n        # If a and b.\\n        else:\\n\\n            # Returning a & b\\n            return a + \\':\\' + b\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "![Screenshot 2023-04-16 9.39.50 PM.png](https://assets.leetcode.com/users/images/a4b0c875-a888-4507-9dc3-66ba61cc103c_1681661524.0048146.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTime(self, time):\\n        \"\"\"\\n        :type time: str\\n        :rtype: str\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # If no \\'?\\' in time str.\\n        if \\'?\\' not in time:\\n            return time\\n\\n        # Splitting hour & minute, h & m respectively.\\n        h, m = time.split(\\':\\')\\n\\n        # Empty str to append new time to.\\n        a = b = \\'\\'\\n\\n        # \\'?\\' in hour.\\n        if \\'?\\' in h:\\n\\n            # \\'?3\\' -> hour like this.\\n            if \\'?\\' in h[0] and \\'?\\' not in h[1]:\\n\\n                # If second digit is less than 4.\\n                if h[1] < \\'4\\':\\n\\n                    # First digit is \\'2\\'.\\n                    a += (\\'2\\' + h[1])\\n\\n                # If second digit is greater than or equal to 4.\\n                elif h[1] >= \\'4\\':\\n\\n                    # First digit is \\'1\\'.\\n                    a += (\\'1\\' + h[1])\\n\\n            # \\'3?\\' -> hour like this.\\n            elif \\'?\\' in h[1] and \\'?\\' not in h[0]:\\n\\n                # First digit is \\'2\\'.\\n                if h[0] == \\'2\\':\\n\\n                    # Second digit is \\'3\\'\\n                    a += (h[0] + \\'3\\')\\n\\n                # First digit is less than 2.\\n                elif h[0] in [\\'0\\', \\'1\\']:\\n\\n                    # Second digit is \\'9\\'.\\n                    a += (h[0] + \\'9\\')\\n\\n            # \\'??\\' -> hour like this.\\n            else:\\n\\n                # New hour.\\n                a += (\\'23\\')\\n\\n        # \\'?\\' in minute.\\n        if \\'?\\' in m:\\n\\n            # \\'?3\\' -> minute like this.\\n            if \\'?\\' in m[0] and \\'?\\' not in m[1]:\\n\\n                # First digit is \\'5\\'.\\n                b += (\\'5\\' + m[1])\\n\\n            # \\'3?\\' -> minute like this.\\n            elif \\'?\\' in m[1] and \\'?\\' not in m[0]:\\n\\n                # Second digit is \\'9\\'.\\n                b += (m[0] + \\'9\\')\\n\\n            # \\'??\\' -> minute like this.\\n            else:\\n\\n                # New minute.\\n                b += (\\'59\\')\\n\\n        # If nothing in a.\\n        if a == \\'\\':\\n\\n            # Returning h as it is with b.\\n            return h + \\':\\' + b\\n\\n        # If nothing in b.\\n        elif b == \\'\\':\\n\\n            # Returning m as it is with a.\\n            return a + \\':\\' + m\\n\\n        # If a and b.\\n        else:\\n\\n            # Returning a & b\\n            return a + \\':\\' + b\\n",
                "codeTag": "Java"
            },
            {
                "id": 3421634,
                "title": "easy-solution-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]-\\'0\\' > 3 and time[1]!=\\'?\\') time[0]=\\'1\\';\\n            else time[0]=\\'2\\';\\n        } \\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'0\\' or time[0]==\\'1\\') time[1]=\\'9\\';\\n            else time[1]=\\'3\\';\\n        }\\n        if(time[3]==\\'?\\') time[3]=\\'5\\';\\n        if(time[4]==\\'?\\') time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0]==\\'?\\'){\\n            if(time[1]-\\'0\\' > 3 and time[1]!=\\'?\\') time[0]=\\'1\\';\\n            else time[0]=\\'2\\';\\n        } \\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'0\\' or time[0]==\\'1\\') time[1]=\\'9\\';\\n            else time[1]=\\'3\\';\\n        }\\n        if(time[3]==\\'?\\') time[3]=\\'5\\';\\n        if(time[4]==\\'?\\') time[4]=\\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415568,
                "title": "c-constant-space-and-time-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIt\\'s so easy. Just read the code.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        unsigned short int first{};\\n\\n        if (time[0] == \\'?\\' && time[1] == \\'?\\') {\\n            time[0] = \\'2\\';\\n        }\\n        else if (time[0] == \\'?\\' && time[1] != \\'?\\'){\\n            first = time[1] - \\'0\\';\\n            time[0] = first > 3 ? \\'1\\' : \\'2\\';\\n        }\\n\\n        first = time[0] - \\'0\\';\\n\\n        if (time[1] == \\'?\\')\\n            time[1] = first > 1 ? \\'3\\' : \\'9\\';\\n        \\n        if (time[3] == \\'?\\')\\n            time[3] = \\'5\\';\\n\\n        if (time[4] == \\'?\\')\\n            time[4] =\\'9\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        unsigned short int first{};\\n\\n        if (time[0] == \\'?\\' && time[1] == \\'?\\') {\\n            time[0] = \\'2\\';\\n        }\\n        else if (time[0] == \\'?\\' && time[1] != \\'?\\'){\\n            first = time[1] - \\'0\\';\\n            time[0] = first > 3 ? \\'1\\' : \\'2\\';\\n        }\\n\\n        first = time[0] - \\'0\\';\\n\\n        if (time[1] == \\'?\\')\\n            time[1] = first > 1 ? \\'3\\' : \\'9\\';\\n        \\n        if (time[3] == \\'?\\')\\n            time[3] = \\'5\\';\\n\\n        if (time[4] == \\'?\\')\\n            time[4] =\\'9\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406222,
                "title": "no-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        new_time = []\\n        if time[0] == \\'?\\':\\n            if time[1] != \\'?\\' and int(time[1]) > 3:\\n                new_time.append(\\'1\\')\\n            else:\\n                new_time.append(\\'2\\')\\n        else:\\n            new_time.append(time[0])\\n        if time[1] == \\'?\\':\\n            if new_time[0] == \\'2\\':\\n                new_time.append(\\'3\\')\\n            else:\\n                new_time.append(\\'9\\')\\n        else:\\n            new_time.append(time[1])\\n        new_time.append(\\':\\')\\n        if time[3] == \\'?\\':\\n            new_time.append(\\'5\\')\\n        else:\\n            new_time.append(time[3])\\n        if time[4] == \\'?\\':\\n            new_time.append(\\'9\\')\\n        else:\\n            new_time.append(time[4])\\n        return \\'\\'.join(new_time)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        new_time = []\\n        if time[0] == \\'?\\':\\n            if time[1] != \\'?\\' and int(time[1]) > 3:\\n                new_time.append(\\'1\\')\\n            else:\\n                new_time.append(\\'2\\')\\n        else:\\n            new_time.append(time[0])\\n        if time[1] == \\'?\\':\\n            if new_time[0] == \\'2\\':\\n                new_time.append(\\'3\\')\\n            else:\\n                new_time.append(\\'9\\')\\n        else:\\n            new_time.append(time[1])\\n        new_time.append(\\':\\')\\n        if time[3] == \\'?\\':\\n            new_time.append(\\'5\\')\\n        else:\\n            new_time.append(time[3])\\n        if time[4] == \\'?\\':\\n            new_time.append(\\'9\\')\\n        else:\\n            new_time.append(time[4])\\n        return \\'\\'.join(new_time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379867,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n        string res = \"\";\\n        for(int i = 0; i < time.Length;i++){\\n            char c = time[i];\\n            if(time[i] == \\'?\\' && i > 2) c = (i == 3)?\\'5\\':\\'9\\';\\n            else if(time[i] == \\'?\\' && i == 0 ) c = \\'2\\';\\n            else if(time[i] == \\'?\\') c = (res[i - 1] == \\'2\\')?\\'3\\':\\'9\\';\\n            res += c;\\n        }\\n        if(Int32.Parse(res.Substring(0,2)) > 23) res = \"1\"+res.Substring(1);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MaximumTime(string time) {\\n        string res = \"\";\\n        for(int i = 0; i < time.Length;i++){\\n            char c = time[i];\\n            if(time[i] == \\'?\\' && i > 2) c = (i == 3)?\\'5\\':\\'9\\';\\n            else if(time[i] == \\'?\\' && i == 0 ) c = \\'2\\';\\n            else if(time[i] == \\'?\\') c = (res[i - 1] == \\'2\\')?\\'3\\':\\'9\\';\\n            res += c;\\n        }\\n        if(Int32.Parse(res.Substring(0,2)) > 23) res = \"1\"+res.Substring(1);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374625,
                "title": "c-soln-100-faster-soln-overall-complexity-is-o-1-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n       if(time[0] == \\'?\\' && (time[1] <= \\'3\\' || time[1] == \\'?\\'))\\n            time[0] = \\'2\\';\\n       else if(time[0] == \\'?\\' && (time[1] > \\'3\\'))\\n            time[0] = \\'1\\'; \\n       if(time[1] == \\'?\\' && (time[0] >= \\'0\\' && time[0] <= \\'1\\'))\\n           time[1] = \\'9\\';\\n       else if(time[1] == \\'?\\' && (time[0] > \\'1\\'))\\n        time[1] = \\'3\\';\\n       if(time[3] == \\'?\\')\\n           time[3] = \\'5\\';\\n       if(time[4] == \\'?\\' )\\n            time[4] = \\'9\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n       if(time[0] == \\'?\\' && (time[1] <= \\'3\\' || time[1] == \\'?\\'))\\n            time[0] = \\'2\\';\\n       else if(time[0] == \\'?\\' && (time[1] > \\'3\\'))\\n            time[0] = \\'1\\'; \\n       if(time[1] == \\'?\\' && (time[0] >= \\'0\\' && time[0] <= \\'1\\'))\\n           time[1] = \\'9\\';\\n       else if(time[1] == \\'?\\' && (time[0] > \\'1\\'))\\n        time[1] = \\'3\\';\\n       if(time[3] == \\'?\\')\\n           time[3] = \\'5\\';\\n       if(time[4] == \\'?\\' )\\n            time[4] = \\'9\\';\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355274,
                "title": "long-and-understandble-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = time.split(\\':\\')\\n        res = []\\n        if time[0][0] == \\'?\\' and  time[0][1] == \\'?\\':\\n            res.append(\\'23\\')\\n        else:\\n            pass\\n\\n        if time[0][0].isdigit() and time[0][1].isdigit():\\n            res.append(time[0])\\n        else:\\n            if time[0][0].isdigit():\\n                if  int(time[0][0]) == 2:\\n                    res.append(\\'23\\')\\n\\n                if  int(time[0][0]) == 1:\\n                    res.append(\\'19\\')\\n\\n                if  int(time[0][0]) == 0:\\n                    res.append(\\'09\\')\\n\\n            if time[0][1].isdigit():\\n                if  int(time[0][1]) == 0:\\n                    res.append(\\'20\\')\\n\\n                if  int(time[0][1]) == 1:\\n                    res.append(\\'21\\')\\n\\n                if  int(time[0][1]) == 2:\\n                    res.append(\\'22\\')\\n\\n                if  int(time[0][1]) == 3:\\n                    res.append(\\'23\\')\\n\\n                if int(time[0][1]) == 4:\\n                    res.append(\\'14\\')\\n\\n                if int(time[0][1]) == 5:\\n                    res.append(\\'15\\')\\n\\n                if int(time[0][1]) == 6:\\n                    res.append(\\'16\\')\\n\\n                if int(time[0][1]) == 7:\\n                    res.append(\\'17\\')\\n\\n                if int(time[0][1]) == 8:\\n                    res.append(\\'18\\')\\n\\n                if int(time[0][1]) == 9:\\n                    res.append(\\'19\\')\\n\\n\\n        if time[1][0]  == \\'?\\' and time[1][1] == \\'?\\':\\n            res.append(\\'59\\')\\n\\n        if time[1][0].isdigit() and time[1][1].isdigit():\\n            res.append(time[1])\\n        else:\\n            if time[1][0].isdigit():\\n\\n                if int(time[1][0]) == 0:\\n                    res.append(\\'09\\')\\n\\n                if int(time[1][0]) == 1:\\n                    res.append(\\'19\\')\\n\\n                if int(time[1][0]) == 2:\\n                    res.append(\\'29\\')\\n\\n                if int(time[1][0]) == 3:\\n                    res.append(\\'39\\')\\n\\n                if int(time[1][0]) == 4:\\n                    res.append(\\'49\\')\\n\\n                if int(time[1][0]) == 5:\\n                    res.append(\\'59\\')\\n\\n            if time[1][1].isdigit():\\n                if int(time[1][1]) == 0:\\n                    res.append(\\'50\\')\\n\\n                if int(time[1][1]) == 1:\\n                    res.append(\\'51\\')\\n\\n                if int(time[1][1]) == 2:\\n                    res.append(\\'52\\')\\n\\n                if int(time[1][1]) == 3:\\n                    res.append(\\'53\\')\\n\\n                if int(time[1][1]) == 4:\\n                    res.append(\\'54\\')\\n\\n                if int(time[1][1]) == 5:\\n                    res.append(\\'55\\')\\n                if int(time[1][1]) == 6:\\n                    res.append(\\'56\\')\\n                if int(time[1][1]) == 7:\\n                    res.append(\\'57\\')\\n                if int(time[1][1]) == 8:\\n                    res.append(\\'58\\')\\n                if int(time[1][1]) == 9:\\n                    res.append(\\'59\\')\\n\\n\\n\\n\\n        return f\\'{res[0]}:{res[1]}\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        time = time.split(\\':\\')\\n        res = []\\n        if time[0][0] == \\'?\\' and  time[0][1] == \\'?\\':\\n            res.append(\\'23\\')\\n        else:\\n            pass\\n\\n        if time[0][0].isdigit() and time[0][1].isdigit():\\n            res.append(time[0])\\n        else:\\n            if time[0][0].isdigit():\\n                if  int(time[0][0]) == 2:\\n                    res.append(\\'23\\')\\n\\n                if  int(time[0][0]) == 1:\\n                    res.append(\\'19\\')\\n\\n                if  int(time[0][0]) == 0:\\n                    res.append(\\'09\\')\\n\\n            if time[0][1].isdigit():\\n                if  int(time[0][1]) == 0:\\n                    res.append(\\'20\\')\\n\\n                if  int(time[0][1]) == 1:\\n                    res.append(\\'21\\')\\n\\n                if  int(time[0][1]) == 2:\\n                    res.append(\\'22\\')\\n\\n                if  int(time[0][1]) == 3:\\n                    res.append(\\'23\\')\\n\\n                if int(time[0][1]) == 4:\\n                    res.append(\\'14\\')\\n\\n                if int(time[0][1]) == 5:\\n                    res.append(\\'15\\')\\n\\n                if int(time[0][1]) == 6:\\n                    res.append(\\'16\\')\\n\\n                if int(time[0][1]) == 7:\\n                    res.append(\\'17\\')\\n\\n                if int(time[0][1]) == 8:\\n                    res.append(\\'18\\')\\n\\n                if int(time[0][1]) == 9:\\n                    res.append(\\'19\\')\\n\\n\\n        if time[1][0]  == \\'?\\' and time[1][1] == \\'?\\':\\n            res.append(\\'59\\')\\n\\n        if time[1][0].isdigit() and time[1][1].isdigit():\\n            res.append(time[1])\\n        else:\\n            if time[1][0].isdigit():\\n\\n                if int(time[1][0]) == 0:\\n                    res.append(\\'09\\')\\n\\n                if int(time[1][0]) == 1:\\n                    res.append(\\'19\\')\\n\\n                if int(time[1][0]) == 2:\\n                    res.append(\\'29\\')\\n\\n                if int(time[1][0]) == 3:\\n                    res.append(\\'39\\')\\n\\n                if int(time[1][0]) == 4:\\n                    res.append(\\'49\\')\\n\\n                if int(time[1][0]) == 5:\\n                    res.append(\\'59\\')\\n\\n            if time[1][1].isdigit():\\n                if int(time[1][1]) == 0:\\n                    res.append(\\'50\\')\\n\\n                if int(time[1][1]) == 1:\\n                    res.append(\\'51\\')\\n\\n                if int(time[1][1]) == 2:\\n                    res.append(\\'52\\')\\n\\n                if int(time[1][1]) == 3:\\n                    res.append(\\'53\\')\\n\\n                if int(time[1][1]) == 4:\\n                    res.append(\\'54\\')\\n\\n                if int(time[1][1]) == 5:\\n                    res.append(\\'55\\')\\n                if int(time[1][1]) == 6:\\n                    res.append(\\'56\\')\\n                if int(time[1][1]) == 7:\\n                    res.append(\\'57\\')\\n                if int(time[1][1]) == 8:\\n                    res.append(\\'58\\')\\n                if int(time[1][1]) == 9:\\n                    res.append(\\'59\\')\\n\\n\\n\\n\\n        return f\\'{res[0]}:{res[1]}\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349991,
                "title": "simple-java-solution-kavinprashad-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String s) {\\n        String ans = \"\";\\n\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            \\n            if(i==0 && c==\\'?\\'){\\n                    if(s.charAt(i+1)<\\'4\\'||s.charAt(i+1)==\\'?\\') ans += 2;\\n                    else ans += 1;\\n            }\\n            else if(i==1 && c==\\'?\\'){\\n                    if(s.charAt(i-1)!=\\'2\\'&&s.charAt(i-1)!=\\'?\\'){\\n                        ans += 9;\\n                    }\\n                    else ans += 3;\\n            }\\n            else if(i==3 && c==\\'?\\'){\\n                ans += 5;\\n            }\\n            else if(i==4 && c==\\'?\\'){\\n                ans += 9;\\n            }\\n            else{\\n                ans += c;\\n            }\\n        }\\n            \\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String s) {\\n        String ans = \"\";\\n\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            \\n            if(i==0 && c==\\'?\\'){\\n                    if(s.charAt(i+1)<\\'4\\'||s.charAt(i+1)==\\'?\\') ans += 2;\\n                    else ans += 1;\\n            }\\n            else if(i==1 && c==\\'?\\'){\\n                    if(s.charAt(i-1)!=\\'2\\'&&s.charAt(i-1)!=\\'?\\'){\\n                        ans += 9;\\n                    }\\n                    else ans += 3;\\n            }\\n            else if(i==3 && c==\\'?\\'){\\n                ans += 5;\\n            }\\n            else if(i==4 && c==\\'?\\'){\\n                ans += 9;\\n            }\\n            else{\\n                ans += c;\\n            }\\n        }\\n            \\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329181,
                "title": "my-easy-if-else-based-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n\\n        if(time[0]==\\'?\\') {\\n            if(time[1]>51 && time[1]<= 57) time[0] = \\'1\\';\\n            else time[0] = \\'2\\';\\n        }\\n\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'2\\') time[1] = \\'3\\';\\n            else time[1] = \\'9\\';\\n        } \\n        if(time[3]==\\'?\\') time[3] = \\'5\\';\\n        if(time[4]==\\'?\\') time[4] = \\'9\\';\\n\\n        \\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n\\n        if(time[0]==\\'?\\') {\\n            if(time[1]>51 && time[1]<= 57) time[0] = \\'1\\';\\n            else time[0] = \\'2\\';\\n        }\\n\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'2\\') time[1] = \\'3\\';\\n            else time[1] = \\'9\\';\\n        } \\n        if(time[3]==\\'?\\') time[3] = \\'5\\';\\n        if(time[4]==\\'?\\') time[4] = \\'9\\';\\n\\n        \\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329179,
                "title": "my-easy-if-else-based-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n\\n        if(time[0]==\\'?\\') {\\n            if(time[1]>51 && time[1]<= 57) time[0] = \\'1\\';\\n            else time[0] = \\'2\\';\\n        }\\n\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'2\\') time[1] = \\'3\\';\\n            else time[1] = \\'9\\';\\n        } \\n        if(time[3]==\\'?\\') time[3] = \\'5\\';\\n        if(time[4]==\\'?\\') time[4] = \\'9\\';\\n\\n        \\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n\\n        if(time[0]==\\'?\\') {\\n            if(time[1]>51 && time[1]<= 57) time[0] = \\'1\\';\\n            else time[0] = \\'2\\';\\n        }\\n\\n        if(time[1]==\\'?\\'){\\n            if(time[0]==\\'2\\') time[1] = \\'3\\';\\n            else time[1] = \\'9\\';\\n        } \\n        if(time[3]==\\'?\\') time[3] = \\'5\\';\\n        if(time[4]==\\'?\\') time[4] = \\'9\\';\\n\\n        \\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327850,
                "title": "runtime-6-ms-beats-25-79-memory-41-5-mb-beats-15-26",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String[] arr = new String[4];\\n        arr[0] = String.valueOf(time.charAt(0));\\n        arr[1] = String.valueOf(time.charAt(1));\\n        arr[2] = String.valueOf(time.charAt(3));\\n        arr[3] = String.valueOf(time.charAt(4));\\n\\n        if (arr[0].equals(\"?\")) {\\n            if (arr[1].equals(\"?\")) {\\n                arr[0] = \"2\";\\n                arr[1] = \"3\";\\n            } else if (arr[1].equals(\"0\") || arr[1].equals(\"1\") || arr[1].equals(\"2\") || arr[1].equals(\"3\")) {\\n                arr[0] = \"2\";\\n            } else {\\n                arr[0] = \"1\";\\n            }\\n        }\\n\\n        if (arr[1].equals(\"?\")) {\\n            if (arr[0].equals(\"0\") || arr[0].equals(\"1\")) {\\n                arr[1] = \"9\";\\n            } else if (arr[0].equals(\"2\")) {\\n                arr[1] = \"3\";\\n            }\\n        }\\n\\n        if (arr[2].equals(\"?\")) {\\n            arr[2] = \"5\";\\n        }\\n\\n        if (arr[3].equals(\"?\")) {\\n            arr[3] = \"9\";\\n        }\\n\\n        return arr[0] + arr[1] + \":\" + arr[2] + arr[3];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String[] arr = new String[4];\\n        arr[0] = String.valueOf(time.charAt(0));\\n        arr[1] = String.valueOf(time.charAt(1));\\n        arr[2] = String.valueOf(time.charAt(3));\\n        arr[3] = String.valueOf(time.charAt(4));\\n\\n        if (arr[0].equals(\"?\")) {\\n            if (arr[1].equals(\"?\")) {\\n                arr[0] = \"2\";\\n                arr[1] = \"3\";\\n            } else if (arr[1].equals(\"0\") || arr[1].equals(\"1\") || arr[1].equals(\"2\") || arr[1].equals(\"3\")) {\\n                arr[0] = \"2\";\\n            } else {\\n                arr[0] = \"1\";\\n            }\\n        }\\n\\n        if (arr[1].equals(\"?\")) {\\n            if (arr[0].equals(\"0\") || arr[0].equals(\"1\")) {\\n                arr[1] = \"9\";\\n            } else if (arr[0].equals(\"2\")) {\\n                arr[1] = \"3\";\\n            }\\n        }\\n\\n        if (arr[2].equals(\"?\")) {\\n            arr[2] = \"5\";\\n        }\\n\\n        if (arr[3].equals(\"?\")) {\\n            arr[3] = \"9\";\\n        }\\n\\n        return arr[0] + arr[1] + \":\" + arr[2] + arr[3];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326829,
                "title": "faster-than-100-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force simple approach.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        char h1 = time[0], h2=time[1], m1=time[3], m2=time[4];\\n\\n        if (h1 == \\'?\\' && h2 != \\'?\\') {\\n            if (h2-48 <= 3) {\\n                time[0] = \\'2\\';\\n            } else {\\n                time[0] = \\'1\\';\\n            }\\n        } else if (h2 == \\'?\\' && h1 != \\'?\\') {\\n            if (h1 == \\'0\\' || h1 == \\'1\\') {\\n                time[1] = \\'9\\';\\n            } else {\\n                time[1] = \\'3\\';\\n            }\\n        } else if (h1 == \\'?\\' && h2 == \\'?\\') {\\n            time[0] = \\'2\\';\\n            time[1] = \\'3\\';\\n        }\\n        \\n        if (m1 == \\'?\\' && m2 != \\'?\\') {\\n            time[3] = \\'5\\';\\n        } else if (m1 != \\'?\\' && m2 == \\'?\\') {\\n            time[4] = \\'9\\';\\n        } else if (m1 == \\'?\\' && m2 == \\'?\\') {\\n            time[3] = \\'5\\';\\n            time[4] = \\'9\\';\\n        }\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        char h1 = time[0], h2=time[1], m1=time[3], m2=time[4];\\n\\n        if (h1 == \\'?\\' && h2 != \\'?\\') {\\n            if (h2-48 <= 3) {\\n                time[0] = \\'2\\';\\n            } else {\\n                time[0] = \\'1\\';\\n            }\\n        } else if (h2 == \\'?\\' && h1 != \\'?\\') {\\n            if (h1 == \\'0\\' || h1 == \\'1\\') {\\n                time[1] = \\'9\\';\\n            } else {\\n                time[1] = \\'3\\';\\n            }\\n        } else if (h1 == \\'?\\' && h2 == \\'?\\') {\\n            time[0] = \\'2\\';\\n            time[1] = \\'3\\';\\n        }\\n        \\n        if (m1 == \\'?\\' && m2 != \\'?\\') {\\n            time[3] = \\'5\\';\\n        } else if (m1 != \\'?\\' && m2 == \\'?\\') {\\n            time[4] = \\'9\\';\\n        } else if (m1 == \\'?\\' && m2 == \\'?\\') {\\n            time[3] = \\'5\\';\\n            time[4] = \\'9\\';\\n        }\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316368,
                "title": "intuitive-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck every possible case and max it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst split time in hour and minute.\\nThan get the max possible hour and the max possible minute.\\nLast return the hour and minute with \":\" in between.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hour, minute = time.split(\":\")\\n        # max hour\\n        if hour == \"??\":\\n            hour = \"23\"\\n        elif hour[0] == \"?\":\\n            if int(hour[1]) < 4:\\n                hour = \"2\" + hour[1]\\n            else:\\n                hour = \"1\" + hour[1]\\n        elif hour[1] == \"?\":\\n            if hour[0] == \"2\":\\n                hour = hour[0] + \"3\"\\n            else:\\n                hour = hour[0] + \"9\"\\n        # max minute\\n        if minute[0] == \"?\":\\n            minute = \"5\" + minute[1]\\n        if minute[1] == \"?\":\\n            minute = minute[0] + \"9\"\\n        return hour+\":\"+minute\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        hour, minute = time.split(\":\")\\n        # max hour\\n        if hour == \"??\":\\n            hour = \"23\"\\n        elif hour[0] == \"?\":\\n            if int(hour[1]) < 4:\\n                hour = \"2\" + hour[1]\\n            else:\\n                hour = \"1\" + hour[1]\\n        elif hour[1] == \"?\":\\n            if hour[0] == \"2\":\\n                hour = hour[0] + \"3\"\\n            else:\\n                hour = hour[0] + \"9\"\\n        # max minute\\n        if minute[0] == \"?\":\\n            minute = \"5\" + minute[1]\\n        if minute[1] == \"?\":\\n            minute = minute[0] + \"9\"\\n        return hour+\":\"+minute\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314730,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O(n), to convert the char array to String\\n\\n- Space complexity:\\n  - O(n), for the char array\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] times = time.toCharArray();\\n        hour(times, 0, 1);\\n        minute(times, 3, 4);\\n        return String.valueOf(times);\\n\\n    }\\n\\n    public void hour(char[] hr, int i, int j) {\\n        if (hr[i] == \\'?\\' && hr[j] == \\'?\\') {\\n            hr[i] = \\'2\\';\\n            hr[j] = \\'3\\';\\n        }\\n\\n        else if (hr[i] == \\'?\\') {\\n            hr[i] = hr[j] <= \\'3\\' ? \\'2\\' : \\'1\\';\\n        }\\n\\n        else if (hr[j] == \\'?\\') {\\n            hr[j] = hr[i] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n    }\\n\\n    public void minute(char[] minute, int i, int j) {\\n        if (minute[i] == \\'?\\' && minute[j] == \\'?\\') {\\n            minute[i] = \\'5\\';\\n            minute[j] = \\'9\\';\\n        }\\n\\n        else if (minute[i] == \\'?\\') {\\n            minute[i] = \\'5\\';\\n        }\\n\\n        else if (minute[j] == \\'?\\') {\\n            minute[j] = \\'9\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] times = time.toCharArray();\\n        hour(times, 0, 1);\\n        minute(times, 3, 4);\\n        return String.valueOf(times);\\n\\n    }\\n\\n    public void hour(char[] hr, int i, int j) {\\n        if (hr[i] == \\'?\\' && hr[j] == \\'?\\') {\\n            hr[i] = \\'2\\';\\n            hr[j] = \\'3\\';\\n        }\\n\\n        else if (hr[i] == \\'?\\') {\\n            hr[i] = hr[j] <= \\'3\\' ? \\'2\\' : \\'1\\';\\n        }\\n\\n        else if (hr[j] == \\'?\\') {\\n            hr[j] = hr[i] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n    }\\n\\n    public void minute(char[] minute, int i, int j) {\\n        if (minute[i] == \\'?\\' && minute[j] == \\'?\\') {\\n            minute[i] = \\'5\\';\\n            minute[j] = \\'9\\';\\n        }\\n\\n        else if (minute[i] == \\'?\\') {\\n            minute[i] = \\'5\\';\\n        }\\n\\n        else if (minute[j] == \\'?\\') {\\n            minute[j] = \\'9\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311748,
                "title": "replacing-hidden-digits-easiest-with-c-in-0ms-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0] == \\'?\\')\\n        {\\n            if(time[1] == \\'?\\')\\n                time[0]=\\'2\\', time[1]=\\'3\\';\\n            else if(time[1] < \\'4\\')\\n                time[0]=\\'2\\';\\n            else\\n                time[0]=\\'1\\';\\n        }\\n        if(time[1] == \\'?\\')\\n        {\\n            if(time[0] == \\'2\\')\\n                time[1]=\\'3\\';\\n            else\\n                time[1]=\\'9\\';\\n        }\\n        if(time[3] == \\'?\\')\\n            time[3]=\\'5\\';\\n        \\n        if(time[4] == \\'?\\')\\n            time[4]=\\'9\\';\\n        \\n        return time;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if(time[0] == \\'?\\')\\n        {\\n            if(time[1] == \\'?\\')\\n                time[0]=\\'2\\', time[1]=\\'3\\';\\n            else if(time[1] < \\'4\\')\\n                time[0]=\\'2\\';\\n            else\\n                time[0]=\\'1\\';\\n        }\\n        if(time[1] == \\'?\\')\\n        {\\n            if(time[0] == \\'2\\')\\n                time[1]=\\'3\\';\\n            else\\n                time[1]=\\'9\\';\\n        }\\n        if(time[3] == \\'?\\')\\n            time[3]=\\'5\\';\\n        \\n        if(time[4] == \\'?\\')\\n            time[4]=\\'9\\';\\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305003,
                "title": "beginner-friendly-solution-using-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Using only if-else and ternary operator. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char [] a = time.toCharArray();\\n\\n        if(a[0]==\\'?\\'){\\n            a[0] = a[1] <= \\'3\\' || a[1] == \\'?\\' ? \\'2\\' : \\'1\\';    \\n        }\\n        if(a[1]==\\'?\\'){\\n            a[1] = a[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n        if(a[3]==\\'?\\'){\\n            a[3]=\\'5\\';\\n        }\\n        if(a[4]==\\'?\\'){\\n            a[4] = \\'9\\';\\n        }\\n       return new String(a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char [] a = time.toCharArray();\\n\\n        if(a[0]==\\'?\\'){\\n            a[0] = a[1] <= \\'3\\' || a[1] == \\'?\\' ? \\'2\\' : \\'1\\';    \\n        }\\n        if(a[1]==\\'?\\'){\\n            a[1] = a[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        }\\n        if(a[3]==\\'?\\'){\\n            a[3]=\\'5\\';\\n        }\\n        if(a[4]==\\'?\\'){\\n            a[4] = \\'9\\';\\n        }\\n       return new String(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300441,
                "title": "my-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n         if (time.charAt(0) == \\'?\\') {\\n            if (time.charAt(1) != \\'?\\' && time.charAt(1) - \\'0\\' > 3) {\\n                time = time.substring(0, 0) + \\'1\\' + time.substring(1);\\n            } else {\\n                time = time.substring(0, 0) + \\'2\\' + time.substring(1);\\n            }\\n        }\\n        if (time.charAt(1) == \\'?\\') {\\n            if (time.charAt(0) == \\'1\\' || time.charAt(0) == \\'0\\') {\\n                time = time.substring(0, 1) + \\'9\\' + time.substring(2);\\n            } else {\\n                time = time.substring(0, 1) + \\'3\\' + time.substring(2);\\n            }\\n        }\\n        if (time.charAt(3) == \\'?\\') {\\n            time = time.substring(0, 3) + \\'5\\' + time.substring(4);\\n        }\\n        if (time.charAt(4) == \\'?\\') {\\n            time = time.substring(0, 4) + \\'9\\';\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n         if (time.charAt(0) == \\'?\\') {\\n            if (time.charAt(1) != \\'?\\' && time.charAt(1) - \\'0\\' > 3) {\\n                time = time.substring(0, 0) + \\'1\\' + time.substring(1);\\n            } else {\\n                time = time.substring(0, 0) + \\'2\\' + time.substring(1);\\n            }\\n        }\\n        if (time.charAt(1) == \\'?\\') {\\n            if (time.charAt(0) == \\'1\\' || time.charAt(0) == \\'0\\') {\\n                time = time.substring(0, 1) + \\'9\\' + time.substring(2);\\n            } else {\\n                time = time.substring(0, 1) + \\'3\\' + time.substring(2);\\n            }\\n        }\\n        if (time.charAt(3) == \\'?\\') {\\n            time = time.substring(0, 3) + \\'5\\' + time.substring(4);\\n        }\\n        if (time.charAt(4) == \\'?\\') {\\n            time = time.substring(0, 4) + \\'9\\';\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281195,
                "title": "c-100-faster-easy-method",
                "content": "# Intuition\\njust checking all the possiblity.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. create a empty string\\n2.check the original string\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string s) {\\n        string t=\"\";\\n        if(s[0]==\\'?\\' && s[1]==\\'?\\') t+= \"23\";\\n        else {\\n            if(s[0]==\\'?\\')  {t+=s[1]<=\\'3\\'? \\'2\\':\\'1\\';} else {t+=s[0];}\\n            if(s[1]==\\'?\\'){ t+=t[0]==\\'2\\'? \\'3\\':\\'9\\';} else{ t+=s[1];}\\n        }\\n        t+=\\':\\';\\n        if(s[3]==\\'?\\' && s[4]==\\'?\\') t+= \"59\";\\n        else { \\n            if(s[3]==\\'?\\') t+= \\'5\\';\\n            else  t+=s[3];\\n        \\n            if(s[4]==\\'?\\')  t+= \\'9\\';\\n            else  t+=s[4];\\n        }\\n        return t;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string s) {\\n        string t=\"\";\\n        if(s[0]==\\'?\\' && s[1]==\\'?\\') t+= \"23\";\\n        else {\\n            if(s[0]==\\'?\\')  {t+=s[1]<=\\'3\\'? \\'2\\':\\'1\\';} else {t+=s[0];}\\n            if(s[1]==\\'?\\'){ t+=t[0]==\\'2\\'? \\'3\\':\\'9\\';} else{ t+=s[1];}\\n        }\\n        t+=\\':\\';\\n        if(s[3]==\\'?\\' && s[4]==\\'?\\') t+= \"59\";\\n        else { \\n            if(s[3]==\\'?\\') t+= \\'5\\';\\n            else  t+=s[3];\\n        \\n            if(s[4]==\\'?\\')  t+= \\'9\\';\\n            else  t+=s[4];\\n        }\\n        return t;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266738,
                "title": "easy-to-understand-code-in-c-c-beats-100-solution-please-upvote-if-its-really-helps-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nchar * maximumTime(char * time){\\nif (time[0] == \\'?\\' && time[1] == \\'?\\') {\\n        time[0] = \\'2\\';\\n        time[1] = \\'3\\';\\n    } else if (time[0] == \\'?\\') {\\n        if (time[1] <= \\'3\\') {\\n            time[0] = \\'2\\';\\n        } else {\\n            time[0] = \\'1\\';\\n        }\\n    } else if (time[1] == \\'?\\') {\\n        if (time[0] == \\'2\\') {\\n            time[1] = \\'3\\';\\n        } else {\\n            time[1] = \\'9\\';\\n        }\\n    }\\n\\n    // Replace the second hidden digit from the left\\n    if (time[3] == \\'?\\') {\\n        time[3] = \\'5\\';\\n    }\\n\\n    // Replace the third and last hidden digit from the left\\n    if (time[4] == \\'?\\') {\\n        time[4] = \\'9\\';\\n    }\\n\\n    return time;\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nchar * maximumTime(char * time){\\nif (time[0] == \\'?\\' && time[1] == \\'?\\') {\\n        time[0] = \\'2\\';\\n        time[1] = \\'3\\';\\n    } else if (time[0] == \\'?\\') {\\n        if (time[1] <= \\'3\\') {\\n            time[0] = \\'2\\';\\n        } else {\\n            time[0] = \\'1\\';\\n        }\\n    } else if (time[1] == \\'?\\') {\\n        if (time[0] == \\'2\\') {\\n            time[1] = \\'3\\';\\n        } else {\\n            time[1] = \\'9\\';\\n        }\\n    }\\n\\n    // Replace the second hidden digit from the left\\n    if (time[3] == \\'?\\') {\\n        time[3] = \\'5\\';\\n    }\\n\\n    // Replace the third and last hidden digit from the left\\n    if (time[4] == \\'?\\') {\\n        time[4] = \\'9\\';\\n    }\\n\\n    return time;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3248175,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String[] time_arr = time.split(\":\", 2);\\n        String max_hour = time_arr[0];\\n        String max_min = time_arr[1];\\n        System.out.println(max_hour);\\n        System.out.println(max_min);\\n        int index = max_hour.indexOf(\\'?\\');\\n        int ind = max_min.indexOf(\\'?\\');\\n        System.out.println(index);\\n        String hour;\\n        String min;\\n        boolean hr = false;\\n        boolean mts = false;\\n        if(max_hour.equals(\"??\")){\\n            max_hour = \"23\";\\n            hr=true;\\n        }\\n        if(max_min.equals(\"??\")){\\n            max_min = \"59\";\\n            mts=true;\\n        }\\n        if(index==1 && hr==false){\\n            int start = max_hour.charAt(0)-\\'0\\';\\n            if(start==0){    \\n                max_hour = \"09\";\\n            }\\n            else if(start==1){\\n                max_hour = \"19\";\\n            }\\n            else if(start==2){\\n                max_hour = \"23\";\\n            }\\n            System.out.println(start+\"= start\");\\n            System.out.println(max_hour+\" = max_hour\");\\n            \\n        }\\n        else if(index == 0 && hr==false)\\n        {\\n            int end = max_hour.charAt(1)-\\'0\\';\\n            if(end==0){    \\n                max_hour = \"20\";\\n            }\\n            else if(end>=1 && end<=3){\\n                max_hour = \"2\"+Integer.toString(end);\\n            }\\n            else if(end>3){\\n                max_hour = \"1\"+Integer.toString(end);\\n            }\\n            // System.out.println(start+\"= start\");\\n            System.out.println(max_hour+\" = max_hour\");\\n        }\\n\\n        if(ind==0 && mts==false)\\n        {\\n            int end = max_min.charAt(1)-\\'0\\';\\n            max_min = \"5\"+Integer.toString(end);\\n            System.out.println(\"max_min = \"+max_min);\\n        }\\n\\n        if(ind==1)\\n        {\\n            int start = max_min.charAt(0)-\\'0\\';\\n            max_min = Integer.toString(start)+\"9\";\\n            System.out.println(\"max_min = \"+max_min);\\n        }\\n\\n        \\n        return max_hour+\":\"+max_min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        String[] time_arr = time.split(\":\", 2);\\n        String max_hour = time_arr[0];\\n        String max_min = time_arr[1];\\n        System.out.println(max_hour);\\n        System.out.println(max_min);\\n        int index = max_hour.indexOf(\\'?\\');\\n        int ind = max_min.indexOf(\\'?\\');\\n        System.out.println(index);\\n        String hour;\\n        String min;\\n        boolean hr = false;\\n        boolean mts = false;\\n        if(max_hour.equals(\"??\")){\\n            max_hour = \"23\";\\n            hr=true;\\n        }\\n        if(max_min.equals(\"??\")){\\n            max_min = \"59\";\\n            mts=true;\\n        }\\n        if(index==1 && hr==false){\\n            int start = max_hour.charAt(0)-\\'0\\';\\n            if(start==0){    \\n                max_hour = \"09\";\\n            }\\n            else if(start==1){\\n                max_hour = \"19\";\\n            }\\n            else if(start==2){\\n                max_hour = \"23\";\\n            }\\n            System.out.println(start+\"= start\");\\n            System.out.println(max_hour+\" = max_hour\");\\n            \\n        }\\n        else if(index == 0 && hr==false)\\n        {\\n            int end = max_hour.charAt(1)-\\'0\\';\\n            if(end==0){    \\n                max_hour = \"20\";\\n            }\\n            else if(end>=1 && end<=3){\\n                max_hour = \"2\"+Integer.toString(end);\\n            }\\n            else if(end>3){\\n                max_hour = \"1\"+Integer.toString(end);\\n            }\\n            // System.out.println(start+\"= start\");\\n            System.out.println(max_hour+\" = max_hour\");\\n        }\\n\\n        if(ind==0 && mts==false)\\n        {\\n            int end = max_min.charAt(1)-\\'0\\';\\n            max_min = \"5\"+Integer.toString(end);\\n            System.out.println(\"max_min = \"+max_min);\\n        }\\n\\n        if(ind==1)\\n        {\\n            int start = max_min.charAt(0)-\\'0\\';\\n            max_min = Integer.toString(start)+\"9\";\\n            System.out.println(\"max_min = \"+max_min);\\n        }\\n\\n        \\n        return max_hour+\":\"+max_min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230184,
                "title": "java-easy-logical-solution",
                "content": "\\nclass Solution {\\n    public String maximumTime(String times) {\\n        char[] time = times.toCharArray();\\n        for(int i=4;i>=0;i--){\\n            if(i == 4 && time[i] == \\'?\\')\\n                time[i] = \\'9\\';\\n            if(i == 3 && time[i] == \\'?\\')\\n                time[i] = \\'5\\';\\n            if(i == 1 && time[i] == \\'?\\'){\\n                if(time[i] == \\'?\\' && time[i-1] == \\'?\\'){\\n                    time[i] = \\'3\\';\\n                    time[i-1] = \\'2\\';\\n                }\\n                else if(time[i-1]==\\'?\\')\\n                time[i] = \\'2\\';\\n                else if(time[i-1] == \\'0\\' || time[i-1] == \\'1\\')\\n                time[i] = \\'9\\';\\n                else if(time[i-1] == \\'2\\')\\n                time[i] = \\'3\\';\\n            }\\n            if(i==0 && time[i] == \\'?\\')\\n                if(time[i+1]-\\'0\\' > 3 && time[i+1]-\\'0\\' <=9)\\n                time[i] = \\'1\\';\\n                else \\n                time[i] = \\'2\\';\\n        }\\n        return String.valueOf(time);\\n    }\\n}\\n```\\n\\nIf you like the approach, do upvote me!!!!\\nThank You.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String maximumTime(String times) {\\n        char[] time = times.toCharArray();\\n        for(int i=4;i>=0;i--){\\n            if(i == 4 && time[i] == \\'?\\')\\n                time[i] = \\'9\\';\\n            if(i == 3 && time[i] == \\'?\\')\\n                time[i] = \\'5\\';\\n            if(i == 1 && time[i] == \\'?\\'){\\n                if(time[i] == \\'?\\' && time[i-1] == \\'?\\'){\\n                    time[i] = \\'3\\';\\n                    time[i-1] = \\'2\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3207757,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if (time[0] == \\'?\\') time[0] = time[1] != \\'?\\' && time[1] > \\'3\\' ? \\'1\\' : \\'2\\';\\n        if (time[1] == \\'?\\') time[1] = time[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        if (time[3] == \\'?\\') time[3] = \\'5\\';\\n        if (time[4] == \\'?\\') time[4] = \\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maximumTime(string time) {\\n        if (time[0] == \\'?\\') time[0] = time[1] != \\'?\\' && time[1] > \\'3\\' ? \\'1\\' : \\'2\\';\\n        if (time[1] == \\'?\\') time[1] = time[0] == \\'2\\' ? \\'3\\' : \\'9\\';\\n        if (time[3] == \\'?\\') time[3] = \\'5\\';\\n        if (time[4] == \\'?\\') time[4] = \\'9\\';\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196117,
                "title": "python-o-50-hint-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI was not satisfied with the if-else solution, thus here is the approach as mentioned in the hints to brute force it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- As always in greedy manner we start from the left to maximize the - time, we choose the leftmost char with a \\'?\\', and start replacing it with 1,2,3,4,... and check if the new time formed is valid or not\\n- If it is valid we save it\\n- There could also be more \\'?\\' to the right of the char we just found, for example 2?:0?, in this case we can just replace it with a 0 as its value doesnt matter for now\\n# Complexity\\n- Time complexity: O(50)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        def check(t):\\n            t = t.replace(\"?\",\"0\")\\n            hours,mins = int(t[:2]),int(t[3:])\\n            if hours in range(0,24) and mins in range(0,60):\\n                return True\\n            return False\\n        \\n        ti = [i for i in time]\\n        \\n        for i in range(len(ti)):\\n            temp = ti.copy()\\n            // we should not modify an character which is not a ?\\n            if ti[i] != \\'?\\':continue\\n            \\n            for j in range(0,10):\\n                // start replacing ith character with increasing digits\\n                temp[i] = str(j)\\n\\n                if check(\\'\\'.join(temp)): ti = temp.copy()\\n                // break if the given time is invalid and thus \\n                // last valid time is saved\\n                else:break\\n        \\n        return \\'\\'.join(ti)\\n\\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        def check(t):\\n            t = t.replace(\"?\",\"0\")\\n            hours,mins = int(t[:2]),int(t[3:])\\n            if hours in range(0,24) and mins in range(0,60):\\n                return True\\n            return False\\n        \\n        ti = [i for i in time]\\n        \\n        for i in range(len(ti)):\\n            temp = ti.copy()\\n            // we should not modify an character which is not a ?\\n            if ti[i] != \\'?\\':continue\\n            \\n            for j in range(0,10):\\n                // start replacing ith character with increasing digits\\n                temp[i] = str(j)\\n\\n                if check(\\'\\'.join(temp)): ti = temp.copy()\\n                // break if the given time is invalid and thus \\n                // last valid time is saved\\n                else:break\\n        \\n        return \\'\\'.join(ti)\\n\\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194437,
                "title": "python-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        l=len(time)\\n        d={0:\\'2\\',1:\\'9\\',3:\\'5\\',4:\\'9\\'}\\n        ans=\\'\\'\\n        missing=set()\\n        for i in range(l):\\n            if time[i]==\\'?\\':\\n                missing.add(i)\\n        for i in range(l):\\n            if i in missing:\\n\\n                if (i==1) and ans[0]==\\'2\\':\\n                    ans+=\\'3\\'\\n                elif (i==0) and time[1] != \\'?\\' and int(time[1])>=4:\\n                    ans+=\\'1\\'\\n                else:\\n                    ans+=d[i]\\n            else:\\n                ans+=time[i]\\n        return ans\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTime(self, time: str) -> str:\\n        l=len(time)\\n        d={0:\\'2\\',1:\\'9\\',3:\\'5\\',4:\\'9\\'}\\n        ans=\\'\\'\\n        missing=set()\\n        for i in range(l):\\n            if time[i]==\\'?\\':\\n                missing.add(i)\\n        for i in range(l):\\n            if i in missing:\\n\\n                if (i==1) and ans[0]==\\'2\\':\\n                    ans+=\\'3\\'\\n                elif (i==0) and time[1] != \\'?\\' and int(time[1])>=4:\\n                    ans+=\\'1\\'\\n                else:\\n                    ans+=d[i]\\n            else:\\n                ans+=time[i]\\n        return ans\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190869,
                "title": "latest-time-javascript-fastest-beats-100",
                "content": "# Code\\n```\\n/**\\n * @param {string} time\\n * @return {string}\\n */\\nvar maximumTime = function(time) {\\n    // convert string to array ( time.split(\\'\\') )\\n    time = time.split(\\'\\')\\n    // conditional statement for time [0]\\n    if (time[0] == \\'?\\' && time[1] > 3) time[0] = 1\\n    else if (time[0] == \\'?\\') time[0] = 2\\n    // conditional statement for time [1]\\n    if (time[1] == \\'?\\' && time[0] == 2) time[1] = 3\\n    else if (time[1] == \\'?\\' && (time[0] == 1 || time[0] == 0)) time[1] = 9\\n    // conditional statement for time [3]\\n    if (time[3] == \\'?\\') time[3] = 5\\n    // conditional statement for time [4]\\n    if (time[4] == \\'?\\') time[4] = 9\\n    // return array.join(\\'\\') -> string\\n    return time.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} time\\n * @return {string}\\n */\\nvar maximumTime = function(time) {\\n    // convert string to array ( time.split(\\'\\') )\\n    time = time.split(\\'\\')\\n    // conditional statement for time [0]\\n    if (time[0] == \\'?\\' && time[1] > 3) time[0] = 1\\n    else if (time[0] == \\'?\\') time[0] = 2\\n    // conditional statement for time [1]\\n    if (time[1] == \\'?\\' && time[0] == 2) time[1] = 3\\n    else if (time[1] == \\'?\\' && (time[0] == 1 || time[0] == 0)) time[1] = 9\\n    // conditional statement for time [3]\\n    if (time[3] == \\'?\\') time[3] = 5\\n    // conditional statement for time [4]\\n    if (time[4] == \\'?\\') time[4] = 9\\n    // return array.join(\\'\\') -> string\\n    return time.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3177907,
                "title": "solution-implemented-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] ch = time.toCharArray();\\n        if (ch[0]==63){\\n            ch[0] = (ch[1]<52 || ch[1] == 63)?\\'2\\':\\'1\\';\\n        }\\n        if (ch[1]==63){\\n            ch[1] = (ch[0]==50)?\\'3\\':\\'9\\';\\n        }\\n        if (ch[3]==63){\\n            ch[3] = \\'5\\';\\n        }\\n        if (ch[4]==63){\\n            ch[4] = \\'9\\';\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String maximumTime(String time) {\\n        char[] ch = time.toCharArray();\\n        if (ch[0]==63){\\n            ch[0] = (ch[1]<52 || ch[1] == 63)?\\'2\\':\\'1\\';\\n        }\\n        if (ch[1]==63){\\n            ch[1] = (ch[0]==50)?\\'3\\':\\'9\\';\\n        }\\n        if (ch[3]==63){\\n            ch[3] = \\'5\\';\\n        }\\n        if (ch[4]==63){\\n            ch[4] = \\'9\\';\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171062,
                "title": "easy-solution-in-js",
                "content": "```\\nvar maximumTime = function(time) {\\n    time = time.split(\"\")\\n    if(time[0] === \"?\") {\\n        if(Number(time[1]) > 3) time[0] = \"1\"\\n        else time[0] = \"2\"\\n    }\\n    if(time[1] === \"?\") {\\n        if(time[0] === \"2\") time[1] = \"3\"\\n        else time[1] = \"9\"\\n    }\\n    if(time[3] === \"?\") time[3] = \"5\"\\n    if(time[4] === \"?\") time[4] = \"9\"\\n    \\n    return time.join(\"\")\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTime = function(time) {\\n    time = time.split(\"\")\\n    if(time[0] === \"?\") {\\n        if(Number(time[1]) > 3) time[0] = \"1\"\\n        else time[0] = \"2\"\\n    }\\n    if(time[1] === \"?\") {\\n        if(time[0] === \"2\") time[1] = \"3\"\\n        else time[1] = \"9\"\\n    }\\n    if(time[3] === \"?\") time[3] = \"5\"\\n    if(time[4] === \"?\") time[4] = \"9\"\\n    \\n    return time.join(\"\")\\n};",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1737294,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: keep patient."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A good example for those of us who jump into coding too quickly, without thinking through the edge cases first. The minor pitfalls on generating the first two digits are a fun exercise. "
                    },
                    {
                        "username": "FluteofCode",
                        "content": "can anyone explain the second and third test case ,i am so confused \\n"
                    },
                    {
                        "username": "danielmascena",
                        "content": "You just need to go for the highest number if that not invalidate the time, for hours it can be between 00 ... 19, when turning into 20 (special case ) you can only go to 23. Hope I could help you"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "Is there a cleaner way to program it without the nested if/else statements?"
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s actually cleaner with some if-else:\\nhttps://leetcode.com/problems/latest-time-by-replacing-hidden-digits/solutions/3752009/0ms-o-1-most-intuitive-solution-works-for-general-cases/"
                    }
                ]
            },
            {
                "id": 1674410,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: keep patient."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A good example for those of us who jump into coding too quickly, without thinking through the edge cases first. The minor pitfalls on generating the first two digits are a fun exercise. "
                    },
                    {
                        "username": "FluteofCode",
                        "content": "can anyone explain the second and third test case ,i am so confused \\n"
                    },
                    {
                        "username": "danielmascena",
                        "content": "You just need to go for the highest number if that not invalidate the time, for hours it can be between 00 ... 19, when turning into 20 (special case ) you can only go to 23. Hope I could help you"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "Is there a cleaner way to program it without the nested if/else statements?"
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s actually cleaner with some if-else:\\nhttps://leetcode.com/problems/latest-time-by-replacing-hidden-digits/solutions/3752009/0ms-o-1-most-intuitive-solution-works-for-general-cases/"
                    }
                ]
            },
            {
                "id": 1730248,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: keep patient."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A good example for those of us who jump into coding too quickly, without thinking through the edge cases first. The minor pitfalls on generating the first two digits are a fun exercise. "
                    },
                    {
                        "username": "FluteofCode",
                        "content": "can anyone explain the second and third test case ,i am so confused \\n"
                    },
                    {
                        "username": "danielmascena",
                        "content": "You just need to go for the highest number if that not invalidate the time, for hours it can be between 00 ... 19, when turning into 20 (special case ) you can only go to 23. Hope I could help you"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "Is there a cleaner way to program it without the nested if/else statements?"
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s actually cleaner with some if-else:\\nhttps://leetcode.com/problems/latest-time-by-replacing-hidden-digits/solutions/3752009/0ms-o-1-most-intuitive-solution-works-for-general-cases/"
                    }
                ]
            },
            {
                "id": 1660081,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: keep patient."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A good example for those of us who jump into coding too quickly, without thinking through the edge cases first. The minor pitfalls on generating the first two digits are a fun exercise. "
                    },
                    {
                        "username": "FluteofCode",
                        "content": "can anyone explain the second and third test case ,i am so confused \\n"
                    },
                    {
                        "username": "danielmascena",
                        "content": "You just need to go for the highest number if that not invalidate the time, for hours it can be between 00 ... 19, when turning into 20 (special case ) you can only go to 23. Hope I could help you"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "Is there a cleaner way to program it without the nested if/else statements?"
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s actually cleaner with some if-else:\\nhttps://leetcode.com/problems/latest-time-by-replacing-hidden-digits/solutions/3752009/0ms-o-1-most-intuitive-solution-works-for-general-cases/"
                    }
                ]
            }
        ]
    }
]