[
    {
        "title": "Find Palindrome With Fixed Length",
        "question_content": "Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.\nA palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.\n&nbsp;\nExample 1:\n\nInput: queries = [1,2,3,4,5,90], intLength = 3\nOutput: [101,111,121,131,141,999]\nExplanation:\nThe first few palindromes of length 3 are:\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\nThe 90th palindrome of length 3 is 999.\n\nExample 2:\n\nInput: queries = [2,4,6], intLength = 4\nOutput: [1111,1331,1551]\nExplanation:\nThe first six palindromes of length 4 are:\n1001, 1111, 1221, 1331, 1441, and 1551.\n\n&nbsp;\nConstraints:\n\n\t1 <= queries.length <= 5 * 104\n\t1 <= queries[i] <= 109\n\t1 <= intLength&nbsp;<= 15",
        "solutions": [
            {
                "id": 1886915,
                "title": "formula",
                "content": "Only the first `(intLength + 1) / 2` characters matter. The remaining characters are just a reflection.\\n\\nSay `intLength == 7`, so we consider only 4 characters. The minimum number is `1000` and maximum - `9999`.\\n\\nTherefore, we can have `9999 - 1000 + 1 == 9000` palindromes. To find out the palindrome, we add a `q - 1` to the minimum number, reverse, and concatenate.\\n\\nFor example, for query `8765`, the base number is `1000 + 8765 - 1 == 9764`. Concatenating it with `679`, we get `9764679` as the result.\\n\\n**C++**\\nThe code could be shorter if we use string operations, but I wanted to avoid those for the efficiency. \\n\\n```cpp\\nint reverse(long long n, bool skip) {\\n    long long res = 0;\\n    for (n = skip ? n / 10 : n; n > 0; n /= 10)\\n        res = res * 10 + n % 10;\\n    return res;\\n}\\nvector<long long> kthPalindrome(vector<int>& queries, int sz) {\\n    vector<long long> res;\\n    long long start = pow(10, (sz + 1) / 2 - 1), end = pow(10, (sz + 1 ) / 2), mul = pow(10, sz / 2);    \\n    for (int q : queries)\\n        res.push_back(start + q > end ? -1 : \\n            (start + q - 1) * mul + reverse(start + q - 1, sz % 2));\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint reverse(long long n, bool skip) {\\n    long long res = 0;\\n    for (n = skip ? n / 10 : n; n > 0; n /= 10)\\n        res = res * 10 + n % 10;\\n    return res;\\n}\\nvector<long long> kthPalindrome(vector<int>& queries, int sz) {\\n    vector<long long> res;\\n    long long start = pow(10, (sz + 1) / 2 - 1), end = pow(10, (sz + 1 ) / 2), mul = pow(10, sz / 2);    \\n    for (int q : queries)\\n        res.push_back(start + q > end ? -1 : \\n            (start + q - 1) * mul + reverse(start + q - 1, sz % 2));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887014,
                "title": "simple-java-solution-half-the-palindrome-length",
                "content": "```\\nclass Solution {\\n/*\\nFirst Palindrome of length 4 = \"10\"+\"01\"\\nFirst Palindrome of length 3 = \"10\"+\"_1\" (without first character 0)\\nFirst half can range from 10 (which is 10^1) to 99 (which is 10^2-1)\\n*/\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] result = new long[queries.length];\\n        int i = 0;\\n        for(int num: queries){\\n\\t\\t\\tlong half = (intLength+1)/2;//half for 3 =2, half for 4 = 2\\n\\t\\t\\tlong start = (long)Math.pow(10,half-1);\\n\\t\\t\\tlong end = (long)Math.pow(10,half)-1;\\n\\t\\t\\tif(num<=(end-start+1)){ //check if query is within range\\n\\t\\t\\t\\tString firstHalfOfPalindrome = ((start)+ (num-1))+\"\";\\n\\t\\t\\t\\tString secondHalf = (new StringBuffer(firstHalfOfPalindrome)).reverse().toString();\\n\\t\\t\\t\\tresult[i++] = Long.parseLong(firstHalfOfPalindrome+secondHalf.substring(intLength%2)); // since half is calculated as 1 extra for odd numbers, remove the first char for odd length in substring - 1001 vs 10+(0)1 \\n\\t\\t\\t}else{\\n\\t\\t\\t\\tresult[i++]=-1;\\n\\t\\t\\t}\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n/*\\nFirst Palindrome of length 4 = \"10\"+\"01\"\\nFirst Palindrome of length 3 = \"10\"+\"_1\" (without first character 0)\\nFirst half can range from 10 (which is 10^1) to 99 (which is 10^2-1)\\n*/\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] result = new long[queries.length];\\n        int i = 0;\\n        for(int num: queries){\\n\\t\\t\\tlong half = (intLength+1)/2;//half for 3 =2, half for 4 = 2\\n\\t\\t\\tlong start = (long)Math.pow(10,half-1);\\n\\t\\t\\tlong end = (long)Math.pow(10,half)-1;\\n\\t\\t\\tif(num<=(end-start+1)){ //check if query is within range\\n\\t\\t\\t\\tString firstHalfOfPalindrome = ((start)+ (num-1))+\"\";\\n\\t\\t\\t\\tString secondHalf = (new StringBuffer(firstHalfOfPalindrome)).reverse().toString();\\n\\t\\t\\t\\tresult[i++] = Long.parseLong(firstHalfOfPalindrome+secondHalf.substring(intLength%2)); // since half is calculated as 1 extra for odd numbers, remove the first char for odd length in substring - 1001 vs 10+(0)1 \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1887170,
                "title": "python-half-of-the-palindromes",
                "content": "# **Intuition**\\nThe first half part of palindrome is ordered.\\nNot leading zeros allowd, so ther starts with 100000, 100001, 100002..\\nEvery number is added a base in pow of 10.\\n<br>\\n\\n# **Explanation**\\nFind the base that we need to add to every element.\\nThe pow equals to the half of the length `l`.\\n\\nFor each query index `q`,\\nwe firstly turn it `q - 1`, whichis 0-based index,\\nthen add it with the base.\\n\\nFinally we make it palindrome by add its reversed string.\\n<br>\\n\\n# **Complexity**\\nTime `O(nl)`\\nSpace `O(nl)`\\n<br>\\n\\n**Python**\\n```py\\n    def kthPalindrome(self, queries, l):\\n        base = 10 ** ((l - 1) / 2)\\n        res = [q - 1 + base for q in queries]\\n        for i,a in enumerate(res):\\n            a = str(a) + str(a)[-1 - l % 2::-1]\\n            res[i] = int(a) if len(a) == l else -1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def kthPalindrome(self, queries, l):\\n        base = 10 ** ((l - 1) / 2)\\n        res = [q - 1 + base for q in queries]\\n        for i,a in enumerate(res):\\n            a = str(a) + str(a)[-1 - l % 2::-1]\\n            res[i] = int(a) if len(a) == l else -1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1886954,
                "title": "c-easy-stimulation-explanation",
                "content": "## Intuition\\n\\n**Case 1:**\\nintLength = 4 (even)\\nPalindromes will be\\n1001, 1111, 2222, ..., 9999\\n10 + 01\\n11 + 11\\n12 + 12\\nSo, we can take base value as 10 ^ (n / 2 - 1) and add query - 1 (as we have to consider 0) to get the first half of palindrome, we can simply reverse it to make palindorme\\n\\n**Case 2:**\\nintLength = 5 (odd)\\nPalindromes will be\\n10001, 10101, 10201, ..., 11011, 11111, 11211, ..., 12021, 12121, 12321, ...\\n**10**0 + 01\\n**10**1 + 01\\n\\t:\\n\\t:\\n**11**0 + 11\\n**11**1 + 11\\n\\t:\\n\\t:\\n**12**0 + 21\\n**12**1 + 21\\nFor odd length, we can take base value as 10 ^ (n / 2) and add query - 1 (as we have to consider 0) to get the first half of palindrome, we can simply reverse and exclude the start digit to make palindorme\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<ll> result;\\n        ll start = intLength % 2 == 0 ? pow(10, intLength/2 - 1) : pow(10, intLength/2);\\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(q * l), where q = no of queries and l = intLength\\n**Space Complexity:** O(q * l), for result array",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<ll> result;\\n        ll start = intLength % 2 == 0 ? pow(10, intLength/2 - 1) : pow(10, intLength/2);\\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886972,
                "title": "java-detailed-explanation-with-the-reference-link",
                "content": "First, we can simplify the problem because we only need to look at the first half of the digits (rounding up if there are an odd number of digits). I will call the first set of digits significant digits and the rest non-significant digits.\\n\\nThis is because the non-significant digits must match the significant digits (in reverse). It is not possible to have another palindrome number with the same leading significant digits and different non-significant digits. The significant digits determine the entire palindrome number.\\n\\nNow, we just need to come up with an algorithm to generate the nth valid significant digits. This would be easier if we allowed for leading zeros, so we\\'ll come up with the algorithm that allows for leading zeros, then tweak the algorithm.\\n\\nThe first few palindromes (significant digits) would be:\\n\\n1: 0000\\n2: 0001\\n3: 0002\\n...\\n100: 0099\\nSo we can find the significant digits of the nth number by finding the decimal representation of (n-1).\\n\\nTo tweak the algorithm to work when not allowing leading zeros, we would start with a one as the leading digit:\\n\\n1: 1000\\n2: 1001\\n3: 1002\\n...\\n100: 1099\\nThis boils down to finding the decimal representation of (n-1) + 1000 = n + 999 and expanding into a full palindrome:\\n\\nExample: Find the 113th palindrome of length 9.\\n\\nDetermine number of digits to look at: Round up(9 / 2) = 5 --> only look at first 5 digits.\\nFind number to add to get rid of leading zeros: 10^(5-1) = 10000\\nUse formula: (113 - 1) + 10000 = 10112\\nExpanded into palindrome: 101121101\\nOn a side note, this algorithm could also be generalized to finding the nth palindrome of any ordered set of symbols (or alphabet).\\n\\nGeneralized algorithm:\\n\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nReference: https://stackoverflow.com/questions/11925840/how-to-calculate-nth-n-digit-palindrome-efficiently\\n\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        long maxNumber = 0;\\n        for(int i=0;i<intLength;i++){\\n            maxNumber = maxNumber*10+9;\\n        }\\n        for(int i=0;i<n;i++){\\n            int nth = queries[i]; \\n            int k = intLength;\\n            long temp = ((k&1) == 1) ? (k / 2) : (k/2 - 1);\\n            long palin = (long)Math.pow(10,temp);\\n            \\n            palin += nth - 1;\\n            temp = palin;\\n            if ((k&1)==1){\\n                palin/=10;\\n            }\\n        \\n            while(palin>0){\\n                temp  = temp*10 + palin%10;\\n                palin/=10;\\n            }\\n            if(maxNumber<temp || temp<0){\\n                temp = -1;\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\nPlease upvote if you find this helpful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        long maxNumber = 0;\\n        for(int i=0;i<intLength;i++){\\n            maxNumber = maxNumber*10+9;\\n        }\\n        for(int i=0;i<n;i++){\\n            int nth = queries[i]; \\n            int k = intLength;\\n            long temp = ((k&1) == 1) ? (k / 2) : (k/2 - 1);\\n            long palin = (long)Math.pow(10,temp);\\n            \\n            palin += nth - 1;\\n            temp = palin;\\n            if ((k&1)==1){\\n                palin/=10;\\n            }\\n        \\n            while(palin>0){\\n                temp  = temp*10 + palin%10;\\n                palin/=10;\\n            }\\n            if(maxNumber<temp || temp<0){\\n                temp = -1;\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887018,
                "title": "c-generate-palindromes",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n**Similar problems**:\\n* [479. Largest Palindrome Product (Hard)](https://leetcode.com/problems/largest-palindrome-product/)\\n* [866. Prime Palindrome (Medium)](https://leetcode.com/problems/prime-palindrome/)\\n* [906. Super Palindromes (Hard)](https://leetcode.com/problems/super-palindromes/)\\n* [2081. Sum of k-Mirror Numbers (Hard)](https://leetcode.com/problems/sum-of-k-mirror-numbers/)\\n\\n## Solution 1.\\n\\nLet `half` be the first half of the palindrome. The range of it is `begin = 10^((len-1)/2)` (inclusive) to `end = 10^((len+1)/2)` (exclusive).\\n\\nFor a given `rank = Q[i]`, `half = begin + Q[i] - 1`. We can use `getPalindrome` helper function to generate the palindrome.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-palindrome-with-fixed-length/\\n// Author: github.com/lzl124631x\\n// Time: O(QL)\\n// Space: O(1) extra space\\nclass Solution {\\n    long getPalindrome(long half, bool odd) {\\n        long pal = half;\\n        if (odd) half /= 10;\\n        for (; half; half /= 10) pal = pal * 10 + half % 10;\\n        return pal;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int len) {\\n        long begin = pow(10L, (len - 1) / 2), end = pow(10L, (len + 1) / 2);\\n        vector<long long> ans(Q.size(), -1);\\n        for (int i = 0; i < Q.size(); ++i) {\\n            long half = begin + Q[i] - 1;\\n            if (half < end) ans[i] = getPalindrome(half, len % 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-palindrome-with-fixed-length/\\n// Author: github.com/lzl124631x\\n// Time: O(QL)\\n// Space: O(1) extra space\\nclass Solution {\\n    long getPalindrome(long half, bool odd) {\\n        long pal = half;\\n        if (odd) half /= 10;\\n        for (; half; half /= 10) pal = pal * 10 + half % 10;\\n        return pal;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int len) {\\n        long begin = pow(10L, (len - 1) / 2), end = pow(10L, (len + 1) / 2);\\n        vector<long long> ans(Q.size(), -1);\\n        for (int i = 0; i < Q.size(); ++i) {\\n            long half = begin + Q[i] - 1;\\n            if (half < end) ans[i] = getPalindrome(half, len % 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887508,
                "title": "simple-pattern-recognition-with-explanation",
                "content": "If we have a string s of length k and string t which is reverse of s\\nthen we can make a palindrome of size of 2*k and 2*k-1 ( if we leave last character of s will adding t to s)\\nLet s=\"aab\" then t=\"baa\" and k=3\\npalindrome of length of 6 is \"aabbaa\" which is s+t\\npalindrome of length of 5 is \"aabaa\" which is s+t.substr(1)\\n\\n*Complexity*\\n\\nTime O(n)\\nSpace O(n) \\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        int k=(l+1)/2,start=pow(10,k-1),end=pow(10,k)-1;\\n        vector<long long> A;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=start+q[i]-1;     //Since the palindromes are in order \\'a\\' is the half palindeome of the required palindrome \\n            if(a>end)               //We want the number of length \\'k\\', if it crosses the length \\'k\\' then our output will be \\'-1\\'\\n            {\\n                A.push_back(-1);\\n                continue;\\n            }\\n            string s=to_string(a),t=s;\\n            reverse(t.begin(),t.end());\\n            if(l%2==0)\\n            {\\n                s+=t;               //Number is \"321\" then palindrome of even length will be \"321\" \"123\"\\n                A.push_back(stoll(s));\\n            }\\n            else\\n            {\\n                s+=t.substr(1);     //Number is \"321\" then palindrome of odd length will be \"321\" \"_23\"\\n                A.push_back(stoll(s));\\n            }\\n        }\\n        return A;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        int k=(l+1)/2,start=pow(10,k-1),end=pow(10,k)-1;\\n        vector<long long> A;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=start+q[i]-1;     //Since the palindromes are in order \\'a\\' is the half palindeome of the required palindrome \\n            if(a>end)               //We want the number of length \\'k\\', if it crosses the length \\'k\\' then our output will be \\'-1\\'\\n            {\\n                A.push_back(-1);\\n                continue;\\n            }\\n            string s=to_string(a),t=s;\\n            reverse(t.begin(),t.end());\\n            if(l%2==0)\\n            {\\n                s+=t;               //Number is \"321\" then palindrome of even length will be \"321\" \"123\"\\n                A.push_back(stoll(s));\\n            }\\n            else\\n            {\\n                s+=t.substr(1);     //Number is \"321\" then palindrome of odd length will be \"321\" \"_23\"\\n                A.push_back(stoll(s));\\n            }\\n        }\\n        return A;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888763,
                "title": "java-solution-highly-commented-readable-easy-understanding",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int n) {\\n        long[] ans = new long[queries.length];\\n        \\n        int halfLength = (n+1)/2; //why n+1 because of odd length numbers\\n        \\n        long start = (long)Math.pow(10,halfLength-1);   //this you need to figure it out by taking example like n = 4\\n        long end = (long)Math.pow(10,halfLength)-1;     //this you need to figure it out\\n       \\n      long total = end-start+1;\\n      for(int i=0;i<queries.length;i++){\\n         if(queries[i]<=total){\\n             \\n             String left = Long.toString(start+queries[i]-1);   //little bitch trick\\n             \\n            StringBuilder temp = new StringBuilder(left);\\n             String right = temp.reverse().toString();\\n             \\n             //this to handling for odd strings example for 4 -> 1001 but for 3 also it is 1001\\n             //but we don\\'t want 1001 for 3 int length instead we want 101 so we have to remove o from right string which this formula likely to do\\n             ans[i] = Long.parseLong(left+right.substring(n%2));\\n             \\n         }\\n          else\\n             ans[i] = -1;\\n      }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int n) {\\n        long[] ans = new long[queries.length];\\n        \\n        int halfLength = (n+1)/2; //why n+1 because of odd length numbers\\n        \\n        long start = (long)Math.pow(10,halfLength-1);   //this you need to figure it out by taking example like n = 4\\n        long end = (long)Math.pow(10,halfLength)-1;     //this you need to figure it out\\n       \\n      long total = end-start+1;\\n      for(int i=0;i<queries.length;i++){\\n         if(queries[i]<=total){\\n             \\n             String left = Long.toString(start+queries[i]-1);   //little bitch trick\\n             \\n            StringBuilder temp = new StringBuilder(left);\\n             String right = temp.reverse().toString();\\n             \\n             //this to handling for odd strings example for 4 -> 1001 but for 3 also it is 1001\\n             //but we don\\'t want 1001 for 3 int length instead we want 101 so we have to remove o from right string which this formula likely to do\\n             ans[i] = Long.parseLong(left+right.substring(n%2));\\n             \\n         }\\n          else\\n             ans[i] = -1;\\n      }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887453,
                "title": "detailed-explanation-with-comments-easy-solution",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        //in length intLength only (intLength+1)/2 palindromes present\\n        \\n        //e.g. in 4 length (range between 1000 to 9999) only (90 substring present)\\n        //as in given example 1001, 1111, 1221, 1331, 1441, 1551,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only 4/2 length or (4+1)/2)\\n        \\n        //e.g. in 3 length (range between 100 to 999) only (90 substring present)\\n        //as in given example 101, 111, 121, 131, 141, 151,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only (3+1)/2 length)\\n        \\n        //bcz palindrome is made of left substring mirror to right substring\\n        //so we care about first half and we can made second half from first half easily\\n        \\n        // intLength is 4 or 3 we get palindrome_present=2 (we care about)\\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        \\n        \\n        for(int q:queries){\\n            \\n            //if queries[ith] is within the bound\\n            //r-l+1 because 10 to 99 we have all the palindrome (in total we have 99-10 +1)\\n            if(q<=(r-l+1)){\\n                \\n                //first half is the minimum value in range (which is l) + query number -1\\n                //-1 bcz we have l (10) number palindrome also\\n                String left_half=Long.toString(l+q-1);\\n                \\n                //second half is just mirror image (01)\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                \\n                //now for intLength 4 we have (1001) and 3 we have (1001)\\n                //we don\\'t need middle value (right half 0 index) if intLength is odd\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        //in length intLength only (intLength+1)/2 palindromes present\\n        \\n        //e.g. in 4 length (range between 1000 to 9999) only (90 substring present)\\n        //as in given example 1001, 1111, 1221, 1331, 1441, 1551,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only 4/2 length or (4+1)/2)\\n        \\n        //e.g. in 3 length (range between 100 to 999) only (90 substring present)\\n        //as in given example 101, 111, 121, 131, 141, 151,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only (3+1)/2 length)\\n        \\n        //bcz palindrome is made of left substring mirror to right substring\\n        //so we care about first half and we can made second half from first half easily\\n        \\n        // intLength is 4 or 3 we get palindrome_present=2 (we care about)\\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        \\n        \\n        for(int q:queries){\\n            \\n            //if queries[ith] is within the bound\\n            //r-l+1 because 10 to 99 we have all the palindrome (in total we have 99-10 +1)\\n            if(q<=(r-l+1)){\\n                \\n                //first half is the minimum value in range (which is l) + query number -1\\n                //-1 bcz we have l (10) number palindrome also\\n                String left_half=Long.toString(l+q-1);\\n                \\n                //second half is just mirror image (01)\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                \\n                //now for intLength 4 we have (1001) and 3 we have (1001)\\n                //we don\\'t need middle value (right half 0 index) if intLength is odd\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886921,
                "title": "generate-palindromes-by-splitting-in-half",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ogLength = intLength\\n        isOdd = intLength & 1\\n        if isOdd:\\n            intLength += 1\\n        k = intLength // 2\\n        k = 10 ** (k - 1)\\n        op = []\\n        for q in queries:\\n            pal = str(k + q - 1)\\n            if isOdd:\\n                pal += pal[::-1][1:]\\n            else:\\n                pal += pal[::-1]\\n            if len(pal) == ogLength:\\n                op.append(int(pal))\\n            else:\\n                op.append(-1)\\n        return op\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ogLength = intLength\\n        isOdd = intLength & 1\\n        if isOdd:\\n            intLength += 1\\n        k = intLength // 2\\n        k = 10 ** (k - 1)\\n        op = []\\n        for q in queries:\\n            pal = str(k + q - 1)\\n            if isOdd:\\n                pal += pal[::-1][1:]\\n            else:\\n                pal += pal[::-1]\\n            if len(pal) == ogLength:\\n                op.append(int(pal))\\n            else:\\n                op.append(-1)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886956,
                "title": "python-simple-and-straightforward",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n        \\n        result = []\\n        \\n        for i in queries:\\n            result.append(self.generatePalindrome(intLength, i))\\n        \\n        return result\\n    \\n    def generatePalindrome(self, length, num):\\n        # index start from 0\\n\\t\\t# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0\\n\\t\\t# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1\\n        index = num -1\\n        \\n\\t\\t# if the length is even\\n\\t\\t# we only think about the fisrt half of digits\\n        if length % 2 == 0:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2 -1))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                cur = cur + cur[::-1]\\n                cur = int(cur)\\n                return cur\\n\\t\\t\\t\\t\\n        # if the length is odd\\n\\t\\t# we consider first (length // 2 + 1) digits\\n        else:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                temp = str(cur)[:-1]\\n                cur = cur + temp[::-1]\\n                cur = int(cur)\\n                return cur",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n        \\n        result = []\\n        \\n        for i in queries:\\n            result.append(self.generatePalindrome(intLength, i))\\n        \\n        return result\\n    \\n    def generatePalindrome(self, length, num):\\n        # index start from 0\\n\\t\\t# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0\\n\\t\\t# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1\\n        index = num -1\\n        \\n\\t\\t# if the length is even\\n\\t\\t# we only think about the fisrt half of digits\\n        if length % 2 == 0:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2 -1))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                cur = cur + cur[::-1]\\n                cur = int(cur)\\n                return cur\\n\\t\\t\\t\\t\\n        # if the length is odd\\n\\t\\t# we consider first (length // 2 + 1) digits\\n        else:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                temp = str(cur)[:-1]\\n                cur = cur + temp[::-1]\\n                cur = int(cur)\\n                return cur",
                "codeTag": "Java"
            },
            {
                "id": 1891452,
                "title": "simple-and-intuitive-pattern-based-c-solution",
                "content": "consider this, suppose you have 5 empty cells like this,\\n| __ | __ | __ | __ | __ |\\n| --- | --- | --- | --- | --- |\\n\\nhow many 5 digit numbers can you get (repetition of digits allowed)?\\nyou have 9 options (1-9) to put in first cell,\\n10 options (0-9) to put in from second to last cell.\\nso,\\n\\n| 9 | 10 | 10 | 10 | 10 |\\n| --- | --- | --- | --- | --- |\\n\\ni.e., you can get 90000 numbers (from 10000 to 99999) of 5 digits.\\n\\nNow, if I ask you to just concatenate these number reversely to themselves, so a number like, say,\\n\\n```48317``` will become ```4831771384```\\n\\nisn\\'t the new number a palindrome?\\n\\n___\\n\\nUsing the same logic, now consider this\\nif the length of palindrome number is \\'x\\', then the total number of palindromes with \\'x\\' length are as follows:\\n\\n| Length of the number | Total number of Palindromes possible |\\n| --- | --- |\\n| 1 | 9 |\\n| 2 | 9 |\\n| 3 | 90 |\\n| 4 | 90 |\\n| 5 | 900 |\\n| 6 | 900 |\\n| 7 | 9000 |\\n| 8 | 9000 |\\n| 9 | 90000 |\\n| 10 | 90000 |\\n\\nHow do we get the above table?\\nIf you don\\'t get it, its fine. just scratch your head a bit, that\\'s how your PSA will improve.\\n\\nAnyway, if you still don\\'t get it, here is the explanation.\\n\\nLet\\'s say the given length is 5, so we only need to consider first 3 cell. After that, we are only repeating the leading cells.\\nSo, for a given length of 5 digits > the possible number of palindromes are > 9* 10* 10.\\nThis will clear it up..\\n\\n| x1 | x2 | x3 | x2 | x1 |\\n| --- | --- | --- | --- | --- |\\n\\n**OR** if the length was 6, then also total possible palindromes would be 900 as,\\n\\n| x1 | x2 | x3 | x3 | x2 | x1 |\\n| --- | --- | --- | --- | --- | --- |\\n\\n___\\n\\n\\n**NOW** moving on to the next part,\\nconsider the first and last palindrome with respect a specified length:\\n\\n| Length of the number | Total number of Palindromes possible | First Palindrome | Second Palindrome |\\n| --- | --- | --- | --- |\\n| 1 | 9 | 1 | 9 |\\n| 2 | 9 | 11 | 99 |\\n| 3 | 90 | 101 | 999 |\\n| 4 | 90 | 1001 | 9999 |\\n| 5 | 900 | 10001 | 99999 |\\n| 6 | 900 | 100001 | 999999 |\\n| 7 | 9000 | 1000001 | 9999999 |\\n| 8 | 9000 | 10000001 | 99999999 |\\n| 9 | 90000 | 100000001 | 999999999 |\\n| 10 | 90000 | 1000000001 | 9999999999 |\\n\\nAlso, observe that, let\\'s say for len==5, I am considering first 3 digits to generate a palindrome.\\nAnd the first 3 digits for the first palindrome would be: 100\\nfor the next, 101,\\nthen 102, 103, 104..and so on.\\ntherefore, for the nth palindrome >> 100 + (n-1)\\n\\nVoila !\\nAlgo is ready..\\n\\n\\n**Based** on the above logic, the code is as follows:\\n\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll nthpalindrome(int n, int len, int exp){\\n        \\n        ll n1 = pow(10,exp);\\n        ll n2 = n1+(n-1);\\n        \\n        string s1 = to_string(n2);\\n        string s2 = \"\";\\n        \\n        for(int i=1; i<=(len/2); i++){\\n            s2+=s1[i-1];\\n        }\\n        \\n        reverse(s2.begin(), s2.end());\\n        \\n        s1=s1+s2;\\n        \\n        ll ans = stoll(s1);\\n        \\n        return ans;\\n    }\\n    \\n    \\npublic:\\n    vector<ll> kthPalindrome(vector<int>& v, int len) {\\n        int n = v.size();\\n        vector<ll> ans(n,0);\\n        int exp;\\n        \\n        if(len%2){\\n            exp=len/2;\\n        }else{\\n            exp=len/2-1;\\n        }\\n        \\n        int lim = 9*pow(10,exp);\\n        \\n        for(int i=0; i<n; i++){\\n            int nth = v[i];\\n            if(nth>lim) ans[i]=-1;\\n            else ans[i]=nthpalindrome(nth,len,exp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```48317```\n```4831771384```\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll nthpalindrome(int n, int len, int exp){\\n        \\n        ll n1 = pow(10,exp);\\n        ll n2 = n1+(n-1);\\n        \\n        string s1 = to_string(n2);\\n        string s2 = \"\";\\n        \\n        for(int i=1; i<=(len/2); i++){\\n            s2+=s1[i-1];\\n        }\\n        \\n        reverse(s2.begin(), s2.end());\\n        \\n        s1=s1+s2;\\n        \\n        ll ans = stoll(s1);\\n        \\n        return ans;\\n    }\\n    \\n    \\npublic:\\n    vector<ll> kthPalindrome(vector<int>& v, int len) {\\n        int n = v.size();\\n        vector<ll> ans(n,0);\\n        int exp;\\n        \\n        if(len%2){\\n            exp=len/2;\\n        }else{\\n            exp=len/2-1;\\n        }\\n        \\n        int lim = 9*pow(10,exp);\\n        \\n        for(int i=0; i<n; i++){\\n            int nth = v[i];\\n            if(nth>lim) ans[i]=-1;\\n            else ans[i]=nthpalindrome(nth,len,exp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104684,
                "title": "detail-explanation-for-any-language-code-in-cpp",
                "content": "**First two approaches are brute and takes more time**\\n\\n**Initial Brute Force approcah**\\n\\n```\\nIn brute force we generate a list of numbers of its size starting from pow(10,size) and \\nstore all palindromes number in that list and return that number\\n\\nTime Complexity - O( All Numbers of Size k* k )\\nMemory - O( All palindromes present in that Numbers )\\n```\\n\\n**Improved version than Brute Force**\\n\\n```\\nJust finding first palindrome and applying next palindrome logic to it\\nin that manner find all palindromes store and return it.\\n```\\n\\n**Simple and best Observing pattern**\\n\\n```\\n here we will use the fact that palindrome is basically the concatenation of half of the string\\n by reversing it.\\n i.e abba -> ab + reverse(ab);\\n hence we will generate the palindrome of (intLength+1)/2 (first part ab)      \\n for both odd and even case.\\n \\n Then in case of even length we will reverse string and return it \\n In case of odd we will leave One as for odd i.e abdba -> ab + d + rev(ab)\\n \\n which is explained through example \\n \\n intLength = 3\\n \\n half= (3+1)/2 = 2\\n \\n here starting and ending implies range of ab\\n \\n so starting = 10^(half-1) = 10^1=10\\n ending =10^(half) -1 = 99\\n \\n now  to get particular nth number we have formula (starting+n-1)\\n \\n if n= 2  so that n element is 10+2-1=11\\n \\n now convert it to string s=11\\n \\n as k is even now rev=11\\n \\n now return s+rev = 11+11=1111\\n \\n -1 Case :\\n      This case occurs if N index is greater or No k lenght palindrome is present at that index\\n\\t  it is checked by using n>(ending-starting+1) range\\n```\\n\\n\\n```\\n#define all(x) x.begin(),x.end()\\n\\nclass Solution {\\npublic:\\n    long long nthpalindrome(long long n,int k){\\n        \\n\\t\\t// calculating power to find starting index\\n        int half = (k+1)>>1;\\n        \\n\\t\\t// starting i.e 10\\n        int starting = pow(10,half-1);\\n        \\n\\t\\t// ending i.e 99\\n        int ending = pow(10,half)-1;\\n        \\n\\t\\t// if at nth index a palindrome of lenght K no exist\\n        if( n>(ending-starting+1) )\\n            return -1;\\n        \\n\\t\\t// convert to string\\n        string front = to_string(starting+n-1);\\n        \\n        string end;\\n        \\n        if( k%2 ){\\n\\t\\t// for odd case we leave last one i.e front= 123\\n\\t\\t// end = rev(12)  so ans = 123+ rev(12)= 123+21\\n            end=front.substr(0,half-1);\\n            reverse(all(end));\\n        }else{\\n\\t\\t// In case of even just reverse it\\n            end=front.substr(0,half);\\n            reverse(all(end));\\n        }\\n        \\n        \\n        return stoll(front+end);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        \\n        for( int x: queries )\\n            ans.push_back( nthpalindrome(x,intLength) );\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Fell free to ask doubts and thank you happy coding***\\n***Please upvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nIn brute force we generate a list of numbers of its size starting from pow(10,size) and \\nstore all palindromes number in that list and return that number\\n\\nTime Complexity - O( All Numbers of Size k* k )\\nMemory - O( All palindromes present in that Numbers )\\n```\n```\\nJust finding first palindrome and applying next palindrome logic to it\\nin that manner find all palindromes store and return it.\\n```\n```\\n here we will use the fact that palindrome is basically the concatenation of half of the string\\n by reversing it.\\n i.e abba -> ab + reverse(ab);\\n hence we will generate the palindrome of (intLength+1)/2 (first part ab)      \\n for both odd and even case.\\n \\n Then in case of even length we will reverse string and return it \\n In case of odd we will leave One as for odd i.e abdba -> ab + d + rev(ab)\\n \\n which is explained through example \\n \\n intLength = 3\\n \\n half= (3+1)/2 = 2\\n \\n here starting and ending implies range of ab\\n \\n so starting = 10^(half-1) = 10^1=10\\n ending =10^(half) -1 = 99\\n \\n now  to get particular nth number we have formula (starting+n-1)\\n \\n if n= 2  so that n element is 10+2-1=11\\n \\n now convert it to string s=11\\n \\n as k is even now rev=11\\n \\n now return s+rev = 11+11=1111\\n \\n -1 Case :\\n      This case occurs if N index is greater or No k lenght palindrome is present at that index\\n\\t  it is checked by using n>(ending-starting+1) range\\n```\n```\\n#define all(x) x.begin(),x.end()\\n\\nclass Solution {\\npublic:\\n    long long nthpalindrome(long long n,int k){\\n        \\n\\t\\t// calculating power to find starting index\\n        int half = (k+1)>>1;\\n        \\n\\t\\t// starting i.e 10\\n        int starting = pow(10,half-1);\\n        \\n\\t\\t// ending i.e 99\\n        int ending = pow(10,half)-1;\\n        \\n\\t\\t// if at nth index a palindrome of lenght K no exist\\n        if( n>(ending-starting+1) )\\n            return -1;\\n        \\n\\t\\t// convert to string\\n        string front = to_string(starting+n-1);\\n        \\n        string end;\\n        \\n        if( k%2 ){\\n\\t\\t// for odd case we leave last one i.e front= 123\\n\\t\\t// end = rev(12)  so ans = 123+ rev(12)= 123+21\\n            end=front.substr(0,half-1);\\n            reverse(all(end));\\n        }else{\\n\\t\\t// In case of even just reverse it\\n            end=front.substr(0,half);\\n            reverse(all(end));\\n        }\\n        \\n        \\n        return stoll(front+end);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        \\n        for( int x: queries )\\n            ans.push_back( nthpalindrome(x,intLength) );\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887591,
                "title": "c-simple-solution-easy-to-understand-with-comments-and-explaination",
                "content": "We need to create the first half of pallindrome first and then the second half by appending the first half in it from rigth to left.\\nFor this we should observe that max pallindrome length for given len will be 10^len, since we are going to create the first half therefore we need to take half of the len , i.e 10^(len/2).\\nAlso the middle digit will be always (query[i-1]-1) for each pallindrome so we need to add it and we get our half pallindrome. Using this we can create the full pallindrome.\\n\\nUPVOTE  if you like it!!\\n\\n```\\nclass Solution {\\npublic:\\n    string create(long long q, long long len)\\n    {\\n        long long k;\\n        \\n        if(len%2 == 0)\\n            k = len/2-1;\\n        else\\n            k=len/2;\\n        \\n        long long half_pall;\\n        \\n\\t\\t//creating half pallindrome by raising 10 to power of len/2\\n\\t\\thalf_pall = pow(10,k);\\n        half_pall+=(q-1);\\n        \\n        string full_pall = to_string(half_pall);\\n        \\n        if(len%2!=0)\\n        half_pall/=10;\\n        \\n\\t\\t//appending half pallindrome to itself in reverse to get full pallindrome\\n        while(half_pall > 0)\\n        {\\n            full_pall+=to_string(half_pall%10);\\n            half_pall/=10;\\n        }\\n\\t\\t\\n\\t\\t//if ans is possible then return string else return -1\\n        if(full_pall.size() == len)\\n            return full_pall;\\n        else\\n            return \"-1\";\\n        \\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        vector<long long> ans;\\n        \\n        for(int i=0 ;i<q.size(); i++)\\n        {\\n\\t\\t\\t//changing string returned by function to long long \\n            long long temp = stoll(create(q[i],len));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string create(long long q, long long len)\\n    {\\n        long long k;\\n        \\n        if(len%2 == 0)\\n            k = len/2-1;\\n        else\\n            k=len/2;\\n        \\n        long long half_pall;\\n        \\n\\t\\t//creating half pallindrome by raising 10 to power of len/2\\n\\t\\thalf_pall = pow(10,k);\\n        half_pall+=(q-1);\\n        \\n        string full_pall = to_string(half_pall);\\n        \\n        if(len%2!=0)\\n        half_pall/=10;\\n        \\n\\t\\t//appending half pallindrome to itself in reverse to get full pallindrome\\n        while(half_pall > 0)\\n        {\\n            full_pall+=to_string(half_pall%10);\\n            half_pall/=10;\\n        }\\n\\t\\t\\n\\t\\t//if ans is possible then return string else return -1\\n        if(full_pall.size() == len)\\n            return full_pall;\\n        else\\n            return \"-1\";\\n        \\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        vector<long long> ans;\\n        \\n        for(int i=0 ;i<q.size(); i++)\\n        {\\n\\t\\t\\t//changing string returned by function to long long \\n            long long temp = stoll(create(q[i],len));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887017,
                "title": "easy-approach-java",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887458,
                "title": "simplest-solution-o-queries-length-o-1-space-simple-maths",
                "content": "Approach:\\n![image](https://assets.leetcode.com/users/images/95ecc5b0-ea8d-4cd0-9f1d-397409f25b09_1648358183.97771.jpeg)\\n\\n\\nExample: n=69, k=3\\n\\n(n-1)  = 68;\\nadding 1\\n(n-1) + pow(10,k/2) = 68+10 = 78 (halfNum)\\n\\nans = 7887\\n\\nn = 90, k=4\\nn-1 = 89;\\npow(10,k/2-1) = 89+10 = 99 (halfNum)\\nans = 9999\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(long long n, long long k) {\\n        \\n        if(n<=9 && k==1)\\n            return n;\\n        \\n        if(9*pow(10,(k-1)/2)<n)\\n            return -1;\\n       \\n        long long halfNum = (n-1) + pow(10,(k-1)/2);\\n        long long num = halfNum;\\n        if(k&1)\\n            halfNum /= 10;\\n        \\n        while(halfNum>0) {\\n            num = num*10+halfNum%10;\\n            halfNum /= 10;\\n        }\\n        \\n        return num;\\n            \\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for(int n:queries) {\\n            ans.push_back(solve(n,intLength));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nplease upvote, if find helpful...",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(long long n, long long k) {\\n        \\n        if(n<=9 && k==1)\\n            return n;\\n        \\n        if(9*pow(10,(k-1)/2)<n)\\n            return -1;\\n       \\n        long long halfNum = (n-1) + pow(10,(k-1)/2);\\n        long long num = halfNum;\\n        if(k&1)\\n            halfNum /= 10;\\n        \\n        while(halfNum>0) {\\n            num = num*10+halfNum%10;\\n            halfNum /= 10;\\n        }\\n        \\n        return num;\\n            \\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for(int n:queries) {\\n            ans.push_back(solve(n,intLength));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724331,
                "title": "java-solution-beginner-friendly-half-of-the-palindrome-length",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tpublic long[] kthPalindrome(int[] queries, int l) {\\n\\t\\t\\t   long res[] = new long[queries.length];\\n\\t\\t\\t\\tint pw = l%2==0? (l/2)-1 : l/2;\\n\\t\\t\\t\\tint start =(int) Math.pow(10,pw);  //lower bound of the number to be palindrome\\n\\t\\t\\t\\tint end = ((int) Math.pow(10,pw+1))-1; //upper bound of the number to be palindrome\\n\\t\\t\\t\\t String ans = \"\";\\n\\n\\t\\t\\t\\tfor(int i=0; i<queries.length; i++){\\n\\t\\t\\t\\t\\tif(queries[i]<=end-start+1)  // for checking that does it exist in the range of upper and lower bound\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans = Integer.toString(start + (queries[i]-1));// coverting int to string by using function\\n\\t\\t\\t\\t\\t\\tString rev = reverse(ans,l-ans.length());\\n\\t\\t\\t\\t\\t\\tans = ans +rev;\\n\\n\\t\\t\\t\\t\\t\\tif(palindrome(ans)){\\n\\t\\t\\t\\t\\t\\t\\tlong r = Long. parseLong(ans);// for converting string to long\\n\\t\\t\\t\\t\\t\\t\\tres[i]=r;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tres[i]=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t return res;\\n\\t\\t\\t}\\n\\n\\t// for creating the reverse of the string\\n\\t\\t\\tstatic String reverse(String rev,int n){\\n\\t\\t\\t\\tString a = \"\";\\n\\t\\t\\t\\tfor (int i=0; i<n; i++) \\n\\t\\t\\t  { \\n\\t\\t\\t\\tchar ch= rev.charAt(i); \\n\\t\\t\\t\\ta= ch+a; \\n\\t\\t\\t  } \\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}\\n\\n\\t// for checking whether the string is palindrome or not\\n\\t\\t\\tstatic boolean palindrome(String ans){\\n\\t\\t\\t\\tString reve = \"\";\\n\\t\\t\\t\\tfor(int i=0;i<ans.length();i++){\\n\\t\\t\\t\\t\\treve =ans.charAt(i)+reve;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn reve.equals(ans);\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic long[] kthPalindrome(int[] queries, int l) {\\n\\t\\t\\t   long res[] = new long[queries.length];\\n\\t\\t\\t\\tint pw = l%2==0? (l/2)-1 : l/2;\\n\\t\\t\\t\\tint start =(int) Math.pow(10,pw);  //lower bound of the number to be palindrome\\n\\t\\t\\t\\tint end = ((int) Math.pow(10,pw+1))-1; //upper bound of the number to be palindrome\\n\\t\\t\\t\\t String ans = \"\";\\n\\n\\t\\t\\t\\tfor(int i=0; i<queries.length; i++){\\n\\t\\t\\t\\t\\tif(queries[i]<=end-start+1)  // for checking that does it exist in the range of upper and lower bound\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans = Integer.toString(start + (queries[i]-1));// coverting int to string by using function\\n\\t\\t\\t\\t\\t\\tString rev = reverse(ans,l-ans.length());\\n\\t\\t\\t\\t\\t\\tans = ans +rev;\\n\\n\\t\\t\\t\\t\\t\\tif(palindrome(ans)){\\n\\t\\t\\t\\t\\t\\t\\tlong r = Long. parseLong(ans);// for converting string to long\\n\\t\\t\\t\\t\\t\\t\\tres[i]=r;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2178890,
                "title": "python3-math-solution-with-explanation",
                "content": "Taking into account the palindrome property, we want to work with only half of the digits, and get the rest as the same half, but in reverse order. For this purpose, we have a **helper** function, in which for even numbers the order of the left side is changed to receive the right part, and for odd numbers the last digit is removed and the order is also changed.\\nAlso, we want to precompute the number of palindromes for a given length **intLength** to avoid the case where the ordinal exceeds the possible number of palindromes.\\nRuntime leaves a lot to be desired, but hopefully the explanations will be helpful.\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        limit = [10, 19]\\n\\n        for i in range(3, intLength + 1):\\n            limit.append(limit[-1] + 9 * (10 ** int((i - 1) / 2)))\\n        \\n        def helper(num):\\n            left = str(num)\\n            \\n            if intLength % 2 == 0:\\n                right = str(num)[::-1]\\n            else:\\n                right = str(num)[:-1][::-1]\\n            \\n            return int(left + right)\\n\\t\\t         \\n        if intLength % 2 == 0:\\n            digits = intLength // 2 - 1\\n        else:\\n            digits = intLength // 2\\n\\t\\t\\n        for i in queries:\\n            if i <= limit[intLength - 1]:\\n                half = 10 ** digits + i - 1\\n                tmp = helper(half)\\n                \\n                if len(str(tmp)) <= intLength:\\n                    ans.append(tmp)\\n                else:\\n                    ans.append(-1)\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        limit = [10, 19]\\n\\n        for i in range(3, intLength + 1):\\n            limit.append(limit[-1] + 9 * (10 ** int((i - 1) / 2)))\\n        \\n        def helper(num):\\n            left = str(num)\\n            \\n            if intLength % 2 == 0:\\n                right = str(num)[::-1]\\n            else:\\n                right = str(num)[:-1][::-1]\\n            \\n            return int(left + right)\\n\\t\\t         \\n        if intLength % 2 == 0:\\n            digits = intLength // 2 - 1\\n        else:\\n            digits = intLength // 2\\n\\t\\t\\n        for i in queries:\\n            if i <= limit[intLength - 1]:\\n                half = 10 ** digits + i - 1\\n                tmp = helper(half)\\n                \\n                if len(str(tmp)) <= intLength:\\n                    ans.append(tmp)\\n                else:\\n                    ans.append(-1)\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012405,
                "title": "easily-explained-each-step",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* here we will use the fact that palindrome is basically the concatenation of half of the string by reversing it.\\n    i.e abba -> ab + reverse(ab);\\n    hence we will generate the palindrome of intLength/2 or more conscisely (intLength+1)/2       for both odd and even case.\\n    Now we will define range by using simple formula i.e how many number can be formed using n digit-> pow(10,n-1);\\n    now for even length we will just reverse the formed string and concatenate it but for odd length we will take substring from length 1.\\n    i.e for abbba.only ba should be added.\\n    lastly if formed palindrome will be equal to original length then push it in ans else push -1;\\n    */\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n           vector<long long> result;\\n        long long start =  pow(10, (intLength+1)/2 - 1) ;\\n        \\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* here we will use the fact that palindrome is basically the concatenation of half of the string by reversing it.\\n    i.e abba -> ab + reverse(ab);\\n    hence we will generate the palindrome of intLength/2 or more conscisely (intLength+1)/2       for both odd and even case.\\n    Now we will define range by using simple formula i.e how many number can be formed using n digit-> pow(10,n-1);\\n    now for even length we will just reverse the formed string and concatenate it but for odd length we will take substring from length 1.\\n    i.e for abbba.only ba should be added.\\n    lastly if formed palindrome will be equal to original length then push it in ans else push -1;\\n    */\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n           vector<long long> result;\\n        long long start =  pow(10, (intLength+1)/2 - 1) ;\\n        \\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888574,
                "title": "simple-math-c",
                "content": "// simple c++\\n                   class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> v(queries.size());\\n        int po=(l+1)/2;\\n        long long tt=pow(10,po)-1;\\n        long long res=pow(10,po-1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long temp=res;\\n            temp+=(queries[i]-1);\\n            string s=to_string(temp);\\n            if((tt-res+1)<queries[i])\\n            {\\n                v[i]=-1;\\n                continue;\\n            }\\n            if(l%2==0)\\n            {\\n                string x,y;\\n                y=s;\\n                x=s;\\n                reverse(x.begin(),x.end());\\n                y=y+x;\\n                temp=stoll(y);\\n            v[i]=temp;\\n            }else{\\n                string x,y=s;\\n                x=s.substr(0,s.size()-1);\\n                reverse(x.begin(),x.end());\\n                y=y+x;\\n                temp=stoll(y);\\n            v[i]=temp;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> v(queries.size());\\n        int po=(l+1)/2;\\n        long long tt=pow(10,po)-1;\\n        long long res=pow(10,po-1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long temp=res;\\n            temp+=(queries[i]-1);\\n            string s=to_string(temp);\\n            if((tt-res+1)<queries[i])\\n            {\\n                v[i]=-1;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3169476,
                "title": "different-than-the-other-solutions-in-discussion-pattern-recognition",
                "content": "# Intuition\\ntaking c as the initial number and then reducing c and taking use of its modulud with 10.\\n\\n# Approach\\nBasically , here i first thought about maximum number of palindromes for a length n which will be 9 *10 ^(n-1/2) ( basically 9 bcoz we cant have number with terminal zeroes and 10^ power(n-1)/2 bcoz we can have 0 to 9 pairs of numbers making it 10 possible values). and now step by step we take modulo of c with 10 (lets say x) and then divide it by 10 untill it reaches 0 . So now we intialize our ans with x-1 or (x-1)(x-1) (if n is even) and then step by step we get values untill c becomes 0 we start appending it in pair for example if c=453 and n=7 then x =3 and later c=45 , so now x=5 , so at this point ans=525. and similarly ans=45254 but snce n=7, so final ans will be 104525401 but in case of n=8 , ans will be 14522541 and in case if n=5, 55255 (edge cases we have to add like if initial c has terminal 0 then x=9 )\\n\\n# Complexity\\n- Time complexity:\\nn*15 (where n is vector query size)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n\\n    long long int pow(int a,long long int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return (a*pow(a,n-1));\\n    }\\n    long long fun(long long int c,long long int n){\\n      \\n      long long int ans;\\n     long long  int f=(n-1)/2;\\n      if(c> (9* pow(10,f)) ){\\n          return -1;\\n      }\\n    long long   int d=c%10;\\n      c=c/10;\\n      long long int count=1;\\n     long long  int flag=0;\\n      if(d!=0){\\n          ans=d-1;\\n      }\\n      else if(d==0){\\n          ans=9;\\n          flag=1;\\n      }\\n      if(n%2==0){\\n          int e=ans*10+ans;\\n          ans=e;\\n          \\n          count++;\\n      }\\n      if(n==1){\\n         return (ans+1);        \\n      }\\n      if(n==2){\\n          return (ans+11);\\n      }\\n   \\n      while(count<n){\\n          if(c==0){\\n              d=0;\\n          }\\n          else if(c!=0){\\n             d=c%10;\\n             \\n          }\\n        \\n         \\n          if(c==0){\\n              int left=(n-count);\\n              left=left/2;\\n             \\n              ans=ans*pow(10,left)+1;\\n              \\n              count=count+left;\\n              \\n              d=pow(10,count+left-1)+ans;\\n              ans=d;\\n              return ans;\\n          }\\n        \\n          if(count==n-2){\\n              \\n            d=d+1;\\n            \\n          }\\n          \\n            if(flag==0){\\n                \\n           count++;\\n            \\n           ans=ans*10+d;\\n          \\n           count++;\\n           d=d*pow(10,count-1)+ans;\\n           ans=d;\\n           \\n            }\\n            else if(flag!=0){\\n               if(d==0){\\n                 d=9;\\n                  count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n                 \\n               }\\n               else if(d!=0){\\n                   \\n                   d=d-1;\\n                   flag=0;\\n                   count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n               }\\n\\n            }\\n          c=c/10;\\n           \\n      }\\n\\n\\n    return ans;\\n        \\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n     vector<long long> v;\\n\\n     long long int ans;\\n    \\n    long long  int n=intLength;\\n     \\n    long long  int i;\\n     for(i=0;i<queries.size();i++){\\n          \\n          v.push_back(fun(queries[i],intLength));\\n        \\n     }\\n\\n      return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n\\n    long long int pow(int a,long long int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return (a*pow(a,n-1));\\n    }\\n    long long fun(long long int c,long long int n){\\n      \\n      long long int ans;\\n     long long  int f=(n-1)/2;\\n      if(c> (9* pow(10,f)) ){\\n          return -1;\\n      }\\n    long long   int d=c%10;\\n      c=c/10;\\n      long long int count=1;\\n     long long  int flag=0;\\n      if(d!=0){\\n          ans=d-1;\\n      }\\n      else if(d==0){\\n          ans=9;\\n          flag=1;\\n      }\\n      if(n%2==0){\\n          int e=ans*10+ans;\\n          ans=e;\\n          \\n          count++;\\n      }\\n      if(n==1){\\n         return (ans+1);        \\n      }\\n      if(n==2){\\n          return (ans+11);\\n      }\\n   \\n      while(count<n){\\n          if(c==0){\\n              d=0;\\n          }\\n          else if(c!=0){\\n             d=c%10;\\n             \\n          }\\n        \\n         \\n          if(c==0){\\n              int left=(n-count);\\n              left=left/2;\\n             \\n              ans=ans*pow(10,left)+1;\\n              \\n              count=count+left;\\n              \\n              d=pow(10,count+left-1)+ans;\\n              ans=d;\\n              return ans;\\n          }\\n        \\n          if(count==n-2){\\n              \\n            d=d+1;\\n            \\n          }\\n          \\n            if(flag==0){\\n                \\n           count++;\\n            \\n           ans=ans*10+d;\\n          \\n           count++;\\n           d=d*pow(10,count-1)+ans;\\n           ans=d;\\n           \\n            }\\n            else if(flag!=0){\\n               if(d==0){\\n                 d=9;\\n                  count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n                 \\n               }\\n               else if(d!=0){\\n                   \\n                   d=d-1;\\n                   flag=0;\\n                   count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n               }\\n\\n            }\\n          c=c/10;\\n           \\n      }\\n\\n\\n    return ans;\\n        \\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n     vector<long long> v;\\n\\n     long long int ans;\\n    \\n    long long  int n=intLength;\\n     \\n    long long  int i;\\n     for(i=0;i<queries.size();i++){\\n          \\n          v.push_back(fun(queries[i],intLength));\\n        \\n     }\\n\\n      return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055374,
                "title": "python-simple-maths",
                "content": "\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        \\n        if intLength%2 == 0:\\n            l = (intLength//2) - 1\\n        else:\\n            l = (intLength//2)\\n            \\n        for i in queries:\\n            x = str(10**l + i-1)\\n            \\n            if intLength%2 == 0:\\n                x = x + x[::-1]\\n            else:\\n                x = x + x[::-1][1:]\\n                \\n            if len(x) == intLength:\\n                ans.append(x)\\n            else:\\n                ans.append(-1)\\n                \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        \\n        if intLength%2 == 0:\\n            l = (intLength//2) - 1\\n        else:\\n            l = (intLength//2)\\n            \\n        for i in queries:\\n            x = str(10**l + i-1)\\n            \\n            if intLength%2 == 0:\\n                x = x + x[::-1]\\n            else:\\n                x = x + x[::-1][1:]\\n                \\n            if len(x) == intLength:\\n                ans.append(x)\\n            else:\\n                ans.append(-1)\\n                \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2016117,
                "title": "javascript-half-reflection",
                "content": "**Intuition**\\n\\n```\\n# First 3 palindromes of 5-digits\\n`100`01, `101`01, `102`01\\n# Last 4 palindromes of 7-digits:\\n`9996`999, `9997`999, `9998`999, `9999`999\\n```\\nFrom above, we find out only **HALF digits** matter for making palindromes.\\n.\\nI\\'ll take `queries`=[5, 98], `intLength`=4 for example:\\n```\\nvar kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t// 1. We use FIRST 2 digits to create palindromes: Math.floor((3+1)/2)=2\\n    let digit=Math.floor((intLength+1)/2);\\n\\t\\n    for(let i=0; i<queries.length; i++){\\n\\t\\t// 2A. Get Nth 2-digits numbers: 10*(2-1)-1+[5,98]=[14,107]\\n        let helper=10**(digit-1)-1+queries[i];\\n\\t\\t// 2B. Digits checking: 107>=100, which is INVALID \\n        if(helper>=10**digit){output.push(-1)}\\n        else{\\n\\t\\t\\tlet m=intLength-digit;\\n\\t\\t\\t// 3A. We still need m digits for REFLECTION: 14=>[\"1\",\"4\"]=>\"41\"\\n            let add=helper.toString().substr(0, m).split(\"\").reverse().join(\"\");\\n\\t\\t\\t// 3B. Multiply 10**m for reversed digits: 14=>1400=>1441 \\n            helper=helper*10**m+add*1;\\n            output.push(helper);\\n        }\\n    }\\n    return output; // [1441,-1]\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n# First 3 palindromes of 5-digits\\n`100`01, `101`01, `102`01\\n# Last 4 palindromes of 7-digits:\\n`9996`999, `9997`999, `9998`999, `9999`999\\n```\n```\\nvar kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t// 1. We use FIRST 2 digits to create palindromes: Math.floor((3+1)/2)=2\\n    let digit=Math.floor((intLength+1)/2);\\n\\t\\n    for(let i=0; i<queries.length; i++){\\n\\t\\t// 2A. Get Nth 2-digits numbers: 10*(2-1)-1+[5,98]=[14,107]\\n        let helper=10**(digit-1)-1+queries[i];\\n\\t\\t// 2B. Digits checking: 107>=100, which is INVALID \\n        if(helper>=10**digit){output.push(-1)}\\n        else{\\n\\t\\t\\tlet m=intLength-digit;\\n\\t\\t\\t// 3A. We still need m digits for REFLECTION: 14=>[\"1\",\"4\"]=>\"41\"\\n            let add=helper.toString().substr(0, m).split(\"\").reverse().join(\"\");\\n\\t\\t\\t// 3B. Multiply 10**m for reversed digits: 14=>1400=>1441 \\n            helper=helper*10**m+add*1;\\n            output.push(helper);\\n        }\\n    }\\n    return output; // [1441,-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012193,
                "title": "java-concise-solution-explained",
                "content": "Here is a list of palindrome:\\n```\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515\\n```\\nDid you see any pattern? the first two digits went from 10, 11, to 51. Increase by 1 each time, and the same thing occurs for even length palindromes.\\nThus, we can generate the first half in O(1) and simply reverse it to form the palindrome for each query! \\n\\n```Java\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] ans = new long[queries.length];\\n        long sz = (long)Math.pow(10, (intLength-1)/2);\\n        for (int i = 0; i < queries.length; i++){\\n            if (queries[i] > 9 * sz){ // invalid\\n                ans[i] = -1;\\n            }else{\\n                long front = sz + queries[i]-1;\\n                StringBuilder back = new StringBuilder(\"\"+front);\\n                ans[i] = Long.parseLong(front+back.reverse().toString().substring(intLength % 2)); \\n\\t\\t\\t\\t// don\\'t take the first letter if the length is odd, otherwise it\\'d overlap.\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515\\n```\n```Java\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] ans = new long[queries.length];\\n        long sz = (long)Math.pow(10, (intLength-1)/2);\\n        for (int i = 0; i < queries.length; i++){\\n            if (queries[i] > 9 * sz){ // invalid\\n                ans[i] = -1;\\n            }else{\\n                long front = sz + queries[i]-1;\\n                StringBuilder back = new StringBuilder(\"\"+front);\\n                ans[i] = Long.parseLong(front+back.reverse().toString().substring(intLength % 2)); \\n\\t\\t\\t\\t// don\\'t take the first letter if the length is odd, otherwise it\\'d overlap.\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898077,
                "title": "easy-python-code-string-math-logic-95-faster",
                "content": "# This is a Pure logic question You just have to find how the math is working and some basic logic\\nso what i did was if k is even lets say 4 then take the first 2 letters and reverse them and join\\neg .    1001-> 10 + 01  pow(10,1)\\nin this we just need 10 and revese that \\nif the value of k is odd lets say 5 then we need pow(10,2)-> 100\\neg. - 100+01 -> 10001\\nin this do not take the first digit of revesed string \\n\\n\\'\\'\\'\\n\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n        start=pow(10,n)\\n        for i in queries:\\n            ans=str(start+i-1)\\n            rev=ans[::-1]\\n            if L%2==0:\\n                st=ans+rev\\n            else:\\n                st=ans+rev[1:]\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n        return l1\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "# This is a Pure logic question You just have to find how the math is working and some basic logic\\nso what i did was if k is even lets say 4 then take the first 2 letters and reverse them and join\\neg .    1001-> 10 + 01  pow(10,1)\\nin this we just need 10 and revese that \\nif the value of k is odd lets say 5 then we need pow(10,2)-> 100\\neg. - 100+01 -> 10001\\nin this do not take the first digit of revesed string \\n\\n\\'\\'\\'\\n\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n        start=pow(10,n)\\n        for i in queries:\\n            ans=str(start+i-1)\\n            rev=ans[::-1]\\n            if L%2==0:\\n                st=ans+rev\\n            else:\\n                st=ans+rev[1:]\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n        return l1\\n\\'\\'\\'\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1892167,
                "title": "javascript-2217-find-palindrome-with-fixed-length",
                "content": "---\\n\\n- Understanding `99`th 8-digit palindrome is 10`98` `89`01 is key to understanding code below\\n\\n---\\n\\n**Weekly Contest 286**\\n- **Q1** answer - https://leetcode.com/problems/find-the-difference-of-two-arrays/discuss/1889224/JavaScript-2215.-Find-the-Difference-of-Two-Arrays\\n- **Q2** answer - https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/discuss/1890258/JavaScript-2216.-Minimum-Deletions-to-Make-Array-Beautiful\\n- **Q3** answer - https://leetcode.com/problems/find-palindrome-with-fixed-length/discuss/1892167/JavaScript-2217.-Find-Palindrome-With-Fixed-Length\\n  - **below**\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar kthPalindrome = function (queries, len) {\\n    let lenAboutHalf = Math.pow(10, Math.ceil(len / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";                     // first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                               // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (len % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;                                        // full palindrome\\n        if (s.length > len) {\\n            ans.push(-1);                                              // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/384fb9f9-40d2-4c07-ac11-a5cdbcfc6637_1648510433.6626642.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kthPalindrome = function (queries, len) {\\n    let lenAboutHalf = Math.pow(10, Math.ceil(len / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";                     // first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                               // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (len % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;                                        // full palindrome\\n        if (s.length > len) {\\n            ans.push(-1);                                              // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1888796,
                "title": "faster-than-100-00-of-c-easy-to-understand",
                "content": "Note the pattern, take length 4 as an example\\n* 1th 1001\\n* 2th 1111\\n* 3rd 1221\\n* 4th 1331\\n\\nwe split the string in half, and increase it query times then reverse to get the query-th palindrome.\\n1. we start with 10...01\\n2. add query-1 to the first half, simulating big integer adding.\\n\\t1. if we do not get overflow, reverse the other half.\\n\\t2. if we get overflow, remembering it to save some work.\\n\\nBelow is full code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& qs, int len) {\\n        string s(len, \\'0\\');\\n        vector<long long> res;\\n        int overflow = INT_MAX;\\n        for (auto q : qs) {\\n            if (q < overflow) {\\n                s.assign(len, \\'0\\');\\n                s[0] = \\'1\\';\\n                s.back() = \\'1\\';  // get 10...01 as start\\n                int carry = q-1; // set carry\\n                for (int ind = (len-1)/2; ind >= 0 && carry; ind--) {\\n                    int total = s[ind]-\\'0\\' + carry;\\n                    s[ind] = total % 10 + \\'0\\';\\n                    carry = total/10;\\n                }\\n                if (carry) {\\n                    overflow = q;\\n                    res.push_back(-1);\\n                    continue;\\n                } else {\\n                    if (len % 2) {\\n                        for (int i = 1; len/2+i <len; i++) {\\n                            s[i+len/2] = s[len/2-i];\\n                        }                        \\n                    } else {\\n                        for (int i = len/2-1, j = i+1; j < len; i--, j++) {\\n                            s[j] = s[i];\\n                        }                                                \\n                    }\\n                    res.push_back(atoll(s.c_str()));\\n                }\\n            } else {\\n                res.push_back(-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& qs, int len) {\\n        string s(len, \\'0\\');\\n        vector<long long> res;\\n        int overflow = INT_MAX;\\n        for (auto q : qs) {\\n            if (q < overflow) {\\n                s.assign(len, \\'0\\');\\n                s[0] = \\'1\\';\\n                s.back() = \\'1\\';  // get 10...01 as start\\n                int carry = q-1; // set carry\\n                for (int ind = (len-1)/2; ind >= 0 && carry; ind--) {\\n                    int total = s[ind]-\\'0\\' + carry;\\n                    s[ind] = total % 10 + \\'0\\';\\n                    carry = total/10;\\n                }\\n                if (carry) {\\n                    overflow = q;\\n                    res.push_back(-1);\\n                    continue;\\n                } else {\\n                    if (len % 2) {\\n                        for (int i = 1; len/2+i <len; i++) {\\n                            s[i+len/2] = s[len/2-i];\\n                        }                        \\n                    } else {\\n                        for (int i = len/2-1, j = i+1; j < len; i--, j++) {\\n                            s[j] = s[i];\\n                        }                                                \\n                    }\\n                    res.push_back(atoll(s.c_str()));\\n                }\\n            } else {\\n                res.push_back(-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888404,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        \\n        int n=queries.size();\\n        \\n        int k=(intLength+1)/2;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            int tot=pow(10,k)-pow(10,k-1);\\n            if(queries[i]>tot)\\n                ans.push_back(-1);\\n            else\\n            {\\n                \\n                long long int str=pow(10,k-1)-1+queries[i];\\n                string a=to_string(str);\\n                string b=\" \";\\n                \\n                if(intLength%2==1)\\n                {\\n                    //cout<<a<<endl;\\n                    b=a.substr(0,a.size()-1);\\n                }\\n                else\\n                {\\n                    b=a;\\n                }\\n                reverse(a.begin(),a.end());\\n                \\n                b+=a;\\n                \\n                long long p=stol(b);\\n                ans.push_back(p);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        \\n        int n=queries.size();\\n        \\n        int k=(intLength+1)/2;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            int tot=pow(10,k)-pow(10,k-1);\\n            if(queries[i]>tot)\\n                ans.push_back(-1);\\n            else\\n            {\\n                \\n                long long int str=pow(10,k-1)-1+queries[i];\\n                string a=to_string(str);\\n                string b=\" \";\\n                \\n                if(intLength%2==1)\\n                {\\n                    //cout<<a<<endl;\\n                    b=a.substr(0,a.size()-1);\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 1887714,
                "title": "simple-and-faster-than-100",
                "content": "```\\nclass Solution:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        a=True\\n        if intLength%2!=0:  a=False\\n        ans=[]\\n        for i in queries:\\n            if a:\\n                t=str(10**(intLength//2 - 1)+i-1)\\n                t=int(t+t[::-1])\\n            else:\\n                t=str(10**(intLength//2)+i-1)\\n                t=int(t+t[:-1][::-1])\\n            if len(str(t))>intLength:   t=-1\\n            ans.append(t)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        a=True\\n        if intLength%2!=0:  a=False\\n        ans=[]\\n        for i in queries:\\n            if a:\\n                t=str(10**(intLength//2 - 1)+i-1)\\n                t=int(t+t[::-1])\\n            else:\\n                t=str(10**(intLength//2)+i-1)\\n                t=int(t+t[:-1][::-1])\\n            if len(str(t))>intLength:   t=-1\\n            ans.append(t)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887356,
                "title": "c-o-n-time-easy-to-understand",
                "content": "```\\nint nmDig(int a){\\n    int ans =0;\\n    if(a==0) return 1;\\n    while(a) a/=10,ans++;\\n    return ans;\\n} // To Count number of Digits in a\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int IL) {\\n        int k=(IL-1)/2,j=0;\\n        while(k--) j+=9,j*=10;  j/=10;//j = 9...99\\n        vector<long long> ans;\\n        long long x,y;\\n        for(int i : Q){\\n\\t\\t x = i+j,y=i+j;\\n            if(nmDig(x) != (IL+1)/2){\\n                ans.push_back(-1); continue;\\n            }\\n            if(IL&1) x/=10;\\n            while(x) y=y*10+(x%10),x/=10;// make for example 1890 to 1890981\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIdea : The first palindrome of any size starts as 100..001\\nWe can divide every palindrome in 2 parts. Traverse from 10..0 to 99...9 which is half the size of palindrome and make a reflection at the end point to convert into palindrome.",
                "solutionTags": [],
                "code": "```\\nint nmDig(int a){\\n    int ans =0;\\n    if(a==0) return 1;\\n    while(a) a/=10,ans++;\\n    return ans;\\n} // To Count number of Digits in a\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int IL) {\\n        int k=(IL-1)/2,j=0;\\n        while(k--) j+=9,j*=10;  j/=10;//j = 9...99\\n        vector<long long> ans;\\n        long long x,y;\\n        for(int i : Q){\\n\\t\\t x = i+j,y=i+j;\\n            if(nmDig(x) != (IL+1)/2){\\n                ans.push_back(-1); continue;\\n            }\\n            if(IL&1) x/=10;\\n            while(x) y=y*10+(x%10),x/=10;// make for example 1890 to 1890981\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887276,
                "title": "c-easy-to-understand-solution-with-detailed-explanation",
                "content": "We are given queries size as 5 * 10^4 , thus we have to solve each query in O(k) or O(1) time. \\nLet us take an example to understand approach to solve it, let intLength=3.\\nSo our sequence here will be 101,111,121,131,141,151,161,171,181,191,202,212,.....999.\\nWe can divide a palindrome into (intLength+1)/2 parts. So above sequence is of form `aba`.  Where `a` can change from 1 to 9, and `b` can change from 0 to 9. Thus total combinations are 9 * 10. \\n(Similarly if we have intLength=6. The palindrome will be of from `abccba` , and total combinations 9 * 10 * 10 .)\\nSo if we get a query of length greater than value of total combinations, we will add -1 to result vector.\\nOtherwise we will find corresponding palindrome. We will create `path` vector, to change values of `a`, `b` in above example. Initially value of `path` vector is `{1,0}` . Let our query is 55, we will first subtract 1 from it.\\nThen => 54 = 5 * 10 + 4 , thus value of `a` is 5 and value of `b` is 4.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long largestPosValue=9*pow(10,(intLength-1)/2);\\n        //Palindrome of length n, will be devided in (n+1)/2 parts\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>largestPosValue)res.push_back(-1);\\n            else{\\n                string str=\"\";\\n                if(intLength==1){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    for(int j=0;j<intLength-2;j++)str+=\\'0\\';\\n                    str+=\\'1\\';\\n                }\\n                \\n                vector<int> paths((intLength+1)/2,0);\\n                paths[paths.size()-1]=1;\\n                int x=queries[i]-1,a=0;\\n                while(x>0){\\n                    paths[a++]+=x%10;\\n                    x/=10;\\n                }\\n                for(int j=paths.size()-1,z=0;j>=0;j--,z++){\\n                    str[z]=char(paths[j]+\\'0\\');\\n                    str[intLength-1-z]=char(paths[j]+\\'0\\');\\n                }\\n                \\n                res.push_back(stoll(str));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long largestPosValue=9*pow(10,(intLength-1)/2);\\n        //Palindrome of length n, will be devided in (n+1)/2 parts\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>largestPosValue)res.push_back(-1);\\n            else{\\n                string str=\"\";\\n                if(intLength==1){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    for(int j=0;j<intLength-2;j++)str+=\\'0\\';\\n                    str+=\\'1\\';\\n                }\\n                \\n                vector<int> paths((intLength+1)/2,0);\\n                paths[paths.size()-1]=1;\\n                int x=queries[i]-1,a=0;\\n                while(x>0){\\n                    paths[a++]+=x%10;\\n                    x/=10;\\n                }\\n                for(int j=paths.size()-1,z=0;j>=0;j--,z++){\\n                    str[z]=char(paths[j]+\\'0\\');\\n                    str[intLength-1-z]=char(paths[j]+\\'0\\');\\n                }\\n                \\n                res.push_back(stoll(str));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887275,
                "title": "python-o-n-with-explanation",
                "content": "If intLength is Even:\\n\\nWe only care about the left half, then add its reverse as the right half \\ne.g. intLength = 6, k = 2\\ncut the length in half, n = 6/2 = 3\\nwhat is the first number/starting number? (for this e.g., it should be 100)\\n`start = 10**(n-1) `\\nWhat is the kth number? (k = 2, starts with 100, the 2nd is 101)\\n`val = start + k - 1`\\nnow we have the left half, reverse it and get the right half\\nleft = `101`, right = `101` -> together `101101` \\n\\nif intLength is Odd:\\n\\nWe only care about the left half, then add its **partial** reverse as the right half \\ne.g. intLength = 5, k = 3\\ncut the length in half, n = 5//2 = 2\\nwhat is the first number/starting number? (for this e.g., it should be 100)\\n`start = 10**(n) `\\nWhat is the kth number? (k = 3, starts with 100, the 3rd is 102)\\n`val = start + k - 1`\\nnow we have the left half, reverse it and get the right half, add the right half without the first digit which is in parentheses\\nleft = `102`, right = `(2)01` -> together `102(2)01` ->`10201`\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:       \\n\\t\\t# if intLengh is Even\\n        if intLength % 2 == 0:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n-1)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n        \\n\\t\\t# if intLengh is Odd\\n        else:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1][1:]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:       \\n\\t\\t# if intLengh is Even\\n        if intLength % 2 == 0:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n-1)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n        \\n\\t\\t# if intLengh is Odd\\n        else:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1][1:]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887181,
                "title": "easy-approach-c",
                "content": "\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll givepali(int n, int k)\\n    {\\n        ll ans = 0;\\n        long long tem;\\n        if(k&1)\\n            tem = k/2;\\n        else\\n            tem = k/2-1;\\n        ll dig = (ll)powl(10, tem);\\n        dig += n - 1;\\n        ans  = dig;\\n\\n        if (k & 1){\\n            dig /= 10;\\n        }\\n\\n        while (dig)\\n        {\\n            ans = ans*10 + dig%10;\\n            dig /= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    vector<long long> kthPalindrome(vector<int>& q, int k) {\\n        \\n        vector<ll> ans;\\n        int x = (k+1)/2;\\n        ll aa = 9*powl(10,x-1);\\n        for(int i=0; i<q.size(); ++i)\\n        {\\n            \\n            if(q[i]<=aa)\\n                ans.push_back(givepali(q[i],k));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll givepali(int n, int k)\\n    {\\n        ll ans = 0;\\n        long long tem;\\n        if(k&1)\\n            tem = k/2;\\n        else\\n            tem = k/2-1;\\n        ll dig = (ll)powl(10, tem);\\n        dig += n - 1;\\n        ans  = dig;\\n\\n        if (k & 1){\\n            dig /= 10;\\n        }\\n\\n        while (dig)\\n        {\\n            ans = ans*10 + dig%10;\\n            dig /= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    vector<long long> kthPalindrome(vector<int>& q, int k) {\\n        \\n        vector<ll> ans;\\n        int x = (k+1)/2;\\n        ll aa = 9*powl(10,x-1);\\n        for(int i=0; i<q.size(); ++i)\\n        {\\n            \\n            if(q[i]<=aa)\\n                ans.push_back(givepali(q[i],k));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917040,
                "title": "python-simple-solution-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        res=[]\\n        ln=ceil(intLength/2)\\n        odd=intLength%2==1\\n        base=10**(ln-1)\\n        def getLalindrome(k:int)->int:\\n            val=str(k-1+base)\\n            if len(val)>ln:\\n                return -1\\n            return int(val+val[-2::-1]) if odd else int(val+val[::-1])\\n        for q in queries:\\n            res.append(getLalindrome(q))  \\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        res=[]\\n        ln=ceil(intLength/2)\\n        odd=intLength%2==1\\n        base=10**(ln-1)\\n        def getLalindrome(k:int)->int:\\n            val=str(k-1+base)\\n            if len(val)>ln:\\n                return -1\\n            return int(val+val[-2::-1]) if odd else int(val+val[::-1])\\n        for q in queries:\\n            res.append(getLalindrome(q))  \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822509,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/82cc68e9-a96c-40f4-a46a-e7c7966a60cc_1690442908.0847147.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629304,
                "title": "simple-and-clean-solution-easy-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    long long helper(long long num,int len)\\n    {\\n        long long pal_num=num;\\n        if(len&1)num/=10;\\n        while(num)\\n        {\\n            pal_num*=10;\\n            pal_num+=(num%10);\\n            num/=10;\\n        }\\n        return pal_num;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        int start=pow(10,((len+1)/2)-1);\\n        long long totalPal=(start==0?9:start*1ll*9);\\n        vector<long long> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i]>totalPal)\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                ans.push_back(helper(start+q[i]-1,len));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(long long num,int len)\\n    {\\n        long long pal_num=num;\\n        if(len&1)num/=10;\\n        while(num)\\n        {\\n            pal_num*=10;\\n            pal_num+=(num%10);\\n            num/=10;\\n        }\\n        return pal_num;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        int start=pow(10,((len+1)/2)-1);\\n        long long totalPal=(start==0?9:start*1ll*9);\\n        vector<long long> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i]>totalPal)\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                ans.push_back(helper(start+q[i]-1,len));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299422,
                "title": "2217-find-palindrome-with-fixed-length-simple-cpp-solution",
                "content": "* class Solution {\\n* public:\\n*     vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n*          int n=(intLength%2==0)?(intLength/2)-1:(intLength/2);\\n*         vector<long long> res;\\n*         int n1=pow(10,n);\\n*         for(auto a:queries)\\n*         {\\n*             string s1=to_string(n1+a-1);\\n*             string rev=s1;\\n*             reverse(rev.begin(),rev.end());\\n*             if(intLength%2 ==0)\\n*             {\\n*                 s1=s1+rev;\\n*             }\\n*             else\\n*             {\\n*                 s1=s1+ rev.substr(1,rev.size()-1);\\n*             }\\n*             if(s1.size()==intLength)\\n*                 res.push_back(stoll(s1));\\n*             else\\n*                 res.push_back(-1);\\n*         }\\n*         return res;\\n*     }\\n* };",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n* public:\\n*     vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n*          int n=(intLength%2==0)?(intLength/2)-1:(intLength/2);\\n*         vector<long long> res;\\n*         int n1=pow(10,n);\\n*         for(auto a:queries)\\n*         {\\n*             string s1=to_string(n1+a-1);\\n*             string rev=s1;\\n*             reverse(rev.begin(),rev.end());\\n*             if(intLength%2 ==0)\\n*             {\\n*                 s1=s1+rev;\\n*             }",
                "codeTag": "Java"
            },
            {
                "id": 2272812,
                "title": "python-no-string-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        left_digits = intLength // 2 + intLength % 2\\n        output = [-1 for _ in queries]\\n        \\n        for i, query in enumerate(queries):\\n            temp = 10 ** (left_digits - 1) + query - 1\\n            if temp < 10 ** left_digits:\\n                x = 0\\n                y = temp // 10 if intLength % 2 else temp\\n                while y > 0:\\n                    x = x * 10 + y % 10\\n                    y //= 10\\n                    temp *= 10\\n                output[i] = temp + x\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        left_digits = intLength // 2 + intLength % 2\\n        output = [-1 for _ in queries]\\n        \\n        for i, query in enumerate(queries):\\n            temp = 10 ** (left_digits - 1) + query - 1\\n            if temp < 10 ** left_digits:\\n                x = 0\\n                y = temp // 10 if intLength % 2 else temp\\n                while y > 0:\\n                    x = x * 10 + y % 10\\n                    y //= 10\\n                    temp *= 10\\n                output[i] = temp + x\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221612,
                "title": "python-math-string-reverse-93-38-faster",
                "content": "\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tresult=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tbase = 10**((intLength)//2 -1 )\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2 -1 ))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbase = 10**((intLength)//2)\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2))\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tif i>temp2:\\n\\t\\t\\t\\t\\tresult.append(-1)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttemp = base + i-1\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-1::-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-2::-1]\\n\\t\\t\\t\\tresult.append(int(temp1))\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tresult=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tbase = 10**((intLength)//2 -1 )\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2 -1 ))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbase = 10**((intLength)//2)\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2))\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tif i>temp2:\\n\\t\\t\\t\\t\\tresult.append(-1)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttemp = base + i-1\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-1::-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-2::-1]\\n\\t\\t\\t\\tresult.append(int(temp1))\\n\\n\\t\\t\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 1976285,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```\\n\\n***Consider upvote if usefull!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958366,
                "title": "python-simple-solution-half-the-palindrome-length",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n1 = 10**(intLength//2-1 if intLength%2==0 else intLength//2)\\n        for query in queries:\\n            n2 = n1 + (query-1)\\n            s = str(n2) + \\'\\'.join(reversed(str(n2)))[0 if intLength%2==0 else 1:]\\n            answer.append(int(s) if len(s) == intLength else -1)\\n        return answer",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n1 = 10**(intLength//2-1 if intLength%2==0 else intLength//2)\\n        for query in queries:\\n            n2 = n1 + (query-1)\\n            s = str(n2) + \\'\\'.join(reversed(str(n2)))[0 if intLength%2==0 else 1:]\\n            answer.append(int(s) if len(s) == intLength else -1)\\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1943697,
                "title": "7-lines-python-solution-93-faster-memory-less-than-70",
                "content": "### ***Solution 1: Time O(n) / Memory O(n)***\\n```\\nclass Solution:\\n    def kthPalindrome(self, Q: List[int], k: int) -> List[int]:\\n        ans=[] ; s=\\'\\' ; n=ceil(k/2)-1\\n        for i in Q:\\n            x=str(10**n+i-1)\\n            if k%2==0: s=x+x[::-1]\\n            else: s=x+x[::-1][1:]\\n            ans.append(s if len(s)==k else -1)\\n        return ans\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, Q: List[int], k: int) -> List[int]:\\n        ans=[] ; s=\\'\\' ; n=ceil(k/2)-1\\n        for i in Q:\\n            x=str(10**n+i-1)\\n            if k%2==0: s=x+x[::-1]\\n            else: s=x+x[::-1][1:]\\n            ans.append(s if len(s)==k else -1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913402,
                "title": "explained-solution-in-easy-ways-step-by-step",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        \\n#         if we have 4 then break it 2 or we have 5 then also to 2\\n\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n            \\n            \\n            \\n#         starting from that length like if we have 2 then 10 find the power if we have 3 then 100 continue from that string \\n        start=pow(10,n)\\n        for i in queries:\\n            print(start)\\n#             add that queries-1 in the start \\n            ans=str(start+i-1)\\n            \\n#         reverse that string \\n            rev=ans[::-1]\\n    \\n#           if the length is the even simple ad the reverse string    \\n            if L%2==0:\\n                st=ans+rev\\n            \\n#             other wise add from the 1 index like k=3 string 10 then we have to just add the 1 to make the final string 101\\n            else:\\n                st=ans+rev[1:]\\n            \\n#           if the string length matches the given length then add in the result otherwise -1\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n            # print(st,l1)\\n        return l1\\n```\\n<strong> if you like the solution then hit the like button",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        \\n#         if we have 4 then break it 2 or we have 5 then also to 2\\n\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n            \\n            \\n            \\n#         starting from that length like if we have 2 then 10 find the power if we have 3 then 100 continue from that string \\n        start=pow(10,n)\\n        for i in queries:\\n            print(start)\\n#             add that queries-1 in the start \\n            ans=str(start+i-1)\\n            \\n#         reverse that string \\n            rev=ans[::-1]\\n    \\n#           if the length is the even simple ad the reverse string    \\n            if L%2==0:\\n                st=ans+rev\\n            \\n#             other wise add from the 1 index like k=3 string 10 then we have to just add the 1 to make the final string 101\\n            else:\\n                st=ans+rev[1:]\\n            \\n#           if the string length matches the given length then add in the result otherwise -1\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n            # print(st,l1)\\n        return l1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896836,
                "title": "java-simple-solution",
                "content": "\\n\\n        int len=(intLength+1)/2;\\n        long left=(long)Math.pow(10,len-1);\\n        long right=(long)(Math.pow(10,len)-1);\\n        long ans[]=new long[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            long rang=right-left+1;\\n            if(queries[i]>rang)\\n                ans[i]=-1;\\n            else\\n            {\\n                String t1=Long.toString(left+queries[i]-1);\\n                String t2=(new StringBuffer(t1)).reverse().toString();\\n                ans[i]=Long.parseLong(t1+t2.substring(intLength%2));\\n                \\n\\n             }\\n        }\\n        return ans;\\n        \\n \\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "\\n\\n        int len=(intLength+1)/2;\\n        long left=(long)Math.pow(10,len-1);\\n        long right=(long)(Math.pow(10,len)-1);\\n        long ans[]=new long[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            long rang=right-left+1;\\n            if(queries[i]>rang)\\n                ans[i]=-1;\\n            else\\n            {\\n                String t1=Long.toString(left+queries[i]-1);\\n                String t2=(new StringBuffer(t1)).reverse().toString();\\n                ans[i]=Long.parseLong(t1+t2.substring(intLength%2));\\n                \\n\\n             }\\n        }\\n        return ans;\\n        \\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1890445,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ##Consider both cases for even and odd length separately##\\n        \\n        l=0\\n        if intLength%2:\\n            l=intLength//2\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[:len(r)-1]\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        else:\\n            l=intLength//2-1\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        return res\\n                \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ##Consider both cases for even and odd length separately##\\n        \\n        l=0\\n        if intLength%2:\\n            l=intLength//2\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[:len(r)-1]\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        else:\\n            l=intLength//2-1\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        return res\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890166,
                "title": "find-palindrome-with-fixed-length",
                "content": "class Solution {\\n    int getDigitCount(int num)\\n    {\\n        int dc=1;\\n        while(num>9)\\n        {\\n            dc++;\\n            num/=10;\\n        }\\n        return dc;\\n    }\\n    long long getKthPal(int k,int length)\\n    {\\n        long long half,dc,factor;\\n        long long num,ans;\\n        half=length/2;\\n        if(length%2==1)\\n        {\\n            num=pow(10,half);\\n            dc=half+1;\\n        }\\n        else \\n        {\\n            num=pow(10,half-1);\\n            dc=half;\\n        }\\n        num+=k-1;\\n        if(getDigitCount(num)>dc)return -1;\\n        if(dc==half)factor=1;\\n        else\\n        {\\n            factor=10;\\n            dc--;\\n        }\\n        while(dc>0)\\n        {\\n            num=num*10+((num/factor)%10);\\n            dc--;\\n            if(dc==0)break;\\n            factor*=100;\\n        }\\n        return num;\\n        \\n    \\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            ans.push_back(getKthPal(queries[i],intLength));\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int getDigitCount(int num)\\n    {\\n        int dc=1;\\n        while(num>9)\\n        {\\n            dc++;\\n            num/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888538,
                "title": "scala-4-liner-using-tostring-tolong",
                "content": "Excluding silly `object Solution {}` and method definition part.\\nRead other links if you want explanation on why this addition works.\\nIn this solution, `toString` and `toLong` is used for for brevity. (If you think about it, palindrome is about strings, not numbers)\\nFor a string `s` denoting upper half of the palindrome, both `s.dropRight (1) ++ s.reverse` and `s ++ s.reverse` makes original palindrome. Choose appropriately depending on `intLength`.\\n\\n```scala\\nobject Solution {\\n  def kthPalindrome (queries: Array[Int], intLength: Int): Array[Long] = {\\n    val begin = Iterator.fill ((intLength - 1) / 2) (10L).product\\n    queries map (n => if (n > begin * 9) -1 else (begin + n - 1).toString match {\\n      case str => (str.dropRight (intLength & 1) ++ str.reverse).toLong\\n    })\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n  def kthPalindrome (queries: Array[Int], intLength: Int): Array[Long] = {\\n    val begin = Iterator.fill ((intLength - 1) / 2) (10L).product\\n    queries map (n => if (n > begin * 9) -1 else (begin + n - 1).toString match {\\n      case str => (str.dropRight (intLength & 1) ++ str.reverse).toLong\\n    })\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1888449,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long find(long long n,int len)\\n    {\\n        long long pal=n;\\n        if(len%2)\\n        {\\n            n/=10;\\n        }\\n        while(n)\\n        {\\n            pal=pal*10+n%10;\\n            n=n/10;\\n        }\\n        return pal;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) \\n    {\\n        vector<long long>ans(q.size(),-1);\\n        long long start=pow(10,(len-1)/2);\\n        long long end=pow(10,(len+1)/2);\\n        int index=-1;\\n        for(auto &it:q)\\n        {\\n            it--;\\n            index++;\\n            if((start+it)<end)\\n            {\\n                ans[index]=find(start+it,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(long long n,int len)\\n    {\\n        long long pal=n;\\n        if(len%2)\\n        {\\n            n/=10;\\n        }\\n        while(n)\\n        {\\n            pal=pal*10+n%10;\\n            n=n/10;\\n        }\\n        return pal;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) \\n    {\\n        vector<long long>ans(q.size(),-1);\\n        long long start=pow(10,(len-1)/2);\\n        long long end=pow(10,(len+1)/2);\\n        int index=-1;\\n        for(auto &it:q)\\n        {\\n            it--;\\n            index++;\\n            if((start+it)<end)\\n            {\\n                ans[index]=find(start+it,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888163,
                "title": "c-first-half-of-palindrome-reverse-and-concatenate",
                "content": "```\\nclass Solution {\\n    long long reverse_and_concatenate(long long num,int intLength){\\n        long long temp = num;\\n        \\n        if(intLength%2) temp /= 10;\\n        \\n        while(temp){\\n            int rem = temp%10;\\n            num = num*10+rem;\\n            temp /= 10;\\n        }\\n        \\n        return num;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> ans(n);\\n        \\n        long long start = pow(10,(intLength+1)/2-1);\\n        long long end = pow(10,(intLength+1)/2)-1;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            long long left_half = start + queries[i] - 1;\\n            if(left_half > end)   ans[i] = -1;\\n            else                  ans[i] = reverse_and_concatenate(left_half,intLength);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long reverse_and_concatenate(long long num,int intLength){\\n        long long temp = num;\\n        \\n        if(intLength%2) temp /= 10;\\n        \\n        while(temp){\\n            int rem = temp%10;\\n            num = num*10+rem;\\n            temp /= 10;\\n        }\\n        \\n        return num;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> ans(n);\\n        \\n        long long start = pow(10,(intLength+1)/2-1);\\n        long long end = pow(10,(intLength+1)/2)-1;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            long long left_half = start + queries[i] - 1;\\n            if(left_half > end)   ans[i] = -1;\\n            else                  ans[i] = reverse_and_concatenate(left_half,intLength);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887449,
                "title": "half-palindrome-to-consider-beats-all-runtime-simle-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private:\\n    long long sto(string s){//string to integer\\n        long long x = 0;\\n        for(int i = 0 ; i < s.size();++i){\\n            x = x*10 + s[i]-\\'0\\';\\n        }\\n        return x;\\n    }\\n    int max(int a,int b){\\n        if(a>b)return a;\\n        return b;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        if(len == 1){\\n            vector<long long>v;\\n            for(auto &i:queries){\\n                if(i>=10)v.emplace_back(-1);\\n                else{\\n                    v.emplace_back(i);\\n                }\\n            }\\n            return v;\\n        }\\n        int startLen = (len+1)/2;\\n        map<long long,long long>m;\\n        long long cnt = 1;\\n        long long start = pow(10,startLen-1);\\n        long long end = pow(10,startLen)-1;\\n        long long maxi = 0;\\n        for(auto&i:queries){\\n            m[i]++;\\n            maxi = max(maxi,i);\\n        }\\n        long long limit = 9*pow(10,startLen-1);\\n        vector<long long>v;\\n        for(auto&i:queries){\\n            if(i>limit){\\n                v.emplace_back(-1);\\n            }\\n            else{\\n                m[i] = i + start -1;\\n                string x = to_string(m[i]);\\n                string y = x;\\n               \\n                if(len&1){\\n                    y.pop_back();\\n                }\\n                 reverse(y.begin(),y.end());\\n                x+=y;\\n                long long z = sto(x);\\n                v.emplace_back(z);\\n            }\\n        }\\n        \\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n    private:\\n    long long sto(string s){//string to integer\\n        long long x = 0;\\n        for(int i = 0 ; i < s.size();++i){\\n            x = x*10 + s[i]-\\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1887330,
                "title": "c-simple-solution-with-explanation-o-no-of-queries-intlength-100-faster",
                "content": "Palindrome in increasing order:\\n* 1 digit : 1,2,3,4,5,6,7,8,9...\\n* 2 digits : **10**, **11**, **12**, **13**....\\n* 3 digits : **10**1, **11**1, **12**1, **13**1....\\n* 4 digits : **10**01, **11**11, **12**21, **13**31, ....\\n\\nWe see a trend that if we split the number in half, then first half starts from 1 or 10 or 100 and keep increasing **sequentially**. So first half for n palindrome will be (start + n -1).\\n\\nWe can leverage on this so that we can create any palindrome directly. \\n\\nOnce we have the first half we can reverse and create the second half and thus get the whole number. In case of odd number we have to reverse and remove first character to keep length same as palindrome.\\n\\n\\n```\\npublic class Solution {\\n    public long[] KthPalindrome(int[] queries, int intLength) {\\n        \\n        int d = (intLength + 1)/2; //length of first half\\n        var odd = intLength % 2 != 0; \\n        \\n        long start = 0;\\n        start = (long)Math.Pow(10, d-1); \\n        long end = (long)Math.Pow(10, d);//if we start from 10 we should go till 99 only else palindrome length will increase\\n        \\n        var arr = new long[queries.Length];        \\n        int count = 1;\\n        for(int i=0; i < queries.Length; i++)\\n        {            \\n            var str = (start + queries[i]-1).ToString();            \\n            var revStr = Reverse(str);\\n            if(odd)\\n                revStr = revStr.Substring(1);\\n            \\n            var numStr = str + revStr;            \\n            //Console.WriteLine($\"str : {str}, revStr : {revStr}\");            \\n            \\n            arr[i] = numStr.Length == intLength ? long.Parse(numStr) : -1;            \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public static string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long[] KthPalindrome(int[] queries, int intLength) {\\n        \\n        int d = (intLength + 1)/2; //length of first half\\n        var odd = intLength % 2 != 0; \\n        \\n        long start = 0;\\n        start = (long)Math.Pow(10, d-1); \\n        long end = (long)Math.Pow(10, d);//if we start from 10 we should go till 99 only else palindrome length will increase\\n        \\n        var arr = new long[queries.Length];        \\n        int count = 1;\\n        for(int i=0; i < queries.Length; i++)\\n        {            \\n            var str = (start + queries[i]-1).ToString();            \\n            var revStr = Reverse(str);\\n            if(odd)\\n                revStr = revStr.Substring(1);\\n            \\n            var numStr = str + revStr;            \\n            //Console.WriteLine($\"str : {str}, revStr : {revStr}\");            \\n            \\n            arr[i] = numStr.Length == intLength ? long.Parse(numStr) : -1;            \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public static string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887307,
                "title": "python-straight-forward-solution-half-palindromes",
                "content": "The squence of the palindromes depend on the first half of the palindromes.\\n\\n1) Find a starting point when the number of length N is even or odd. For example, N=2, the half of the first palindromes is 1; N=3, the half of the first palindromes is 10; N=4, the half of the first palindromes is 10.\\n```\\nif intLength % 2 == 0 :\\n     power = intLength / 2 - 1\\nelse:\\n     power = (intLength - 1) /2\\n        \\nspoint = 1\\nfor i in range(int(power)):\\n     spoint = spoint * 10\\n```\\n2) Find the corresponding first half of the palindrome according to the sequence and get the remaining palindrome based on the first half. Still, the situation will be different when the length is even or odd.\\n```\\nrnumber = []\\nif intLength % 2 == 0:\\n     for query in queries:\\n            number = (query + spoint - 1)\\n            if len(str(number)+str(number)[::-1]) > intLength:\\n                rnumber.append(-1)\\n            else:\\n                rnumber.append(int(str(number)+str(number)[::-1]))\\nelif intLength % 2 != 0:\\n     for query in queries:\\n           number = (query + spoint -1)\\n           if len(str(number)+str(number)[:-1][::-1]) > intLength:\\n               rnumber.append(-1)\\n           else:\\n               rnumber.append(int(str(number)+str(number)[:-1][::-1]))\\nreturn rnumber\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nif intLength % 2 == 0 :\\n     power = intLength / 2 - 1\\nelse:\\n     power = (intLength - 1) /2\\n        \\nspoint = 1\\nfor i in range(int(power)):\\n     spoint = spoint * 10\\n```\n```\\nrnumber = []\\nif intLength % 2 == 0:\\n     for query in queries:\\n            number = (query + spoint - 1)\\n            if len(str(number)+str(number)[::-1]) > intLength:\\n                rnumber.append(-1)\\n            else:\\n                rnumber.append(int(str(number)+str(number)[::-1]))\\nelif intLength % 2 != 0:\\n     for query in queries:\\n           number = (query + spoint -1)\\n           if len(str(number)+str(number)[:-1][::-1]) > intLength:\\n               rnumber.append(-1)\\n           else:\\n               rnumber.append(int(str(number)+str(number)[:-1][::-1]))\\nreturn rnumber\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887277,
                "title": "c-solution-maths",
                "content": "```\\nstring nthPalindrome(int n, int k){\\n\\tstring res=\"\";\\n\\tint temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n\\tint palindrome = (int)pow(10, temp);\\n\\tpalindrome += n - 1;\\n    res+=to_string(palindrome);\\n\\t\\n\\tif (k & 1)\\n\\t\\tpalindrome /= 10;\\n\\t\\t\\n\\twhile (palindrome)\\n\\t{\\n        res+=to_string( palindrome % 10);\\n\\t\\tpalindrome /= 10;\\n\\t}\\n    return res;\\n}\\n\\nvector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n\\t\\tvector<long long>ans;\\n   \\n        for(auto &it: queries){\\n           string ele= nthPalindrome(it, intLength);\\n            if(ele.size()!=intLength)ans.push_back(-1);\\n            else ans.push_back(stol(ele));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nstring nthPalindrome(int n, int k){\\n\\tstring res=\"\";\\n\\tint temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n\\tint palindrome = (int)pow(10, temp);\\n\\tpalindrome += n - 1;\\n    res+=to_string(palindrome);\\n\\t\\n\\tif (k & 1)\\n\\t\\tpalindrome /= 10;\\n\\t\\t\\n\\twhile (palindrome)\\n\\t{\\n        res+=to_string( palindrome % 10);\\n\\t\\tpalindrome /= 10;\\n\\t}\\n    return res;\\n}\\n\\nvector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n\\t\\tvector<long long>ans;\\n   \\n        for(auto &it: queries){\\n           string ele= nthPalindrome(it, intLength);\\n            if(ele.size()!=intLength)ans.push_back(-1);\\n            else ans.push_back(stol(ele));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887259,
                "title": "javascript-typescript-solution-explained",
                "content": "```\\n// main idea:\\n// the 1st palindrome will always be of intLength length with 1 as the first and last digit\\n// each next palindrome is always just the previous one with its first half + 1\\n// i.e.:\\n// first: 1001 (first half = 10) | first: 101 (first half = 10)\\n// nth:   7887 (first half = 78) | kth:   595 (first half = 59)\\n// nth+1: 7997 (first half = 79) | kth+1: 606 (first half = 60)\\n// nth+2: 8008 (first half = 80) | kth+2: 616 (first half = 61)\\n\\nfunction kthPalindrome(queries: number[], intLength: number): number[] {\\n    if (intLength === 0) return queries.map(q => -1);\\n\\n\\t// calculate the 1st palindrome\\n    let init = 10**(intLength - 1);\\n    if (init !== 1) init++;\\n\\n\\t// get the first half of the first number as a string, i.e. 100 for 100001 or 10 for 101\\n\\tconst initString = init.toString(10);\\n\\tlet endOfFirstHalfIndex = Math.floor(intLength / 2 + 0.5);\\n\\tconst halfInitString = initString.slice(0, endOfFirstHalfIndex);\\n    \\n    function getNthPalindrome(index: number) {\\n        const nextHalfStr = (+halfInitString + index - 1).toString(10); // figure out the hirst half of the nth palindrome\\n        if (nextHalfStr.length > halfInitString.length) return -1; // we\\'ve over the intLength, return -1;\\n\\t\\t\\n\\t\\t// now we just have to complete palindrome by recreating the other half\\n\\t\\t// (remember to handle both odd and even intLength)\\n\\t\\tconst res = [];\\n        for (let i = 0, j = intLength - 1; i <= j; i++, j--) {\\n            res[i] = nextHalfStr[i];\\n            res[j] = res[i];\\n        }\\n        return +res.join(\\'\\');\\n    }\\n    \\n\\treturn queries.map(getNthPalindrome);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// main idea:\\n// the 1st palindrome will always be of intLength length with 1 as the first and last digit\\n// each next palindrome is always just the previous one with its first half + 1\\n// i.e.:\\n// first: 1001 (first half = 10) | first: 101 (first half = 10)\\n// nth:   7887 (first half = 78) | kth:   595 (first half = 59)\\n// nth+1: 7997 (first half = 79) | kth+1: 606 (first half = 60)\\n// nth+2: 8008 (first half = 80) | kth+2: 616 (first half = 61)\\n\\nfunction kthPalindrome(queries: number[], intLength: number): number[] {\\n    if (intLength === 0) return queries.map(q => -1);\\n\\n\\t// calculate the 1st palindrome\\n    let init = 10**(intLength - 1);\\n    if (init !== 1) init++;\\n\\n\\t// get the first half of the first number as a string, i.e. 100 for 100001 or 10 for 101\\n\\tconst initString = init.toString(10);\\n\\tlet endOfFirstHalfIndex = Math.floor(intLength / 2 + 0.5);\\n\\tconst halfInitString = initString.slice(0, endOfFirstHalfIndex);\\n    \\n    function getNthPalindrome(index: number) {\\n        const nextHalfStr = (+halfInitString + index - 1).toString(10); // figure out the hirst half of the nth palindrome\\n        if (nextHalfStr.length > halfInitString.length) return -1; // we\\'ve over the intLength, return -1;\\n\\t\\t\\n\\t\\t// now we just have to complete palindrome by recreating the other half\\n\\t\\t// (remember to handle both odd and even intLength)\\n\\t\\tconst res = [];\\n        for (let i = 0, j = intLength - 1; i <= j; i++, j--) {\\n            res[i] = nextHalfStr[i];\\n            res[j] = res[i];\\n        }\\n        return +res.join(\\'\\');\\n    }\\n    \\n\\treturn queries.map(getNthPalindrome);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887197,
                "title": "intuitive-easy-to-understand-o-n-constructing-palindrome-optimized",
                "content": "TO UNDERSTAND THIS, FIRST RUN THIS COMMENTED CODE TO SEE THE INTUTION\\n1. We just have to build half part of palindrome.\\n2. Have you noticed that Difference between two consutive palindromes.\\n\\n\\t\\t101\\n\\t\\t111\\n\\t\\t121\\n\\t\\t131\\n\\t\\t141\\n\\t\\t151\\n\\t\\t161\\n\\t\\t171\\n\\t\\t181\\n\\t\\t191\\n\\t\\t202\\n\\t\\t212\\n\\t\\t222\\n\\t\\t232\\n\\t\\t242\\n\\t\\t252\\n\\t\\t262\\n\\t\\t272\\n\\t\\t282\\n\\t\\t292\\n\\t\\t303\\n\\t\\t313\\n\\t\\t323\\n\\t\\t333\\n\\t\\t343\\n\\t\\t353\\n\\t\\t363\\n\\t\\t373\\n\\t\\t383\\n\\t\\t393\\n\\t\\t404\\n\\t\\t414\\n\\t\\t424\\n\\t\\t434\\n\\t\\t444\\n\\t\\t454\\n\\t\\t464\\n\\t\\t474\\n\\t\\t484\\n\\t\\t494\\n\\t\\t505\\n\\t\\t515\\n\\t\\t525\\n\\t\\t535\\n\\t\\t545\\n\\t\\t555\\n\\t\\t565\\n\\t\\t575\\n\\t\\t585\\n\\t\\t595\\n\\t\\t606\\n\\t\\t616\\n\\t\\t626\\n\\t\\t636\\n\\t\\t646\\n\\t\\t656\\n\\t\\t666\\n\\t\\t676\\n\\t\\t686\\n\\t\\t696\\n\\t\\t707\\n\\t\\t717\\n\\t\\t727\\n\\t\\t737\\n\\t\\t747\\n\\t\\t757\\n\\t\\t767\\n\\t\\t777\\n\\t\\t787\\n\\t\\t797\\n\\t\\t808\\n\\t\\t818\\n\\t\\t828\\n\\t\\t838\\n\\t\\t848\\n\\t\\t858\\n\\t\\t868\\n\\t\\t878\\n\\t\\t888\\n\\t\\t898\\n\\t\\t909\\n\\t\\t919\\n\\t\\t929\\n\\t\\t939\\n\\t\\t949\\n\\t\\t959\\n\\t\\t969\\n\\t\\t979\\n\\t\\t989\\n\\t\\t999\\n   ``` \\n\\t// for(int i=100;i<1000;i++)\\n        // {\\n        //     string s=to_string(i);\\n        //     string r=string(s.rbegin(),s.rend());\\n        //     if(r==s)\\n        //         cout<<r<<\" \"<<i+10<<endl;\\n        // }\\n\\n\\tvector<long long> kthPalindrome(vector<int>& a, int l) {\\n        vector<long long> ans;\\n        int y=(l+1)/2-1;\\n        long long k=1;\\n            k=pow(10,y);\\n        k--;\\n   \\n        int c=0,x=l/2;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            long long t = k+(long long)a[i];\\n            string s=to_string(t);\\n            if(l%2 && s.size()>x+1)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            if(l%2==0 && s.size()>x)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string r=string(s.rbegin(),s.rend());\\n            if(l%2)\\n                s.pop_back();\\n            s+=r;\\n            t=stoll(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "TO UNDERSTAND THIS, FIRST RUN THIS COMMENTED CODE TO SEE THE INTUTION\\n1. We just have to build half part of palindrome.\\n2. Have you noticed that Difference between two consutive palindromes.\\n\\n\\t\\t101\\n\\t\\t111\\n\\t\\t121\\n\\t\\t131\\n\\t\\t141\\n\\t\\t151\\n\\t\\t161\\n\\t\\t171\\n\\t\\t181\\n\\t\\t191\\n\\t\\t202\\n\\t\\t212\\n\\t\\t222\\n\\t\\t232\\n\\t\\t242\\n\\t\\t252\\n\\t\\t262\\n\\t\\t272\\n\\t\\t282\\n\\t\\t292\\n\\t\\t303\\n\\t\\t313\\n\\t\\t323\\n\\t\\t333\\n\\t\\t343\\n\\t\\t353\\n\\t\\t363\\n\\t\\t373\\n\\t\\t383\\n\\t\\t393\\n\\t\\t404\\n\\t\\t414\\n\\t\\t424\\n\\t\\t434\\n\\t\\t444\\n\\t\\t454\\n\\t\\t464\\n\\t\\t474\\n\\t\\t484\\n\\t\\t494\\n\\t\\t505\\n\\t\\t515\\n\\t\\t525\\n\\t\\t535\\n\\t\\t545\\n\\t\\t555\\n\\t\\t565\\n\\t\\t575\\n\\t\\t585\\n\\t\\t595\\n\\t\\t606\\n\\t\\t616\\n\\t\\t626\\n\\t\\t636\\n\\t\\t646\\n\\t\\t656\\n\\t\\t666\\n\\t\\t676\\n\\t\\t686\\n\\t\\t696\\n\\t\\t707\\n\\t\\t717\\n\\t\\t727\\n\\t\\t737\\n\\t\\t747\\n\\t\\t757\\n\\t\\t767\\n\\t\\t777\\n\\t\\t787\\n\\t\\t797\\n\\t\\t808\\n\\t\\t818\\n\\t\\t828\\n\\t\\t838\\n\\t\\t848\\n\\t\\t858\\n\\t\\t868\\n\\t\\t878\\n\\t\\t888\\n\\t\\t898\\n\\t\\t909\\n\\t\\t919\\n\\t\\t929\\n\\t\\t939\\n\\t\\t949\\n\\t\\t959\\n\\t\\t969\\n\\t\\t979\\n\\t\\t989\\n\\t\\t999\\n   ``` \\n\\t// for(int i=100;i<1000;i++)\\n        // {\\n        //     string s=to_string(i);\\n        //     string r=string(s.rbegin(),s.rend());\\n        //     if(r==s)\\n        //         cout<<r<<\" \"<<i+10<<endl;\\n        // }\\n\\n\\tvector<long long> kthPalindrome(vector<int>& a, int l) {\\n        vector<long long> ans;\\n        int y=(l+1)/2-1;\\n        long long k=1;\\n            k=pow(10,y);\\n        k--;\\n   \\n        int c=0,x=l/2;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            long long t = k+(long long)a[i];\\n            string s=to_string(t);\\n            if(l%2 && s.size()>x+1)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            if(l%2==0 && s.size()>x)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string r=string(s.rbegin(),s.rend());\\n            if(l%2)\\n                s.pop_back();\\n            s+=r;\\n            t=stoll(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 1887178,
                "title": "c-o-n-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for (int q : queries) {\\n            ans.push_back(get(q, intLength));\\n        }\\n        return ans;\\n    }\\n    \\n    long long get(int q, int l) {\\n        if (l==1) return q<10 ? q : -1;\\n        \\n        long long temp = pow(10, l)/pow(10, l/2 + 1);;\\n        long long ans;\\n        \\n        temp += q-1;  \\n        \\n        ans = mirror(temp, l);\\n        if (ans>=pow(10, l)) return -1;\\n        return ans;\\n    }\\n    \\n    long long mirror(long long n, int len) {\\n        int c = len/2;\\n        auto tmp = n;\\n        auto rev = 0;\\n        if(len%2 != 0) tmp/=10;\\n        while (c--) {\\n            n*=10;\\n            n+=tmp%10;\\n            tmp/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for (int q : queries) {\\n            ans.push_back(get(q, intLength));\\n        }\\n        return ans;\\n    }\\n    \\n    long long get(int q, int l) {\\n        if (l==1) return q<10 ? q : -1;\\n        \\n        long long temp = pow(10, l)/pow(10, l/2 + 1);;\\n        long long ans;\\n        \\n        temp += q-1;  \\n        \\n        ans = mirror(temp, l);\\n        if (ans>=pow(10, l)) return -1;\\n        return ans;\\n    }\\n    \\n    long long mirror(long long n, int len) {\\n        int c = len/2;\\n        auto tmp = n;\\n        auto rev = 0;\\n        if(len%2 != 0) tmp/=10;\\n        while (c--) {\\n            n*=10;\\n            n+=tmp%10;\\n            tmp/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887175,
                "title": "python-half-palindrome-pattern-observation",
                "content": "**Working:**\\nIf length `k` is 4 , \\nthen we start with left half of smallest palindrome (1001) , i,e `10` as initial value `ini`\\n- 2nd smallest: `11`  (`10+1`) (1111)\\n- 3rd smallest: `12`  (`10 +3`) (1221)\\n- 4th smallest: `13`  (`10 +3`) (1331)\\n- last smallest: `99` (9999)\\n\\n\\n**if we notice the pattern , we can see that `n`th smallest palindrome\\'s left half is the initial valiue `ini` + `n-1`**\\n\\n```\\n    def kthPalindrome(self, queries: List[int], k: int) -> List[int]:\\n        ans=[]\\n        for n in queries:\\n            dig = t=k//2 if k&1 else k//2-1\\n            ini = 10**t\\n            sol= ini+n-1\\n            if len(str(sol))>len(str(ini)):         #eg , when k=4 and our left half sol exceeds 99\\n                ans.append(-1)\\n                continue\\n            rev=sol\\n            if k&1:\\n                rev=rev//10\\n            while rev:\\n                sol=sol*10 + rev%10\\n                rev=rev//10\\n            ans.append(sol)\\n        return ans\\n```\\n\\nIf you have any questions , feel free to ask\\n\\n**Happy Coding !**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def kthPalindrome(self, queries: List[int], k: int) -> List[int]:\\n        ans=[]\\n        for n in queries:\\n            dig = t=k//2 if k&1 else k//2-1\\n            ini = 10**t\\n            sol= ini+n-1\\n            if len(str(sol))>len(str(ini)):         #eg , when k=4 and our left half sol exceeds 99\\n                ans.append(-1)\\n                continue\\n            rev=sol\\n            if k&1:\\n                rev=rev//10\\n            while rev:\\n                sol=sol*10 + rev%10\\n                rev=rev//10\\n            ans.append(sol)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1887143,
                "title": "python3-simple-math-using-string",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        x=intLength//2 + intLength%2 -1\\n        startX=10**x\\n        maxY=int(\\'9\\'*(x+1))\\n        answ=[]\\n        for q in queries:\\n            y=startX + q -1 \\n            if maxY<y:\\n                answ.append(-1)\\n            else:\\n                s=str(y)\\n                if intLength%2:\\n                    s+=s[:-1][::-1]\\n                else:\\n                    s+=s[::-1]\\n                answ.append(int(s))      \\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        x=intLength//2 + intLength%2 -1\\n        startX=10**x\\n        maxY=int(\\'9\\'*(x+1))\\n        answ=[]\\n        for q in queries:\\n            y=startX + q -1 \\n            if maxY<y:\\n                answ.append(-1)\\n            else:\\n                s=str(y)\\n                if intLength%2:\\n                    s+=s[:-1][::-1]\\n                else:\\n                    s+=s[::-1]\\n                answ.append(int(s))      \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887142,
                "title": "c-ez-math-solution-explained-in-detail-191ms",
                "content": "The approach to this problem is we generate the number in halves since its a palindrome.\\n2 conditions will arise :\\n1.  intLength will be even\\n2.  intLength will be Odd\\n In both of these condtions we need to build the first half of the number differently. If intLength is even ( Eg : intLength=4 ) then we need to generate the first half as pow(10,intLength/2-1). If intLength is odd (Eg:intLength=3) then we need to geerate the first half as pow (10,intLength/2) since in palindrome numers of odd length the middle number occurs only once (eg : 121,13831 ).\\nWhile dealing with each query[i] , we add 1 minus it to the first Half of the number. As you see our first half of the number is complete.\\neg: inLength=3 query[i] =2;\\nfirstHalf=pow(10,1)+(2-1)=11\\n\\neg: intLength = 4, query[i] =5;\\nfirstHalf=pow(10,1)+(5-1)=14\\n\\nTo generate the other half of our number we have 2 cases :\\n1.  If intLength is even then the other half would be just the reverse of the firstHalf.\\n2.  if intLength is odd then the other half would be reverse of the firstHalf after doing firstHalf/10. To prevent overlap of the middle element.\\n  At the end we check whether our number is withing the given RANGE.\\n  NOTE: To prevent integer overflows we convert ourFirst half to string and find its length If the length is greater then intLength no need to generate the otherhalf since that number will be out of range.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        long long start=pow(10,intLength%2?intLength/2:intLength/2-1);\\n        long long range=pow(10,intLength);\\n        for(int i=0;i<queries.size();i++){\\n              unsigned long long first=(queries[i]-1)+start,tmp;\\n            string str=to_string(first);\\n            if(str.length()>intLength){\\n                ans.push_back(-1);\\n                continue;\\n            }          \\n            tmp=first;\\n            if(intLength%2)\\n            tmp/=10;\\n            while(tmp)\\n            {\\n                first=(first*10)+(tmp%10);\\n                tmp/=10;\\n            }\\n            if(first>=range||first<range/10)\\n                ans.push_back(-1);\\n            else\\n            ans.push_back(first);        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        long long start=pow(10,intLength%2?intLength/2:intLength/2-1);\\n        long long range=pow(10,intLength);\\n        for(int i=0;i<queries.size();i++){\\n              unsigned long long first=(queries[i]-1)+start,tmp;\\n            string str=to_string(first);\\n            if(str.length()>intLength){\\n                ans.push_back(-1);\\n                continue;\\n            }          \\n            tmp=first;\\n            if(intLength%2)\\n            tmp/=10;\\n            while(tmp)\\n            {\\n                first=(first*10)+(tmp%10);\\n                tmp/=10;\\n            }\\n            if(first>=range||first<range/10)\\n                ans.push_back(-1);\\n            else\\n            ans.push_back(first);        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887102,
                "title": "python-easy-solution-beats-100",
                "content": "1. If length is even we need to select length/2 and append its reverse. For each l/2 number we will have 1 palindrome\\n2. if length s odd we need to select each length/2 append number 0 to 9 then append reverse of length/2 number. For each l/2 number we will have 10 palindrome\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        if intLength == 1:\\n            return [ i if i < 10 else -1 for i in queries ]\\n        else:\\n            start = 10**(intLength//2-1)\\n            end   = 10**(intLength)\\n            res = []\\n            for q in queries:\\n                q -= 1\\n                if intLength%2:\\n                    temp = str(start+q//10 ) + str(q%10) + str(start+q//10 )[::-1]\\n                else:\\n                    temp = str(start+q) +str(start+q )[::-1]\\n                temp = int(temp) if int(temp) < end else -1\\n                res.append(temp)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        if intLength == 1:\\n            return [ i if i < 10 else -1 for i in queries ]\\n        else:\\n            start = 10**(intLength//2-1)\\n            end   = 10**(intLength)\\n            res = []\\n            for q in queries:\\n                q -= 1\\n                if intLength%2:\\n                    temp = str(start+q//10 ) + str(q%10) + str(start+q//10 )[::-1]\\n                else:\\n                    temp = str(start+q) +str(start+q )[::-1]\\n                temp = int(temp) if int(temp) < end else -1\\n                res.append(temp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887093,
                "title": "python-easy-formula-short-code",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], n: int) -> List[int]:\\n        ans = []\\n        l = n // 2 if n & 1 else n // 2 - 1\\n        for q in queries:\\n            if q > 9 * 10**l:\\n                ans.append(-1)\\n            else:\\n                s = str(q - 1 + 10**l)\\n                s = s + (s[:-1][::-1] if n & 1 else s[::-1])\\n                ans.append(s)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], n: int) -> List[int]:\\n        ans = []\\n        l = n // 2 if n & 1 else n // 2 - 1\\n        for q in queries:\\n            if q > 9 * 10**l:\\n                ans.append(-1)\\n            else:\\n                s = str(q - 1 + 10**l)\\n                s = s + (s[:-1][::-1] if n & 1 else s[::-1])\\n                ans.append(s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886998,
                "title": "c-o-n-of-digits",
                "content": "Count the `nth` palindrome for `ith` query, and store the resutls. `solve2` method is used to calculate the palindrome for the `ith` query.\\n\\nIf there are `n` queries and `k` be the number of digits, then time complexity would be `O(n*k).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long solve2(int queries, int intLength){\\n        int rex = (intLength & 1) ? (intLength / 2) : (intLength/2 - 1);\\n        int tex = (int)pow(10, rex);\\n        tex += queries - 1;\\n \\n        string res = \"\";\\n        res += to_string(tex);\\n        \\n        string r1 = \"\";\\n        if (intLength & 1)\\n            tex /= 10;\\n \\n        while (tex){\\n            r1 += to_string(tex%10);\\n            tex /= 10;\\n        }\\n        \\n        if(res.size() + r1.size() == intLength){\\n            return (stoll(res+r1));\\n        }\\n        return -1;\\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        int n = queries.size();\\n        \\n        for(int i =0;i <= n-1;i++){\\n            long long t1 = solve2(queries[i],intLength);\\n            res.push_back(t1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve2(int queries, int intLength){\\n        int rex = (intLength & 1) ? (intLength / 2) : (intLength/2 - 1);\\n        int tex = (int)pow(10, rex);\\n        tex += queries - 1;\\n \\n        string res = \"\";\\n        res += to_string(tex);\\n        \\n        string r1 = \"\";\\n        if (intLength & 1)\\n            tex /= 10;\\n \\n        while (tex){\\n            r1 += to_string(tex%10);\\n            tex /= 10;\\n        }\\n        \\n        if(res.size() + r1.size() == intLength){\\n            return (stoll(res+r1));\\n        }\\n        return -1;\\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        int n = queries.size();\\n        \\n        for(int i =0;i <= n-1;i++){\\n            long long t1 = solve2(queries[i],intLength);\\n            res.push_back(t1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886997,
                "title": "python-o-n-permutation-similar-to-find-nth-word-in-dictionary",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        for i in range(len(queries)):\\n            if queries[i] > 9*(10**((intLength-1)//2)):\\n                ans.append(-1)\\n            else:\\n                if intLength > 1:\\n                    x = [1]+[0]*(intLength-2)+[1]\\n                else:\\n                    x = [1]\\n                queries[i] -= 1\\n                k = (intLength-1)//2\\n                while queries[i] > 0:\\n                    r = queries[i]%10\\n                    queries[i] = queries[i]//10\\n                    if k == intLength-k-1:\\n                        x[k] += r\\n                    else:\\n                        x[k] += r\\n                        x[intLength-k-1] += r\\n                    k -= 1\\n                ans.append(int(\"\".join([str(j) for j in x])))\\n        return ans\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        for i in range(len(queries)):\\n            if queries[i] > 9*(10**((intLength-1)//2)):\\n                ans.append(-1)\\n            else:\\n                if intLength > 1:\\n                    x = [1]+[0]*(intLength-2)+[1]\\n                else:\\n                    x = [1]\\n                queries[i] -= 1\\n                k = (intLength-1)//2\\n                while queries[i] > 0:\\n                    r = queries[i]%10\\n                    queries[i] = queries[i]//10\\n                    if k == intLength-k-1:\\n                        x[k] += r\\n                    else:\\n                        x[k] += r\\n                        x[intLength-k-1] += r\\n                    k -= 1\\n                ans.append(int(\"\".join([str(j) for j in x])))\\n        return ans\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 4079277,
                "title": "c-generating-palindrome-with-half-string-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) \\n    {\\n        vector<long long> ans;\\n        string pal;\\n        int power;\\n\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(intLength%2 == 0) power = intLength/2-1;\\n            else power = intLength/2;\\n\\n            if(pow(10, power+1) - pow(10, power) < queries[i])\\n                ans.push_back(-1);\\n            else\\n            {\\n                int temp = pow(10, power) + queries[i] - 1;\\n                pal = to_string(temp);\\n\\n                for(int i=intLength/2-1; i>=0; i--) pal += pal[i];\\n\\n                ans.push_back(stoll(pal));\\n            }\\n        }   \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) \\n    {\\n        vector<long long> ans;\\n        string pal;\\n        int power;\\n\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(intLength%2 == 0) power = intLength/2-1;\\n            else power = intLength/2;\\n\\n            if(pow(10, power+1) - pow(10, power) < queries[i])\\n                ans.push_back(-1);\\n            else\\n            {\\n                int temp = pow(10, power) + queries[i] - 1;\\n                pal = to_string(temp);\\n\\n                for(int i=intLength/2-1; i>=0; i--) pal += pal[i];\\n\\n                ans.push_back(stoll(pal));\\n            }\\n        }   \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994182,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n    start = pow(10, (intLength + 1) // 2 - 1)\\n    end = pow(10, (intLength + 1) // 2)\\n    mul = pow(10, intLength // 2)\\n\\n    def reverse(num: int) -> int:\\n      res = 0\\n      while num:\\n        res = res * 10 + num % 10\\n        num //= 10\\n      return res\\n\\n    def getKthPalindrome(query: int) -> int:\\n      prefix = start + query - 1\\n      return prefix * mul + reverse(prefix // 10 if intLength & 1 else prefix)\\n\\n    return [-1 if start + query > end else getKthPalindrome(query)\\n            for query in queries]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n    start = pow(10, (intLength + 1) // 2 - 1)\\n    end = pow(10, (intLength + 1) // 2)\\n    mul = pow(10, intLength // 2)\\n\\n    def reverse(num: int) -> int:\\n      res = 0\\n      while num:\\n        res = res * 10 + num % 10\\n        num //= 10\\n      return res\\n\\n    def getKthPalindrome(query: int) -> int:\\n      prefix = start + query - 1\\n      return prefix * mul + reverse(prefix // 10 if intLength & 1 else prefix)\\n\\n    return [-1 if start + query > end else getKthPalindrome(query)\\n            for query in queries]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892801,
                "title": "golang-simple-solution-compute-half-of-the-palindrome",
                "content": "# Code\\n```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n  answer := make([]int64, len(queries))\\n  half := (intLength + 1)/2\\n  start := int(math.Pow10(half-1))\\n  var end int\\n  for i := 0; i < half; i++ {\\n    end = end * 10 + 9\\n  }\\n  // fmt.Printf(\"start: %d, end: %d\\\\n\", start, end)\\n  for i := 0; i < len(queries); i++ {\\n    if start + queries[i] - 1 > end {\\n      answer[i] = -1\\n      continue\\n    }\\n    // Now it is possible to make the palindrome\\n    answer[i] = makePalindrome(start + queries[i] - 1, intLength%2 == 1)\\n  }\\n  return answer\\n}\\n\\n// makePalindrome makes the palindrome by using the first half. It also accepts\\n// a flag that denotes whether the palindrome is odd length or even length. For odd length\\n// we skip duplicating the last digit\\nfunc makePalindrome(half int, odd bool) int64 {\\n  n := half\\n  if odd {\\n    n /= 10 // skip the last digit\\n  }\\n  res := int64(half)\\n  for ; n > 0; n /= 10 {\\n    res = res * 10 + int64(n%10)\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Math"
                ],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n  answer := make([]int64, len(queries))\\n  half := (intLength + 1)/2\\n  start := int(math.Pow10(half-1))\\n  var end int\\n  for i := 0; i < half; i++ {\\n    end = end * 10 + 9\\n  }\\n  // fmt.Printf(\"start: %d, end: %d\\\\n\", start, end)\\n  for i := 0; i < len(queries); i++ {\\n    if start + queries[i] - 1 > end {\\n      answer[i] = -1\\n      continue\\n    }\\n    // Now it is possible to make the palindrome\\n    answer[i] = makePalindrome(start + queries[i] - 1, intLength%2 == 1)\\n  }\\n  return answer\\n}\\n\\n// makePalindrome makes the palindrome by using the first half. It also accepts\\n// a flag that denotes whether the palindrome is odd length or even length. For odd length\\n// we skip duplicating the last digit\\nfunc makePalindrome(half int, odd bool) int64 {\\n  n := half\\n  if odd {\\n    n /= 10 // skip the last digit\\n  }\\n  res := int64(half)\\n  for ; n > 0; n /= 10 {\\n    res = res * 10 + int64(n%10)\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846571,
                "title": "python-simple-100-faster",
                "content": "```\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        half_length = (intLength+1)//2 # this handles even and odd both \\n        left_bound = 10**(half_length-1)\\n        right_bound = 10**(half_length)-1\\n        \\n        for query in queries:\\n            if query>(right_bound-left_bound+1):\\n                ans.append(-1)\\n                continue\\n            # add the answers string\\n            left_palli = str(left_bound+query - 1)\\n            right_palli = left_palli[::-1]\\n            # queryth pallindrome will be formed once we combine both \\n            pallindrome = left_palli + right_palli[intLength%2:]\\n            ans.append(int(pallindrome))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        half_length = (intLength+1)//2 # this handles even and odd both \\n        left_bound = 10**(half_length-1)\\n        right_bound = 10**(half_length)-1\\n        \\n        for query in queries:\\n            if query>(right_bound-left_bound+1):\\n                ans.append(-1)\\n                continue\\n            # add the answers string\\n            left_palli = str(left_bound+query - 1)\\n            right_palli = left_palli[::-1]\\n            # queryth pallindrome will be formed once we combine both \\n            pallindrome = left_palli + right_palli[intLength%2:]\\n            ans.append(int(pallindrome))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723594,
                "title": "js-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe actual code is really messy but on paper it\\'s pretty simple.\\n\\nWe need:\\n\\n- Amount of possible answers for `intLength`, so we can check if query is out of range.\\n- Different approach for odd and even number of `intLength`.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## setup\\n\\nFor the amount of possible answers, we can calculate it with math.\\n- odd: $$(10^n-10^{n-1})\\\\times10$$\\n- even: $$(10^n-10^{n-1})$$\\n\\nThe reason for subtracting $$10^{n-1}$$ is to prevent false answers. For example 1000 on right hand side, which mirrors to the left side as 0001. Let `intLength` to be 8, the answer will be `00011000`, or just `11000`.\\n\\nThe reason for $$\\\\times10$$ for odd `intLength` is for digit at the center (`0~9`).\\n\\n`n`, `tenPower` is pretty self explanatory, however the latter one is such a dumb variable name I suggest you come up with a better one.\\n\\n`tenPowerLess` is an awkward one. It needs to exists so we don\\'t run into annoying float precision problems, so I replaced `tenPower/10`. But in hindsight, I would make `tenPower` $$10^{n-1}$$ to make it look cleaner, but hey, it works.\\n\\n## Odd `intLength` Answers\\n\\nWe\\'ll calculate the middle digit together with left-side, so it\\'s easier to make sure the first digit is always non-zero, and incrementing left-side increments the result faster than incrementing the center digit or the right-side.\\n\\nRemember to $$-1$$ because `left` starts at 10*n.\\n\\nThen, reverse the right-side and add everything together.\\n\\n## Even `intLength` Answers\\n\\n`left` here starts at $$10^{n-1}$$. The rest is pretty much the same as odd `intLength` answers. Maybe you can try simplifying this if statement?\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst kthPalindrome = function(queries, intLength) {\\n    const reverse = (n) => {\\n        let result = 0\\n        while(n){\\n            result=(result*10)+n%10;\\n            n=Math.floor(n/10);\\n        }\\n        return result;\\n    }\\n    const n = Math.floor(intLength/2);\\n    const tenPowerLess = 10**(n-1);\\n    const tenPower = tenPowerLess*10;\\n    const count = (tenPower - tenPowerLess) * ((intLength%2)? 10 : 1);\\n    return queries.map((value,index)=>{\\n        if (value>count) return -1;\\n        if (intLength%2) {\\n            const left = value-1+tenPower;\\n            return left*tenPower + reverse(Math.floor(left/10));\\n        } else {\\n            const left = tenPowerLess + value - 1;\\n            // console.log(index,left,tenPower,value)\\n            return left*tenPower + reverse(left);\\n        }\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kthPalindrome = function(queries, intLength) {\\n    const reverse = (n) => {\\n        let result = 0\\n        while(n){\\n            result=(result*10)+n%10;\\n            n=Math.floor(n/10);\\n        }\\n        return result;\\n    }\\n    const n = Math.floor(intLength/2);\\n    const tenPowerLess = 10**(n-1);\\n    const tenPower = tenPowerLess*10;\\n    const count = (tenPower - tenPowerLess) * ((intLength%2)? 10 : 1);\\n    return queries.map((value,index)=>{\\n        if (value>count) return -1;\\n        if (intLength%2) {\\n            const left = value-1+tenPower;\\n            return left*tenPower + reverse(Math.floor(left/10));\\n        } else {\\n            const left = tenPowerLess + value - 1;\\n            // console.log(index,left,tenPower,value)\\n            return left*tenPower + reverse(left);\\n        }\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707888,
                "title": "c-simple-short-clean-code",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Adhoc Pattern\\n    //TC=O(N) N=size of queries\\n    //SC=O(N)\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n=queries.size();\\n        vector<long long> ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> v(intLength,0);\\n            v[0]=1,v[intLength-1]=1;\\n            int mid=intLength/2,no=queries[i];\\n            bool nonzero=false;\\n            //fill last digit of no  in vector v\\n            if(intLength%2!=0){\\n                v[mid]=(no%10)-1;\\n                no/=10;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                }\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n               \\n            }else{\\n                v[mid-1]=(no%10)-1;\\n                v[mid]=(no%10)-1;\\n                 no/=10;\\n                 //if it  first digit is  last digit then don\\'t need to do -1. so we do ++;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                    v[mid-1]++;\\n                }\\n                //if last digit is 0 then chaged to 9\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                    v[mid-1]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n                \\n                \\n            }\\n            int lo=-1,hi=-1;\\n            //even\\n            if(intLength%2==0){\\n                lo=mid-2;\\n                hi=mid+1;\\n            }else{\\n                //odd\\n                lo=mid-1;\\n                hi=mid+1;\\n            }\\n            bool flag=true;\\n            while(no>0 && lo>=0 && hi<intLength){\\n                int rem=no%10;\\n                no/=10;                \\n                if(nonzero==false){\\n                    v[lo]+=(rem-1);\\n                    v[hi]+=(rem-1);\\n                    if(v[lo]==-1){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;hi++;                   \\n                    if(rem!=0){\\n                        nonzero=true;\\n                    }   \\n                    continue;\\n                }\\n                \\n                    v[lo]+=rem;\\n                    v[hi]+=rem;\\n                    //can\\'t make palidrom\\n                    if(v[lo]==10){\\n                        ans[i]=-1;\\n                        flag=false;\\n                        break;\\n                    }                    \\n                    if(v[lo]==0 && nonzero==false){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;\\n                    hi++;\\n                 \\n            }\\n            //intLenght shorter & no is large so can\\'t make palidrome\\n            if(no>0){\\n                ans[i]=-1;\\n                continue;\\n            }\\n            if(flag){\\n                long long curr=0;\\n                for(int j=0;j<v.size();j++){\\n                    curr=curr*10+v[j];\\n                }\\n                ans[i]=curr;\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```\\n//**It Take me 2 hour to solve this problem\\uD83D\\uDE13**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Adhoc Pattern\\n    //TC=O(N) N=size of queries\\n    //SC=O(N)\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n=queries.size();\\n        vector<long long> ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> v(intLength,0);\\n            v[0]=1,v[intLength-1]=1;\\n            int mid=intLength/2,no=queries[i];\\n            bool nonzero=false;\\n            //fill last digit of no  in vector v\\n            if(intLength%2!=0){\\n                v[mid]=(no%10)-1;\\n                no/=10;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                }\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n               \\n            }else{\\n                v[mid-1]=(no%10)-1;\\n                v[mid]=(no%10)-1;\\n                 no/=10;\\n                 //if it  first digit is  last digit then don\\'t need to do -1. so we do ++;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                    v[mid-1]++;\\n                }\\n                //if last digit is 0 then chaged to 9\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                    v[mid-1]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n                \\n                \\n            }\\n            int lo=-1,hi=-1;\\n            //even\\n            if(intLength%2==0){\\n                lo=mid-2;\\n                hi=mid+1;\\n            }else{\\n                //odd\\n                lo=mid-1;\\n                hi=mid+1;\\n            }\\n            bool flag=true;\\n            while(no>0 && lo>=0 && hi<intLength){\\n                int rem=no%10;\\n                no/=10;                \\n                if(nonzero==false){\\n                    v[lo]+=(rem-1);\\n                    v[hi]+=(rem-1);\\n                    if(v[lo]==-1){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;hi++;                   \\n                    if(rem!=0){\\n                        nonzero=true;\\n                    }   \\n                    continue;\\n                }\\n                \\n                    v[lo]+=rem;\\n                    v[hi]+=rem;\\n                    //can\\'t make palidrom\\n                    if(v[lo]==10){\\n                        ans[i]=-1;\\n                        flag=false;\\n                        break;\\n                    }                    \\n                    if(v[lo]==0 && nonzero==false){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;\\n                    hi++;\\n                 \\n            }\\n            //intLenght shorter & no is large so can\\'t make palidrome\\n            if(no>0){\\n                ans[i]=-1;\\n                continue;\\n            }\\n            if(flag){\\n                long long curr=0;\\n                for(int j=0;j<v.size();j++){\\n                    curr=curr*10+v[j];\\n                }\\n                ans[i]=curr;\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664005,
                "title": "swift-version-of-most-voted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        /**\\n         \\n         Only the first (intLength + 1) / 2 characters matter. The remaining characters are just a reflection.\\n\\n         Say intLength == 7, so we consider only 4 characters. The minimum number is 1000 and maximum - 9999.\\n\\n         Therefore, we can have 9999 - 1000 + 1 == 9000 palindromes. To find out the palindrome, we add a q - 1 to the minimum number, reverse, and concatenate.\\n\\n         For example, for query 8765, the base number is 1000 + 8765 - 1 == 9764. Concatenating it with 679, we get 9764679 as the result.\\n         \\n         */\\n        let significantNums: Int = (intLength + 1) / 2\\n        let min = (pow(10, significantNums-1) as NSDecimalNumber).intValue // 10^s\\n        let max = (pow(10, significantNums) as NSDecimalNumber).intValue - 1 // 10^(s+1) - 1\\n        \\n        let numsAvailableOfIntLength = max - min + 1\\n        var ans: [Int] = []\\n        for q in queries {\\n            if q > numsAvailableOfIntLength {\\n                ans.append(-1)\\n                continue\\n            }\\n            let firstHalf = min + (q - 1)\\n            let firstHalfAsString = String(firstHalf)\\n            let numOfCharsToDrop = intLength % 2\\n            let stringForReverse = String(firstHalfAsString.dropLast(numOfCharsToDrop))\\n            let reversedHalf = String(stringForReverse.reversed())\\n            let palindrome = firstHalfAsString + reversedHalf\\n            ans.append(Int(palindrome) ?? -1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        /**\\n         \\n         Only the first (intLength + 1) / 2 characters matter. The remaining characters are just a reflection.\\n\\n         Say intLength == 7, so we consider only 4 characters. The minimum number is 1000 and maximum - 9999.\\n\\n         Therefore, we can have 9999 - 1000 + 1 == 9000 palindromes. To find out the palindrome, we add a q - 1 to the minimum number, reverse, and concatenate.\\n\\n         For example, for query 8765, the base number is 1000 + 8765 - 1 == 9764. Concatenating it with 679, we get 9764679 as the result.\\n         \\n         */\\n        let significantNums: Int = (intLength + 1) / 2\\n        let min = (pow(10, significantNums-1) as NSDecimalNumber).intValue // 10^s\\n        let max = (pow(10, significantNums) as NSDecimalNumber).intValue - 1 // 10^(s+1) - 1\\n        \\n        let numsAvailableOfIntLength = max - min + 1\\n        var ans: [Int] = []\\n        for q in queries {\\n            if q > numsAvailableOfIntLength {\\n                ans.append(-1)\\n                continue\\n            }\\n            let firstHalf = min + (q - 1)\\n            let firstHalfAsString = String(firstHalf)\\n            let numOfCharsToDrop = intLength % 2\\n            let stringForReverse = String(firstHalfAsString.dropLast(numOfCharsToDrop))\\n            let reversedHalf = String(stringForReverse.reversed())\\n            let palindrome = firstHalfAsString + reversedHalf\\n            ans.append(Int(palindrome) ?? -1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663559,
                "title": "1-line-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe k\\'th smallest palindrome of a certain length is basically the concatenation of the k\\'th smallest number of half that length rounded up and that number in reverse, potentially without the last digit if the length is odd\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIndexing a range to get the k\\'th number in the range easily\\n\\n# Complexity\\nn being len(queries):\\n\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        return [base:=range(int(10**(-(-intLength//2)-1)),int(10**(-(-intLength//2))))] and [(int(str(base[q-1])+str(base[q-1])[(-1 if intLength%2==0 else -2)::-1]) if q<=len(base) else -1) for q in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        return [base:=range(int(10**(-(-intLength//2)-1)),int(10**(-(-intLength//2))))] and [(int(str(base[q-1])+str(base[q-1])[(-1 if intLength%2==0 else -2)::-1]) if q<=len(base) else -1) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528201,
                "title": "go-beginner",
                "content": "\\n# Code\\n```\\n\\nimport (\\n\\t\"math\"\\n\\t\"strconv\"\\n)\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    ret := make([]int64, len(queries))\\n    for i, q := range queries {\\n        ret[i] = GetNthPalindrome(q, intLength)\\n    }\\n    return ret\\n}\\n\\n\\nfunc GetNthPalindrome(nth, length int) int64 {\\n\\tif length == 1 {\\n\\t\\tif nth <= 9 {\\n\\t\\t\\treturn int64(nth)\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\tdigits := make([]byte, length)\\n\\n\\toperationNumLength := length/2 + (length % 2)\\n\\ttargetNum := int(math.Pow(10, float64(operationNumLength-1))) + nth - 1\\n\\tmaxNum := int(math.Pow(10, float64(operationNumLength)))\\n\\tif targetNum >= maxNum {\\n\\t\\treturn -1\\n\\t}\\n\\thalfStr := strconv.Itoa(targetNum)\\n\\n\\tfor i, c := range halfStr {\\n\\t\\tnum := int(c - \\'0\\')\\n\\t\\tdigits[i] = byte(num)\\n\\t\\tdigits[length-i-1] = byte(num)\\n\\t}\\n\\n\\tstr := \"\"\\n\\n\\tfor _, v := range digits {\\n\\t\\tstr += strconv.Itoa(int(v))\\n\\t}\\n\\n\\tret, _ := strconv.Atoi(str)\\n\\treturn int64(ret)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nimport (\\n\\t\"math\"\\n\\t\"strconv\"\\n)\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    ret := make([]int64, len(queries))\\n    for i, q := range queries {\\n        ret[i] = GetNthPalindrome(q, intLength)\\n    }\\n    return ret\\n}\\n\\n\\nfunc GetNthPalindrome(nth, length int) int64 {\\n\\tif length == 1 {\\n\\t\\tif nth <= 9 {\\n\\t\\t\\treturn int64(nth)\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\tdigits := make([]byte, length)\\n\\n\\toperationNumLength := length/2 + (length % 2)\\n\\ttargetNum := int(math.Pow(10, float64(operationNumLength-1))) + nth - 1\\n\\tmaxNum := int(math.Pow(10, float64(operationNumLength)))\\n\\tif targetNum >= maxNum {\\n\\t\\treturn -1\\n\\t}\\n\\thalfStr := strconv.Itoa(targetNum)\\n\\n\\tfor i, c := range halfStr {\\n\\t\\tnum := int(c - \\'0\\')\\n\\t\\tdigits[i] = byte(num)\\n\\t\\tdigits[length-i-1] = byte(num)\\n\\t}\\n\\n\\tstr := \"\"\\n\\n\\tfor _, v := range digits {\\n\\t\\tstr += strconv.Itoa(int(v))\\n\\t}\\n\\n\\tret, _ := strconv.Atoi(str)\\n\\treturn int64(ret)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3503806,
                "title": "easy-jaaava-solution-just-simple-maths-beats-95-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose intLength =4;\\nwe need to check intLength/2 as it should be a palindrome,so here first 2.\\n1st place can have 9 possible numbers(1-9),and second place can have 10 numbers(0-9),also any nth(n>2) place can have 10 possible numbers.\\nHence,total max palindrome possible are 9*pow(10,intLength/2-1).\\nCode is self explanatory..\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple trick is you should take n-1 to do the calculation.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n       \\n        int[] a = new int[intLength];\\n        long[] ans = new long[queries.length];\\n        if(intLength==1 || intLength==2){\\n        for(int i=0;i<ans.length;i++){\\n            if(queries[i]>9)ans[i]=-1;\\n            else{\\n            long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+queries[i];\\n                ans[i]=h;}\\n        }\\n        return ans;\\n        }\\n\\n        for(int i=0;i<ans.length;i++){\\n            int l=0,u=a.length-1,m=(u/2);\\n            l+=m;\\n            u-=m;\\n            double x= 9*Math.pow(10,l);\\n            if(queries[i]>(int)x)ans[i]=-1;\\n            else{\\n                int n = queries[i]-1;\\n                while(n>0 && l>0){\\n                a[u++]=n%10;\\n                a[l--]=n%10;\\n                n/=10;\\n                }\\n                if(n==0 ){\\n                    while(l>0){\\n                        a[u++]=0;\\n                        a[l--]=0;\\n                    }\\n                    a[u++]=1;\\n                    a[l--]=1;\\n                }\\n                else if(l==0){\\n                a[u++]=n%10+1;\\n                a[l--]=n%10+1;\\n                }\\n                long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+a[k];\\n                ans[i]=h;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n       \\n        int[] a = new int[intLength];\\n        long[] ans = new long[queries.length];\\n        if(intLength==1 || intLength==2){\\n        for(int i=0;i<ans.length;i++){\\n            if(queries[i]>9)ans[i]=-1;\\n            else{\\n            long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+queries[i];\\n                ans[i]=h;}\\n        }\\n        return ans;\\n        }\\n\\n        for(int i=0;i<ans.length;i++){\\n            int l=0,u=a.length-1,m=(u/2);\\n            l+=m;\\n            u-=m;\\n            double x= 9*Math.pow(10,l);\\n            if(queries[i]>(int)x)ans[i]=-1;\\n            else{\\n                int n = queries[i]-1;\\n                while(n>0 && l>0){\\n                a[u++]=n%10;\\n                a[l--]=n%10;\\n                n/=10;\\n                }\\n                if(n==0 ){\\n                    while(l>0){\\n                        a[u++]=0;\\n                        a[l--]=0;\\n                    }\\n                    a[u++]=1;\\n                    a[l--]=1;\\n                }\\n                else if(l==0){\\n                a[u++]=n%10+1;\\n                a[l--]=n%10+1;\\n                }\\n                long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+a[k];\\n                ans[i]=h;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453217,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nfirst half part of palindrome also are ordered, so we construct first half part of palindrome first, and construct palindrome with reversed first half part, and make query to 0-based first.\\nbecause the number can not have leading zeros, so we can use a base number to construct first half part,\\nbase number is half of intLength and first digit start from 1, the remain start from 0,\\ne,g., intLength = 3, so base number is 10\\nand queries[i] = 90, we make query to 0-based first, 89. And add it to base number, 99, \\nand construct palindrome with reversed number \\'99\\' + \\'9\\' = \\'999\\'\\n\\ntc is O(len(queries)*intLength), sc is O(len(queries))\\n\\'\\'\\'\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = 10 ** ((intLength - 1) // 2)\\n        ans = [q - 1 + base for q in queries]\\n        for idx, half in enumerate(ans):\\n            half = str(half) + str(half)[-1-intLength % 2::-1]\\n            ans[idx] = int(half) if len(half) == intLength else -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\nfirst half part of palindrome also are ordered, so we construct first half part of palindrome first, and construct palindrome with reversed first half part, and make query to 0-based first.\\nbecause the number can not have leading zeros, so we can use a base number to construct first half part,\\nbase number is half of intLength and first digit start from 1, the remain start from 0,\\ne,g., intLength = 3, so base number is 10\\nand queries[i] = 90, we make query to 0-based first, 89. And add it to base number, 99, \\nand construct palindrome with reversed number \\'99\\' + \\'9\\' = \\'999\\'\\n\\ntc is O(len(queries)*intLength), sc is O(len(queries))\\n\\'\\'\\'\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = 10 ** ((intLength - 1) // 2)\\n        ans = [q - 1 + base for q in queries]\\n        for idx, half in enumerate(ans):\\n            half = str(half) + str(half)[-1-intLength % 2::-1]\\n            ans[idx] = int(half) if len(half) == intLength else -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390629,
                "title": "javascript-half-at-a-time",
                "content": "```\\nconst kthPalindrome = function (q, len) {\\n  let half = 10 ** (Math.ceil(len / 2) - 1);\\n\\n  let ans = [];\\n  for (let nth of q) {\\n    let palindrome = String(half + (nth - 1));\\n\\n    if (len % 2) {\\n      palindrome += [...palindrome.substring(0, palindrome.length - 1)]\\n        .reverse()\\n        .join(\"\");\\n    } else {\\n      palindrome += [...palindrome].reverse().join(\"\");\\n    }\\n\\n    palindrome.length > len ? ans.push(-1) : ans.push(+palindrome);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kthPalindrome = function (q, len) {\\n  let half = 10 ** (Math.ceil(len / 2) - 1);\\n\\n  let ans = [];\\n  for (let nth of q) {\\n    let palindrome = String(half + (nth - 1));\\n\\n    if (len % 2) {\\n      palindrome += [...palindrome.substring(0, palindrome.length - 1)]\\n        .reverse()\\n        .join(\"\");\\n    } else {\\n      palindrome += [...palindrome].reverse().join(\"\");\\n    }\\n\\n    palindrome.length > len ? ans.push(-1) : ans.push(+palindrome);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356616,
                "title": "transformation-of-input",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec kth_palindrome(queries :: [integer], int_length :: integer) :: [integer]\\n  def kth_palindrome(queries, int_length) do\\n    Enum.map(queries, fn query -> int_to_palindrome(query, int_length) end)\\n  end\\n\\n  defp int_to_palindrome(query, int_length) do\\n    half_length = ceil(int_length / 2)\\n    if query <= 10 ** (half_length - 1) * 9 do\\n      10 ** (half_length - 1) + query - 1\\n      |> Integer.to_string()\\n      |> (fn x ->\\n          rev =\\n            x\\n            |> String.codepoints()\\n            |> Enum.reverse()\\n            |> (fn [a | b] -> if(rem(int_length, 2) == 0, do: [a | b], else: b) end).()\\n            |> Enum.join()\\n          \\n          x <> rev\\n        end).()\\n      |> String.to_integer()\\n    else\\n      -1\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec kth_palindrome(queries :: [integer], int_length :: integer) :: [integer]\\n  def kth_palindrome(queries, int_length) do\\n    Enum.map(queries, fn query -> int_to_palindrome(query, int_length) end)\\n  end\\n\\n  defp int_to_palindrome(query, int_length) do\\n    half_length = ceil(int_length / 2)\\n    if query <= 10 ** (half_length - 1) * 9 do\\n      10 ** (half_length - 1) + query - 1\\n      |> Integer.to_string()\\n      |> (fn x ->\\n          rev =\\n            x\\n            |> String.codepoints()\\n            |> Enum.reverse()\\n            |> (fn [a | b] -> if(rem(int_length, 2) == 0, do: [a | b], else: b) end).()\\n            |> Enum.join()\\n          \\n          x <> rev\\n        end).()\\n      |> String.to_integer()\\n    else\\n      -1\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3330032,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int k = ceil(intLength / 2.0);\\n        int start = pow(10, k - 1);\\n        vector<long long> ans(queries.size(), -1);\\n        for(int i = 0; i < queries.size(); i++) {\\n            long long val = start + queries[i] - 1;\\n            string suffix = to_string(val);\\n            reverse(suffix.begin(), suffix.end());\\n            string res = to_string(val) + suffix.substr(intLength & 1);\\n            if(res.length() == intLength) ans[i] = stol(res);\\n        }       \\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc reverse(s []byte) string {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n    return string(s)\\n}\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    var k int = (intLength  + 1) / 2\\n    var start int = int(math.Pow(10.0, float64(k - 1)))\\n    ans := make([]int64, len(queries))\\n    for i := 0; i < len(queries); i++ {\\n        val := start + queries[i] - 1\\n        prefix := strconv.Itoa(val) \\n        res := prefix + reverse([]byte(prefix))[intLength % 2:]\\n        ans[i] = -1\\n        if len(res) == intLength {ans[i], _ = strconv.ParseInt(res, 10, 64)}\\n    }       \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int k = ceil(intLength / 2.0);\\n        int start = pow(10, k - 1);\\n        vector<long long> ans(queries.size(), -1);\\n        for(int i = 0; i < queries.size(); i++) {\\n            long long val = start + queries[i] - 1;\\n            string suffix = to_string(val);\\n            reverse(suffix.begin(), suffix.end());\\n            string res = to_string(val) + suffix.substr(intLength & 1);\\n            if(res.length() == intLength) ans[i] = stol(res);\\n        }       \\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc reverse(s []byte) string {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n    return string(s)\\n}\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    var k int = (intLength  + 1) / 2\\n    var start int = int(math.Pow(10.0, float64(k - 1)))\\n    ans := make([]int64, len(queries))\\n    for i := 0; i < len(queries); i++ {\\n        val := start + queries[i] - 1\\n        prefix := strconv.Itoa(val) \\n        res := prefix + reverse([]byte(prefix))[intLength % 2:]\\n        ans[i] = -1\\n        if len(res) == intLength {ans[i], _ = strconv.ParseInt(res, 10, 64)}\\n    }       \\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222118,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I created a smallest pelindrom number of the given length by creating an int array each with index correspond to each int index, then there are two cases, one is whene it is odd and the other is when it is even. I iterate through all the indices in the given query to create each number. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe way I make the number is to see the remainder of the query[i]. As long as it is with in bond or greater than 0, I know I need to find a bigger number. The reason to substract 1 from query[i] is because the 1st  represent a 0 which should be number 1, the 9th represent 8, and 10th represent a 9. However, after the first index in the middle, the other index will have 1st represent a 1, and so 9 represent a 9, 10 represent a 0.\\n\\n# Complexity\\nLet the size of query be M, and the length be N. \\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(MN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n   public long[] kthPalindrome(int[] queries, int intLength) {\\n        int[] c;\\n        long[] rv = new long[queries.length];\\n        boolean oddOrE = intLength%2 == 0;\\n        int index;\\n        for(int i = 0; i < queries.length;i++) {\\n            c = new int[intLength];\\n            c[0] = 1;\\n            c[intLength-1] = 1;\\n            index = 1;\\n            if (oddOrE) {\\n                c[intLength/2] += (queries[i]-1)%10;\\n                c[intLength/2-1] = c[intLength/2];\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index-1 >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index-1] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            } else {\\n                c[intLength / 2] += (queries[i]-1)%10;\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            }\\n            if(c[0] >= 10 || queries[i]!= 0){\\n                rv[i] = -1;\\n            }else{\\n                for(int j = 0; j < intLength;j++){\\n                    rv[i] = rv[i]*10 + c[j];\\n                }\\n            }\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public long[] kthPalindrome(int[] queries, int intLength) {\\n        int[] c;\\n        long[] rv = new long[queries.length];\\n        boolean oddOrE = intLength%2 == 0;\\n        int index;\\n        for(int i = 0; i < queries.length;i++) {\\n            c = new int[intLength];\\n            c[0] = 1;\\n            c[intLength-1] = 1;\\n            index = 1;\\n            if (oddOrE) {\\n                c[intLength/2] += (queries[i]-1)%10;\\n                c[intLength/2-1] = c[intLength/2];\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index-1 >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index-1] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            } else {\\n                c[intLength / 2] += (queries[i]-1)%10;\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            }\\n            if(c[0] >= 10 || queries[i]!= 0){\\n                rv[i] = -1;\\n            }else{\\n                for(int j = 0; j < intLength;j++){\\n                    rv[i] = rv[i]*10 + c[j];\\n                }\\n            }\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221998,
                "title": "dart-odd-even-approach",
                "content": "# Intuition\\nPick the middle of intLength and calculate left and reverse it and append to the right.\\n\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> kthPalindrome(List<int> queries, int intLength) {\\n    int oddLen = intLength ~/ 2;\\n    int evenLen = (intLength ~/ 2) - 1;\\n    int len = intLength.isEven ? evenLen : oddLen;\\n    int start = pow(10, len).toInt();\\n\\n    for (var i = 0; i < queries.length; i++) {\\n      var x = start + queries[i] - 1;\\n      var s = x.toString();\\n      if (intLength.isEven) {\\n        s += s.split(\\'\\').reversed.join();\\n      } else {\\n        s += s.substring(0, len).split(\\'\\').reversed.join();\\n      }\\n      if (s.length > intLength) {\\n        queries[i] = -1;\\n      } else {\\n        queries[i] = int.parse(s);\\n      }\\n    }\\n\\n    return queries;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> kthPalindrome(List<int> queries, int intLength) {\\n    int oddLen = intLength ~/ 2;\\n    int evenLen = (intLength ~/ 2) - 1;\\n    int len = intLength.isEven ? evenLen : oddLen;\\n    int start = pow(10, len).toInt();\\n\\n    for (var i = 0; i < queries.length; i++) {\\n      var x = start + queries[i] - 1;\\n      var s = x.toString();\\n      if (intLength.isEven) {\\n        s += s.split(\\'\\').reversed.join();\\n      } else {\\n        s += s.substring(0, len).split(\\'\\').reversed.join();\\n      }\\n      if (s.length > intLength) {\\n        queries[i] = -1;\\n      } else {\\n        queries[i] = int.parse(s);\\n      }\\n    }\\n\\n    return queries;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219686,
                "title": "formula-in-go",
                "content": "\\n\\n# Code\\n```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    answerArr := make([]int64, len(queries))\\n\\n    for i, v := range queries {\\n        answerArr[i] = getPalindrome(v, intLength)\\n    }\\n    return answerArr\\n}\\n\\nfunc getPalindrome(x int, intLengthIn int) int64 {\\n    \\n    // fmt.Println(\"1) Count\", int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)))\\n    \\n    if x > int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)) {\\n        return int64(-1)\\n    }\\n    \\n    num := int((x - 1) + int(math.Pow10((intLengthIn - 1)/2))) * int(math.Pow10((intLengthIn)/2))\\n    // fmt.Println(\"2) num  \", num)\\n    x = (num / (int(math.Pow10((intLengthIn + 1)/2))))\\n    // fmt.Println(\"3) x    \", x)\\n    count := (intLengthIn)/2\\n    revx := 0\\n    for i := 1; x > 0; i++{\\n        // fmt.Println(\"--->\", x % 10)\\n        revx = revx + (x % 10) * int(math.Pow10(count - i))\\n        x = x / 10\\n    }\\n    // fmt.Println(\"4) revx \", revx)\\n    return int64(num + revx)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    answerArr := make([]int64, len(queries))\\n\\n    for i, v := range queries {\\n        answerArr[i] = getPalindrome(v, intLength)\\n    }\\n    return answerArr\\n}\\n\\nfunc getPalindrome(x int, intLengthIn int) int64 {\\n    \\n    // fmt.Println(\"1) Count\", int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)))\\n    \\n    if x > int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)) {\\n        return int64(-1)\\n    }\\n    \\n    num := int((x - 1) + int(math.Pow10((intLengthIn - 1)/2))) * int(math.Pow10((intLengthIn)/2))\\n    // fmt.Println(\"2) num  \", num)\\n    x = (num / (int(math.Pow10((intLengthIn + 1)/2))))\\n    // fmt.Println(\"3) x    \", x)\\n    count := (intLengthIn)/2\\n    revx := 0\\n    for i := 1; x > 0; i++{\\n        // fmt.Println(\"--->\", x % 10)\\n        revx = revx + (x % 10) * int(math.Pow10(count - i))\\n        x = x / 10\\n    }\\n    // fmt.Println(\"4) revx \", revx)\\n    return int64(num + revx)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3200613,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    LL flip(LL val){\\n        LL ret = 0 ;\\n        while(val){\\n            ret = ret*10 + val%10 ;\\n            val /= 10 ;\\n        }\\n        return ret ;\\n    }\\n    \\n    LL getKth(int digit, int k){\\n        LL ret ;\\n        if(k > 9*pow(10, digit-1))\\n            return -1 ;\\n        return pow(10, digit-1) + k - 1;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<LL>ret ;\\n        for(int k : queries){\\n            if(intLength % 2 == 0)\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d) + b) ;\\n            }\\n            else\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d+1, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL c = a%10 ;\\n                a /= 10 ;\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d+1) + c*pow(10, d) + b ) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    LL flip(LL val){\\n        LL ret = 0 ;\\n        while(val){\\n            ret = ret*10 + val%10 ;\\n            val /= 10 ;\\n        }\\n        return ret ;\\n    }\\n    \\n    LL getKth(int digit, int k){\\n        LL ret ;\\n        if(k > 9*pow(10, digit-1))\\n            return -1 ;\\n        return pow(10, digit-1) + k - 1;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<LL>ret ;\\n        for(int k : queries){\\n            if(intLength % 2 == 0)\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d) + b) ;\\n            }\\n            else\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d+1, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL c = a%10 ;\\n                a /= 10 ;\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d+1) + c*pow(10, d) + b ) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182925,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        res = []\\n        for x in queries:\\n            temp = str(x + 10**((intLength-1)//2) - 1)\\n            if len(temp) > (intLength+1)//2:\\n                res.append(-1)\\n            else:\\n                if intLength%2 == 0:\\n                    temp += temp[::-1]\\n\\n                else:\\n                    temp += temp[-2::-1]\\n\\n                res.append(int(temp))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        res = []\\n        for x in queries:\\n            temp = str(x + 10**((intLength-1)//2) - 1)\\n            if len(temp) > (intLength+1)//2:\\n                res.append(-1)\\n            else:\\n                if intLength%2 == 0:\\n                    temp += temp[::-1]\\n\\n                else:\\n                    temp += temp[-2::-1]\\n\\n                res.append(int(temp))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157951,
                "title": "python-short-solution-with-explanation-playing-with-half",
                "content": "```\\ns_half: 99...9 - There are \\'ceil(x/2)-1\\' 9s (starting point of half)\\nmx_half: 99...9 - There are \\'ceil(x/2)\\' 9s  (max value of half)\\n```\\nWith the definition above, the **half** of `kth Palindrome` is `s_half+k` if `s_half+k <= mx_half`\\nLet us walk a few examples with `x = 3`\\n```\\ns_half = 9, mx_half = 99\\nk = 2, the half of 2nd Palindrome is 9+2 = 11 <= mx_half --> 111\\nk = 90, the half of 90th Palindrome is 9+90 = 99 <= mx_half --> 999\\nk = 100, the half of 100th Palindrome is 9+100 = 109 > mx_half --> -1\\n```\\n\\n\\n```\\ndef kthPalindrome(self, qs: List[int], x: int) -> List[int]:\\n\\tmx_half, s_half, ans = int(\\'9\\'*ceil(x/2)), int(\\'1\\'+\\'0\\'*(ceil(x/2)-1))-1, []\\n\\tfor i in qs:\\n\\t\\tans.append(-1)\\n\\t\\tif s_half+i<=mx_half:\\n\\t\\t\\tn = str(s_half+i)\\n\\t\\t\\tans[-1] = int(n+n[:x-len(n)][::-1])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ns_half: 99...9 - There are \\'ceil(x/2)-1\\' 9s (starting point of half)\\nmx_half: 99...9 - There are \\'ceil(x/2)\\' 9s  (max value of half)\\n```\n```\\ns_half = 9, mx_half = 99\\nk = 2, the half of 2nd Palindrome is 9+2 = 11 <= mx_half --> 111\\nk = 90, the half of 90th Palindrome is 9+90 = 99 <= mx_half --> 999\\nk = 100, the half of 100th Palindrome is 9+100 = 109 > mx_half --> -1\\n```\n```\\ndef kthPalindrome(self, qs: List[int], x: int) -> List[int]:\\n\\tmx_half, s_half, ans = int(\\'9\\'*ceil(x/2)), int(\\'1\\'+\\'0\\'*(ceil(x/2)-1))-1, []\\n\\tfor i in qs:\\n\\t\\tans.append(-1)\\n\\t\\tif s_half+i<=mx_half:\\n\\t\\t\\tn = str(s_half+i)\\n\\t\\t\\tans[-1] = int(n+n[:x-len(n)][::-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3118842,
                "title": "swift-solution",
                "content": "\\n# Complexity\\n- Time complexity: On\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        queries.map { getPlindrome($0, intLength)}\\n    }\\n\\n    func getPlindrome(_ n: Int, _ lenght: Int) -> Int {\\n    let halfCountNumbers = lenght.isMultiple(of: 2) ? lenght / 2 : lenght / 2 + 1\\n\\n    var number = 1\\n\\n    (0..<halfCountNumbers - 1).forEach { _ in\\n        number *= 10\\n    }\\n\\n    let max = number * 10 - number\\n    guard n <= max else { return -1 }\\n\\n    let result = number + n - 1\\n    let second = String(String(result).reversed())\\n    let first = String(result)\\n    let mainResult = Int(first + (lenght.isMultiple(of: 2) ? second : String(second.dropFirst())))!\\n    return mainResult\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        queries.map { getPlindrome($0, intLength)}\\n    }\\n\\n    func getPlindrome(_ n: Int, _ lenght: Int) -> Int {\\n    let halfCountNumbers = lenght.isMultiple(of: 2) ? lenght / 2 : lenght / 2 + 1\\n\\n    var number = 1\\n\\n    (0..<halfCountNumbers - 1).forEach { _ in\\n        number *= 10\\n    }\\n\\n    let max = number * 10 - number\\n    guard n <= max else { return -1 }\\n\\n    let result = number + n - 1\\n    let second = String(String(result).reversed())\\n    let first = String(result)\\n    let mainResult = Int(first + (lenght.isMultiple(of: 2) ? second : String(second.dropFirst())))!\\n    return mainResult\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073689,
                "title": "find-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n-->\\nThis is second task of all tasks on leetCode/ And this is difficult for me\\n\\nRecursive function - is very long time execute\\nAnd I did have an error \"Time limit exceed\" \\nThis dicision is not my. A save it for me\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} queries\\n * @param {number} intLength\\n * @return {number[]}\\n */\\nvar kthPalindrome = function(queries, intLength) {\\n   \\n    let lenAboutHalf = Math.pow(10, Math.ceil(intLength / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";// first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                              // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (intLength % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;             // full palindrome\\n        if (s.length > intLength) {\\n            ans.push(-1);             // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n   \\n   /*\\n    var answer = [];\\n    if(intLength>15 || queries.length > Math.pow(10,4) * 5){\\n        return;\\n    }\\n \\n    function makePalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(0);\\n        }\\n        res[0] = 1;\\n        if(len > 1){\\n            res[len-1] = 1;\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n    function makeMaxPalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(9);\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n            \\n    function incPalindrom(pal, intLength){\\n        var mas = (pal+\\'\\').split(\\'\\');\\n        var temp = parseInt(intLength/2);\\n\\n        // \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0447\\u0435\\u0442\\n        if(intLength%2) {\\n            function incMiddle(m) {\\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp]++;\\n                        return mas;\\n                    } else if(intLength !== 1) {\\n                        mas[temp] = 0;\\n                        return incMiddle(m+1);\\n                    } else return -1;\\n                } else if (m<=temp) {\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m]++;\\n                        \\n                        return mas;\\n                    } else {\\n                        mas[temp+m] = 0;\\n                        mas[temp-m] = 0;\\n                        \\n                        return incMiddle(m+1);\\n                    }\\n                } else return -1;\\n            }\\n            \\n            incMiddle(0);\\n        } else { // \\u0435\\u0441\\u043B\\u0438 \\u0447\\u0435\\u0442\\n        \\n            function incMiddle2(m) {\\n                \\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp-1]++;\\n                        mas[temp]++;\\n\\n                        return mas;\\n                    } else {\\n                        mas[temp] = 0;\\n                        mas[temp-1] = 0;\\n                       return  incMiddle2(m+1);\\n                        \\n                    }\\n                } else if (m<=temp){\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m-1]++;\\n                        return mas;\\n                    } else {\\n                        mas[temp+m]=0;\\n                        mas[temp-m-1]=0;\\n                        return incMiddle2(m+1);\\n                        \\n                    }\\n                } else return -1;\\n            }\\n            incMiddle2(0);\\n        }\\n        \\n        return Number(mas.join(\\'\\'));     \\n    }\\n  \\n    var start = makePalindromByL(intLength);\\n\\n    \\n    \\n    var allPalindroms = [start];\\n     var maxPal = makeMaxPalindromByL(intLength);\\n    \\n     var indexP = 0;\\n    while(start < maxPal  )  {\\n        allPalindroms[indexP] = start;\\n        start = incPalindrom(start, intLength);\\n   \\n        indexP++;\\n    }\\n    allPalindroms[indexP] = maxPal;\\n    var countPal = allPalindroms.length;\\n   \\n\\n\\n    for(var l=0; l<queries.length; l++){\\n        if(queries[l] > countPal) {\\n            answer[l] = -1;\\n        } else {\\n            answer[l] = allPalindroms[queries[l] - 1];\\n        }\\n    }\\n\\n  return answer;*/\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} queries\\n * @param {number} intLength\\n * @return {number[]}\\n */\\nvar kthPalindrome = function(queries, intLength) {\\n   \\n    let lenAboutHalf = Math.pow(10, Math.ceil(intLength / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";// first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                              // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (intLength % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;             // full palindrome\\n        if (s.length > intLength) {\\n            ans.push(-1);             // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n   \\n   /*\\n    var answer = [];\\n    if(intLength>15 || queries.length > Math.pow(10,4) * 5){\\n        return;\\n    }\\n \\n    function makePalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(0);\\n        }\\n        res[0] = 1;\\n        if(len > 1){\\n            res[len-1] = 1;\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n    function makeMaxPalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(9);\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n            \\n    function incPalindrom(pal, intLength){\\n        var mas = (pal+\\'\\').split(\\'\\');\\n        var temp = parseInt(intLength/2);\\n\\n        // \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0447\\u0435\\u0442\\n        if(intLength%2) {\\n            function incMiddle(m) {\\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp]++;\\n                        return mas;\\n                    } else if(intLength !== 1) {\\n                        mas[temp] = 0;\\n                        return incMiddle(m+1);\\n                    } else return -1;\\n                } else if (m<=temp) {\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m]++;\\n                        \\n                        return mas;\\n                    } else {\\n                        mas[temp+m] = 0;\\n                        mas[temp-m] = 0;\\n                        \\n                        return incMiddle(m+1);\\n                    }\\n                } else return -1;\\n            }\\n            \\n            incMiddle(0);\\n        } else { // \\u0435\\u0441\\u043B\\u0438 \\u0447\\u0435\\u0442\\n        \\n            function incMiddle2(m) {\\n                \\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp-1]++;\\n                        mas[temp]++;\\n\\n                        return mas;\\n                    } else {\\n                        mas[temp] = 0;\\n                        mas[temp-1] = 0;\\n                       return  incMiddle2(m+1);\\n                        \\n                    }\\n                } else if (m<=temp){\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m-1]++;\\n                        return mas;\\n                    } else {\\n                        mas[temp+m]=0;\\n                        mas[temp-m-1]=0;\\n                        return incMiddle2(m+1);\\n                        \\n                    }\\n                } else return -1;\\n            }\\n            incMiddle2(0);\\n        }\\n        \\n        return Number(mas.join(\\'\\'));     \\n    }\\n  \\n    var start = makePalindromByL(intLength);\\n\\n    \\n    \\n    var allPalindroms = [start];\\n     var maxPal = makeMaxPalindromByL(intLength);\\n    \\n     var indexP = 0;\\n    while(start < maxPal  )  {\\n        allPalindroms[indexP] = start;\\n        start = incPalindrom(start, intLength);\\n   \\n        indexP++;\\n    }\\n    allPalindroms[indexP] = maxPal;\\n    var countPal = allPalindroms.length;\\n   \\n\\n\\n    for(var l=0; l<queries.length; l++){\\n        if(queries[l] > countPal) {\\n            answer[l] = -1;\\n        } else {\\n            answer[l] = allPalindroms[queries[l] - 1];\\n        }\\n    }\\n\\n  return answer;*/\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027290,
                "title": "python-o-n-solution-explained-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe process palindromes in O(1) time for every query so the overall complexity is $$O(n)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use an array of size n to store answers so the space complexity is $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\n        def numofpalins(n) :\\n            return (9 * pow(10, (n - 1) // 2))\\n\\n        ans = []\\n\\n        maxend = 0\\n        totalpalins = numofpalins(intLength)\\n        for i in queries:\\n                if i<=totalpalins:\\n                    maxend = max(maxend, i)\\n\\n        if intLength % 2 == 0:\\n            curlen = intLength // 2\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n\\n        if intLength % 2 != 0:\\n            curlen = math.ceil(intLength/2)\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1][1:] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\n        def numofpalins(n) :\\n            return (9 * pow(10, (n - 1) // 2))\\n\\n        ans = []\\n\\n        maxend = 0\\n        totalpalins = numofpalins(intLength)\\n        for i in queries:\\n                if i<=totalpalins:\\n                    maxend = max(maxend, i)\\n\\n        if intLength % 2 == 0:\\n            curlen = intLength // 2\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n\\n        if intLength % 2 != 0:\\n            curlen = math.ceil(intLength/2)\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1][1:] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018933,
                "title": "c-using-pure-math-and-complete-detailed-explanation",
                "content": "# Intuition\\nUsing the knowledge of permutations we can find out how many possible palindromes can be made of a given length. Suppose if length is 5 so for first number we have 9 choices and till ceil(intLength / 2) digits we have 10 choices. As the number is palindrome so rest digits have one choice so we have 9 * 10 * 10 * 1 * 1 palindromes of intLength 5.\\nThen as the number is a palindrome we can find only the first part and then combining it with the reverse of it would be easy. So question is how to get the first part.\\nsuppose writing down 5 digit palindromes.\\n\\npalindrome      index\\n  10001           1\\n  10101           2\\n  10201           3\\n  10301           4\\nwe can see a pattern is being generated that for every palindrome the first part is 100 + index - 1. The 100 comes from the formula pow(10, ceil(intLength / 2) - 1) as ceil(intLength / 2) is the number of digits for first half we have to find. Finally we get our first half we can reverse it and add it to first half * 10^(floor(intLength / 2)).\\n# Approach\\nIterate over the queries array and apply the above math for each queries[i]. If queries[i] is > possible palindromes of intLength then append -1 in res else the whole procedure for finding palindrome.\\n\\n# Complexity\\n- Time complexity:\\nO(n) as the mathematical calculations require O(1) and we do them for whole queries so O(1) * O(n) gives O(n).\\n\\n- Space complexity:\\nO(n) extra space for result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long revNum(long long n) {\\n        long long res = 0;\\n        while (n > 0) {\\n            res *= 10;\\n            res += (n % 10);\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long possiblePalindromes = 9 * pow(10, ceil(intLength / 2.0) - 1);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (queries[i] > possiblePalindromes) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            long long palindrome;\\n            if (intLength % 2) {\\n                long long firstHalf = pow(10, floor(intLength / 2.0)) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf / 10);\\n            }\\n            else {\\n                long long firstHalf = pow(10, floor(intLength / 2.0) - 1) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf);\\n            }\\n            res.push_back(palindrome);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long revNum(long long n) {\\n        long long res = 0;\\n        while (n > 0) {\\n            res *= 10;\\n            res += (n % 10);\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long possiblePalindromes = 9 * pow(10, ceil(intLength / 2.0) - 1);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (queries[i] > possiblePalindromes) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            long long palindrome;\\n            if (intLength % 2) {\\n                long long firstHalf = pow(10, floor(intLength / 2.0)) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf / 10);\\n            }\\n            else {\\n                long long firstHalf = pow(10, floor(intLength / 2.0) - 1) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf);\\n            }\\n            res.push_back(palindrome);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973251,
                "title": "typescript-solution",
                "content": "```\\nlet res = [];\\n    let start = Math.pow(10, Math.floor((intLength + 1) / 2) - 1);\\n    let end = Math.pow(10, Math.floor((intLength + 1 ) / 2))\\n    for (let q of queries) {\\n        if (start + q > end) {\\n            res.push(-1);\\n        } else {\\n            const firstHalf = (start + q - 1).toString();\\n            const secondHalf = firstHalf.slice(0, Math.floor(intLength / 2)).split(\\'\\').reverse().join(\\'\\');\\n            res.push(Number.parseInt(firstHalf + secondHalf))\\n        }\\n    }\\n    return res;\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nlet res = [];\\n    let start = Math.pow(10, Math.floor((intLength + 1) / 2) - 1);\\n    let end = Math.pow(10, Math.floor((intLength + 1 ) / 2))\\n    for (let q of queries) {\\n        if (start + q > end) {\\n            res.push(-1);\\n        } else {\\n            const firstHalf = (start + q - 1).toString();\\n            const secondHalf = firstHalf.slice(0, Math.floor(intLength / 2)).split(\\'\\').reverse().join(\\'\\');\\n            res.push(Number.parseInt(firstHalf + secondHalf))\\n        }\\n    }\\n    return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971197,
                "title": "java-half-palindrome-formula",
                "content": "```\\nFormula :-\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        int q = (int) Math.ceil((double) intLength / 2);\\n        int offset = (int) Math.pow(10,q-1);\\n        for(int i = 0 ; i < n ; i++){\\n            String half = Integer.toString((queries[i] - 1) + offset);\\n            String halfCopy = half.substring(0,intLength % 2 == 0 ? q : q - 1);\\n            StringBuilder otherHalf = new StringBuilder();\\n            otherHalf.append(halfCopy);\\n            otherHalf.reverse();\\n            String curr = half.concat(otherHalf.toString());\\n            if (curr.length() > intLength){\\n                ans[i] = -1;\\n            }\\n            else{\\n                ans[i] = Long.parseLong(curr);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFormula :-\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        int q = (int) Math.ceil((double) intLength / 2);\\n        int offset = (int) Math.pow(10,q-1);\\n        for(int i = 0 ; i < n ; i++){\\n            String half = Integer.toString((queries[i] - 1) + offset);\\n            String halfCopy = half.substring(0,intLength % 2 == 0 ? q : q - 1);\\n            StringBuilder otherHalf = new StringBuilder();\\n            otherHalf.append(halfCopy);\\n            otherHalf.reverse();\\n            String curr = half.concat(otherHalf.toString());\\n            if (curr.length() > intLength){\\n                ans[i] = -1;\\n            }\\n            else{\\n                ans[i] = Long.parseLong(curr);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936433,
                "title": "java-solution-firsthalf",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res = new long[queries.length];\\n        long min = (long) Math.pow(10, (intLength /2 + (intLength % 2) - 1));\\n        long max = (long) Math.pow(10, (intLength /2 + (intLength % 2))) -1;\\n        long multi = (long) Math.pow(10, intLength / 2);\\n        for(int i = 0; i< queries.length; i++){\\n            long firstHalf = min + queries[i] - 1;\\n            if(firstHalf > max) {\\n                res[i] = -1;\\n                continue;\\n            }\\n            long secondHalf = intLength %2 != 0? reverse(firstHalf / 10): reverse(firstHalf);\\n            res[i] = firstHalf * multi + secondHalf;\\n        }\\n        return res;\\n    }\\n\\n    public long reverse(long num){\\n        long res = 0;\\n        while(num != 0){\\n            long d = num %10;\\n            res = res*10 + d;\\n            num /= 10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res = new long[queries.length];\\n        long min = (long) Math.pow(10, (intLength /2 + (intLength % 2) - 1));\\n        long max = (long) Math.pow(10, (intLength /2 + (intLength % 2))) -1;\\n        long multi = (long) Math.pow(10, intLength / 2);\\n        for(int i = 0; i< queries.length; i++){\\n            long firstHalf = min + queries[i] - 1;\\n            if(firstHalf > max) {\\n                res[i] = -1;\\n                continue;\\n            }\\n            long secondHalf = intLength %2 != 0? reverse(firstHalf / 10): reverse(firstHalf);\\n            res[i] = firstHalf * multi + secondHalf;\\n        }\\n        return res;\\n    }\\n\\n    public long reverse(long num){\\n        long res = 0;\\n        while(num != 0){\\n            long d = num %10;\\n            res = res*10 + d;\\n            num /= 10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867707,
                "title": "kotlin-fast-solution",
                "content": "Solution with using just formulas, **without** \"*all range iteration*\" and \"*toString()*\"\\n\\n```\\nclass Solution {\\n    fun kthPalindrome(queries: IntArray, intLength: Int): LongArray {\\n        var res = LongArray(queries.size)\\n        \\n        val r = if(intLength % 2 == 0) 0 else 1\\n        val n = intLength / 2 + r\\n        \\n        val lo = Math.pow( 10.0, n.toDouble()-1 ).toLong()\\n        val hi = Math.pow( 10.0, n.toDouble()   ).toLong() - 1\\n        \\n        val dec = Math.pow( 10.0, n.toDouble()   ).toLong()\\n\\n        for((idx, v) in queries.withIndex()) {\\n            var d : Long = lo + v - 1\\n            if( d < lo || d > hi ) d = -1\\n            val s : Long =\\n                if( d == -1L ) {\\n                    d\\n                } else {\\n                    if( r == 1 ) {\\n                        if( d < 10 ) {\\n                            d\\n                        } else {\\n                            d / 10 * dec + revert(d)\\n                        }\\n                    } else {\\n                        d * dec + revert(d)\\n                    }\\n                }\\n            res[idx] = s\\n        }        \\n        \\n        return res\\n    }\\n        \\n    fun revert(i: Long): Long {\\n        var s = 0L\\n        var d = i\\n        var r = 0L\\n        while(true){\\n            r = d % 10\\n            d = d / 10            \\n            s = s * 10 + r\\n            if( d == 0L ) break\\n        }        \\n        return s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun kthPalindrome(queries: IntArray, intLength: Int): LongArray {\\n        var res = LongArray(queries.size)\\n        \\n        val r = if(intLength % 2 == 0) 0 else 1\\n        val n = intLength / 2 + r\\n        \\n        val lo = Math.pow( 10.0, n.toDouble()-1 ).toLong()\\n        val hi = Math.pow( 10.0, n.toDouble()   ).toLong() - 1\\n        \\n        val dec = Math.pow( 10.0, n.toDouble()   ).toLong()\\n\\n        for((idx, v) in queries.withIndex()) {\\n            var d : Long = lo + v - 1\\n            if( d < lo || d > hi ) d = -1\\n            val s : Long =\\n                if( d == -1L ) {\\n                    d\\n                } else {\\n                    if( r == 1 ) {\\n                        if( d < 10 ) {\\n                            d\\n                        } else {\\n                            d / 10 * dec + revert(d)\\n                        }\\n                    } else {\\n                        d * dec + revert(d)\\n                    }\\n                }\\n            res[idx] = s\\n        }        \\n        \\n        return res\\n    }\\n        \\n    fun revert(i: Long): Long {\\n        var s = 0L\\n        var d = i\\n        var r = 0L\\n        while(true){\\n            r = d % 10\\n            d = d / 10            \\n            s = s * 10 + r\\n            if( d == 0L ) break\\n        }        \\n        return s\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815196,
                "title": "python3-short-code-using-math-better-than-90",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\t\\t# range = [10 ** (intLength - 1), 10 ** intLength - 1] --> inclusive\\n\\t\\t\\n        rootLength = (intLength + 1) // 2\\n        maxPossible = 10 ** (rootLength - 1) * 9\\n        root = str(10 ** (intLength - 1))[:rootLength]\\n        res = []\\n\\t\\t\\n        for q in queries:\\n\\t\\t\\n            if q > maxPossible:\\n                res.append(-1)\\n\\t\\t\\t\\t\\n            else:\\n                pre = str(int(root) + (q - 1))\\n                if intLength % 2 == 0:\\n                    res.append(int(pre + pre[::-1]))\\n                else:\\n                    res.append(int(pre + pre[:-1][::-1]))\\n\\t\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\t\\t# range = [10 ** (intLength - 1), 10 ** intLength - 1] --> inclusive\\n\\t\\t\\n        rootLength = (intLength + 1) // 2\\n        maxPossible = 10 ** (rootLength - 1) * 9\\n        root = str(10 ** (intLength - 1))[:rootLength]\\n        res = []\\n\\t\\t\\n        for q in queries:\\n\\t\\t\\n            if q > maxPossible:\\n                res.append(-1)\\n\\t\\t\\t\\t\\n            else:\\n                pre = str(int(root) + (q - 1))\\n                if intLength % 2 == 0:\\n                    res.append(int(pre + pre[::-1]))\\n                else:\\n                    res.append(int(pre + pre[:-1][::-1]))\\n\\t\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755086,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> res;\\n        long long start;\\n        if(l%2)\\n            start = pow(10,l/2);\\n        else\\n            start = pow(10,l/2-1);\\n        \\n        long long end = pow(10,(l+1)/2);\\n        \\n        for(int q:queries){\\n            if(start+q>end){\\n                res.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long firstHalf = start+q-1;\\n            string lhs = to_string(firstHalf);\\n            string rhs = lhs;\\n            if(l%2)\\n                rhs = rhs.substr(0,lhs.size()-1);\\n            \\n            reverse(rhs.begin(),rhs.end());\\n            string fin = lhs+rhs;\\n            res.push_back(stoll(fin));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> res;\\n        long long start;\\n        if(l%2)\\n            start = pow(10,l/2);\\n        else\\n            start = pow(10,l/2-1);\\n        \\n        long long end = pow(10,(l+1)/2);\\n        \\n        for(int q:queries){\\n            if(start+q>end){\\n                res.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long firstHalf = start+q-1;\\n            string lhs = to_string(firstHalf);\\n            string rhs = lhs;\\n            if(l%2)\\n                rhs = rhs.substr(0,lhs.size()-1);\\n            \\n            reverse(rhs.begin(),rhs.end());\\n            string fin = lhs+rhs;\\n            res.push_back(stoll(fin));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740248,
                "title": "ruby-solution-easy-variable-names",
                "content": "```\\ndef kth_palindrome(queries, int_length)\\n  half_length = (int_length + 1) / 2\\n  first_palindrome = 10.pow(half_length - 1)\\n  max_palindromes = first_palindrome * 9\\n  queries.map do |query|\\n    if query > max_palindromes\\n      -1\\n    else\\n      left_part = (first_palindrome + query - 1).to_s\\n      right_part = left_part.reverse\\n      right_part[0] = \\'\\' if int_length.odd?\\n      (left_part + right_part).to_i\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef kth_palindrome(queries, int_length)\\n  half_length = (int_length + 1) / 2\\n  first_palindrome = 10.pow(half_length - 1)\\n  max_palindromes = first_palindrome * 9\\n  queries.map do |query|\\n    if query > max_palindromes\\n      -1\\n    else\\n      left_part = (first_palindrome + query - 1).to_s\\n      right_part = left_part.reverse\\n      right_part[0] = \\'\\' if int_length.odd?\\n      (left_part + right_part).to_i\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2731212,
                "title": "simple-easy-solution",
                "content": "**Please Upvote If You Fiind Useful**\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        rawnum = 10 ** int((intLength-1)/2)\\n        ans = []\\n        for x in queries :\\n            \\n            firsthalf = rawnum + x - 1\\n            stri = str(firsthalf)   \\n            stri += stri[::-1] if intLength%2 == 0 else stri[:len(stri)-1][::-1]   \\n            if len(stri) == intLength:\\n                ans.append(stri)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        rawnum = 10 ** int((intLength-1)/2)\\n        ans = []\\n        for x in queries :\\n            \\n            firsthalf = rawnum + x - 1\\n            stri = str(firsthalf)   \\n            stri += stri[::-1] if intLength%2 == 0 else stri[:len(stri)-1][::-1]   \\n            if len(stri) == intLength:\\n                ans.append(stri)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674221,
                "title": "c-to-string",
                "content": "```\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        bool isOdd = intLength % 2;\\n        int len = intLength / 2 + isOdd;\\n        int start = pow(10, len-1);\\n        int maxN = pow(10, len) - start;\\n        \\n        \\n        vector<long long> res;\\n        for(auto x:queries){\\n            if(x > maxN) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int y = start + x-1;\\n            auto s = to_string(y);\\n            auto t = s;\\n            reverse(t.begin(), t.end());\\n            if(isOdd) s.pop_back();\\n            auto z = stoll(s+t);\\n            res.push_back(z);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        bool isOdd = intLength % 2;\\n        int len = intLength / 2 + isOdd;\\n        int start = pow(10, len-1);\\n        int maxN = pow(10, len) - start;\\n        \\n        \\n        vector<long long> res;\\n        for(auto x:queries){\\n            if(x > maxN) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int y = start + x-1;\\n            auto s = to_string(y);\\n            auto t = s;\\n            reverse(t.begin(), t.end());\\n            if(isOdd) s.pop_back();\\n            auto z = stoll(s+t);\\n            res.push_back(z);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2662790,
                "title": "fast-python3-solution",
                "content": "```\\nclass Solution:\\n    def create_palindrome(self, base, query, intLength):\\n        start = f\"{base + query - 1}\"\\n        addIndex = intLength - len(start)\\n        palindrome = f\"{start}{start[:addIndex][::-1]}\"\\n        return int(palindrome)\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        palindromes = []\\n        base = 10**((intLength-1)//2)\\n        for query in queries:\\n            no_palins = base*10 - base\\n            if no_palins < query:\\n                palindromes.append(-1)\\n            else:\\n                palindrome = self.create_palindrome(base, query, intLength)\\n                palindromes.append(palindrome)\\n\\n        return palindromes\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def create_palindrome(self, base, query, intLength):\\n        start = f\"{base + query - 1}\"\\n        addIndex = intLength - len(start)\\n        palindrome = f\"{start}{start[:addIndex][::-1]}\"\\n        return int(palindrome)\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        palindromes = []\\n        base = 10**((intLength-1)//2)\\n        for query in queries:\\n            no_palins = base*10 - base\\n            if no_palins < query:\\n                palindromes.append(-1)\\n            else:\\n                palindrome = self.create_palindrome(base, query, intLength)\\n                palindromes.append(palindrome)\\n\\n        return palindromes\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636848,
                "title": "simple-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t# define ll longlong\\n\\n\\t\\tlong long find(int i, int l) {\\n\\t\\t\\tint base;\\n\\n\\t\\t\\tif(l%2==0)\\n\\t\\t\\t\\tbase = pow(10, l/2-1);\\n\\t\\t\\telse \\n\\t\\t\\t\\tbase = pow(10, l/2);\\n\\n\\t\\t\\tstring t = to_string(base+i-1);\\n\\t\\t\\tstring b = to_string(base);\\n\\t\\t\\tint n= t.length();\\n\\n\\t\\t\\tif(n>b.length()) \\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tif(l%2==1)\\n\\t\\t\\t\\tb=t.substr(0, n-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tb=t;\\n\\n\\t\\t\\treverse(b.begin(), b.end());\\n\\t\\t\\tt+=b;\\n\\n\\t\\t\\treturn stoll(t);\\n\\n\\n\\t\\t}\\n\\t\\tvector<long long> kthPalindrome(vector<int>& q, int il) {\\n\\t\\t\\tvector<long long> ans;\\n\\n\\t\\t\\tfor(int i =0 ; i<q.size(); i++)\\n\\t\\t\\t\\tans.push_back(find(q[i], il));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t# define ll longlong\\n\\n\\t\\tlong long find(int i, int l) {\\n\\t\\t\\tint base;\\n\\n\\t\\t\\tif(l%2==0)\\n\\t\\t\\t\\tbase = pow(10, l/2-1);\\n\\t\\t\\telse \\n\\t\\t\\t\\tbase = pow(10, l/2);\\n\\n\\t\\t\\tstring t = to_string(base+i-1);\\n\\t\\t\\tstring b = to_string(base);\\n\\t\\t\\tint n= t.length();\\n\\n\\t\\t\\tif(n>b.length()) \\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tif(l%2==1)\\n\\t\\t\\t\\tb=t.substr(0, n-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tb=t;\\n\\n\\t\\t\\treverse(b.begin(), b.end());\\n\\t\\t\\tt+=b;\\n\\n\\t\\t\\treturn stoll(t);\\n\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2553818,
                "title": "c-easy-maths-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long >ans;\\n        int val=(intLength-1)/2;\\n        long long  value=9*pow(10,val);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>value){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                if(intLength%2){\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                else{\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength-1)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                \\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long >ans;\\n        int val=(intLength-1)/2;\\n        long long  value=9*pow(10,val);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>value){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                if(intLength%2){\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                else{\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength-1)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                \\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2553080,
                "title": "palindrome-with-fixed-length-java-easy-solution",
                "content": "```\\nRuntime: 150ms\\n```\\n```\\nMemory Usage: 100MB\\n```\\n```\\nclass SolutionForPalindromeWithFixedLength{\\npublic static long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\tlong[] ans = new long[queries.length];\\n\\t\\tint hl = (intLength + 1) / 2;\\n\\t\\tString s1 = \"\";\\n\\t\\tString s2 = \"9\";\\n\\t\\tfor (int i = 0; i < (hl - 1); i++) {\\n\\t\\t\\ts1 += \"0\";\\n\\t\\t\\ts2 += \"9\";\\n\\t\\t}\\n\\t\\ts1 = \"1\" + s1;\\n\\t\\tint sp = Integer.parseInt(s1);\\n\\t\\tint lp = Integer.parseInt(s2);\\n\\t\\tif (intLength == 1) {\\n\\t\\t\\tsp = 1;\\n\\t\\t\\tlp = 9;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\tif (queries[i] - 1 + sp > lp) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = queries[i] - 1 + sp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(intLength == 0) {\\n\\t\\t\\tArrays.fill(ans,-1);\\n\\t\\t}\\n\\t\\tif (intLength > 1) {\\n\\t\\t\\tif (intLength % 2 != 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i] / 10;\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i];\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nRuntime: 150ms\\n```\n```\\nMemory Usage: 100MB\\n```\n```\\nclass SolutionForPalindromeWithFixedLength{\\npublic static long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\tlong[] ans = new long[queries.length];\\n\\t\\tint hl = (intLength + 1) / 2;\\n\\t\\tString s1 = \"\";\\n\\t\\tString s2 = \"9\";\\n\\t\\tfor (int i = 0; i < (hl - 1); i++) {\\n\\t\\t\\ts1 += \"0\";\\n\\t\\t\\ts2 += \"9\";\\n\\t\\t}\\n\\t\\ts1 = \"1\" + s1;\\n\\t\\tint sp = Integer.parseInt(s1);\\n\\t\\tint lp = Integer.parseInt(s2);\\n\\t\\tif (intLength == 1) {\\n\\t\\t\\tsp = 1;\\n\\t\\t\\tlp = 9;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\tif (queries[i] - 1 + sp > lp) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = queries[i] - 1 + sp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(intLength == 0) {\\n\\t\\t\\tArrays.fill(ans,-1);\\n\\t\\t}\\n\\t\\tif (intLength > 1) {\\n\\t\\t\\tif (intLength % 2 != 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i] / 10;\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i];\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416530,
                "title": "simple-solution-in-python3",
                "content": "Just generate half of the number and mirror it.\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    \\n    def mirror(self, num, intLength):\\n        if intLength%2==0:\\n            num_mirror = int(str(num)[::-1])\\n            out = num_mirror + num * 10**(intLength//2)\\n        if intLength%2==1:\\n            num_mirror = int(str(num//10)[::-1])\\n            out = num * 10**(intLength//2) + num_mirror\\n        return out\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        if intLength%2==0:\\n            start = 10**(intLength//2-1)\\n            end = 10**(intLength//2)\\n        if intLength%2==1:\\n            start = 10**(intLength//2)\\n            end = 10**(intLength//2+1)\\n        output = []\\n        for q in queries:\\n            if q > end-start:\\n                output.append(-1)\\n            else:\\n                output.append(self.mirror(start+q-1, intLength))\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    \\n    def mirror(self, num, intLength):\\n        if intLength%2==0:\\n            num_mirror = int(str(num)[::-1])\\n            out = num_mirror + num * 10**(intLength//2)\\n        if intLength%2==1:\\n            num_mirror = int(str(num//10)[::-1])\\n            out = num * 10**(intLength//2) + num_mirror\\n        return out\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        if intLength%2==0:\\n            start = 10**(intLength//2-1)\\n            end = 10**(intLength//2)\\n        if intLength%2==1:\\n            start = 10**(intLength//2)\\n            end = 10**(intLength//2+1)\\n        output = []\\n        for q in queries:\\n            if q > end-start:\\n                output.append(-1)\\n            else:\\n                output.append(self.mirror(start+q-1, intLength))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376635,
                "title": "simple-java-solution-using-math-logic",
                "content": "queries = [1,2,3,4,5,90], intLength = 3\\noutput should be [101,111,121,131,141,999]\\n\\nif we add 9 to each element and append its mirror value to make its lenght equal to intLength we will get palindrome eg.\\n9+1=>10=>10+\"1\"=>101\\n9+2=>11=>11+\"1\"=>111\\n.\\n.\\n90+9=>99=>99+\"9\"=999\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int half = (intLength+1)/2;\\n        Double pow = Math.pow(10, half-1);\\n        int add = pow.intValue() - 1;\\n        long[] result = new long[queries.length];\\n        for(int i = 0; i< queries.length; i++){\\n            if(queries[i]>pow*10){\\n                result[i] = -1;\\n                continue;\\n            }\\n            String tempNum =Integer.toString(queries[i]+add);\\n            long tempResult =0;\\n            String tempString = null;\\n            if(intLength%2==0){\\n                tempString = tempNum + new StringBuilder(tempNum).reverse().toString();\\n                \\n            }\\n            else{\\n                String subString = tempNum.substring(0,intLength/2);\\n                tempString = tempNum + new StringBuilder(subString).reverse().toString();\\n                \\n            }\\n            if(tempString.length()<=intLength){\\n                tempResult = Long.parseLong(tempString);\\n            }\\n            else {\\n                tempResult = -1;\\n            }\\n            result[i] = tempResult;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int half = (intLength+1)/2;\\n        Double pow = Math.pow(10, half-1);\\n        int add = pow.intValue() - 1;\\n        long[] result = new long[queries.length];\\n        for(int i = 0; i< queries.length; i++){\\n            if(queries[i]>pow*10){\\n                result[i] = -1;\\n                continue;\\n            }\\n            String tempNum =Integer.toString(queries[i]+add);\\n            long tempResult =0;\\n            String tempString = null;\\n            if(intLength%2==0){\\n                tempString = tempNum + new StringBuilder(tempNum).reverse().toString();\\n                \\n            }\\n            else{\\n                String subString = tempNum.substring(0,intLength/2);\\n                tempString = tempNum + new StringBuilder(subString).reverse().toString();\\n                \\n            }\\n            if(tempString.length()<=intLength){\\n                tempResult = Long.parseLong(tempString);\\n            }\\n            else {\\n                tempResult = -1;\\n            }\\n            result[i] = tempResult;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369422,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = pow(10, (intLength+1)//2-1)\\n        ans = []\\n        for q in queries:\\n            response = str(base+q-1)+str(base+q-1)[::-1][intLength%2:]\\n            ans.append(int(response) if len(response) <= intLength else -1)\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = pow(10, (intLength+1)//2-1)\\n        ans = []\\n        for q in queries:\\n            response = str(base+q-1)+str(base+q-1)[::-1][intLength%2:]\\n            ans.append(int(response) if len(response) <= intLength else -1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2329444,
                "title": "python-string-manipulation",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\n        res = []\\n        \\n        halflength = math.ceil(intLength/2)\\n        \\n        left_range = 10**(halflength-1)\\n        right_range = 10**halflength - 1\\n        num_in_range = right_range-left_range + 1\\n        is_odd = intLength % 2 != 0\\n\\n        for q in queries:\\n            if q > num_in_range:\\n                res.append(-1)\\n                continue\\n            \\n            #smallest value in range + q-1\\n            left_half = str(left_range + q - 1)\\n            right_half = left_half[::-1]\\n            \\n            #if value is odd, shave off middle value\\n            if is_odd:\\n                right_half = right_half[1:]\\n            res.append(int(left_half+right_half))\\n        \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\n        res = []\\n        \\n        halflength = math.ceil(intLength/2)\\n        \\n        left_range = 10**(halflength-1)\\n        right_range = 10**halflength - 1\\n        num_in_range = right_range-left_range + 1\\n        is_odd = intLength % 2 != 0\\n\\n        for q in queries:\\n            if q > num_in_range:\\n                res.append(-1)\\n                continue\\n            \\n            #smallest value in range + q-1\\n            left_half = str(left_range + q - 1)\\n            right_half = left_half[::-1]\\n            \\n            #if value is odd, shave off middle value\\n            if is_odd:\\n                right_half = right_half[1:]\\n            res.append(int(left_half+right_half))\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259703,
                "title": "c-maths",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int m = (intLength + 1) / 2;\\n\\t\\tlong long f = pow(10, m - 1);\\n\\t\\tint n = queries.size();\\n\\t\\tvector<long long> ans(n);\\n\\t\\tlong long mx = 9 * f;\\n\\t\\tstring start = \"\";\\n\\t\\tfor (int i = 0; i < intLength; i++) start += \\'0\\';\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (queries[i] > mx) ans[i] = -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstring s = start;\\n\\t\\t\\t\\tqueries[i]--;\\n\\t\\t\\t\\tlong long d = f;\\n\\t\\t\\t\\ts[0] = s[intLength - 1] = \\'0\\' + (1 + queries[i] / d);\\n\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\tint st = 1, en = intLength - 2;\\n\\t\\t\\t\\twhile (st <= en) {\\n\\t\\t\\t\\t\\ts[st] = s[en] = \\'0\\' + (queries[i] / d);\\n\\t\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\t\\tst++, en--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = stoll(s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int m = (intLength + 1) / 2;\\n\\t\\tlong long f = pow(10, m - 1);\\n\\t\\tint n = queries.size();\\n\\t\\tvector<long long> ans(n);\\n\\t\\tlong long mx = 9 * f;\\n\\t\\tstring start = \"\";\\n\\t\\tfor (int i = 0; i < intLength; i++) start += \\'0\\';\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (queries[i] > mx) ans[i] = -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstring s = start;\\n\\t\\t\\t\\tqueries[i]--;\\n\\t\\t\\t\\tlong long d = f;\\n\\t\\t\\t\\ts[0] = s[intLength - 1] = \\'0\\' + (1 + queries[i] / d);\\n\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\tint st = 1, en = intLength - 2;\\n\\t\\t\\t\\twhile (st <= en) {\\n\\t\\t\\t\\t\\ts[st] = s[en] = \\'0\\' + (queries[i] / d);\\n\\t\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\t\\tst++, en--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = stoll(s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255323,
                "title": "python-simple-and-concise-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n = (intLength+1)//2 - 1\\n        \\n        for q in queries:\\n            num = str(10**n + q - 1)\\n            result = num + (num[:n+1-(intLength%2)])[::-1]\\n            if len(result) > intLength:\\n                answer.append(-1)\\n            else:\\n                answer.append(result)\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n = (intLength+1)//2 - 1\\n        \\n        for q in queries:\\n            num = str(10**n + q - 1)\\n            result = num + (num[:n+1-(intLength%2)])[::-1]\\n            if len(result) > intLength:\\n                answer.append(-1)\\n            else:\\n                answer.append(result)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249375,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int il) {\\n        int l=(il+1)/2;\\n        int ll=pow(10,l-1);\\n        int rl=pow(10,l)-1;\\n        int range=rl-ll+1;\\n        vector<long long>v;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=range){\\n               string a=to_string(ll+q[i]-1);\\n               string b=a;\\n                if(il%2==1)b.pop_back();\\n                reverse(b.begin(),b.end());\\n                string c=a+b;\\n                v.push_back(stoll(c));\\n            }\\n            else v.push_back(-1);\\n        }\\n        return v;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int il) {\\n        int l=(il+1)/2;\\n        int ll=pow(10,l-1);\\n        int rl=pow(10,l)-1;\\n        int range=rl-ll+1;\\n        vector<long long>v;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=range){\\n               string a=to_string(ll+q[i]-1);\\n               string b=a;\\n                if(il%2==1)b.pop_back();\\n                reverse(b.begin(),b.end());\\n                string c=a+b;\\n                v.push_back(stoll(c));\\n            }\\n            else v.push_back(-1);\\n        }\\n        return v;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235628,
                "title": "showing-runtime-error-please-help",
                "content": "Please review this code :\\nThis code passes sample test cases as well as many test cases but on submitting it shows runtime error.\\nPlease help me in finding mistake.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n      //Finding range of pelindrome number to be found\\n        long long start = (int)pow(10,(intLength-1));\\n        long long end = (int)pow(10, intLength) - 1;\\n        \\n        vector<long long>vec;\\n        \\n        for(long long i = start+1; i <= end; i++){\\n            long long num = i, rev = 0;\\n            while(num!=0){\\n                rev=rev*10+(num%10);\\n                num/=10;\\n            }\\n\\t\\t\\t//Inserting only pelindrome numbers witihin that range\\n            if(i == rev) vec.push_back(rev);\\n        }\\n        //Checking if no any pelindrome found then return empty -1 status\\n        vector<long long> ans;\\n        if(vec.empty()){\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n       //Getting answer of queries from vec array and pushing into ans vector\\n    for(int i = 0;i<queries.size();i++){\\n        ans.push_back(vec[queries[i]-1]);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n      //Finding range of pelindrome number to be found\\n        long long start = (int)pow(10,(intLength-1));\\n        long long end = (int)pow(10, intLength) - 1;\\n        \\n        vector<long long>vec;\\n        \\n        for(long long i = start+1; i <= end; i++){\\n            long long num = i, rev = 0;\\n            while(num!=0){\\n                rev=rev*10+(num%10);\\n                num/=10;\\n            }\\n\\t\\t\\t//Inserting only pelindrome numbers witihin that range\\n            if(i == rev) vec.push_back(rev);\\n        }\\n        //Checking if no any pelindrome found then return empty -1 status\\n        vector<long long> ans;\\n        if(vec.empty()){\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n       //Getting answer of queries from vec array and pushing into ans vector\\n    for(int i = 0;i<queries.size();i++){\\n        ans.push_back(vec[queries[i]-1]);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213521,
                "title": "java-kth-permutation-variation",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) \\n    {\\n        int n=queries.length;\\n        \\n        long ans[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int k=queries[i];\\n            ans[i]=helper((long)k-1,intLength);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public long helper(long k,int len)\\n    {\\n        int fill=(len+1)/2;\\n        long max=9*(long)Math.pow(10,fill-1);\\n        \\n        if(k>=max)\\n        return -1L;\\n        \\n        long start=(long)Math.pow(10,fill-1);\\n        StringBuilder sb=new StringBuilder(Long.toString((k/start)+1));\\n        \\n        k=k%start;\\n        start=start/10;\\n        \\n        for(int i=2;i<=fill;i++)\\n        {\\n            sb=sb.append((k/start));\\n            k=k%start;\\n            start=start/10;\\n        }\\n        \\n        String x=sb.toString();\\n        sb=sb.reverse();\\n        \\n        if(len%2!=0)\\n        sb=sb.deleteCharAt(0);\\n        \\n        x+=sb.toString();\\n        \\n        long ans=Long.parseLong(x);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) \\n    {\\n        int n=queries.length;\\n        \\n        long ans[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int k=queries[i];\\n            ans[i]=helper((long)k-1,intLength);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public long helper(long k,int len)\\n    {\\n        int fill=(len+1)/2;\\n        long max=9*(long)Math.pow(10,fill-1);\\n        \\n        if(k>=max)\\n        return -1L;\\n        \\n        long start=(long)Math.pow(10,fill-1);\\n        StringBuilder sb=new StringBuilder(Long.toString((k/start)+1));\\n        \\n        k=k%start;\\n        start=start/10;\\n        \\n        for(int i=2;i<=fill;i++)\\n        {\\n            sb=sb.append((k/start));\\n            k=k%start;\\n            start=start/10;\\n        }\\n        \\n        String x=sb.toString();\\n        sb=sb.reverse();\\n        \\n        if(len%2!=0)\\n        sb=sb.deleteCharAt(0);\\n        \\n        x+=sb.toString();\\n        \\n        long ans=Long.parseLong(x);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191346,
                "title": "c-index-from-pow-10-length-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> r;\\n        long long start,count,num,ans digitLen,d;\\n        bool bOddLen,firstSkipped=false;\\n        \\n        for (auto& q : queries) {\\n            bOddLen = intLength % 2 == 1;\\n            digitLen = (intLength-1) / 2;\\n\\n            start = pow(10, digitLen);\\n            count = pow(10,digitLen+1)-start;\\n            \\n            num = start + q - 1;\\n            if(q>count) {   r.push_back(-1);  continue; }\\n\\n            ans = num;\\n            firstSkipped = false;\\n            while (num) {\\n                d = num % 10;\\n                num = num / 10;\\n                if (bOddLen && !firstSkipped) {  firstSkipped = true;continue; }\\n                ans = ans * 10 + d;\\n            }\\n           r.push_back(ans);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> r;\\n        long long start,count,num,ans digitLen,d;\\n        bool bOddLen,firstSkipped=false;\\n        \\n        for (auto& q : queries) {\\n            bOddLen = intLength % 2 == 1;\\n            digitLen = (intLength-1) / 2;\\n\\n            start = pow(10, digitLen);\\n            count = pow(10,digitLen+1)-start;\\n            \\n            num = start + q - 1;\\n            if(q>count) {   r.push_back(-1);  continue; }\\n\\n            ans = num;\\n            firstSkipped = false;\\n            while (num) {\\n                d = num % 10;\\n                num = num / 10;\\n                if (bOddLen && !firstSkipped) {  firstSkipped = true;continue; }\\n                ans = ans * 10 + d;\\n            }\\n           r.push_back(ans);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186268,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        long long int base=(pow(10, (intLength-1)/2));\\n        long long int maxLimit= 9*base;\\n        \\n        vector<long long> res;\\n        long long int a,b;\\n        string str1, str2;\\n        for(auto q: queries) {\\n            if(q>maxLimit) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            a=base+q-1;\\n            str1=to_string(a);\\n            str2=str1;\\n            if(intLength%2) \\n                str1.pop_back();\\n            reverse(str1.begin(), str1.end());\\n            str2+=str1; \\n            a=stoll(str2);\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        long long int base=(pow(10, (intLength-1)/2));\\n        long long int maxLimit= 9*base;\\n        \\n        vector<long long> res;\\n        long long int a,b;\\n        string str1, str2;\\n        for(auto q: queries) {\\n            if(q>maxLimit) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            a=base+q-1;\\n            str1=to_string(a);\\n            str2=str1;\\n            if(intLength%2) \\n                str1.pop_back();\\n            reverse(str1.begin(), str1.end());\\n            str2+=str1; \\n            a=stoll(str2);\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169448,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        s=[]\\n        c=0\\n        if intLength%2==0:\\n            c=intLength//2-1\\n        else:\\n            c=intLength//2\\n        d=[]\\n        for i in queries:\\n            d=str(10**c +i-1) \\n            if intLength%2==0:\\n                d+=d[::-1]\\n            else:\\n                 d+=d[::-1][1:]\\n            if len(d) == intLength:\\n                s.append(d)\\n            else:\\n                s.append(-1)\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        s=[]\\n        c=0\\n        if intLength%2==0:\\n            c=intLength//2-1\\n        else:\\n            c=intLength//2\\n        d=[]\\n        for i in queries:\\n            d=str(10**c +i-1) \\n            if intLength%2==0:\\n                d+=d[::-1]\\n            else:\\n                 d+=d[::-1][1:]\\n            if len(d) == intLength:\\n                s.append(d)\\n            else:\\n                s.append(-1)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121018,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        p1 = \\'1\\'\\n        p1 += \\'0\\'*((intLength-1) // 2)  \\n        ans = []\\n        place = 9*(10**((intLength-1) // 2)) # numbers of palindrome in this intlength \\n        for i in queries:\\n            if i <= place:\\n                strTempt = str(int(p1)+i-1) \\n                strTempt += strTempt[::-1]\\n                if (intLength-1) % 2 !=1:\\n                    strTempt = strTempt[:intLength // 2]+ strTempt[intLength // 2 +1:] \\n                ans.append(int(strTempt))\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```\\n\\t\\n![image](https://assets.leetcode.com/users/images/84116f73-3e47-4e16-a65b-920b807464a0_1654580823.6780982.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        p1 = \\'1\\'\\n        p1 += \\'0\\'*((intLength-1) // 2)  \\n        ans = []\\n        place = 9*(10**((intLength-1) // 2)) # numbers of palindrome in this intlength \\n        for i in queries:\\n            if i <= place:\\n                strTempt = str(int(p1)+i-1) \\n                strTempt += strTempt[::-1]\\n                if (intLength-1) % 2 !=1:\\n                    strTempt = strTempt[:intLength // 2]+ strTempt[intLength // 2 +1:] \\n                ans.append(int(strTempt))\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061159,
                "title": "c",
                "content": "\\t\\t#define ll unsigned long long int\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<long long> kthPalindrome(vector<int>& q, int n) {\\n\\t\\t\\t\\tlong long h=0;\\n\\t\\t\\t\\tint j = n;\\n\\t\\t\\t\\twhile(j--){\\n\\t\\t\\t\\t\\th = h*10 + 9;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long k;\\n\\t\\t\\t\\tif(n%2==0){\\n\\t\\t\\t\\t\\tk = n/2 - 1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tk = n/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long m = 1;\\n\\t\\t\\t\\twhile(k--){\\n\\t\\t\\t\\t\\tm = m*10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<long long> res;\\n\\n\\t\\t\\t\\tfor(int i=0; i<q.size(); i++){\\n\\t\\t\\t\\t\\tll num = m;\\n\\t\\t\\t\\t\\tnum = num+(q[i]-1);\\n\\t\\t\\t\\t\\tlong long b;\\n\\n\\t\\t\\t\\t\\tif(n%2==1){\\n\\t\\t\\t\\t\\t\\tb = num/10;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tb = num;\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\twhile(b){\\n\\t\\t\\t\\t\\t\\tnum = num*10 + b%10;\\n\\t\\t\\t\\t\\t\\tb = b/10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(num>h){\\n\\t\\t\\t\\t\\t\\tres.push_back(-1);\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tres.push_back(num);\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn res;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<long long> kthPalindrome(vector<int>& q, int n) {\\n\\t\\t\\t\\tlong long h=0;\\n\\t\\t\\t\\tint j = n;\\n\\t\\t\\t\\twhile(j--){\\n\\t\\t\\t\\t\\th = h*10 + 9;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2035625,
                "title": "palindrome-with-fixed-length",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        vector<long long>res;\\n        int k=intLength;\\n        long long Cpalk;\\n        \\n        //count total number of possible palindrome of kth digits\\n        long long p=(k&1)?((k+1)/2-1):(k/2-1);\\n        Cpalk=(long long)pow(10LL, p)*9;\\n        \\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //If value of queries is greater than possible number of palindrome of kth digit push_back -1\\n            \\n            if(Cpalk<queries[i]){\\n                res.push_back(-1);\\n            }\\n            else{\\n                \\n                int n=queries[i];\\n                \\n                // We can easily write the above sequence for nth\\n//                 palindrome as: (n-1) + 1000\\n//                 For k digit number, we can generalize above formula as:\\n\\n//                 If k is odd\\n//                 => num = (n-1) + 10k/2\\n//                 else \\n//                 => num = (n-1) + 10k/2 - 1 \\n\\n//                 Now rest half digits can be expanded by just \\n//                 printing the value of num in reverse order. \\n//                 But before this if k is odd then we have to truncate \\n//                 the last digit of a value num \\n                    \\n                    \\n                long long temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n                long long num= (long long)pow(10LL, temp);\\n                num += n - 1;\\n                \\n                \\n                string ans=\"\";\\n                \\n                if(k&1){\\n                    if(num<10){\\n                        res.push_back(num);\\n                        continue;\\n                    }\\n                    \\n                    int t=num%10;\\n                    num=num/10;\\n                    \\n                    ans+=to_string(num);\\n                    string temp=ans;\\n                    ans+=to_string(t);\\n                    \\n                    reverse(temp.begin(), temp.end());\\n                    ans+=temp;\\n                    \\n                    res.push_back(stoll(ans));\\n                    \\n                }else{\\n                    ans+=to_string(num);\\n                    string temp=ans;\\n                    reverse(temp.begin(), temp.end());\\n                    ans+=temp;\\n                    \\n                    res.push_back(stoll(ans));\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        vector<long long>res;\\n        int k=intLength;\\n        long long Cpalk;\\n        \\n        //count total number of possible palindrome of kth digits\\n        long long p=(k&1)?((k+1)/2-1):(k/2-1);\\n        Cpalk=(long long)pow(10LL, p)*9;\\n        \\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //If value of queries is greater than possible number of palindrome of kth digit push_back -1\\n            \\n            if(Cpalk<queries[i]){\\n                res.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2004648,
                "title": "intuitive-easy-to-understand-c",
                "content": "```\\nclass Solution {\\n    long long vecToInt(vector<int>& vec) {\\n        long long res = 0;\\n        for (int i = 0; i < vec.size(); i++) {\\n            res = res * 10 + vec[i];\\n        }\\n        return res;\\n    }\\n\\n    long long getMaxQuery(int len) {\\n        long long res = 9;\\n        if (len%2) len++;\\n        for (int i = 1; i < len/2; i++) {\\n            res *= 10;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int mx = getMaxQuery(intLength);\\n        \\n        vector<long long> res;\\n        for (int q : queries) {\\n            if (q > mx) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n\\n            q--; // Because we\\'re dealing with 0 based index\\n\\n            vector<int> num(intLength, 0);\\n\\n            int l, r; // Starting from the middle and work our way to the boundaries\\n            if (intLength%2) l = r = intLength/2;\\n            else l = (intLength-1)/2, r = intLength/2;\\n\\n            while (l >= 0) {\\n                if (l == 0) {\\n                    // Handeling this case alone because the numbers range from 1 to 9 (9 numbers)\\n                    // we can\\'t have leading zeros\\n                    num[l] = num[r] = (q%9 + 1);\\n                } else {\\n                    // Numbers range from 0 to 9 (10 numbers)\\n                    num[l] = num[r] = (q%10);\\n                }\\n\\n                q /= 10;\\n                l--, r++;\\n            }\\n\\n            res.push_back(vecToInt(num));\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long long vecToInt(vector<int>& vec) {\\n        long long res = 0;\\n        for (int i = 0; i < vec.size(); i++) {\\n            res = res * 10 + vec[i];\\n        }\\n        return res;\\n    }\\n\\n    long long getMaxQuery(int len) {\\n        long long res = 9;\\n        if (len%2) len++;\\n        for (int i = 1; i < len/2; i++) {\\n            res *= 10;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int mx = getMaxQuery(intLength);\\n        \\n        vector<long long> res;\\n        for (int q : queries) {\\n            if (q > mx) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n\\n            q--; // Because we\\'re dealing with 0 based index\\n\\n            vector<int> num(intLength, 0);\\n\\n            int l, r; // Starting from the middle and work our way to the boundaries\\n            if (intLength%2) l = r = intLength/2;\\n            else l = (intLength-1)/2, r = intLength/2;\\n\\n            while (l >= 0) {\\n                if (l == 0) {\\n                    // Handeling this case alone because the numbers range from 1 to 9 (9 numbers)\\n                    // we can\\'t have leading zeros\\n                    num[l] = num[r] = (q%9 + 1);\\n                } else {\\n                    // Numbers range from 0 to 9 (10 numbers)\\n                    num[l] = num[r] = (q%10);\\n                }\\n\\n                q /= 10;\\n                l--, r++;\\n            }\\n\\n            res.push_back(vecToInt(num));\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994229,
                "title": "python-first-half-maths",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        \"\"\"\\n        :type queries: List[int]\\n        :type intLength: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if intLength % 2 == 0:\\n            start = 10**(intLength/2 - 1)\\n            ma =  9*(10**(intLength/2 - 1))\\n        else:\\n            start = 10**(intLength/2)\\n            ma =  9*(10**(intLength/2))\\n        r = []\\n        for q in queries:\\n            if q > ma:\\n                r.append(-1)\\n                continue\\n            w = str(start + q - 1)\\n            if intLength == 1:\\n                r.append(w)\\n                continue\\n            if intLength % 2 != 0:\\n                r.append(w + w[0:len(w)-1][::-1])\\n                continue\\n            r.append(w + w[:][::-1])\\n        return r\\n            \\n        \\n      \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        \"\"\"\\n        :type queries: List[int]\\n        :type intLength: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if intLength % 2 == 0:\\n            start = 10**(intLength/2 - 1)\\n            ma =  9*(10**(intLength/2 - 1))\\n        else:\\n            start = 10**(intLength/2)\\n            ma =  9*(10**(intLength/2))\\n        r = []\\n        for q in queries:\\n            if q > ma:\\n                r.append(-1)\\n                continue\\n            w = str(start + q - 1)\\n            if intLength == 1:\\n                r.append(w)\\n                continue\\n            if intLength % 2 != 0:\\n                r.append(w + w[0:len(w)-1][::-1])\\n                continue\\n            r.append(w + w[:][::-1])\\n        return r\\n            \\n        \\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973867,
                "title": "java-cut-the-number-into-half-and-everything-is-clear",
                "content": "for 4 digit number \\nthe first number is  1001;\\nthe second is          1111;\\nthe third is               1221;\\ncut the number into halves:\\n1: 10\\n2: 11\\n3: 12\\n...\\nn: 10+n-1;\\nthen and a reversed number to it. 12--->1221, 13-->1331\\n\\nNOTE: if it\\'s an odd length number, 12321, half is 123, when we add a reversed number to it, we need to remove the last digit 3 \\n\\n\\n\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long minHalf=(long)Math.pow(10,(intLength-1)/2);\\n        long maxIndex=(long)Math.pow(10,(intLength+1)/2)-minHalf;\\n        boolean isOdd=intLength%2==1;\\n        long res[]=new long[queries.length];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=queries[i]>maxIndex?-1:helper(queries[i],minHalf,isOdd);\\n        }\\n        return res;\\n    }\\n    \\n    private long helper(long index,long minHalf,boolean isOdd){\\n        long half=minHalf+index-1;\\n        long res=half;\\n        if(isOdd){\\n            res/=10;\\n        }\\n        while(half!=0){\\n            res=res*10+half%10;\\n            half/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long minHalf=(long)Math.pow(10,(intLength-1)/2);\\n        long maxIndex=(long)Math.pow(10,(intLength+1)/2)-minHalf;\\n        boolean isOdd=intLength%2==1;\\n        long res[]=new long[queries.length];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=queries[i]>maxIndex?-1:helper(queries[i],minHalf,isOdd);\\n        }\\n        return res;\\n    }\\n    \\n    private long helper(long index,long minHalf,boolean isOdd){\\n        long half=minHalf+index-1;\\n        long res=half;\\n        if(isOdd){\\n            res/=10;\\n        }\\n        while(half!=0){\\n            res=res*10+half%10;\\n            half/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967265,
                "title": "java-solve-for-half",
                "content": "```\\npublic long[] kthPalindrome(int[] queries, int intLength) {\\n        var res = new long[queries.length];\\n        \\n        var halfLength = (intLength / 2) + (intLength % 2);\\n        var first = (int) Math.pow(10, halfLength - 1);\\n        var last = (int) Math.pow(10, halfLength) - 1;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            var half = first + queries[i] - 1;\\n            var next = build(half, intLength);\\n            \\n            res[i] = half > last ? -1 : next;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long build(long n, long l) {\\n        var res = n;\\n        \\n        if (l % 2 == 1) // for odd length, we skip the middle element\\n            n /= 10;\\n        \\n        \\n        while (n > 0) {\\n            res = res * 10 + n % 10;\\n            n /= 10;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long[] kthPalindrome(int[] queries, int intLength) {\\n        var res = new long[queries.length];\\n        \\n        var halfLength = (intLength / 2) + (intLength % 2);\\n        var first = (int) Math.pow(10, halfLength - 1);\\n        var last = (int) Math.pow(10, halfLength) - 1;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            var half = first + queries[i] - 1;\\n            var next = build(half, intLength);\\n            \\n            res[i] = half > last ? -1 : next;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long build(long n, long l) {\\n        var res = n;\\n        \\n        if (l % 2 == 1) // for odd length, we skip the middle element\\n            n /= 10;\\n        \\n        \\n        while (n > 0) {\\n            res = res * 10 + n % 10;\\n            n /= 10;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946956,
                "title": "can-someone-help-me-with-what-i-did-wrong",
                "content": "I am getting time exceeded error, I do understand I am using 4 loops but in terms of thinking process, what could I have done better?\\n\\nHere is my code, and TIA\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = [-1 for i in range(len(queries))]\\n        palindrome = []\\n        \\n        low = 10**(intLength-1)\\n        high = 10**intLength\\n        x = 0\\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i]>=high):\\n                queries[i] = -1\\n        \\n        while(low<=high):\\n            if(x<=max(queries)):\\n                str1 = str(low)\\n                str2 = str1[::-1]\\n                if(str1==str2):\\n                    palindrome.append(low)\\n                    x = x + 1\\n                \\n            low = low + 1\\n        \\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i] != -1):\\n                try:\\n                    ans[i] = palindrome[queries[i]-1]\\n                except:\\n                    ans[i] = -1\\n        \\n            \\n        return ans\\n            \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = [-1 for i in range(len(queries))]\\n        palindrome = []\\n        \\n        low = 10**(intLength-1)\\n        high = 10**intLength\\n        x = 0\\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i]>=high):\\n                queries[i] = -1\\n        \\n        while(low<=high):\\n            if(x<=max(queries)):\\n                str1 = str(low)\\n                str2 = str1[::-1]\\n                if(str1==str2):\\n                    palindrome.append(low)\\n                    x = x + 1\\n                \\n            low = low + 1\\n        \\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i] != -1):\\n                try:\\n                    ans[i] = palindrome[queries[i]-1]\\n                except:\\n                    ans[i] = -1\\n        \\n            \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937935,
                "title": "golang-easy-manipulation-o-n-time-o-1-mem-100",
                "content": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    half := (intLength - 1) / 2 + 1\\n    \\n    start := 1\\n    for i := 1; i < half; i++ {\\n       start *= 10 \\n    }\\n    \\n    numPalin := start * 9\\n    start--\\n    doubleLast := (intLength & 1) == 0\\n    \\n    ans := make([]int64, len(queries)) \\n    for i := range queries {\\n        if queries[i] > numPalin {\\n            ans[i] = -1\\n        } else {\\n            ans[i] = mirror(start + queries[i], doubleLast)\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc mirror(v int, doubleLast bool) int64 {\\n    ans := 0\\n    p := 1 // power of 10\\n    for v > 0 {\\n        d := v % 10 // digit\\n        v /= 10\\n        \\n        if p == 1 { // first\\n            if doubleLast {\\n                ans = d * 11\\n                p = 100\\n            } else {\\n                ans = d\\n                p = 10\\n            }\\n        } else {\\n            ans = 10 * (d * p + ans) + d\\n            p *= 100\\n        }\\n    } \\n    \\n    return int64(ans)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    half := (intLength - 1) / 2 + 1\\n    \\n    start := 1\\n    for i := 1; i < half; i++ {\\n       start *= 10 \\n    }\\n    \\n    numPalin := start * 9\\n    start--\\n    doubleLast := (intLength & 1) == 0\\n    \\n    ans := make([]int64, len(queries)) \\n    for i := range queries {\\n        if queries[i] > numPalin {\\n            ans[i] = -1\\n        } else {\\n            ans[i] = mirror(start + queries[i], doubleLast)\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc mirror(v int, doubleLast bool) int64 {\\n    ans := 0\\n    p := 1 // power of 10\\n    for v > 0 {\\n        d := v % 10 // digit\\n        v /= 10\\n        \\n        if p == 1 { // first\\n            if doubleLast {\\n                ans = d * 11\\n                p = 100\\n            } else {\\n                ans = d\\n                p = 10\\n            }\\n        } else {\\n            ans = 10 * (d * p + ans) + d\\n            p *= 100\\n        }\\n    } \\n    \\n    return int64(ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935424,
                "title": "the-general-rule-to-build-number-palindrome",
                "content": "To solve this problem with confidence, it is better to know the general rule behind number palindrome generation.\\n\\nTo build a palindrome from a number `n`, we can just reverse all the digits of `n` and concatenate them to create a palindrome. \\n\\nLet\\'s start from two base case:\\n\\n*  Build palindrome from a even-length number\\n\\n\\tGiven the number `12`, try to build the palindromes from it.\\n\\n\\tThe reversed number of `12` is `21`, so we get a even-length palindrome `1221`. \\n\\n\\tTo get odd-length palindrome, we simply drop the last digit of `12` to get `1`. The reversed number of `1` is `1`. `12`+`1` = `121`. \\n\\n\\tSo we can get two palindromes from a single even-length number: one is even-length and the other is odd-length.\\n\\n*  Build palindrome from a odd-length number\\n\\n\\tGiven the number `123`, try to build the palindromes from it.\\n\\n\\tThe reversed number of `123` is `321`, so we get a even-length palindrome `123321`. \\n\\n\\tTo get odd-length palindrome, we simply drop the last digit of `123` to get `12`. The reversed number of `12` is `21`. `123`+`21` = `12321`. \\n\\n\\tSo we can also get two palindromes from a single odd-length number: one is even-length and the other is odd-length.\\n\\nThe two cases can be generalized and summized as the following table:\\n( I call the number used to generate the palindrome the `seed` number, and its length the `seed len`.)\\n\\n```\\nseed len  |  seed range   | even-length palindrome  | odd-length palindrome\\n1         | 1 ~ 9         | 11 ~ 99                 | 1 ~ 9\\n2         | 10 ~ 99       | 1001 ~ 9999             | 101 ~ 999\\n3         | 100 ~ 999     | 100001 ~ 999999         | 10001 ~ 99999\\n4         | 1000 ~ 9999   | 10000001 ~ 99999999     | 1000001 ~ 9999999\\n```  \\n\\nNow let\\'s take a look another fact about the palindrome generation: **the order**.\\nTake single digit number for example, the palindromes are:\\n**odd length**\\n1 -> 1\\n2 -> 2\\n3 -> 3\\n4 -> 4\\n5 -> 5\\n6 -> 6\\n7 -> 7\\n8 -> 8\\n9 -> 9\\n\\n**even length**\\n1 -> 11\\n2 -> 22\\n3 -> 33\\n4 -> 44\\n5 -> 55\\n6 -> 66\\n7 -> 77\\n8 -> 88\\n9 -> 99\\n\\nYou can see the **generated palindromes are in the same order as the seed number**.\\n**It means if we want to generate the 9-th palindrome of length 1, we just take the 9-th seed and the generated palindrome will be the 9-th palindrome.***\\n\\nNow come back to the problem. It is asking palindrome of a given length, how do we know the seed length? We already know that for any number of length `n`, it can be used to build a palindrome of length `2n` or `2n-1`. So on the other side, **to get a palindrome of length `n`, it can be built from a seed number of length `(n+1)/2` .**\\n\\nOnce we know the seed length, the seed range can be calculated by \\n```\\nstart seed=10^(seed_len-1) \\nend seed=10^seed_len - 1\\n```\\n\\nBy iterating every element in `quries` , we know the `queries[i]th` palindrome can be generated by `start seed + queries[i]` if it does not exceed `end seed`. A helper function `getPal` is then called to get the palindrome from this seed.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int seedLen = (intLength+1)/2;\\n        int start = pow(10, seedLen-1), end = pow(10, seedLen);\\n        int n = queries.size();\\n        vector<long long> ret;\\n        bool evenLen = intLength%2==0;\\n        for(int i=0; i<n; i++) {\\n            int seed = queries[i]+start-1;\\n            if(seed>=end)\\n                ret.push_back(-1);\\n            else\\n                ret.push_back(getPal(seed, evenLen));\\n        }\\n        return ret;\\n        \\n    }\\n    \\n    // get palindrome, \\n    // even: even length or not\\n    long long getPal(long long n, bool even) {\\n        long long t = n;\\n        if(!even)\\n            t /= 10;\\n        while(t) {\\n            n = n*10 + t%10;\\n            t/=10;\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\n\\n\\nSimilar problems\\nhttps://leetcode.com/problems/sum-of-k-mirror-numbers/\\nhttps://leetcode.com/problems/find-palindrome-with-fixed-length/\\n",
                "solutionTags": [],
                "code": "```\\nseed len  |  seed range   | even-length palindrome  | odd-length palindrome\\n1         | 1 ~ 9         | 11 ~ 99                 | 1 ~ 9\\n2         | 10 ~ 99       | 1001 ~ 9999             | 101 ~ 999\\n3         | 100 ~ 999     | 100001 ~ 999999         | 10001 ~ 99999\\n4         | 1000 ~ 9999   | 10000001 ~ 99999999     | 1000001 ~ 9999999\\n```\n```\\nstart seed=10^(seed_len-1) \\nend seed=10^seed_len - 1\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int seedLen = (intLength+1)/2;\\n        int start = pow(10, seedLen-1), end = pow(10, seedLen);\\n        int n = queries.size();\\n        vector<long long> ret;\\n        bool evenLen = intLength%2==0;\\n        for(int i=0; i<n; i++) {\\n            int seed = queries[i]+start-1;\\n            if(seed>=end)\\n                ret.push_back(-1);\\n            else\\n                ret.push_back(getPal(seed, evenLen));\\n        }\\n        return ret;\\n        \\n    }\\n    \\n    // get palindrome, \\n    // even: even length or not\\n    long long getPal(long long n, bool even) {\\n        long long t = n;\\n        if(!even)\\n            t /= 10;\\n        while(t) {\\n            n = n*10 + t%10;\\n            t/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932368,
                "title": "java-math-time-on-space-o1",
                "content": "Runtime: 48 ms, faster than 82.51% of Java online submissions for Find Palindrome With Fixed Length.\\nMemory Usage: 51.1 MB, less than 97.47% of Java online submissions for Find Palindrome With Fixed Length.\\n```\\nclass Solution {\\n  public long[] kthPalindrome(int[] queries, int intLength) {\\n    long ans[] = new long[queries.length];                                    //for answer\\n    int f_len = (intLength>>1) + (intLength&1);                               //for middle of polindrom\\n    char table[] = new char[intLength];                                       //for each digit of polindrome\\n    int id = 0;                                                               //for index of answer\\n    \\n    for(int n : queries){                                         \\n      Arrays.fill(table, \\'0\\');                                                //prepear for current number\\n      table[0] = \\'1\\';                                                         //and fill first number\\n      n--; \\n      for(int i = f_len; i > 0; n /= 10) table[--i] += n%10;                  //fill our table from begin to middle\\n      \\n      if(n == 0){                                                         //if such polindrome exist\\n        for(int i = 0, j = intLength - 1; i < j; ) table[j--] = table[i++];   //fill our polindrome from middle to end\\n        \\n        try {ans[id] = Long.parseLong(new String(table));}                    //try to convert into long\\n        catch (Exception e){ans[id] = -1;}\\n        \\n        id++;      \\n      }else ans[id++] = -1;                                               //if not exist                                           \\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long[] kthPalindrome(int[] queries, int intLength) {\\n    long ans[] = new long[queries.length];                                    //for answer\\n    int f_len = (intLength>>1) + (intLength&1);                               //for middle of polindrom\\n    char table[] = new char[intLength];                                       //for each digit of polindrome\\n    int id = 0;                                                               //for index of answer\\n    \\n    for(int n : queries){                                         \\n      Arrays.fill(table, \\'0\\');                                                //prepear for current number\\n      table[0] = \\'1\\';                                                         //and fill first number\\n      n--; \\n      for(int i = f_len; i > 0; n /= 10) table[--i] += n%10;                  //fill our table from begin to middle\\n      \\n      if(n == 0){                                                         //if such polindrome exist\\n        for(int i = 0, j = intLength - 1; i < j; ) table[j--] = table[i++];   //fill our polindrome from middle to end\\n        \\n        try {ans[id] = Long.parseLong(new String(table));}                    //try to convert into long\\n        catch (Exception e){ans[id] = -1;}\\n        \\n        id++;      \\n      }else ans[id++] = -1;                                               //if not exist                                           \\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929286,
                "title": "pure-manipulation-beats-98-5",
                "content": "-The first thing to note, is that the first palindrome at any intLength starts with 1. For length 1 we have 1, for length 2 we have 11, length 3 we have 101. So i decided to only deal with one side of the possible solution for a  query. \\n\\n-I created an initial, which is the start of the first possible solution. As we loop through the query all we have to do is add the value in query -1 to initial to arrive at what one side of the palindrome will be. With this we can build the other side of the palindrome.\\n\\n-The next thing is determining when we have reached the limit of a query, i found that the limit of a query occurs at 9* initial.\\n\\n\\n        half=math.ceil(intLength/2)\\n        res=[]\\n        initial=int(\\'1\\'+(half-1)*\\'0\\')\\n    \\n        for query in queries:\\n            if query<=9*initial:\\n                new_half=initial+query-1\\n                string_half=str(new_half)#converts to str since we would do reversals later.\\n                \\n                if intLength%2: res.append(int(string_half[:]+string_half[::-1][1:]))\\n                else: res.append(int(string_half+string_half[::-1]))\\n                \\n            else:#From testing i found there are no more than 9*initial palindromes for an intLength\\n                res.append(-1)\\n        return res\\n\\t",
                "solutionTags": [
                    "Math"
                ],
                "code": "-The first thing to note, is that the first palindrome at any intLength starts with 1. For length 1 we have 1, for length 2 we have 11, length 3 we have 101. So i decided to only deal with one side of the possible solution for a  query. \\n\\n-I created an initial, which is the start of the first possible solution. As we loop through the query all we have to do is add the value in query -1 to initial to arrive at what one side of the palindrome will be. With this we can build the other side of the palindrome.\\n\\n-The next thing is determining when we have reached the limit of a query, i found that the limit of a query occurs at 9* initial.\\n\\n\\n        half=math.ceil(intLength/2)\\n        res=[]\\n        initial=int(\\'1\\'+(half-1)*\\'0\\')\\n    \\n        for query in queries:\\n            if query<=9*initial:\\n                new_half=initial+query-1\\n                string_half=str(new_half)#converts to str since we would do reversals later.\\n                \\n                if intLength%2: res.append(int(string_half[:]+string_half[::-1][1:]))\\n                else: res.append(int(string_half+string_half[::-1]))\\n                \\n            else:#From testing i found there are no more than 9*initial palindromes for an intLength\\n                res.append(-1)\\n        return res\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1915677,
                "title": "easy-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fe(long long e,int a){\\n        long long b=e;\\n        if(a==0){\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        else{\\n            e=e/10;\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        return b;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        long long a,c,d,e,f;\\n        int b;\\n        vector<long long>ans;\\n        b=l/2+(l%2);\\n        c=pow(10,b-1);\\n        d=pow(10,b)-1;\\n        for(int i=0;i<q.size();i++){\\n            a=q[i];\\n            e=c+a-1;\\n            if(e<=d){\\n                f=fe(e,l%2);\\n                ans.push_back(f);\\n            }\\n            else{\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fe(long long e,int a){\\n        long long b=e;\\n        if(a==0){\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        else{\\n            e=e/10;\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        return b;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        long long a,c,d,e,f;\\n        int b;\\n        vector<long long>ans;\\n        b=l/2+(l%2);\\n        c=pow(10,b-1);\\n        d=pow(10,b)-1;\\n        for(int i=0;i<q.size();i++){\\n            a=q[i];\\n            e=c+a-1;\\n            if(e<=d){\\n                f=fe(e,l%2);\\n                ans.push_back(f);\\n            }\\n            else{\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908127,
                "title": "c",
                "content": "```\\n    public long[] KthPalindrome(int[] queries, int intLength)\\n    {\\n        List<long> list = new List<long>();\\n        long initialValue= (long)(Math.Pow(10, (intLength - 1) / 2));\\n        foreach (int n in queries)\\n            if (initialValue + n > initialValue * 10)\\n                list.Add(-1);\\n            else\\n            {\\n                if (intLength % 2 == 0)\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, intLength / 2) + ReverseLong(n - 1 + initialValue));\\n                else\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, (intLength - 1) / 2) + ReverseLong((n - 1 + initialValue) / 10));\\n            }\\n        return list.ToArray();\\n    }\\n    public long ReverseLong(long num)\\n    {\\n        long result = 0;\\n        while (num > 0)\\n        {\\n            result = result * 10 + num % 10;\\n            num /= 10;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long[] KthPalindrome(int[] queries, int intLength)\\n    {\\n        List<long> list = new List<long>();\\n        long initialValue= (long)(Math.Pow(10, (intLength - 1) / 2));\\n        foreach (int n in queries)\\n            if (initialValue + n > initialValue * 10)\\n                list.Add(-1);\\n            else\\n            {\\n                if (intLength % 2 == 0)\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, intLength / 2) + ReverseLong(n - 1 + initialValue));\\n                else\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, (intLength - 1) / 2) + ReverseLong((n - 1 + initialValue) / 10));\\n            }\\n        return list.ToArray();\\n    }\\n    public long ReverseLong(long num)\\n    {\\n        long result = 0;\\n        while (num > 0)\\n        {\\n            result = result * 10 + num % 10;\\n            num /= 10;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906438,
                "title": "c-95-faster-time-complexity-o-n-log-n-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int check(int num,int len)\\n    {\\n        int n=0;\\n        if(len&1)\\n            n=len/2;\\n        else\\n            n=len/2-1;\\n        long long int ans=(long long int)pow(10,n)+num-1;\\n        unsigned long long int p=ans;\\n        if(len&1)\\n            ans/=10;\\n        while(ans)\\n        {\\n            p=p*10+ans%10;\\n            ans/=10;\\n        }\\n        return p;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long int k=0;\\n            k=check(queries[i],intLength);\\n            if(abs(k)>(long long int)(pow(10,intLength)-1))\\n                k=-1;\\n            ans.emplace_back(k);\\n        }\\n        return ans;\\n    }\\n};\\nany problem feel free to ask\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int check(int num,int len)\\n    {\\n        int n=0;\\n        if(len&1)\\n            n=len/2;\\n        else\\n            n=len/2-1;\\n        long long int ans=(long long int)pow(10,n)+num-1;\\n        unsigned long long int p=ans;\\n        if(len&1)\\n            ans/=10;\\n        while(ans)\\n        {\\n            p=p*10+ans%10;\\n            ans/=10;\\n        }\\n        return p;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long int k=0;\\n            k=check(queries[i],intLength);\\n            if(abs(k)>(long long int)(pow(10,intLength)-1))\\n                k=-1;\\n            ans.emplace_back(k);\\n        }\\n        return ans;\\n    }\\n};\\nany problem feel free to ask\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904351,
                "title": "half-length-based-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        vector<long long>ans;\\n        \\n        ll arr[]={9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999,99999999999,999999999999,9999999999999,99999999999999,999999999999999};\\n        \\n        for(auto x:queries)\\n        {\\n            \\n            ll k=(len)/2;\\n            \\n            if(len%2==0)\\n                  k=(len)/2-1;\\n            \\n            ll base=pow(10ll,k);\\n            \\n            base+=(x-1);\\n            \\n            if(base>arr[k])\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string s=to_string(base);\\n            \\n            if(len%2!=0)\\n            {\\n                for(int i=k-1;i>=0;i--)\\n                    s+=s[i];\\n            }\\n            else\\n            {\\n                for(int i=k;i>=0;i--)\\n                    s+=s[i];\\n            } \\n            ans.push_back(stol(s));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n[](http://www.google.com/url?sa=i&url=https%3A%2F%2Ftestbytessoftware.medium.com%2F50-funny-programming-memes-for-programmers-testbytes-ffa75eb8dcd7&psig=AOvVaw1BkpiZWnF48fPwGBAsVtlS&ust=1648924908713000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCLjh4-TC8_YCFQAAAAAdAAAAABA4)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        vector<long long>ans;\\n        \\n        ll arr[]={9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999,99999999999,999999999999,9999999999999,99999999999999,999999999999999};\\n        \\n        for(auto x:queries)\\n        {\\n            \\n            ll k=(len)/2;\\n            \\n            if(len%2==0)\\n                  k=(len)/2-1;\\n            \\n            ll base=pow(10ll,k);\\n            \\n            base+=(x-1);\\n            \\n            if(base>arr[k])\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string s=to_string(base);\\n            \\n            if(len%2!=0)\\n            {\\n                for(int i=k-1;i>=0;i--)\\n                    s+=s[i];\\n            }\\n            else\\n            {\\n                for(int i=k;i>=0;i--)\\n                    s+=s[i];\\n            } \\n            ans.push_back(stol(s));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902080,
                "title": "c-clean-and-easy-to-understand-short-explain",
                "content": "Steps:\\n1.Calculate the pairs of Palindrome for both even and odd pattern by (intLength+1)/2;\\n2.Generate evary result from left/right of Palindrome to center.\\n\\n```\\n        public long[] KthPalindrome(int[] queries, int intLength)\\n        {\\n            long[] res = new long[queries.Length];\\n            //maxCount for each intLength from 1 to 15\\n            Dictionary<int, long> maxCountDict = new Dictionary<int, long>();\\n            for(int i = 1; i <= 15; i++)\\n            {\\n                long count = 9;\\n                int j = i-1;\\n                while (j-- > 0)\\n                    count *= 10;\\n                maxCountDict.Add(i, count);\\n            }\\n            //how many palindrome pairs\\n            int pair = (intLength + 1) / 2;\\n            for (int i=0; i < queries.Length; i++)\\n            {\\n                //out of range, assign -1\\n                if (queries[i] > maxCountDict[pair]) res[i] = -1;\\n                else\\n                {\\n                    //from left/right to center, hold all digits\\n                    long[] list = new long[intLength];\\n                    long curr = queries[i];\\n                    for (int j = 0; j < pair; j++)\\n                    {\\n                        //get current index by divide to next total count of 10^(pair - j - 1)\\n                        long count = (long)Math.Pow(10, pair - j - 1);\\n                        long k = curr / count;\\n                        if (curr % count == 0) k--;//if mod is 0, need k--\\n                        curr -= k * count;\\n                        list[j] = k;\\n                        list[intLength-1-j] = k;//work for both odd and even intLength, only issue is double assign for the center of odd pattern\\n                    }\\n                    //remove leading zero\\n                    list[0] = list[0] + 1;\\n                    list[intLength-1] = list[0];//this will work for intLength=1, avoid duplicate +1\\n                    res[i] = long.Parse(String.Join(\"\", list));\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public long[] KthPalindrome(int[] queries, int intLength)\\n        {\\n            long[] res = new long[queries.Length];\\n            //maxCount for each intLength from 1 to 15\\n            Dictionary<int, long> maxCountDict = new Dictionary<int, long>();\\n            for(int i = 1; i <= 15; i++)\\n            {\\n                long count = 9;\\n                int j = i-1;\\n                while (j-- > 0)\\n                    count *= 10;\\n                maxCountDict.Add(i, count);\\n            }\\n            //how many palindrome pairs\\n            int pair = (intLength + 1) / 2;\\n            for (int i=0; i < queries.Length; i++)\\n            {\\n                //out of range, assign -1\\n                if (queries[i] > maxCountDict[pair]) res[i] = -1;\\n                else\\n                {\\n                    //from left/right to center, hold all digits\\n                    long[] list = new long[intLength];\\n                    long curr = queries[i];\\n                    for (int j = 0; j < pair; j++)\\n                    {\\n                        //get current index by divide to next total count of 10^(pair - j - 1)\\n                        long count = (long)Math.Pow(10, pair - j - 1);\\n                        long k = curr / count;\\n                        if (curr % count == 0) k--;//if mod is 0, need k--\\n                        curr -= k * count;\\n                        list[j] = k;\\n                        list[intLength-1-j] = k;//work for both odd and even intLength, only issue is double assign for the center of odd pattern\\n                    }\\n                    //remove leading zero\\n                    list[0] = list[0] + 1;\\n                    list[intLength-1] = list[0];//this will work for intLength=1, avoid duplicate +1\\n                    res[i] = long.Parse(String.Join(\"\", list));\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901337,
                "title": "simple-and-easy-well-commented-c-solution-for-better-undestanding",
                "content": "class Solution {\\npublic:\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        //for taking the power if intLength is 7 which is odd then 10^(7/2) i.e., 10^3 and if its 6 which is even the 10^(6/2-1) i.e., 10^2\\n        int power = intLength%2==0 ? (intLength/2-1) : (intLength/2);\\n        int start = pow(10, power);\\n        \\n        vector<long long> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //according to the observation 10+ query no. if its length is 3 & if length is 4 then it will start from 100 + query no.\\n            //start+ queries[i] - 1 -> 100 + 1 - 1 = 100\\n            string temp = to_string(start+ queries[i] - 1);\\n            \\n            //rev will store temp and will reverse it\\n            //reverse(100) -> 001\\n            string rev = temp;\\n            reverse(rev.begin(), rev.end());\\n            \\n            //intLength is even then 100+001 -> 100001 as its stored in string\\n            if(intLength%2==0){\\n                temp = temp + rev;\\n                \\n            //if intLength is odd then 1000+001 -> 1000001\\n            } else {\\n                //substr(pos, length) -> pos = position of first character and length of string\\n                //0001 -> 001\\n                temp = temp + rev.substr(1, rev.size()-1);\\n            }\\n            \\n            //Edge case that string should fall under the given length\\n            if(temp.size() == intLength){\\n                \\n                //stoll is used to convert string to long long\\n                ans.push_back(stoll(temp));\\n            }else {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        //for taking the power if intLength is 7 which is odd then 10^(7/2) i.e., 10^3 and if its 6 which is even the 10^(6/2-1) i.e., 10^2\\n        int power = intLength%2==0 ? (intLength/2-1) : (intLength/2);\\n        int start = pow(10, power);\\n        \\n        vector<long long> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //according to the observation 10+ query no. if its length is 3 & if length is 4 then it will start from 100 + query no.\\n            //start+ queries[i] - 1 -> 100 + 1 - 1 = 100\\n            string temp = to_string(start+ queries[i] - 1);\\n            \\n            //rev will store temp and will reverse it\\n            //reverse(100) -> 001\\n            string rev = temp;\\n            reverse(rev.begin(), rev.end());\\n            \\n            //intLength is even then 100+001 -> 100001 as its stored in string\\n            if(intLength%2==0){\\n                temp = temp + rev;\\n                \\n            //if intLength is odd then 1000+001 -> 1000001\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901150,
                "title": "golang-o-n-solution",
                "content": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n\\thalfWidth := intLength/2 + intLength%2\\n\\tfirstValue, maxValue := 1, 9\\n\\tfor i := 1; i < halfWidth; i++ {\\n\\t\\tfirstValue *= 10\\n\\t\\tmaxValue = maxValue*10 + 9\\n\\t}\\n\\tmaxQuery := maxValue - firstValue + 1\\n\\tanswers := make([]int64, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tif query > maxQuery {\\n\\t\\t\\tanswers = append(answers, -1)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thalfAnswer := firstValue + query - 1\\n\\t\\thalfAnswerString := strconv.Itoa(halfAnswer)\\n\\t\\tshift := 1\\n\\t\\tpairAnswer := 0\\n\\t\\tfor width := halfWidth; width < intLength; width++ {\\n\\t\\t\\tpairAnswer += shift * int(halfAnswerString[width-halfWidth]-\\'0\\')\\n\\t\\t\\tshift *= 10\\n\\t\\t}\\n        answers = append(answers, int64(halfAnswer*shift+pairAnswer))\\n\\t}\\n\\treturn answers\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n\\thalfWidth := intLength/2 + intLength%2\\n\\tfirstValue, maxValue := 1, 9\\n\\tfor i := 1; i < halfWidth; i++ {\\n\\t\\tfirstValue *= 10\\n\\t\\tmaxValue = maxValue*10 + 9\\n\\t}\\n\\tmaxQuery := maxValue - firstValue + 1\\n\\tanswers := make([]int64, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tif query > maxQuery {\\n\\t\\t\\tanswers = append(answers, -1)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thalfAnswer := firstValue + query - 1\\n\\t\\thalfAnswerString := strconv.Itoa(halfAnswer)\\n\\t\\tshift := 1\\n\\t\\tpairAnswer := 0\\n\\t\\tfor width := halfWidth; width < intLength; width++ {\\n\\t\\t\\tpairAnswer += shift * int(halfAnswerString[width-halfWidth]-\\'0\\')\\n\\t\\t\\tshift *= 10\\n\\t\\t}\\n        answers = append(answers, int64(halfAnswer*shift+pairAnswer))\\n\\t}\\n\\treturn answers\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898708,
                "title": "python-solution-beats-75",
                "content": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], inl: int) -> List[int]:\\n\\t\\t\\tres = []\\n\\t\\t\\tif inl == 1:\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tif i > 9:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tif inl % 2:\\n\\t\\t\\t\\tx = inl // 2\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tm = m[1:]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx = inl // 2 - 1\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], inl: int) -> List[int]:\\n\\t\\t\\tres = []\\n\\t\\t\\tif inl == 1:\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tif i > 9:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tif inl % 2:\\n\\t\\t\\t\\tx = inl // 2\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tm = m[1:]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx = inl // 2 - 1\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1897455,
                "title": "one-pass-98-speed",
                "content": "![image](https://assets.leetcode.com/users/images/8a4495ca-4645-4298-8116-5a5d3474ba51_1648642223.1228337.png)\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        half = intLength // 2\\n        odd = intLength % 2\\n        half += odd\\n        max_num = pow(10, half)\\n        base = max_num // 10 - 1\\n\\n        def query(i: int) -> int:\\n            n = base + i\\n            if n < max_num:\\n                s = str(n)\\n                s += s[::-1][odd::]\\n                return int(s)\\n            else:\\n                return -1\\n\\n        return [query(q) for q in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        half = intLength // 2\\n        odd = intLength % 2\\n        half += odd\\n        max_num = pow(10, half)\\n        base = max_num // 10 - 1\\n\\n        def query(i: int) -> int:\\n            n = base + i\\n            if n < max_num:\\n                s = str(n)\\n                s += s[::-1][odd::]\\n                return int(s)\\n            else:\\n                return -1\\n\\n        return [query(q) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896729,
                "title": "95-faster-easy-python3-solution-find-palindrome-with-fixed-length",
                "content": "# upvote if useful\\n![image](https://assets.leetcode.com/users/images/ece1fee8-e10c-40ec-b49f-74c5bcb685cb_1648623154.3350413.png)\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, q: List[int], l: int) -> List[int]:\\n        ans = []\\n        if l%2==0:\\n            x = (l//2)-1\\n        else:\\n            x = l//2\\n        #print(x)\\n        for i in q:\\n            a = str(10**x+i-1)\\n            b = a[::-1]\\n            if l%2==0:\\n                a = a+b\\n            else:\\n                a = a+b[1:]\\n            if len(a)==l:\\n                ans.append(a)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, q: List[int], l: int) -> List[int]:\\n        ans = []\\n        if l%2==0:\\n            x = (l//2)-1\\n        else:\\n            x = l//2\\n        #print(x)\\n        for i in q:\\n            a = str(10**x+i-1)\\n            b = a[::-1]\\n            if l%2==0:\\n                a = a+b\\n            else:\\n                a = a+b[1:]\\n            if len(a)==l:\\n                ans.append(a)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896517,
                "title": "python-easy-solution-time-o-n-fastest-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tpow = (intLength//2)-1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpow = intLength//2\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tans = str(10**pow + i-1)\\n\\t\\t\\t\\trev=ans[::-1]\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\tans+=rev\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans+=rev[1:]\\n\\t\\t\\t\\tif len(ans)==intLength:\\n\\t\\t\\t\\t\\tres.append(int(ans))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tpow = (intLength//2)-1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpow = intLength//2\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tans = str(10**pow + i-1)\\n\\t\\t\\t\\trev=ans[::-1]\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\tans+=rev\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans+=rev[1:]\\n\\t\\t\\t\\tif len(ans)==intLength:\\n\\t\\t\\t\\t\\tres.append(int(ans))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1895998,
                "title": "c-easy-to-understand-observational-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long hf;\\n    string getHalf(int q){\\n        int st=pow(10,hf-1);\\n        return to_string(st+q-1);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int mxl) {\\n        vector<long long> ans;\\n        hf=mxl/2+(mxl%2?1:0);\\n        for(auto&q:queries){\\n            string gh= getHalf(q);\\n            string oh=mxl%2?gh.substr(0,gh.size()-1):gh;\\n            reverse(oh.begin(),oh.end());\\n            gh+=oh;\\n            if(gh.size()==mxl)ans.push_back(stoll(gh));\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long hf;\\n    string getHalf(int q){\\n        int st=pow(10,hf-1);\\n        return to_string(st+q-1);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int mxl) {\\n        vector<long long> ans;\\n        hf=mxl/2+(mxl%2?1:0);\\n        for(auto&q:queries){\\n            string gh= getHalf(q);\\n            string oh=mxl%2?gh.substr(0,gh.size()-1):gh;\\n            reverse(oh.begin(),oh.end());\\n            gh+=oh;\\n            if(gh.size()==mxl)ans.push_back(stoll(gh));\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895534,
                "title": "observation-based-question-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        vector<long long> res;\\n        int pw = n % 2 == 0 ? (n/2 - 1) : (n/2);\\n        int st = pow(10,pw);\\n        \\n        for(auto q : queries){\\n            string ans = to_string(st + q - 1);\\n            string rev = ans;\\n            if(n % 2) rev.pop_back();\\n            reverse(rev.begin(),rev.end());\\n            ans += rev;\\n            if(ans.size() == n) res.push_back(stoll(ans));\\n            else res.push_back(-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        vector<long long> res;\\n        int pw = n % 2 == 0 ? (n/2 - 1) : (n/2);\\n        int st = pow(10,pw);\\n        \\n        for(auto q : queries){\\n            string ans = to_string(st + q - 1);\\n            string rev = ans;\\n            if(n % 2) rev.pop_back();\\n            reverse(rev.begin(),rev.end());\\n            ans += rev;\\n            if(ans.size() == n) res.push_back(stoll(ans));\\n            else res.push_back(-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894601,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> sol(n);\\n        int len = (intLength + 1) / 2;\\n        auto getLen = [] (long long v) {\\n            int len = 0;\\n            while (v > 0) {\\n                v /= 10;\\n                ++len;\\n            }\\n            return len;\\n        };\\n        auto getPal = [&] (long long v) {\\n            long long value = v;\\n            if (intLength & 1) {\\n                value /= 10;\\n            }\\n            while (value > 0) {\\n                int d = value % 10;\\n                v = v * 10 + d;\\n                value /= 10;\\n            }\\n            return v;\\n        };\\n        long long val = pow(10, len - 1);\\n        for (int i = 0; i < n; i++) {\\n            long long v = queries[i] - 1;\\n            long long val1 = val + v;\\n            if (getLen(val1) > len) {\\n                sol[i] = -1;\\n            }\\n            else {\\n                sol[i] = getPal(val1);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> sol(n);\\n        int len = (intLength + 1) / 2;\\n        auto getLen = [] (long long v) {\\n            int len = 0;\\n            while (v > 0) {\\n                v /= 10;\\n                ++len;\\n            }\\n            return len;\\n        };\\n        auto getPal = [&] (long long v) {\\n            long long value = v;\\n            if (intLength & 1) {\\n                value /= 10;\\n            }\\n            while (value > 0) {\\n                int d = value % 10;\\n                v = v * 10 + d;\\n                value /= 10;\\n            }\\n            return v;\\n        };\\n        long long val = pow(10, len - 1);\\n        for (int i = 0; i < n; i++) {\\n            long long v = queries[i] - 1;\\n            long long val1 = val + v;\\n            if (getLen(val1) > len) {\\n                sol[i] = -1;\\n            }\\n            else {\\n                sol[i] = getPal(val1);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894170,
                "title": "golang",
                "content": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    base := 1\\n    for i := 0; i < (intLength - 1) / 2; i++ {\\n        base *= 10\\n    }\\n    \\n    res := make([]int64, len(queries))\\n    \\n    for i, q := range queries {\\n        if q - 1 >= 9 * base {\\n            res[i] = -1\\n            continue\\n        }\\n        a := base - 1 + q             \\n        b := a\\n        if intLength % 2 == 1 {\\n            b /= 10\\n        }\\n        for b > 0 {\\n            a = a * 10 + b % 10\\n            b /= 10\\n        }\\n        res[i] = int64(a)\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    base := 1\\n    for i := 0; i < (intLength - 1) / 2; i++ {\\n        base *= 10\\n    }\\n    \\n    res := make([]int64, len(queries))\\n    \\n    for i, q := range queries {\\n        if q - 1 >= 9 * base {\\n            res[i] = -1\\n            continue\\n        }\\n        a := base - 1 + q             \\n        b := a\\n        if intLength % 2 == 1 {\\n            b /= 10\\n        }\\n        for b > 0 {\\n            a = a * 10 + b % 10\\n            b /= 10\\n        }\\n        res[i] = int64(a)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894091,
                "title": "python-two-similar-solutions",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        odd = intLength&1\\n        h = intLength//2 + odd\\n        x = 10**(h - 1)\\n        return [int(n+n[~odd::-1]) if len(n := str(x+q-1)) <= h else -1 for q in queries]\\n        # return [int((n := str(y))+n[~odd::-1]) if (y := x+q-1) < 10*x else -1 for q in queries]\\n```\\n\\nIn the first one we check the length of the string, in the second one we check that the number does not exceed a certain threshold (should be a bit faster, I think).\\n\\n`~odd` is an odd way to write `-1 - odd`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        odd = intLength&1\\n        h = intLength//2 + odd\\n        x = 10**(h - 1)\\n        return [int(n+n[~odd::-1]) if len(n := str(x+q-1)) <= h else -1 for q in queries]\\n        # return [int((n := str(y))+n[~odd::-1]) if (y := x+q-1) < 10*x else -1 for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893895,
                "title": "recursively-obtaining-palindrome-python",
                "content": "##### How to obtain the palindrome:\\nWe need to figure out a pattern to relaiably obtain the correct palindrome given the intlength and query number. Let\\'s see how bigger palindromes are related to the smaller palindromes. \\n\\nFor example, using intLength 3, the first 11 palindromes are 101, 111, 121... 191, 202. Notice that after 10 iterations, the outer number increases. For a palindrome of intLength 1, there are 9 palindromes (1-9), with 0 being excluded. \\n\\nFrom this example, we can see that each outer most number can contain 10 smaller palindromes  inside it (0 is included as long as it is not the outer most number). And we can deduce that the largest palindrome for intLength 3 is 999 with a query number of 90 (the example was kind enough to give this clue). \\n\\nFrom this observation, we can conclude a couple things:\\n* The relationship between large palindromes and small palindrome\\n* The max Query number given the intLength (1:9, 2:9, 3:90, 4:90, 5:900...) \\n\\nUsing these observations, we can get the outer most palindrome number by dividing a base number which changes based on the current intLength. \\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        def helper(num, length, pos):\\n            if length == 0:\\n                # base case\\n                return 0\\n            elif length == 1:\\n                # base case\\n                return num*(10**pos)\\n            else:\\n\\t\\t\\t\\t# (length-1//2) because we want to get the correct base number\\n\\t\\t\\t\\t# length = 1,2 we want base number 1\\n\\t\\t\\t\\t# length = 3,4 we want base number 10 and so on\\n                base = 10**(max(0,(length-1)//2))\\n                n, newNum = divmod(num,base)\\n            if intLength == length:\\n                # n+1 because in order to form a valid palindrome, our outer numbers needs to\\n                # be from 1-9, 10 is not possible since we ruled them out in the beginning (max_base)\\n                return (n+1)*(10**(length-1)) + (n+1) + helper(newNum, length-2, pos+1)\\n            else:\\n                return n*(10**(length-1+pos)) + n*(10**pos) + helper(newNum, length-2, pos+1)\\n                \\n        ans = []\\n        # if query number exceeds max_base, this means it is not possible to form a palidnrome\\n        max_base = int(10**((max(0,intLength-1)//2)) * 9) \\n        if intLength == 1:\\n            # handles special case, not sure how to handle every case in the helper function without making it ugly\\n            return [x if x < 10 else -1 for x in queries]\\n        for n in queries:\\n            if n > max_base:\\n                ans.append(-1)\\n            else:\\n                # queries number starts from 0 instead of 1 (n-1)\\n                res = helper(n-1, intLength, 0)\\n                ans.append(res)\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        def helper(num, length, pos):\\n            if length == 0:\\n                # base case\\n                return 0\\n            elif length == 1:\\n                # base case\\n                return num*(10**pos)\\n            else:\\n\\t\\t\\t\\t# (length-1//2) because we want to get the correct base number\\n\\t\\t\\t\\t# length = 1,2 we want base number 1\\n\\t\\t\\t\\t# length = 3,4 we want base number 10 and so on\\n                base = 10**(max(0,(length-1)//2))\\n                n, newNum = divmod(num,base)\\n            if intLength == length:\\n                # n+1 because in order to form a valid palindrome, our outer numbers needs to\\n                # be from 1-9, 10 is not possible since we ruled them out in the beginning (max_base)\\n                return (n+1)*(10**(length-1)) + (n+1) + helper(newNum, length-2, pos+1)\\n            else:\\n                return n*(10**(length-1+pos)) + n*(10**pos) + helper(newNum, length-2, pos+1)\\n                \\n        ans = []\\n        # if query number exceeds max_base, this means it is not possible to form a palidnrome\\n        max_base = int(10**((max(0,intLength-1)//2)) * 9) \\n        if intLength == 1:\\n            # handles special case, not sure how to handle every case in the helper function without making it ugly\\n            return [x if x < 10 else -1 for x in queries]\\n        for n in queries:\\n            if n > max_base:\\n                ans.append(-1)\\n            else:\\n                # queries number starts from 0 instead of 1 (n-1)\\n                res = helper(n-1, intLength, 0)\\n                ans.append(res)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893534,
                "title": "rust-iter-rev-collect-o-n",
                "content": "```\\nimpl Solution {\\n    pub fn kth_palindrome(queries: Vec<i32>, int_length: i32) -> Vec<i64> {\\n        let mut res = vec![];\\n        let p_len = int_length;\\n        let mut is_odd = true;\\n        if p_len % 2 == 0 {\\n            is_odd = false;\\n        }\\n        let half = if is_odd {\\n            p_len / 2 + 1\\n        } else {\\n            p_len / 2\\n        };\\n        let half = half as u32;\\n        let start = 10_i32.pow(half - 1);\\n        let end = start * 10;\\n        \\n        for q in queries {\\n            if q > end - start {\\n                res.push(-1);\\n                continue\\n            }\\n            let pal = start + q - 1;\\n            // println!(\"pal is {:?}\", pal);\\n            let mut cs: Vec<char> = pal.to_string().chars().collect();\\n            if is_odd {\\n                cs.pop();\\n            }\\n            let last_half: String = cs.iter().rev().collect();\\n            // println!(\"es is {:?}\", es);\\n            let mut curr = pal.to_string();\\n            curr.push_str(&last_half[..]);\\n            // println!(\"curr is {:?}\", curr);\\n            let curr:i64 = curr.parse().map_or(0, |v| v);\\n            // println!(\"curr is {:?}\", curr);\\n            res.push(curr);\\n        }\\n        \\n        res\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn kth_palindrome(queries: Vec<i32>, int_length: i32) -> Vec<i64> {\\n        let mut res = vec![];\\n        let p_len = int_length;\\n        let mut is_odd = true;\\n        if p_len % 2 == 0 {\\n            is_odd = false;\\n        }\\n        let half = if is_odd {\\n            p_len / 2 + 1\\n        } else {\\n            p_len / 2\\n        };\\n        let half = half as u32;\\n        let start = 10_i32.pow(half - 1);\\n        let end = start * 10;\\n        \\n        for q in queries {\\n            if q > end - start {\\n                res.push(-1);\\n                continue\\n            }\\n            let pal = start + q - 1;\\n            // println!(\"pal is {:?}\", pal);\\n            let mut cs: Vec<char> = pal.to_string().chars().collect();\\n            if is_odd {\\n                cs.pop();\\n            }\\n            let last_half: String = cs.iter().rev().collect();\\n            // println!(\"es is {:?}\", es);\\n            let mut curr = pal.to_string();\\n            curr.push_str(&last_half[..]);\\n            // println!(\"curr is {:?}\", curr);\\n            let curr:i64 = curr.parse().map_or(0, |v| v);\\n            // println!(\"curr is {:?}\", curr);\\n            res.push(curr);\\n        }\\n        \\n        res\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893181,
                "title": "python-easy-to-understand-solution-with-simple-explanation-faster-than-90",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        n = intLength//2\\n        if(intLength%2==0):\\n            ## even length (2n)  n>=1\\n            ##          - only need to consider left half, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**(n-1) (first digit (0,9], remaining n-1 digits [0,9] ))\\n            ##                  => smallest 1*10**(n-1) (first digit=1, remaining n-1 digits = 0)\\n            total_palindrome = 9*(10**(n-1))\\n            first_smallest = 1*(10**(n-1))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**n)+self.flip(kth_smallest))\\n        else:\\n            ## odd length (2n+1)  n>=0\\n            ##          - only need to consider left half and middle one, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**n (first digit (0,9], remaining n digits [0,9] ))\\n            ##                  => smallest 1*10**n (first digit=1, remaining n digits = 0)\\n            total_palindrome = 9*(10**(n))\\n            first_smallest = 1*(10**(n))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**(n))+self.flip(kth_smallest//10))\\n        return res\\n    \\n    def flip(self, number):\\n        return int(str(number)[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        n = intLength//2\\n        if(intLength%2==0):\\n            ## even length (2n)  n>=1\\n            ##          - only need to consider left half, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**(n-1) (first digit (0,9], remaining n-1 digits [0,9] ))\\n            ##                  => smallest 1*10**(n-1) (first digit=1, remaining n-1 digits = 0)\\n            total_palindrome = 9*(10**(n-1))\\n            first_smallest = 1*(10**(n-1))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**n)+self.flip(kth_smallest))\\n        else:\\n            ## odd length (2n+1)  n>=0\\n            ##          - only need to consider left half and middle one, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**n (first digit (0,9], remaining n digits [0,9] ))\\n            ##                  => smallest 1*10**n (first digit=1, remaining n digits = 0)\\n            total_palindrome = 9*(10**(n))\\n            first_smallest = 1*(10**(n))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**(n))+self.flip(kth_smallest//10))\\n        return res\\n    \\n    def flip(self, number):\\n        return int(str(number)[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892003,
                "title": "c-sol-for-those-who-couldn-t-find-the-formula",
                "content": "Remember t = queries[x] - 1.\\nRest of the code is simple brute.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        int q = queries.size();\\n        int k = n/2 + n%2;\\n        vector<long long> res(q);\\n        for(int x = 0; x < q; x++)\\n        {\\n            int t = queries[x]-1;\\n            vector<int> temp(k, 0);\\n            for(int y = 0; y < k && t; y++)\\n            {\\n                int i = t%10;\\n                temp[y] = i;\\n                t = t/10;\\n            }\\n            if(t || temp[k-1] == 9)\\n            {\\n                res[x] = -1;\\n                continue;\\n            }\\n            temp[k-1]++;\\n            string s = \"\";\\n            for(int y = 0; y < k; y++)\\n                s += to_string(temp[y]);\\n            string tt = s;\\n            if(n%2)\\n                tt.erase(tt.begin());\\n            reverse(s.begin(), s.end());\\n            s = s + tt;\\n            res[x] = stoll(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        int q = queries.size();\\n        int k = n/2 + n%2;\\n        vector<long long> res(q);\\n        for(int x = 0; x < q; x++)\\n        {\\n            int t = queries[x]-1;\\n            vector<int> temp(k, 0);\\n            for(int y = 0; y < k && t; y++)\\n            {\\n                int i = t%10;\\n                temp[y] = i;\\n                t = t/10;\\n            }\\n            if(t || temp[k-1] == 9)\\n            {\\n                res[x] = -1;\\n                continue;\\n            }\\n            temp[k-1]++;\\n            string s = \"\";\\n            for(int y = 0; y < k; y++)\\n                s += to_string(temp[y]);\\n            string tt = s;\\n            if(n%2)\\n                tt.erase(tt.begin());\\n            reverse(s.begin(), s.end());\\n            s = s + tt;\\n            res[x] = stoll(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891773,
                "title": "c-faster-than-100-memory-less-than-100-simple",
                "content": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        \\n        int a = pow(10,l/2);\\n        if(l%2==0)\\n            a = pow(10,(l/2)-1);\\n        \\n        int last=9;\\n        if(l%2==0)\\n            last = 0;\\n        \\n        for(int i=1;i<=l/2;i++)\\n            last = last*10 + 9;\\n        \\n        vector<long long> v;\\n        \\n        for(auto n : q)\\n            if(last-a+1 < n){\\n                v.push_back(-1);\\n            }\\n            else{\\n                long long ans = a-1 + n;\\n                int temp = ans;\\n                if(l%2==1)\\n                    temp/=10;\\n                \\n                while(temp){\\n                    ans = ans*10 + temp%10;\\n                    temp/=10;\\n                }\\n                v.push_back(ans);\\n            }\\n        \\n        return v;\\n    }\\n};\\n\\nHit like if found helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        \\n        int a = pow(10,l/2);\\n        if(l%2==0)\\n            a = pow(10,(l/2)-1);\\n        \\n        int last=9;\\n        if(l%2==0)\\n            last = 0;\\n        \\n        for(int i=1;i<=l/2;i++)\\n            last = last*10 + 9;\\n        \\n        vector<long long> v;\\n        \\n        for(auto n : q)\\n            if(last-a+1 < n){\\n                v.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1891734,
                "title": "python-easy-solution-with-explanation",
                "content": "There\\'s a pattern, so the idea is to find the starting number for the first half.\\nThe starting number can be:\\n```\\n0\\n1\\n10\\n100\\n1000\\n......\\n```\\n`10 ** ((intLength + odd) // 2 - 1)`\\nOnce you find it, except for the edge case when it\\'s 0, everything else is easy.\\n```python\\n        odd = intLength % 2 != 0\\n        startNum = 10 ** ((intLength + odd) // 2 - 1)\\n        res = []\\n        \\n        for n in queries:\\n            currNum = str(startNum + n - 1)\\n            currNum = currNum + currNum[::-1][odd:]\\n            if startNum == 0: currNum += 1\\n            if len(currNum) > intLength: res.append(-1)\\n            else: res.append(int(currNum))\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n0\\n1\\n10\\n100\\n1000\\n......\\n```\n```python\\n        odd = intLength % 2 != 0\\n        startNum = 10 ** ((intLength + odd) // 2 - 1)\\n        res = []\\n        \\n        for n in queries:\\n            currNum = str(startNum + n - 1)\\n            currNum = currNum + currNum[::-1][odd:]\\n            if startNum == 0: currNum += 1\\n            if len(currNum) > intLength: res.append(-1)\\n            else: res.append(int(currNum))\\n            \\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891710,
                "title": "ruby",
                "content": "```\\n# @param {Integer[]} queries\\n# @param {Integer} int_length\\n# @return {Integer[]}\\ndef kth_palindrome(queries, int_length)\\n   res = []\\n   queries.each do |elem|\\n     res << pdm(elem, int_length)\\n   end\\n   res\\nend\\n\\ndef pdm(position, length)\\n    if length == 1\\n        return -1 if position.to_s.length > length\\n        (position.to_s == position.to_s.reverse) ? position : -1\\n    elsif length == 2\\n        num = position*11\\n        return -1 if num.to_s.length > length\\n        (num.to_s == num.to_s.reverse) ? num : -1\\n    elsif length % 2 == 0\\n        fp = 10**((length/2)-1) + (position-1)\\n        lp = fp.to_s.reverse\\n        p = (fp.to_s + lp)\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    else\\n        fp = 10**(length/2) + (position-1)\\n        lp = fp.to_s.reverse[1..-1]\\n        p = fp.to_s+lp\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} queries\\n# @param {Integer} int_length\\n# @return {Integer[]}\\ndef kth_palindrome(queries, int_length)\\n   res = []\\n   queries.each do |elem|\\n     res << pdm(elem, int_length)\\n   end\\n   res\\nend\\n\\ndef pdm(position, length)\\n    if length == 1\\n        return -1 if position.to_s.length > length\\n        (position.to_s == position.to_s.reverse) ? position : -1\\n    elsif length == 2\\n        num = position*11\\n        return -1 if num.to_s.length > length\\n        (num.to_s == num.to_s.reverse) ? num : -1\\n    elsif length % 2 == 0\\n        fp = 10**((length/2)-1) + (position-1)\\n        lp = fp.to_s.reverse\\n        p = (fp.to_s + lp)\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    else\\n        fp = 10**(length/2) + (position-1)\\n        lp = fp.to_s.reverse[1..-1]\\n        p = fp.to_s+lp\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1891421,
                "title": "javascript-solution",
                "content": "```\\nvar kthPalindrome = function(queries, intLength) {\\n         let count = Math.floor((intLength+1)/2);\\n        let start = Math.pow(10,count-1);\\n        let ans =[];\\n        for(let i=0;i<queries.length;i++) {\\n            let q = queries[i];\\n            let half = start+q-1;\\n                let rev = half.toString().split(\"\").reverse().join(\"\");\\n            if(intLength%2==0){\\n                let num = (half+rev);\\n                if(num.length == intLength){\\n                 ans.push(Number(num));\\n                } else {\\n                 ans.push(-1);\\n                }\\n            } else {\\n                let num = ((half+rev.slice(1)));\\n                if(num.length == intLength){\\n                     ans.push(Number(num));\\n                }  else {\\n                 ans.push(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar kthPalindrome = function(queries, intLength) {\\n         let count = Math.floor((intLength+1)/2);\\n        let start = Math.pow(10,count-1);\\n        let ans =[];\\n        for(let i=0;i<queries.length;i++) {\\n            let q = queries[i];\\n            let half = start+q-1;\\n                let rev = half.toString().split(\"\").reverse().join(\"\");\\n            if(intLength%2==0){\\n                let num = (half+rev);\\n                if(num.length == intLength){\\n                 ans.push(Number(num));\\n                } else {\\n                 ans.push(-1);\\n                }\\n            } else {\\n                let num = ((half+rev.slice(1)));\\n                if(num.length == intLength){\\n                     ans.push(Number(num));\\n                }  else {\\n                 ans.push(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891413,
                "title": "my-java-solution-by-observing-the-1-2-3-4-10-11-12-13-100-101-102-pattern",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        // 11 22 33 44 55\\n        // 101 111 121 131 141\\n        // 1001 1111 1221 1331 1441\\n        // 10001 10101 10201 ....... we can observe the pattern that its liek 1, 2, 3, 4 or 10, 11, 12, 13 or 100, 101, 102 etc\\n        List<String> store = new ArrayList<>();\\n        int powerFactor = 0;\\n        boolean isEven = false;\\n        if (intLength % 2 == 0) {\\n            powerFactor = (int)(Math.pow(10, (intLength / 2) - 1));\\n            isEven = true;\\n        }\\n        else {\\n            powerFactor = (int)(Math.pow(10, intLength / 2));\\n        }\\n        for (int query : queries) {\\n            StringBuilder sb = new StringBuilder();\\n            int kthPalindromeStart = powerFactor + query - 1;\\n            sb.append(kthPalindromeStart);\\n            String normal = sb.toString();\\n            String reversed = sb.reverse().toString();\\n            sb = new StringBuilder();\\n            if (isEven) {\\n                // 100 -> we reverse fully to get 001 and append both to get 100001\\n                sb.append(normal).append(reversed);\\n            }\\n            else {\\n                //100 -> we reverse the first 2 letters to get 01 and append both to get 10001\\n                sb.append(normal).append(reversed.substring(1));\\n            }\\n            if (sb.length() == intLength)\\n                store.add(sb.toString());\\n            else\\n                store.add(\"-1\");\\n        }\\n        //System.out.println\\n        long [] result = new long [store.size()];\\n        int index = 0;\\n        for (String value : store) {\\n            result[index++] = Long.valueOf(value);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        // 11 22 33 44 55\\n        // 101 111 121 131 141\\n        // 1001 1111 1221 1331 1441\\n        // 10001 10101 10201 ....... we can observe the pattern that its liek 1, 2, 3, 4 or 10, 11, 12, 13 or 100, 101, 102 etc\\n        List<String> store = new ArrayList<>();\\n        int powerFactor = 0;\\n        boolean isEven = false;\\n        if (intLength % 2 == 0) {\\n            powerFactor = (int)(Math.pow(10, (intLength / 2) - 1));\\n            isEven = true;\\n        }\\n        else {\\n            powerFactor = (int)(Math.pow(10, intLength / 2));\\n        }\\n        for (int query : queries) {\\n            StringBuilder sb = new StringBuilder();\\n            int kthPalindromeStart = powerFactor + query - 1;\\n            sb.append(kthPalindromeStart);\\n            String normal = sb.toString();\\n            String reversed = sb.reverse().toString();\\n            sb = new StringBuilder();\\n            if (isEven) {\\n                // 100 -> we reverse fully to get 001 and append both to get 100001\\n                sb.append(normal).append(reversed);\\n            }\\n            else {\\n                //100 -> we reverse the first 2 letters to get 01 and append both to get 10001\\n                sb.append(normal).append(reversed.substring(1));\\n            }\\n            if (sb.length() == intLength)\\n                store.add(sb.toString());\\n            else\\n                store.add(\"-1\");\\n        }\\n        //System.out.println\\n        long [] result = new long [store.size()];\\n        int index = 0;\\n        for (String value : store) {\\n            result[index++] = Long.valueOf(value);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891407,
                "title": "java-solution-100-time-space-complexity-simple-reverse",
                "content": "\\tclass Solution {\\n\\t\\tpublic long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\t\\tlong[] result = new long[queries.length];\\n\\n\\t\\t\\tlong start = (long)Math.pow(10, (intLength + 1)/2 - 1);\\n\\t\\t\\tlong end = (long)Math.pow(10, (intLength + 1)/2);\\n\\n\\t\\t\\tboolean even = (intLength % 2 == 0);\\n\\t\\t\\tfor (int i = 0; i < queries.length; i++)\\n\\t\\t\\t\\tif (start + queries[i] > end)\\n\\t\\t\\t\\t\\tresult[i] = -1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[i] = computeNumber(start + queries[i] - 1, even);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic long computeNumber(long num, boolean check) {\\n\\t\\t\\tlong result = num;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tif (!check)\\n\\t\\t\\t\\tnum /= 10;\\n\\n\\t\\t\\tlong reversed = 0;\\n\\t\\t\\tfor (; num != 0; num /= 10) {\\n\\t\\t\\t\\treversed = reversed * 10 + num % 10;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (long)(result * Math.pow(10, count)) + reversed;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\t\\tlong[] result = new long[queries.length];\\n\\n\\t\\t\\tlong start = (long)Math.pow(10, (intLength + 1)/2 - 1);\\n\\t\\t\\tlong end = (long)Math.pow(10, (intLength + 1)/2);\\n\\n\\t\\t\\tboolean even = (intLength % 2 == 0);\\n\\t\\t\\tfor (int i = 0; i < queries.length; i++)\\n\\t\\t\\t\\tif (start + queries[i] > end)\\n\\t\\t\\t\\t\\tresult[i] = -1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[i] = computeNumber(start + queries[i] - 1, even);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1750340,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576553,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1832575,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1759419,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2033331,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1997398,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1718627,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            }
        ]
    }
]