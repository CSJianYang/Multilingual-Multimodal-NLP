[
    {
        "title": "Binary Gap",
        "question_content": "Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\nTwo 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n&nbsp;\nExample 1:\n\nInput: n = 22\nOutput: 2\nExplanation: 22 in binary is \"10110\".\nThe first adjacent pair of 1's is \"10110\" with a distance of 2.\nThe second adjacent pair of 1's is \"10110\" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n\nExample 2:\n\nInput: n = 8\nOutput: 0\nExplanation: 8 in binary is \"1000\".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\nExample 3:\n\nInput: n = 5\nOutput: 2\nExplanation: 5 in binary is \"101\".\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 109",
        "solutions": [
            {
                "id": 149835,
                "title": "c-java-python-dividing-by-2",
                "content": "One pass on `N` in binary from right to left.\\n`d` means the distance from the last 1 position.\\n`d` is initial to a small enough value `-32`\\n\\n**C++:**\\n```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149945,
                "title": "simple-java-10-ms",
                "content": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149834,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358693,
                "title": "868-javascript-1-line-solution",
                "content": "> Runtime: **48 ms**, faster than *95.29%* of JavaScript online submissions\\n> Memory Usage: **33.9 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151143,
                "title": "python-1-line-solution",
                "content": "If only one \\'1\\' exists in the binary, the number must be 2^N where N is a natural number and we return 0. Otherwise, given the binary, we strip \\'0\\' from both sides and split the string into sections by \\'1\\', and return the max length of consecutive \\'0\\'s plus 1.\\n```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382476,
                "title": "c-0-ms-simple-o-32",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613498,
                "title": "java-solution-100-with-explanation",
                "content": "The answer key to this problem uses bitwise from the start -- which is not where my mind immediately went; nor did my mind think to use linear space in the naive implementation (since we only care about space between consecutive 1\\'s). Hopefully this solution will help you think through the problem logically.\\n\\nThe first time I did the problem, I came up with a linear time solution that used linear space.\\n\\nRuntime: 1 ms, faster than 42.91% of Java online submissions for Binary Gap.\\nMemory Usage: 36 MB, less than 7.14% of Java online submissions for Binary Gap.\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\\n\\nI then realized this can be done faster since numbers are already stored as their binary representations. We can use bitwise operators, specifically, the bitwise right shift operator. All this means is take the rightmost bit off the binary representation during each iteration. This results in a solution with logarithmic time and constant space.\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Binary Gap.\\nMemory Usage: 36.1 MB, less than 7.14% of Java online submissions for Binary Gap.\\n\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519571,
                "title": "simple-python-solution-o-log-n-t-o-log-n-s-explanation",
                "content": "We first convert the number to binary and then find the 1\\'s in the binary representation. We store the location of adjacent 1\\'s in the variables i and j. The maximum difference between these successive 1\\'s is the answer. \\nA number \\'n\\' has (log n) bits, hence the time complexity is log(n) and since we are storing these bits as a string, the space complexity is also log(n).\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380567,
                "title": "easy-c-solution-0ms-bit-manipulation",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n\\n```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321031,
                "title": "intuitive-java-solution-with-explanation",
                "content": "We will first convert `n` into a character array which represents the binary string of `n`. We will then iterate over this array and store the indices of where a 1 occurs in this character array. If there was only one 1 in the binary string representation of `n` then we return 0 as the problem statement says. We then iterate over `indices` and calculate the distance of a 1 with its adjacent neighbor and update `ans` accordingly.\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481624,
                "title": "easy-solution-finding-the-total-number-of-set-bits",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}\\n\\t\\t\\tif(aux.size()==1)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint m = INT_MIN;\\n\\t\\t\\tfor(int x=1;x<aux.size();x++){\\n\\t\\t\\t\\tm = max(m,(aux[x]-aux[x-1]));\\n        }\\n\\t\\t\\treturn m;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1129220,
                "title": "java-0ms",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508760,
                "title": "python3-beats-96-time-100-memory",
                "content": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2913701,
                "title": "java-1-ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308293,
                "title": "0ms-easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968113,
                "title": "c-faster-than-100-0ms-bit-manipulation-diagrammatic-representation",
                "content": "***Diagrammatic representation***\\n![image](https://assets.leetcode.com/users/images/64c84117-88d6-47e0-8f70-0a208378086d_1650504132.5012343.png)\\n![image](https://assets.leetcode.com/users/images/5759fe91-4034-47a8-8a60-c72533f6bd23_1650504170.695796.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697161,
                "title": "simple-javascript-solution",
                "content": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365234,
                "title": "c-std-bitset-0-ms-8-3-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316060,
                "title": "c-beats-100-time-and-92-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152701,
                "title": "easy-understand-java-solution",
                "content": "```\\n\\n```public int binaryGap(int N) {\\n        int max = 0;\\n        int d = -32;\\n        while(N > 0){\\n            if(N % 2 == 1){\\n                max = Math.max(max, d);\\n                d = 0;\\n            }\\n            N /= 2;\\n            d++;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816558,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677249,
                "title": "java-simple-solution",
                "content": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2485217,
                "title": "c-faster-than-100-setbits",
                "content": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }\\n            else if((n&1)==1&&one==0){\\n                one=1;\\n            }\\n            if(one==1)\\n            count++;   \\n            n>>=1;\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1582979,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364757,
                "title": "golang-bitwise-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306246,
                "title": "easy-python-solution-100",
                "content": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 157931,
                "title": "0ms-commented-golang",
                "content": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992567,
                "title": "solution",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555976,
                "title": "868-binary-gap",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499368,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464142,
                "title": "beats-100-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3457342,
                "title": "easiest-solution-bit-manipulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409133,
                "title": "very-understandable-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303808,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181929,
                "title": "beats-98-easy-solution-please-upvote",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176459,
                "title": "easy-solution-using-bin-function",
                "content": "\\n\\n# Approach\\nFirst of all ,We have to convert the given integer into its equivalent binary string. Then we will store all the indexes of \"1\" in an array.\\nThen we will calculate the difference between adjacent elements. After calculating the differences we will return the maximum difference ..\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113966,
                "title": "python3-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816573,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790637,
                "title": "python-simple-solution-ii-o-n-one-pass",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687088,
                "title": "c-0ms-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565781,
                "title": "js-easy-solution-100-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/475ee9ed-ee46-4a6a-a0f9-f5783f5b13de_1662972381.4477122.png)\\n\\n```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437228,
                "title": "my-kotlin-solution-with-time-o-1-and-space-o-1",
                "content": "Below is my solution in kotlin, it preprocess the n with it right most bit and calculate the gap through shift right.\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430116,
                "title": "binary-gap-c-5ms",
                "content": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }\\n            x > 0? x++: x = 0;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2145256,
                "title": "c-fast-easy-code-bit-manipulation",
                "content": "Check each bit from the back and if it\\'s \\'1\\', we calculate the distance using the difference between the current index and the previous index that points to the previous \\'1\\' found. Compare the value with the current max distance and store the larger value back. There\\'s no previous index for the first \\'1\\' so we simply set previous index to the current index.\\n\\n**Code:**\\n```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091944,
                "title": "java-simple-solution",
                "content": "Here is a simple approach to solve this question.\\nWhat we are doing here is\\ni) if(n&1) is equal to 1 then find next 1\\n\\t\\t........**(subcondition)**.........if(n==0) then it means next 1 not found else 1 is found so set the value of max\\nii) else right shift.\\n\\n```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1984287,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "codeTag": "Python3"
            },
            {
                "id": 1919356,
                "title": "fast-solution-in-python3",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859275,
                "title": "100-time-o-logn-easy-to-understand",
                "content": "**here we are using  differnt function of bit to solve question**\\n***be noted why we initialize count to -32 i wrote it in comment in code***\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n***this is my solution if yu have any doubt than fill free to ask in comment if i can than absolutly solve it***\\n***if you find solution use ful than upwote else downvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794889,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736152,
                "title": "javascript-solution-using-bit-manipulation",
                "content": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "solutionTags": [],
                "code": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1722203,
                "title": "using-format-for-binary-string",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519288,
                "title": "fastest-100-passed-c-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467446,
                "title": "simple-c-o-log-n-constant-space",
                "content": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1410829,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }\\n            else if(p.charAt(i)==\\'1\\')\\n            {\\n                j=i;\\n                c++;\\n            }\\n        }\\n        return k;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1405152,
                "title": "fast-c-solution-o-1-space-0-ms-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362260,
                "title": "o-n-0ms-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337314,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263330,
                "title": "c-simple-solution-0ms",
                "content": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200055,
                "title": "hashing-steps-explanation-0ms-c",
                "content": "**STEPS:-**\\n**1) convert the number in binary format and store it in a string (LSB at 0 index)**\\n**2) declare a  map( key = char, value = int) and define an int dist = 0**\\n**3) then just iterate over the string, if map does not contain key = \\'1\\' , then just insert it with value = index**\\n**4) if key = \\'1\\', already present then simply update the dist as max(dist,abs(map[\\'1\\']-index))**\\n**5) return the dist**\\n**NOTE: Why its working ??, you got it by now :)**\\n```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156816,
                "title": "super-simple-and-easy-cpp-solution-must-check",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }\\n            else if(flag)\\n                dis++;\\n            n = n>>1;    \\n        }\\n        return maxi;\\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1081801,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030187,
                "title": "python-solution",
                "content": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "solutionTags": [],
                "code": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1020460,
                "title": "python-bitwise-95-faster",
                "content": "Every odd value will have a 1 on the right hand side of the binary digit (because this is the ones digit and all factors of 2 are even except 2 raised to the 0 power).  We can then bitwise right shift by 1 (i.e. integer division by 2, effectively dropping the right digit) to \\'traverse\\' across the binary and count the times until we obtain another odd (1) value.\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017556,
                "title": "clean-js-solution",
                "content": "Remove the first \\'1\\' in the binary, then loop through the string. If we hit a \\'1\\', record the gap and compare it to the max gap then reset the gap to 0.\\n```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989270,
                "title": "simple-java-solution-1-ms-with-explanation",
                "content": "- Intially store the first occur \\'1\\'\\n- Next if the current value is \\'1\\' then minu the previous value with current index and change the previous value\\n\\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982479,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964373,
                "title": "ugly-code-but-one-pass-without-casting-to-string",
                "content": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929372,
                "title": "3-solutions",
                "content": "**two indices**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\\n**distance**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\\n\\n**`builtin_ctz` \\u2014 `gcc` builtin function that counts the number of trailing zeroes**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\\nor\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```\\n\\nHere https://leetcode.com/problems/get-maximum-in-generated-array/discuss/930626/elegant-o1-space you can  different recipes on how to write `__builtin_ctz` function yourself.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806074,
                "title": "faster-than-100-c-online-submisssion",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798058,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730010,
                "title": "python3-easy-soln",
                "content": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 696308,
                "title": "java-simple-neat-solution-with-two-pointers-beat-100",
                "content": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "solutionTags": [],
                "code": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 654605,
                "title": "simple-c-solution-o-n-easy-to-understand-with-explain",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 5.9 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n**The problem is that find longest distance between two 1\\'s such that between them all the characters are 0;\\ne.g; 110000110 ans=5\\n11101 ans=2\\n100000001 ans=8\\n1001000100001 ans=5**\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645879,
                "title": "o-log-binary-n-time-o-log-binary-n-space-java-solution",
                "content": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 639188,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        } \\n       \\n         int k=i-1;\\n         int d=0;\\n        int b=0;\\n        int c=0;\\n        int co=0;\\n        int max=0;\\n        for (int j = i - 1; j >= 0; j--) \\n        {\\n            if(a[j]==1 && co==0)\\n            {\\n                b=j;\\n                co++;\\n            }\\n            else\\n                if(a[j]==1)\\n                {\\n                  int t=b;\\n                    c=j;\\n                    d=t-c;\\n                    max=(max>=d)?max:d;\\n                    \\n                    b=c;                    \\n                }\\n                  \\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 628726,
                "title": "0ms-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }\\n        int mx = 0;\\n        for(int i=1;i<pos.size();i++)\\n        {\\n            mx = max(mx,pos[i]-pos[i-1]);\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 608977,
                "title": "go-solution-clean-and-fast-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2.1 MB, less than 100.00% of Go online submissions for Binary Gap.\\n```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578704,
                "title": "java-solution-use-bit-operation",
                "content": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537449,
                "title": "c-simple-solution-beats-100-100-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528358,
                "title": "c-100-space-100-time-solution-o-log-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515335,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410886,
                "title": "c-0ms-solution-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402093,
                "title": "java-0ms-100",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377082,
                "title": "simple-solution-using-bit-manipulation-java-0ms",
                "content": "Used a very simple concept of Bitwise AND (&) to check the last bit and Right shift (>>).\\n\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }\\n                index = i;\\n            }\\n            \\n            N = N >> 1;\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 360221,
                "title": "go-golang-0ms-clean-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Binary Gap.\\n\\n```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 297792,
                "title": "simple-python-solution-faster-than-94-64-and-less-than-83-31-of-python3",
                "content": "it\\'s pretty simple solution and easy to understand \\n\\n```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 293442,
                "title": "o-log-log-n",
                "content": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286322,
                "title": "python-split-bin-n-by-1",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260480,
                "title": "functional-js-solution-faster-than-90",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 160233,
                "title": "fast-swift-solution",
                "content": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158803,
                "title": "c-solution-using-while-loop",
                "content": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151314,
                "title": "simple-java-solution",
                "content": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150926,
                "title": "c-average-case-faster-than-simple-right-shifting-0-ms",
                "content": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150846,
                "title": "python-solution-using-3-if-statements-and-a-counter",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 149904,
                "title": "c-like-languages-o-1-simple-solution",
                "content": "In fact, I realized that it\\'s O(log N) thanks to [@sasha.pad](https://leetcode.com/sashapad) reminded me. Sorry to showed an inaccurate statement to you.\\n```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149841,
                "title": "simple-java-o-1-time",
                "content": "Just maintain a variable which is a power of 2 (i.e. contains only 1 one). We right shift this every time in a loop taking at max 32 right shfift for an integer. Simply keep track of `lastPosition` where we found a one and a `max` distance between 1\\'s. \\n```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\\n\\nA bit more compact version \\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086691,
                "title": "bitset-lib",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055804,
                "title": "c-easy-and-readable-solution-faster-than-70",
                "content": "![image.png](https://assets.leetcode.com/users/images/aaf78b84-c2d4-40bf-89c6-7aa0d31faa17_1694955763.498142.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054572,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048317,
                "title": "fastest-c-single-pass-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048241,
                "title": "fastest-c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037525,
                "title": "100-faster-with-branchless-techniques",
                "content": "# Intuition\\nMy attempt to get rid of as much branching as possible, even though the compiler will probably do better with optimization flags.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031355,
                "title": "for-loop-java-sol",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030878,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024404,
                "title": "easy-python-solution-using-list-comprehension-and-bin-function-beats-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b25e8437-66c7-427b-9cf4-7703085d7645_1694311239.7161283.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017029,
                "title": "java-solution-using-bit-manipulation",
                "content": "# Intuition\\nUsing bit operations like and operation with 1 followed by right shift of 1 we can solve this.\\n\\n# Approach\\n(n & 1) will yeild right most bit. Whenever we see right most bit as 1, we will compare is there any max previous distance. If it is not 1 then we increment the distance.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011074,
                "title": "python-rust-solutions",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010516,
                "title": "typescript-javascript-regex-solution",
                "content": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004034,
                "title": "the-best-available-solution-that-beats-100-of-existing-solution",
                "content": "# Intuition\\nThe problem requires finding the maximum distance between two \\'1\\'s in the binary representation of a given integer \\'n\\'. To solve this problem, you can first convert the integer \\'n\\' to its binary representation as a string, and then iterate through the string to find the maximum gap between two \\'1\\'s. This gap represents the distance between two consecutive \\'1\\'s in the binary representation.\\n\\n# Approach\\n1. Initialize an empty string \\'bin\\' to store the binary representation of \\'n\\'.\\n2. Initialize a variable \\'result\\' to store the maximum binary gap, initially set to 0.\\n3. Use a while loop to convert \\'n\\' to its binary representation:\\n   a. Check if \\'n\\' is even (n % 2 == 0), and if so, insert \\'0\\' at the beginning of the \\'bin\\' string.\\n   b. Otherwise, insert \\'1\\' at the beginning of the \\'bin\\' string.\\n   c. Update \\'n\\' by performing integer division by 2 (n /= 2).\\n4. Initialize a temporary variable \\'temp\\' to 0, which will be used to keep track of the current binary gap.\\n5. Iterate through the \\'bin\\' string:\\n   a. If the current character is \\'1\\' and \\'temp\\' is 0, increment \\'temp\\' by 1.\\n   b. If the current character is \\'0\\', increment \\'temp\\' by 1.\\n   c. If the current character is \\'1\\' and \\'temp\\' is not 0, update \\'result\\' with the maximum of \\'result\\' and \\'temp\\', then reset \\'temp\\' to 1.\\n6. After the loop, return \\'result\\' as the maximum binary gap.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution depends on the number of bits in the binary representation of \\'n\\'. In the worst case, \\'n\\' has \\'log2(n)\\' bits. Therefore, the time complexity is O(log n) for converting \\'n\\' to its binary representation and O(log n) for iterating through the binary representation, resulting in an overall time complexity of O(log n).\\n\\n- Space complexity: Space Complexity: The space complexity is determined by the space needed for the \\'bin\\' string, which stores the binary representation of \\'n\\'. In the worst case, the length of the binary representation is \\'log2(n)\\' characters. Thus, the space complexity is O(log n) for the \\'bin\\' string, and O(1) for other variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980521,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967409,
                "title": "c-solution-with-tc-o-logn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960208,
                "title": "ugly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMy ugly solution\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952135,
                "title": "mom-we-have-java-solution-at-home-java-solution-at-home",
                "content": "# Approach\\nIn this solution, we are processing the input in multiple steps. First, we are converting the integer value to a binary string (I felt like it will be easier to check every characters). Then chop off the zeros before and after the \\'1\\'s.\\n\\nAt this point, we have to see if there is only a single \\'1\\' character in the string. If so, there can\\'t be a distance value.\\n\\nWe define an ArrayList to keep all distances we counted with the for loop. After that, if there is at least a distance element in the arraylist, we are finding the maximum and return the result. \\u2615\\n\\nThis may seem ugly but I think this is a really simple and easy to understand solution. \\uD83D\\uDE4C\\n\\nPlease leave an upvote, to keep a random person motivated \\uD83D\\uDC7D\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949547,
                "title": "python-beats-100-get-1s-indices",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2eb9ab23-c46f-475e-8683-48b3aa516616_1692786972.5100787.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943485,
                "title": "optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939109,
                "title": "1ms-o-n-time-complexity-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929262,
                "title": "python-beats-100-time",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/74782748-f21c-4d2a-bd3d-9b8be148fde0_1692415205.3358538.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914260,
                "title": "step-by-step",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903222,
                "title": "c-easy-sol-without-storing-the-binary-in-a-variable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892743,
                "title": "python-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889546,
                "title": "quick-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888853,
                "title": "c-simplest-solution-using-bit-manipulation",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855124,
                "title": "strictly-bit-manipulation-beats-100-explained-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBroke the problem down into steps:\\n\\n1. Iterate through each bit of the number\\n2. Count the number of zeroes between each pair of ones\\n3. return the greatest \\'gap\\'.\\n\\n---\\nThe following code iterates through the each bit from right to left:\\n```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\\nThis boolean variable ensures that the counter \"runningCount\" does not begin counting the zeroes until the first \"1\" is encountered:\\n```\\nboolean first = true;\\n```\\nWhen a second \"1\" bit is encountered, a check is made to see if the \"runningCount\" is greater than the recorded \"max\" count and \"max\" is updated accordingly.\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\n```\\nboolean first = true;\\n```\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847840,
                "title": "go-bits-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833523,
                "title": "explained-js-ts-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to convert the given positive integer n to its binary representation as a string and then traverse the binary string to find the longest distance between any two adjacent 1\\'s. We keep track of the count of consecutive zeros after each \\'1\\', and whenever we encounter a \\'1\\', we update the maximum distance found so far.\\n\\n# Approach\\n1) Convert n to its binary representation as a string using toString(2).\\n\\n2) Initialize variables isOpen as false (to keep track of whether we have encountered a \\'1\\' yet), count to 0 (to track the number of consecutive zeros after each \\'1\\'), and max to 0 (to store the maximum distance found).\\n\\n3) Traverse the binary string character by character using a for-loop.\\n\\n4) When we encounter a \\'0\\' and isOpen is true (indicating we have seen a \\'1\\' already), increment the count.\\n\\n5) When we encounter a \\'1\\' and isOpen is true, update the max distance by taking the maximum of the current count + 1 and the existing max, and reset the count to 0.\\n\\n6) If we encounter a \\'1\\' and isOpen is false, set isOpen to true.\\n\\n7) After the loop, return the max, which represents the longest distance between any two adjacent 1\\'s in the binary representation of n.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is dominated by the conversion of n to its binary representation, which takes O(log n) time.\\nThe subsequent loop to traverse the binary string takes linear time, but its complexity is bounded by O(log n) since the binary representation of n has O(log n) digits.\\n\\n- Space complexity:\\nThe space complexity is mainly determined by the binary string representation of n, which has O(log n) bits in the worst case.\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806424,
                "title": "fast-solution-on-bit-operations-runtime-96-62",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801920,
                "title": "java-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to find the farthest adjacent 1\\'s, we actually need the longest sequence of 0\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can start by getting rid of the trailing 0\\'s in the binary string representation of the number and then finding the longest sequence of 0\\'s.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801129,
                "title": "java-bit-manipulation-0ms-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784102,
                "title": "convert-to-string-first-then-get-a-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753700,
                "title": "using-math-max-and-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738607,
                "title": "easy-to-understand-java-beginner-s-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735371,
                "title": "100-beats-eaisest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729550,
                "title": "easy-solution-in-ts",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "String"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728531,
                "title": "aniruddha-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724037,
                "title": "nothing-special",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721068,
                "title": "c-one-pass-beats-100-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716617,
                "title": "straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714117,
                "title": "java-solution-with-detailed-explanation-beats-100",
                "content": "# Approach\\nHere, we need to track when we get the first 1 of the pair (if there is any) and the last 1 of the pair (the last 1 would be the first 1 of the next pair if there is any, and so on). Also, we need to count the in-between 0s of the pair.\\nTo do so, we will initialize two variables that will track the current (say, `currGap`) and maximum (say, `largestGap`) gaps between the pairs. Both will be initialized as 0, which will indicate that no pairs of 1 are still found. Then, we will run a loop that will run until the number becomes 0 (we will right shift the number to 1 position on each iteration).\\nIf we find a 1, that means it could be the start of a new pair (if there is any) or the end of an existing pair (also the start of a new pair if there is any). In both cases, we need to update the `currGap` to 1 (which will indicate that the start of a pair is found). And, if it\\'s the end of the existing pair, we need to update the `largestGap`, if applicable.\\nOn the other hand, if we encounter a 0 and the `currGap` is not 0, it means that the 0 resides in-between the pair (if there is any) of 1s. In this case, we need to increment the `currGap` by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713538,
                "title": "easy-sol-100-faster-95-in-space-bitwise-left-shift-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N) where N is number of bits.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710994,
                "title": "868-binary-gap-100-beats-than-all-java-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for finding the longest distance between adjacent 1\\'s in the binary representation of a positive integer:\\n\\n**-** Initialize variables: Set the longest distance and the current distance between adjacent 1\\'s to 0. Also, set a flag to keep track of the existence of the first 1 bit.\\n\\n**-** Iterate through the binary representation: Start from the least significant bit and move towards the most significant bit.\\n\\n**-** Handling 0 bits: If a 0 bit is encountered, shift the bits to the right. If the first 1 bit has been found (flag is true), increment the current distance between adjacent 1\\'s.\\n\\n**-** Handling 1 bits: If a 1 bit is encountered, update the longest distance with the maximum value between the current distance and the longest distance found so far. Set the first 1 bit flag to true and reset the current distance to 0.\\n\\n**-** Continue iteration: Repeat steps 3 and 4 until all bits have been processed.\\n\\n**-** Return the longest distance: After iterating through all bits, return the longest distance as the result.\\n\\nThe intuition behind this approach is to identify consecutive 1 bits and calculate the distance between them. By using bitwise operations and maintaining appropriate variables, the code tracks the longest distance between adjacent 1\\'s. It handles the case when there are no adjacent 1\\'s by returning 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a bitwise operation to calculate the binary gap of a given integer. It iterates over the binary representation of the number, keeping track of the longest distance between consecutive 1 bits. It uses a distance variable to keep track of the current distance between 1 bits and updates the longestDistance variable whenever a new longest distance is found. The code also uses a **firstOneBitExist boolean flag to handle the case when the first 1 bit is encountered**. Overall, the approach is to shift the bits to the right and perform bitwise operations to identify the binary gap.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates over the bits of the given integer, which takes O(log n) time, where n is the value of the integer.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space, so the space complexity is O(1).\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705608,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697621,
                "title": "fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3687494,
                "title": "100-100-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675230,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669421,
                "title": "javascript-bit-manipulation",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644406,
                "title": "easy-to-understand-beats-100-0ms-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636123,
                "title": "bitwise-operation-play-with-bits",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623422,
                "title": "doing-it-in-a-normal-way-thinking",
                "content": "# Intuition\\nThis is probably the first idea that comes to mind.\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(n) + O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617317,
                "title": "easy-solution-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605910,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->so the approach is i take an pointer start which is the first bit and take another pointer end if character at start is equal to character at end then start pointer is equal to end pointer and the end will be incremented \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565853,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1859732,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1633657,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1685912,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1573579,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 2058642,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1945810,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Reordered Power of 2",
        "question_content": "<p>You are given an integer <code>n</code>. We reorder the digits in any order (including the original order) such that the leading digit is not zero.</p>\n\n<p>Return <code>true</code> <em>if and only if we can do this so that the resulting number is a power of two</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 149843,
                "title": "c-java-python-straight-forward",
                "content": "`counter` will counter the number of digits 9876543210 in the given number.\\nThen I just compare `counter(N)` with all `counter(power of 2)`.\\n`1 <= N <= 10^9`, so up to 8 same digits.\\nIf `N > 10^9`, we can use a hash map.\\n\\n**C++:**\\n```\\n    bool reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n\\n    long counter(int N) {\\n        long res = 0;\\n        for (; N; N /= 10) res += pow(10, N % 10);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n    public long counter(int N) {\\n        long res = 0;\\n        for (; N > 0; N /= 10) res += (int)Math.pow(10, N % 10);\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def reorderedPowerOf2(self, N):\\n        c = collections.Counter(str(N))\\n        return any(c == collections.Counter(str(1 << i)) for i in xrange(30))\\n```\\n\\n\\n**Python 1-line**\\nsuggested by @urashima9616, bests 80%\\n```\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]\\n```",
                "solutionTags": [],
                "code": "```\\n    bool reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n\\n    long counter(int N) {\\n        long res = 0;\\n        for (; N; N /= 10) res += pow(10, N % 10);\\n        return res;\\n    }\\n```\n```\\n    public boolean reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n    public long counter(int N) {\\n        long res = 0;\\n        for (; N > 0; N /= 10) res += (int)Math.pow(10, N % 10);\\n        return res;\\n    }\\n```\n```\\n    def reorderedPowerOf2(self, N):\\n        c = collections.Counter(str(N))\\n        return any(c == collections.Counter(str(1 << i)) for i in xrange(30))\\n```\n```\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 151949,
                "title": "simple-java-solution-based-on-string-sorting",
                "content": "The idea here is similar to that of group Anagrams problem (Leetcode #49). \\n\\nFirst, we convert the input number (N) into a string and sort the string. Next, we get the digits that form the power of 2 (by using 1 << i and vary i), convert them into a string, and then sort them. As we convert the powers of 2 (and there are only 31 that are <= 10^9), for each power of 2, we compare if the string is equal to that of string based on N. If the two strings are equal, then we return true.\\n\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] a1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(a1);\\n        String s1 = new String(a1);\\n        \\n        for (int i = 0; i < 31; i++) {\\n            char[] a2 = String.valueOf((int)(1 << i)).toCharArray();\\n            Arrays.sort(a2);\\n            String s2 = new String(a2);\\n            if (s1.equals(s2)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] a1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(a1);\\n        String s1 = new String(a1);\\n        \\n        for (int i = 0; i < 31; i++) {\\n            char[] a2 = String.valueOf((int)(1 << i)).toCharArray();\\n            Arrays.sort(a2);\\n            String s2 = new String(a2);\\n            if (s1.equals(s2)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120153,
                "title": "c-super-simple-and-short-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string N_str = sorted_num(N);\\n        for (int i = 0; i < 32; i++)\\n            if (N_str == sorted_num(1 << i)) return true;\\n        return false;\\n    }\\n    \\n    string sorted_num(int n) {\\n        string res = to_string(n);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string N_str = sorted_num(N);\\n        for (int i = 0; i < 32; i++)\\n            if (N_str == sorted_num(1 << i)) return true;\\n        return false;\\n    }\\n    \\n    string sorted_num(int n) {\\n        string res = to_string(n);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480899,
                "title": "c-100-fast-0ms",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120106,
                "title": "js-python-java-c-easy-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\nThere are ways to very slightly improve the run time and memory here, but with an operation this small, it\\'s honestly not very necessary.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can directly compare the lists and Java can directly compare the char arrays without needing to join them into strings. C++ can sort the strings in-place without needing to convert to an array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 100% / 44).\\n```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 76%).\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 97% / 88%).\\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481219,
                "title": "quick-math",
                "content": "The main idea is what powers of 2 look like in binary form:\\n\\n<img width=\"200\" src=\"https://assets.leetcode.com/users/images/ae9964b4-ffbd-40a5-a934-e3dc1de49d28_1661482426.3498342.png\">\\n\\nthis will help easily iterate over all powers of two\\n\\nSo all we need is to convert n to sorted digits and then compare them with the sorted digits for each power of two.\\n`n <= 10e9`, we only need to check powers in the range `[0,29]`\\n\\na little explanation of how the shift operation `<< `works: \\n\\n<img src=\"https://assets.leetcode.com/users/images/df39060e-624d-4fb8-abe2-e3f1da6d0bf9_1661486107.3084147.png\">\\n\\n\\n##### Java\\n\\n```java\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = sortedDigits(1 << i);\\n            if (Arrays.equals(number, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private char[] sortedDigits(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n```\\n\\n##### C++\\n\\n```\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            string powerOfTwo = sortedDigits(1 << i);\\n            if (number == powerOfTwo)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n\\nprivate:\\n    string sortedDigits(int n) {\\n        string digits = to_string(n);\\n        sort(digits.begin(), digits.end());\\n        return digits;\\n    }\\n```\\n\\n##### Python\\n```python\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = sortedDigits(1 << i);\\n            if (Arrays.equals(number, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private char[] sortedDigits(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n```\n```\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            string powerOfTwo = sortedDigits(1 << i);\\n            if (number == powerOfTwo)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n\\nprivate:\\n    string sortedDigits(int n) {\\n        string digits = to_string(n);\\n        sort(digits.begin(), digits.end());\\n        return digits;\\n    }\\n```\n```python\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1120216,
                "title": "reordered-power-of-2-short-easy-w-explanation-beats-100",
                "content": "***Solution - I (Counting Digits Frequency)***\\n\\nA simple solution is to check if frequency of digits in N and all powers of 2 less than `10^9` are equal. In our case, we need to check for all powers of 2 from `2^0` to `2^29` and if any of them matches with digits in `N`, return true.\\n\\n```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\\n\\n**Time Complexity :** **`O(logn)`**, where `n` is maximum power of 2 for which digits are counted (2^30). More specifically the time complexity can be written as `O(logN + log2 + log4 + ... + log(2^30))` which after ignoring the constant factors and lower order terms comes out to `O(logn)`.\\n**Time Complexity :** **`O(1)`**. We are using vector to store digits of `N` and powers of 2 but they are taking constant space and don\\'t depend on the input `N`.\\n\\n---------\\n---------\\n\\n***Solution - II (Convert to string & sort)***\\n\\nWe can convert `N` to string, sort it and compare it with every power of 2 by converting and sorting that as well.\\n\\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n-------\\n\\nBoth solutions have the same run-time -\\n\\n![image](https://assets.leetcode.com/users/images/ec72eb4f-071d-4c4f-91b1-c6c098015f29_1616318669.6588662.png)\\n\\n-------\\n-------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481714,
                "title": "easy-java-solution-100-faster-1ms-with-basic-explanation",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\nbasically we are finding occurrence of each digit in n after that we are finding same occurrence of each digit of each power of 2 which is in range between (2^0 to 2^30) if any power of 2 matches same occurence than we can return true if none of the power of 2 matches with occurence of our number n we return false\\n\\n```\\npublic boolean reorderedPowerOf2(int n) {\\n        int Count[] = Count(n);\\n        int power = 1;\\n        for (int i = 0; i < 31; i++) {\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            power *= 2;\\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { // Counting Occurence of each digit\\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        int Count[] = Count(n);\\n        int power = 1;\\n        for (int i = 0; i < 31; i++) {\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            power *= 2;\\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { // Counting Occurence of each digit\\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482894,
                "title": "python-easily-understood-faster-than-96-fast",
                "content": "**Appreciate if you could upvote this solution**\\n\\nSince the maximun of `n` is 10^9 and the `len(str(10**9))` is 10 which is complicated to get all the combinations of the digits.\\n\\nThus, we resolved this questions to:\\n**If the digit combination of n match the digit combinations of all the power of 2**\\n\\nThen, it is much more easier as we need to compare n with 30 numbers only which are\\n```\\n2^0\\n2^1\\n... \\n2^30\\n```\\n\\nFor the digit combinations, there are 2 methons to handle:\\n\\n1) Dict: Count the occurrences of all digits\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [Counter(str(1 << i)) for i in range(30)] \\n```\\n\\n2) String: Sort all the digits\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [sorted(str(1 << i)) for i in range(30)] \\n```\\n\\n**Time Complexity**: \\n - Counter -  `O(n)`\\n - Sort - `O(nlogn)`\\n\\n**Space Complexity**: `O(1)`\\n<br />\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n2^0\\n2^1\\n... \\n2^30\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [Counter(str(1 << i)) for i in range(30)] \\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [sorted(str(1 << i)) for i in range(30)] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482392,
                "title": "python-one-liner-bit-shift-detailed-explain-beginner-friendly-easy-understand",
                "content": "**Main idea:**\\n1. We loop through 1 to 2^29 using Bit shift.\\n2. And using Counter() to check if every digit in n is in power of two.\\n\\n**One-liner code:**\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return Counter(str(n)) in [Counter(str(1 << i)) for i in range(30)]\\n```\\n\\nAnd here\\'s the code for better understand:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            if digits == Counter(str(1 << i)):\\n                return True\\n        return False\\n```\\n\\nFor those who don\\'t know bit shift:\\nThis is how power of 2 in binary looks like:\\nAnd we keep left shift the number to get every power of 2.\\n```\\n1  -> 1\\n2  -> 10\\n4  -> 100\\n8  -> 1000\\n16 -> 10000\\n32 -> 100000\\n64 -> 1000000\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return Counter(str(n)) in [Counter(str(1 << i)) for i in range(30)]\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            if digits == Counter(str(1 << i)):\\n                return True\\n        return False\\n```\n```\\n1  -> 1\\n2  -> 10\\n4  -> 100\\n8  -> 1000\\n16 -> 10000\\n32 -> 100000\\n64 -> 1000000\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120606,
                "title": "python-solution-detailed-explanation-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that in this question, the input n is less and equal to 10\\u2079 so the powers of 2 can be 1, 2, 4, and 8 all the way up to 2 to the power of 29 since 2\\xB2\\u2079 is less than 10\\u2079 and 10\\u2079 is less than 2\\xB3\\u2070.\\n\\n![image.png](https://assets.leetcode.com/users/images/19613664-10f3-4d4f-8440-7c0698bba38c_1675118248.3209496.png)\\n\\nSince We can reorder the digits in any order, input 218 can be reordered into 128 which is 2 to the power of 7. On the other hand, input 123 returns false since all the combinations of 123 [213, 123, 132, 231, 213, 312, 321] are not the power of 2.\\n\\nThe observation we can make is that reordering digits of a number in any order does not change the number of occurrences of its digits. So the main idea behind solving this question is that we want to count the occurrence of each digit in the input N and compare it with the occurrence of each digit in the powers of 2. If the occurrences are the same, it means that we can reorder the digits of N to have the resulting number as a power of 2. If the occurrence is not the same, it means we can\\u2019t reorder the digits to become a power of 2.\\n\\n![image.png](https://assets.leetcode.com/users/images/e85c5861-3926-4f48-8adc-f48a3336c06c_1675118345.1014912.png)\\n\\nIf we consider the previous example, 218 returns true since 218 and 128 = 2\\u2077 both have one 1, one 2, and one 8. 123 returns false since it does not match any powers of 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by converting the given number ```N``` to a string and then using the counter method to count the occurrences of each digit in ```N```. We use the variable ```occurrence``` to store the result. \\nNext, we will use a for loop to iterate through the range of 0 to 29. In each iteration, we compare the occurrence of each digit in 2 to the power of i to the occurrences of each digit of the given number ```N```. if they are the same, we return ```True```, otherwise, we increment i and keep comparing. \\nIf the loop completes and no match is found, it means the digits of ```N``` cannot be reordered to form a power of 2, we return ```False```.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        occurrence = Counter(str(n))\\n        for i in range(30):\\n            if (occurrence == Counter(str(2**i))):\\n                return True\\n        return False\\n\\n\\n```\\n\\nCheck out the video solution for this problem:\\nhttps://www.youtube.com/watch?v=4FAdMIoqRes\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```N```\n```N```\n```occurrence```\n```N```\n```True```\n```N```\n```False```\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        occurrence = Counter(str(n))\\n        for i in range(30):\\n            if (occurrence == Counter(str(2**i))):\\n                return True\\n        return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120214,
                "title": "simple-easy-w-explanation-beats-100-shortest-clean-code",
                "content": "***Solution - I (Counting Digits Frequency)***\\n\\nA simple solution is to check if frequency of digits in N and all powers of 2 less than `10^9` are equal. In our case, we need to check for all powers of 2 from `2^0` to `2^29` and if any of them matches with digits in `N`, return true.\\n\\n```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\\n\\n**Time Complexity :** **`O(logn)`**, where `n` is maximum power of 2 for which digits are counted (2^30). More specifically the time complexity can be written as `O(logN + log2 + log4 + ... + log(2^30))` which after ignoring the constant factors and lower order terms comes out to `O(logn)`.\\n**Time Complexity :** **`O(1)`**. We are using vector to store digits of `N` and powers of 2 but they are taking constant space and don\\'t depend on the input `N`.\\n\\n---------\\n---------\\n\\n***Solution - II (Convert to string & sort)***\\n\\nWe can convert `N` to string, sort it and compare it with every power of 2 by converting and sorting that as well.\\n\\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n-------\\n\\nBoth solutions have the same run-time -\\n\\n![image](https://assets.leetcode.com/users/images/ec72eb4f-071d-4c4f-91b1-c6c098015f29_1616318669.6588662.png)\\n\\n-------\\n-------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120130,
                "title": "python-find-anagram-explained",
                "content": "This is in fact question about anagrams: given string we need to find if we have another string from list of powers of too, which is anagram of original string. Let us iterate through all powers of two and check if count of this number is equal to count of given number `N`. \\n\\n**Complexity**: time complexity will be `O(log^2 N)`: we check `O(log N)` numbers, each of them have `O(log N)` digits at most. In fact it can be improved to `O(log^2N)`, because there can be at most `4` numbers with given number of digits, but here it just not worth it. Space complexity is `O(log N)`.\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        cnt = Counter(str(N))\\n        return any(cnt == Counter(str(1<<i)) for i in range(30))\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        cnt = Counter(str(N))\\n        return any(cnt == Counter(str(1<<i)) for i in range(30))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120107,
                "title": "reordered-power-of-2-js-python-java-c-easy-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\nThere are ways to very slightly improve the run time and memory here, but with an operation this small, it\\'s honestly not very necessary.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can directly compare the lists and Java can directly compare the char arrays without needing to join them into strings. C++ can sort the strings in-place without needing to convert to an array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 100% / 44).\\n```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 76%).\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 97% / 88%).\\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481906,
                "title": "from-brute-force-to-optimziation-fully-explained",
                "content": "In this post, I shared my full thought process behind the question, and how I arrived at the optimal solution.\\n\\nIn contrast to just posting the answer, I try to teach and show how to tackle problems and arrive progressively at the optimal solution, instead of memorizing them :)\\n\\n<hr />\\n\\nThe problem states that we are given an integer `n` and we can rearrange it in any order, except leading zero. And we need to check whether we can arrive at a valid power of 2.\\n\\nIn such questions, it\\'s very important to look at the **constraints** because a lot of times it can contradict/hint toward specific solutions. In our case `1 <= n <= 10^9`\\n\\nGiven the constraints, we know that we can have at most 10 digits in n. So generating all permutations will cost us n!, which is **10!** => **3,628,800** (A little less because 0 is invalid in the first position. But that\\'s an upper bound)\\n\\nAlso, we know that a 32-bit integer has 31 powers of 2. You can just shift the active bit to the left. (1 bit it taken for the sign)\\n\\nSo the initial idea can be to generate a set containing all the powers of 2, and to generate a set of all the permutations, and then check whether there is an element that is intersecting between both sets.\\n\\n# Naive brute force\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        int32_powers_of_two = set()\\n        for i in range(31):\\n            int32_powers_of_two.add(1<<i)\\n        \\n        n_numbers = []\\n        while n > 0:\\n            n_numbers.append(n % 10)\\n            n //= 10\\n        \\n        permutations = set()\\n        def generate_permutations(cur_permutation, options):\\n            if not options:\\n                permutations.add(int(cur_permutation))\\n                return\\n            \\n            for i in range(len(options)):\\n                if cur_permutation == \"\" and options[i] == 0: continue\\n                generate_permutations(cur_permutation + str(options[i]), [*options[:i], *options[i+1:]])\\n        \\n        generate_permutations(\"\", n_numbers)\\n        return permutations.intersection(int32_powers_of_two)\\n```\\n\\nThat will TLE on the last test cases. Let\\'s optimize\\n\\n# Optimization\\n\\nOne observation that we can make is that we don\\'t need to generate all the permutations for n. \\n\\nLet\\'s say `n` is `4210`\\n\\nIt\\'s enough for us to look at the powers of two that have 4 digits. i.e. [1024, 2048, 4096, 8192]\\n\\nTake a look, can `n` be reordered to a power of 2? how would you know that efficiently?\\n\\nWhenever you are asked about ordering/shuffling and equality, think about sorting. Sorting will represent the lexicographical order, and if both lexicographical orders are equal, you can reshuffle A to get B.\\n\\nIf we sort `n` = `4210` -> `0124`\\nIf we sort `1024` (a power of 2) -> `0124`\\n\\nBoth are equal, hence we can reorder n to get a power of two.\\n\\n# Algorithm\\n1. We will generate all permutations of 2 within the 32-bit integer range, but store them in buckets relevant to their digit count. This will allow us to look at the powers of 2 that have the same digit count as n\\n2. We will sort `n` (transform to string and sort) and compare against all powers of 2 with the same digit count sorted.\\n3. If we find the same lexicographical order, we can reorder to a valid power of 2. \\n4. If non-matched, we return false after the iteration.\\n\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        buckets = [[] for _ in range(11)]\\n        for i in range(31):\\n            power_of_two = 1<<i\\n            digits_count = math.floor(math.log10(power_of_two)) + 1\\n            buckets[digits_count].append(power_of_two)\\n        \\n        n_str_sorted = \"\".join(sorted(str(n)))\\n        n_digits_count = math.floor(math.log10(n)) + 1\\n        for power_of_two in buckets[n_digits_count]:\\n            if n_str_sorted == \"\".join(sorted(str(power_of_two))):\\n                return True\\n        return False\\n```\\n\\n# Further notes\\n* Instead of sorting you could also count the character frequency and check whether any power of 2 has the same count character count as `n`\\n* Feel free to add a comment with the code in a different language so I\\'ll add them to the post and mention your name.\\n\\n<hr />\\nHave a great day!\\n\\nIf you found this read helpful, please upvote.\\nIt motivates me to do more of them, and also shows me that these posts are helpful for some folks.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        int32_powers_of_two = set()\\n        for i in range(31):\\n            int32_powers_of_two.add(1<<i)\\n        \\n        n_numbers = []\\n        while n > 0:\\n            n_numbers.append(n % 10)\\n            n //= 10\\n        \\n        permutations = set()\\n        def generate_permutations(cur_permutation, options):\\n            if not options:\\n                permutations.add(int(cur_permutation))\\n                return\\n            \\n            for i in range(len(options)):\\n                if cur_permutation == \"\" and options[i] == 0: continue\\n                generate_permutations(cur_permutation + str(options[i]), [*options[:i], *options[i+1:]])\\n        \\n        generate_permutations(\"\", n_numbers)\\n        return permutations.intersection(int32_powers_of_two)\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        buckets = [[] for _ in range(11)]\\n        for i in range(31):\\n            power_of_two = 1<<i\\n            digits_count = math.floor(math.log10(power_of_two)) + 1\\n            buckets[digits_count].append(power_of_two)\\n        \\n        n_str_sorted = \"\".join(sorted(str(n)))\\n        n_digits_count = math.floor(math.log10(n)) + 1\\n        for power_of_two in buckets[n_digits_count]:\\n            if n_str_sorted == \"\".join(sorted(str(power_of_two))):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149825,
                "title": "java-naive-backtracking-15-lines",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length]);\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used){\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```\\nIt would be faster if you use memo to prune.\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length], new HashSet<Integer>());\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used, HashSet<Integer> vis){\\n        if (!vis.add(cur)) return false;\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used, vis)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length]);\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used){\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length], new HashSet<Integer>());\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used, HashSet<Integer> vis){\\n        if (!vis.add(cur)) return false;\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used, vis)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481202,
                "title": "java-easy-solution-using-hashset",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }\\n\\n        return two.contains(transform(n));\\n    }\\n\\n    private long transform(int n){\\n        long sum = 0;\\n        while(n > 0){\\n            int d = n % 10;\\n            sum += 1L << (d*3);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }\\n\\n        return two.contains(transform(n));\\n    }\\n\\n    private long transform(int n){\\n        long sum = 0;\\n        while(n > 0){\\n            int d = n % 10;\\n            sum += 1L << (d*3);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120407,
                "title": "clean-and-easy-to-understand-digits-anagram",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int i = 0, num = 1; i < 32; i++, num <<= 1)\\n            if(Arrays.equals(digitFreq(N), digitFreq(num)))\\n                return true;\\n        \\n        return false;\\n    }\\n    \\n    private int[] digitFreq(int N) {\\n        int[] f = new int[10];\\n        while(N > 0) {\\n            f[N % 10]++;\\n            N /= 10;\\n        }\\n        \\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int i = 0, num = 1; i < 32; i++, num <<= 1)\\n            if(Arrays.equals(digitFreq(N), digitFreq(num)))\\n                return true;\\n        \\n        return false;\\n    }\\n    \\n    private int[] digitFreq(int N) {\\n        int[] f = new int[10];\\n        while(N > 0) {\\n            f[N % 10]++;\\n            N /= 10;\\n        }\\n        \\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149827,
                "title": "simple-python-check-upto-2-power-30",
                "content": "```\\n    def reorderedPowerOf2(self, N):\\n        c1 = Counter(str(N))\\n        for i in range(30):\\n            n = int(math.pow(2, i))\\n            if Counter(str(n)) == c1: return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def reorderedPowerOf2(self, N):\\n        c1 = Counter(str(N))\\n        for i in range(30):\\n            n = int(math.pow(2, i))\\n            if Counter(str(n)) == c1: return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2481055,
                "title": "python-27-ms-faster-than-100-new-idea-to-improve-other-s-solutions",
                "content": "Like others solutions, i use the same idea of counting the digits and then compare with digits of candidates: ```1, 2, 4, 8, 16, 32, 64 ... 2^30```.\\nBut i noticed that if our input is for example ```251``` we need to compare it only with power of 2 numbers that have exact 3 digits: ```128, 256, 512```, but how can we find out what numbers we need?\\nLet\\'s look for numbers that are powers of 2, their length(number of digits) and their power:\\n```\\nnumbers: 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192\\nlength:  1 1 1 1  2  2  2   3   3   3    4    4    4    4 \\npower:   0 1 2 3  4  5  6   7   8   9   10   11   12   13\\n```\\nLet\\'s see the pattern between ```length``` and ```power```:\\nIf length of number is 1, power lies between 0 and 3, if length is 2 , power lies between 4 and 6 and etc.\\nSo all we need is to find the formula to know in what boundaries numbers lie.\\nFirst of all what i thought is that power lies in ```((length - 1) * 3 + 1, length * 3 + 1)```, for example for ```length = 2``` range will be ```range(4, 7) = (4, 5, 6)``` is what we needed, but this formula doesn\\'t work for ```length = 1, 4, 7 etc```, because every third length(or every 10th power) there are 4 numbers with this length, that ruins the formula, so i thought \"okay, what if we will add 1 every time when we our numbers length reaches 1, 4, 7 etc...\", or in another words: ```add length // 3```, but now our length of range will always be 4, that is still better than 30.\\nSo now our formula for range is ```((length - 1) * 3 + length // 3, length * 3 + length // 3 + 1)```, maybe there\\'s a way to simplify the formula, but i think it\\'s fine, so the final code is:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        from collections import Counter\\n        length = len(str(n))\\n        c = Counter(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            candidate = str(1 << i)\\n            if c == Counter(candidate):\\n                return True\\n        return False\\n```\\n\\nIf we replace the Counter with sorted, it can be even faster:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        length = len(str(n))\\n        c = sorted(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            if c == sorted(str(1 << i)):\\n                return True\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/4b1d106b-c511-4fc9-af8c-8c610e325fab_1661479742.4333918.png)\\n\\n```\\nP.S. The formula was obtained by trial and error, \\nbut i came up with the main idea with connection length and power.\\n```\\n\\n```\\nP.P.S. Feel free to ask about something if it\\'s unclear, \\nwrite an improve ment if you have an idea, \\nor point on mistakes(including english) :)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Sorting"
                ],
                "code": "```1, 2, 4, 8, 16, 32, 64 ... 2^30```\n```251```\n```128, 256, 512```\n```\\nnumbers: 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192\\nlength:  1 1 1 1  2  2  2   3   3   3    4    4    4    4 \\npower:   0 1 2 3  4  5  6   7   8   9   10   11   12   13\\n```\n```length```\n```power```\n```((length - 1) * 3 + 1, length * 3 + 1)```\n```length = 2```\n```range(4, 7) = (4, 5, 6)```\n```length = 1, 4, 7 etc```\n```add length // 3```\n```((length - 1) * 3 + length // 3, length * 3 + length // 3 + 1)```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        from collections import Counter\\n        length = len(str(n))\\n        c = Counter(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            candidate = str(1 << i)\\n            if c == Counter(candidate):\\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        length = len(str(n))\\n        c = sorted(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            if c == sorted(str(1 << i)):\\n                return True\\n        return False\\n```\n```\\nP.S. The formula was obtained by trial and error, \\nbut i came up with the main idea with connection length and power.\\n```\n```\\nP.P.S. Feel free to ask about something if it\\'s unclear, \\nwrite an improve ment if you have an idea, \\nor point on mistakes(including english) :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120140,
                "title": "python-go-o-log-n-by-digit-occurrence-mapping-w-comment",
                "content": "For example:\\n\\nGiven power of 2 = 2 ^ 6 = 64\\n\\n64 => {6: 1, 4: 1}\\n6 shows up one time\\n4 shows up one time\\n\\n---\\n\\nN=46 or N=64 return **true** because their **digit - occurrence mapping** are the same with 64\\n\\n46 => {4: 1, 6: 1}\\n4 shows up one time\\n6 shows up one time\\n\\n64 => {6: 1, 4: 1}\\n6 shows up one time\\n4 shows up one time\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        # digit <-> occurrence mapping of N\\n        signature_of_N = Counter(str(N))\\n        \\n        \\n        # check each possible power of 2\\n        for i in range(32):\\n            \\n            # get power of 2 by bitwise operation\\n            power_of_2 = 1 << i\\n                \\n            if Counter( str(power_of_2) ) == signature_of_N:\\n                \\n                # Accept if at least one power of 2\\'s mapping is the same with N\\'s mapping\\n                return True\\n        \\n        # Reject otherwise\\n        return False\\n```\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping based on recursion and decimal representation\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        def make_signature(n: int):\\n            \\n\\t\\t\\t## base case\\n            if n == 0:\\n                return 0\\n            \\n\\t\\t\\t\\n\\t\\t\\t## general case\\n\\t\\t\\t\\n            leading, remaining = divmod(n, 10)\\n            return make_signature(leading) + ( 10 ** remaining )\\n        \\n        # ---------------------------------------------------------\\n        \\n        signature_of_N = make_signature(N)\\n        \\n\\t\\t# check each possible power of 2\\n        for i in range(32):\\n            \\n\\t\\t\\t# get power of 2 by bitwise operation, and check signature\\n            if make_signature( 1 << i ) == signature_of_N:\\n\\t\\t\\t\\n\\t\\t\\t\\t# Accept if at least one power of 2\\'s signature is the same with N\\'s signature\\n                return True\\n        \\n\\t\\t# Reject otherwise\\n        return False\\n```\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping based on recursion and decimal representation\\n\\nGo:\\n\\n```\\nfunc reorderedPowerOf2(N int) bool {\\n \\n    var makeSignature func(n int) int\\n    \\n    makeSignature = func(n int) int {\\n        \\n        if n == 0{\\n            // base case\\n            return 0\\n        }\\n        \\n        // general case\\n        leading, remaining := n / 10, n % 10\\n        return makeSignature( leading ) + int( math.Pow(10, float64(remaining) ) )\\n        \\n    }\\n    \\n    // -----------------------------------------------------\\n    \\n    signatureN := makeSignature( N )\\n    \\n    // check each possible power of 2\\n    for i := 0 ; i < 32 ; i++ {\\n        \\n        if makeSignature( 1 << i ) == signatureN{\\n            \\n            // Accept if at least one power of 2\\'s signature is the smae with N\\'s\\n            return true\\n        }\\n        \\n    }\\n    \\n    // Reject otherwise\\n    return false\\n}\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about specialized dictionary Counter( ... )](https://docs.python.org/3/library/collections.html#collections.Counter)\\n\\n[2] [Python official docs about bitwise operation](https://wiki.python.org/moin/BitwiseOperators)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        # digit <-> occurrence mapping of N\\n        signature_of_N = Counter(str(N))\\n        \\n        \\n        # check each possible power of 2\\n        for i in range(32):\\n            \\n            # get power of 2 by bitwise operation\\n            power_of_2 = 1 << i\\n                \\n            if Counter( str(power_of_2) ) == signature_of_N:\\n                \\n                # Accept if at least one power of 2\\'s mapping is the same with N\\'s mapping\\n                return True\\n        \\n        # Reject otherwise\\n        return False\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        def make_signature(n: int):\\n            \\n\\t\\t\\t## base case\\n            if n == 0:\\n                return 0\\n            \\n\\t\\t\\t\\n\\t\\t\\t## general case\\n\\t\\t\\t\\n            leading, remaining = divmod(n, 10)\\n            return make_signature(leading) + ( 10 ** remaining )\\n        \\n        # ---------------------------------------------------------\\n        \\n        signature_of_N = make_signature(N)\\n        \\n\\t\\t# check each possible power of 2\\n        for i in range(32):\\n            \\n\\t\\t\\t# get power of 2 by bitwise operation, and check signature\\n            if make_signature( 1 << i ) == signature_of_N:\\n\\t\\t\\t\\n\\t\\t\\t\\t# Accept if at least one power of 2\\'s signature is the same with N\\'s signature\\n                return True\\n        \\n\\t\\t# Reject otherwise\\n        return False\\n```\n```\\nfunc reorderedPowerOf2(N int) bool {\\n \\n    var makeSignature func(n int) int\\n    \\n    makeSignature = func(n int) int {\\n        \\n        if n == 0{\\n            // base case\\n            return 0\\n        }\\n        \\n        // general case\\n        leading, remaining := n / 10, n % 10\\n        return makeSignature( leading ) + int( math.Pow(10, float64(remaining) ) )\\n        \\n    }\\n    \\n    // -----------------------------------------------------\\n    \\n    signatureN := makeSignature( N )\\n    \\n    // check each possible power of 2\\n    for i := 0 ; i < 32 ; i++ {\\n        \\n        if makeSignature( 1 << i ) == signatureN{\\n            \\n            // Accept if at least one power of 2\\'s signature is the smae with N\\'s\\n            return true\\n        }\\n        \\n    }\\n    \\n    // Reject otherwise\\n    return false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159513,
                "title": "c-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        set<string> si = {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\",\\n                          \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\",\\n                          \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\",\\n        };\\n        string t = to_string(N);\\n        sort(t.begin(), t.end());\\n        return si.count(t) > 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        set<string> si = {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\",\\n                          \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\",\\n                          \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\",\\n        };\\n        string t = to_string(N);\\n        sort(t.begin(), t.end());\\n        return si.count(t) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481179,
                "title": "c-easy-solution-of-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        \\n        while(n){\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# **Please share and Upvote it keeps me motivated**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        \\n        while(n){\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150340,
                "title": "possibly-fastest-c-solution-using-multiset-0ms-runtime",
                "content": "**So, the idea is very simple:**\\n1. Convert `N` into a multiset of its digits, for an example, if `N = 426412` then the multiset will contain `{1, 2, 2, 4, 4, 6}`.\\n2. Now, we will generate some 2\\'s power and will convert them into another multiset as well, **if both multiset are same**, function will return **true**\\n3. To speed up the process we don\\'t need to find all `2`\\'s power. In fact, it will depent on `N`, if `N` has `6` digits, I compute `2^12 to 2^20`, the above number is `2^18`, when both set matches, we just return true.\\n\\n```\\nprivate:    \\n    multiset<int> convert(int num) {        //  this function converts a number into a multiset of its digit.\\n        multiset<int> allDigit;\\n        while(num) { allDigit.insert(num%10); num /= 10; }\\n        return allDigit;\\n    }\\n    \\npublic:\\n    bool reorderedPowerOf2(int N) {\\n    \\n        if(N<10) {                                          //  for single digit\\n            if (N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n\\n        multiset<int> digitN;\\n        int num = N, cc=0, powerOf2=8;\\n\\n        while(num) { digitN.insert(num%10); num /= 10; cc++;}\\n\\n        for(int i=4; i <= 4*cc; i++) {      //  number of digit in decimal <= 4 * number of digit in binary\\n            powerOf2 *= 2;\\n            multiset<int> digitNum = convert(powerOf2);\\n            if(digitNum == digitN) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:    \\n    multiset<int> convert(int num) {        //  this function converts a number into a multiset of its digit.\\n        multiset<int> allDigit;\\n        while(num) { allDigit.insert(num%10); num /= 10; }\\n        return allDigit;\\n    }\\n    \\npublic:\\n    bool reorderedPowerOf2(int N) {\\n    \\n        if(N<10) {                                          //  for single digit\\n            if (N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n\\n        multiset<int> digitN;\\n        int num = N, cc=0, powerOf2=8;\\n\\n        while(num) { digitN.insert(num%10); num /= 10; cc++;}\\n\\n        for(int i=4; i <= 4*cc; i++) {      //  number of digit in decimal <= 4 * number of digit in binary\\n            powerOf2 *= 2;\\n            multiset<int> digitNum = convert(powerOf2);\\n            if(digitNum == digitN) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481234,
                "title": "leetcode-the-hard-way-easy-sorting-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string sortStr(int n) {\\n        // since the input is an integer,\\n        // we convert it to a string first\\n        string t = to_string(n);\\n        // use STL to sort\\n        sort(t.begin(), t.end());\\n        // return the string\\n        return t;\\n    }\\n    \\n    // the idea is to sort `n` and compare all sorted power of two\\n    // if they are matched, then it means they can be reordered to each other\\n    bool reorderedPowerOf2(int n) {\\n        // since the sorted string of n is always same\\n        // so we convert it here instead of doing it in the loop\\n        string s = sortStr(n);\\n        for (int i = 0; i < 30; i++) {\\n            // power of 2 = 1 << i\\n            // we sort each power of 2 string\\n            string t = sortStr(1 << i);\\n            // and compare with `s`\\n            // if they are matched, then return true\\n            if (s == t) return true;\\n        }\\n        // otherwise it is not possible to reorder to a power of 2\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string sortStr(int n) {\\n        // since the input is an integer,\\n        // we convert it to a string first\\n        string t = to_string(n);\\n        // use STL to sort\\n        sort(t.begin(), t.end());\\n        // return the string\\n        return t;\\n    }\\n    \\n    // the idea is to sort `n` and compare all sorted power of two\\n    // if they are matched, then it means they can be reordered to each other\\n    bool reorderedPowerOf2(int n) {\\n        // since the sorted string of n is always same\\n        // so we convert it here instead of doing it in the loop\\n        string s = sortStr(n);\\n        for (int i = 0; i < 30; i++) {\\n            // power of 2 = 1 << i\\n            // we sort each power of 2 string\\n            string t = sortStr(1 << i);\\n            // and compare with `s`\\n            // if they are matched, then return true\\n            if (s == t) return true;\\n        }\\n        // otherwise it is not possible to reorder to a power of 2\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121867,
                "title": "javascript-easy-to-understand-4-solutions",
                "content": "For this problem, there are 2 main strategies to solve it:\\n- One is following the rules in the description and try every possible option.\\n- Another one is to try to find a way to serialize the number and check whether the serialization for `N` matches any serialization of power of 2.\\n\\n## SOLUTION 1\\n\\nFirst, we try the most straight forward solution - validate every reordered sequence of `N` and check if it\\'s the power of 2.\\n\\n```js\\nconst set = new Set();\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(String(cur));\\n}\\n\\nconst validate = (left, cur = \"\") => {\\n  if (left.length === 1) return set.has(cur + left[0]);\\n  for (let i = 0; i < left.length; ++i) {\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    if (validate(next, cur + left[i])) return true;\\n  }\\n  return false;\\n};\\n\\nconst reorderedPowerOf2 = (n) => validate(String(n));\\n```\\n\\n## SOLUTION 2\\n\\nWe could find out all the possible sequences for the power of 2 between 1 and 10 ** 9 first. And then just check the mapping for the result.\\n\\n```js\\nconst set = new Set();\\n\\nconst permute = (left, cur = \"\") => {\\n  if (left.length === 1) {\\n    set.add(Number(cur + left[0]));\\n    return;\\n  }\\n  for (let i = 0; i < left.length; ++i) {\\n    if (left[i] === \"0\" && cur.length === 0) continue;\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    permute(next, cur + left[i]);\\n  }\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  permute(String(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(n);\\n```\\n\\n## SOLUTION 3\\n\\nThis solution follows the second strategy. We achieve serialization by counting the occurrences of each number.\\n\\n```js\\nconst set = new Set();\\n\\nconst serialize = str => {\\n  const count = new Uint8Array(10);\\n  const BASE = 48;\\n  for (let i = 0; i < str.length; ++i) {\\n    ++count[str.charCodeAt(i) - BASE];\\n  }\\n  return count.join(\\':\\');\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(String(cur)));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(String(n)));\\n```\\n\\n## SOLUTION 4\\n\\nHere we use a more efficient serialization approach.\\nSince the range is `[1, 10 ** 9]`, so for every number, the occurrences must small than 10, which means we could use a number to represent the serialization value. For example, `4510` means there are 4 number 4, 5 number 3, 1 number 2 and 0 number 1.\\n\\n```js\\nconst set = new Set();\\n\\nconst serialize = num => {\\n  let val = 0;\\n  while (num >= 1) {\\n    val += 1 << num % 10;\\n    num /= 10;\\n  }\\n  return val;\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(n));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst set = new Set();\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(String(cur));\\n}\\n\\nconst validate = (left, cur = \"\") => {\\n  if (left.length === 1) return set.has(cur + left[0]);\\n  for (let i = 0; i < left.length; ++i) {\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    if (validate(next, cur + left[i])) return true;\\n  }\\n  return false;\\n};\\n\\nconst reorderedPowerOf2 = (n) => validate(String(n));\\n```\n```js\\nconst set = new Set();\\n\\nconst permute = (left, cur = \"\") => {\\n  if (left.length === 1) {\\n    set.add(Number(cur + left[0]));\\n    return;\\n  }\\n  for (let i = 0; i < left.length; ++i) {\\n    if (left[i] === \"0\" && cur.length === 0) continue;\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    permute(next, cur + left[i]);\\n  }\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  permute(String(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(n);\\n```\n```js\\nconst set = new Set();\\n\\nconst serialize = str => {\\n  const count = new Uint8Array(10);\\n  const BASE = 48;\\n  for (let i = 0; i < str.length; ++i) {\\n    ++count[str.charCodeAt(i) - BASE];\\n  }\\n  return count.join(\\':\\');\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(String(cur)));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(String(n)));\\n```\n```js\\nconst set = new Set();\\n\\nconst serialize = num => {\\n  let val = 0;\\n  while (num >= 1) {\\n    val += 1 << num % 10;\\n    num /= 10;\\n  }\\n  return val;\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(n));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483824,
                "title": "c-efficient-solution-easy",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n        \\n    if(n==1)\\n        return true;\\n    \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    unordered_map<string,int> powers;\\n    \\n    //creating all 0 to 29 possible powers of 2;\\n    for(int i =0 ; i<=29; i++){\\n        string str = to_string((int)pow(2,i));      //pow function returns float so we need to convert\\n        sort(str.begin(),str.end());\\n        powers[str] = 1;\\n    }        \\n    \\n    if(powers[num]==1)\\n        return 1;\\n    else\\n        return 0;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n        \\n    if(n==1)\\n        return true;\\n    \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    unordered_map<string,int> powers;\\n    \\n    //creating all 0 to 29 possible powers of 2;\\n    for(int i =0 ; i<=29; i++){\\n        string str = to_string((int)pow(2,i));      //pow function returns float so we need to convert\\n        sort(str.begin(),str.end());\\n        powers[str] = 1;\\n    }        \\n    \\n    if(powers[num]==1)\\n        return 1;\\n    else\\n        return 0;\\n    \\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483623,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nbool isPowerOfTwo(int n) {        \\n    if(n==0)\\n        return 0;\\n        \\n    if(ceil(log2(n)) == floor(log2(n)))\\n        return 1;\\n    else\\n        return 0;            \\n}\\n    \\n    \\nbool reorderedPowerOf2(int n) {\\n        \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    do{ \\n        if(num[0]==\\'0\\')                //edge case\\n            continue;\\n\\t\\t\\t\\n        if(isPowerOfTwo(stoi(num)))\\n            return 1;        \\n    }while(next_permutation(num.begin(),num.end()));     \\n    \\n\\treturn 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nbool isPowerOfTwo(int n) {        \\n    if(n==0)\\n        return 0;\\n        \\n    if(ceil(log2(n)) == floor(log2(n)))\\n        return 1;\\n    else\\n        return 0;            \\n}\\n    \\n    \\nbool reorderedPowerOf2(int n) {\\n        \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    do{ \\n        if(num[0]==\\'0\\')                //edge case\\n            continue;\\n\\t\\t\\t\\n        if(isPowerOfTwo(stoi(num)))\\n            return 1;        \\n    }while(next_permutation(num.begin(),num.end()));     \\n    \\n\\treturn 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480861,
                "title": "daily-leetcoding-challenge-august-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reordered-power-of-2/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Permutations\n\n  \n**Approach 2:** Counting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reordered-power-of-2/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1011051,
                "title": "python-3",
                "content": "```\\ndef reorderedPowerOf2(self, N: int) -> bool:\\n        c, l = collections.Counter(str(N)), len(str(N))\\n        n = 1\\n        while len(str(n)) <= l:\\n            if collections.Counter(str(n)) == c:\\n                return True\\n            n *= 2\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef reorderedPowerOf2(self, N: int) -> bool:\\n        c, l = collections.Counter(str(N)), len(str(N))\\n        n = 1\\n        while len(str(n)) <= l:\\n            if collections.Counter(str(n)) == c:\\n                return True\\n            n *= 2\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 172840,
                "title": "one-line-python-beats-70",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1<<i)) for i in range(33)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1<<i)) for i in range(33)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484879,
                "title": "lightining-fast-high-iq-marvel-approach",
                "content": "**Logic?**\\n\\nWe have used a special operation here  \" **<<** \" , which is know as **binary left operator**.  The left operands value is moved left by the number of bits specified by the right operand.\\n\\nSo ,\\n*1      = 00000000 00000000 00000000 00000001 = 1*\\n*1 << 1 = 00000000 00000000 00000000 00000010 = 2*\\n*1 << 8 = 00000000 00000000 00000001 00000000 = 256*\\n\\n***for e.g., 1<<6 will be 1(2^6)= 64***\\n\\n***So here we are just trying to store, 2 to the power i***\\n\\nHence, for each value of **i** in for loop it will give us the corresponding **power of 2** which we store in a string as digits!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n       //Create a string to store the number as individual digits\\n       string num = to_string(n);\\n       \\n       //Sort the string of digits\\n       sort(num.begin(), num.end());\\n        \\n        //It is given that n lies in range [ 1 <= n <= 10^9 ]\\n        //So, if n is a power of 2 it must exist between 2^0(=1) to 2^30(1073741824)\\n        \\n        //Hence, we loop from 0 to 29 and find all corresponding powers of 2\\n        \\n        for(int i = 0; i < 30; i++){\\n            \\n            //For each i, the respective power of 2 can be calculated as:\\n            //**Logic is discussed above**\\n            string powerOf2 = to_string(1 << i);\\n            \\n            //We again convert that number to string and sort its digits\\n            sort(powerOf2.begin(), powerOf2.end());\\n            \\n            //If the resulting sorted string of digits is equal to num string then return True\\n            if(num == powerOf2){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        // Else, that number isn\\'t a power of 2 and so return False\\n        return false;\\n    }\\n};\\n```\\n\\n**@Credits to @rahulvarma5297 and @divyamRai for the original answers!**\\n\\n![image](https://assets.leetcode.com/users/images/eb61f3be-ac79-49cd-9415-6fa8dc469155_1661541899.0942814.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n       //Create a string to store the number as individual digits\\n       string num = to_string(n);\\n       \\n       //Sort the string of digits\\n       sort(num.begin(), num.end());\\n        \\n        //It is given that n lies in range [ 1 <= n <= 10^9 ]\\n        //So, if n is a power of 2 it must exist between 2^0(=1) to 2^30(1073741824)\\n        \\n        //Hence, we loop from 0 to 29 and find all corresponding powers of 2\\n        \\n        for(int i = 0; i < 30; i++){\\n            \\n            //For each i, the respective power of 2 can be calculated as:\\n            //**Logic is discussed above**\\n            string powerOf2 = to_string(1 << i);\\n            \\n            //We again convert that number to string and sort its digits\\n            sort(powerOf2.begin(), powerOf2.end());\\n            \\n            //If the resulting sorted string of digits is equal to num string then return True\\n            if(num == powerOf2){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        // Else, that number isn\\'t a power of 2 and so return False\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484240,
                "title": "best-java-solution",
                "content": "\\n**TC : Calculating the frequency Count for a no would be O(no of digits in N). Also,there could a case where it matches with 2^31 (last power of 2).So the complexity would be O(32*length(2^32) + O(no of digits in N)**\\n```\\nclass Solution { \\n    \\n    public boolean reorderedPowerOf2(int n) \\n    {\\n\\t\\tint [] nFreq=digitFreq(n);\\n        \\n        for(int i=0;i<31;i++) //Within the integer range max power of 2 that lies is 2^31\\n        {\\n            int powerOf2=(int)Math.pow(2,i);\\n            int [] powerOf2FreqCount = digitFreq(powerOf2);            \\n            if(compareFreq(nFreq,powerOf2FreqCount)) \\n                return true;            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean compareFreq (int []nFreq ,int []powerOf2FreqCount){\\n        boolean match=true;\\n        \\n        for(int i=0;i<10;i++){\\n            if(nFreq[i]!=powerOf2FreqCount[i])\\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private int [] digitFreq(int num){\\n        int [] digitFreq=new int [10];\\n        while(num>0){\\n            digitFreq[num%10]++;    //counting freq for each digit so here we extracted the last digit from number ( from right side )\\n            num /= 10; \\n        }\\n        return digitFreq;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution { \\n    \\n    public boolean reorderedPowerOf2(int n) \\n    {\\n\\t\\tint [] nFreq=digitFreq(n);\\n        \\n        for(int i=0;i<31;i++) //Within the integer range max power of 2 that lies is 2^31\\n        {\\n            int powerOf2=(int)Math.pow(2,i);\\n            int [] powerOf2FreqCount = digitFreq(powerOf2);            \\n            if(compareFreq(nFreq,powerOf2FreqCount)) \\n                return true;            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean compareFreq (int []nFreq ,int []powerOf2FreqCount){\\n        boolean match=true;\\n        \\n        for(int i=0;i<10;i++){\\n            if(nFreq[i]!=powerOf2FreqCount[i])\\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private int [] digitFreq(int num){\\n        int [] digitFreq=new int [10];\\n        while(num>0){\\n            digitFreq[num%10]++;    //counting freq for each digit so here we extracted the last digit from number ( from right side )\\n            num /= 10; \\n        }\\n        return digitFreq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483526,
                "title": "one-easy-way-to-solve",
                "content": "```\\nvar reorderedPowerOf2 = function(n) {\\n    let str = n.toString();\\n   let initialString =  str.split(\\'\\').sort().join(\\'\\');\\n    \\n    \\n    for(let i=0; i<30; i++){\\n        let tempString = (1<<i).toString();\\n       let finalString = tempString.split(\\'\\').sort().join(\\'\\');\\n        if(initialString===finalString){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function(n) {\\n    let str = n.toString();\\n   let initialString =  str.split(\\'\\').sort().join(\\'\\');\\n    \\n    \\n    for(let i=0; i<30; i++){\\n        let tempString = (1<<i).toString();\\n       let finalString = tempString.split(\\'\\').sort().join(\\'\\');\\n        if(initialString===finalString){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482638,
                "title": "100-00-of-c-2-approach-using-map-and-sorting-optimise-space",
                "content": "**1st approach using only sorting function**\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n        vector<string>v;\\n        \\n        for(int i=0;i<=30;i++){\\n            int p = pow(2 , i);\\n            v.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(v[i].begin() , v[i].end());\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin() , s.end());\\n        \\n        for(int i=0;i<=30;i++){\\n            if(v[i]==s) return true;\\n        }\\n        return false;\\n    }\\n};   \\n```\\n\\n**2nd approach using map**\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n\\n         int x = pow(10 , 9);\\n         map<int ,vector<int>>word;\\n         for(int i=1;i<=x;i=i*2){\\n             int k =i;\\n             vector<int>v(10 , 0);\\n             while(k){\\n                 int l = k%10;\\n                 v[l]++;\\n                 k=k/10;\\n             }\\n             word[i]=v;\\n         }\\n        \\n         vector<int> v(10 , 0);\\n         while(n){\\n             int l = n%10;\\n             v[l]++;\\n             n=n/10;\\n         }\\n        \\n         for(int i=1;i<=x;i=i*2){\\n            \\n             vector<int> m=word[i];\\n             bool flag=0;\\n             for(int j=0;j<=9;j++){\\n                if(v[j]!=m[j]){\\n                    flag=1;\\n                }\\n             }\\n             if(flag==0){\\n                 return 1;\\n             }\\n         }\\n         return 0; \\n    }\\n};   \\n```\\n\\n**If you found this solution helpful a upvote is highly appreciated**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n        vector<string>v;\\n        \\n        for(int i=0;i<=30;i++){\\n            int p = pow(2 , i);\\n            v.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(v[i].begin() , v[i].end());\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin() , s.end());\\n        \\n        for(int i=0;i<=30;i++){\\n            if(v[i]==s) return true;\\n        }\\n        return false;\\n    }\\n};   \\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n\\n         int x = pow(10 , 9);\\n         map<int ,vector<int>>word;\\n         for(int i=1;i<=x;i=i*2){\\n             int k =i;\\n             vector<int>v(10 , 0);\\n             while(k){\\n                 int l = k%10;\\n                 v[l]++;\\n                 k=k/10;\\n             }\\n             word[i]=v;\\n         }\\n        \\n         vector<int> v(10 , 0);\\n         while(n){\\n             int l = n%10;\\n             v[l]++;\\n             n=n/10;\\n         }\\n        \\n         for(int i=1;i<=x;i=i*2){\\n            \\n             vector<int> m=word[i];\\n             bool flag=0;\\n             for(int j=0;j<=9;j++){\\n                if(v[j]!=m[j]){\\n                    flag=1;\\n                }\\n             }\\n             if(flag==0){\\n                 return 1;\\n             }\\n         }\\n         return 0; \\n    }\\n};   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482021,
                "title": "c-0-ms-faster-than-100-00",
                "content": "**C++:**\\n```\\nvector<string> arr = {\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"};\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n       string s =  to_string(n);\\n       sort(s.begin(),s.end());\\n       return s == arr[lower_bound(arr.begin(),arr.end(),s)\\n\\t   - arr.begin()];\\n        \\n    }\\n};\\n```\\n\\nStep 1: Convert each power of 2 (upto 30) to string and sort all strings. \\nStep 2: Push the resultant strings to global vector `arr`  in the sorted fashion.\\n\\nYour vector will look like something like this -\\n```\\n[\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"]\\n```\\n\\nNow simply convert `n` to string `s`, sort it and apply binary search to find  `s` in `arr`\\nEg - \\nn = 251\\ns = \"251\"\\nafter sorting : s = \"125\"\\nfind index of \"125\" in `arr` and retrive the index\\nhere index will be 16,\\nNow simply check whether string exists or not by `arr[index]==s`\\nreturn it ;)\\n\\n*Upvote if it helped you*\\n\\n",
                "solutionTags": [],
                "code": "```\\nvector<string> arr = {\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"};\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n       string s =  to_string(n);\\n       sort(s.begin(),s.end());\\n       return s == arr[lower_bound(arr.begin(),arr.end(),s)\\n\\t   - arr.begin()];\\n        \\n    }\\n};\\n```\n```\\n[\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481482,
                "title": "javascript-easy-to-understand-fully-explained-power-of-2-simple",
                "content": "```\\n//Main function\\nvar reorderedPowerOf2 = function(n) {\\n let arr = FindDigitMapArray(n);\\n    \\n for(let i=0;i<31;i++){ //Till value of power of 2 is less than 10^9 or 2^32 find all such power of 2\\n      let num = Math.pow(2,i);\\n      let twoArray = FindDigitMapArray(num);\\n       if(CheckTwoArraysAreEqual(arr,twoArray)) return true;\\n }\\n    return false;\\n}\\n\\n//Function to generate digit map\\nvar FindDigitMapArray = function(n){ //For a given number it stores the count of digit on respective index.\\n    let arr = Array(10).fill(0);\\n    while(n>0){\\n        arr[n%10]+=1;\\n        n/=10;\\n        n=Math.floor(n);\\n    }\\n    return arr;\\n}\\n\\n//Function to check if two arrays are equal\\nvar CheckTwoArraysAreEqual = function(arr,twoArray){\\n     let count = 0;\\n    for(let i=0;i<10;i++){ //Check if digit map of both numbers are equal\\n     if(twoArray[i]==arr[i]){\\n            count++;\\n        }\\n    }\\n    if(count==10) return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//Main function\\nvar reorderedPowerOf2 = function(n) {\\n let arr = FindDigitMapArray(n);\\n    \\n for(let i=0;i<31;i++){ //Till value of power of 2 is less than 10^9 or 2^32 find all such power of 2\\n      let num = Math.pow(2,i);\\n      let twoArray = FindDigitMapArray(num);\\n       if(CheckTwoArraysAreEqual(arr,twoArray)) return true;\\n }\\n    return false;\\n}\\n\\n//Function to generate digit map\\nvar FindDigitMapArray = function(n){ //For a given number it stores the count of digit on respective index.\\n    let arr = Array(10).fill(0);\\n    while(n>0){\\n        arr[n%10]+=1;\\n        n/=10;\\n        n=Math.floor(n);\\n    }\\n    return arr;\\n}\\n\\n//Function to check if two arrays are equal\\nvar CheckTwoArraysAreEqual = function(arr,twoArray){\\n     let count = 0;\\n    for(let i=0;i<10;i++){ //Check if digit map of both numbers are equal\\n     if(twoArray[i]==arr[i]){\\n            count++;\\n        }\\n    }\\n    if(count==10) return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481467,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(Constant * logN)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for checking is two numbers have identiacal digits\\n    \\n    bool is_possible(int num1, int num2)\\n    {\\n        vector<int> mp(10, 0);\\n        \\n        // increment the count of digits by num1 \\n        \\n        while(num1)\\n        {\\n            int r = num1 % 10;\\n            \\n            mp[r]++;\\n            \\n            num1 = num1 / 10;\\n        }\\n        \\n        // decrement the count of digits by num2\\n        \\n        while(num2)\\n        {\\n            int r = num2 % 10;\\n            \\n            mp[r]--;\\n            \\n            num2 = num2 / 10;\\n        }\\n        \\n        // check if both are idenical of not\\n        \\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(mp[i] != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        // first of all find all the power of 2 <= 1e9 and store in power array\\n        \\n        int num = 1;\\n        \\n        vector<int> power;\\n        \\n        power.push_back(1);\\n        \\n        while(num * 2 <= 1e9)\\n        {\\n            power.push_back(num * 2);\\n            \\n            num = num * 2;\\n        }\\n        \\n        // compare the number with every element of power array, if any of them have the identical digits \\n        \\n        // then we can reorder the number to power of 2\\n        \\n        for(int i = 0; i < power.size(); i++)\\n        {\\n            if(is_possible(power[i], n))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for checking is two numbers have identiacal digits\\n    \\n    bool is_possible(int num1, int num2)\\n    {\\n        vector<int> mp(10, 0);\\n        \\n        // increment the count of digits by num1 \\n        \\n        while(num1)\\n        {\\n            int r = num1 % 10;\\n            \\n            mp[r]++;\\n            \\n            num1 = num1 / 10;\\n        }\\n        \\n        // decrement the count of digits by num2\\n        \\n        while(num2)\\n        {\\n            int r = num2 % 10;\\n            \\n            mp[r]--;\\n            \\n            num2 = num2 / 10;\\n        }\\n        \\n        // check if both are idenical of not\\n        \\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(mp[i] != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        // first of all find all the power of 2 <= 1e9 and store in power array\\n        \\n        int num = 1;\\n        \\n        vector<int> power;\\n        \\n        power.push_back(1);\\n        \\n        while(num * 2 <= 1e9)\\n        {\\n            power.push_back(num * 2);\\n            \\n            num = num * 2;\\n        }\\n        \\n        // compare the number with every element of power array, if any of them have the identical digits \\n        \\n        // then we can reorder the number to power of 2\\n        \\n        for(int i = 0; i < power.size(); i++)\\n        {\\n            if(is_possible(power[i], n))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481411,
                "title": "java-sort",
                "content": "We can do the hash thing or we can also just sort it.\\nI think sorting is easier. \\n```Java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        for (int i = 0; i <= 30; i++){\\n            char[] a = (\"\"+(1<<i)).toCharArray();\\n            char[] b = (\"\"+n).toCharArray();\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n            if (Arrays.equals(a, b)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        for (int i = 0; i <= 30; i++){\\n            char[] a = (\"\"+(1<<i)).toCharArray();\\n            char[] b = (\"\"+n).toCharArray();\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n            if (Arrays.equals(a, b)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481019,
                "title": "c-easy-to-understand-beginner-friendly",
                "content": "\\tbool check(string str)\\n\\t{\\n\\t\\tint x = 0;\\n\\t\\tfor(int i=0;i<str.size();i++)\\n\\t\\t{\\n\\t\\t\\tx=x*10+(str[i]-\\'0\\');\\n\\t\\t}\\n\\t\\tint z = (x&(x-1));\\n\\t\\tif(z==0)return true;\\n\\t\\treturn false;\\n\\t}\\n\\tvoid permute(string &str,int index,bool &ans)\\n\\t{\\n\\t\\tif(index==str.size())\\n\\t\\t{\\n\\t\\t\\tif(str[0]!=\\'0\\' && check(str))ans = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i=index;i<str.size();i++)\\n\\t\\t{\\n\\t\\t\\tswap(str[i],str[index]);\\n\\t\\t\\tpermute(str,index+1,ans);\\n\\t\\t\\tswap(str[i],str[index]);\\n\\t\\t}\\n\\t}\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool reorderedPowerOf2(int n) \\n\\t\\t{\\n\\t\\t\\tbool ans = false;\\n\\t\\t\\tstring str = to_string(n);\\n\\t\\t\\tpermute(str,0,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool reorderedPowerOf2(int n) \\n\\t\\t{\\n\\t\\t\\tbool ans = false;\\n\\t\\t\\tstring str = to_string(n);\\n\\t\\t\\tpermute(str,0,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2481005,
                "title": "python-my-soln",
                "content": "class Solution:\\n\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n1 = sorted(str(n))\\n        \\n        for i in range(30):\\n            res = sorted(str(2 ** i))\\n            if res == n1:\\n                return True\\n            \\n            \\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n1 = sorted(str(n))\\n        \\n        for i in range(30):\\n            res = sorted(str(2 ** i))\\n            if res == n1:\\n                return True\\n            \\n            \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1120308,
                "title": "c-linear-time-constant-space-solution-explained-100-time-100-space",
                "content": "Great problem to tackle and, since it was pretty straightforward, I gave myself a few extra challenges:\\n* no conversion to string (that will not look cool to most interviewers anyway);\\n* no sorting;\\n* getting there with constant space.\\n\\nAnd it looks like I did it \\uD83C\\uDF8A !\\n\\nIn order to proceed, first of all I declared as a `static constexpr` a 2D array with all the powers of 2 up to the given limit (`9` digits), grouped by number of digits, so that I could have a smoother lookup later.\\n\\nIn the main function, we will declare 2 support variables:\\n* `digits` is an array of `9` elements (again, the maximum we might have to consider;\\n* `pos` is a pointer that will tell us where to write or up to where to read in `digits`, preset to `0`.\\n\\nWe will then proceed to destructure `n` into its base digits, proceeding until it is reduced to `0` and:\\n* assign its quotient and remainder to the aptly named `qr`;\\n* store the remainder in `digits`, while also increasing `pos` by `1`;\\n* update `n` to be the quotient - ie: functionally shaving off the least significant/leftmost digit that we just store.\\n\\nOnce done, we will call `verifyDigits` with all the non-`0` values that we have in `powers[pos]` (ie: all the powers of 2 we pre-stored), returning `true` if anyone of them matches the content of digits (ie: the initial number was an \"anagram\" of any power of 2 with the same amount of digits).\\n\\n`verifyDigits` takes 3 parameters (our array/pointer `digits`, `pos` which doubles now as the size of `digits` and `n`, the pre-stored power of 2 to verify) and:\\n* declare a support variable `check` as an array of `10` elements, all preset to `0`;\\n* increase each matching cell of `check` by `1` for each element in `digits` up to `pos` - so, for example, if we had `digits = {3, 5, 6, 6, 5}`, `check` would be `{0, 0, 0, 1, 0, 2, 2, 0, 0, 0}`;\\n* proceed to destructure `n` in a similar fashion to what we did before and:\\n\\t* put quotient and remainder into `qr`;\\n\\t* return `false` if any cell of `check` matching the remainder (ie: the least significant digits) ends up being reduced below `0`;\\n\\t* update `n` to be the quotient, shaving off again the least significant digit and moving on;\\n* return `true` if we reach the end of the loop, since we successfully reduced `pos` elements in `check` without any of them going below `0`, which implies a perfect match!\\n\\nIf we are back in the main function, we will then return `false` at this point, since all the `digits` from the original `n` could not be used to make any known power of 2.\\n\\nThe code:\\n\\n```cpp\\n// precomputed values of powers, grouped by number of digits\\nstatic constexpr int powers[10][4] = {{}, {1, 2, 4, 8}, {16, 32, 64}, {128, 256, 512}, {1024, 2048, 4096, 8192}, {16384, 32768, 65536}, {131072, 262144, 524288}, {1048576, 2097152, 4194304, 8388608}, {16777216, 33554432, 67108864}, {134217728, 268435456, 536870912}};\\n\\nclass Solution {\\n    bool verifyDigits(int *digits, int pos, int n) {\\n        // support variables\\n        int check[10] = {};\\n        // preparing check\\n        for (int i = 0; i < pos; i++) check[digits[i]]++;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // verifying if the matching least significant digit can be used\\n            if (--check[qr.rem] < 0) return false;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        // support variables\\n        int digits[9], pos = 0;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // storing the least significant digit of n\\n            digits[pos++] = qr.rem;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        // checking if we have a match for any known power of 2 with the same amount of digits\\n        for (int n: powers[pos]) if (n && verifyDigits(digits, pos, n)) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n// precomputed values of powers, grouped by number of digits\\nstatic constexpr int powers[10][4] = {{}, {1, 2, 4, 8}, {16, 32, 64}, {128, 256, 512}, {1024, 2048, 4096, 8192}, {16384, 32768, 65536}, {131072, 262144, 524288}, {1048576, 2097152, 4194304, 8388608}, {16777216, 33554432, 67108864}, {134217728, 268435456, 536870912}};\\n\\nclass Solution {\\n    bool verifyDigits(int *digits, int pos, int n) {\\n        // support variables\\n        int check[10] = {};\\n        // preparing check\\n        for (int i = 0; i < pos; i++) check[digits[i]]++;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // verifying if the matching least significant digit can be used\\n            if (--check[qr.rem] < 0) return false;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        // support variables\\n        int digits[9], pos = 0;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // storing the least significant digit of n\\n            digits[pos++] = qr.rem;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        // checking if we have a match for any known power of 2 with the same amount of digits\\n        for (int n: powers[pos]) if (n && verifyDigits(digits, pos, n)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149975,
                "title": "a-java-solution-which-easy-understand",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int ans=1;ans<=Math.pow(10,9);ans*=2)\\n            if(equal(N,ans))\\n                return true;\\n        return false;\\n    }\\n    public boolean equal(int num1,int num2){\\n        char[] str1 = Integer.toString(num1).toCharArray(),str2 = Integer.toString(num2).toCharArray();\\n        int[] nums = new int[10];\\n        for(int i=0;i<str1.length;i++) nums[str1[i] - \\'0\\']--;\\n        for(int i=0;i<str2.length;i++) nums[str2[i] - \\'0\\']++;\\n        for(int i:nums)\\n            if(i!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int ans=1;ans<=Math.pow(10,9);ans*=2)\\n            if(equal(N,ans))\\n                return true;\\n        return false;\\n    }\\n    public boolean equal(int num1,int num2){\\n        char[] str1 = Integer.toString(num1).toCharArray(),str2 = Integer.toString(num2).toCharArray();\\n        int[] nums = new int[10];\\n        for(int i=0;i<str1.length;i++) nums[str1[i] - \\'0\\']--;\\n        for(int i=0;i<str2.length;i++) nums[str2[i] - \\'0\\']++;\\n        for(int i:nums)\\n            if(i!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233498,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        while(n)\\n        {\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n)\\n     {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        while(n)\\n        {\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n)\\n     {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930717,
                "title": "c-clear-solution-with-explanation-runtime-0-ms-faster-than-100-00",
                "content": "1.**Brute force Approach:** Find all possible combinations of numbers that can be formed from the Given Target number\\'s digits  and for each combination check if it is a\\n power of 2 or not . (Hint :   Convert the number to string )\\n 2. **Optimised/Efficient Approach:** We can see the constraint for n is *1 <= n <= 10^9* \\n*   If somehow we can show that , with the given number\\'s digits we can form a number which is a power of 2 , then our job is done!\\n*   First of all , We will keep the count of the frequency of digits  of the given number and then we will check if the frequency count matches or not for every power of 2 within the given constraint.\\n*   Linear Time Complexity Solution \\n```\\nclass Solution {\\npublic:\\n    vector<int>nfreq;\\n    vector<int> util(int n)  // To find the freqeuncy of digits of a number\\n    {\\n        vector<int>digitFreq(10,0); \\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            n = n/10;\\n            digitFreq[rem]++;\\n        }\\n        return digitFreq;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n     \\n        nfreq = util(n);\\n        for(int i= 0;i<32;++i)\\n        {\\n            if(nfreq == util(1<<i))   // Checking condition \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>nfreq;\\n    vector<int> util(int n)  // To find the freqeuncy of digits of a number\\n    {\\n        vector<int>digitFreq(10,0); \\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            n = n/10;\\n            digitFreq[rem]++;\\n        }\\n        return digitFreq;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n     \\n        nfreq = util(n);\\n        for(int i= 0;i<32;++i)\\n        {\\n            if(nfreq == util(1<<i))   // Checking condition \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485025,
                "title": "python-short-and-precise-answer",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        for i in range(32):\\n            if Counter(str(n))==Counter(str(2**i)):\\n                return True\\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        for i in range(32):\\n            if Counter(str(n))==Counter(str(2**i)):\\n                return True\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2483872,
                "title": "easy-6-line-c-code-beginner-friendly-bitwise",
                "content": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n      string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if( s[0]==\\'0\\') continue;\\n          int k=stoi(s);\\n            if(!(k&k-1)) return true;\\n        }while(next_permutation(s.begin(),s.end()) );\\n            return false;\\n    }\\n};\\n*Upvote if you liked the solution*",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n      string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if( s[0]==\\'0\\') continue;\\n          int k=stoi(s);\\n            if(!(k&k-1)) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2483557,
                "title": "python-o-log-n-time-o-1-space-faster-than-100-explained-and-compared",
                "content": "# Approach\\nFor all the solutions presented here, the general approach is as follows:\\n- **Step #1**: Identify the digits `n` is made of.\\n- **Step #2**: Identify the powers of 2 that have the same number of digits as `n`; there are maximum four of them.\\n- **Step #3**: Check whether any of the powers of 2 from step **#2** are made of the same digits as identified in step **#1**.\\n\\n# Solution with the lowest time and space theoretical complexity\\n**Description**\\nThis solution uses:\\n- Integer division by 10 and modulo base 10 to identify the digits making up a given integer value.\\n- A `dict` to count the number of occurrences of each digit in a given integer value.\\n  Such a dict has maximum 10 entries.\\n- The comparison between such `dict` instances to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n))`\\n- Space: `O(1)`\\n\\n**Code**\\nThe code below gave me: `Runtime: 26 ms, faster than 100.00% of Python3 online submissions`\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `digitCounts` has maximum 10 entries\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `powerOf2DigitCounts` has maximum 10 entries\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Faster solution: Use string conversion to get the digits\\n**Description**\\nThis solution uses:\\n- String conversion to identify the digits making up a given integer value.\\n- A `dict` to count the number of occurrences of each digit in a given integer value.\\n  Such a dict has maximum 10 entries.\\n- The comparison between such `dict` instances to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n))`\\n- Space: `O(log(n))`\\n\\n**Code**\\nThe code below gave me: `Runtime: 28 ms, faster than 100.00% of Python3 online submissions`\\nAgainst LeetCode\\'s test suite, this timing does not look as good as the previous solution, **BUT** this is due to LeetCode\\'s:\\n- Huge variance in running times, even for the exact same code.\\n- Test suites often no being comprehensive enough to properly differentiate algorithms.\\n\\nPlease see the *comparison* section at the end of this post to get a clear picture that this solution is globally faster than the previous one.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate string\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate strings\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n**Description**\\nThis solution uses:\\n- String conversion to identify the digits making up a given integer value.\\n- Sorting of the digits.\\n- The comparison between such sorted lists to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n)*log(log(n)))`\\n- Space: `O(log(n))`\\n\\nAlthough the theoretical time complexity is worse than the previous solutions, in practice this performs noticeable faster, as:\\n- We are talking about a relatively small number of digits, so the sorting is actually very fast.\\n- The building of a list structure is much faster than the building of a counter dictionary structure.\\n\\n**Code**\\nThe code below gave me: `Runtime: 23 ms, faster than 100.00% of Python3 online submissions`\\nPlease see the *comparison* section at the end of this post to get a better sense of how much faster this solution actually is.\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and sort them\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we sort the digits and compare to the ones from step #1\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Timings comparison\\nAs mentioned previously, one cannot rely on LeetCode\\'s test suites or LeetCode\\'s inconsistent running times to get a proper picture of how different algorithms actually compare.\\n\\nSo, here is some code that compares the 3 solutions presented above, and that anyone can run on their own machine.\\nIt generates 1,000,000 test cases with integers of varying sizes; out of these, 332 can be reordered into a power of 2.\\n\\n**Code**\\n```\\n# ==================================================================================================\\n# Solution with the lowest time and space theoretical complexity\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_1:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Faster solution: Use string conversion to get the digits\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_2:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n# ==================================================================================================\\n\\nfrom math import ceil, log2\\n\\nclass Solution_3:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Testing\\n# ==================================================================================================\\n\\nfrom time import perf_counter\\n\\npowersOf2sortedDigits = frozenset(tuple(sorted(str(powerOf2))) for powerOf2 in (2 ** i for i in range(31)))\\ntestCases = [(n, tuple(sorted(str(n))) in powersOf2sortedDigits) for n in (137 * i for i in range(1, 1000001))]\\nprint(f\"{len(testCases)} test cases out of which {sum(1 for _, expected in testCases if expected is True)} return `True`\")\\n\\nfor Solution in [Solution_1, Solution_2, Solution_3]:\\n    print(f\"*** {Solution.__name__} ***\")\\n    startPerfCounter = perf_counter()\\n    for n, expected in testCases:\\n        actual = Solution().reorderedPowerOf2(n)\\n        assert actual == expected, f\"ERROR for arg {n}:\\\\n- Expected: {expected}\\\\n- Got: {actual}\"\\n    else:\\n        endPerfCounter = perf_counter()\\n        print(f\"Completed in {(endPerfCounter - startPerfCounter)}s\")\\n```\\n\\n**Results**\\nRunning this code on my laptop, I got:\\n```\\n1000000 test cases out of which 332 return `True`\\n*** Solution_1 ***\\nCompleted in 10.228865999999925s\\n*** Solution_2 ***\\nCompleted in 7.209750700000313s\\n*** Solution_3 ***\\nCompleted in 3.2113036999999167s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `digitCounts` has maximum 10 entries\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `powerOf2DigitCounts` has maximum 10 entries\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate string\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate strings\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and sort them\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we sort the digits and compare to the ones from step #1\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\n# ==================================================================================================\\n# Solution with the lowest time and space theoretical complexity\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_1:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Faster solution: Use string conversion to get the digits\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_2:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n# ==================================================================================================\\n\\nfrom math import ceil, log2\\n\\nclass Solution_3:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Testing\\n# ==================================================================================================\\n\\nfrom time import perf_counter\\n\\npowersOf2sortedDigits = frozenset(tuple(sorted(str(powerOf2))) for powerOf2 in (2 ** i for i in range(31)))\\ntestCases = [(n, tuple(sorted(str(n))) in powersOf2sortedDigits) for n in (137 * i for i in range(1, 1000001))]\\nprint(f\"{len(testCases)} test cases out of which {sum(1 for _, expected in testCases if expected is True)} return `True`\")\\n\\nfor Solution in [Solution_1, Solution_2, Solution_3]:\\n    print(f\"*** {Solution.__name__} ***\")\\n    startPerfCounter = perf_counter()\\n    for n, expected in testCases:\\n        actual = Solution().reorderedPowerOf2(n)\\n        assert actual == expected, f\"ERROR for arg {n}:\\\\n- Expected: {expected}\\\\n- Got: {actual}\"\\n    else:\\n        endPerfCounter = perf_counter()\\n        print(f\"Completed in {(endPerfCounter - startPerfCounter)}s\")\\n```\n```\\n1000000 test cases out of which 332 return `True`\\n*** Solution_1 ***\\nCompleted in 10.228865999999925s\\n*** Solution_2 ***\\nCompleted in 7.209750700000313s\\n*** Solution_3 ***\\nCompleted in 3.2113036999999167s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482545,
                "title": "c-10-4bit-counters-packet-into-64bit-integer-fast-0ms",
                "content": "**Please upvote if you like the solution, it motivates me to post more of them**\\n\\n**Solution 1: 10 4bit counters packet into a 64bit integer**\\n\\nThis solution is basically do a frequency count. Since any digit (0 to 9) is for sure less frequent than 16 in a 32bit integer we can use 4 bits to count the frequency the digitis. With that we can pack 10 4bit counters easily into a 64bit integer. The solution has to functions:\\n\\nWe just need to compare the signature of ```n``` with the signature of all powers of 2.\\n\\n```\\n    bool reorderedPowerOf2(int n) {\\n        const uint64_t sig_n = signatur(n);\\n        // Compare to all powers of 2.\\n        for (int i = 0; i < 32; ++i) {\\n            if (sig_n == signatur(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n```\\n\\nThe more interesting part is to compute the singatures:\\n\\n```\\n    // We use 4 bits to count each digit.\\n    static uint64_t signatur(uint32_t n) {\\n        uint64_t sig = 0;\\n        while (n) {\\n            sig += 1UL << ((n % 10) * 4);\\n            n /= 10;\\n        }\\n        return sig;\\n    }\\n```\\n\\nAlternative to an ```uint64_t``` signature we could have used an ```array<char, 10>``` (or a similar structure) or just use a ```string``` and just sort the digits.\\n\\nAs always feedback is welcome.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```n```\n```\\n    bool reorderedPowerOf2(int n) {\\n        const uint64_t sig_n = signatur(n);\\n        // Compare to all powers of 2.\\n        for (int i = 0; i < 32; ++i) {\\n            if (sig_n == signatur(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n```\n```\\n    // We use 4 bits to count each digit.\\n    static uint64_t signatur(uint32_t n) {\\n        uint64_t sig = 0;\\n        while (n) {\\n            sig += 1UL << ((n % 10) * 4);\\n            n /= 10;\\n        }\\n        return sig;\\n    }\\n```\n```uint64_t```\n```array<char, 10>```\n```string```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482451,
                "title": "java-simplest-solution-so-far-no-bitwise",
                "content": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        Arrays.sort(num);\\n        for(int i=0;i<30;i++){\\n            int intCur = (int)Math.pow(2,i);\\n            char[] charCur = String.valueOf(intCur).toCharArray();\\n            Arrays.sort(charCur);\\n            if(Arrays.equals(num,charCur))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        Arrays.sort(num);\\n        for(int i=0;i<30;i++){\\n            int intCur = (int)Math.pow(2,i);\\n            char[] charCur = String.valueOf(intCur).toCharArray();\\n            Arrays.sort(charCur);\\n            if(Arrays.equals(num,charCur))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481969,
                "title": "daily-challenge-c-100-faster-easy-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int arr[10];\\n        memset(arr,0,sizeof(arr));\\n        \\n        int x =n;\\n        for(;x>0;){\\n            int rem = x%10;\\n            arr[rem]++;\\n            x = x/10;\\n        }\\n        for(int i=0; i<31; i++){\\n            int check[10];\\n            memset(check,0,sizeof(check));\\n            int y = pow(2,i);\\n            while(y>0){\\n                int rem = y%10;\\n                check[rem]++;\\n                y = y/10;\\n            }\\n            bool flag = true;\\n            for(int j=0; j<10; j++){\\n                if(arr[j]!=check[j]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int arr[10];\\n        memset(arr,0,sizeof(arr));\\n        \\n        int x =n;\\n        for(;x>0;){\\n            int rem = x%10;\\n            arr[rem]++;\\n            x = x/10;\\n        }\\n        for(int i=0; i<31; i++){\\n            int check[10];\\n            memset(check,0,sizeof(check));\\n            int y = pow(2,i);\\n            while(y>0){\\n                int rem = y%10;\\n                check[rem]++;\\n                y = y/10;\\n            }\\n            bool flag = true;\\n            for(int j=0; j<10; j++){\\n                if(arr[j]!=check[j]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481830,
                "title": "c-easy-understand",
                "content": "# core concept\\nWe can use `2147483648%num`to determine` num` is power of 2 or not.\\nI hope this concept can help you~~~\\nif you think this is useful, please upvoted it to let more people see this article.\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if(2147483648%stoi(s)==0&&s[0]!=\\'0\\') return 1;\\n        }while(next_permutation(s.begin(), s.end()));\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if(2147483648%stoi(s)==0&&s[0]!=\\'0\\') return 1;\\n        }while(next_permutation(s.begin(), s.end()));\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481280,
                "title": "c-simple-solution",
                "content": "1.  Convert our given number to string (`to_string()`)\\n2.  Sort it (`sort()`)\\n3.  Compare it will all sorted string forms of 2 power numbers upto 30 ( 2^31 > 10^9)\\n4.  If equals to anyone return `true`\\n5.  else if no-match found return `false`\\n\\n**PLEASE UPVOTE IF YOU LIKED THIS \\uD83D\\uDE09\\uD83D\\uDE4C**\\n\\n\\n\\n\\n\\n```\\nbool reorderedPowerOf2(int n) {\\n\\tstring s = sortedString(n);\\n\\tfor(int i = 0; i < 30; ++i){\\n\\t\\tif(s == sortedString(1<<i)) return true;\\n\\t}\\n\\treturn false;\\n}\\nstring sortedString(int n){\\n\\tstring s = to_string(n);\\n\\tsort(s.begin(),s.end());\\n\\treturn s;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n\\tstring s = sortedString(n);\\n\\tfor(int i = 0; i < 30; ++i){\\n\\t\\tif(s == sortedString(1<<i)) return true;\\n\\t}\\n\\treturn false;\\n}\\nstring sortedString(int n){\\n\\tstring s = to_string(n);\\n\\tsort(s.begin(),s.end());\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481061,
                "title": "python3-easy-understanding-sort",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        i, arr = 0, []\\n        v = 2**i\\n        while v <= 10**9: arr.append(sorted(str(v))); i+=1; v = 2**i\\n        return sorted(str(n)) in arr\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        i, arr = 0, []\\n        v = 2**i\\n        while v <= 10**9: arr.append(sorted(str(v))); i+=1; v = 2**i\\n        return sorted(str(n)) in arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481013,
                "title": "go-golang-solution",
                "content": "```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tstr := strconv.Itoa(n)\\n\\tstrByte := []byte(str)\\n\\tsort.Slice(strByte, func(i, j int) bool { return strByte[i] < strByte[j] })\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\ttmp := strconv.Itoa(1 << i)\\n\\t\\ttmpByte := []byte(tmp)\\n\\t\\tsort.Slice(tmpByte, func(i, j int) bool { return tmpByte[i] < tmpByte[j] })\\n\\t\\tif string(strByte) == string(tmpByte) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\\n\\nuse slice as counter (can\\'t use == to compare two slice)\\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) []int {\\n\\t\\tresult := make([]int, 10)\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tcompare := func(s1, s2 []int) bool {\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif compare(nCnt, count(1<<i)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\\n\\nuse array as counter (can use == to compare two array)\\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) [10]int {\\n\\t\\tvar result [10]int\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif nCnt == count(1<<i) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tstr := strconv.Itoa(n)\\n\\tstrByte := []byte(str)\\n\\tsort.Slice(strByte, func(i, j int) bool { return strByte[i] < strByte[j] })\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\ttmp := strconv.Itoa(1 << i)\\n\\t\\ttmpByte := []byte(tmp)\\n\\t\\tsort.Slice(tmpByte, func(i, j int) bool { return tmpByte[i] < tmpByte[j] })\\n\\t\\tif string(strByte) == string(tmpByte) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) []int {\\n\\t\\tresult := make([]int, 10)\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tcompare := func(s1, s2 []int) bool {\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif compare(nCnt, count(1<<i)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) [10]int {\\n\\t\\tvar result [10]int\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif nCnt == count(1<<i) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824308,
                "title": "track-with-hashmap-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> powers;\\n        for(int i=1;i<=1e9;i*=2){\\n            powers.push_back(i);\\n        }\\n        \\n        map<int,int> demand;\\n        while(n>0){\\n            demand[n%10]++;\\n            n/=10;\\n        }\\n        \\n        for(auto& num:powers){\\n            map<int,int> curr;\\n            while(num>0){\\n                curr[num%10]++;\\n                num/=10;\\n            }\\n            \\n            if(curr==demand){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> powers;\\n        for(int i=1;i<=1e9;i*=2){\\n            powers.push_back(i);\\n        }\\n        \\n        map<int,int> demand;\\n        while(n>0){\\n            demand[n%10]++;\\n            n/=10;\\n        }\\n        \\n        for(auto& num:powers){\\n            map<int,int> curr;\\n            while(num>0){\\n                curr[num%10]++;\\n                num/=10;\\n            }\\n            \\n            if(curr==demand){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617077,
                "title": "easy-to-understand-python-solution",
                "content": "```\\n\\t\\tl = sorted(list(str(n)))\\n        for i in range(30):\\n            a = 2**i\\n            b = sorted(list(str(a)))\\n            if l == b:\\n                return True\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tl = sorted(list(str(n)))\\n        for i in range(30):\\n            a = 2**i\\n            b = sorted(list(str(a)))\\n            if l == b:\\n                return True\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1545432,
                "title": "java-1ms-97-25-faster",
                "content": "**Explanation**\\n1) Store the count of digits of given n in an array.\\n2) Store the count of digits of every power of 2 from 1 to 30.\\n3) If the count of digits in any of the power of 2 matches with the count of digits of given n, then return true. \\n4) If a match is not found after all iterations, that means the given number cannot be arranged in the form of a power of 2. Hence, return false.\\n```\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        int[] cnt = new int[10];\\n        int num = n;\\n        while(num != 0)\\n        {\\n            cnt[num % 10]++;\\n            num /= 10;\\n        }\\n        \\n        int two = 1;\\n        int pow = 1;\\n        while(pow <= 30)\\n        {\\n            int cur[] = new int[10];\\n            num = two;\\n            while(num != 0)\\n            {\\n                cur[num % 10]++;\\n                num /= 10;\\n            }\\n            \\n            boolean powOfTwo = true;\\n            for(int i=0; i<10; i++)\\n            {\\n                if(cnt[i] != cur[i])\\n                {\\n                    powOfTwo = false;\\n                    break;\\n                }\\n            }\\n            if(powOfTwo)\\n                return true;\\n            two *= 2;\\n            pow++;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        int[] cnt = new int[10];\\n        int num = n;\\n        while(num != 0)\\n        {\\n            cnt[num % 10]++;\\n            num /= 10;\\n        }\\n        \\n        int two = 1;\\n        int pow = 1;\\n        while(pow <= 30)\\n        {\\n            int cur[] = new int[10];\\n            num = two;\\n            while(num != 0)\\n            {\\n                cur[num % 10]++;\\n                num /= 10;\\n            }\\n            \\n            boolean powOfTwo = true;\\n            for(int i=0; i<10; i++)\\n            {\\n                if(cnt[i] != cur[i])\\n                {\\n                    powOfTwo = false;\\n                    break;\\n                }\\n            }\\n            if(powOfTwo)\\n                return true;\\n            two *= 2;\\n            pow++;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121404,
                "title": "java-simple-and-easy-solution-1-ms-faster-than-96-64-t-o-1-s-o-1-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    //store all the power of 2 digits,\\n    //only do this operation 1 time\\n    static PowerOfTwo powerOfTwo = new PowerOfTwo();\\n    \\n    public boolean reorderedPowerOf2(int N) {\\n        String numDigit = String.valueOf(N);\\n        \\n        /*\\n            Approach\\n            1. calculate one time only, power of 2\\n               and store \\n            2. for given number, if its digit is anagram of any\\n               stored power of 2 digits, return true otherwise false\\n            3. Time O(1), Space O(1)\\n        */\\n        \\n        \\n        for(String power : powerOfTwo.digits){\\n            if(isAnagrams(power, numDigit)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    private boolean isAnagrams(String str1, String str2){\\n        if(str1.length() != str2.length()) return false;\\n        \\n        int[] counts = new int[10];\\n        \\n        for(char digit : str1.toCharArray()){\\n            counts[digit - \\'0\\']++;\\n        }\\n        \\n        for(char digit : str2.toCharArray()){\\n            counts[digit - \\'0\\']--;\\n        }\\n        \\n        for(int count : counts){\\n            if(count != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nclass PowerOfTwo{\\n    String[]  digits;\\n    \\n    public PowerOfTwo(){\\n        digits = new String[30];\\n        \\n        for(int i = 0; i < digits.length; i++){\\n            digits[i] = String.valueOf((1 << i));\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //store all the power of 2 digits,\\n    //only do this operation 1 time\\n    static PowerOfTwo powerOfTwo = new PowerOfTwo();\\n    \\n    public boolean reorderedPowerOf2(int N) {\\n        String numDigit = String.valueOf(N);\\n        \\n        /*\\n            Approach\\n            1. calculate one time only, power of 2\\n               and store \\n            2. for given number, if its digit is anagram of any\\n               stored power of 2 digits, return true otherwise false\\n            3. Time O(1), Space O(1)\\n        */\\n        \\n        \\n        for(String power : powerOfTwo.digits){\\n            if(isAnagrams(power, numDigit)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    private boolean isAnagrams(String str1, String str2){\\n        if(str1.length() != str2.length()) return false;\\n        \\n        int[] counts = new int[10];\\n        \\n        for(char digit : str1.toCharArray()){\\n            counts[digit - \\'0\\']++;\\n        }\\n        \\n        for(char digit : str2.toCharArray()){\\n            counts[digit - \\'0\\']--;\\n        }\\n        \\n        for(int count : counts){\\n            if(count != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nclass PowerOfTwo{\\n    String[]  digits;\\n    \\n    public PowerOfTwo(){\\n        digits = new String[30];\\n        \\n        for(int i = 0; i < digits.length; i++){\\n            digits[i] = String.valueOf((1 << i));\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120965,
                "title": "simplest-explaned-solution",
                "content": "\\nlet say we are given a number 46. So we need to check for 46 or 64 . If anyone of them is power of two then we will return true that there exist a permutation who is Power of 2.\\n\\nDoes we need to **calculate every Permutaion :( ?**\\n**NO :)** we just need to make a digit frequency map. and then compare that to power of two\\'s .\\n As digit can have only value 0 to 9 .  So instead of map can have a array of length 10.(0 to 9)\\nTry to **understand through example :**\\nLet say N=46 \\n`InputDigit= [0,0,0,0,1,0,1,0,0,0]`\\n**Start comparing it with Powers of 2.**\\n2^0 =1 \\n`digitArray=[0,1,0,0,0,0,0,0,0,0]`\\n\\n2^1=2\\n`digitArray=[0,0,1,0,0,0,0,0,0,0]`\\n\\n2^2=4\\n`digitArray=[0,0,0,0,1,0,0,0,0,0]`\\n\\n2^3=8\\n`digitArray=[0,0,0,0,0,0,0,0,1,0]`\\n\\n2^4=16\\n`digitArray=[0,1,0,0,0,0,1,0,0,0]`\\n\\n2^5=32\\n`digitArray=[0,0,1,1,0,0,0,0,0,0]`\\n\\n2^6=64\\n`digitArray=[0,0,0,0,1,0,1,0,0,0]`**SAME AS OF INPUT DIGITS ARRAY** return true\\n\\n\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        int[] InputDigits=count(N);\\n         \\n        int powerOfTwo=1;\\n        for(int i=0;i<31;i++){\\n            int[] powerDigits=count(powerOfTwo);\\n            if(isEqual(InputDigits,powerDigits)) return true;\\n            powerOfTwo<<=1;  // leftShift basically multiplying by 2\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isEqual(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i]!=arr2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int[] count(int n){\\n        int[] digitMap=new int[10];\\n        while(n>0){\\n            digitMap[n%10]++;\\n            n/=10;\\n        }\\n        return digitMap;\\n    }\\n}\\n```\\nPlease **UPVOTE** if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        int[] InputDigits=count(N);\\n         \\n        int powerOfTwo=1;\\n        for(int i=0;i<31;i++){\\n            int[] powerDigits=count(powerOfTwo);\\n            if(isEqual(InputDigits,powerDigits)) return true;\\n            powerOfTwo<<=1;  // leftShift basically multiplying by 2\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isEqual(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i]!=arr2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int[] count(int n){\\n        int[] digitMap=new int[10];\\n        while(n>0){\\n            digitMap[n%10]++;\\n            n/=10;\\n        }\\n        return digitMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120773,
                "title": "c-python-direct-simulation-indirect-checking-all-possibilities-of-power-of-2",
                "content": "Idea1:  Direct simulation of Permutations [1]\\nIntuition\\n\\nFor each permutation of the digits of N, let\\'s check if that permutation is a power of 2.\\n\\nAlgorithm\\n\\nThis approach has two steps: how will we generate the permutations of the digits, and how will we check that the permutation represents a power of 2?\\n\\nTo generate permutations of the digits, we place any digit into the first position (start = 0), then any of the remaining digits into the second position (start = 1), and so on. In Python, we can use the builtin function itertools.permutations.\\n\\nTo check whether a permutation represents a power of 2, we check that there is no leading zero, and divide out all factors of 2. If the result is 1 (that is, it contained no other factors besides 2), then it was a power of 2. In Python, we can use the check bin(N).count(\\'1\\') == 1.\\n\\n```\\nTime Complexity: O((logN)!\\u2217logN). Note that logN is the number of digits in the binary representation of N. For each of (logN)! permutations of the digits of N, we need to check that it is a power of 2 in O(logN) time.\\n\\nSpace Complexity: O(logN), the space used by A (or cand in Python).\\n```\\n\\nApproach 1: C++\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digits;\\n        while(N>0){\\n            digits.push_back(N%10);\\n            N /= 10;\\n        }\\n        \\n        sort(digits.begin(), digits.end());        \\n        do{\\n            if( digits[0] != 0 && __builtin_popcount(digit2num(digits)) == 1)\\n                return true;\\n        }while(next_permutation(digits.begin(), digits.end()));\\n        return false;\\n    }\\n    \\nprivate:\\n    int digit2num(vector<int>& digits){\\n        int ans = 0;\\n        for(auto digit: digits)\\n            ans = ans * 10 + digit;\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        for cand in itertools.permutations(str(N)):\\n            if cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1:\\n                return True\\n        return False\\n        #return any( cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1\\n        #           for cand in itertools.permutations(str(N)))\\n            #for cand in iterationtools.permutation(str(N)))\\n```\\n\\n\\n\\nIdea2: Counting\\nIntuition and Algorithm\\n\\nWe can check whether two numbers have the same digits by comparing the count of their digits. For example, 338 and 833 have the same digits because they both have exactly two 3\\'s and one 8.\\nSince NN could only be a power of 2 with 9 digits or less (namely, 2^0, 2^1, 2^31), we can just check whether NN has the same digits as any of these possibilities.\\n\\nComplexity Analysis\\n\\nTime Complexity: O( (logN)^2). There are logN different candidate powers of 2, and each comparison has O(logN) time complexity.\\nSpace Complexity: O(logN).\\n\\n\\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, N):\\n        count = collections.Counter(str(N))\\n        return any(count == collections.Counter(str(1 << b))\\n                   for b in xrange(31))\\n```\\n\\nReference:\\n[1] https://leetcode.com/problems/reordered-power-of-2/solution/\\n[2] itertools.permutations:\\nIllustration:\\n\\nN=128\\n\\n>>> for cand in itertools.permutations(str(N)):print(cand)\\n...\\n(\\'1\\', \\'2\\', \\'8\\')\\n(\\'1\\', \\'8\\', \\'2\\')\\n(\\'2\\', \\'1\\', \\'8\\')\\n(\\'2\\', \\'8\\', \\'1\\')\\n(\\'8\\', \\'1\\', \\'2\\')\\n(\\'8\\', \\'2\\', \\'1\\')\\n>>> for cand in itertools.permutations([1,2,8]):print(cand)\\n...\\n(1, 2, 8)\\n(1, 8, 2)\\n(2, 1, 8)\\n(2, 8, 1)\\n(8, 1, 2)\\n(8, 2, 1)",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nTime Complexity: O((logN)!\\u2217logN). Note that logN is the number of digits in the binary representation of N. For each of (logN)! permutations of the digits of N, we need to check that it is a power of 2 in O(logN) time.\\n\\nSpace Complexity: O(logN), the space used by A (or cand in Python).\\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digits;\\n        while(N>0){\\n            digits.push_back(N%10);\\n            N /= 10;\\n        }\\n        \\n        sort(digits.begin(), digits.end());        \\n        do{\\n            if( digits[0] != 0 && __builtin_popcount(digit2num(digits)) == 1)\\n                return true;\\n        }while(next_permutation(digits.begin(), digits.end()));\\n        return false;\\n    }\\n    \\nprivate:\\n    int digit2num(vector<int>& digits){\\n        int ans = 0;\\n        for(auto digit: digits)\\n            ans = ans * 10 + digit;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        for cand in itertools.permutations(str(N)):\\n            if cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1:\\n                return True\\n        return False\\n        #return any( cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1\\n        #           for cand in itertools.permutations(str(N)))\\n            #for cand in iterationtools.permutation(str(N)))\\n```\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, N):\\n        count = collections.Counter(str(N))\\n        return any(count == collections.Counter(str(1 << b))\\n                   for b in xrange(31))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120255,
                "title": "reordered-power-of-2-beats-100-c",
                "content": "The steps for solution to this problem are :\\n* Store all the powers of 2 in a vector\\n* Compare each numbner in vector with the given number to check if both have same digits .\\n* If both have same digits , return true\\n* else return false .\\nPls upvote if u feel it is correct and suggest if it can be improved .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120112,
                "title": "rust-counting-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        let digit_counts = |n: i32| -> [usize; 10] {\\n            let mut n = n;\\n            let mut d = [0; 10];\\n            while n > 0 {\\n                d[(n % 10) as usize] += 1;\\n                n /= 10;\\n            }\\n            d\\n        };\\n        let counts = digit_counts(n);\\n        (0..31).any(|i| digit_counts(1 << i) == counts)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        let digit_counts = |n: i32| -> [usize; 10] {\\n            let mut n = n;\\n            let mut d = [0; 10];\\n            while n > 0 {\\n                d[(n % 10) as usize] += 1;\\n                n /= 10;\\n            }\\n            d\\n        };\\n        let counts = digit_counts(n);\\n        (0..31).any(|i| digit_counts(1 << i) == counts)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120035,
                "title": "python",
                "content": "As `N` is bounded by 10^9 we need to check at most the 30-th power of 2. For each power of 2 we count the occurrence of every digit and store it in an array of size 10 (from 0,...,9). If for any power of 2 the count matches that of `N` we return True. Else return False.\\n\\nTime: `O(1)`\\nSpace: `O(1)`\\n\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        def is_equal(c1, c2):\\n            return sum(abs(x-y) for x,y in zip(c1,c2))==0\\n        \\n        \\n        def count(n):\\n            c = [0]*10\\n            while n:\\n                c[n % 10] += 1\\n                n //= 10\\n            return c\\n        \\n        \\n        c1 = count(N)\\n        for i in range(31):\\n            c2 = count(2**i)\\n            if is_equal(c1, c2):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        def is_equal(c1, c2):\\n            return sum(abs(x-y) for x,y in zip(c1,c2))==0\\n        \\n        \\n        def count(n):\\n            c = [0]*10\\n            while n:\\n                c[n % 10] += 1\\n                n //= 10\\n            return c\\n        \\n        \\n        c1 = count(N)\\n        for i in range(31):\\n            c2 = count(2**i)\\n            if is_equal(c1, c2):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980748,
                "title": "easy-short-understandable-code-in-c",
                "content": "#using compare function for removing 0 as first digit\\n```\\nstatic bool com(char a,char b){\\n        return a>b;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n       string s= to_string(N);\\n        int n=s.size();\\n        int k=1;\\n        string p;\\n        sort(s.begin(),s.end(),com);\\n        while(n>=p.size())\\n        {\\n            p=to_string(k);\\n            sort(p.begin(),p.end(),com);  //sort every power of twofor checking \\n            if(s==p)\\n                return 1;\\n            k=k<<1; //using for finding next power of two\\n        }\\n        return 0;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic bool com(char a,char b){\\n        return a>b;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n       string s= to_string(N);\\n        int n=s.size();\\n        int k=1;\\n        string p;\\n        sort(s.begin(),s.end(),com);\\n        while(n>=p.size())\\n        {\\n            p=to_string(k);\\n            sort(p.begin(),p.end(),com);  //sort every power of twofor checking \\n            if(s==p)\\n                return 1;\\n            k=k<<1; //using for finding next power of two\\n        }\\n        return 0;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149928,
                "title": "python-easy-to-understand-with-explanation",
                "content": "Since the leading digit is not zero, the reordered number shares the same number of digits with original one.\\nThe search base can be greatly reduced.\\nReturn true if `Counter(N) == Counter(power of 2) and NumberOfDigits(N) == NumberOfDigits(power of 2)`\\n\\n```python\\n    def reorderedPowerOf2(self, N):\\n        from collections import Counter\\n\\n        digits_of_n = len(str(N))\\n        counter = Counter(str(N))\\n        power = 1\\n\\n        while True:\\n            digits_of_power = len(str(power))\\n\\n            if digits_of_power > digits_of_n:\\n                break\\n            \\n            if digits_of_power == digits_of_n and Counter(str(power)) == counter:\\n                return True\\n\\n            power = power*2\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\n    def reorderedPowerOf2(self, N):\\n        from collections import Counter\\n\\n        digits_of_n = len(str(N))\\n        counter = Counter(str(N))\\n        power = 1\\n\\n        while True:\\n            digits_of_power = len(str(power))\\n\\n            if digits_of_power > digits_of_n:\\n                break\\n            \\n            if digits_of_power == digits_of_n and Counter(str(power)) == counter:\\n                return True\\n\\n            power = power*2\\n\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2952889,
                "title": "js-easiest-to-follow-one-glance-you-will-get-it-fastest",
                "content": "Have fun :)\\n\\n# Intuition\\nhttps://onlinenumbertools.com/sort-digits\\n\\n\\n# Code\\n```\\nvar reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827694,
                "title": "java-100-faster-1-ms-solution-explained",
                "content": "# Approach\\nExplanation.\\n\\n**Occur** is an 2d array which stores occurrences of all digits of each number (power of 2). \\n\\nExample: 2^16 = 65536, array with occurences of digits for it will be: [0,0,0,1,0,2,2,0,0,0], because we have one occurence of 3, two occurences of 5, and two occurences of 6.\\n\\n**Occur** is $$static$$ because I fill it only once and use for each test case.\\n\\nThe names of methods are self explainable.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static byte[][] ocurr;\\n\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            //increment digits frequency for number pow\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static byte[][] ocurr;\\n\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            //increment digits frequency for number pow\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783380,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516026,
                "title": "understanding-reordered-power-of-2-in-3-basic-steps",
                "content": "I broke it down into 3 core parts:\\n1. Identify individual digits of the number\\n2. Identify valid permutations of the digits\\n3. Test to see if a permutation is a power of 2.\\n\\n**Step 1:  Identify the Digits**\\nIf I as a human see the number 1,024, I\\'ll list the digits from left-to-right:  1, 0, 2, 4.  But if I want a computer to do it, I\\'m better off going from right-to-left:  4, 2, 0, 1.  How can we make the computer do this?  How can we ask it to tell us, \"What\\'s in the 1\\'s column?\"\\n\\n1. Divide the number by 10:  `1024 / 10 = 102`\\n2. Multiply by it by 10:  `102 * 10 = 1020`\\n3. Subtract this result from the original value:  `1024 - 1020 = 4`\\n\\nJust divide the original number by 10 and repeat the process until you run out of digits!\\n\\n**Step 2:  Identify Valid Permutations**\\nHow many different ways can we arrange these digits, and what are they?  Well, do we actually care?  We don\\'t really need to *enumerate* the permutations, we just need to *identify* them.  That\\'s a boolean test.  If I ask you, \"Is 4210 a permutation of the digits in 1024?\" how do you answer that question?  If you\\'re like me, you just check to see if all digits have been used. \\n\\nYou can use an integer array of length 10 to count the digits in the input number.  For each digit observed in step 1, increment the corresponding index in the array.  Using 1024 (or 4210!) as our example, the resulting array should be:  `[1, 1, 1, 0, 1, 0, 0, 0, 0, 0]`\\n\\nIf our input number was `55,963,220`, the array would be:   `[1, 0, 2, 1, 0, 2, 1, 0, 0, 1]`\\n\\nIf two numbers\\' arrays are equal, then the digits of one number can be rearranged to make the other!\\n\\n**Step 3: Test Powers of 2**\\nWho remembers their big O times?  What grows faster:  `O(x^2)`, or `O(2^x)`?  The anwer is the latter. `2^x` grows pretty quickly.  In fact, `2^30 == 1,073,741,824`, and that\\'s greater than a billion.  The problem statement says that n will be less than 10 to the 9th, which means we only have 30 dfferent powers of 2 that we\\'d need to test.  That\\'s a pretty small data set to test!  Just generate powers of 2, and extract their digits into an array, and compare to the array of digits for our given number.  If they match, it means our number can be rearranged to make a power of 2.",
                "solutionTags": [],
                "code": "I broke it down into 3 core parts:\\n1. Identify individual digits of the number\\n2. Identify valid permutations of the digits\\n3. Test to see if a permutation is a power of 2.\\n\\n**Step 1:  Identify the Digits**\\nIf I as a human see the number 1,024, I\\'ll list the digits from left-to-right:  1, 0, 2, 4.  But if I want a computer to do it, I\\'m better off going from right-to-left:  4, 2, 0, 1.  How can we make the computer do this?  How can we ask it to tell us, \"What\\'s in the 1\\'s column?\"\\n\\n1. Divide the number by 10:  `1024 / 10 = 102`\\n2. Multiply by it by 10:  `102 * 10 = 1020`\\n3. Subtract this result from the original value:  `1024 - 1020 = 4`\\n\\nJust divide the original number by 10 and repeat the process until you run out of digits!\\n\\n**Step 2:  Identify Valid Permutations**\\nHow many different ways can we arrange these digits, and what are they?  Well, do we actually care?  We don\\'t really need to *enumerate* the permutations, we just need to *identify* them.  That\\'s a boolean test.  If I ask you, \"Is 4210 a permutation of the digits in 1024?\" how do you answer that question?  If you\\'re like me, you just check to see if all digits have been used. \\n\\nYou can use an integer array of length 10 to count the digits in the input number.  For each digit observed in step 1, increment the corresponding index in the array.  Using 1024 (or 4210!) as our example, the resulting array should be:  `[1, 1, 1, 0, 1, 0, 0, 0, 0, 0]`\\n\\nIf our input number was `55,963,220`, the array would be:   `[1, 0, 2, 1, 0, 2, 1, 0, 0, 1]`\\n\\nIf two numbers\\' arrays are equal, then the digits of one number can be rearranged to make the other!\\n\\n**Step 3: Test Powers of 2**\\nWho remembers their big O times?  What grows faster:  `O(x^2)`, or `O(2^x)`?  The anwer is the latter. `2^x` grows pretty quickly.  In fact, `2^30 == 1,073,741,824`, and that\\'s greater than a billion.  The problem statement says that n will be less than 10 to the 9th, which means we only have 30 dfferent powers of 2 that we\\'d need to test.  That\\'s a pretty small data set to test!  Just generate powers of 2, and extract their digits into an array, and compare to the array of digits for our given number.  If they match, it means our number can be rearranged to make a power of 2.",
                "codeTag": "Unknown"
            },
            {
                "id": 2484929,
                "title": "simple-solution-using-next-permutation-to-find-the-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> tovector(int n){\\n        vector<int> ans;\\n        while(n!=0){\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    // [5,2,1]\\n    \\n    int toInteger(vector<int> &ans){\\n        int nums = 0;\\n        for(auto x : ans){\\n            nums = nums*10 + x;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n      vector<int> vec = tovector(n);\\n      do{\\n          if(vec.size() == 1 && vec[0] == 1) return true;\\n          if(vec[0] == 0 ||((vec[vec.size()-1]%2 ==1))){\\n              continue;\\n          }\\n          int n = toInteger(vec);\\n          if((n &(n-1)) == 0) return true;\\n          \\n      }while(next_permutation(vec.begin(),vec.end()));\\n      return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tovector(int n){\\n        vector<int> ans;\\n        while(n!=0){\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    // [5,2,1]\\n    \\n    int toInteger(vector<int> &ans){\\n        int nums = 0;\\n        for(auto x : ans){\\n            nums = nums*10 + x;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n      vector<int> vec = tovector(n);\\n      do{\\n          if(vec.size() == 1 && vec[0] == 1) return true;\\n          if(vec[0] == 0 ||((vec[vec.size()-1]%2 ==1))){\\n              continue;\\n          }\\n          int n = toInteger(vec);\\n          if((n &(n-1)) == 0) return true;\\n          \\n      }while(next_permutation(vec.begin(),vec.end()));\\n      return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484157,
                "title": "ruby-set-of-strings",
                "content": "## Leetcode: 869. Reordered Power of 2.\\n\\n\\n**Ruby: Set of strings.**\\n\\n1. Need to get an array of powers of two till `10**9`.\\n2. Convert these numbers to strings and sort chars. Create a set from the array.\\n3. Convert inpur to string sort chars join and check does in include in the set.\\n\\nLet\\'s try.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 869. Reordered Power of 2.\\n# https://leetcode.com/problems/reordered-power-of-2/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 82 ms, faster than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# Memory Usage: 210.9 MB, less than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# @param {Integer} n\\n# @return {Boolean}\\ndef reordered_power_of2(n)\\n  require \"set\"\\n  @two ||= get_powers_of_2()\\n    .map{|x| x.to_s.chars.sort.join}.to_set\\n  @two.include?(n.to_s.chars.sort.join)\\nend\\n\\ndef get_powers_of_2()\\n  answer = []\\n  value = 1\\n  border = 10**9 \\n  while value <= border\\n    answer.push value\\n    value *= 2\\n  end\\n  answer\\nend\\n\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Ordered Set"
                ],
                "code": "```Ruby\\n# Leetcode: 869. Reordered Power of 2.\\n# https://leetcode.com/problems/reordered-power-of-2/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 82 ms, faster than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# Memory Usage: 210.9 MB, less than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# @param {Integer} n\\n# @return {Boolean}\\ndef reordered_power_of2(n)\\n  require \"set\"\\n  @two ||= get_powers_of_2()\\n    .map{|x| x.to_s.chars.sort.join}.to_set\\n  @two.include?(n.to_s.chars.sort.join)\\nend\\n\\ndef get_powers_of_2()\\n  answer = []\\n  value = 1\\n  border = 10**9 \\n  while value <= border\\n    answer.push value\\n    value *= 2\\n  end\\n  answer\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484091,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] num = getArr(n);\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = getArr(1 << i);\\n            if (Arrays.equals(num, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public char[] getArr(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] num = getArr(n);\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = getArr(1 << i);\\n            if (Arrays.equals(num, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public char[] getArr(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484063,
                "title": "c-0ms-solution-easy-to-understand-short-code",
                "content": "1) Create a vector of strings \"v\" of size 30 where each string represents a power of 2 (from 0 to 30) with its digits in sorted form.\\n2) Convert the given number to string \"s\" and sort its digits as well.\\n3) Compare the resultant string \"s\" with each element of the vector of strings \"v\".\\n4) Return true if a match is found else return false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> v;\\n        for(int i=0;i<30;i++)\\n        {\\n            int k=pow(2,i);\\n            string c=to_string(k);\\n            sort(c.begin(),c.end());\\n            v.push_back(c);\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(auto it:v)\\n        {\\n            if(s==it)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> v;\\n        for(int i=0;i<30;i++)\\n        {\\n            int k=pow(2,i);\\n            string c=to_string(k);\\n            sort(c.begin(),c.end());\\n            v.push_back(c);\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(auto it:v)\\n        {\\n            if(s==it)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482968,
                "title": "rust-solution",
                "content": "```\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n\\n        let mut log = (n as f32).log2();\\n        if n == i32::pow(2, log as u32) {\\n            return true;\\n        }\\n\\n        let mut n_s = n.to_string().chars().collect::<Vec<char>>();\\n\\n        n_s.sort();\\n\\n        for i in 0..30 {\\n            let pow_2 = i64::pow(2, i);\\n            \\n\\n            let mut pow_2_s = pow_2.to_string().chars().collect::<Vec<char>>();\\n\\n            pow_2_s.sort();\\n\\n            if pow_2_s == n_s {\\n                println!(\"found at {}\", pow_2);\\n                return true;\\n            }\\n            \\n            \\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n\\n        let mut log = (n as f32).log2();\\n        if n == i32::pow(2, log as u32) {\\n            return true;\\n        }\\n\\n        let mut n_s = n.to_string().chars().collect::<Vec<char>>();\\n\\n        n_s.sort();\\n\\n        for i in 0..30 {\\n            let pow_2 = i64::pow(2, i);\\n            \\n\\n            let mut pow_2_s = pow_2.to_string().chars().collect::<Vec<char>>();\\n\\n            pow_2_s.sort();\\n\\n            if pow_2_s == n_s {\\n                println!(\"found at {}\", pow_2);\\n                return true;\\n            }\\n            \\n            \\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482867,
                "title": "python-simple-python-solution-using-two-different-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. First Apporach Using Permutation Concept : \\n# Runtime: 8288 ms, faster than 5.35% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 28.1 MB, less than 11.23% of Python3 online submissions for Reordered Power of 2.\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tall_permutations = [] \\n\\n\\t\\t\\tfor single_number in itertools.permutations(str(n)):\\n\\n\\t\\t\\t\\tif single_number[0] != \\'0\\':\\n\\n\\t\\t\\t\\t\\tnum = int(\\'\\'.join(single_number))\\n\\n\\t\\t\\t\\t\\tall_permutations.append(num)\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tif 2**i in all_permutations:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# 2. Second Approach With HashMap Or Dictionary with Sorting : \\n# Runtime: 56 ms, faster than 60.96% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 13.7 MB, less than 96.79% of Python3 online submissions for Reordered Power of 2.\\n\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tnum = sorted(str(n))\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tcurrent_num = sorted(str(2**i))\\n\\n\\t\\t\\t\\tif num == current_num:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Probability and Statistics"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. First Apporach Using Permutation Concept : \\n# Runtime: 8288 ms, faster than 5.35% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 28.1 MB, less than 11.23% of Python3 online submissions for Reordered Power of 2.\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tall_permutations = [] \\n\\n\\t\\t\\tfor single_number in itertools.permutations(str(n)):\\n\\n\\t\\t\\t\\tif single_number[0] != \\'0\\':\\n\\n\\t\\t\\t\\t\\tnum = int(\\'\\'.join(single_number))\\n\\n\\t\\t\\t\\t\\tall_permutations.append(num)\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tif 2**i in all_permutations:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# 2. Second Approach With HashMap Or Dictionary with Sorting : \\n# Runtime: 56 ms, faster than 60.96% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 13.7 MB, less than 96.79% of Python3 online submissions for Reordered Power of 2.\\n\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tnum = sorted(str(n))\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tcurrent_num = sorted(str(2**i))\\n\\n\\t\\t\\t\\tif num == current_num:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2482646,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        char[] car1 = (\"\" + n).toCharArray(); \\n\\t\\tArrays.sort(car1);\\n\\n        for(int i = 0; i < 30;i++){\\n            char[] car2 = (\"\" + (1 << i)).toCharArray(); \\n\\t\\t\\tArrays.sort(car2);\\n            if(Arrays.equals(car1, car2)) return true;\\n        }\\n\\n        return false;",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482476,
                "title": "asymptotic-o-1-constant-time-solution-faster-than-100-explanation",
                "content": "```\\nclass Solution { // 0ms - 100.00% Faster \\n    static HashSet<String> set;\\n    Solution(){ // this checks if the set is null, or it computes all the powers of 2 and stores it in the set(this operation occurs only once)\\n        if(set==null){\\n            set = new HashSet<String>();\\n            for(long i=1;i<=1000000000;i=i<<1){\\n                String s = getFrequencyChart(i);\\n                set.add(s);\\n            }\\n        }\\n    }\\n    private String getFrequencyChart(long n){ // this is the function to calculate the frequency of all the digits in the array\\n        int[] freq = new int[10];\\n        while(n>0){\\n            freq[(int)n%10]++;\\n            n/=10;\\n        }\\n        return Arrays.toString(freq);\\n    }\\n    \\n    public boolean reorderedPowerOf2(int n) {\\n        return set.contains(getFrequencyChart((long)n));\\n    }\\n}\\n```\\nExplanation:\\n* Which we are setting the map as static, it creates only one `set` map object for all the object of the Solution class. Thus reducing the time to recalculate the set\\n* `getFrequencyChart generates a frequency map of a number\\'s digits and returns it which is used as a hashset key\\n* In the Main Function we are just checking if the frequencies of the given numbers matches with the any power of 2.\\n\\n`Please Upvote if you find it helpful` \\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution { // 0ms - 100.00% Faster \\n    static HashSet<String> set;\\n    Solution(){ // this checks if the set is null, or it computes all the powers of 2 and stores it in the set(this operation occurs only once)\\n        if(set==null){\\n            set = new HashSet<String>();\\n            for(long i=1;i<=1000000000;i=i<<1){\\n                String s = getFrequencyChart(i);\\n                set.add(s);\\n            }\\n        }\\n    }\\n    private String getFrequencyChart(long n){ // this is the function to calculate the frequency of all the digits in the array\\n        int[] freq = new int[10];\\n        while(n>0){\\n            freq[(int)n%10]++;\\n            n/=10;\\n        }\\n        return Arrays.toString(freq);\\n    }\\n    \\n    public boolean reorderedPowerOf2(int n) {\\n        return set.contains(getFrequencyChart((long)n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482244,
                "title": "100-faster-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n    bool equal(vector<int>&a,vector<int>&b ){\\n        for(int i=0;i<10;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    vector<int> freq(int n){\\n        vector<int>f(10,0);\\n        while(n>0){\\n            f[n%10]++;\\n            n/=10;\\n        }\\n        return f;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        vector<int>a(10,0);\\n        vector<int>b(10,0);\\n        a=freq(n);\\n        for(int i=0;i<31;i++){\\n            b=freq(pow(2,i));\\n            if(equal(a,b))return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool equal(vector<int>&a,vector<int>&b ){\\n        for(int i=0;i<10;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    vector<int> freq(int n){\\n        vector<int>f(10,0);\\n        while(n>0){\\n            f[n%10]++;\\n            n/=10;\\n        }\\n        return f;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        vector<int>a(10,0);\\n        vector<int>b(10,0);\\n        a=freq(n);\\n        for(int i=0;i<31;i++){\\n            b=freq(pow(2,i));\\n            if(equal(a,b))return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482202,
                "title": "rust-run-time-one-liner-and-the-nerdiest-approach-you-will-ever-see-p-with-comments",
                "content": "So I wasn\\'t the only one to think about precomputation here... Anyway, my \"standard\" solution is below, and then we\\'ll go really crazy with an idea I had below that, which you really don\\'t want to miss :D.\\n\\nI love how easy it is to compute things at compile time in Rust compared to C++\\'s `constexpr`. So for the \"standard\" solution I use that to build a look-up table with the digit histograms of all the powers of two <= 10^9 (there are 30). At runtime, I only have to build the histogram of the given number, and check if it is in the lookup table.\\n\\n**\"Standard\" Solution**\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nconst fn build_histogram(mut n: i32) -> [u8; N_DIGITS] {\\n    let mut rez = [0; N_DIGITS];\\n    while n > 0 {\\n        rez[(n % 10) as usize] += 1;\\n        n /= 10;\\n    }\\n    rez\\n}\\n\\nconst N_POWERS: usize = 30;\\n\\nconst fn compute_power_histograms() -> [[u8; N_DIGITS]; N_POWERS] {\\n    let mut i = 0;\\n    let mut rez = [[0; N_DIGITS]; N_POWERS];\\n    while i < N_POWERS {\\n        rez[i] = build_histogram(1 << i);\\n        i += 1;\\n    }\\n    rez\\n}\\n\\nconst POWER_HISTOGRAMS: [[u8; N_DIGITS]; N_POWERS] = compute_power_histograms();\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        POWER_HISTOGRAMS.contains(&build_histogram(n))\\n    }\\n}\\n```\\n\\n**Graph Solution**\\n\\nSo, what if we build a graph of all the valid paths we can take given the digits as edges? We\\'ll mark whether each node is a valid leaf or not. The result is that when we traverse the graph e.g. 64 and 46 both end up at the same leaf node. The benefit of this approach is that we will be able to weed out a number as soon as we encounter a digit that is not on a valid path, since the tail node won\\'t have an edge for the next digit. Compare that to the \"standard\" solution where we *have* to have all the digits of `n` before checking if it\\'s a valid power of two (yeah, yeah, big-O time complexities are the same, but let\\'s have some fun :) ) We\\'ll use a separate program to compute the graph (I have pasted that in at the very bottom of this post), and we\\'ll use the computed graph as a constant that gets compiled into our program for solving the problem. Here is the finished solution (it\\'s long :) ):\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(mut n: i32) -> bool {\\n        let mut node = 0;\\n        while n > 0 {\\n            let digit = (n % 10) as usize;\\n            match GRAPH[node].0[digit] {\\n                0 => return false,\\n                next_node => node = next_node,\\n            }\\n            n /= 10;\\n        }\\n        GRAPH[node].1\\n    }\\n}\\n\\nconst GRAPH: [([usize; N_DIGITS], bool); 1203] = [\\n    ([31, 1, 2, 7, 3, 17, 5, 87, 4, 38], false),\\n    ([30, 139, 13, 75, 25, 20, 6, 123, 12, 54], true),\\n    ([29, 13, 162, 8, 21, 18, 16, 94, 10, 52], true),\\n    ([27, 25, 21, 73, 154, 184, 9, 261, 32, 43], true),\\n    ([37, 12, 10, 66, 32, 176, 55, 76, 164, 48], true),\\n    ([47, 6, 16, 71, 9, 14, 96, 88, 55, 39], false),\\n    ([273, 460, 153, 72, 70, 269, 457, 250, 62, 1072], true),\\n    ([136, 75, 8, 512, 73, 107, 71, 92, 66, 363], false),\\n    ([132, 128, 733, 515, 511, 501, 95, 93, 86, 1082], true),\\n    ([46, 70, 147, 68, 141, 265, 581, 246, 56, 40], true),\\n    ([36, 11, 183, 86, 33, 180, 85, 83, 174, 49], false),\\n    ([1153, 672, 670, 667, 661, 1147, 1138, 649, 0, 50], true),\\n    ([237, 673, 11, 67, 65, 233, 62, 215, 557, 51], false),\\n    ([28, 137, 163, 128, 22, 19, 153, 118, 11, 53], false),\\n    ([271, 269, 15, 104, 265, 102, 97, 238, 218, 1044], false),\\n    ([1190, 1188, 0, 868, 867, 860, 842, 1162, 792, 1053], true),\\n    ([1196, 153, 151, 95, 147, 15, 454, 91, 85, 1068], false),\\n    ([278, 20, 18, 107, 184, 105, 14, 253, 176, 303], false),\\n    ([338, 19, 187, 501, 185, 482, 15, 322, 180, 304], false),\\n    ([337, 0, 334, 1197, 0, 0, 1188, 327, 1147, 309], true),\\n    ([277, 0, 19, 1200, 274, 0, 269, 258, 233, 312], false),\\n    ([24, 22, 160, 511, 155, 185, 147, 713, 33, 0], false),\\n    ([23, 731, 161, 727, 158, 0, 150, 717, 661, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 23, 0, 0, 0, 0, 0, 0, 34, 0], false),\\n    ([26, 732, 22, 74, 159, 274, 70, 262, 65, 361], false),\\n    ([0, 0, 23, 381, 379, 275, 272, 263, 236, 362], false),\\n    ([0, 26, 24, 382, 380, 276, 46, 264, 35, 44], false),\\n    ([0, 138, 339, 131, 23, 337, 1195, 121, 1153, 319], false),\\n    ([0, 28, 340, 132, 24, 338, 1196, 122, 36, 320], false),\\n    ([0, 140, 28, 135, 26, 277, 273, 126, 237, 321], false),\\n    ([0, 30, 29, 136, 27, 278, 47, 127, 37, 45], false),\\n    ([35, 65, 33, 63, 819, 177, 56, 211, 171, 0], false),\\n    ([34, 661, 182, 652, 822, 178, 798, 632, 172, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 236, 34, 0, 0, 232, 227, 214, 556, 0], false),\\n    ([0, 1153, 0, 1151, 34, 1149, 1140, 1124, 0, 993], false),\\n    ([0, 237, 36, 407, 35, 235, 229, 217, 405, 995], false),\\n    ([45, 54, 52, 363, 43, 303, 39, 279, 48, 0], false),\\n    ([42, 1072, 1068, 1060, 40, 1044, 0, 996, 936, 0], false),\\n    ([41, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 1073, 1071, 1067, 41, 1059, 0, 1027, 967, 0], false),\\n    ([44, 361, 0, 357, 341, 0, 40, 0, 0, 0], false),\\n    ([0, 362, 0, 360, 356, 0, 41, 0, 0, 0], false),\\n    ([0, 321, 320, 366, 44, 314, 42, 302, 995, 0], false),\\n    ([0, 272, 0, 0, 0, 268, 584, 249, 227, 41], false),\\n    ([0, 273, 1196, 408, 46, 271, 586, 252, 229, 42], false),\\n    ([995, 51, 49, 984, 0, 968, 936, 872, 0, 0], false),\\n    ([993, 50, 0, 985, 0, 977, 961, 929, 0, 0], false),\\n    ([992, 0, 0, 986, 0, 978, 962, 930, 0, 0], true),\\n    ([994, 0, 50, 989, 0, 981, 965, 933, 0, 0], false),\\n    ([320, 53, 315, 1082, 0, 304, 1068, 292, 49, 0], false),\\n    ([319, 0, 316, 1083, 0, 309, 1069, 297, 50, 0], false),\\n    ([321, 0, 53, 364, 361, 312, 1072, 300, 51, 0], false),\\n    ([229, 62, 85, 60, 56, 218, 567, 77, 399, 936], false),\\n    ([227, 59, 798, 57, 793, 219, 568, 196, 548, 0], false),\\n    ([0, 58, 797, 0, 794, 787, 765, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([226, 0, 0, 58, 0, 220, 569, 197, 549, 0], false),\\n    ([406, 61, 84, 0, 57, 790, 768, 78, 400, 953], false),\\n    ([1137, 0, 1134, 0, 58, 1128, 0, 1101, 0, 958], false),\\n    ([228, 0, 1138, 61, 59, 223, 572, 200, 552, 965], false),\\n    ([0, 64, 652, 0, 820, 815, 57, 623, 0, 0], false),\\n    ([0, 658, 656, 0, 0, 0, 58, 630, 0, 0], false),\\n    ([236, 663, 661, 64, 0, 230, 59, 212, 554, 0], false),\\n    ([407, 67, 86, 0, 63, 817, 60, 81, 403, 984], false),\\n    ([1152, 669, 667, 0, 64, 1144, 61, 644, 0, 989], false),\\n    ([0, 69, 871, 0, 869, 865, 847, 0, 57, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 58, 0], false),\\n    ([272, 0, 150, 69, 146, 266, 582, 247, 59, 0], false),\\n    ([408, 72, 95, 0, 68, 104, 101, 89, 60, 1060], false),\\n    ([1194, 0, 1191, 0, 69, 1185, 0, 1169, 61, 1065], false),\\n    ([382, 74, 511, 507, 375, 491, 68, 704, 63, 357], false),\\n    ([381, 729, 727, 0, 376, 0, 69, 711, 64, 358], false),\\n    ([135, 133, 128, 0, 74, 1200, 72, 113, 67, 364], false),\\n    ([217, 215, 83, 81, 211, 203, 77, 587, 516, 872], false),\\n    ([202, 200, 80, 78, 196, 188, 559, 0, 517, 873], false),\\n    ([1103, 1101, 79, 0, 0, 1086, 0, 0, 0, 890], false),\\n    ([1100, 1098, 0, 0, 0, 1087, 0, 0, 0, 891], true),\\n    ([1106, 1104, 0, 79, 0, 1094, 0, 0, 0, 898], false),\\n    ([1122, 644, 82, 0, 623, 1107, 78, 606, 0, 921], false),\\n    ([1120, 642, 639, 0, 624, 1108, 79, 607, 0, 922], false),\\n    ([1124, 649, 646, 82, 632, 1115, 80, 615, 0, 929], false),\\n    ([1136, 1134, 0, 0, 797, 791, 769, 79, 0, 954], false),\\n    ([1140, 1138, 0, 84, 798, 792, 770, 80, 0, 961], false),\\n    ([1151, 667, 664, 0, 652, 818, 84, 82, 0, 985], false),\\n    ([127, 123, 94, 92, 261, 253, 88, 409, 76, 279], false),\\n    ([252, 250, 91, 89, 246, 238, 445, 428, 77, 996], false),\\n    ([1171, 1169, 90, 0, 0, 1154, 0, 0, 78, 1013], false),\\n    ([1168, 1166, 0, 0, 0, 1155, 0, 0, 79, 1014], false),\\n    ([1173, 451, 0, 90, 0, 1162, 446, 435, 80, 1021], false),\\n    ([117, 113, 93, 0, 704, 1174, 89, 692, 81, 1036], false),\\n    ([112, 108, 720, 0, 705, 1175, 90, 693, 82, 1037], false),\\n    ([122, 118, 330, 93, 713, 322, 91, 440, 83, 292], false),\\n    ([1193, 1191, 0, 0, 871, 868, 850, 90, 84, 1061], false),\\n    ([586, 457, 454, 101, 581, 97, 0, 445, 567, 0], false),\\n    ([0, 0, 842, 100, 833, 98, 0, 0, 737, 0], false),\\n    ([0, 0, 832, 99, 823, 0, 0, 0, 738, 0], false),\\n    ([0, 0, 831, 0, 828, 0, 0, 0, 747, 0], true),\\n    ([0, 0, 841, 0, 838, 99, 0, 0, 758, 0], false),\\n    ([0, 0, 850, 0, 847, 100, 0, 0, 768, 0], false),\\n    ([0, 0, 860, 103, 851, 0, 98, 0, 771, 0], false),\\n    ([0, 0, 859, 0, 856, 0, 99, 0, 780, 0], false),\\n    ([1187, 1185, 868, 0, 865, 103, 100, 1154, 790, 1045], false),\\n    ([0, 0, 482, 106, 461, 0, 102, 0, 799, 0], false),\\n    ([0, 0, 481, 477, 470, 0, 103, 0, 808, 0], false),\\n    (\\n        [1202, 1200, 501, 497, 491, 106, 104, 1174, 817, 1074],\\n        false,\\n    ),\\n    ([111, 109, 721, 0, 709, 1176, 1166, 697, 642, 1038], false),\\n    ([110, 0, 722, 0, 710, 0, 0, 698, 643, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 110, 0, 0, 0, 1177, 1167, 0, 1119, 1039], false),\\n    ([0, 111, 0, 0, 0, 1178, 1168, 0, 1120, 1040], false),\\n    ([116, 114, 108, 0, 711, 1179, 1169, 699, 644, 1041], false),\\n    ([115, 0, 109, 0, 712, 0, 0, 700, 645, 0], false),\\n    ([0, 0, 110, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 115, 111, 0, 0, 1180, 1170, 0, 1121, 1042], false),\\n    ([0, 116, 112, 0, 0, 1181, 1171, 0, 1122, 1043], false),\\n    ([121, 119, 331, 108, 717, 327, 451, 441, 649, 297], false),\\n    ([120, 0, 723, 109, 718, 0, 452, 442, 650, 0], false),\\n    ([0, 0, 0, 110, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 120, 332, 111, 0, 328, 1172, 0, 1123, 298], false),\\n    ([0, 121, 333, 112, 0, 329, 1173, 0, 1124, 299], false),\\n    ([126, 124, 118, 113, 262, 258, 250, 443, 215, 300], false),\\n    ([125, 0, 119, 114, 719, 0, 453, 444, 651, 0], false),\\n    ([0, 0, 120, 115, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 125, 121, 116, 263, 259, 251, 0, 216, 301], false),\\n    ([0, 126, 122, 117, 264, 260, 252, 0, 217, 302], false),\\n    ([131, 129, 734, 0, 727, 1197, 1191, 108, 667, 1083], false),\\n    ([130, 0, 735, 0, 728, 0, 0, 109, 668, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 110, 0, 0], false),\\n    ([0, 130, 0, 0, 0, 1198, 1192, 111, 1150, 1084], false),\\n    ([0, 131, 0, 0, 0, 1199, 1193, 112, 1151, 1085], false),\\n    ([134, 0, 129, 0, 729, 0, 0, 114, 669, 0], false),\\n    ([0, 0, 130, 0, 0, 0, 0, 115, 0, 0], false),\\n    ([0, 134, 131, 0, 381, 1201, 1194, 116, 1152, 365], false),\\n    ([0, 135, 132, 0, 382, 1202, 408, 117, 407, 366], false),\\n    ([138, 0, 736, 129, 731, 0, 459, 119, 672, 0], false),\\n    ([0, 0, 0, 130, 0, 0, 0, 120, 0, 0], false),\\n    ([140, 0, 137, 133, 732, 0, 460, 124, 673, 0], false),\\n    ([0, 0, 138, 134, 0, 0, 0, 125, 0, 0], false),\\n    ([0, 146, 142, 869, 0, 861, 843, 0, 793, 0], false),\\n    ([0, 145, 143, 870, 0, 864, 846, 0, 796, 0], false),\\n    ([0, 144, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 144, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 145, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 150, 148, 871, 142, 867, 849, 0, 798, 0], false),\\n    ([0, 149, 0, 0, 143, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 144, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 149, 0, 145, 0, 0, 0, 0, 0], false),\\n    ([0, 152, 0, 0, 148, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 149, 0, 0, 0, 0, 0], false),\\n    (\\n        [1195, 459, 152, 1191, 150, 1188, 455, 451, 1138, 1069],\\n        false,\\n    ),\\n    ([380, 159, 155, 375, 367, 483, 141, 0, 819, 341], false),\\n    ([0, 158, 156, 506, 0, 490, 142, 0, 822, 0], false),\\n    ([0, 157, 0, 0, 0, 0, 143, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 144, 0, 0, 0], false),\\n    ([0, 0, 157, 0, 0, 0, 145, 0, 0, 0], false),\\n    ([379, 0, 158, 376, 372, 0, 146, 0, 0, 354], false),\\n    ([0, 161, 0, 724, 156, 186, 148, 714, 182, 0], false),\\n    ([0, 730, 0, 725, 157, 0, 149, 715, 659, 0], false),\\n    ([340, 163, 0, 733, 160, 187, 151, 330, 183, 315], false),\\n    ([339, 736, 0, 734, 161, 334, 152, 331, 670, 316], false),\\n    ([405, 557, 174, 403, 171, 165, 399, 516, 383, 0], false),\\n    ([0, 0, 169, 0, 166, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 167, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 168, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 170, 0, 167, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 168, 0, 0, 0, 0, 0], false),\\n    ([556, 554, 172, 0, 0, 166, 548, 533, 0, 0], false),\\n    ([0, 0, 173, 0, 0, 167, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 168, 0, 0, 0, 0], false),\\n    ([0, 0, 175, 0, 172, 169, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 173, 170, 0, 0, 0, 0], false),\\n    ([235, 233, 180, 817, 177, 799, 218, 203, 165, 968], false),\\n    ([232, 230, 178, 815, 811, 800, 219, 204, 166, 0], false),\\n    ([0, 0, 179, 816, 814, 807, 789, 0, 167, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 168, 0], false),\\n    ([1149, 1147, 181, 818, 178, 810, 792, 1115, 169, 977], false),\\n    ([0, 0, 0, 0, 179, 0, 0, 0, 170, 0], false),\\n    ([0, 659, 0, 653, 0, 179, 0, 633, 173, 0], false),\\n    ([0, 670, 0, 664, 182, 181, 0, 646, 175, 0], false),\\n    ([276, 274, 185, 491, 483, 461, 265, 254, 177, 0], false),\\n    ([0, 0, 186, 496, 490, 476, 867, 0, 178, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 179, 0], false),\\n    ([336, 334, 0, 0, 186, 0, 0, 323, 181, 305], false),\\n    ([195, 193, 1094, 1086, 189, 0, 0, 0, 0, 874], false),\\n    ([192, 190, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([191, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 191, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([194, 0, 1095, 1091, 190, 0, 0, 0, 0, 887], false),\\n    ([0, 0, 1096, 1092, 191, 0, 0, 0, 0, 888], false),\\n    ([0, 194, 1097, 1093, 192, 0, 0, 0, 0, 889], false),\\n    ([199, 197, 0, 0, 0, 189, 560, 0, 526, 0], false),\\n    ([198, 0, 0, 0, 0, 190, 561, 0, 527, 0], false),\\n    ([0, 0, 0, 0, 0, 191, 562, 0, 528, 0], false),\\n    ([0, 198, 0, 0, 0, 192, 563, 0, 529, 0], false),\\n    ([201, 0, 1104, 1101, 197, 193, 564, 0, 530, 902], false),\\n    ([0, 0, 1105, 1102, 198, 194, 565, 0, 531, 903], false),\\n    ([0, 201, 1106, 1103, 199, 195, 566, 0, 532, 904], false),\\n    ([210, 208, 1115, 1107, 204, 0, 188, 0, 0, 905], false),\\n    ([207, 205, 0, 0, 0, 0, 189, 0, 0, 0], false),\\n    ([206, 0, 0, 0, 0, 0, 190, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 191, 0, 0, 0], false),\\n    ([0, 206, 0, 0, 0, 0, 192, 0, 0, 0], false),\\n    ([209, 0, 1116, 1112, 205, 0, 193, 0, 0, 918], false),\\n    ([0, 0, 1117, 1113, 206, 0, 194, 0, 0, 919], false),\\n    ([0, 209, 1118, 1114, 207, 0, 195, 0, 0, 920], false),\\n    ([214, 212, 632, 623, 0, 204, 196, 588, 533, 0], false),\\n    ([213, 638, 636, 630, 0, 205, 197, 604, 534, 0], false),\\n    ([0, 0, 0, 0, 0, 206, 198, 0, 535, 0], false),\\n    ([0, 213, 0, 0, 0, 207, 199, 0, 536, 0], false),\\n    ([216, 651, 649, 644, 212, 208, 200, 621, 537, 933], false),\\n    ([0, 0, 1123, 1121, 213, 209, 201, 0, 538, 934], false),\\n    ([0, 216, 1124, 1122, 214, 210, 202, 0, 539, 935], false),\\n    ([225, 223, 792, 790, 219, 771, 737, 188, 0, 937], false),\\n    ([222, 220, 789, 787, 783, 772, 750, 189, 0, 0], false),\\n    ([221, 0, 0, 0, 0, 0, 0, 190, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 191, 0, 0], false),\\n    ([0, 221, 0, 0, 0, 0, 0, 192, 0, 0], false),\\n    ([224, 0, 1131, 1128, 220, 0, 0, 193, 0, 950], false),\\n    ([0, 0, 1132, 1129, 221, 0, 0, 194, 0, 951], false),\\n    ([0, 224, 1133, 1130, 222, 0, 0, 195, 0, 952], false),\\n    ([0, 0, 0, 0, 0, 221, 570, 198, 550, 0], false),\\n    ([0, 226, 0, 0, 0, 222, 571, 199, 551, 0], false),\\n    ([0, 0, 1139, 1137, 226, 224, 573, 201, 553, 966], false),\\n    ([0, 228, 1140, 406, 227, 225, 574, 202, 402, 967], false),\\n    ([231, 0, 0, 0, 0, 0, 220, 205, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 221, 206, 0, 0], false),\\n    ([0, 231, 0, 0, 0, 0, 222, 207, 0, 0], false),\\n    ([234, 0, 1147, 1144, 230, 0, 223, 208, 0, 981], false),\\n    ([0, 0, 1148, 1145, 231, 0, 224, 209, 0, 982], false),\\n    ([0, 234, 1149, 1146, 232, 0, 225, 210, 0, 983], false),\\n    ([0, 0, 0, 0, 0, 231, 226, 213, 555, 0], false),\\n    ([0, 0, 1153, 1152, 236, 234, 228, 216, 558, 994], false),\\n    ([245, 243, 1162, 1154, 239, 0, 0, 0, 188, 997], false),\\n    ([242, 240, 0, 0, 0, 0, 0, 0, 189, 0], false),\\n    ([241, 0, 0, 0, 0, 0, 0, 0, 190, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 191, 0], false),\\n    ([0, 241, 0, 0, 0, 0, 0, 0, 192, 0], false),\\n    ([244, 0, 1163, 1159, 240, 0, 0, 0, 193, 1010], false),\\n    ([0, 0, 1164, 1160, 241, 0, 0, 0, 194, 1011], false),\\n    ([0, 244, 1165, 1161, 242, 0, 0, 0, 195, 1012], false),\\n    ([249, 247, 0, 0, 0, 239, 575, 0, 196, 0], false),\\n    ([248, 0, 0, 0, 0, 240, 576, 0, 197, 0], false),\\n    ([0, 0, 0, 0, 0, 241, 577, 0, 198, 0], false),\\n    ([0, 248, 0, 0, 0, 242, 578, 0, 199, 0], false),\\n    ([251, 453, 451, 1169, 247, 243, 449, 438, 200, 1025], false),\\n    ([0, 0, 1172, 1170, 248, 244, 579, 0, 201, 1026], false),\\n    ([0, 251, 1173, 1171, 249, 245, 580, 0, 202, 1027], false),\\n    ([260, 258, 322, 1174, 254, 0, 238, 0, 203, 280], false),\\n    ([257, 255, 0, 0, 0, 0, 239, 0, 204, 0], false),\\n    ([256, 0, 0, 0, 0, 0, 240, 0, 205, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 241, 0, 206, 0], false),\\n    ([0, 256, 0, 0, 0, 0, 242, 0, 207, 0], false),\\n    ([259, 0, 327, 1179, 255, 0, 243, 0, 208, 289], false),\\n    ([0, 0, 328, 1180, 256, 0, 244, 0, 209, 290], false),\\n    ([0, 259, 329, 1181, 257, 0, 245, 0, 210, 291], false),\\n    ([264, 262, 713, 704, 0, 254, 246, 674, 211, 0], false),\\n    ([263, 719, 717, 711, 0, 255, 247, 690, 212, 0], false),\\n    ([0, 0, 0, 0, 0, 256, 248, 0, 213, 0], false),\\n    ([0, 263, 0, 0, 0, 257, 249, 0, 214, 0], false),\\n    ([268, 266, 867, 865, 861, 851, 833, 239, 219, 0], false),\\n    ([267, 0, 0, 0, 0, 0, 0, 240, 220, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 241, 221, 0], false),\\n    ([0, 267, 0, 0, 0, 0, 0, 242, 222, 0], false),\\n    ([270, 0, 1188, 1185, 266, 0, 0, 243, 223, 1057], false),\\n    ([0, 0, 1189, 1186, 267, 0, 0, 244, 224, 1058], false),\\n    ([0, 270, 1190, 1187, 268, 0, 0, 245, 225, 1059], false),\\n    ([0, 0, 0, 0, 0, 267, 583, 248, 226, 0], false),\\n    ([0, 0, 1195, 1194, 272, 270, 585, 251, 228, 1073], false),\\n    ([275, 0, 0, 0, 0, 0, 266, 255, 230, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 267, 256, 231, 0], false),\\n    ([0, 275, 0, 0, 0, 0, 268, 257, 232, 0], false),\\n    ([0, 0, 337, 1201, 275, 0, 270, 259, 234, 313], false),\\n    ([0, 277, 338, 1202, 276, 0, 271, 260, 235, 314], false),\\n    ([302, 300, 292, 1036, 0, 280, 996, 0, 872, 0], false),\\n    ([291, 289, 281, 1028, 0, 0, 997, 0, 905, 0], false),\\n    ([288, 286, 282, 1029, 0, 0, 1006, 0, 914, 0], false),\\n    ([285, 283, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([284, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 284, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([287, 0, 283, 1030, 0, 0, 1007, 0, 915, 0], false),\\n    ([0, 0, 284, 1031, 0, 0, 1008, 0, 916, 0], false),\\n    ([0, 287, 285, 1032, 0, 0, 1009, 0, 917, 0], false),\\n    ([290, 0, 286, 1033, 0, 0, 1010, 0, 918, 0], false),\\n    ([0, 0, 287, 1034, 0, 0, 1011, 0, 919, 0], false),\\n    ([0, 290, 288, 1035, 0, 0, 1012, 0, 920, 0], false),\\n    ([299, 297, 293, 1037, 0, 281, 1021, 0, 929, 0], false),\\n    ([296, 294, 0, 0, 0, 282, 0, 0, 0, 0], false),\\n    ([295, 0, 0, 0, 0, 283, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 284, 0, 0, 0, 0], false),\\n    ([0, 295, 0, 0, 0, 285, 0, 0, 0, 0], false),\\n    ([298, 0, 294, 1038, 0, 286, 1022, 0, 930, 0], false),\\n    ([0, 0, 295, 1039, 0, 287, 1023, 0, 931, 0], false),\\n    ([0, 298, 296, 1040, 0, 288, 1024, 0, 932, 0], false),\\n    ([301, 0, 297, 1041, 0, 289, 1025, 0, 933, 0], false),\\n    ([0, 0, 298, 1042, 0, 290, 1026, 0, 934, 0], false),\\n    ([0, 301, 299, 1043, 0, 291, 1027, 0, 935, 0], false),\\n    ([314, 312, 304, 1074, 0, 0, 1044, 280, 968, 0], false),\\n    ([311, 309, 305, 1075, 0, 0, 1053, 281, 977, 0], false),\\n    ([308, 306, 0, 0, 0, 0, 0, 282, 0, 0], false),\\n    ([307, 0, 0, 0, 0, 0, 0, 283, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 284, 0, 0], false),\\n    ([0, 307, 0, 0, 0, 0, 0, 285, 0, 0], false),\\n    ([310, 0, 306, 1076, 0, 0, 1054, 286, 978, 0], false),\\n    ([0, 0, 307, 1077, 0, 0, 1055, 287, 979, 0], false),\\n    ([0, 310, 308, 1078, 0, 0, 1056, 288, 980, 0], false),\\n    ([313, 0, 309, 1079, 0, 0, 1057, 289, 981, 0], false),\\n    ([0, 0, 310, 1080, 0, 0, 1058, 290, 982, 0], false),\\n    ([0, 313, 311, 1081, 0, 0, 1059, 291, 983, 0], false),\\n    ([318, 316, 0, 0, 0, 305, 0, 293, 0, 0], false),\\n    ([317, 0, 0, 0, 0, 306, 0, 294, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 307, 0, 295, 0, 0], false),\\n    ([0, 317, 0, 0, 0, 308, 0, 296, 0, 0], false),\\n    ([0, 0, 317, 1084, 0, 310, 1070, 298, 992, 0], false),\\n    ([0, 319, 318, 1085, 0, 311, 1071, 299, 993, 0], false),\\n    ([0, 0, 319, 365, 362, 313, 1073, 301, 994, 0], false),\\n    ([329, 327, 323, 1175, 0, 0, 1162, 0, 1115, 281], false),\\n    ([326, 324, 0, 0, 0, 0, 0, 0, 0, 282], false),\\n    ([325, 0, 0, 0, 0, 0, 0, 0, 0, 283], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 284], false),\\n    ([0, 325, 0, 0, 0, 0, 0, 0, 0, 285], false),\\n    ([328, 0, 324, 1176, 0, 0, 1163, 0, 1116, 286], false),\\n    ([0, 0, 325, 1177, 0, 0, 1164, 0, 1117, 287], false),\\n    ([0, 328, 326, 1178, 0, 0, 1165, 0, 1118, 288], false),\\n    ([333, 331, 0, 720, 714, 323, 0, 701, 646, 293], false),\\n    ([332, 723, 0, 721, 715, 324, 0, 702, 647, 294], false),\\n    ([0, 0, 0, 0, 0, 325, 0, 0, 0, 295], false),\\n    ([0, 332, 0, 0, 0, 326, 0, 0, 0, 296], false),\\n    ([335, 0, 0, 0, 0, 0, 0, 324, 0, 306], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 325, 0, 307], false),\\n    ([0, 335, 0, 0, 0, 0, 0, 326, 0, 308], false),\\n    ([0, 0, 335, 1198, 0, 0, 1189, 328, 1148, 310], false),\\n    ([0, 337, 336, 1199, 0, 0, 1190, 329, 1149, 311], false),\\n    ([0, 0, 0, 0, 0, 335, 0, 332, 0, 317], false),\\n    ([0, 339, 0, 0, 0, 336, 0, 333, 0, 318], false),\\n    ([356, 354, 0, 350, 342, 0, 0, 0, 0, 0], false),\\n    ([349, 347, 0, 343, 0, 0, 0, 0, 0, 0], false),\\n    ([346, 344, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([345, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 345, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([348, 0, 0, 344, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 345, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 348, 0, 346, 0, 0, 0, 0, 0, 0], false),\\n    ([353, 351, 0, 0, 343, 0, 0, 0, 0, 0], false),\\n    ([352, 0, 0, 0, 344, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 345, 0, 0, 0, 0, 0], false),\\n    ([0, 352, 0, 0, 346, 0, 0, 0, 0, 0], false),\\n    ([355, 0, 0, 351, 347, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 352, 348, 0, 0, 0, 0, 0], false),\\n    ([0, 355, 0, 353, 349, 0, 0, 0, 0, 0], false),\\n    ([360, 358, 0, 0, 350, 0, 0, 0, 0, 0], false),\\n    ([359, 0, 0, 0, 351, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 352, 0, 0, 0, 0, 0], false),\\n    ([0, 359, 0, 0, 353, 0, 0, 0, 0, 0], false),\\n    ([362, 0, 0, 358, 354, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 359, 355, 0, 0, 0, 0, 0], false),\\n    ([366, 364, 1082, 0, 357, 1074, 1060, 1036, 984, 0], false),\\n    ([365, 0, 1083, 0, 358, 1079, 1065, 1041, 989, 0], false),\\n    ([0, 0, 1084, 0, 359, 1080, 1066, 1042, 990, 0], false),\\n    ([0, 365, 1085, 0, 360, 1081, 1067, 1043, 991, 0], false),\\n    ([374, 372, 0, 368, 0, 0, 0, 0, 0, 342], false),\\n    ([371, 369, 0, 0, 0, 0, 0, 0, 0, 343], false),\\n    ([370, 0, 0, 0, 0, 0, 0, 0, 0, 344], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 345], false),\\n    ([0, 370, 0, 0, 0, 0, 0, 0, 0, 346], false),\\n    ([373, 0, 0, 369, 0, 0, 0, 0, 0, 347], false),\\n    ([0, 0, 0, 370, 0, 0, 0, 0, 0, 348], false),\\n    ([0, 373, 0, 371, 0, 0, 0, 0, 0, 349], false),\\n    ([378, 376, 506, 502, 368, 484, 869, 0, 820, 350], false),\\n    ([377, 0, 0, 0, 369, 0, 0, 0, 0, 351], false),\\n    ([0, 0, 0, 0, 370, 0, 0, 0, 0, 352], false),\\n    ([0, 377, 0, 0, 371, 0, 0, 0, 0, 353], false),\\n    ([0, 0, 0, 377, 373, 0, 0, 0, 0, 355], false),\\n    ([0, 379, 0, 378, 374, 0, 0, 0, 0, 356], false),\\n    ([0, 0, 0, 0, 377, 0, 0, 0, 0, 359], false),\\n    ([0, 381, 0, 0, 378, 0, 0, 0, 0, 360], false),\\n    ([398, 0, 0, 396, 0, 0, 392, 0, 384, 0], false),\\n    ([391, 0, 0, 389, 0, 0, 385, 0, 0, 0], false),\\n    ([388, 0, 0, 386, 0, 0, 0, 0, 0, 0], false),\\n    ([387, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 387, 0, 0, 0, 0, 0, 0], false),\\n    ([390, 0, 0, 0, 0, 0, 386, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 387, 0, 0, 0], false),\\n    ([0, 0, 0, 390, 0, 0, 388, 0, 0, 0], false),\\n    ([395, 0, 0, 393, 0, 0, 0, 0, 385, 0], false),\\n    ([394, 0, 0, 0, 0, 0, 0, 0, 386, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 387, 0], false),\\n    ([0, 0, 0, 394, 0, 0, 0, 0, 388, 0], false),\\n    ([397, 0, 0, 0, 0, 0, 393, 0, 389, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 394, 0, 390, 0], false),\\n    ([0, 0, 0, 397, 0, 0, 395, 0, 391, 0], false),\\n    ([402, 552, 0, 400, 548, 0, 540, 517, 392, 0], false),\\n    ([401, 0, 0, 0, 0, 0, 0, 0, 393, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 394, 0], false),\\n    ([0, 553, 0, 401, 551, 0, 547, 532, 395, 0], false),\\n    ([404, 0, 0, 0, 0, 0, 400, 0, 396, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 401, 0, 397, 0], false),\\n    ([0, 558, 0, 404, 556, 0, 402, 539, 398, 0], false),\\n    ([0, 1137, 1136, 0, 0, 1130, 0, 1103, 401, 960], false),\\n    ([0, 1152, 1151, 0, 0, 1146, 406, 1122, 404, 991], false),\\n    ([0, 1194, 1193, 0, 0, 1187, 0, 1171, 406, 1067], false),\\n    ([0, 443, 440, 692, 674, 0, 428, 410, 587, 0], false),\\n    ([0, 426, 423, 0, 0, 0, 411, 0, 0, 0], false),\\n    ([0, 421, 418, 0, 0, 0, 412, 0, 0, 0], false),\\n    ([0, 416, 413, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 414, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 415, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 417, 414, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 415, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 419, 0, 0, 0, 0, 413, 0, 0, 0], false),\\n    ([0, 420, 0, 0, 0, 0, 414, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 415, 0, 0, 0], false),\\n    ([0, 422, 419, 0, 0, 0, 416, 0, 0, 0], false),\\n    ([0, 0, 420, 0, 0, 0, 417, 0, 0, 0], false),\\n    ([0, 424, 0, 0, 0, 0, 418, 0, 0, 0], false),\\n    ([0, 425, 0, 0, 0, 0, 419, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 420, 0, 0, 0], false),\\n    ([0, 427, 424, 0, 0, 0, 421, 0, 0, 0], false),\\n    ([0, 0, 425, 0, 0, 0, 422, 0, 0, 0], false),\\n    ([0, 438, 435, 0, 0, 0, 429, 411, 0, 0], false),\\n    ([0, 433, 430, 0, 0, 0, 0, 412, 0, 0], false),\\n    ([0, 431, 0, 0, 0, 0, 0, 413, 0, 0], false),\\n    ([0, 432, 0, 0, 0, 0, 0, 414, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 415, 0, 0], false),\\n    ([0, 434, 431, 0, 0, 0, 0, 416, 0, 0], false),\\n    ([0, 0, 432, 0, 0, 0, 0, 417, 0, 0], false),\\n    ([0, 436, 0, 0, 0, 0, 430, 418, 0, 0], false),\\n    ([0, 437, 0, 0, 0, 0, 431, 419, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 432, 420, 0, 0], false),\\n    ([0, 439, 436, 0, 0, 0, 433, 421, 0, 0], false),\\n    ([0, 0, 437, 0, 0, 0, 434, 422, 0, 0], false),\\n    ([0, 441, 701, 693, 684, 0, 435, 423, 615, 0], false),\\n    ([0, 442, 702, 697, 688, 0, 436, 424, 619, 0], false),\\n    ([0, 0, 703, 698, 689, 0, 437, 425, 620, 0], false),\\n    ([0, 444, 441, 699, 690, 0, 438, 426, 621, 0], false),\\n    ([0, 0, 442, 700, 691, 0, 439, 427, 622, 0], false),\\n    ([580, 449, 446, 0, 575, 0, 0, 429, 559, 0], false),\\n    ([0, 447, 0, 0, 0, 0, 0, 430, 0, 0], false),\\n    ([0, 448, 0, 0, 0, 0, 0, 431, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 432, 0, 0], false),\\n    ([579, 450, 447, 0, 576, 0, 0, 433, 564, 0], false),\\n    ([0, 0, 448, 0, 0, 0, 0, 434, 0, 0], false),\\n    ([1172, 452, 0, 1166, 0, 1163, 447, 436, 1104, 1022], false),\\n    ([0, 0, 0, 0, 0, 0, 448, 437, 0, 0], false),\\n    ([0, 0, 452, 0, 0, 0, 450, 439, 0, 0], false),\\n    ([0, 455, 0, 850, 849, 842, 0, 446, 770, 0], false),\\n    ([0, 456, 0, 0, 0, 0, 0, 447, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 448, 0, 0], false),\\n    ([585, 458, 455, 0, 582, 0, 0, 449, 572, 0], false),\\n    ([0, 0, 456, 0, 0, 0, 0, 450, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 456, 452, 0, 0], false),\\n    ([0, 0, 459, 0, 0, 0, 458, 453, 0, 0], false),\\n    ([0, 0, 476, 470, 462, 0, 851, 0, 800, 0], false),\\n    ([0, 0, 469, 463, 0, 0, 852, 0, 801, 0], false),\\n    ([0, 0, 468, 464, 0, 0, 853, 0, 802, 0], false),\\n    ([0, 0, 467, 465, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 466, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 466, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 467, 0, 0, 854, 0, 803, 0], false),\\n    ([0, 0, 0, 468, 0, 0, 855, 0, 804, 0], false),\\n    ([0, 0, 475, 471, 463, 0, 856, 0, 805, 0], false),\\n    ([0, 0, 474, 472, 464, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 473, 0, 465, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 466, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 473, 467, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 474, 468, 0, 857, 0, 806, 0], false),\\n    ([0, 0, 0, 475, 469, 0, 858, 0, 807, 0], false),\\n    ([0, 0, 480, 478, 471, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 479, 0, 472, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 473, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 479, 474, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 480, 475, 0, 859, 0, 809, 0], false),\\n    ([0, 0, 0, 481, 476, 0, 860, 0, 810, 0], false),\\n    ([0, 0, 490, 484, 0, 462, 861, 0, 811, 0], false),\\n    ([0, 0, 489, 485, 0, 463, 862, 0, 812, 0], false),\\n    ([0, 0, 488, 486, 0, 464, 0, 0, 0, 0], false),\\n    ([0, 0, 487, 0, 0, 465, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 466, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 487, 0, 467, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 488, 0, 468, 863, 0, 813, 0], false),\\n    ([0, 0, 0, 489, 0, 469, 864, 0, 814, 0], false),\\n    ([0, 0, 496, 492, 484, 470, 865, 0, 815, 0], false),\\n    ([0, 0, 495, 493, 485, 471, 0, 0, 0, 0], false),\\n    ([0, 0, 494, 0, 486, 472, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 487, 473, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 494, 488, 474, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 495, 489, 475, 866, 0, 816, 0], false),\\n    ([0, 0, 500, 498, 492, 477, 0, 0, 0, 0], false),\\n    ([0, 0, 499, 0, 493, 478, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 494, 479, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 499, 495, 480, 0, 0, 0, 0], false),\\n    ([1199, 1197, 0, 500, 496, 481, 868, 1175, 818, 1075], false),\\n    ([0, 0, 505, 503, 0, 485, 0, 0, 0, 0], false),\\n    ([0, 0, 504, 0, 0, 486, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 487, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 504, 0, 488, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 505, 0, 489, 870, 0, 821, 0], false),\\n    ([0, 0, 510, 508, 502, 492, 0, 0, 0, 0], false),\\n    ([0, 0, 509, 0, 503, 493, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 504, 494, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 509, 505, 495, 0, 0, 0, 0], false),\\n    ([0, 727, 724, 510, 506, 496, 871, 705, 652, 0], false),\\n    ([0, 0, 515, 513, 507, 497, 0, 0, 0, 0], false),\\n    ([0, 0, 514, 0, 508, 498, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 509, 499, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 514, 510, 500, 0, 0, 0, 0], false),\\n    ([539, 537, 0, 0, 533, 0, 517, 0, 0, 0], false),\\n    ([532, 530, 0, 0, 526, 0, 518, 0, 0, 0], false),\\n    ([525, 523, 0, 0, 519, 0, 0, 0, 0, 0], false),\\n    ([522, 520, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([521, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 521, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([524, 0, 0, 0, 520, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 521, 0, 0, 0, 0, 0], false),\\n    ([0, 524, 0, 0, 522, 0, 0, 0, 0, 0], false),\\n    ([529, 527, 0, 0, 0, 0, 519, 0, 0, 0], false),\\n    ([528, 0, 0, 0, 0, 0, 520, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 521, 0, 0, 0], false),\\n    ([0, 528, 0, 0, 0, 0, 522, 0, 0, 0], false),\\n    ([531, 0, 0, 0, 527, 0, 523, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 528, 0, 524, 0, 0, 0], false),\\n    ([0, 531, 0, 0, 529, 0, 525, 0, 0, 0], false),\\n    ([536, 534, 0, 0, 0, 0, 526, 0, 0, 0], false),\\n    ([535, 0, 0, 0, 0, 0, 527, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 528, 0, 0, 0], false),\\n    ([0, 535, 0, 0, 0, 0, 529, 0, 0, 0], false),\\n    ([538, 0, 0, 0, 534, 0, 530, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 535, 0, 531, 0, 0, 0], false),\\n    ([0, 538, 0, 0, 536, 0, 532, 0, 0, 0], false),\\n    ([547, 545, 0, 0, 541, 0, 0, 518, 0, 0], false),\\n    ([544, 542, 0, 0, 0, 0, 0, 519, 0, 0], false),\\n    ([543, 0, 0, 0, 0, 0, 0, 520, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 521, 0, 0], false),\\n    ([0, 543, 0, 0, 0, 0, 0, 522, 0, 0], false),\\n    ([546, 0, 0, 0, 542, 0, 0, 523, 0, 0], false),\\n    ([0, 0, 0, 0, 543, 0, 0, 524, 0, 0], false),\\n    ([0, 546, 0, 0, 544, 0, 0, 525, 0, 0], false),\\n    ([551, 549, 0, 0, 0, 0, 541, 526, 0, 0], false),\\n    ([550, 0, 0, 0, 0, 0, 542, 527, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 543, 528, 0, 0], false),\\n    ([0, 550, 0, 0, 0, 0, 544, 529, 0, 0], false),\\n    ([553, 0, 0, 0, 549, 0, 545, 530, 0, 0], false),\\n    ([0, 0, 0, 0, 550, 0, 546, 531, 0, 0], false),\\n    ([555, 0, 0, 0, 0, 0, 549, 534, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 550, 535, 0, 0], false),\\n    ([0, 555, 0, 0, 0, 0, 551, 536, 0, 0], false),\\n    ([558, 0, 0, 0, 554, 0, 552, 537, 0, 0], false),\\n    ([0, 0, 0, 0, 555, 0, 553, 538, 0, 0], false),\\n    ([566, 564, 0, 0, 560, 0, 0, 0, 518, 0], false),\\n    ([563, 561, 0, 0, 0, 0, 0, 0, 519, 0], false),\\n    ([562, 0, 0, 0, 0, 0, 0, 0, 520, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 521, 0], false),\\n    ([0, 562, 0, 0, 0, 0, 0, 0, 522, 0], false),\\n    ([565, 0, 0, 0, 561, 0, 0, 0, 523, 0], false),\\n    ([0, 0, 0, 0, 562, 0, 0, 0, 524, 0], false),\\n    ([0, 565, 0, 0, 563, 0, 0, 0, 525, 0], false),\\n    ([574, 572, 770, 768, 568, 737, 0, 559, 540, 0], false),\\n    ([571, 569, 767, 765, 761, 750, 0, 560, 541, 0], false),\\n    ([570, 0, 0, 0, 0, 0, 0, 561, 542, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 562, 543, 0], false),\\n    ([0, 570, 0, 0, 0, 0, 0, 563, 544, 0], false),\\n    ([573, 0, 0, 0, 569, 0, 0, 564, 545, 0], false),\\n    ([0, 0, 0, 0, 570, 0, 0, 565, 546, 0], false),\\n    ([0, 573, 0, 0, 571, 0, 0, 566, 547, 0], false),\\n    ([578, 576, 0, 0, 0, 0, 0, 0, 560, 0], false),\\n    ([577, 0, 0, 0, 0, 0, 0, 0, 561, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 562, 0], false),\\n    ([0, 577, 0, 0, 0, 0, 0, 0, 563, 0], false),\\n    ([0, 0, 0, 0, 577, 0, 0, 0, 565, 0], false),\\n    ([0, 579, 0, 0, 578, 0, 0, 0, 566, 0], false),\\n    ([584, 582, 849, 847, 843, 833, 0, 575, 568, 0], false),\\n    ([583, 0, 0, 0, 0, 0, 0, 576, 569, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 577, 570, 0], false),\\n    ([0, 583, 0, 0, 0, 0, 0, 578, 571, 0], false),\\n    ([0, 0, 0, 0, 583, 0, 0, 579, 573, 0], false),\\n    ([0, 585, 0, 0, 584, 0, 0, 580, 574, 0], false),\\n    ([0, 621, 615, 606, 588, 0, 0, 0, 0, 0], false),\\n    ([0, 604, 598, 589, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 596, 590, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 594, 591, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 592, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 593, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 595, 592, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 593, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 597, 594, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 595, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 602, 599, 590, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 600, 0, 591, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 601, 0, 592, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 593, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 603, 600, 594, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 601, 595, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 605, 602, 596, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 603, 597, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 613, 607, 0, 589, 0, 0, 0, 0, 0], false),\\n    ([0, 611, 608, 0, 590, 0, 0, 0, 0, 0], false),\\n    ([0, 609, 0, 0, 591, 0, 0, 0, 0, 0], false),\\n    ([0, 610, 0, 0, 592, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 593, 0, 0, 0, 0, 0], false),\\n    ([0, 612, 609, 0, 594, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 610, 0, 595, 0, 0, 0, 0, 0], false),\\n    ([0, 614, 611, 0, 596, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 612, 0, 597, 0, 0, 0, 0, 0], false),\\n    ([0, 619, 616, 607, 598, 0, 0, 0, 0, 0], false),\\n    ([0, 617, 0, 608, 599, 0, 0, 0, 0, 0], false),\\n    ([0, 618, 0, 609, 600, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 610, 601, 0, 0, 0, 0, 0], false),\\n    ([0, 620, 617, 611, 602, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 618, 612, 603, 0, 0, 0, 0, 0], false),\\n    ([0, 622, 619, 613, 604, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 620, 614, 605, 0, 0, 0, 0, 0], false),\\n    ([0, 630, 624, 0, 0, 0, 0, 589, 0, 0], false),\\n    ([0, 628, 625, 0, 0, 0, 0, 590, 0, 0], false),\\n    ([0, 626, 0, 0, 0, 0, 0, 591, 0, 0], false),\\n    ([0, 627, 0, 0, 0, 0, 0, 592, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 593, 0, 0], false),\\n    ([0, 629, 626, 0, 0, 0, 0, 594, 0, 0], false),\\n    ([0, 0, 627, 0, 0, 0, 0, 595, 0, 0], false),\\n    ([0, 631, 628, 0, 0, 0, 0, 596, 0, 0], false),\\n    ([0, 0, 629, 0, 0, 0, 0, 597, 0, 0], false),\\n    ([0, 636, 633, 624, 0, 0, 0, 598, 0, 0], false),\\n    ([0, 634, 0, 625, 0, 0, 0, 599, 0, 0], false),\\n    ([0, 635, 0, 626, 0, 0, 0, 600, 0, 0], false),\\n    ([0, 0, 0, 627, 0, 0, 0, 601, 0, 0], false),\\n    ([0, 637, 634, 628, 0, 0, 0, 602, 0, 0], false),\\n    ([0, 0, 635, 629, 0, 0, 0, 603, 0, 0], false),\\n    ([0, 0, 637, 631, 0, 0, 0, 605, 0, 0], false),\\n    ([0, 640, 0, 0, 625, 0, 0, 608, 0, 0], false),\\n    ([0, 641, 0, 0, 626, 0, 0, 609, 0, 0], false),\\n    ([0, 0, 0, 0, 627, 0, 0, 610, 0, 0], false),\\n    ([1119, 643, 640, 0, 628, 1109, 1098, 611, 0, 923], false),\\n    ([0, 0, 641, 0, 629, 0, 0, 612, 0, 0], false),\\n    ([1121, 645, 642, 0, 630, 1112, 1101, 613, 0, 926], false),\\n    ([0, 0, 643, 0, 631, 0, 0, 614, 0, 0], false),\\n    ([0, 647, 0, 639, 633, 0, 0, 616, 0, 0], false),\\n    ([0, 648, 0, 640, 634, 0, 0, 617, 0, 0], false),\\n    ([0, 0, 0, 641, 635, 0, 0, 618, 0, 0], false),\\n    ([1123, 650, 647, 642, 636, 1116, 1104, 619, 0, 930], false),\\n    ([0, 0, 648, 643, 637, 0, 0, 620, 0, 0], false),\\n    ([0, 0, 650, 645, 638, 0, 0, 622, 0, 0], false),\\n    ([0, 656, 653, 0, 821, 816, 797, 624, 0, 0], false),\\n    ([0, 654, 0, 0, 0, 0, 0, 625, 0, 0], false),\\n    ([0, 655, 0, 0, 0, 0, 0, 626, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 627, 0, 0], false),\\n    ([0, 657, 654, 0, 0, 0, 0, 628, 0, 0], false),\\n    ([0, 0, 655, 0, 0, 0, 0, 629, 0, 0], false),\\n    ([0, 0, 657, 0, 0, 0, 0, 631, 0, 0], false),\\n    ([0, 660, 0, 654, 0, 0, 0, 634, 0, 0], false),\\n    ([0, 0, 0, 655, 0, 0, 0, 635, 0, 0], false),\\n    ([0, 662, 659, 656, 0, 0, 0, 636, 0, 0], false),\\n    ([0, 0, 660, 657, 0, 0, 0, 637, 0, 0], false),\\n    ([0, 0, 662, 658, 0, 0, 0, 638, 0, 0], false),\\n    ([0, 665, 0, 0, 653, 0, 0, 639, 0, 0], false),\\n    ([0, 666, 0, 0, 654, 0, 0, 640, 0, 0], false),\\n    ([0, 0, 0, 0, 655, 0, 0, 641, 0, 0], false),\\n    ([1150, 668, 665, 0, 656, 1141, 1134, 642, 0, 986], false),\\n    ([0, 0, 666, 0, 657, 0, 0, 643, 0, 0], false),\\n    ([0, 0, 668, 0, 658, 0, 0, 645, 0, 0], false),\\n    ([0, 671, 0, 665, 659, 0, 0, 647, 0, 0], false),\\n    ([0, 0, 0, 666, 660, 0, 0, 648, 0, 0], false),\\n    ([0, 0, 671, 668, 662, 0, 0, 650, 0, 0], false),\\n    ([0, 0, 672, 669, 663, 0, 0, 651, 0, 0], false),\\n    ([0, 690, 684, 675, 0, 0, 0, 0, 588, 0], false),\\n    ([0, 682, 676, 0, 0, 0, 0, 0, 589, 0], false),\\n    ([0, 680, 677, 0, 0, 0, 0, 0, 590, 0], false),\\n    ([0, 678, 0, 0, 0, 0, 0, 0, 591, 0], false),\\n    ([0, 679, 0, 0, 0, 0, 0, 0, 592, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 593, 0], false),\\n    ([0, 681, 678, 0, 0, 0, 0, 0, 594, 0], false),\\n    ([0, 0, 679, 0, 0, 0, 0, 0, 595, 0], false),\\n    ([0, 683, 680, 0, 0, 0, 0, 0, 596, 0], false),\\n    ([0, 0, 681, 0, 0, 0, 0, 0, 597, 0], false),\\n    ([0, 688, 685, 676, 0, 0, 0, 0, 598, 0], false),\\n    ([0, 686, 0, 677, 0, 0, 0, 0, 599, 0], false),\\n    ([0, 687, 0, 678, 0, 0, 0, 0, 600, 0], false),\\n    ([0, 0, 0, 679, 0, 0, 0, 0, 601, 0], false),\\n    ([0, 689, 686, 680, 0, 0, 0, 0, 602, 0], false),\\n    ([0, 0, 687, 681, 0, 0, 0, 0, 603, 0], false),\\n    ([0, 691, 688, 682, 0, 0, 0, 0, 604, 0], false),\\n    ([0, 0, 689, 683, 0, 0, 0, 0, 605, 0], false),\\n    ([0, 699, 693, 0, 675, 0, 0, 0, 606, 0], false),\\n    ([0, 697, 694, 0, 676, 0, 0, 0, 607, 0], false),\\n    ([0, 695, 0, 0, 677, 0, 0, 0, 608, 0], false),\\n    ([0, 696, 0, 0, 678, 0, 0, 0, 609, 0], false),\\n    ([0, 0, 0, 0, 679, 0, 0, 0, 610, 0], false),\\n    ([0, 698, 695, 0, 680, 0, 0, 0, 611, 0], false),\\n    ([0, 0, 696, 0, 681, 0, 0, 0, 612, 0], false),\\n    ([0, 700, 697, 0, 682, 0, 0, 0, 613, 0], false),\\n    ([0, 0, 698, 0, 683, 0, 0, 0, 614, 0], false),\\n    ([0, 702, 0, 694, 685, 0, 0, 0, 616, 0], false),\\n    ([0, 703, 0, 695, 686, 0, 0, 0, 617, 0], false),\\n    ([0, 0, 0, 696, 687, 0, 0, 0, 618, 0], false),\\n    ([0, 711, 705, 0, 0, 0, 0, 675, 623, 0], false),\\n    ([0, 709, 706, 0, 0, 0, 0, 676, 624, 0], false),\\n    ([0, 707, 0, 0, 0, 0, 0, 677, 625, 0], false),\\n    ([0, 708, 0, 0, 0, 0, 0, 678, 626, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 679, 627, 0], false),\\n    ([0, 710, 707, 0, 0, 0, 0, 680, 628, 0], false),\\n    ([0, 0, 708, 0, 0, 0, 0, 681, 629, 0], false),\\n    ([0, 712, 709, 0, 0, 0, 0, 682, 630, 0], false),\\n    ([0, 0, 710, 0, 0, 0, 0, 683, 631, 0], false),\\n    ([0, 717, 714, 705, 0, 0, 0, 684, 632, 0], false),\\n    ([0, 715, 0, 706, 0, 0, 0, 685, 633, 0], false),\\n    ([0, 716, 0, 707, 0, 0, 0, 686, 634, 0], false),\\n    ([0, 0, 0, 708, 0, 0, 0, 687, 635, 0], false),\\n    ([0, 718, 715, 709, 0, 0, 0, 688, 636, 0], false),\\n    ([0, 0, 716, 710, 0, 0, 0, 689, 637, 0], false),\\n    ([0, 0, 718, 712, 0, 0, 0, 691, 638, 0], false),\\n    ([0, 721, 0, 0, 706, 0, 0, 694, 639, 0], false),\\n    ([0, 722, 0, 0, 707, 0, 0, 695, 640, 0], false),\\n    ([0, 0, 0, 0, 708, 0, 0, 696, 641, 0], false),\\n    ([0, 0, 0, 722, 716, 0, 0, 703, 648, 0], false),\\n    ([0, 725, 0, 0, 0, 0, 0, 706, 653, 0], false),\\n    ([0, 726, 0, 0, 0, 0, 0, 707, 654, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 708, 655, 0], false),\\n    ([0, 728, 725, 0, 0, 0, 0, 709, 656, 0], false),\\n    ([0, 0, 726, 0, 0, 0, 0, 710, 657, 0], false),\\n    ([0, 0, 728, 0, 0, 0, 0, 712, 658, 0], false),\\n    ([0, 0, 0, 726, 0, 0, 0, 716, 660, 0], false),\\n    ([0, 0, 730, 728, 0, 0, 0, 718, 662, 0], false),\\n    ([0, 0, 731, 729, 0, 0, 0, 719, 663, 0], false),\\n    ([0, 734, 0, 0, 724, 0, 0, 720, 664, 0], false),\\n    ([0, 735, 0, 0, 725, 0, 0, 721, 665, 0], false),\\n    ([0, 0, 0, 0, 726, 0, 0, 722, 666, 0], false),\\n    ([0, 0, 0, 735, 730, 0, 0, 723, 671, 0], false),\\n    ([0, 0, 760, 758, 750, 738, 0, 0, 0, 0], false),\\n    ([0, 0, 749, 747, 739, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 746, 744, 740, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 743, 741, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 742, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 742, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 745, 0, 741, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 742, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 745, 743, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 748, 0, 744, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 745, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 748, 746, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 757, 755, 751, 739, 0, 0, 0, 0], false),\\n    ([0, 0, 754, 752, 0, 740, 0, 0, 0, 0], false),\\n    ([0, 0, 753, 0, 0, 741, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 742, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 753, 0, 743, 0, 0, 0, 0], false),\\n    ([0, 0, 756, 0, 752, 744, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 753, 745, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 756, 754, 746, 0, 0, 0, 0], false),\\n    ([0, 0, 759, 0, 755, 747, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 756, 748, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 759, 757, 749, 0, 0, 0, 0], false),\\n    ([0, 0, 764, 762, 0, 751, 0, 0, 0, 0], false),\\n    ([0, 0, 763, 0, 0, 752, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 753, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 763, 0, 754, 0, 0, 0, 0], false),\\n    ([0, 0, 766, 0, 762, 755, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 763, 756, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 766, 764, 757, 0, 0, 0, 0], false),\\n    ([0, 0, 769, 0, 765, 758, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 766, 759, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 769, 767, 760, 0, 0, 0, 0], false),\\n    ([0, 0, 782, 780, 772, 0, 738, 0, 0, 0], false),\\n    ([0, 0, 779, 777, 773, 0, 739, 0, 0, 0], false),\\n    ([0, 0, 776, 774, 0, 0, 740, 0, 0, 0], false),\\n    ([0, 0, 775, 0, 0, 0, 741, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 742, 0, 0, 0], false),\\n    ([0, 0, 0, 775, 0, 0, 743, 0, 0, 0], false),\\n    ([0, 0, 778, 0, 774, 0, 744, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 775, 0, 745, 0, 0, 0], false),\\n    ([0, 0, 0, 778, 776, 0, 746, 0, 0, 0], false),\\n    ([0, 0, 781, 0, 777, 0, 747, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 778, 0, 748, 0, 0, 0], false),\\n    ([0, 0, 0, 781, 779, 0, 749, 0, 0, 0], false),\\n    ([0, 0, 786, 784, 0, 773, 751, 0, 0, 0], false),\\n    ([0, 0, 785, 0, 0, 774, 752, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 775, 753, 0, 0, 0], false),\\n    ([0, 0, 0, 785, 0, 776, 754, 0, 0, 0], false),\\n    ([0, 0, 788, 0, 784, 777, 755, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 785, 778, 756, 0, 0, 0], false),\\n    ([0, 0, 0, 788, 786, 779, 757, 0, 0, 0], false),\\n    ([1130, 1128, 791, 0, 787, 780, 758, 1086, 0, 938], false),\\n    ([1127, 1125, 0, 0, 788, 781, 759, 1087, 0, 939], false),\\n    ([1133, 1131, 0, 791, 789, 782, 760, 1094, 0, 946], false),\\n    ([0, 0, 796, 794, 0, 783, 761, 0, 0, 0], false),\\n    ([0, 0, 795, 0, 0, 784, 762, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 785, 763, 0, 0, 0], false),\\n    ([0, 0, 0, 795, 0, 786, 764, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 795, 788, 766, 0, 0, 0], false),\\n    ([0, 0, 0, 797, 796, 789, 767, 0, 0, 0], false),\\n    ([0, 0, 810, 808, 800, 0, 771, 0, 0, 0], false),\\n    ([0, 0, 807, 805, 801, 0, 772, 0, 0, 0], false),\\n    ([0, 0, 804, 802, 0, 0, 773, 0, 0, 0], false),\\n    ([0, 0, 803, 0, 0, 0, 774, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 775, 0, 0, 0], false),\\n    ([0, 0, 0, 803, 0, 0, 776, 0, 0, 0], false),\\n    ([0, 0, 806, 0, 802, 0, 777, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 803, 0, 778, 0, 0, 0], false),\\n    ([0, 0, 0, 806, 804, 0, 779, 0, 0, 0], false),\\n    ([0, 0, 809, 0, 805, 0, 780, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 806, 0, 781, 0, 0, 0], false),\\n    ([0, 0, 0, 809, 807, 0, 782, 0, 0, 0], false),\\n    ([0, 0, 814, 812, 0, 801, 783, 0, 0, 0], false),\\n    ([0, 0, 813, 0, 0, 802, 784, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 803, 785, 0, 0, 0], false),\\n    ([0, 0, 0, 813, 0, 804, 786, 0, 0, 0], false),\\n    ([0, 0, 816, 0, 812, 805, 787, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 813, 806, 788, 0, 0, 0], false),\\n    ([1146, 1144, 818, 0, 815, 808, 790, 1107, 0, 969], false),\\n    ([1143, 1141, 0, 0, 816, 809, 791, 1108, 0, 970], false),\\n    ([0, 0, 822, 820, 0, 811, 793, 0, 0, 0], false),\\n    ([0, 0, 821, 0, 0, 812, 794, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 813, 795, 0, 0, 0], false),\\n    ([0, 0, 0, 821, 0, 814, 796, 0, 0, 0], false),\\n    ([0, 0, 830, 828, 824, 0, 0, 0, 739, 0], false),\\n    ([0, 0, 827, 825, 0, 0, 0, 0, 740, 0], false),\\n    ([0, 0, 826, 0, 0, 0, 0, 0, 741, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 742, 0], false),\\n    ([0, 0, 0, 826, 0, 0, 0, 0, 743, 0], false),\\n    ([0, 0, 829, 0, 825, 0, 0, 0, 744, 0], false),\\n    ([0, 0, 0, 0, 826, 0, 0, 0, 745, 0], false),\\n    ([0, 0, 0, 829, 827, 0, 0, 0, 746, 0], false),\\n    ([0, 0, 0, 0, 829, 0, 0, 0, 748, 0], false),\\n    ([0, 0, 0, 831, 830, 0, 0, 0, 749, 0], false),\\n    ([0, 0, 840, 838, 834, 823, 0, 0, 750, 0], false),\\n    ([0, 0, 837, 835, 0, 824, 0, 0, 751, 0], false),\\n    ([0, 0, 836, 0, 0, 825, 0, 0, 752, 0], false),\\n    ([0, 0, 0, 0, 0, 826, 0, 0, 753, 0], false),\\n    ([0, 0, 0, 836, 0, 827, 0, 0, 754, 0], false),\\n    ([0, 0, 839, 0, 835, 828, 0, 0, 755, 0], false),\\n    ([0, 0, 0, 0, 836, 829, 0, 0, 756, 0], false),\\n    ([0, 0, 0, 839, 837, 830, 0, 0, 757, 0], false),\\n    ([0, 0, 0, 0, 839, 831, 0, 0, 759, 0], false),\\n    ([0, 0, 0, 841, 840, 832, 0, 0, 760, 0], false),\\n    ([0, 0, 846, 844, 0, 834, 0, 0, 761, 0], false),\\n    ([0, 0, 845, 0, 0, 835, 0, 0, 762, 0], false),\\n    ([0, 0, 0, 0, 0, 836, 0, 0, 763, 0], false),\\n    ([0, 0, 0, 845, 0, 837, 0, 0, 764, 0], false),\\n    ([0, 0, 848, 0, 844, 838, 0, 0, 765, 0], false),\\n    ([0, 0, 0, 0, 845, 839, 0, 0, 766, 0], false),\\n    ([0, 0, 0, 848, 846, 840, 0, 0, 767, 0], false),\\n    ([0, 0, 0, 0, 848, 841, 0, 0, 769, 0], false),\\n    ([0, 0, 858, 856, 852, 0, 823, 0, 772, 0], false),\\n    ([0, 0, 855, 853, 0, 0, 824, 0, 773, 0], false),\\n    ([0, 0, 854, 0, 0, 0, 825, 0, 774, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 826, 0, 775, 0], false),\\n    ([0, 0, 0, 854, 0, 0, 827, 0, 776, 0], false),\\n    ([0, 0, 857, 0, 853, 0, 828, 0, 777, 0], false),\\n    ([0, 0, 0, 0, 854, 0, 829, 0, 778, 0], false),\\n    ([0, 0, 0, 857, 855, 0, 830, 0, 779, 0], false),\\n    ([0, 0, 0, 0, 857, 0, 831, 0, 781, 0], false),\\n    ([0, 0, 0, 859, 858, 0, 832, 0, 782, 0], false),\\n    ([0, 0, 864, 862, 0, 852, 834, 0, 783, 0], false),\\n    ([0, 0, 863, 0, 0, 853, 835, 0, 784, 0], false),\\n    ([0, 0, 0, 0, 0, 854, 836, 0, 785, 0], false),\\n    ([0, 0, 0, 863, 0, 855, 837, 0, 786, 0], false),\\n    ([0, 0, 866, 0, 862, 856, 838, 0, 787, 0], false),\\n    ([0, 0, 0, 0, 863, 857, 839, 0, 788, 0], false),\\n    ([0, 0, 0, 866, 864, 858, 840, 0, 789, 0], false),\\n    ([1184, 1182, 0, 0, 866, 859, 841, 1155, 791, 1046], false),\\n    ([0, 0, 870, 0, 0, 862, 844, 0, 794, 0], false),\\n    ([0, 0, 0, 0, 0, 863, 845, 0, 795, 0], false),\\n    ([0, 0, 0, 0, 870, 866, 848, 0, 797, 0], false),\\n    ([935, 933, 929, 921, 0, 905, 873, 0, 0, 0], false),\\n    ([904, 902, 898, 890, 0, 874, 0, 0, 0, 0], false),\\n    ([889, 887, 883, 875, 0, 0, 0, 0, 0, 0], false),\\n    ([882, 880, 876, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([879, 877, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([878, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 878, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([881, 0, 877, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 878, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 881, 879, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([886, 884, 0, 876, 0, 0, 0, 0, 0, 0], false),\\n    ([885, 0, 0, 877, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 878, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 885, 0, 879, 0, 0, 0, 0, 0, 0], false),\\n    ([888, 0, 884, 880, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 885, 881, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 888, 886, 882, 0, 0, 0, 0, 0, 0], false),\\n    ([897, 895, 891, 0, 0, 875, 0, 0, 0, 0], false),\\n    ([894, 892, 0, 0, 0, 876, 0, 0, 0, 0], false),\\n    ([893, 0, 0, 0, 0, 877, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 878, 0, 0, 0, 0], false),\\n    ([0, 893, 0, 0, 0, 879, 0, 0, 0, 0], false),\\n    ([896, 0, 892, 0, 0, 880, 0, 0, 0, 0], false),\\n    ([0, 0, 893, 0, 0, 881, 0, 0, 0, 0], false),\\n    ([0, 896, 894, 0, 0, 882, 0, 0, 0, 0], false),\\n    ([901, 899, 0, 891, 0, 883, 0, 0, 0, 0], false),\\n    ([900, 0, 0, 892, 0, 884, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 893, 0, 885, 0, 0, 0, 0], false),\\n    ([0, 900, 0, 894, 0, 886, 0, 0, 0, 0], false),\\n    ([903, 0, 899, 895, 0, 887, 0, 0, 0, 0], false),\\n    ([0, 0, 900, 896, 0, 888, 0, 0, 0, 0], false),\\n    ([0, 903, 901, 897, 0, 889, 0, 0, 0, 0], false),\\n    ([920, 918, 914, 906, 0, 0, 874, 0, 0, 0], false),\\n    ([913, 911, 907, 0, 0, 0, 875, 0, 0, 0], false),\\n    ([910, 908, 0, 0, 0, 0, 876, 0, 0, 0], false),\\n    ([909, 0, 0, 0, 0, 0, 877, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 878, 0, 0, 0], false),\\n    ([0, 909, 0, 0, 0, 0, 879, 0, 0, 0], false),\\n    ([912, 0, 908, 0, 0, 0, 880, 0, 0, 0], false),\\n    ([0, 0, 909, 0, 0, 0, 881, 0, 0, 0], false),\\n    ([0, 912, 910, 0, 0, 0, 882, 0, 0, 0], false),\\n    ([917, 915, 0, 907, 0, 0, 883, 0, 0, 0], false),\\n    ([916, 0, 0, 908, 0, 0, 884, 0, 0, 0], false),\\n    ([0, 0, 0, 909, 0, 0, 885, 0, 0, 0], false),\\n    ([0, 916, 0, 910, 0, 0, 886, 0, 0, 0], false),\\n    ([919, 0, 915, 911, 0, 0, 887, 0, 0, 0], false),\\n    ([0, 0, 916, 912, 0, 0, 888, 0, 0, 0], false),\\n    ([0, 919, 917, 913, 0, 0, 889, 0, 0, 0], false),\\n    ([928, 926, 922, 0, 0, 906, 890, 0, 0, 0], false),\\n    ([925, 923, 0, 0, 0, 907, 891, 0, 0, 0], false),\\n    ([924, 0, 0, 0, 0, 908, 892, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 909, 893, 0, 0, 0], false),\\n    ([0, 924, 0, 0, 0, 910, 894, 0, 0, 0], false),\\n    ([927, 0, 923, 0, 0, 911, 895, 0, 0, 0], false),\\n    ([0, 0, 924, 0, 0, 912, 896, 0, 0, 0], false),\\n    ([0, 927, 925, 0, 0, 913, 897, 0, 0, 0], false),\\n    ([932, 930, 0, 922, 0, 914, 898, 0, 0, 0], false),\\n    ([931, 0, 0, 923, 0, 915, 899, 0, 0, 0], false),\\n    ([0, 0, 0, 924, 0, 916, 900, 0, 0, 0], false),\\n    ([0, 931, 0, 925, 0, 917, 901, 0, 0, 0], false),\\n    ([934, 0, 930, 926, 0, 918, 902, 0, 0, 0], false),\\n    ([0, 0, 931, 927, 0, 919, 903, 0, 0, 0], false),\\n    ([0, 934, 932, 928, 0, 920, 904, 0, 0, 0], false),\\n    ([967, 965, 961, 953, 0, 937, 0, 873, 0, 0], false),\\n    ([952, 950, 946, 938, 0, 0, 0, 874, 0, 0], false),\\n    ([945, 943, 939, 0, 0, 0, 0, 875, 0, 0], false),\\n    ([942, 940, 0, 0, 0, 0, 0, 876, 0, 0], false),\\n    ([941, 0, 0, 0, 0, 0, 0, 877, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 878, 0, 0], false),\\n    ([0, 941, 0, 0, 0, 0, 0, 879, 0, 0], false),\\n    ([944, 0, 940, 0, 0, 0, 0, 880, 0, 0], false),\\n    ([0, 0, 941, 0, 0, 0, 0, 881, 0, 0], false),\\n    ([0, 944, 942, 0, 0, 0, 0, 882, 0, 0], false),\\n    ([949, 947, 0, 939, 0, 0, 0, 883, 0, 0], false),\\n    ([948, 0, 0, 940, 0, 0, 0, 884, 0, 0], false),\\n    ([0, 0, 0, 941, 0, 0, 0, 885, 0, 0], false),\\n    ([0, 948, 0, 942, 0, 0, 0, 886, 0, 0], false),\\n    ([951, 0, 947, 943, 0, 0, 0, 887, 0, 0], false),\\n    ([0, 0, 948, 944, 0, 0, 0, 888, 0, 0], false),\\n    ([0, 951, 949, 945, 0, 0, 0, 889, 0, 0], false),\\n    ([960, 958, 954, 0, 0, 938, 0, 890, 0, 0], false),\\n    ([957, 955, 0, 0, 0, 939, 0, 891, 0, 0], false),\\n    ([956, 0, 0, 0, 0, 940, 0, 892, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 941, 0, 893, 0, 0], false),\\n    ([0, 956, 0, 0, 0, 942, 0, 894, 0, 0], false),\\n    ([959, 0, 955, 0, 0, 943, 0, 895, 0, 0], false),\\n    ([0, 0, 956, 0, 0, 944, 0, 896, 0, 0], false),\\n    ([0, 959, 957, 0, 0, 945, 0, 897, 0, 0], false),\\n    ([964, 962, 0, 954, 0, 946, 0, 898, 0, 0], false),\\n    ([963, 0, 0, 955, 0, 947, 0, 899, 0, 0], false),\\n    ([0, 0, 0, 956, 0, 948, 0, 900, 0, 0], false),\\n    ([0, 963, 0, 957, 0, 949, 0, 901, 0, 0], false),\\n    ([966, 0, 962, 958, 0, 950, 0, 902, 0, 0], false),\\n    ([0, 0, 963, 959, 0, 951, 0, 903, 0, 0], false),\\n    ([0, 966, 964, 960, 0, 952, 0, 904, 0, 0], false),\\n    ([983, 981, 977, 969, 0, 0, 937, 905, 0, 0], false),\\n    ([976, 974, 970, 0, 0, 0, 938, 906, 0, 0], false),\\n    ([973, 971, 0, 0, 0, 0, 939, 907, 0, 0], false),\\n    ([972, 0, 0, 0, 0, 0, 940, 908, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 941, 909, 0, 0], false),\\n    ([0, 972, 0, 0, 0, 0, 942, 910, 0, 0], false),\\n    ([975, 0, 971, 0, 0, 0, 943, 911, 0, 0], false),\\n    ([0, 0, 972, 0, 0, 0, 944, 912, 0, 0], false),\\n    ([0, 975, 973, 0, 0, 0, 945, 913, 0, 0], false),\\n    ([980, 978, 0, 970, 0, 0, 946, 914, 0, 0], false),\\n    ([979, 0, 0, 971, 0, 0, 947, 915, 0, 0], false),\\n    ([0, 0, 0, 972, 0, 0, 948, 916, 0, 0], false),\\n    ([0, 979, 0, 973, 0, 0, 949, 917, 0, 0], false),\\n    ([982, 0, 978, 974, 0, 0, 950, 918, 0, 0], false),\\n    ([0, 0, 979, 975, 0, 0, 951, 919, 0, 0], false),\\n    ([0, 982, 980, 976, 0, 0, 952, 920, 0, 0], false),\\n    ([991, 989, 985, 0, 0, 969, 953, 921, 0, 0], false),\\n    ([988, 986, 0, 0, 0, 970, 954, 922, 0, 0], false),\\n    ([987, 0, 0, 0, 0, 971, 955, 923, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 972, 956, 924, 0, 0], false),\\n    ([0, 987, 0, 0, 0, 973, 957, 925, 0, 0], false),\\n    ([990, 0, 986, 0, 0, 974, 958, 926, 0, 0], false),\\n    ([0, 0, 987, 0, 0, 975, 959, 927, 0, 0], false),\\n    ([0, 990, 988, 0, 0, 976, 960, 928, 0, 0], false),\\n    ([0, 0, 0, 987, 0, 979, 963, 931, 0, 0], false),\\n    ([0, 992, 0, 988, 0, 980, 964, 932, 0, 0], false),\\n    ([0, 0, 992, 990, 0, 982, 966, 934, 0, 0], false),\\n    ([0, 994, 993, 991, 0, 983, 967, 935, 0, 0], false),\\n    ([1027, 1025, 1021, 1013, 0, 997, 0, 0, 873, 0], false),\\n    ([1012, 1010, 1006, 998, 0, 0, 0, 0, 874, 0], false),\\n    ([1005, 1003, 999, 0, 0, 0, 0, 0, 875, 0], false),\\n    ([1002, 1000, 0, 0, 0, 0, 0, 0, 876, 0], false),\\n    ([1001, 0, 0, 0, 0, 0, 0, 0, 877, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 878, 0], false),\\n    ([0, 1001, 0, 0, 0, 0, 0, 0, 879, 0], false),\\n    ([1004, 0, 1000, 0, 0, 0, 0, 0, 880, 0], false),\\n    ([0, 0, 1001, 0, 0, 0, 0, 0, 881, 0], false),\\n    ([0, 1004, 1002, 0, 0, 0, 0, 0, 882, 0], false),\\n    ([1009, 1007, 0, 999, 0, 0, 0, 0, 883, 0], false),\\n    ([1008, 0, 0, 1000, 0, 0, 0, 0, 884, 0], false),\\n    ([0, 0, 0, 1001, 0, 0, 0, 0, 885, 0], false),\\n    ([0, 1008, 0, 1002, 0, 0, 0, 0, 886, 0], false),\\n    ([1011, 0, 1007, 1003, 0, 0, 0, 0, 887, 0], false),\\n    ([0, 0, 1008, 1004, 0, 0, 0, 0, 888, 0], false),\\n    ([0, 1011, 1009, 1005, 0, 0, 0, 0, 889, 0], false),\\n    ([1020, 1018, 1014, 0, 0, 998, 0, 0, 890, 0], false),\\n    ([1017, 1015, 0, 0, 0, 999, 0, 0, 891, 0], false),\\n    ([1016, 0, 0, 0, 0, 1000, 0, 0, 892, 0], false),\\n    ([0, 0, 0, 0, 0, 1001, 0, 0, 893, 0], false),\\n    ([0, 1016, 0, 0, 0, 1002, 0, 0, 894, 0], false),\\n    ([1019, 0, 1015, 0, 0, 1003, 0, 0, 895, 0], false),\\n    ([0, 0, 1016, 0, 0, 1004, 0, 0, 896, 0], false),\\n    ([0, 1019, 1017, 0, 0, 1005, 0, 0, 897, 0], false),\\n    ([1024, 1022, 0, 1014, 0, 1006, 0, 0, 898, 0], false),\\n    ([1023, 0, 0, 1015, 0, 1007, 0, 0, 899, 0], false),\\n    ([0, 0, 0, 1016, 0, 1008, 0, 0, 900, 0], false),\\n    ([0, 1023, 0, 1017, 0, 1009, 0, 0, 901, 0], false),\\n    ([1026, 0, 1022, 1018, 0, 1010, 0, 0, 902, 0], false),\\n    ([0, 0, 1023, 1019, 0, 1011, 0, 0, 903, 0], false),\\n    ([0, 1026, 1024, 1020, 0, 1012, 0, 0, 904, 0], false),\\n    ([1035, 1033, 1029, 0, 0, 0, 998, 0, 906, 0], false),\\n    ([1032, 1030, 0, 0, 0, 0, 999, 0, 907, 0], false),\\n    ([1031, 0, 0, 0, 0, 0, 1000, 0, 908, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1001, 0, 909, 0], false),\\n    ([0, 1031, 0, 0, 0, 0, 1002, 0, 910, 0], false),\\n    ([1034, 0, 1030, 0, 0, 0, 1003, 0, 911, 0], false),\\n    ([0, 0, 1031, 0, 0, 0, 1004, 0, 912, 0], false),\\n    ([0, 1034, 1032, 0, 0, 0, 1005, 0, 913, 0], false),\\n    ([1043, 1041, 1037, 0, 0, 1028, 1013, 0, 921, 0], false),\\n    ([1040, 1038, 0, 0, 0, 1029, 1014, 0, 922, 0], false),\\n    ([1039, 0, 0, 0, 0, 1030, 1015, 0, 923, 0], false),\\n    ([0, 0, 0, 0, 0, 1031, 1016, 0, 924, 0], false),\\n    ([0, 1039, 0, 0, 0, 1032, 1017, 0, 925, 0], false),\\n    ([1042, 0, 1038, 0, 0, 1033, 1018, 0, 926, 0], false),\\n    ([0, 0, 1039, 0, 0, 1034, 1019, 0, 927, 0], false),\\n    ([0, 1042, 1040, 0, 0, 1035, 1020, 0, 928, 0], false),\\n    ([1059, 1057, 1053, 1045, 0, 0, 0, 997, 937, 0], false),\\n    ([1052, 1050, 1046, 0, 0, 0, 0, 998, 938, 0], false),\\n    ([1049, 1047, 0, 0, 0, 0, 0, 999, 939, 0], false),\\n    ([1048, 0, 0, 0, 0, 0, 0, 1000, 940, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1001, 941, 0], false),\\n    ([0, 1048, 0, 0, 0, 0, 0, 1002, 942, 0], false),\\n    ([1051, 0, 1047, 0, 0, 0, 0, 1003, 943, 0], false),\\n    ([0, 0, 1048, 0, 0, 0, 0, 1004, 944, 0], false),\\n    ([0, 1051, 1049, 0, 0, 0, 0, 1005, 945, 0], false),\\n    ([1056, 1054, 0, 1046, 0, 0, 0, 1006, 946, 0], false),\\n    ([1055, 0, 0, 1047, 0, 0, 0, 1007, 947, 0], false),\\n    ([0, 0, 0, 1048, 0, 0, 0, 1008, 948, 0], false),\\n    ([0, 1055, 0, 1049, 0, 0, 0, 1009, 949, 0], false),\\n    ([1058, 0, 1054, 1050, 0, 0, 0, 1010, 950, 0], false),\\n    ([0, 0, 1055, 1051, 0, 0, 0, 1011, 951, 0], false),\\n    ([0, 1058, 1056, 1052, 0, 0, 0, 1012, 952, 0], false),\\n    ([1067, 1065, 1061, 0, 0, 1045, 0, 1013, 953, 0], false),\\n    ([1064, 1062, 0, 0, 0, 1046, 0, 1014, 954, 0], false),\\n    ([1063, 0, 0, 0, 0, 1047, 0, 1015, 955, 0], false),\\n    ([0, 0, 0, 0, 0, 1048, 0, 1016, 956, 0], false),\\n    ([0, 1063, 0, 0, 0, 1049, 0, 1017, 957, 0], false),\\n    ([1066, 0, 1062, 0, 0, 1050, 0, 1018, 958, 0], false),\\n    ([0, 0, 1063, 0, 0, 1051, 0, 1019, 959, 0], false),\\n    ([0, 1066, 1064, 0, 0, 1052, 0, 1020, 960, 0], false),\\n    ([1071, 1069, 0, 1061, 0, 1053, 0, 1021, 961, 0], false),\\n    ([1070, 0, 0, 1062, 0, 1054, 0, 1022, 962, 0], false),\\n    ([0, 0, 0, 1063, 0, 1055, 0, 1023, 963, 0], false),\\n    ([0, 1070, 0, 1064, 0, 1056, 0, 1024, 964, 0], false),\\n    ([1073, 0, 1069, 1065, 0, 1057, 0, 1025, 965, 0], false),\\n    ([0, 0, 1070, 1066, 0, 1058, 0, 1026, 966, 0], false),\\n    ([1081, 1079, 1075, 0, 0, 0, 1045, 1028, 969, 0], false),\\n    ([1078, 1076, 0, 0, 0, 0, 1046, 1029, 970, 0], false),\\n    ([1077, 0, 0, 0, 0, 0, 1047, 1030, 971, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1048, 1031, 972, 0], false),\\n    ([0, 1077, 0, 0, 0, 0, 1049, 1032, 973, 0], false),\\n    ([1080, 0, 1076, 0, 0, 0, 1050, 1033, 974, 0], false),\\n    ([0, 0, 1077, 0, 0, 0, 1051, 1034, 975, 0], false),\\n    ([0, 1080, 1078, 0, 0, 0, 1052, 1035, 976, 0], false),\\n    ([1085, 1083, 0, 0, 0, 1075, 1061, 1037, 985, 0], false),\\n    ([1084, 0, 0, 0, 0, 1076, 1062, 1038, 986, 0], false),\\n    ([0, 0, 0, 0, 0, 1077, 1063, 1039, 987, 0], false),\\n    ([0, 1084, 0, 0, 0, 1078, 1064, 1040, 988, 0], false),\\n    ([1093, 1091, 1087, 0, 0, 0, 0, 0, 0, 875], false),\\n    ([1090, 1088, 0, 0, 0, 0, 0, 0, 0, 876], false),\\n    ([1089, 0, 0, 0, 0, 0, 0, 0, 0, 877], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 878], false),\\n    ([0, 1089, 0, 0, 0, 0, 0, 0, 0, 879], false),\\n    ([1092, 0, 1088, 0, 0, 0, 0, 0, 0, 880], false),\\n    ([0, 0, 1089, 0, 0, 0, 0, 0, 0, 881], false),\\n    ([0, 1092, 1090, 0, 0, 0, 0, 0, 0, 882], false),\\n    ([1097, 1095, 0, 1087, 0, 0, 0, 0, 0, 883], false),\\n    ([1096, 0, 0, 1088, 0, 0, 0, 0, 0, 884], false),\\n    ([0, 0, 0, 1089, 0, 0, 0, 0, 0, 885], false),\\n    ([0, 1096, 0, 1090, 0, 0, 0, 0, 0, 886], false),\\n    ([1099, 0, 0, 0, 0, 1088, 0, 0, 0, 892], false),\\n    ([0, 0, 0, 0, 0, 1089, 0, 0, 0, 893], false),\\n    ([0, 1099, 0, 0, 0, 1090, 0, 0, 0, 894], false),\\n    ([1102, 0, 1098, 0, 0, 1091, 0, 0, 0, 895], false),\\n    ([0, 0, 1099, 0, 0, 1092, 0, 0, 0, 896], false),\\n    ([0, 1102, 1100, 0, 0, 1093, 0, 0, 0, 897], false),\\n    ([1105, 0, 0, 1098, 0, 1095, 0, 0, 0, 899], false),\\n    ([0, 0, 0, 1099, 0, 1096, 0, 0, 0, 900], false),\\n    ([0, 1105, 0, 1100, 0, 1097, 0, 0, 0, 901], false),\\n    ([1114, 1112, 1108, 0, 0, 0, 1086, 0, 0, 906], false),\\n    ([1111, 1109, 0, 0, 0, 0, 1087, 0, 0, 907], false),\\n    ([1110, 0, 0, 0, 0, 0, 1088, 0, 0, 908], false),\\n    ([0, 0, 0, 0, 0, 0, 1089, 0, 0, 909], false),\\n    ([0, 1110, 0, 0, 0, 0, 1090, 0, 0, 910], false),\\n    ([1113, 0, 1109, 0, 0, 0, 1091, 0, 0, 911], false),\\n    ([0, 0, 1110, 0, 0, 0, 1092, 0, 0, 912], false),\\n    ([0, 1113, 1111, 0, 0, 0, 1093, 0, 0, 913], false),\\n    ([1118, 1116, 0, 1108, 0, 0, 1094, 0, 0, 914], false),\\n    ([1117, 0, 0, 1109, 0, 0, 1095, 0, 0, 915], false),\\n    ([0, 0, 0, 1110, 0, 0, 1096, 0, 0, 916], false),\\n    ([0, 1117, 0, 1111, 0, 0, 1097, 0, 0, 917], false),\\n    ([0, 0, 0, 0, 0, 1110, 1099, 0, 0, 924], false),\\n    ([0, 1119, 0, 0, 0, 1111, 1100, 0, 0, 925], false),\\n    ([0, 0, 1119, 0, 0, 1113, 1102, 0, 0, 927], false),\\n    ([0, 1121, 1120, 0, 0, 1114, 1103, 0, 0, 928], false),\\n    ([0, 0, 0, 1119, 0, 1117, 1105, 0, 0, 931], false),\\n    ([0, 1123, 0, 1120, 0, 1118, 1106, 0, 0, 932], false),\\n    ([1126, 0, 0, 0, 0, 0, 0, 1088, 0, 940], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1089, 0, 941], false),\\n    ([0, 1126, 0, 0, 0, 0, 0, 1090, 0, 942], false),\\n    ([1129, 0, 1125, 0, 0, 0, 0, 1091, 0, 943], false),\\n    ([0, 0, 1126, 0, 0, 0, 0, 1092, 0, 944], false),\\n    ([0, 1129, 1127, 0, 0, 0, 0, 1093, 0, 945], false),\\n    ([1132, 0, 0, 1125, 0, 0, 0, 1095, 0, 947], false),\\n    ([0, 0, 0, 1126, 0, 0, 0, 1096, 0, 948], false),\\n    ([0, 1132, 0, 1127, 0, 0, 0, 1097, 0, 949], false),\\n    ([1135, 0, 0, 0, 0, 1125, 0, 1098, 0, 955], false),\\n    ([0, 0, 0, 0, 0, 1126, 0, 1099, 0, 956], false),\\n    ([0, 1135, 0, 0, 0, 1127, 0, 1100, 0, 957], false),\\n    ([0, 0, 1135, 0, 0, 1129, 0, 1102, 0, 959], false),\\n    ([1139, 0, 0, 1134, 0, 1131, 0, 1104, 0, 962], false),\\n    ([0, 0, 0, 1135, 0, 1132, 0, 1105, 0, 963], false),\\n    ([0, 1139, 0, 1136, 0, 1133, 0, 1106, 0, 964], false),\\n    ([1142, 0, 0, 0, 0, 0, 1125, 1109, 0, 971], false),\\n    ([0, 0, 0, 0, 0, 0, 1126, 1110, 0, 972], false),\\n    ([0, 1142, 0, 0, 0, 0, 1127, 1111, 0, 973], false),\\n    ([1145, 0, 1141, 0, 0, 0, 1128, 1112, 0, 974], false),\\n    ([0, 0, 1142, 0, 0, 0, 1129, 1113, 0, 975], false),\\n    ([0, 1145, 1143, 0, 0, 0, 1130, 1114, 0, 976], false),\\n    ([1148, 0, 0, 1141, 0, 0, 1131, 1116, 0, 978], false),\\n    ([0, 0, 0, 1142, 0, 0, 1132, 1117, 0, 979], false),\\n    ([0, 1148, 0, 1143, 0, 0, 1133, 1118, 0, 980], false),\\n    ([0, 0, 0, 0, 0, 1142, 1135, 1119, 0, 987], false),\\n    ([0, 1150, 0, 0, 0, 1143, 1136, 1120, 0, 988], false),\\n    ([0, 0, 1150, 0, 0, 1145, 1137, 1121, 0, 990], false),\\n    ([0, 0, 0, 1150, 0, 1148, 1139, 1123, 0, 992], false),\\n    ([1161, 1159, 1155, 0, 0, 0, 0, 0, 1086, 998], false),\\n    ([1158, 1156, 0, 0, 0, 0, 0, 0, 1087, 999], false),\\n    ([1157, 0, 0, 0, 0, 0, 0, 0, 1088, 1000], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 1089, 1001], false),\\n    ([0, 1157, 0, 0, 0, 0, 0, 0, 1090, 1002], false),\\n    ([1160, 0, 1156, 0, 0, 0, 0, 0, 1091, 1003], false),\\n    ([0, 0, 1157, 0, 0, 0, 0, 0, 1092, 1004], false),\\n    ([0, 1160, 1158, 0, 0, 0, 0, 0, 1093, 1005], false),\\n    ([1165, 1163, 0, 1155, 0, 0, 0, 0, 1094, 1006], false),\\n    ([1164, 0, 0, 1156, 0, 0, 0, 0, 1095, 1007], false),\\n    ([0, 0, 0, 1157, 0, 0, 0, 0, 1096, 1008], false),\\n    ([0, 1164, 0, 1158, 0, 0, 0, 0, 1097, 1009], false),\\n    ([1167, 0, 0, 0, 0, 1156, 0, 0, 1098, 1015], false),\\n    ([0, 0, 0, 0, 0, 1157, 0, 0, 1099, 1016], false),\\n    ([0, 1167, 0, 0, 0, 1158, 0, 0, 1100, 1017], false),\\n    ([1170, 0, 1166, 0, 0, 1159, 0, 0, 1101, 1018], false),\\n    ([0, 0, 1167, 0, 0, 1160, 0, 0, 1102, 1019], false),\\n    ([0, 1170, 1168, 0, 0, 1161, 0, 0, 1103, 1020], false),\\n    ([0, 0, 0, 1167, 0, 1164, 0, 0, 1105, 1023], false),\\n    ([0, 1172, 0, 1168, 0, 1165, 0, 0, 1106, 1024], false),\\n    ([1181, 1179, 1175, 0, 0, 0, 1154, 0, 1107, 1028], false),\\n    ([1178, 1176, 0, 0, 0, 0, 1155, 0, 1108, 1029], false),\\n    ([1177, 0, 0, 0, 0, 0, 1156, 0, 1109, 1030], false),\\n    ([0, 0, 0, 0, 0, 0, 1157, 0, 1110, 1031], false),\\n    ([0, 1177, 0, 0, 0, 0, 1158, 0, 1111, 1032], false),\\n    ([1180, 0, 1176, 0, 0, 0, 1159, 0, 1112, 1033], false),\\n    ([0, 0, 1177, 0, 0, 0, 1160, 0, 1113, 1034], false),\\n    ([0, 1180, 1178, 0, 0, 0, 1161, 0, 1114, 1035], false),\\n    ([1183, 0, 0, 0, 0, 0, 0, 1156, 1125, 1047], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1157, 1126, 1048], false),\\n    ([0, 1183, 0, 0, 0, 0, 0, 1158, 1127, 1049], false),\\n    ([1186, 0, 1182, 0, 0, 0, 0, 1159, 1128, 1050], false),\\n    ([0, 0, 1183, 0, 0, 0, 0, 1160, 1129, 1051], false),\\n    ([0, 1186, 1184, 0, 0, 0, 0, 1161, 1130, 1052], false),\\n    ([1189, 0, 0, 1182, 0, 0, 0, 1163, 1131, 1054], false),\\n    ([0, 0, 0, 1183, 0, 0, 0, 1164, 1132, 1055], false),\\n    ([0, 1189, 0, 1184, 0, 0, 0, 1165, 1133, 1056], false),\\n    ([1192, 0, 0, 0, 0, 1182, 0, 1166, 1134, 1062], false),\\n    ([0, 0, 0, 0, 0, 1183, 0, 1167, 1135, 1063], false),\\n    ([0, 1192, 0, 0, 0, 1184, 0, 1168, 1136, 1064], false),\\n    ([0, 0, 1192, 0, 0, 1186, 0, 1170, 1137, 1066], false),\\n    ([0, 0, 0, 1192, 0, 1189, 0, 1172, 1139, 1070], false),\\n    ([0, 1195, 0, 1193, 0, 1190, 0, 1173, 1140, 1071], false),\\n    ([1198, 0, 0, 0, 0, 0, 1182, 1176, 1141, 1076], false),\\n    ([0, 0, 0, 0, 0, 0, 1183, 1177, 1142, 1077], false),\\n    ([0, 1198, 0, 0, 0, 0, 1184, 1178, 1143, 1078], false),\\n    ([1201, 0, 1197, 0, 0, 0, 1185, 1179, 1144, 1079], false),\\n    ([0, 0, 1198, 0, 0, 0, 1186, 1180, 1145, 1080], false),\\n    ([0, 1201, 1199, 0, 0, 0, 1187, 1181, 1146, 1081], false),\\n];\\n```\\n\\nIf you scrolled all the way here, you might as well enjoy reading the program that generates the graph:\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nuse std::collections::HashMap;\\n\\nfn get_node_id(digits: &[usize], visited: &mut [bool], n_visited: usize) -> usize {\\n    if n_visited == 0 {\\n        usize::MAX\\n    } else {\\n        digits\\n            .iter()\\n            .zip(visited.iter())\\n            .fold(0, |id, (d, v)| if *v { id * 10 + *d } else { id })\\n    }\\n}\\n\\nfn backtrack(\\n    digits: &[usize],\\n    visited: &mut [bool],\\n    depth: usize,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let curr_id = get_node_id(digits, visited, depth);\\n    if depth == digits.len() {\\n        graph.get_mut(&curr_id).unwrap().2 = true;\\n    } else {\\n        graph.entry(curr_id).or_insert_with(|| {\\n            let nn = *node_number;\\n            *node_number += 1;\\n            (nn, [0; N_DIGITS], false)\\n        });\\n\\n        for i in 0..digits.len() {\\n            if !visited[i] {\\n                visited[i] = true;\\n                let next_id = get_node_id(digits, visited, depth + 1);\\n                let next_node_number = graph\\n                    .entry(next_id)\\n                    .or_insert_with(|| {\\n                        let nn = *node_number;\\n                        *node_number += 1;\\n                        (nn, [0; N_DIGITS], false)\\n                    })\\n                    .0;\\n                graph.get_mut(&curr_id).unwrap().1[digits[i]] = next_node_number;\\n                backtrack(digits, visited, depth + 1, graph, node_number);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\nfn get_digits(mut n: i32) -> Vec<usize> {\\n    if n == 0 {\\n        vec![0]\\n    } else {\\n        let mut rez = vec![];\\n        while n > 0 {\\n            rez.push((n % 10) as usize);\\n            n /= 10;\\n        }\\n        rez.sort_unstable_by(|d1, d2| d2.cmp(d1));\\n        rez\\n    }\\n}\\n\\nfn insert(\\n    n: i32,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let digits = get_digits(n);\\n    let mut visited = vec![false; digits.len()];\\n    backtrack(&digits, &mut visited, 0, graph, node_number);\\n}\\n\\nfn main() {\\n    let mut node_number = 0;\\n    let mut graph_map = HashMap::new();\\n    for shift in 0..30 {\\n        insert(1 << shift, &mut graph_map, &mut node_number);\\n    }\\n    let mut graph = graph_map.values().copied().collect::<Vec<_>>();\\n    graph.sort_unstable_by_key(|(node_number, _, _)| *node_number);\\n    let graph = graph\\n        .into_iter()\\n        .map(|(_, edges, leaf)| (edges, leaf))\\n        .collect::<Vec<_>>();\\n    println!(\"{:?}\", graph);\\n    println!(\"{:?}\", graph.len());\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst N_DIGITS: usize = 10;\\n\\nconst fn build_histogram(mut n: i32) -> [u8; N_DIGITS] {\\n    let mut rez = [0; N_DIGITS];\\n    while n > 0 {\\n        rez[(n % 10) as usize] += 1;\\n        n /= 10;\\n    }\\n    rez\\n}\\n\\nconst N_POWERS: usize = 30;\\n\\nconst fn compute_power_histograms() -> [[u8; N_DIGITS]; N_POWERS] {\\n    let mut i = 0;\\n    let mut rez = [[0; N_DIGITS]; N_POWERS];\\n    while i < N_POWERS {\\n        rez[i] = build_histogram(1 << i);\\n        i += 1;\\n    }\\n    rez\\n}\\n\\nconst POWER_HISTOGRAMS: [[u8; N_DIGITS]; N_POWERS] = compute_power_histograms();\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        POWER_HISTOGRAMS.contains(&build_histogram(n))\\n    }\\n}\\n```\n```\\nconst N_DIGITS: usize = 10;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(mut n: i32) -> bool {\\n        let mut node = 0;\\n        while n > 0 {\\n            let digit = (n % 10) as usize;\\n            match GRAPH[node].0[digit] {\\n                0 => return false,\\n                next_node => node = next_node,\\n            }\\n            n /= 10;\\n        }\\n        GRAPH[node].1\\n    }\\n}\\n\\nconst GRAPH: [([usize; N_DIGITS], bool); 1203] = [\\n    ([31, 1, 2, 7, 3, 17, 5, 87, 4, 38], false),\\n    ([30, 139, 13, 75, 25, 20, 6, 123, 12, 54], true),\\n    ([29, 13, 162, 8, 21, 18, 16, 94, 10, 52], true),\\n    ([27, 25, 21, 73, 154, 184, 9, 261, 32, 43], true),\\n    ([37, 12, 10, 66, 32, 176, 55, 76, 164, 48], true),\\n    ([47, 6, 16, 71, 9, 14, 96, 88, 55, 39], false),\\n    ([273, 460, 153, 72, 70, 269, 457, 250, 62, 1072], true),\\n    ([136, 75, 8, 512, 73, 107, 71, 92, 66, 363], false),\\n    ([132, 128, 733, 515, 511, 501, 95, 93, 86, 1082], true),\\n    ([46, 70, 147, 68, 141, 265, 581, 246, 56, 40], true),\\n    ([36, 11, 183, 86, 33, 180, 85, 83, 174, 49], false),\\n    ([1153, 672, 670, 667, 661, 1147, 1138, 649, 0, 50], true),\\n    ([237, 673, 11, 67, 65, 233, 62, 215, 557, 51], false),\\n    ([28, 137, 163, 128, 22, 19, 153, 118, 11, 53], false),\\n    ([271, 269, 15, 104, 265, 102, 97, 238, 218, 1044], false),\\n    ([1190, 1188, 0, 868, 867, 860, 842, 1162, 792, 1053], true),\\n    ([1196, 153, 151, 95, 147, 15, 454, 91, 85, 1068], false),\\n    ([278, 20, 18, 107, 184, 105, 14, 253, 176, 303], false),\\n    ([338, 19, 187, 501, 185, 482, 15, 322, 180, 304], false),\\n    ([337, 0, 334, 1197, 0, 0, 1188, 327, 1147, 309], true),\\n    ([277, 0, 19, 1200, 274, 0, 269, 258, 233, 312], false),\\n    ([24, 22, 160, 511, 155, 185, 147, 713, 33, 0], false),\\n    ([23, 731, 161, 727, 158, 0, 150, 717, 661, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 23, 0, 0, 0, 0, 0, 0, 34, 0], false),\\n    ([26, 732, 22, 74, 159, 274, 70, 262, 65, 361], false),\\n    ([0, 0, 23, 381, 379, 275, 272, 263, 236, 362], false),\\n    ([0, 26, 24, 382, 380, 276, 46, 264, 35, 44], false),\\n    ([0, 138, 339, 131, 23, 337, 1195, 121, 1153, 319], false),\\n    ([0, 28, 340, 132, 24, 338, 1196, 122, 36, 320], false),\\n    ([0, 140, 28, 135, 26, 277, 273, 126, 237, 321], false),\\n    ([0, 30, 29, 136, 27, 278, 47, 127, 37, 45], false),\\n    ([35, 65, 33, 63, 819, 177, 56, 211, 171, 0], false),\\n    ([34, 661, 182, 652, 822, 178, 798, 632, 172, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 236, 34, 0, 0, 232, 227, 214, 556, 0], false),\\n    ([0, 1153, 0, 1151, 34, 1149, 1140, 1124, 0, 993], false),\\n    ([0, 237, 36, 407, 35, 235, 229, 217, 405, 995], false),\\n    ([45, 54, 52, 363, 43, 303, 39, 279, 48, 0], false),\\n    ([42, 1072, 1068, 1060, 40, 1044, 0, 996, 936, 0], false),\\n    ([41, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 1073, 1071, 1067, 41, 1059, 0, 1027, 967, 0], false),\\n    ([44, 361, 0, 357, 341, 0, 40, 0, 0, 0], false),\\n    ([0, 362, 0, 360, 356, 0, 41, 0, 0, 0], false),\\n    ([0, 321, 320, 366, 44, 314, 42, 302, 995, 0], false),\\n    ([0, 272, 0, 0, 0, 268, 584, 249, 227, 41], false),\\n    ([0, 273, 1196, 408, 46, 271, 586, 252, 229, 42], false),\\n    ([995, 51, 49, 984, 0, 968, 936, 872, 0, 0], false),\\n    ([993, 50, 0, 985, 0, 977, 961, 929, 0, 0], false),\\n    ([992, 0, 0, 986, 0, 978, 962, 930, 0, 0], true),\\n    ([994, 0, 50, 989, 0, 981, 965, 933, 0, 0], false),\\n    ([320, 53, 315, 1082, 0, 304, 1068, 292, 49, 0], false),\\n    ([319, 0, 316, 1083, 0, 309, 1069, 297, 50, 0], false),\\n    ([321, 0, 53, 364, 361, 312, 1072, 300, 51, 0], false),\\n    ([229, 62, 85, 60, 56, 218, 567, 77, 399, 936], false),\\n    ([227, 59, 798, 57, 793, 219, 568, 196, 548, 0], false),\\n    ([0, 58, 797, 0, 794, 787, 765, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([226, 0, 0, 58, 0, 220, 569, 197, 549, 0], false),\\n    ([406, 61, 84, 0, 57, 790, 768, 78, 400, 953], false),\\n    ([1137, 0, 1134, 0, 58, 1128, 0, 1101, 0, 958], false),\\n    ([228, 0, 1138, 61, 59, 223, 572, 200, 552, 965], false),\\n    ([0, 64, 652, 0, 820, 815, 57, 623, 0, 0], false),\\n    ([0, 658, 656, 0, 0, 0, 58, 630, 0, 0], false),\\n    ([236, 663, 661, 64, 0, 230, 59, 212, 554, 0], false),\\n    ([407, 67, 86, 0, 63, 817, 60, 81, 403, 984], false),\\n    ([1152, 669, 667, 0, 64, 1144, 61, 644, 0, 989], false),\\n    ([0, 69, 871, 0, 869, 865, 847, 0, 57, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 58, 0], false),\\n    ([272, 0, 150, 69, 146, 266, 582, 247, 59, 0], false),\\n    ([408, 72, 95, 0, 68, 104, 101, 89, 60, 1060], false),\\n    ([1194, 0, 1191, 0, 69, 1185, 0, 1169, 61, 1065], false),\\n    ([382, 74, 511, 507, 375, 491, 68, 704, 63, 357], false),\\n    ([381, 729, 727, 0, 376, 0, 69, 711, 64, 358], false),\\n    ([135, 133, 128, 0, 74, 1200, 72, 113, 67, 364], false),\\n    ([217, 215, 83, 81, 211, 203, 77, 587, 516, 872], false),\\n    ([202, 200, 80, 78, 196, 188, 559, 0, 517, 873], false),\\n    ([1103, 1101, 79, 0, 0, 1086, 0, 0, 0, 890], false),\\n    ([1100, 1098, 0, 0, 0, 1087, 0, 0, 0, 891], true),\\n    ([1106, 1104, 0, 79, 0, 1094, 0, 0, 0, 898], false),\\n    ([1122, 644, 82, 0, 623, 1107, 78, 606, 0, 921], false),\\n    ([1120, 642, 639, 0, 624, 1108, 79, 607, 0, 922], false),\\n    ([1124, 649, 646, 82, 632, 1115, 80, 615, 0, 929], false),\\n    ([1136, 1134, 0, 0, 797, 791, 769, 79, 0, 954], false),\\n    ([1140, 1138, 0, 84, 798, 792, 770, 80, 0, 961], false),\\n    ([1151, 667, 664, 0, 652, 818, 84, 82, 0, 985], false),\\n    ([127, 123, 94, 92, 261, 253, 88, 409, 76, 279], false),\\n    ([252, 250, 91, 89, 246, 238, 445, 428, 77, 996], false),\\n    ([1171, 1169, 90, 0, 0, 1154, 0, 0, 78, 1013], false),\\n    ([1168, 1166, 0, 0, 0, 1155, 0, 0, 79, 1014], false),\\n    ([1173, 451, 0, 90, 0, 1162, 446, 435, 80, 1021], false),\\n    ([117, 113, 93, 0, 704, 1174, 89, 692, 81, 1036], false),\\n    ([112, 108, 720, 0, 705, 1175, 90, 693, 82, 1037], false),\\n    ([122, 118, 330, 93, 713, 322, 91, 440, 83, 292], false),\\n    ([1193, 1191, 0, 0, 871, 868, 850, 90, 84, 1061], false),\\n    ([586, 457, 454, 101, 581, 97, 0, 445, 567, 0], false),\\n    ([0, 0, 842, 100, 833, 98, 0, 0, 737, 0], false),\\n    ([0, 0, 832, 99, 823, 0, 0, 0, 738, 0], false),\\n    ([0, 0, 831, 0, 828, 0, 0, 0, 747, 0], true),\\n    ([0, 0, 841, 0, 838, 99, 0, 0, 758, 0], false),\\n    ([0, 0, 850, 0, 847, 100, 0, 0, 768, 0], false),\\n    ([0, 0, 860, 103, 851, 0, 98, 0, 771, 0], false),\\n    ([0, 0, 859, 0, 856, 0, 99, 0, 780, 0], false),\\n    ([1187, 1185, 868, 0, 865, 103, 100, 1154, 790, 1045], false),\\n    ([0, 0, 482, 106, 461, 0, 102, 0, 799, 0], false),\\n    ([0, 0, 481, 477, 470, 0, 103, 0, 808, 0], false),\\n    (\\n        [1202, 1200, 501, 497, 491, 106, 104, 1174, 817, 1074],\\n        false,\\n    ),\\n    ([111, 109, 721, 0, 709, 1176, 1166, 697, 642, 1038], false),\\n    ([110, 0, 722, 0, 710, 0, 0, 698, 643, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 110, 0, 0, 0, 1177, 1167, 0, 1119, 1039], false),\\n    ([0, 111, 0, 0, 0, 1178, 1168, 0, 1120, 1040], false),\\n    ([116, 114, 108, 0, 711, 1179, 1169, 699, 644, 1041], false),\\n    ([115, 0, 109, 0, 712, 0, 0, 700, 645, 0], false),\\n    ([0, 0, 110, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 115, 111, 0, 0, 1180, 1170, 0, 1121, 1042], false),\\n    ([0, 116, 112, 0, 0, 1181, 1171, 0, 1122, 1043], false),\\n    ([121, 119, 331, 108, 717, 327, 451, 441, 649, 297], false),\\n    ([120, 0, 723, 109, 718, 0, 452, 442, 650, 0], false),\\n    ([0, 0, 0, 110, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 120, 332, 111, 0, 328, 1172, 0, 1123, 298], false),\\n    ([0, 121, 333, 112, 0, 329, 1173, 0, 1124, 299], false),\\n    ([126, 124, 118, 113, 262, 258, 250, 443, 215, 300], false),\\n    ([125, 0, 119, 114, 719, 0, 453, 444, 651, 0], false),\\n    ([0, 0, 120, 115, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 125, 121, 116, 263, 259, 251, 0, 216, 301], false),\\n    ([0, 126, 122, 117, 264, 260, 252, 0, 217, 302], false),\\n    ([131, 129, 734, 0, 727, 1197, 1191, 108, 667, 1083], false),\\n    ([130, 0, 735, 0, 728, 0, 0, 109, 668, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 110, 0, 0], false),\\n    ([0, 130, 0, 0, 0, 1198, 1192, 111, 1150, 1084], false),\\n    ([0, 131, 0, 0, 0, 1199, 1193, 112, 1151, 1085], false),\\n    ([134, 0, 129, 0, 729, 0, 0, 114, 669, 0], false),\\n    ([0, 0, 130, 0, 0, 0, 0, 115, 0, 0], false),\\n    ([0, 134, 131, 0, 381, 1201, 1194, 116, 1152, 365], false),\\n    ([0, 135, 132, 0, 382, 1202, 408, 117, 407, 366], false),\\n    ([138, 0, 736, 129, 731, 0, 459, 119, 672, 0], false),\\n    ([0, 0, 0, 130, 0, 0, 0, 120, 0, 0], false),\\n    ([140, 0, 137, 133, 732, 0, 460, 124, 673, 0], false),\\n    ([0, 0, 138, 134, 0, 0, 0, 125, 0, 0], false),\\n    ([0, 146, 142, 869, 0, 861, 843, 0, 793, 0], false),\\n    ([0, 145, 143, 870, 0, 864, 846, 0, 796, 0], false),\\n    ([0, 144, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 144, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 145, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 150, 148, 871, 142, 867, 849, 0, 798, 0], false),\\n    ([0, 149, 0, 0, 143, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 144, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 149, 0, 145, 0, 0, 0, 0, 0], false),\\n    ([0, 152, 0, 0, 148, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 149, 0, 0, 0, 0, 0], false),\\n    (\\n        [1195, 459, 152, 1191, 150, 1188, 455, 451, 1138, 1069],\\n        false,\\n    ),\\n    ([380, 159, 155, 375, 367, 483, 141, 0, 819, 341], false),\\n    ([0, 158, 156, 506, 0, 490, 142, 0, 822, 0], false),\\n    ([0, 157, 0, 0, 0, 0, 143, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 144, 0, 0, 0], false),\\n    ([0, 0, 157, 0, 0, 0, 145, 0, 0, 0], false),\\n    ([379, 0, 158, 376, 372, 0, 146, 0, 0, 354], false),\\n    ([0, 161, 0, 724, 156, 186, 148, 714, 182, 0], false),\\n    ([0, 730, 0, 725, 157, 0, 149, 715, 659, 0], false),\\n    ([340, 163, 0, 733, 160, 187, 151, 330, 183, 315], false),\\n    ([339, 736, 0, 734, 161, 334, 152, 331, 670, 316], false),\\n    ([405, 557, 174, 403, 171, 165, 399, 516, 383, 0], false),\\n    ([0, 0, 169, 0, 166, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 167, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 168, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 170, 0, 167, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 168, 0, 0, 0, 0, 0], false),\\n    ([556, 554, 172, 0, 0, 166, 548, 533, 0, 0], false),\\n    ([0, 0, 173, 0, 0, 167, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 168, 0, 0, 0, 0], false),\\n    ([0, 0, 175, 0, 172, 169, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 173, 170, 0, 0, 0, 0], false),\\n    ([235, 233, 180, 817, 177, 799, 218, 203, 165, 968], false),\\n    ([232, 230, 178, 815, 811, 800, 219, 204, 166, 0], false),\\n    ([0, 0, 179, 816, 814, 807, 789, 0, 167, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 168, 0], false),\\n    ([1149, 1147, 181, 818, 178, 810, 792, 1115, 169, 977], false),\\n    ([0, 0, 0, 0, 179, 0, 0, 0, 170, 0], false),\\n    ([0, 659, 0, 653, 0, 179, 0, 633, 173, 0], false),\\n    ([0, 670, 0, 664, 182, 181, 0, 646, 175, 0], false),\\n    ([276, 274, 185, 491, 483, 461, 265, 254, 177, 0], false),\\n    ([0, 0, 186, 496, 490, 476, 867, 0, 178, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 179, 0], false),\\n    ([336, 334, 0, 0, 186, 0, 0, 323, 181, 305], false),\\n    ([195, 193, 1094, 1086, 189, 0, 0, 0, 0, 874], false),\\n    ([192, 190, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([191, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 191, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([194, 0, 1095, 1091, 190, 0, 0, 0, 0, 887], false),\\n    ([0, 0, 1096, 1092, 191, 0, 0, 0, 0, 888], false),\\n    ([0, 194, 1097, 1093, 192, 0, 0, 0, 0, 889], false),\\n    ([199, 197, 0, 0, 0, 189, 560, 0, 526, 0], false),\\n    ([198, 0, 0, 0, 0, 190, 561, 0, 527, 0], false),\\n    ([0, 0, 0, 0, 0, 191, 562, 0, 528, 0], false),\\n    ([0, 198, 0, 0, 0, 192, 563, 0, 529, 0], false),\\n    ([201, 0, 1104, 1101, 197, 193, 564, 0, 530, 902], false),\\n    ([0, 0, 1105, 1102, 198, 194, 565, 0, 531, 903], false),\\n    ([0, 201, 1106, 1103, 199, 195, 566, 0, 532, 904], false),\\n    ([210, 208, 1115, 1107, 204, 0, 188, 0, 0, 905], false),\\n    ([207, 205, 0, 0, 0, 0, 189, 0, 0, 0], false),\\n    ([206, 0, 0, 0, 0, 0, 190, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 191, 0, 0, 0], false),\\n    ([0, 206, 0, 0, 0, 0, 192, 0, 0, 0], false),\\n    ([209, 0, 1116, 1112, 205, 0, 193, 0, 0, 918], false),\\n    ([0, 0, 1117, 1113, 206, 0, 194, 0, 0, 919], false),\\n    ([0, 209, 1118, 1114, 207, 0, 195, 0, 0, 920], false),\\n    ([214, 212, 632, 623, 0, 204, 196, 588, 533, 0], false),\\n    ([213, 638, 636, 630, 0, 205, 197, 604, 534, 0], false),\\n    ([0, 0, 0, 0, 0, 206, 198, 0, 535, 0], false),\\n    ([0, 213, 0, 0, 0, 207, 199, 0, 536, 0], false),\\n    ([216, 651, 649, 644, 212, 208, 200, 621, 537, 933], false),\\n    ([0, 0, 1123, 1121, 213, 209, 201, 0, 538, 934], false),\\n    ([0, 216, 1124, 1122, 214, 210, 202, 0, 539, 935], false),\\n    ([225, 223, 792, 790, 219, 771, 737, 188, 0, 937], false),\\n    ([222, 220, 789, 787, 783, 772, 750, 189, 0, 0], false),\\n    ([221, 0, 0, 0, 0, 0, 0, 190, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 191, 0, 0], false),\\n    ([0, 221, 0, 0, 0, 0, 0, 192, 0, 0], false),\\n    ([224, 0, 1131, 1128, 220, 0, 0, 193, 0, 950], false),\\n    ([0, 0, 1132, 1129, 221, 0, 0, 194, 0, 951], false),\\n    ([0, 224, 1133, 1130, 222, 0, 0, 195, 0, 952], false),\\n    ([0, 0, 0, 0, 0, 221, 570, 198, 550, 0], false),\\n    ([0, 226, 0, 0, 0, 222, 571, 199, 551, 0], false),\\n    ([0, 0, 1139, 1137, 226, 224, 573, 201, 553, 966], false),\\n    ([0, 228, 1140, 406, 227, 225, 574, 202, 402, 967], false),\\n    ([231, 0, 0, 0, 0, 0, 220, 205, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 221, 206, 0, 0], false),\\n    ([0, 231, 0, 0, 0, 0, 222, 207, 0, 0], false),\\n    ([234, 0, 1147, 1144, 230, 0, 223, 208, 0, 981], false),\\n    ([0, 0, 1148, 1145, 231, 0, 224, 209, 0, 982], false),\\n    ([0, 234, 1149, 1146, 232, 0, 225, 210, 0, 983], false),\\n    ([0, 0, 0, 0, 0, 231, 226, 213, 555, 0], false),\\n    ([0, 0, 1153, 1152, 236, 234, 228, 216, 558, 994], false),\\n    ([245, 243, 1162, 1154, 239, 0, 0, 0, 188, 997], false),\\n    ([242, 240, 0, 0, 0, 0, 0, 0, 189, 0], false),\\n    ([241, 0, 0, 0, 0, 0, 0, 0, 190, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 191, 0], false),\\n    ([0, 241, 0, 0, 0, 0, 0, 0, 192, 0], false),\\n    ([244, 0, 1163, 1159, 240, 0, 0, 0, 193, 1010], false),\\n    ([0, 0, 1164, 1160, 241, 0, 0, 0, 194, 1011], false),\\n    ([0, 244, 1165, 1161, 242, 0, 0, 0, 195, 1012], false),\\n    ([249, 247, 0, 0, 0, 239, 575, 0, 196, 0], false),\\n    ([248, 0, 0, 0, 0, 240, 576, 0, 197, 0], false),\\n    ([0, 0, 0, 0, 0, 241, 577, 0, 198, 0], false),\\n    ([0, 248, 0, 0, 0, 242, 578, 0, 199, 0], false),\\n    ([251, 453, 451, 1169, 247, 243, 449, 438, 200, 1025], false),\\n    ([0, 0, 1172, 1170, 248, 244, 579, 0, 201, 1026], false),\\n    ([0, 251, 1173, 1171, 249, 245, 580, 0, 202, 1027], false),\\n    ([260, 258, 322, 1174, 254, 0, 238, 0, 203, 280], false),\\n    ([257, 255, 0, 0, 0, 0, 239, 0, 204, 0], false),\\n    ([256, 0, 0, 0, 0, 0, 240, 0, 205, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 241, 0, 206, 0], false),\\n    ([0, 256, 0, 0, 0, 0, 242, 0, 207, 0], false),\\n    ([259, 0, 327, 1179, 255, 0, 243, 0, 208, 289], false),\\n    ([0, 0, 328, 1180, 256, 0, 244, 0, 209, 290], false),\\n    ([0, 259, 329, 1181, 257, 0, 245, 0, 210, 291], false),\\n    ([264, 262, 713, 704, 0, 254, 246, 674, 211, 0], false),\\n    ([263, 719, 717, 711, 0, 255, 247, 690, 212, 0], false),\\n    ([0, 0, 0, 0, 0, 256, 248, 0, 213, 0], false),\\n    ([0, 263, 0, 0, 0, 257, 249, 0, 214, 0], false),\\n    ([268, 266, 867, 865, 861, 851, 833, 239, 219, 0], false),\\n    ([267, 0, 0, 0, 0, 0, 0, 240, 220, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 241, 221, 0], false),\\n    ([0, 267, 0, 0, 0, 0, 0, 242, 222, 0], false),\\n    ([270, 0, 1188, 1185, 266, 0, 0, 243, 223, 1057], false),\\n    ([0, 0, 1189, 1186, 267, 0, 0, 244, 224, 1058], false),\\n    ([0, 270, 1190, 1187, 268, 0, 0, 245, 225, 1059], false),\\n    ([0, 0, 0, 0, 0, 267, 583, 248, 226, 0], false),\\n    ([0, 0, 1195, 1194, 272, 270, 585, 251, 228, 1073], false),\\n    ([275, 0, 0, 0, 0, 0, 266, 255, 230, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 267, 256, 231, 0], false),\\n    ([0, 275, 0, 0, 0, 0, 268, 257, 232, 0], false),\\n    ([0, 0, 337, 1201, 275, 0, 270, 259, 234, 313], false),\\n    ([0, 277, 338, 1202, 276, 0, 271, 260, 235, 314], false),\\n    ([302, 300, 292, 1036, 0, 280, 996, 0, 872, 0], false),\\n    ([291, 289, 281, 1028, 0, 0, 997, 0, 905, 0], false),\\n    ([288, 286, 282, 1029, 0, 0, 1006, 0, 914, 0], false),\\n    ([285, 283, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([284, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 284, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([287, 0, 283, 1030, 0, 0, 1007, 0, 915, 0], false),\\n    ([0, 0, 284, 1031, 0, 0, 1008, 0, 916, 0], false),\\n    ([0, 287, 285, 1032, 0, 0, 1009, 0, 917, 0], false),\\n    ([290, 0, 286, 1033, 0, 0, 1010, 0, 918, 0], false),\\n    ([0, 0, 287, 1034, 0, 0, 1011, 0, 919, 0], false),\\n    ([0, 290, 288, 1035, 0, 0, 1012, 0, 920, 0], false),\\n    ([299, 297, 293, 1037, 0, 281, 1021, 0, 929, 0], false),\\n    ([296, 294, 0, 0, 0, 282, 0, 0, 0, 0], false),\\n    ([295, 0, 0, 0, 0, 283, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 284, 0, 0, 0, 0], false),\\n    ([0, 295, 0, 0, 0, 285, 0, 0, 0, 0], false),\\n    ([298, 0, 294, 1038, 0, 286, 1022, 0, 930, 0], false),\\n    ([0, 0, 295, 1039, 0, 287, 1023, 0, 931, 0], false),\\n    ([0, 298, 296, 1040, 0, 288, 1024, 0, 932, 0], false),\\n    ([301, 0, 297, 1041, 0, 289, 1025, 0, 933, 0], false),\\n    ([0, 0, 298, 1042, 0, 290, 1026, 0, 934, 0], false),\\n    ([0, 301, 299, 1043, 0, 291, 1027, 0, 935, 0], false),\\n    ([314, 312, 304, 1074, 0, 0, 1044, 280, 968, 0], false),\\n    ([311, 309, 305, 1075, 0, 0, 1053, 281, 977, 0], false),\\n    ([308, 306, 0, 0, 0, 0, 0, 282, 0, 0], false),\\n    ([307, 0, 0, 0, 0, 0, 0, 283, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 284, 0, 0], false),\\n    ([0, 307, 0, 0, 0, 0, 0, 285, 0, 0], false),\\n    ([310, 0, 306, 1076, 0, 0, 1054, 286, 978, 0], false),\\n    ([0, 0, 307, 1077, 0, 0, 1055, 287, 979, 0], false),\\n    ([0, 310, 308, 1078, 0, 0, 1056, 288, 980, 0], false),\\n    ([313, 0, 309, 1079, 0, 0, 1057, 289, 981, 0], false),\\n    ([0, 0, 310, 1080, 0, 0, 1058, 290, 982, 0], false),\\n    ([0, 313, 311, 1081, 0, 0, 1059, 291, 983, 0], false),\\n    ([318, 316, 0, 0, 0, 305, 0, 293, 0, 0], false),\\n    ([317, 0, 0, 0, 0, 306, 0, 294, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 307, 0, 295, 0, 0], false),\\n    ([0, 317, 0, 0, 0, 308, 0, 296, 0, 0], false),\\n    ([0, 0, 317, 1084, 0, 310, 1070, 298, 992, 0], false),\\n    ([0, 319, 318, 1085, 0, 311, 1071, 299, 993, 0], false),\\n    ([0, 0, 319, 365, 362, 313, 1073, 301, 994, 0], false),\\n    ([329, 327, 323, 1175, 0, 0, 1162, 0, 1115, 281], false),\\n    ([326, 324, 0, 0, 0, 0, 0, 0, 0, 282], false),\\n    ([325, 0, 0, 0, 0, 0, 0, 0, 0, 283], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 284], false),\\n    ([0, 325, 0, 0, 0, 0, 0, 0, 0, 285], false),\\n    ([328, 0, 324, 1176, 0, 0, 1163, 0, 1116, 286], false),\\n    ([0, 0, 325, 1177, 0, 0, 1164, 0, 1117, 287], false),\\n    ([0, 328, 326, 1178, 0, 0, 1165, 0, 1118, 288], false),\\n    ([333, 331, 0, 720, 714, 323, 0, 701, 646, 293], false),\\n    ([332, 723, 0, 721, 715, 324, 0, 702, 647, 294], false),\\n    ([0, 0, 0, 0, 0, 325, 0, 0, 0, 295], false),\\n    ([0, 332, 0, 0, 0, 326, 0, 0, 0, 296], false),\\n    ([335, 0, 0, 0, 0, 0, 0, 324, 0, 306], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 325, 0, 307], false),\\n    ([0, 335, 0, 0, 0, 0, 0, 326, 0, 308], false),\\n    ([0, 0, 335, 1198, 0, 0, 1189, 328, 1148, 310], false),\\n    ([0, 337, 336, 1199, 0, 0, 1190, 329, 1149, 311], false),\\n    ([0, 0, 0, 0, 0, 335, 0, 332, 0, 317], false),\\n    ([0, 339, 0, 0, 0, 336, 0, 333, 0, 318], false),\\n    ([356, 354, 0, 350, 342, 0, 0, 0, 0, 0], false),\\n    ([349, 347, 0, 343, 0, 0, 0, 0, 0, 0], false),\\n    ([346, 344, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([345, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 345, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([348, 0, 0, 344, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 345, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 348, 0, 346, 0, 0, 0, 0, 0, 0], false),\\n    ([353, 351, 0, 0, 343, 0, 0, 0, 0, 0], false),\\n    ([352, 0, 0, 0, 344, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 345, 0, 0, 0, 0, 0], false),\\n    ([0, 352, 0, 0, 346, 0, 0, 0, 0, 0], false),\\n    ([355, 0, 0, 351, 347, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 352, 348, 0, 0, 0, 0, 0], false),\\n    ([0, 355, 0, 353, 349, 0, 0, 0, 0, 0], false),\\n    ([360, 358, 0, 0, 350, 0, 0, 0, 0, 0], false),\\n    ([359, 0, 0, 0, 351, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 352, 0, 0, 0, 0, 0], false),\\n    ([0, 359, 0, 0, 353, 0, 0, 0, 0, 0], false),\\n    ([362, 0, 0, 358, 354, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 359, 355, 0, 0, 0, 0, 0], false),\\n    ([366, 364, 1082, 0, 357, 1074, 1060, 1036, 984, 0], false),\\n    ([365, 0, 1083, 0, 358, 1079, 1065, 1041, 989, 0], false),\\n    ([0, 0, 1084, 0, 359, 1080, 1066, 1042, 990, 0], false),\\n    ([0, 365, 1085, 0, 360, 1081, 1067, 1043, 991, 0], false),\\n    ([374, 372, 0, 368, 0, 0, 0, 0, 0, 342], false),\\n    ([371, 369, 0, 0, 0, 0, 0, 0, 0, 343], false),\\n    ([370, 0, 0, 0, 0, 0, 0, 0, 0, 344], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 345], false),\\n    ([0, 370, 0, 0, 0, 0, 0, 0, 0, 346], false),\\n    ([373, 0, 0, 369, 0, 0, 0, 0, 0, 347], false),\\n    ([0, 0, 0, 370, 0, 0, 0, 0, 0, 348], false),\\n    ([0, 373, 0, 371, 0, 0, 0, 0, 0, 349], false),\\n    ([378, 376, 506, 502, 368, 484, 869, 0, 820, 350], false),\\n    ([377, 0, 0, 0, 369, 0, 0, 0, 0, 351], false),\\n    ([0, 0, 0, 0, 370, 0, 0, 0, 0, 352], false),\\n    ([0, 377, 0, 0, 371, 0, 0, 0, 0, 353], false),\\n    ([0, 0, 0, 377, 373, 0, 0, 0, 0, 355], false),\\n    ([0, 379, 0, 378, 374, 0, 0, 0, 0, 356], false),\\n    ([0, 0, 0, 0, 377, 0, 0, 0, 0, 359], false),\\n    ([0, 381, 0, 0, 378, 0, 0, 0, 0, 360], false),\\n    ([398, 0, 0, 396, 0, 0, 392, 0, 384, 0], false),\\n    ([391, 0, 0, 389, 0, 0, 385, 0, 0, 0], false),\\n    ([388, 0, 0, 386, 0, 0, 0, 0, 0, 0], false),\\n    ([387, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 387, 0, 0, 0, 0, 0, 0], false),\\n    ([390, 0, 0, 0, 0, 0, 386, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 387, 0, 0, 0], false),\\n    ([0, 0, 0, 390, 0, 0, 388, 0, 0, 0], false),\\n    ([395, 0, 0, 393, 0, 0, 0, 0, 385, 0], false),\\n    ([394, 0, 0, 0, 0, 0, 0, 0, 386, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 387, 0], false),\\n    ([0, 0, 0, 394, 0, 0, 0, 0, 388, 0], false),\\n    ([397, 0, 0, 0, 0, 0, 393, 0, 389, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 394, 0, 390, 0], false),\\n    ([0, 0, 0, 397, 0, 0, 395, 0, 391, 0], false),\\n    ([402, 552, 0, 400, 548, 0, 540, 517, 392, 0], false),\\n    ([401, 0, 0, 0, 0, 0, 0, 0, 393, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 394, 0], false),\\n    ([0, 553, 0, 401, 551, 0, 547, 532, 395, 0], false),\\n    ([404, 0, 0, 0, 0, 0, 400, 0, 396, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 401, 0, 397, 0], false),\\n    ([0, 558, 0, 404, 556, 0, 402, 539, 398, 0], false),\\n    ([0, 1137, 1136, 0, 0, 1130, 0, 1103, 401, 960], false),\\n    ([0, 1152, 1151, 0, 0, 1146, 406, 1122, 404, 991], false),\\n    ([0, 1194, 1193, 0, 0, 1187, 0, 1171, 406, 1067], false),\\n    ([0, 443, 440, 692, 674, 0, 428, 410, 587, 0], false),\\n    ([0, 426, 423, 0, 0, 0, 411, 0, 0, 0], false),\\n    ([0, 421, 418, 0, 0, 0, 412, 0, 0, 0], false),\\n    ([0, 416, 413, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 414, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 415, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 417, 414, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 415, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 419, 0, 0, 0, 0, 413, 0, 0, 0], false),\\n    ([0, 420, 0, 0, 0, 0, 414, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 415, 0, 0, 0], false),\\n    ([0, 422, 419, 0, 0, 0, 416, 0, 0, 0], false),\\n    ([0, 0, 420, 0, 0, 0, 417, 0, 0, 0], false),\\n    ([0, 424, 0, 0, 0, 0, 418, 0, 0, 0], false),\\n    ([0, 425, 0, 0, 0, 0, 419, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 420, 0, 0, 0], false),\\n    ([0, 427, 424, 0, 0, 0, 421, 0, 0, 0], false),\\n    ([0, 0, 425, 0, 0, 0, 422, 0, 0, 0], false),\\n    ([0, 438, 435, 0, 0, 0, 429, 411, 0, 0], false),\\n    ([0, 433, 430, 0, 0, 0, 0, 412, 0, 0], false),\\n    ([0, 431, 0, 0, 0, 0, 0, 413, 0, 0], false),\\n    ([0, 432, 0, 0, 0, 0, 0, 414, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 415, 0, 0], false),\\n    ([0, 434, 431, 0, 0, 0, 0, 416, 0, 0], false),\\n    ([0, 0, 432, 0, 0, 0, 0, 417, 0, 0], false),\\n    ([0, 436, 0, 0, 0, 0, 430, 418, 0, 0], false),\\n    ([0, 437, 0, 0, 0, 0, 431, 419, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 432, 420, 0, 0], false),\\n    ([0, 439, 436, 0, 0, 0, 433, 421, 0, 0], false),\\n    ([0, 0, 437, 0, 0, 0, 434, 422, 0, 0], false),\\n    ([0, 441, 701, 693, 684, 0, 435, 423, 615, 0], false),\\n    ([0, 442, 702, 697, 688, 0, 436, 424, 619, 0], false),\\n    ([0, 0, 703, 698, 689, 0, 437, 425, 620, 0], false),\\n    ([0, 444, 441, 699, 690, 0, 438, 426, 621, 0], false),\\n    ([0, 0, 442, 700, 691, 0, 439, 427, 622, 0], false),\\n    ([580, 449, 446, 0, 575, 0, 0, 429, 559, 0], false),\\n    ([0, 447, 0, 0, 0, 0, 0, 430, 0, 0], false),\\n    ([0, 448, 0, 0, 0, 0, 0, 431, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 432, 0, 0], false),\\n    ([579, 450, 447, 0, 576, 0, 0, 433, 564, 0], false),\\n    ([0, 0, 448, 0, 0, 0, 0, 434, 0, 0], false),\\n    ([1172, 452, 0, 1166, 0, 1163, 447, 436, 1104, 1022], false),\\n    ([0, 0, 0, 0, 0, 0, 448, 437, 0, 0], false),\\n    ([0, 0, 452, 0, 0, 0, 450, 439, 0, 0], false),\\n    ([0, 455, 0, 850, 849, 842, 0, 446, 770, 0], false),\\n    ([0, 456, 0, 0, 0, 0, 0, 447, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 448, 0, 0], false),\\n    ([585, 458, 455, 0, 582, 0, 0, 449, 572, 0], false),\\n    ([0, 0, 456, 0, 0, 0, 0, 450, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 456, 452, 0, 0], false),\\n    ([0, 0, 459, 0, 0, 0, 458, 453, 0, 0], false),\\n    ([0, 0, 476, 470, 462, 0, 851, 0, 800, 0], false),\\n    ([0, 0, 469, 463, 0, 0, 852, 0, 801, 0], false),\\n    ([0, 0, 468, 464, 0, 0, 853, 0, 802, 0], false),\\n    ([0, 0, 467, 465, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 466, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 466, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 467, 0, 0, 854, 0, 803, 0], false),\\n    ([0, 0, 0, 468, 0, 0, 855, 0, 804, 0], false),\\n    ([0, 0, 475, 471, 463, 0, 856, 0, 805, 0], false),\\n    ([0, 0, 474, 472, 464, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 473, 0, 465, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 466, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 473, 467, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 474, 468, 0, 857, 0, 806, 0], false),\\n    ([0, 0, 0, 475, 469, 0, 858, 0, 807, 0], false),\\n    ([0, 0, 480, 478, 471, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 479, 0, 472, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 473, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 479, 474, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 480, 475, 0, 859, 0, 809, 0], false),\\n    ([0, 0, 0, 481, 476, 0, 860, 0, 810, 0], false),\\n    ([0, 0, 490, 484, 0, 462, 861, 0, 811, 0], false),\\n    ([0, 0, 489, 485, 0, 463, 862, 0, 812, 0], false),\\n    ([0, 0, 488, 486, 0, 464, 0, 0, 0, 0], false),\\n    ([0, 0, 487, 0, 0, 465, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 466, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 487, 0, 467, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 488, 0, 468, 863, 0, 813, 0], false),\\n    ([0, 0, 0, 489, 0, 469, 864, 0, 814, 0], false),\\n    ([0, 0, 496, 492, 484, 470, 865, 0, 815, 0], false),\\n    ([0, 0, 495, 493, 485, 471, 0, 0, 0, 0], false),\\n    ([0, 0, 494, 0, 486, 472, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 487, 473, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 494, 488, 474, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 495, 489, 475, 866, 0, 816, 0], false),\\n    ([0, 0, 500, 498, 492, 477, 0, 0, 0, 0], false),\\n    ([0, 0, 499, 0, 493, 478, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 494, 479, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 499, 495, 480, 0, 0, 0, 0], false),\\n    ([1199, 1197, 0, 500, 496, 481, 868, 1175, 818, 1075], false),\\n    ([0, 0, 505, 503, 0, 485, 0, 0, 0, 0], false),\\n    ([0, 0, 504, 0, 0, 486, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 487, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 504, 0, 488, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 505, 0, 489, 870, 0, 821, 0], false),\\n    ([0, 0, 510, 508, 502, 492, 0, 0, 0, 0], false),\\n    ([0, 0, 509, 0, 503, 493, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 504, 494, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 509, 505, 495, 0, 0, 0, 0], false),\\n    ([0, 727, 724, 510, 506, 496, 871, 705, 652, 0], false),\\n    ([0, 0, 515, 513, 507, 497, 0, 0, 0, 0], false),\\n    ([0, 0, 514, 0, 508, 498, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 509, 499, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 514, 510, 500, 0, 0, 0, 0], false),\\n    ([539, 537, 0, 0, 533, 0, 517, 0, 0, 0], false),\\n    ([532, 530, 0, 0, 526, 0, 518, 0, 0, 0], false),\\n    ([525, 523, 0, 0, 519, 0, 0, 0, 0, 0], false),\\n    ([522, 520, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([521, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 521, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([524, 0, 0, 0, 520, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 521, 0, 0, 0, 0, 0], false),\\n    ([0, 524, 0, 0, 522, 0, 0, 0, 0, 0], false),\\n    ([529, 527, 0, 0, 0, 0, 519, 0, 0, 0], false),\\n    ([528, 0, 0, 0, 0, 0, 520, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 521, 0, 0, 0], false),\\n    ([0, 528, 0, 0, 0, 0, 522, 0, 0, 0], false),\\n    ([531, 0, 0, 0, 527, 0, 523, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 528, 0, 524, 0, 0, 0], false),\\n    ([0, 531, 0, 0, 529, 0, 525, 0, 0, 0], false),\\n    ([536, 534, 0, 0, 0, 0, 526, 0, 0, 0], false),\\n    ([535, 0, 0, 0, 0, 0, 527, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 528, 0, 0, 0], false),\\n    ([0, 535, 0, 0, 0, 0, 529, 0, 0, 0], false),\\n    ([538, 0, 0, 0, 534, 0, 530, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 535, 0, 531, 0, 0, 0], false),\\n    ([0, 538, 0, 0, 536, 0, 532, 0, 0, 0], false),\\n    ([547, 545, 0, 0, 541, 0, 0, 518, 0, 0], false),\\n    ([544, 542, 0, 0, 0, 0, 0, 519, 0, 0], false),\\n    ([543, 0, 0, 0, 0, 0, 0, 520, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 521, 0, 0], false),\\n    ([0, 543, 0, 0, 0, 0, 0, 522, 0, 0], false),\\n    ([546, 0, 0, 0, 542, 0, 0, 523, 0, 0], false),\\n    ([0, 0, 0, 0, 543, 0, 0, 524, 0, 0], false),\\n    ([0, 546, 0, 0, 544, 0, 0, 525, 0, 0], false),\\n    ([551, 549, 0, 0, 0, 0, 541, 526, 0, 0], false),\\n    ([550, 0, 0, 0, 0, 0, 542, 527, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 543, 528, 0, 0], false),\\n    ([0, 550, 0, 0, 0, 0, 544, 529, 0, 0], false),\\n    ([553, 0, 0, 0, 549, 0, 545, 530, 0, 0], false),\\n    ([0, 0, 0, 0, 550, 0, 546, 531, 0, 0], false),\\n    ([555, 0, 0, 0, 0, 0, 549, 534, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 550, 535, 0, 0], false),\\n    ([0, 555, 0, 0, 0, 0, 551, 536, 0, 0], false),\\n    ([558, 0, 0, 0, 554, 0, 552, 537, 0, 0], false),\\n    ([0, 0, 0, 0, 555, 0, 553, 538, 0, 0], false),\\n    ([566, 564, 0, 0, 560, 0, 0, 0, 518, 0], false),\\n    ([563, 561, 0, 0, 0, 0, 0, 0, 519, 0], false),\\n    ([562, 0, 0, 0, 0, 0, 0, 0, 520, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 521, 0], false),\\n    ([0, 562, 0, 0, 0, 0, 0, 0, 522, 0], false),\\n    ([565, 0, 0, 0, 561, 0, 0, 0, 523, 0], false),\\n    ([0, 0, 0, 0, 562, 0, 0, 0, 524, 0], false),\\n    ([0, 565, 0, 0, 563, 0, 0, 0, 525, 0], false),\\n    ([574, 572, 770, 768, 568, 737, 0, 559, 540, 0], false),\\n    ([571, 569, 767, 765, 761, 750, 0, 560, 541, 0], false),\\n    ([570, 0, 0, 0, 0, 0, 0, 561, 542, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 562, 543, 0], false),\\n    ([0, 570, 0, 0, 0, 0, 0, 563, 544, 0], false),\\n    ([573, 0, 0, 0, 569, 0, 0, 564, 545, 0], false),\\n    ([0, 0, 0, 0, 570, 0, 0, 565, 546, 0], false),\\n    ([0, 573, 0, 0, 571, 0, 0, 566, 547, 0], false),\\n    ([578, 576, 0, 0, 0, 0, 0, 0, 560, 0], false),\\n    ([577, 0, 0, 0, 0, 0, 0, 0, 561, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 562, 0], false),\\n    ([0, 577, 0, 0, 0, 0, 0, 0, 563, 0], false),\\n    ([0, 0, 0, 0, 577, 0, 0, 0, 565, 0], false),\\n    ([0, 579, 0, 0, 578, 0, 0, 0, 566, 0], false),\\n    ([584, 582, 849, 847, 843, 833, 0, 575, 568, 0], false),\\n    ([583, 0, 0, 0, 0, 0, 0, 576, 569, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 577, 570, 0], false),\\n    ([0, 583, 0, 0, 0, 0, 0, 578, 571, 0], false),\\n    ([0, 0, 0, 0, 583, 0, 0, 579, 573, 0], false),\\n    ([0, 585, 0, 0, 584, 0, 0, 580, 574, 0], false),\\n    ([0, 621, 615, 606, 588, 0, 0, 0, 0, 0], false),\\n    ([0, 604, 598, 589, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 596, 590, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 594, 591, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 592, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 593, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 595, 592, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 593, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 597, 594, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 595, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 602, 599, 590, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 600, 0, 591, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 601, 0, 592, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 593, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 603, 600, 594, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 601, 595, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 605, 602, 596, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 603, 597, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 613, 607, 0, 589, 0, 0, 0, 0, 0], false),\\n    ([0, 611, 608, 0, 590, 0, 0, 0, 0, 0], false),\\n    ([0, 609, 0, 0, 591, 0, 0, 0, 0, 0], false),\\n    ([0, 610, 0, 0, 592, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 593, 0, 0, 0, 0, 0], false),\\n    ([0, 612, 609, 0, 594, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 610, 0, 595, 0, 0, 0, 0, 0], false),\\n    ([0, 614, 611, 0, 596, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 612, 0, 597, 0, 0, 0, 0, 0], false),\\n    ([0, 619, 616, 607, 598, 0, 0, 0, 0, 0], false),\\n    ([0, 617, 0, 608, 599, 0, 0, 0, 0, 0], false),\\n    ([0, 618, 0, 609, 600, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 610, 601, 0, 0, 0, 0, 0], false),\\n    ([0, 620, 617, 611, 602, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 618, 612, 603, 0, 0, 0, 0, 0], false),\\n    ([0, 622, 619, 613, 604, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 620, 614, 605, 0, 0, 0, 0, 0], false),\\n    ([0, 630, 624, 0, 0, 0, 0, 589, 0, 0], false),\\n    ([0, 628, 625, 0, 0, 0, 0, 590, 0, 0], false),\\n    ([0, 626, 0, 0, 0, 0, 0, 591, 0, 0], false),\\n    ([0, 627, 0, 0, 0, 0, 0, 592, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 593, 0, 0], false),\\n    ([0, 629, 626, 0, 0, 0, 0, 594, 0, 0], false),\\n    ([0, 0, 627, 0, 0, 0, 0, 595, 0, 0], false),\\n    ([0, 631, 628, 0, 0, 0, 0, 596, 0, 0], false),\\n    ([0, 0, 629, 0, 0, 0, 0, 597, 0, 0], false),\\n    ([0, 636, 633, 624, 0, 0, 0, 598, 0, 0], false),\\n    ([0, 634, 0, 625, 0, 0, 0, 599, 0, 0], false),\\n    ([0, 635, 0, 626, 0, 0, 0, 600, 0, 0], false),\\n    ([0, 0, 0, 627, 0, 0, 0, 601, 0, 0], false),\\n    ([0, 637, 634, 628, 0, 0, 0, 602, 0, 0], false),\\n    ([0, 0, 635, 629, 0, 0, 0, 603, 0, 0], false),\\n    ([0, 0, 637, 631, 0, 0, 0, 605, 0, 0], false),\\n    ([0, 640, 0, 0, 625, 0, 0, 608, 0, 0], false),\\n    ([0, 641, 0, 0, 626, 0, 0, 609, 0, 0], false),\\n    ([0, 0, 0, 0, 627, 0, 0, 610, 0, 0], false),\\n    ([1119, 643, 640, 0, 628, 1109, 1098, 611, 0, 923], false),\\n    ([0, 0, 641, 0, 629, 0, 0, 612, 0, 0], false),\\n    ([1121, 645, 642, 0, 630, 1112, 1101, 613, 0, 926], false),\\n    ([0, 0, 643, 0, 631, 0, 0, 614, 0, 0], false),\\n    ([0, 647, 0, 639, 633, 0, 0, 616, 0, 0], false),\\n    ([0, 648, 0, 640, 634, 0, 0, 617, 0, 0], false),\\n    ([0, 0, 0, 641, 635, 0, 0, 618, 0, 0], false),\\n    ([1123, 650, 647, 642, 636, 1116, 1104, 619, 0, 930], false),\\n    ([0, 0, 648, 643, 637, 0, 0, 620, 0, 0], false),\\n    ([0, 0, 650, 645, 638, 0, 0, 622, 0, 0], false),\\n    ([0, 656, 653, 0, 821, 816, 797, 624, 0, 0], false),\\n    ([0, 654, 0, 0, 0, 0, 0, 625, 0, 0], false),\\n    ([0, 655, 0, 0, 0, 0, 0, 626, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 627, 0, 0], false),\\n    ([0, 657, 654, 0, 0, 0, 0, 628, 0, 0], false),\\n    ([0, 0, 655, 0, 0, 0, 0, 629, 0, 0], false),\\n    ([0, 0, 657, 0, 0, 0, 0, 631, 0, 0], false),\\n    ([0, 660, 0, 654, 0, 0, 0, 634, 0, 0], false),\\n    ([0, 0, 0, 655, 0, 0, 0, 635, 0, 0], false),\\n    ([0, 662, 659, 656, 0, 0, 0, 636, 0, 0], false),\\n    ([0, 0, 660, 657, 0, 0, 0, 637, 0, 0], false),\\n    ([0, 0, 662, 658, 0, 0, 0, 638, 0, 0], false),\\n    ([0, 665, 0, 0, 653, 0, 0, 639, 0, 0], false),\\n    ([0, 666, 0, 0, 654, 0, 0, 640, 0, 0], false),\\n    ([0, 0, 0, 0, 655, 0, 0, 641, 0, 0], false),\\n    ([1150, 668, 665, 0, 656, 1141, 1134, 642, 0, 986], false),\\n    ([0, 0, 666, 0, 657, 0, 0, 643, 0, 0], false),\\n    ([0, 0, 668, 0, 658, 0, 0, 645, 0, 0], false),\\n    ([0, 671, 0, 665, 659, 0, 0, 647, 0, 0], false),\\n    ([0, 0, 0, 666, 660, 0, 0, 648, 0, 0], false),\\n    ([0, 0, 671, 668, 662, 0, 0, 650, 0, 0], false),\\n    ([0, 0, 672, 669, 663, 0, 0, 651, 0, 0], false),\\n    ([0, 690, 684, 675, 0, 0, 0, 0, 588, 0], false),\\n    ([0, 682, 676, 0, 0, 0, 0, 0, 589, 0], false),\\n    ([0, 680, 677, 0, 0, 0, 0, 0, 590, 0], false),\\n    ([0, 678, 0, 0, 0, 0, 0, 0, 591, 0], false),\\n    ([0, 679, 0, 0, 0, 0, 0, 0, 592, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 593, 0], false),\\n    ([0, 681, 678, 0, 0, 0, 0, 0, 594, 0], false),\\n    ([0, 0, 679, 0, 0, 0, 0, 0, 595, 0], false),\\n    ([0, 683, 680, 0, 0, 0, 0, 0, 596, 0], false),\\n    ([0, 0, 681, 0, 0, 0, 0, 0, 597, 0], false),\\n    ([0, 688, 685, 676, 0, 0, 0, 0, 598, 0], false),\\n    ([0, 686, 0, 677, 0, 0, 0, 0, 599, 0], false),\\n    ([0, 687, 0, 678, 0, 0, 0, 0, 600, 0], false),\\n    ([0, 0, 0, 679, 0, 0, 0, 0, 601, 0], false),\\n    ([0, 689, 686, 680, 0, 0, 0, 0, 602, 0], false),\\n    ([0, 0, 687, 681, 0, 0, 0, 0, 603, 0], false),\\n    ([0, 691, 688, 682, 0, 0, 0, 0, 604, 0], false),\\n    ([0, 0, 689, 683, 0, 0, 0, 0, 605, 0], false),\\n    ([0, 699, 693, 0, 675, 0, 0, 0, 606, 0], false),\\n    ([0, 697, 694, 0, 676, 0, 0, 0, 607, 0], false),\\n    ([0, 695, 0, 0, 677, 0, 0, 0, 608, 0], false),\\n    ([0, 696, 0, 0, 678, 0, 0, 0, 609, 0], false),\\n    ([0, 0, 0, 0, 679, 0, 0, 0, 610, 0], false),\\n    ([0, 698, 695, 0, 680, 0, 0, 0, 611, 0], false),\\n    ([0, 0, 696, 0, 681, 0, 0, 0, 612, 0], false),\\n    ([0, 700, 697, 0, 682, 0, 0, 0, 613, 0], false),\\n    ([0, 0, 698, 0, 683, 0, 0, 0, 614, 0], false),\\n    ([0, 702, 0, 694, 685, 0, 0, 0, 616, 0], false),\\n    ([0, 703, 0, 695, 686, 0, 0, 0, 617, 0], false),\\n    ([0, 0, 0, 696, 687, 0, 0, 0, 618, 0], false),\\n    ([0, 711, 705, 0, 0, 0, 0, 675, 623, 0], false),\\n    ([0, 709, 706, 0, 0, 0, 0, 676, 624, 0], false),\\n    ([0, 707, 0, 0, 0, 0, 0, 677, 625, 0], false),\\n    ([0, 708, 0, 0, 0, 0, 0, 678, 626, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 679, 627, 0], false),\\n    ([0, 710, 707, 0, 0, 0, 0, 680, 628, 0], false),\\n    ([0, 0, 708, 0, 0, 0, 0, 681, 629, 0], false),\\n    ([0, 712, 709, 0, 0, 0, 0, 682, 630, 0], false),\\n    ([0, 0, 710, 0, 0, 0, 0, 683, 631, 0], false),\\n    ([0, 717, 714, 705, 0, 0, 0, 684, 632, 0], false),\\n    ([0, 715, 0, 706, 0, 0, 0, 685, 633, 0], false),\\n    ([0, 716, 0, 707, 0, 0, 0, 686, 634, 0], false),\\n    ([0, 0, 0, 708, 0, 0, 0, 687, 635, 0], false),\\n    ([0, 718, 715, 709, 0, 0, 0, 688, 636, 0], false),\\n    ([0, 0, 716, 710, 0, 0, 0, 689, 637, 0], false),\\n    ([0, 0, 718, 712, 0, 0, 0, 691, 638, 0], false),\\n    ([0, 721, 0, 0, 706, 0, 0, 694, 639, 0], false),\\n    ([0, 722, 0, 0, 707, 0, 0, 695, 640, 0], false),\\n    ([0, 0, 0, 0, 708, 0, 0, 696, 641, 0], false),\\n    ([0, 0, 0, 722, 716, 0, 0, 703, 648, 0], false),\\n    ([0, 725, 0, 0, 0, 0, 0, 706, 653, 0], false),\\n    ([0, 726, 0, 0, 0, 0, 0, 707, 654, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 708, 655, 0], false),\\n    ([0, 728, 725, 0, 0, 0, 0, 709, 656, 0], false),\\n    ([0, 0, 726, 0, 0, 0, 0, 710, 657, 0], false),\\n    ([0, 0, 728, 0, 0, 0, 0, 712, 658, 0], false),\\n    ([0, 0, 0, 726, 0, 0, 0, 716, 660, 0], false),\\n    ([0, 0, 730, 728, 0, 0, 0, 718, 662, 0], false),\\n    ([0, 0, 731, 729, 0, 0, 0, 719, 663, 0], false),\\n    ([0, 734, 0, 0, 724, 0, 0, 720, 664, 0], false),\\n    ([0, 735, 0, 0, 725, 0, 0, 721, 665, 0], false),\\n    ([0, 0, 0, 0, 726, 0, 0, 722, 666, 0], false),\\n    ([0, 0, 0, 735, 730, 0, 0, 723, 671, 0], false),\\n    ([0, 0, 760, 758, 750, 738, 0, 0, 0, 0], false),\\n    ([0, 0, 749, 747, 739, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 746, 744, 740, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 743, 741, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 742, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 742, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 745, 0, 741, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 742, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 745, 743, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 748, 0, 744, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 745, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 748, 746, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 757, 755, 751, 739, 0, 0, 0, 0], false),\\n    ([0, 0, 754, 752, 0, 740, 0, 0, 0, 0], false),\\n    ([0, 0, 753, 0, 0, 741, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 742, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 753, 0, 743, 0, 0, 0, 0], false),\\n    ([0, 0, 756, 0, 752, 744, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 753, 745, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 756, 754, 746, 0, 0, 0, 0], false),\\n    ([0, 0, 759, 0, 755, 747, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 756, 748, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 759, 757, 749, 0, 0, 0, 0], false),\\n    ([0, 0, 764, 762, 0, 751, 0, 0, 0, 0], false),\\n    ([0, 0, 763, 0, 0, 752, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 753, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 763, 0, 754, 0, 0, 0, 0], false),\\n    ([0, 0, 766, 0, 762, 755, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 763, 756, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 766, 764, 757, 0, 0, 0, 0], false),\\n    ([0, 0, 769, 0, 765, 758, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 766, 759, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 769, 767, 760, 0, 0, 0, 0], false),\\n    ([0, 0, 782, 780, 772, 0, 738, 0, 0, 0], false),\\n    ([0, 0, 779, 777, 773, 0, 739, 0, 0, 0], false),\\n    ([0, 0, 776, 774, 0, 0, 740, 0, 0, 0], false),\\n    ([0, 0, 775, 0, 0, 0, 741, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 742, 0, 0, 0], false),\\n    ([0, 0, 0, 775, 0, 0, 743, 0, 0, 0], false),\\n    ([0, 0, 778, 0, 774, 0, 744, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 775, 0, 745, 0, 0, 0], false),\\n    ([0, 0, 0, 778, 776, 0, 746, 0, 0, 0], false),\\n    ([0, 0, 781, 0, 777, 0, 747, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 778, 0, 748, 0, 0, 0], false),\\n    ([0, 0, 0, 781, 779, 0, 749, 0, 0, 0], false),\\n    ([0, 0, 786, 784, 0, 773, 751, 0, 0, 0], false),\\n    ([0, 0, 785, 0, 0, 774, 752, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 775, 753, 0, 0, 0], false),\\n    ([0, 0, 0, 785, 0, 776, 754, 0, 0, 0], false),\\n    ([0, 0, 788, 0, 784, 777, 755, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 785, 778, 756, 0, 0, 0], false),\\n    ([0, 0, 0, 788, 786, 779, 757, 0, 0, 0], false),\\n    ([1130, 1128, 791, 0, 787, 780, 758, 1086, 0, 938], false),\\n    ([1127, 1125, 0, 0, 788, 781, 759, 1087, 0, 939], false),\\n    ([1133, 1131, 0, 791, 789, 782, 760, 1094, 0, 946], false),\\n    ([0, 0, 796, 794, 0, 783, 761, 0, 0, 0], false),\\n    ([0, 0, 795, 0, 0, 784, 762, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 785, 763, 0, 0, 0], false),\\n    ([0, 0, 0, 795, 0, 786, 764, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 795, 788, 766, 0, 0, 0], false),\\n    ([0, 0, 0, 797, 796, 789, 767, 0, 0, 0], false),\\n    ([0, 0, 810, 808, 800, 0, 771, 0, 0, 0], false),\\n    ([0, 0, 807, 805, 801, 0, 772, 0, 0, 0], false),\\n    ([0, 0, 804, 802, 0, 0, 773, 0, 0, 0], false),\\n    ([0, 0, 803, 0, 0, 0, 774, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 775, 0, 0, 0], false),\\n    ([0, 0, 0, 803, 0, 0, 776, 0, 0, 0], false),\\n    ([0, 0, 806, 0, 802, 0, 777, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 803, 0, 778, 0, 0, 0], false),\\n    ([0, 0, 0, 806, 804, 0, 779, 0, 0, 0], false),\\n    ([0, 0, 809, 0, 805, 0, 780, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 806, 0, 781, 0, 0, 0], false),\\n    ([0, 0, 0, 809, 807, 0, 782, 0, 0, 0], false),\\n    ([0, 0, 814, 812, 0, 801, 783, 0, 0, 0], false),\\n    ([0, 0, 813, 0, 0, 802, 784, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 803, 785, 0, 0, 0], false),\\n    ([0, 0, 0, 813, 0, 804, 786, 0, 0, 0], false),\\n    ([0, 0, 816, 0, 812, 805, 787, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 813, 806, 788, 0, 0, 0], false),\\n    ([1146, 1144, 818, 0, 815, 808, 790, 1107, 0, 969], false),\\n    ([1143, 1141, 0, 0, 816, 809, 791, 1108, 0, 970], false),\\n    ([0, 0, 822, 820, 0, 811, 793, 0, 0, 0], false),\\n    ([0, 0, 821, 0, 0, 812, 794, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 813, 795, 0, 0, 0], false),\\n    ([0, 0, 0, 821, 0, 814, 796, 0, 0, 0], false),\\n    ([0, 0, 830, 828, 824, 0, 0, 0, 739, 0], false),\\n    ([0, 0, 827, 825, 0, 0, 0, 0, 740, 0], false),\\n    ([0, 0, 826, 0, 0, 0, 0, 0, 741, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 742, 0], false),\\n    ([0, 0, 0, 826, 0, 0, 0, 0, 743, 0], false),\\n    ([0, 0, 829, 0, 825, 0, 0, 0, 744, 0], false),\\n    ([0, 0, 0, 0, 826, 0, 0, 0, 745, 0], false),\\n    ([0, 0, 0, 829, 827, 0, 0, 0, 746, 0], false),\\n    ([0, 0, 0, 0, 829, 0, 0, 0, 748, 0], false),\\n    ([0, 0, 0, 831, 830, 0, 0, 0, 749, 0], false),\\n    ([0, 0, 840, 838, 834, 823, 0, 0, 750, 0], false),\\n    ([0, 0, 837, 835, 0, 824, 0, 0, 751, 0], false),\\n    ([0, 0, 836, 0, 0, 825, 0, 0, 752, 0], false),\\n    ([0, 0, 0, 0, 0, 826, 0, 0, 753, 0], false),\\n    ([0, 0, 0, 836, 0, 827, 0, 0, 754, 0], false),\\n    ([0, 0, 839, 0, 835, 828, 0, 0, 755, 0], false),\\n    ([0, 0, 0, 0, 836, 829, 0, 0, 756, 0], false),\\n    ([0, 0, 0, 839, 837, 830, 0, 0, 757, 0], false),\\n    ([0, 0, 0, 0, 839, 831, 0, 0, 759, 0], false),\\n    ([0, 0, 0, 841, 840, 832, 0, 0, 760, 0], false),\\n    ([0, 0, 846, 844, 0, 834, 0, 0, 761, 0], false),\\n    ([0, 0, 845, 0, 0, 835, 0, 0, 762, 0], false),\\n    ([0, 0, 0, 0, 0, 836, 0, 0, 763, 0], false),\\n    ([0, 0, 0, 845, 0, 837, 0, 0, 764, 0], false),\\n    ([0, 0, 848, 0, 844, 838, 0, 0, 765, 0], false),\\n    ([0, 0, 0, 0, 845, 839, 0, 0, 766, 0], false),\\n    ([0, 0, 0, 848, 846, 840, 0, 0, 767, 0], false),\\n    ([0, 0, 0, 0, 848, 841, 0, 0, 769, 0], false),\\n    ([0, 0, 858, 856, 852, 0, 823, 0, 772, 0], false),\\n    ([0, 0, 855, 853, 0, 0, 824, 0, 773, 0], false),\\n    ([0, 0, 854, 0, 0, 0, 825, 0, 774, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 826, 0, 775, 0], false),\\n    ([0, 0, 0, 854, 0, 0, 827, 0, 776, 0], false),\\n    ([0, 0, 857, 0, 853, 0, 828, 0, 777, 0], false),\\n    ([0, 0, 0, 0, 854, 0, 829, 0, 778, 0], false),\\n    ([0, 0, 0, 857, 855, 0, 830, 0, 779, 0], false),\\n    ([0, 0, 0, 0, 857, 0, 831, 0, 781, 0], false),\\n    ([0, 0, 0, 859, 858, 0, 832, 0, 782, 0], false),\\n    ([0, 0, 864, 862, 0, 852, 834, 0, 783, 0], false),\\n    ([0, 0, 863, 0, 0, 853, 835, 0, 784, 0], false),\\n    ([0, 0, 0, 0, 0, 854, 836, 0, 785, 0], false),\\n    ([0, 0, 0, 863, 0, 855, 837, 0, 786, 0], false),\\n    ([0, 0, 866, 0, 862, 856, 838, 0, 787, 0], false),\\n    ([0, 0, 0, 0, 863, 857, 839, 0, 788, 0], false),\\n    ([0, 0, 0, 866, 864, 858, 840, 0, 789, 0], false),\\n    ([1184, 1182, 0, 0, 866, 859, 841, 1155, 791, 1046], false),\\n    ([0, 0, 870, 0, 0, 862, 844, 0, 794, 0], false),\\n    ([0, 0, 0, 0, 0, 863, 845, 0, 795, 0], false),\\n    ([0, 0, 0, 0, 870, 866, 848, 0, 797, 0], false),\\n    ([935, 933, 929, 921, 0, 905, 873, 0, 0, 0], false),\\n    ([904, 902, 898, 890, 0, 874, 0, 0, 0, 0], false),\\n    ([889, 887, 883, 875, 0, 0, 0, 0, 0, 0], false),\\n    ([882, 880, 876, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([879, 877, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([878, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 878, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([881, 0, 877, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 878, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 881, 879, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([886, 884, 0, 876, 0, 0, 0, 0, 0, 0], false),\\n    ([885, 0, 0, 877, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 878, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 885, 0, 879, 0, 0, 0, 0, 0, 0], false),\\n    ([888, 0, 884, 880, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 885, 881, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 888, 886, 882, 0, 0, 0, 0, 0, 0], false),\\n    ([897, 895, 891, 0, 0, 875, 0, 0, 0, 0], false),\\n    ([894, 892, 0, 0, 0, 876, 0, 0, 0, 0], false),\\n    ([893, 0, 0, 0, 0, 877, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 878, 0, 0, 0, 0], false),\\n    ([0, 893, 0, 0, 0, 879, 0, 0, 0, 0], false),\\n    ([896, 0, 892, 0, 0, 880, 0, 0, 0, 0], false),\\n    ([0, 0, 893, 0, 0, 881, 0, 0, 0, 0], false),\\n    ([0, 896, 894, 0, 0, 882, 0, 0, 0, 0], false),\\n    ([901, 899, 0, 891, 0, 883, 0, 0, 0, 0], false),\\n    ([900, 0, 0, 892, 0, 884, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 893, 0, 885, 0, 0, 0, 0], false),\\n    ([0, 900, 0, 894, 0, 886, 0, 0, 0, 0], false),\\n    ([903, 0, 899, 895, 0, 887, 0, 0, 0, 0], false),\\n    ([0, 0, 900, 896, 0, 888, 0, 0, 0, 0], false),\\n    ([0, 903, 901, 897, 0, 889, 0, 0, 0, 0], false),\\n    ([920, 918, 914, 906, 0, 0, 874, 0, 0, 0], false),\\n    ([913, 911, 907, 0, 0, 0, 875, 0, 0, 0], false),\\n    ([910, 908, 0, 0, 0, 0, 876, 0, 0, 0], false),\\n    ([909, 0, 0, 0, 0, 0, 877, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 878, 0, 0, 0], false),\\n    ([0, 909, 0, 0, 0, 0, 879, 0, 0, 0], false),\\n    ([912, 0, 908, 0, 0, 0, 880, 0, 0, 0], false),\\n    ([0, 0, 909, 0, 0, 0, 881, 0, 0, 0], false),\\n    ([0, 912, 910, 0, 0, 0, 882, 0, 0, 0], false),\\n    ([917, 915, 0, 907, 0, 0, 883, 0, 0, 0], false),\\n    ([916, 0, 0, 908, 0, 0, 884, 0, 0, 0], false),\\n    ([0, 0, 0, 909, 0, 0, 885, 0, 0, 0], false),\\n    ([0, 916, 0, 910, 0, 0, 886, 0, 0, 0], false),\\n    ([919, 0, 915, 911, 0, 0, 887, 0, 0, 0], false),\\n    ([0, 0, 916, 912, 0, 0, 888, 0, 0, 0], false),\\n    ([0, 919, 917, 913, 0, 0, 889, 0, 0, 0], false),\\n    ([928, 926, 922, 0, 0, 906, 890, 0, 0, 0], false),\\n    ([925, 923, 0, 0, 0, 907, 891, 0, 0, 0], false),\\n    ([924, 0, 0, 0, 0, 908, 892, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 909, 893, 0, 0, 0], false),\\n    ([0, 924, 0, 0, 0, 910, 894, 0, 0, 0], false),\\n    ([927, 0, 923, 0, 0, 911, 895, 0, 0, 0], false),\\n    ([0, 0, 924, 0, 0, 912, 896, 0, 0, 0], false),\\n    ([0, 927, 925, 0, 0, 913, 897, 0, 0, 0], false),\\n    ([932, 930, 0, 922, 0, 914, 898, 0, 0, 0], false),\\n    ([931, 0, 0, 923, 0, 915, 899, 0, 0, 0], false),\\n    ([0, 0, 0, 924, 0, 916, 900, 0, 0, 0], false),\\n    ([0, 931, 0, 925, 0, 917, 901, 0, 0, 0], false),\\n    ([934, 0, 930, 926, 0, 918, 902, 0, 0, 0], false),\\n    ([0, 0, 931, 927, 0, 919, 903, 0, 0, 0], false),\\n    ([0, 934, 932, 928, 0, 920, 904, 0, 0, 0], false),\\n    ([967, 965, 961, 953, 0, 937, 0, 873, 0, 0], false),\\n    ([952, 950, 946, 938, 0, 0, 0, 874, 0, 0], false),\\n    ([945, 943, 939, 0, 0, 0, 0, 875, 0, 0], false),\\n    ([942, 940, 0, 0, 0, 0, 0, 876, 0, 0], false),\\n    ([941, 0, 0, 0, 0, 0, 0, 877, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 878, 0, 0], false),\\n    ([0, 941, 0, 0, 0, 0, 0, 879, 0, 0], false),\\n    ([944, 0, 940, 0, 0, 0, 0, 880, 0, 0], false),\\n    ([0, 0, 941, 0, 0, 0, 0, 881, 0, 0], false),\\n    ([0, 944, 942, 0, 0, 0, 0, 882, 0, 0], false),\\n    ([949, 947, 0, 939, 0, 0, 0, 883, 0, 0], false),\\n    ([948, 0, 0, 940, 0, 0, 0, 884, 0, 0], false),\\n    ([0, 0, 0, 941, 0, 0, 0, 885, 0, 0], false),\\n    ([0, 948, 0, 942, 0, 0, 0, 886, 0, 0], false),\\n    ([951, 0, 947, 943, 0, 0, 0, 887, 0, 0], false),\\n    ([0, 0, 948, 944, 0, 0, 0, 888, 0, 0], false),\\n    ([0, 951, 949, 945, 0, 0, 0, 889, 0, 0], false),\\n    ([960, 958, 954, 0, 0, 938, 0, 890, 0, 0], false),\\n    ([957, 955, 0, 0, 0, 939, 0, 891, 0, 0], false),\\n    ([956, 0, 0, 0, 0, 940, 0, 892, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 941, 0, 893, 0, 0], false),\\n    ([0, 956, 0, 0, 0, 942, 0, 894, 0, 0], false),\\n    ([959, 0, 955, 0, 0, 943, 0, 895, 0, 0], false),\\n    ([0, 0, 956, 0, 0, 944, 0, 896, 0, 0], false),\\n    ([0, 959, 957, 0, 0, 945, 0, 897, 0, 0], false),\\n    ([964, 962, 0, 954, 0, 946, 0, 898, 0, 0], false),\\n    ([963, 0, 0, 955, 0, 947, 0, 899, 0, 0], false),\\n    ([0, 0, 0, 956, 0, 948, 0, 900, 0, 0], false),\\n    ([0, 963, 0, 957, 0, 949, 0, 901, 0, 0], false),\\n    ([966, 0, 962, 958, 0, 950, 0, 902, 0, 0], false),\\n    ([0, 0, 963, 959, 0, 951, 0, 903, 0, 0], false),\\n    ([0, 966, 964, 960, 0, 952, 0, 904, 0, 0], false),\\n    ([983, 981, 977, 969, 0, 0, 937, 905, 0, 0], false),\\n    ([976, 974, 970, 0, 0, 0, 938, 906, 0, 0], false),\\n    ([973, 971, 0, 0, 0, 0, 939, 907, 0, 0], false),\\n    ([972, 0, 0, 0, 0, 0, 940, 908, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 941, 909, 0, 0], false),\\n    ([0, 972, 0, 0, 0, 0, 942, 910, 0, 0], false),\\n    ([975, 0, 971, 0, 0, 0, 943, 911, 0, 0], false),\\n    ([0, 0, 972, 0, 0, 0, 944, 912, 0, 0], false),\\n    ([0, 975, 973, 0, 0, 0, 945, 913, 0, 0], false),\\n    ([980, 978, 0, 970, 0, 0, 946, 914, 0, 0], false),\\n    ([979, 0, 0, 971, 0, 0, 947, 915, 0, 0], false),\\n    ([0, 0, 0, 972, 0, 0, 948, 916, 0, 0], false),\\n    ([0, 979, 0, 973, 0, 0, 949, 917, 0, 0], false),\\n    ([982, 0, 978, 974, 0, 0, 950, 918, 0, 0], false),\\n    ([0, 0, 979, 975, 0, 0, 951, 919, 0, 0], false),\\n    ([0, 982, 980, 976, 0, 0, 952, 920, 0, 0], false),\\n    ([991, 989, 985, 0, 0, 969, 953, 921, 0, 0], false),\\n    ([988, 986, 0, 0, 0, 970, 954, 922, 0, 0], false),\\n    ([987, 0, 0, 0, 0, 971, 955, 923, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 972, 956, 924, 0, 0], false),\\n    ([0, 987, 0, 0, 0, 973, 957, 925, 0, 0], false),\\n    ([990, 0, 986, 0, 0, 974, 958, 926, 0, 0], false),\\n    ([0, 0, 987, 0, 0, 975, 959, 927, 0, 0], false),\\n    ([0, 990, 988, 0, 0, 976, 960, 928, 0, 0], false),\\n    ([0, 0, 0, 987, 0, 979, 963, 931, 0, 0], false),\\n    ([0, 992, 0, 988, 0, 980, 964, 932, 0, 0], false),\\n    ([0, 0, 992, 990, 0, 982, 966, 934, 0, 0], false),\\n    ([0, 994, 993, 991, 0, 983, 967, 935, 0, 0], false),\\n    ([1027, 1025, 1021, 1013, 0, 997, 0, 0, 873, 0], false),\\n    ([1012, 1010, 1006, 998, 0, 0, 0, 0, 874, 0], false),\\n    ([1005, 1003, 999, 0, 0, 0, 0, 0, 875, 0], false),\\n    ([1002, 1000, 0, 0, 0, 0, 0, 0, 876, 0], false),\\n    ([1001, 0, 0, 0, 0, 0, 0, 0, 877, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 878, 0], false),\\n    ([0, 1001, 0, 0, 0, 0, 0, 0, 879, 0], false),\\n    ([1004, 0, 1000, 0, 0, 0, 0, 0, 880, 0], false),\\n    ([0, 0, 1001, 0, 0, 0, 0, 0, 881, 0], false),\\n    ([0, 1004, 1002, 0, 0, 0, 0, 0, 882, 0], false),\\n    ([1009, 1007, 0, 999, 0, 0, 0, 0, 883, 0], false),\\n    ([1008, 0, 0, 1000, 0, 0, 0, 0, 884, 0], false),\\n    ([0, 0, 0, 1001, 0, 0, 0, 0, 885, 0], false),\\n    ([0, 1008, 0, 1002, 0, 0, 0, 0, 886, 0], false),\\n    ([1011, 0, 1007, 1003, 0, 0, 0, 0, 887, 0], false),\\n    ([0, 0, 1008, 1004, 0, 0, 0, 0, 888, 0], false),\\n    ([0, 1011, 1009, 1005, 0, 0, 0, 0, 889, 0], false),\\n    ([1020, 1018, 1014, 0, 0, 998, 0, 0, 890, 0], false),\\n    ([1017, 1015, 0, 0, 0, 999, 0, 0, 891, 0], false),\\n    ([1016, 0, 0, 0, 0, 1000, 0, 0, 892, 0], false),\\n    ([0, 0, 0, 0, 0, 1001, 0, 0, 893, 0], false),\\n    ([0, 1016, 0, 0, 0, 1002, 0, 0, 894, 0], false),\\n    ([1019, 0, 1015, 0, 0, 1003, 0, 0, 895, 0], false),\\n    ([0, 0, 1016, 0, 0, 1004, 0, 0, 896, 0], false),\\n    ([0, 1019, 1017, 0, 0, 1005, 0, 0, 897, 0], false),\\n    ([1024, 1022, 0, 1014, 0, 1006, 0, 0, 898, 0], false),\\n    ([1023, 0, 0, 1015, 0, 1007, 0, 0, 899, 0], false),\\n    ([0, 0, 0, 1016, 0, 1008, 0, 0, 900, 0], false),\\n    ([0, 1023, 0, 1017, 0, 1009, 0, 0, 901, 0], false),\\n    ([1026, 0, 1022, 1018, 0, 1010, 0, 0, 902, 0], false),\\n    ([0, 0, 1023, 1019, 0, 1011, 0, 0, 903, 0], false),\\n    ([0, 1026, 1024, 1020, 0, 1012, 0, 0, 904, 0], false),\\n    ([1035, 1033, 1029, 0, 0, 0, 998, 0, 906, 0], false),\\n    ([1032, 1030, 0, 0, 0, 0, 999, 0, 907, 0], false),\\n    ([1031, 0, 0, 0, 0, 0, 1000, 0, 908, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1001, 0, 909, 0], false),\\n    ([0, 1031, 0, 0, 0, 0, 1002, 0, 910, 0], false),\\n    ([1034, 0, 1030, 0, 0, 0, 1003, 0, 911, 0], false),\\n    ([0, 0, 1031, 0, 0, 0, 1004, 0, 912, 0], false),\\n    ([0, 1034, 1032, 0, 0, 0, 1005, 0, 913, 0], false),\\n    ([1043, 1041, 1037, 0, 0, 1028, 1013, 0, 921, 0], false),\\n    ([1040, 1038, 0, 0, 0, 1029, 1014, 0, 922, 0], false),\\n    ([1039, 0, 0, 0, 0, 1030, 1015, 0, 923, 0], false),\\n    ([0, 0, 0, 0, 0, 1031, 1016, 0, 924, 0], false),\\n    ([0, 1039, 0, 0, 0, 1032, 1017, 0, 925, 0], false),\\n    ([1042, 0, 1038, 0, 0, 1033, 1018, 0, 926, 0], false),\\n    ([0, 0, 1039, 0, 0, 1034, 1019, 0, 927, 0], false),\\n    ([0, 1042, 1040, 0, 0, 1035, 1020, 0, 928, 0], false),\\n    ([1059, 1057, 1053, 1045, 0, 0, 0, 997, 937, 0], false),\\n    ([1052, 1050, 1046, 0, 0, 0, 0, 998, 938, 0], false),\\n    ([1049, 1047, 0, 0, 0, 0, 0, 999, 939, 0], false),\\n    ([1048, 0, 0, 0, 0, 0, 0, 1000, 940, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1001, 941, 0], false),\\n    ([0, 1048, 0, 0, 0, 0, 0, 1002, 942, 0], false),\\n    ([1051, 0, 1047, 0, 0, 0, 0, 1003, 943, 0], false),\\n    ([0, 0, 1048, 0, 0, 0, 0, 1004, 944, 0], false),\\n    ([0, 1051, 1049, 0, 0, 0, 0, 1005, 945, 0], false),\\n    ([1056, 1054, 0, 1046, 0, 0, 0, 1006, 946, 0], false),\\n    ([1055, 0, 0, 1047, 0, 0, 0, 1007, 947, 0], false),\\n    ([0, 0, 0, 1048, 0, 0, 0, 1008, 948, 0], false),\\n    ([0, 1055, 0, 1049, 0, 0, 0, 1009, 949, 0], false),\\n    ([1058, 0, 1054, 1050, 0, 0, 0, 1010, 950, 0], false),\\n    ([0, 0, 1055, 1051, 0, 0, 0, 1011, 951, 0], false),\\n    ([0, 1058, 1056, 1052, 0, 0, 0, 1012, 952, 0], false),\\n    ([1067, 1065, 1061, 0, 0, 1045, 0, 1013, 953, 0], false),\\n    ([1064, 1062, 0, 0, 0, 1046, 0, 1014, 954, 0], false),\\n    ([1063, 0, 0, 0, 0, 1047, 0, 1015, 955, 0], false),\\n    ([0, 0, 0, 0, 0, 1048, 0, 1016, 956, 0], false),\\n    ([0, 1063, 0, 0, 0, 1049, 0, 1017, 957, 0], false),\\n    ([1066, 0, 1062, 0, 0, 1050, 0, 1018, 958, 0], false),\\n    ([0, 0, 1063, 0, 0, 1051, 0, 1019, 959, 0], false),\\n    ([0, 1066, 1064, 0, 0, 1052, 0, 1020, 960, 0], false),\\n    ([1071, 1069, 0, 1061, 0, 1053, 0, 1021, 961, 0], false),\\n    ([1070, 0, 0, 1062, 0, 1054, 0, 1022, 962, 0], false),\\n    ([0, 0, 0, 1063, 0, 1055, 0, 1023, 963, 0], false),\\n    ([0, 1070, 0, 1064, 0, 1056, 0, 1024, 964, 0], false),\\n    ([1073, 0, 1069, 1065, 0, 1057, 0, 1025, 965, 0], false),\\n    ([0, 0, 1070, 1066, 0, 1058, 0, 1026, 966, 0], false),\\n    ([1081, 1079, 1075, 0, 0, 0, 1045, 1028, 969, 0], false),\\n    ([1078, 1076, 0, 0, 0, 0, 1046, 1029, 970, 0], false),\\n    ([1077, 0, 0, 0, 0, 0, 1047, 1030, 971, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1048, 1031, 972, 0], false),\\n    ([0, 1077, 0, 0, 0, 0, 1049, 1032, 973, 0], false),\\n    ([1080, 0, 1076, 0, 0, 0, 1050, 1033, 974, 0], false),\\n    ([0, 0, 1077, 0, 0, 0, 1051, 1034, 975, 0], false),\\n    ([0, 1080, 1078, 0, 0, 0, 1052, 1035, 976, 0], false),\\n    ([1085, 1083, 0, 0, 0, 1075, 1061, 1037, 985, 0], false),\\n    ([1084, 0, 0, 0, 0, 1076, 1062, 1038, 986, 0], false),\\n    ([0, 0, 0, 0, 0, 1077, 1063, 1039, 987, 0], false),\\n    ([0, 1084, 0, 0, 0, 1078, 1064, 1040, 988, 0], false),\\n    ([1093, 1091, 1087, 0, 0, 0, 0, 0, 0, 875], false),\\n    ([1090, 1088, 0, 0, 0, 0, 0, 0, 0, 876], false),\\n    ([1089, 0, 0, 0, 0, 0, 0, 0, 0, 877], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 878], false),\\n    ([0, 1089, 0, 0, 0, 0, 0, 0, 0, 879], false),\\n    ([1092, 0, 1088, 0, 0, 0, 0, 0, 0, 880], false),\\n    ([0, 0, 1089, 0, 0, 0, 0, 0, 0, 881], false),\\n    ([0, 1092, 1090, 0, 0, 0, 0, 0, 0, 882], false),\\n    ([1097, 1095, 0, 1087, 0, 0, 0, 0, 0, 883], false),\\n    ([1096, 0, 0, 1088, 0, 0, 0, 0, 0, 884], false),\\n    ([0, 0, 0, 1089, 0, 0, 0, 0, 0, 885], false),\\n    ([0, 1096, 0, 1090, 0, 0, 0, 0, 0, 886], false),\\n    ([1099, 0, 0, 0, 0, 1088, 0, 0, 0, 892], false),\\n    ([0, 0, 0, 0, 0, 1089, 0, 0, 0, 893], false),\\n    ([0, 1099, 0, 0, 0, 1090, 0, 0, 0, 894], false),\\n    ([1102, 0, 1098, 0, 0, 1091, 0, 0, 0, 895], false),\\n    ([0, 0, 1099, 0, 0, 1092, 0, 0, 0, 896], false),\\n    ([0, 1102, 1100, 0, 0, 1093, 0, 0, 0, 897], false),\\n    ([1105, 0, 0, 1098, 0, 1095, 0, 0, 0, 899], false),\\n    ([0, 0, 0, 1099, 0, 1096, 0, 0, 0, 900], false),\\n    ([0, 1105, 0, 1100, 0, 1097, 0, 0, 0, 901], false),\\n    ([1114, 1112, 1108, 0, 0, 0, 1086, 0, 0, 906], false),\\n    ([1111, 1109, 0, 0, 0, 0, 1087, 0, 0, 907], false),\\n    ([1110, 0, 0, 0, 0, 0, 1088, 0, 0, 908], false),\\n    ([0, 0, 0, 0, 0, 0, 1089, 0, 0, 909], false),\\n    ([0, 1110, 0, 0, 0, 0, 1090, 0, 0, 910], false),\\n    ([1113, 0, 1109, 0, 0, 0, 1091, 0, 0, 911], false),\\n    ([0, 0, 1110, 0, 0, 0, 1092, 0, 0, 912], false),\\n    ([0, 1113, 1111, 0, 0, 0, 1093, 0, 0, 913], false),\\n    ([1118, 1116, 0, 1108, 0, 0, 1094, 0, 0, 914], false),\\n    ([1117, 0, 0, 1109, 0, 0, 1095, 0, 0, 915], false),\\n    ([0, 0, 0, 1110, 0, 0, 1096, 0, 0, 916], false),\\n    ([0, 1117, 0, 1111, 0, 0, 1097, 0, 0, 917], false),\\n    ([0, 0, 0, 0, 0, 1110, 1099, 0, 0, 924], false),\\n    ([0, 1119, 0, 0, 0, 1111, 1100, 0, 0, 925], false),\\n    ([0, 0, 1119, 0, 0, 1113, 1102, 0, 0, 927], false),\\n    ([0, 1121, 1120, 0, 0, 1114, 1103, 0, 0, 928], false),\\n    ([0, 0, 0, 1119, 0, 1117, 1105, 0, 0, 931], false),\\n    ([0, 1123, 0, 1120, 0, 1118, 1106, 0, 0, 932], false),\\n    ([1126, 0, 0, 0, 0, 0, 0, 1088, 0, 940], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1089, 0, 941], false),\\n    ([0, 1126, 0, 0, 0, 0, 0, 1090, 0, 942], false),\\n    ([1129, 0, 1125, 0, 0, 0, 0, 1091, 0, 943], false),\\n    ([0, 0, 1126, 0, 0, 0, 0, 1092, 0, 944], false),\\n    ([0, 1129, 1127, 0, 0, 0, 0, 1093, 0, 945], false),\\n    ([1132, 0, 0, 1125, 0, 0, 0, 1095, 0, 947], false),\\n    ([0, 0, 0, 1126, 0, 0, 0, 1096, 0, 948], false),\\n    ([0, 1132, 0, 1127, 0, 0, 0, 1097, 0, 949], false),\\n    ([1135, 0, 0, 0, 0, 1125, 0, 1098, 0, 955], false),\\n    ([0, 0, 0, 0, 0, 1126, 0, 1099, 0, 956], false),\\n    ([0, 1135, 0, 0, 0, 1127, 0, 1100, 0, 957], false),\\n    ([0, 0, 1135, 0, 0, 1129, 0, 1102, 0, 959], false),\\n    ([1139, 0, 0, 1134, 0, 1131, 0, 1104, 0, 962], false),\\n    ([0, 0, 0, 1135, 0, 1132, 0, 1105, 0, 963], false),\\n    ([0, 1139, 0, 1136, 0, 1133, 0, 1106, 0, 964], false),\\n    ([1142, 0, 0, 0, 0, 0, 1125, 1109, 0, 971], false),\\n    ([0, 0, 0, 0, 0, 0, 1126, 1110, 0, 972], false),\\n    ([0, 1142, 0, 0, 0, 0, 1127, 1111, 0, 973], false),\\n    ([1145, 0, 1141, 0, 0, 0, 1128, 1112, 0, 974], false),\\n    ([0, 0, 1142, 0, 0, 0, 1129, 1113, 0, 975], false),\\n    ([0, 1145, 1143, 0, 0, 0, 1130, 1114, 0, 976], false),\\n    ([1148, 0, 0, 1141, 0, 0, 1131, 1116, 0, 978], false),\\n    ([0, 0, 0, 1142, 0, 0, 1132, 1117, 0, 979], false),\\n    ([0, 1148, 0, 1143, 0, 0, 1133, 1118, 0, 980], false),\\n    ([0, 0, 0, 0, 0, 1142, 1135, 1119, 0, 987], false),\\n    ([0, 1150, 0, 0, 0, 1143, 1136, 1120, 0, 988], false),\\n    ([0, 0, 1150, 0, 0, 1145, 1137, 1121, 0, 990], false),\\n    ([0, 0, 0, 1150, 0, 1148, 1139, 1123, 0, 992], false),\\n    ([1161, 1159, 1155, 0, 0, 0, 0, 0, 1086, 998], false),\\n    ([1158, 1156, 0, 0, 0, 0, 0, 0, 1087, 999], false),\\n    ([1157, 0, 0, 0, 0, 0, 0, 0, 1088, 1000], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 1089, 1001], false),\\n    ([0, 1157, 0, 0, 0, 0, 0, 0, 1090, 1002], false),\\n    ([1160, 0, 1156, 0, 0, 0, 0, 0, 1091, 1003], false),\\n    ([0, 0, 1157, 0, 0, 0, 0, 0, 1092, 1004], false),\\n    ([0, 1160, 1158, 0, 0, 0, 0, 0, 1093, 1005], false),\\n    ([1165, 1163, 0, 1155, 0, 0, 0, 0, 1094, 1006], false),\\n    ([1164, 0, 0, 1156, 0, 0, 0, 0, 1095, 1007], false),\\n    ([0, 0, 0, 1157, 0, 0, 0, 0, 1096, 1008], false),\\n    ([0, 1164, 0, 1158, 0, 0, 0, 0, 1097, 1009], false),\\n    ([1167, 0, 0, 0, 0, 1156, 0, 0, 1098, 1015], false),\\n    ([0, 0, 0, 0, 0, 1157, 0, 0, 1099, 1016], false),\\n    ([0, 1167, 0, 0, 0, 1158, 0, 0, 1100, 1017], false),\\n    ([1170, 0, 1166, 0, 0, 1159, 0, 0, 1101, 1018], false),\\n    ([0, 0, 1167, 0, 0, 1160, 0, 0, 1102, 1019], false),\\n    ([0, 1170, 1168, 0, 0, 1161, 0, 0, 1103, 1020], false),\\n    ([0, 0, 0, 1167, 0, 1164, 0, 0, 1105, 1023], false),\\n    ([0, 1172, 0, 1168, 0, 1165, 0, 0, 1106, 1024], false),\\n    ([1181, 1179, 1175, 0, 0, 0, 1154, 0, 1107, 1028], false),\\n    ([1178, 1176, 0, 0, 0, 0, 1155, 0, 1108, 1029], false),\\n    ([1177, 0, 0, 0, 0, 0, 1156, 0, 1109, 1030], false),\\n    ([0, 0, 0, 0, 0, 0, 1157, 0, 1110, 1031], false),\\n    ([0, 1177, 0, 0, 0, 0, 1158, 0, 1111, 1032], false),\\n    ([1180, 0, 1176, 0, 0, 0, 1159, 0, 1112, 1033], false),\\n    ([0, 0, 1177, 0, 0, 0, 1160, 0, 1113, 1034], false),\\n    ([0, 1180, 1178, 0, 0, 0, 1161, 0, 1114, 1035], false),\\n    ([1183, 0, 0, 0, 0, 0, 0, 1156, 1125, 1047], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1157, 1126, 1048], false),\\n    ([0, 1183, 0, 0, 0, 0, 0, 1158, 1127, 1049], false),\\n    ([1186, 0, 1182, 0, 0, 0, 0, 1159, 1128, 1050], false),\\n    ([0, 0, 1183, 0, 0, 0, 0, 1160, 1129, 1051], false),\\n    ([0, 1186, 1184, 0, 0, 0, 0, 1161, 1130, 1052], false),\\n    ([1189, 0, 0, 1182, 0, 0, 0, 1163, 1131, 1054], false),\\n    ([0, 0, 0, 1183, 0, 0, 0, 1164, 1132, 1055], false),\\n    ([0, 1189, 0, 1184, 0, 0, 0, 1165, 1133, 1056], false),\\n    ([1192, 0, 0, 0, 0, 1182, 0, 1166, 1134, 1062], false),\\n    ([0, 0, 0, 0, 0, 1183, 0, 1167, 1135, 1063], false),\\n    ([0, 1192, 0, 0, 0, 1184, 0, 1168, 1136, 1064], false),\\n    ([0, 0, 1192, 0, 0, 1186, 0, 1170, 1137, 1066], false),\\n    ([0, 0, 0, 1192, 0, 1189, 0, 1172, 1139, 1070], false),\\n    ([0, 1195, 0, 1193, 0, 1190, 0, 1173, 1140, 1071], false),\\n    ([1198, 0, 0, 0, 0, 0, 1182, 1176, 1141, 1076], false),\\n    ([0, 0, 0, 0, 0, 0, 1183, 1177, 1142, 1077], false),\\n    ([0, 1198, 0, 0, 0, 0, 1184, 1178, 1143, 1078], false),\\n    ([1201, 0, 1197, 0, 0, 0, 1185, 1179, 1144, 1079], false),\\n    ([0, 0, 1198, 0, 0, 0, 1186, 1180, 1145, 1080], false),\\n    ([0, 1201, 1199, 0, 0, 0, 1187, 1181, 1146, 1081], false),\\n];\\n```\n```\\nconst N_DIGITS: usize = 10;\\n\\nuse std::collections::HashMap;\\n\\nfn get_node_id(digits: &[usize], visited: &mut [bool], n_visited: usize) -> usize {\\n    if n_visited == 0 {\\n        usize::MAX\\n    } else {\\n        digits\\n            .iter()\\n            .zip(visited.iter())\\n            .fold(0, |id, (d, v)| if *v { id * 10 + *d } else { id })\\n    }\\n}\\n\\nfn backtrack(\\n    digits: &[usize],\\n    visited: &mut [bool],\\n    depth: usize,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let curr_id = get_node_id(digits, visited, depth);\\n    if depth == digits.len() {\\n        graph.get_mut(&curr_id).unwrap().2 = true;\\n    } else {\\n        graph.entry(curr_id).or_insert_with(|| {\\n            let nn = *node_number;\\n            *node_number += 1;\\n            (nn, [0; N_DIGITS], false)\\n        });\\n\\n        for i in 0..digits.len() {\\n            if !visited[i] {\\n                visited[i] = true;\\n                let next_id = get_node_id(digits, visited, depth + 1);\\n                let next_node_number = graph\\n                    .entry(next_id)\\n                    .or_insert_with(|| {\\n                        let nn = *node_number;\\n                        *node_number += 1;\\n                        (nn, [0; N_DIGITS], false)\\n                    })\\n                    .0;\\n                graph.get_mut(&curr_id).unwrap().1[digits[i]] = next_node_number;\\n                backtrack(digits, visited, depth + 1, graph, node_number);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\nfn get_digits(mut n: i32) -> Vec<usize> {\\n    if n == 0 {\\n        vec![0]\\n    } else {\\n        let mut rez = vec![];\\n        while n > 0 {\\n            rez.push((n % 10) as usize);\\n            n /= 10;\\n        }\\n        rez.sort_unstable_by(|d1, d2| d2.cmp(d1));\\n        rez\\n    }\\n}\\n\\nfn insert(\\n    n: i32,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let digits = get_digits(n);\\n    let mut visited = vec![false; digits.len()];\\n    backtrack(&digits, &mut visited, 0, graph, node_number);\\n}\\n\\nfn main() {\\n    let mut node_number = 0;\\n    let mut graph_map = HashMap::new();\\n    for shift in 0..30 {\\n        insert(1 << shift, &mut graph_map, &mut node_number);\\n    }\\n    let mut graph = graph_map.values().copied().collect::<Vec<_>>();\\n    graph.sort_unstable_by_key(|(node_number, _, _)| *node_number);\\n    let graph = graph\\n        .into_iter()\\n        .map(|(_, edges, leaf)| (edges, leaf))\\n        .collect::<Vec<_>>();\\n    println!(\"{:?}\", graph);\\n    println!(\"{:?}\", graph.len());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482080,
                "title": "c-python-simple-fastest-solution-with-explanation",
                "content": "**Idea:**\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\n**C++ Code:**\\nThe best result for the code below is 0ms / 5.9MB (beats 100% / 83.90%).\\n```\\nclass Solution {\\npublic:\\n    string convert(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = convert(n);\\n        for (int i = 0; i < 30; i++) {\\n            if (s == convert(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Python Code:**\\nThe best result for the code below is 33ms / 14MB (beats 98.93% / 26.74%).\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def getConvert(n):\\n            return \"\".join(sorted([x for x in str(n)]))\\n        s = getConvert(n)\\n        for i in range(30):\\n            if s == getConvert(1<<i): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = convert(n);\\n        for (int i = 0; i < 30; i++) {\\n            if (s == convert(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def getConvert(n):\\n            return \"\".join(sorted([x for x in str(n)]))\\n        s = getConvert(n)\\n        for i in range(30):\\n            if s == getConvert(1<<i): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482051,
                "title": "q869-c-100-time-space-fast-easy",
                "content": "C++ Code:\\n```\\n    bool isEqual(int arr1[10], int arr2[10]) {\\n        for (int i = 0; i < 10; i++) if (arr1[i] != arr2[i]) return 0;\\n        return 1;\\n    }\\n\\n    int countDigits(int num, int digits[10]) {\\n        int cnt = 0;\\n        while (num > 0) digits[num % 10]++, num /= 10, cnt++;\\n        return cnt;\\n    }\\n\\n    bool reorderedPowerOf2(int num) {\\n        if (num > 0) {\\n            int numDigits[10] = { 0 }, numCnt = countDigits(num, numDigits);\\n            long po2 = 1; // po2: Power of 2\\n            while (1) {\\n                int po2Digits[10] = { 0 }, po2Cnt = countDigits(po2, po2Digits);\\n                po2 <<= 1; // same as (po2 = po2 * 2;)\\n                if (po2Cnt < numCnt) continue;\\n                if (po2Cnt > numCnt || po2 > INT_MAX) break;\\n                if (isEqual(numDigits, po2Digits)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n**The complexity of this solution:**\\n-\\tTime: O( n^2 ) // depend on the size of num and po2\\n-\\tSpace: O( 1 ) // constant array size\\n\\nResult: \\n![image](https://assets.leetcode.com/users/images/bceeb8be-3eb7-4c31-8d01-2517b3102621_1661493958.3626537.png)\\n**If you loved this solution please up vote, enjoy your coding \\uD83D\\uDE0A\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool isEqual(int arr1[10], int arr2[10]) {\\n        for (int i = 0; i < 10; i++) if (arr1[i] != arr2[i]) return 0;\\n        return 1;\\n    }\\n\\n    int countDigits(int num, int digits[10]) {\\n        int cnt = 0;\\n        while (num > 0) digits[num % 10]++, num /= 10, cnt++;\\n        return cnt;\\n    }\\n\\n    bool reorderedPowerOf2(int num) {\\n        if (num > 0) {\\n            int numDigits[10] = { 0 }, numCnt = countDigits(num, numDigits);\\n            long po2 = 1; // po2: Power of 2\\n            while (1) {\\n                int po2Digits[10] = { 0 }, po2Cnt = countDigits(po2, po2Digits);\\n                po2 <<= 1; // same as (po2 = po2 * 2;)\\n                if (po2Cnt < numCnt) continue;\\n                if (po2Cnt > numCnt || po2 > INT_MAX) break;\\n                if (isEqual(numDigits, po2Digits)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481945,
                "title": "90-tc-and-78-sc-python-magic",
                "content": "```\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n\\tnum = set(\"\".join(sorted(str(2**i))) for i in range(0, 32))\\n\\tn = \\'\\'.join(sorted(str(n)))\\n\\treturn n in num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n\\tnum = set(\"\".join(sorted(str(2**i))) for i in range(0, 32))\\n\\tn = \\'\\'.join(sorted(str(n)))\\n\\treturn n in num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2481937,
                "title": "c-100-faster-0ms-solution-by-hash",
                "content": "# **Workaround**\\n\\nAccording to the question, we need to reorder the target number `n` to indicate whether the number is power of 2. That is, the count of each digit in `n` must be same as the certain number which is power of 2. Therefore, we can use a custom hash function to count the digits:\\n\\n``` cpp\\nint hashNumber(int n) {\\n  auto res = int(0);              /// our result hash value.\\n  while (n != 0) {                /// loop the number by taking its last digit until it becomes zero. \\n    res += int(pow(10, n % 10));  /// take digit and add res by 10 ^ n.\\n    n /= 10;                      /// iterate to next digit.\\n  }\\n  return res;\\n}\\n```\\n\\nNote for the argument `n` of function. We have constraints from the question `1 <= n <= 10^9` hence there is impossible to have a number with the count of certain digit more than `9`. We can add our result `res` by `pow(10, n%10*m)` if the count of certain digit can be increased to `m`-digits.\\n\\n---\\n# **Constant Variable**\\n\\nWhen it comes to the hash values of the power of 2, it always calculate the same hash value of `1`, `2`, `4`, `8` ... etc. Hence we can memorize the hash value of these number by  `hashNumber(m)` where `1 <= m <= 10^9` and `m` is power of 2, that is, we can construct a `unordered_set` :\\n\\n```cpp\\nauto mp     = unordered_set<int>(); /// our map which is used to store the hash value.\\nauto number = int(1);               /// our iteration of power of 2.\\nwhile (number <= 1e9) {             /// loop the number until it is bigger than 10^9.\\n  mp.emplace(hashNumber(number));   /// insert a hash value of number into our map.\\n  number <<= 1;                     /// iterate the number by multipling it by 2\\n}\\n```\\n\\nFinally, we have a constant `unordered_set`:\\n``` cpp\\nunordered_set<int> hashes{\\n  10,         100,        10000,     100000000,  1000010,    1100,\\n  1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n  1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n  1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n  32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n```\\n\\n---\\n\\n# **Source Code**\\n\\n``` cpp\\nclass Solution {\\nprivate:\\n  inline const static unordered_set<int> hashes{\\n    10,         100,        10000,     100000000,  1000010,    1100,\\n    1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n    1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n    1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n    32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n\\n  int hashNumber(int n) {\\n    auto res = int(0);\\n    while (n != 0) {\\n      res += int(pow(10, n % 10));\\n      n /= 10;\\n    }\\n    return res;\\n  }\\n\\npublic:\\n  bool reorderedPowerOf2(int n) {\\n    return hashes.find(hashNumber(n)) != hashes.end();\\n  }\\n};\\n```\\n# **Complexity**\\n\\n- **Time**: `O(number_of_digits(n))`\\n- **Space**: `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/24a1f710-c749-478e-9fc9-49c0285789f9_1661494383.20038.png)\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "``` cpp\\nint hashNumber(int n) {\\n  auto res = int(0);              /// our result hash value.\\n  while (n != 0) {                /// loop the number by taking its last digit until it becomes zero. \\n    res += int(pow(10, n % 10));  /// take digit and add res by 10 ^ n.\\n    n /= 10;                      /// iterate to next digit.\\n  }\\n  return res;\\n}\\n```\n```cpp\\nauto mp     = unordered_set<int>(); /// our map which is used to store the hash value.\\nauto number = int(1);               /// our iteration of power of 2.\\nwhile (number <= 1e9) {             /// loop the number until it is bigger than 10^9.\\n  mp.emplace(hashNumber(number));   /// insert a hash value of number into our map.\\n  number <<= 1;                     /// iterate the number by multipling it by 2\\n}\\n```\n``` cpp\\nunordered_set<int> hashes{\\n  10,         100,        10000,     100000000,  1000010,    1100,\\n  1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n  1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n  1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n  32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n```\n``` cpp\\nclass Solution {\\nprivate:\\n  inline const static unordered_set<int> hashes{\\n    10,         100,        10000,     100000000,  1000010,    1100,\\n    1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n    1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n    1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n    32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n\\n  int hashNumber(int n) {\\n    auto res = int(0);\\n    while (n != 0) {\\n      res += int(pow(10, n % 10));\\n      n /= 10;\\n    }\\n    return res;\\n  }\\n\\npublic:\\n  bool reorderedPowerOf2(int n) {\\n    return hashes.find(hashNumber(n)) != hashes.end();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481868,
                "title": "c-simple-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkdigits(int n,vector<int>&v)\\n    {\\n        vector<int>v1(10,-1);\\n        while(n)\\n        {\\n            v1[n%10]++;\\n            n=n/10;\\n        }\\n        if(v1==v)\\n            return true;\\n        return false;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v(10,-1);\\n        while(n)\\n        {\\n            v[n%10]++;\\n            n=n/10;\\n        }\\n        int num=1;\\n        for(int i=1;i<=30;i++)\\n        {\\n            if(checkdigits(num,v))\\n                return true;\\n            num=num*2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkdigits(int n,vector<int>&v)\\n    {\\n        vector<int>v1(10,-1);\\n        while(n)\\n        {\\n            v1[n%10]++;\\n            n=n/10;\\n        }\\n        if(v1==v)\\n            return true;\\n        return false;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v(10,-1);\\n        while(n)\\n        {\\n            v[n%10]++;\\n            n=n/10;\\n        }\\n        int num=1;\\n        for(int i=1;i<=30;i++)\\n        {\\n            if(checkdigits(num,v))\\n                return true;\\n            num=num*2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481815,
                "title": "100-faster-c-solution-easy-understanding-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n        vector<int> gem(long int n) {\\n        vector<int>nums(10);\\n        \\n        while(n){\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>arr=gem(n);\\n        for(int i=0;i<31;i++){\\n            if(arr==gem(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n        vector<int> gem(long int n) {\\n        vector<int>nums(10);\\n        \\n        while(n){\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>arr=gem(n);\\n        for(int i=0;i<31;i++){\\n            if(arr==gem(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481805,
                "title": "approach-converting-into-string-max-tc-o-33-9-log-9-i-e-o-1-constant-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<33;i++){\\n            string x = to_string((long long)pow(2,i));\\n            sort(x.begin(),x.end());\\n            if(s==x){\\n                // cout<<s<<\" \"<<x<<endl;\\n                return true;\\n            }\\n                        \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<33;i++){\\n            string x = to_string((long long)pow(2,i));\\n            sort(x.begin(),x.end());\\n            if(s==x){\\n                // cout<<s<<\" \"<<x<<endl;\\n                return true;\\n            }\\n                        \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2481586,
                "title": "c",
                "content": "first we convert the given number to string and sort it. Then we compare the sorted string to every power of 2 till 30(as constraint is 10^9, so it can not exceed 2^30). If we find that n==2^x the we return true.\\n\\n bool reorderedPowerOf2(int n) {\\n       \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<31;i++)\\n        {\\n            int n= pow(2,i);\\n            string s2 = to_string(n);\\n            sort(s2.begin(),s2.end());\\n            if(s2==s) return true;\\n        }\\n        return false;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "first we convert the given number to string and sort it. Then we compare the sorted string to every power of 2 till 30(as constraint is 10^9, so it can not exceed 2^30). If we find that n==2^x the we return true.\\n\\n bool reorderedPowerOf2(int n) {\\n       \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<31;i++)\\n        {\\n            int n= pow(2,i);\\n            string s2 = to_string(n);\\n            sort(s2.begin(),s2.end());\\n            if(s2==s) return true;\\n        }\\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2481585,
                "title": "c-solution-using-sorting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string x = to_string(n);\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<32;i++){\\n            string temp = to_string(1<<i);\\n            sort(temp.begin(),temp.end());\\n            if(x==temp) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string x = to_string(n);\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<32;i++){\\n            string temp = to_string(1<<i);\\n            sort(temp.begin(),temp.end());\\n            if(x==temp) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481490,
                "title": "c-easy-solution-100-fast",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        for (int i = 0; i <= 30; i++)\\n        {\\n            int p = pow(2, i);\\n            string t = to_string(p);\\n            sort(t.begin(), t.end());\\n            if (t == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        for (int i = 0; i <= 30; i++)\\n        {\\n            int p = pow(2, i);\\n            string t = to_string(p);\\n            sort(t.begin(), t.end());\\n            if (t == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481455,
                "title": "string-based-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        int i = 1;\\n        int lenOfN = floor(log10(n)+1);\\n        int lenOfI = floor(log10(i)+1);\\n        string sn = to_string(n);\\n        sort(sn.begin(), sn.end());\\n        while(lenOfI<=lenOfN){\\n            \\n            string si = to_string(i);\\n            sort(si.begin(), si.end());\\n            \\n            if(lenOfN==lenOfI){\\n                    \\n                if(sn.compare(si)==0) return true;\\n            }\\n            \\n            i = i*2;\\n            lenOfI = floor(log10(i)+1);\\n      \\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        int i = 1;\\n        int lenOfN = floor(log10(n)+1);\\n        int lenOfI = floor(log10(i)+1);\\n        string sn = to_string(n);\\n        sort(sn.begin(), sn.end());\\n        while(lenOfI<=lenOfN){\\n            \\n            string si = to_string(i);\\n            sort(si.begin(), si.end());\\n            \\n            if(lenOfN==lenOfI){\\n                    \\n                if(sn.compare(si)==0) return true;\\n            }\\n            \\n            i = i*2;\\n            lenOfI = floor(log10(i)+1);\\n      \\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481415,
                "title": "c-good-code-quality-next-permutation-solution",
                "content": "We are generating each permutation from the string converting it back to integer and checking if it is a power of 2 or not. The runtime is not good it beats 10% but it is a different solution than the rest of discuss.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool LeadingDigitZero(string s){\\n        return s[0] == \\'0\\';\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        if(ceil(log2(n)) == floor(log2(n))){\\n            return true;\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            n = stoi(s);\\n            if(!LeadingDigitZero(s) && ceil(log2(n)) == floor(log2(n))){\\n                return true;\\n            }\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool LeadingDigitZero(string s){\\n        return s[0] == \\'0\\';\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        if(ceil(log2(n)) == floor(log2(n))){\\n            return true;\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            n = stoi(s);\\n            if(!LeadingDigitZero(s) && ceil(log2(n)) == floor(log2(n))){\\n                return true;\\n            }\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481395,
                "title": "java-solution-easy-counting-with-comments",
                "content": "### **Approach:**\\n##### *The Approach is to check whether the given number n is an anagram of another number m, where m is a power of two 1<=m<=Math.pow(2,30).*\\n```java \\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        String s=n+\"\";\\n        int[] a = new int[10];   // frequency of digits in number s, s=n\\n        for(int i=0;i<s.length();i++)\\n            a[s.charAt(i)-\\'0\\']++;\\n\\n        int i=1;\\n        String t = \"1\";   //Math.pow(2,0) =1\\n        while(s.length()>=t.length())\\n        {\\n            if(s.length()==t.length()){\\n            int[] b = new int[10];     // frequency of digits in number t, where t = Math.pow(2,i)\\n                \\n            for(int j=0;j<t.length();j++)\\n                b[t.charAt(j)-\\'0\\']++;\\n                \\n            if(Arrays.equals(a,b))   //Checking whether String s is Anagram of String t\\n                return true;\\n            }\\n            t = (int)Math.pow(2,i++)+\"\";\\n        }\\n        return false;\\n    }  \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        String s=n+\"\";\\n        int[] a = new int[10];   // frequency of digits in number s, s=n\\n        for(int i=0;i<s.length();i++)\\n            a[s.charAt(i)-\\'0\\']++;\\n\\n        int i=1;\\n        String t = \"1\";   //Math.pow(2,0) =1\\n        while(s.length()>=t.length())\\n        {\\n            if(s.length()==t.length()){\\n            int[] b = new int[10];     // frequency of digits in number t, where t = Math.pow(2,i)\\n                \\n            for(int j=0;j<t.length();j++)\\n                b[t.charAt(j)-\\'0\\']++;\\n                \\n            if(Arrays.equals(a,b))   //Checking whether String s is Anagram of String t\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2481394,
                "title": "c-stirng-solution",
                "content": "```\\n    bool reorderedPowerOf2(int n) {\\n        int i=0;\\n        string s1=to_string(n);\\n        sort(s1.begin(),s1.end());\\n        while(true)\\n        {\\n            int temp = pow(2,i);\\n            int digits= floor(log10(temp) + 1);\\n            int n_digits= floor(log10(n)+1);\\n            if(digits==n_digits)\\n            {\\n                string s=to_string(temp);\\n                sort(s.begin(),s.end());\\n                if(s.compare(s1)==0){\\n                    // cout<<s<<\" \"<<s1<<endl;\\n                    return true;\\n                }\\n            }\\n            if(digits>n_digits)\\n                return false;\\n            i++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n    bool reorderedPowerOf2(int n) {\\n        int i=0;\\n        string s1=to_string(n);\\n        sort(s1.begin(),s1.end());\\n        while(true)\\n        {\\n            int temp = pow(2,i);\\n            int digits= floor(log10(temp) + 1);\\n            int n_digits= floor(log10(n)+1);\\n            if(digits==n_digits)\\n            {\\n                string s=to_string(temp);\\n                sort(s.begin(),s.end());\\n                if(s.compare(s1)==0){\\n                    // cout<<s<<\" \"<<s1<<endl;\\n                    return true;\\n                }\\n            }\\n            if(digits>n_digits)\\n                return false;\\n            i++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2481356,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> func(int n){\\n        vector<int>ans(10);\\n        \\n        while(n){\\n            ans[n%10]++;\\n            n/=10;\\n        }\\n        \\n        return ans;\\n    }   \\n    \\n    bool reorderedPowerOf2(int n) {\\n                \\n        if((n&(n-1))==0)return true;\\n        \\n        vector<int>ans=func(n);\\n        \\n        for(int i=1;i<31;i++){\\n            vector<int>v=func(1<<i);\\n            if(v==ans)return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> func(int n){\\n        vector<int>ans(10);\\n        \\n        while(n){\\n            ans[n%10]++;\\n            n/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2481355,
                "title": "c-easy-string-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        long long x = 1;\\n        vector<string> arr;\\n        while(x <= 1000000000){\\n            arr.push_back(to_string(x)); // store all the power of 2s less than 1e9 in a vector\\n            x *= 2;\\n        }\\n        for(auto &i : arr){\\n            sort(i.begin(), i.end()); // sort each power of 2 \\n        }\\n        string s = to_string(n);\\n        sort(s.begin(), s.end()); // sort given number\\n        for(auto i : arr){\\n            if(i == s) // if our number matches with any of the number which is of power two, then we can re-arrange our number.\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        long long x = 1;\\n        vector<string> arr;\\n        while(x <= 1000000000){\\n            arr.push_back(to_string(x)); // store all the power of 2s less than 1e9 in a vector\\n            x *= 2;\\n        }\\n        for(auto &i : arr){\\n            sort(i.begin(), i.end()); // sort each power of 2 \\n        }\\n        string s = to_string(n);\\n        sort(s.begin(), s.end()); // sort given number\\n        for(auto i : arr){\\n            if(i == s) // if our number matches with any of the number which is of power two, then we can re-arrange our number.\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481253,
                "title": "javascript-easy-understanding-with-explanation",
                "content": "Instead of shuffling we can sort the the input value and do the comparison of sorted values of pow of i \\nPlease upvote the solution \\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar reorderedPowerOf2 = function(n) {\\n// If the value is 1 return true\\n    if(n===1) return true;\\n    let total = 1;\\n    let i = 1;\\n\\t// coverting the given number and sorted that with any order(ASC/DESC) \\n    let nTemp = n.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t// If the length of the string is more than the given one means we can break the loop and return false \\n    while(total.toString().length<=n.toString().length){\\n        total = Math.pow(2,i);\\n        let tTemp = total.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t\\t// Comparing the pow of 2 and the given number\\n        if(tTemp===nTemp) return true;\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar reorderedPowerOf2 = function(n) {\\n// If the value is 1 return true\\n    if(n===1) return true;\\n    let total = 1;\\n    let i = 1;\\n\\t// coverting the given number and sorted that with any order(ASC/DESC) \\n    let nTemp = n.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t// If the length of the string is more than the given one means we can break the loop and return false \\n    while(total.toString().length<=n.toString().length){\\n        total = Math.pow(2,i);\\n        let tTemp = total.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t\\t// Comparing the pow of 2 and the given number\\n        if(tTemp===nTemp) return true;\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481233,
                "title": "daily-leetcode-solution-time-complexity-log-n-space-complexity-log-n",
                "content": "![image](https://assets.leetcode.com/users/images/6b668789-1528-4080-9ea3-37b97cff6585_1661483519.3508134.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/6b668789-1528-4080-9ea3-37b97cff6585_1661483519.3508134.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2481227,
                "title": "very-easy-to-understand-implementation-with-80-runtime",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        list_of_powers_of_2=[]\\n        for i in range(31):\\n            list_of_powers_of_2.append(\\'\\'.join(sorted(str(1<<i))))   ## storing powers of 2 as sorted string to help checking reorder of number given matches or not. \\n        return \\'\\'.join(sorted(str(n))) in list_of_powers_of_2 \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        list_of_powers_of_2=[]\\n        for i in range(31):\\n            list_of_powers_of_2.append(\\'\\'.join(sorted(str(1<<i))))   ## storing powers of 2 as sorted string to help checking reorder of number given matches or not. \\n        return \\'\\'.join(sorted(str(n))) in list_of_powers_of_2 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481143,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n == 1) return true;\\n        unordered_map<int, int> map;\\n        \\n        string temp = to_string(n);\\n        for(int i = 0; i < temp.size(); i++){\\n            map[int(temp[i])-48]++;\\n        }  \\n        \\n        int digits = temp.size();\\n        return helper(map, 1, n, digits);\\n    }\\n    \\n    bool helper(unordered_map<int, int> map, long k, int s, int digits){\\n        if(k > pow(10, digits) - 1) return false;\\n        if(k == s) return true;\\n        \\n        unordered_map<int, int> copy = map;\\n        \\n        string temp = to_string(k);\\n        for(int i = 0; i < temp.size(); i++){\\n            copy[int(temp[i])-48]--;\\n        }\\n        \\n        for(auto &it: copy){\\n            if(it.second != 0) return helper(map, k*2, s, digits);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n == 1) return true;\\n        unordered_map<int, int> map;\\n        \\n        string temp = to_string(n);\\n        for(int i = 0; i < temp.size(); i++){\\n            map[int(temp[i])-48]++;\\n        }  \\n        \\n        int digits = temp.size();\\n        return helper(map, 1, n, digits);\\n    }\\n    \\n    bool helper(unordered_map<int, int> map, long k, int s, int digits){\\n        if(k > pow(10, digits) - 1) return false;\\n        if(k == s) return true;\\n        \\n        unordered_map<int, int> copy = map;\\n        \\n        string temp = to_string(k);\\n        for(int i = 0; i < temp.size(); i++){\\n            copy[int(temp[i])-48]--;\\n        }\\n        \\n        for(auto &it: copy){\\n            if(it.second != 0) return helper(map, k*2, s, digits);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481027,
                "title": "swift-simple-solution",
                "content": "```\\nclass Solution {\\n\\tfunc reorderedPowerOf2(_ n: Int) -> Bool {\\n\\t\\tvar pool = Set<[Character]>()\\n\\t\\tvar i = 1\\n\\t\\twhile i <= 1000000000 {\\n\\t\\t\\tpool.insert(String(i).sorted())\\n\\t\\t\\ti *= 2\\n\\t\\t}\\n\\t\\treturn pool.contains(String(n).sorted())\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc reorderedPowerOf2(_ n: Int) -> Bool {\\n\\t\\tvar pool = Set<[Character]>()\\n\\t\\tvar i = 1\\n\\t\\twhile i <= 1000000000 {\\n\\t\\t\\tpool.insert(String(i).sorted())\\n\\t\\t\\ti *= 2\\n\\t\\t}\\n\\t\\treturn pool.contains(String(n).sorted())\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480924,
                "title": "c-clean-code-hashmap",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    vector<int> countdig(int N){\\n        vector<int>digitsInN(10);\\n        while(N)\\n            digitsInN[N % 10]++, N /= 10;\\n        return digitsInN;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digitsInN = countdig(N); \\n        for(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n            if(digitsInN == countdig(powOf2)) return true;  \\n        return false;\\n    }\\n};\\n```\\nTime Complexity : **O(logN)**\\nSpace Complexity : **O(1)**\\n\\nHope this helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countdig(int N){\\n        vector<int>digitsInN(10);\\n        while(N)\\n            digitsInN[N % 10]++, N /= 10;\\n        return digitsInN;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digitsInN = countdig(N); \\n        for(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n            if(digitsInN == countdig(powOf2)) return true;  \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480910,
                "title": "python-precompute-all-power2-and-add-to-set-30ms-beats-100",
                "content": "\\n\\nIdea: \\n- precalculate all power 2 numbers and add them as sorted strings into a set\\n- check if `sorted(str(n))` is in the set\\n\\n```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.s = {\"1\"}\\n        K = 1\\n        while K <= 10** 9:\\n            K <<= 1\\n            self.s.add(\"\".join(sorted(str(K))))\\n            \\n    def reorderedPowerOf2(self, N):\\n        return \"\".join(sorted(str(N))) in self.s\\n```\\n\\nTime: `O(1)` or `O(KlogK)` where `max(K) = 9`\\nSpace: `O(1)` or 32 strings with max length of 9\\n\\n![image](https://assets.leetcode.com/users/images/0fed2e3c-313f-494e-aa12-4d5aa02d1ff6_1661473604.5191245.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.s = {\"1\"}\\n        K = 1\\n        while K <= 10** 9:\\n            K <<= 1\\n            self.s.add(\"\".join(sorted(str(K))))\\n            \\n    def reorderedPowerOf2(self, N):\\n        return \"\".join(sorted(str(N))) in self.s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178138,
                "title": "greate-solution",
                "content": "class Solution {\\npublic:\\n   bool reorderedPowerOf2(int n)\\n{\\n\\n    string num = to_string(n);\\n    int ans = 1;\\n    string ansnum = to_string(ans);\\n    while (ansnum.size() != num.size())\\n    {\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n    }\\n\\n    unordered_map<char, int> mp;\\n    for (int i = 0; i < num.size(); i++)\\n    {\\n        mp[num[i]]++;\\n    }\\n\\n    while (ansnum.size() == num.size())\\n    {\\n        unordered_map<char, int> mp1;\\n        for (int i = 0; i < ansnum.size(); i++)\\n        {\\n            mp1[ansnum[i]]++;\\n        }\\n\\n        if (mp == mp1)\\n            return 1;\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n\\n    }\\n    return 0;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   bool reorderedPowerOf2(int n)\\n{\\n\\n    string num = to_string(n);\\n    int ans = 1;\\n    string ansnum = to_string(ans);\\n    while (ansnum.size() != num.size())\\n    {\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1825803,
                "title": "javascript-869-reordered-power-of-2",
                "content": "---\\n\\n- Used known powers of 2, as question is a different test\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar reorderedPowerOf2 = function (n) {\\n    let p2 = [\\n        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\\n\\t\\t16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, /* , 2147483648, 4294967296, 8589934592, */\\n    ];\\n\\n    let ns = (\"\" + n).split(\"\").sort().join(\"\");\\n\\n    OUTER:\\n\\tfor (let p of p2) {\\n        let ps = (\"\" + p).split(\"\").sort().join(\"\");\\n        if (ps.length > ns.length) return false;\\n        if (ps === ns) return true;\\n    }\\n\\n    return false;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function (n) {\\n    let p2 = [\\n        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\\n\\t\\t16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, /* , 2147483648, 4294967296, 8589934592, */\\n    ];\\n\\n    let ns = (\"\" + n).split(\"\").sort().join(\"\");\\n\\n    OUTER:\\n\\tfor (let p of p2) {\\n        let ps = (\"\" + p).split(\"\").sort().join(\"\");\\n        if (ps.length > ns.length) return false;\\n        if (ps === ns) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606443,
                "title": "c-0-ms-faster-than-100-solution-by-sorting-string",
                "content": "- Sort the digits of n and the numbers of form 2^i in the same order, then check if n is the same as the number of forms 2^i \\n- example: \\nn = 2401 -> 0124 \\n2^10 = 1024 -> 0124 \\n=> true\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int a=pow(2,i);\\n            power.push_back(to_string(a));\\n        }\\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n\\n        for(int i=0;i<=30;i++){\\n            if(s==power[i]){return true;}\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int a=pow(2,i);\\n            power.push_back(to_string(a));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1313945,
                "title": "c-solution",
                "content": "```\\n\\n```public:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        long long int i,x;\\n        sort(s.begin(),s.end());\\n        for(i=0;i<=30;i++)\\n        {\\n            x=pow(2,i);\\n            string s1=to_string(x);\\n            sort(s1.begin(),s1.end());\\n            if(s==s1)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121817,
                "title": "rust-fastest-solution-using-64-bit-number-as-counter-array",
                "content": "```rust\\nuse std::iter::successors;\\n\\nlazy_static! {\\n    static ref POWS: Vec<u64> = (0..30).map(|x| 1 << x).map(digit_map).collect();\\n}\\npub fn reordered_power_of2(n: i32) -> bool {\\n    POWS.contains(&digit_map(n))\\n}\\n\\nfn digit_map(n: i32) -> u64 {\\n    successors(Some(n), |&x| Some(x / 10))\\n        .take_while(|&x| x > 0)\\n        .map(|x| x % 10)\\n        .fold(0, |m, c| {\\n            let mask = 0b1111 << 4 * c;\\n            let count = ((m & mask) >> 4 * c) + 1;\\n            m & (!0 ^ mask) | (count << 4 * c)\\n        })\\n}\\n```\\n\\nthe only tricky part here is `digit_map` function, we use 64-bit number as array of 4-bit numbers. Bits from `4*i` to `4*i + 3` store count of  digit `i`\\n step-by step\\n```\\n    successors(Some(n), |&x| Some(x / 10))          // descending iterator of n / 10^i\\n        .take_while(|&x| x > 0)                     // stop when the number is zero\\n        .map(|x| x % 10)                            // take next digit\\n        .fold(0, |m, d| {                           // m - is current digit bitcounter, d is next digit\\n            let mask = 0b1111 << 4 * d;             // make a mask filtering bits from `4*i` to `4*i + 3`\\n            let count = ((m & mask) >> 4 * d) + 1;  // get and increment current value under the mask\\n            m & (!0 ^ mask) | (count << 4 * d)      // assign number under the mask for the next iteration\\n        });",
                "solutionTags": [],
                "code": "```rust\\nuse std::iter::successors;\\n\\nlazy_static! {\\n    static ref POWS: Vec<u64> = (0..30).map(|x| 1 << x).map(digit_map).collect();\\n}\\npub fn reordered_power_of2(n: i32) -> bool {\\n    POWS.contains(&digit_map(n))\\n}\\n\\nfn digit_map(n: i32) -> u64 {\\n    successors(Some(n), |&x| Some(x / 10))\\n        .take_while(|&x| x > 0)\\n        .map(|x| x % 10)\\n        .fold(0, |m, c| {\\n            let mask = 0b1111 << 4 * c;\\n            let count = ((m & mask) >> 4 * c) + 1;\\n            m & (!0 ^ mask) | (count << 4 * c)\\n        })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120777,
                "title": "heavily-commented-javascript-solution-hash-maps-no-sort",
                "content": "My first thought was going towards generating all posibilities of orders of N\\'s numbers and check if it\\'s a pow by math.\\nThen I was thinking, we only have to check even numbers\\n\\nBut then I took a look at all the numbers that are  power of 2 under 10^9\\nThere are only 29 numbers there, as 2^30 is already over 10^9: 1,073,741,824\\n\\nSo if we generate those pows, or at least up to the N.length + 1\\nWe can then check the numbers that have the same length by a frequency map\\nIf the frequency map of N and one of the target powers is the same, we have a match.\\n\\nFor example: 1234\\nAll the powers of 2 of length 4 (it always has to be the same length as N of course) are:\\n[ 1024, 2048, 4096, 8192 ]\\n\\nThe frequency map of 1234 is:\\n{ \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\nVersus one of the powers of 2:\\n{ \\'1\\': 1, \\'0\\': 1, \\'2\\': 1, \\'4\\': 1 };\\n\\twill not match.\\n\\nBut if we had 1204 as N then we have a freq map of: { \\'1\\': 1, \\'2\\': 1, \\'0\\': 1, \\'4\\': 1 };\\nThough not in the same order as the freq map of 1024, a simple for loop will match them.\\n\\n-- Coding --\\n\\nThat works great with sample input, I think one optimization could be in the poweredNumbers \\ngenerator. I am generating all the pows of lower digit count too. Maybe with some math\\nand binary search I could make that better, but I don\\'t think it\\'s worth the effort.        \\n        \\n\\n\\n\\t/**\\n\\t * @param {number} N\\n\\t * @return {boolean}\\n\\t */\\n\\tvar reorderedPowerOf2 = function(N) {\\n\\n\\n\\t\\tvar maxPowerLength = 0, // I got this variable of a hair blower\\n\\t\\t\\tsN = String(N),\\n\\t\\t\\tnLength = sN.length, // how many numbers are in N total\\n\\t\\t\\tpoweredNumbers = [], // this will hold the numbers we should check N against\\n\\t\\t\\ti = 0,\\n\\t\\t\\tnFreq = {}; // we\\'ll use this in part 2, to check which numbers we need to find\\n\\n\\t\\t// Generate the powers\\n\\t\\twhile (maxPowerLength <= nLength) {\\n\\t\\t\\tlet pow = Math.pow(2, i);\\n\\n\\t\\t\\tmaxPowerLength = String(pow).length;\\n\\n\\t\\t\\t// We\\'re only interested in numbers of the same length, of course\\n\\t\\t\\tif (maxPowerLength === nLength) {\\n\\t\\t\\t\\tpoweredNumbers.push(pow);\\n\\t\\t\\t}\\n\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\t// at this point, for a N like 1234, we\\'ll have poweredNumbers [ 1024, 2048, 4096, 8192 ]\\n\\t\\t// console.log(\\'poweredNumbers\\', poweredNumbers);\\n\\n\\t\\t// now we need to see if all the numbers in N can be check off of one of those\\n\\t\\tnFreq = getFreqMap(sN);\\n\\n\\t\\t// at this point we have nFreq: { \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\t\\t// console.log(\\'nFreq\\', nFreq);\\n\\n\\t\\t// Create a map for the target numbers and see if there is a match\\n\\t\\tfor (var target of poweredNumbers) {\\n\\t\\t\\tlet fm2 = getFreqMap(String(target));\\n\\n\\t\\t\\tif (isFreqMapEqual(nFreq, fm2)) {\\n\\t\\t\\t\\t// we have a match!\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// by reaching this point we\\'ve proven there is no match possible\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/**\\n\\t * Helper function: Create frequency map of a string\\n\\t * @param {string} s\\n\\t * @return {object}\\n\\t */\\n\\tvar getFreqMap = function (s) {\\n\\t\\tvar map = {},\\n\\t\\t\\tl = s.length;\\n\\n\\t\\tfor (i = 0; i < l; i++) {\\n\\t\\t\\tif (!map[s[i]]) {\\n\\t\\t\\t\\tmap[s[i]] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap[s[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn map;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function:  Check if 2 frequency maps hold the same values.\\n\\t *  Assumes the maps are of the same length total\\n\\t * @param {object} fm1 frequency map\\n\\t * @param {object} fm2 frequence map\\n\\t * @return {boolean}\\n\\t */\\n\\tvar isFreqMapEqual = function(fm1, fm2) {\\n\\n\\t\\tfor (var entry in fm1) {\\n\\t\\t\\tif (fm1[entry] !== fm2[entry]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "My first thought was going towards generating all posibilities of orders of N\\'s numbers and check if it\\'s a pow by math.\\nThen I was thinking, we only have to check even numbers\\n\\nBut then I took a look at all the numbers that are  power of 2 under 10^9\\nThere are only 29 numbers there, as 2^30 is already over 10^9: 1,073,741,824\\n\\nSo if we generate those pows, or at least up to the N.length + 1\\nWe can then check the numbers that have the same length by a frequency map\\nIf the frequency map of N and one of the target powers is the same, we have a match.\\n\\nFor example: 1234\\nAll the powers of 2 of length 4 (it always has to be the same length as N of course) are:\\n[ 1024, 2048, 4096, 8192 ]\\n\\nThe frequency map of 1234 is:\\n{ \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\nVersus one of the powers of 2:\\n{ \\'1\\': 1, \\'0\\': 1, \\'2\\': 1, \\'4\\': 1 };\\n\\twill not match.\\n\\nBut if we had 1204 as N then we have a freq map of: { \\'1\\': 1, \\'2\\': 1, \\'0\\': 1, \\'4\\': 1 };\\nThough not in the same order as the freq map of 1024, a simple for loop will match them.\\n\\n-- Coding --\\n\\nThat works great with sample input, I think one optimization could be in the poweredNumbers \\ngenerator. I am generating all the pows of lower digit count too. Maybe with some math\\nand binary search I could make that better, but I don\\'t think it\\'s worth the effort.        \\n        \\n\\n\\n\\t/**\\n\\t * @param {number} N\\n\\t * @return {boolean}\\n\\t */\\n\\tvar reorderedPowerOf2 = function(N) {\\n\\n\\n\\t\\tvar maxPowerLength = 0, // I got this variable of a hair blower\\n\\t\\t\\tsN = String(N),\\n\\t\\t\\tnLength = sN.length, // how many numbers are in N total\\n\\t\\t\\tpoweredNumbers = [], // this will hold the numbers we should check N against\\n\\t\\t\\ti = 0,\\n\\t\\t\\tnFreq = {}; // we\\'ll use this in part 2, to check which numbers we need to find\\n\\n\\t\\t// Generate the powers\\n\\t\\twhile (maxPowerLength <= nLength) {\\n\\t\\t\\tlet pow = Math.pow(2, i);\\n\\n\\t\\t\\tmaxPowerLength = String(pow).length;\\n\\n\\t\\t\\t// We\\'re only interested in numbers of the same length, of course\\n\\t\\t\\tif (maxPowerLength === nLength) {\\n\\t\\t\\t\\tpoweredNumbers.push(pow);\\n\\t\\t\\t}\\n\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\t// at this point, for a N like 1234, we\\'ll have poweredNumbers [ 1024, 2048, 4096, 8192 ]\\n\\t\\t// console.log(\\'poweredNumbers\\', poweredNumbers);\\n\\n\\t\\t// now we need to see if all the numbers in N can be check off of one of those\\n\\t\\tnFreq = getFreqMap(sN);\\n\\n\\t\\t// at this point we have nFreq: { \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\t\\t// console.log(\\'nFreq\\', nFreq);\\n\\n\\t\\t// Create a map for the target numbers and see if there is a match\\n\\t\\tfor (var target of poweredNumbers) {\\n\\t\\t\\tlet fm2 = getFreqMap(String(target));\\n\\n\\t\\t\\tif (isFreqMapEqual(nFreq, fm2)) {\\n\\t\\t\\t\\t// we have a match!\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// by reaching this point we\\'ve proven there is no match possible\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/**\\n\\t * Helper function: Create frequency map of a string\\n\\t * @param {string} s\\n\\t * @return {object}\\n\\t */\\n\\tvar getFreqMap = function (s) {\\n\\t\\tvar map = {},\\n\\t\\t\\tl = s.length;\\n\\n\\t\\tfor (i = 0; i < l; i++) {\\n\\t\\t\\tif (!map[s[i]]) {\\n\\t\\t\\t\\tmap[s[i]] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap[s[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn map;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function:  Check if 2 frequency maps hold the same values.\\n\\t *  Assumes the maps are of the same length total\\n\\t * @param {object} fm1 frequency map\\n\\t * @param {object} fm2 frequence map\\n\\t * @return {boolean}\\n\\t */\\n\\tvar isFreqMapEqual = function(fm1, fm2) {\\n\\n\\t\\tfor (var entry in fm1) {\\n\\t\\t\\tif (fm1[entry] !== fm2[entry]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1120141,
                "title": "c-cool-super-short-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) \\n    {\\n        static const set<string> pows {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\", \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\", \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\", \"0112344778\"};\\n        \\n        string str = to_string(N);\\n        sort(str.begin(), str.end());\\n        \\n        return pows.find(str) != pows.end();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) \\n    {\\n        static const set<string> pows {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\", \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\", \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\", \"0112344778\"};\\n        \\n        string str = to_string(N);\\n        sort(str.begin(), str.end());\\n        \\n        return pows.find(str) != pows.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120090,
                "title": "java-count-occurance-of-digits",
                "content": "From the problem description it is clear that we need to check whether N is a permutation of a power of 2. The approach is the following:\\n\\nIn the first step, we count the occurance of each digit (0-9) in N\\n\\nIn the second step, we go through each power of 2 (say, x). For each x, we do the following:\\n1. Count the occurance of each digit in x\\n2. We compare the occurance of digits in x with that of N. If we find a match, we return true.\\n3. If we don\\'t find a match for any x, we return false.\\n\\nFor example, for N = 83461, the counts will match for x = 16384 and thus we will return true. For, N = 10000, the counts will not match for any x, so we will return false.\\n\\n```\\n\\tpublic boolean reorderedPowerOf2(int N) {\\n        int[] dcountN = getDigitCount(N);\\n        \\n        for(int i = 0; i < 31; i++){\\n            int x = 1 << i, j;\\n            int[] dcountX = getDigitCount(x);\\n            \\n            for(j = 0; j < 10 && dcountN[j] == dcountX[j]; j++);\\n\\t\\t\\t/*if j becomes 10 after above loop, it means the counts\\n\\t\\t\\t  of the digits are the same in x and N*/\\n            if(j == 10) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int[] getDigitCount(int x){\\n        int[] result = new int[10];\\n        while(x > 0){\\n            result[x % 10]++;\\n            x /= 10;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "From the problem description it is clear that we need to check whether N is a permutation of a power of 2. The approach is the following:\\n\\nIn the first step, we count the occurance of each digit (0-9) in N\\n\\nIn the second step, we go through each power of 2 (say, x). For each x, we do the following:\\n1. Count the occurance of each digit in x\\n2. We compare the occurance of digits in x with that of N. If we find a match, we return true.\\n3. If we don\\'t find a match for any x, we return false.\\n\\nFor example, for N = 83461, the counts will match for x = 16384 and thus we will return true. For, N = 10000, the counts will not match for any x, so we will return false.\\n\\n```\\n\\tpublic boolean reorderedPowerOf2(int N) {\\n        int[] dcountN = getDigitCount(N);\\n        \\n        for(int i = 0; i < 31; i++){\\n            int x = 1 << i, j;\\n            int[] dcountX = getDigitCount(x);\\n            \\n            for(j = 0; j < 10 && dcountN[j] == dcountX[j]; j++);\\n\\t\\t\\t/*if j becomes 10 after above loop, it means the counts\\n\\t\\t\\t  of the digits are the same in x and N*/\\n            if(j == 10) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int[] getDigitCount(int x){\\n        int[] result = new int[10];\\n        while(x > 0){\\n            result[x % 10]++;\\n            x /= 10;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1120038,
                "title": "python-o64-o1-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def helper(self,num):\\n        char_arr = str(num)\\n        table = dict()\\n        for char in char_arr:\\n            if char not in table:\\n                table[char] = 1\\n            else:\\n                table[char] += 1\\n        return table\\n            \\n            \\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        num_tab = self.helper(N)\\n        i = 0\\n        while i < 64:\\n            if num_tab == self.helper(pow(2,i)):\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self,num):\\n        char_arr = str(num)\\n        table = dict()\\n        for char in char_arr:\\n            if char not in table:\\n                table[char] = 1\\n            else:\\n                table[char] += 1\\n        return table\\n            \\n            \\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        num_tab = self.helper(N)\\n        i = 0\\n        while i < 64:\\n            if num_tab == self.helper(pow(2,i)):\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104832,
                "title": "c-beats-100-simple-approach",
                "content": "Powers of 2 will increase really rapidly, hence we can utilize that. \\n\\n// 1\\n// 2\\n// 4\\n// 8\\n// 16\\n// 32\\n// 64\\n// 128\\n// 256\\n// 512\\n// 1024\\n// 2048\\n// 4096\\n// 8192\\n// 16384\\n// 32768\\n// 65536\\n// 131072\\n// 262144\\n// 524288\\n\\nJust collect the numbers having same number of digits and a match accordingly. \\n\\n```\\nclass Solution {\\npublic:\\n\\t#define d(x) cout<<#x<<\" \"<<x<<endl; \\n    bool check(int a,int b)\\n    {\\n\\t\\t// Can use a map too.\\n        vector<int> ar(10,0);\\n        while(a)\\n        {\\n            ar[a%10]++;\\n            a/=10;\\n        }\\n        while(b)\\n        {\\n            ar[b%10]--;\\n            b/=10;\\n        }\\n        for(int i:ar)\\n        {\\n            if(i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n  \\n    bool reorderedPowerOf2(int N) {\\n        vector<int> ar;\\n        int sum = 1;\\n\\t\\t\\n\\t\\t//Number of Digits of N\\n        int digitN = floor(log10(N)) + 1;\\n\\t\\t\\n\\t\\t// Important Consideration we need to go to the last value in that range and not till N, \\n\\t\\t// Eg: for 125 we should go till 512 so let\\'s better go till 999.\\n        int X = pow(10,digitN)-1;\\n\\t\\t\\n        while(sum<X)\\n        {\\n            int digit = floor(log10(sum)) + 1;\\n            if(digit == digitN)\\n                ar.push_back(sum);\\n            sum=sum*2;\\n            // d(digit);\\n            // d(sum);\\n        }\\n        for(int i:ar)\\n        {\\n            // cout<<i;\\n            if(check(i,N))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t#define d(x) cout<<#x<<\" \"<<x<<endl; \\n    bool check(int a,int b)\\n    {\\n\\t\\t// Can use a map too.\\n        vector<int> ar(10,0);\\n        while(a)\\n        {\\n            ar[a%10]++;\\n            a/=10;\\n        }\\n        while(b)\\n        {\\n            ar[b%10]--;\\n            b/=10;\\n        }\\n        for(int i:ar)\\n        {\\n            if(i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n  \\n    bool reorderedPowerOf2(int N) {\\n        vector<int> ar;\\n        int sum = 1;\\n\\t\\t\\n\\t\\t//Number of Digits of N\\n        int digitN = floor(log10(N)) + 1;\\n\\t\\t\\n\\t\\t// Important Consideration we need to go to the last value in that range and not till N, \\n\\t\\t// Eg: for 125 we should go till 512 so let\\'s better go till 999.\\n        int X = pow(10,digitN)-1;\\n\\t\\t\\n        while(sum<X)\\n        {\\n            int digit = floor(log10(sum)) + 1;\\n            if(digit == digitN)\\n                ar.push_back(sum);\\n            sum=sum*2;\\n            // d(digit);\\n            // d(sum);\\n        }\\n        for(int i:ar)\\n        {\\n            // cout<<i;\\n            if(check(i,N))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 970128,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        [\\n            [1, 1, 1, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\\n            [0, 0, 0, 1, 0, 2, 2, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 0, 1, 0, 1, 0, 0, 0, 1, 0],\\n            [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\\n            [0, 1, 2, 0, 2, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 1, 1, 0, 0, 0],\\n            [1, 1, 0, 0, 1, 0, 2, 1, 2, 0],\\n            [1, 1, 0, 0, 1, 1, 1, 1, 1, 0],\\n            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],\\n            [1, 0, 0, 1, 0, 0, 1, 0, 4, 0],\\n            [0, 2, 1, 0, 0, 0, 2, 3, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 3, 2, 2, 0, 0, 0, 0],\\n            [1, 1, 1, 1, 0, 1, 1, 1, 1, 1],\\n            [1, 2, 1, 1, 0, 0, 0, 1, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 1],\\n            [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\\n            [1, 1, 2, 0, 0, 1, 0, 1, 0, 1],\\n            [0, 2, 2, 1, 1, 0, 0, 2, 1, 0],\\n            [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\\n            [0, 0, 2, 0, 1, 1, 0, 0, 2, 0],\\n            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 1, 0, 1, 3, 0, 0, 0, 0, 1],\\n            [0, 0, 1, 1, 2, 2, 2, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 1, 0, 0, 0, 0],\\n            [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],\\n        ]\\n        .iter()\\n        .cloned()\\n        .collect::<HashSet<[i32; 10]>>()\\n        .contains(\\n            &n.to_string().chars().map(|c| c.to_digit(10).unwrap()).fold(\\n                [0; 10],\\n                |mut acc, cur| {\\n                    acc[cur as usize] += 1;\\n                    acc\\n                },\\n            ),\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        [\\n            [1, 1, 1, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\\n            [0, 0, 0, 1, 0, 2, 2, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 0, 1, 0, 1, 0, 0, 0, 1, 0],\\n            [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\\n            [0, 1, 2, 0, 2, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 1, 1, 0, 0, 0],\\n            [1, 1, 0, 0, 1, 0, 2, 1, 2, 0],\\n            [1, 1, 0, 0, 1, 1, 1, 1, 1, 0],\\n            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],\\n            [1, 0, 0, 1, 0, 0, 1, 0, 4, 0],\\n            [0, 2, 1, 0, 0, 0, 2, 3, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 3, 2, 2, 0, 0, 0, 0],\\n            [1, 1, 1, 1, 0, 1, 1, 1, 1, 1],\\n            [1, 2, 1, 1, 0, 0, 0, 1, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 1],\\n            [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\\n            [1, 1, 2, 0, 0, 1, 0, 1, 0, 1],\\n            [0, 2, 2, 1, 1, 0, 0, 2, 1, 0],\\n            [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\\n            [0, 0, 2, 0, 1, 1, 0, 0, 2, 0],\\n            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 1, 0, 1, 3, 0, 0, 0, 0, 1],\\n            [0, 0, 1, 1, 2, 2, 2, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 1, 0, 0, 0, 0],\\n            [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],\\n        ]\\n        .iter()\\n        .cloned()\\n        .collect::<HashSet<[i32; 10]>>()\\n        .contains(\\n            &n.to_string().chars().map(|c| c.to_digit(10).unwrap()).fold(\\n                [0; 10],\\n                |mut acc, cur| {\\n                    acc[cur as usize] += 1;\\n                    acc\\n                },\\n            ),\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480331,
                "title": "count-digits-up-to-2-31-1-c-solution",
                "content": "```\\n    bool reorderedPowerOf2(int N) {\\n         for(int i =0;i < 31;i++){\\n            if(cmpr(N,1<<i))\\n                return true;\\n         }\\n        return false;\\n    }\\n    bool cmpr(int i , int j){\\n        vector <int> cnti (10,0);\\n        vector <int> cntj (10,0);\\n        while(i> 0){\\n            cnti[i%10]++;\\n            i -= i%10;\\n            i /= 10;\\n        }\\n        while(j> 0){\\n            cntj[j%10]++;\\n            j -= j%10;\\n            j /= 10;\\n        }\\n        for(int it =0; it < 10; it++){\\n            if(cnti[it] != cntj[it]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool reorderedPowerOf2(int N) {\\n         for(int i =0;i < 31;i++){\\n            if(cmpr(N,1<<i))\\n                return true;\\n         }\\n        return false;\\n    }\\n    bool cmpr(int i , int j){\\n        vector <int> cnti (10,0);\\n        vector <int> cntj (10,0);\\n        while(i> 0){\\n            cnti[i%10]++;\\n            i -= i%10;\\n            i /= 10;\\n        }\\n        while(j> 0){\\n            cntj[j%10]++;\\n            j -= j%10;\\n            j /= 10;\\n        }\\n        for(int it =0; it < 10; it++){\\n            if(cnti[it] != cntj[it]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475150,
                "title": "c",
                "content": "```\\npublic bool ReorderedPowerOf2(int N) {\\n\\tvar pows = new HashSet<string>();\\n\\tfor (var i = 1; 0 < i && i < int.MaxValue; i *= 2)\\n\\t\\tpows.Add(Ordered(i));\\n\\n\\treturn pows.Contains(Ordered(N));\\n\\n\\tstring Ordered(int n) =>\\n\\t\\tnew string(n.ToString().ToCharArray().OrderBy(c => c).ToArray());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool ReorderedPowerOf2(int N) {\\n\\tvar pows = new HashSet<string>();\\n\\tfor (var i = 1; 0 < i && i < int.MaxValue; i *= 2)\\n\\t\\tpows.Add(Ordered(i));\\n\\n\\treturn pows.Contains(Ordered(N));\\n\\n\\tstring Ordered(int n) =>\\n\\t\\tnew string(n.ToString().ToCharArray().OrderBy(c => c).ToArray());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470212,
                "title": "c-simple-straight-forward-using-sorting-beat-100-100",
                "content": "Just a simple idea using std::string and sorting.\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string sN = to_string(N);\\n        sort(sN.begin(), sN.end());\\n        \\n        for (int i=1; ; i*=2) {\\n            string si = to_string(i);\\n            if (si.length() < sN.length()) continue;\\n            if (si.length() > sN.length()) break;\\n            sort(si.begin(), si.end());\\n            if (si == sN) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string sN = to_string(N);\\n        sort(sN.begin(), sN.end());\\n        \\n        for (int i=1; ; i*=2) {\\n            string si = to_string(i);\\n            if (si.length() < sN.length()) continue;\\n            if (si.length() > sN.length()) break;\\n            sort(si.begin(), si.end());\\n            if (si == sN) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433700,
                "title": "c-o-1-time-o-1-space-with-explanation",
                "content": "If a number `q` can be converted to a target number `N` by re-ordering digits, the histograms of the digits of `q` and `N` must match. For example the histogram of the numbers `1024` => `((0,1),(1,1),(2,1),(3,0),(4,1),(5,0),(6,0),(7,0),(8,0),(9,0))` is the same as the histogram for `2014` => `((0,1),(1,1),(2,1),(3,0),(4,1),(5,0),(6,0),(7,0),(8,0),(9,0))`. The number of integers which are a power of 2 less than `10e9` are `floor(log2(10e9))`. Hence, the solution just checks if the given target `N` has the same histogram as any power of two in the given range.\\n\\n```\\nclass Solution {\\nprivate:\\n    /*\\n        make_hist(): function to make histogram of input number\\n        \\n        params: pp (long int): number to construct histogram\\n        returns: ret (pair<int,vector<int>>): ret.first: number of digits in pp\\n                                              ret.second: histogram of digits in pp\\n    */\\n    pair<int,vector<int>> make_hist(long int pp)\\n    {\\n        int num_digs = 0;\\n        vector<int> dig_count(10, 0);\\n        while(pp)\\n        {\\n            ++num_digs;\\n            ++dig_count[pp%10];\\n            pp /= 10;\\n        }\\n        return make_pair(num_digs, dig_count);\\n    }\\npublic:    \\n    bool reorderedPowerOf2(int N) \\n    {\\n        // make histogram of target N\\n        auto tg_hist = make_hist(N);\\n        \\n        // start querying from lowest power of 2\\n        long int q = 1;\\n        while(q <= 10e9) // upper limit given in the question\\n        {\\n            // make histogram of power of 2\\n            auto q_hist = make_hist(q);\\n            q <<= 1; // increment q to next power\\n            \\n            // if number of digits in query > number of digits in target\\n            // break -- since answer cannot have different number of digits\\n            if(q_hist.first > tg_hist.first) break;\\n            \\n            // if number of digits in query < than number of digits in target\\n            // move on to next query\\n            if(q_hist.first < tg_hist.first) continue;\\n            \\n            // now it is ensured query and target have same number of digits\\n            \\n            // compare histograms of target and query\\n            int i = 0;\\n            for(; i < 10; ++i)\\n            {\\n                if(tg_hist.second[i] != q_hist.second[i]) break;\\n            }\\n            \\n            // if match found\\n            if(i == 10) return true;\\n        }\\n        // no match found\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /*\\n        make_hist(): function to make histogram of input number\\n        \\n        params: pp (long int): number to construct histogram\\n        returns: ret (pair<int,vector<int>>): ret.first: number of digits in pp\\n                                              ret.second: histogram of digits in pp\\n    */\\n    pair<int,vector<int>> make_hist(long int pp)\\n    {\\n        int num_digs = 0;\\n        vector<int> dig_count(10, 0);\\n        while(pp)\\n        {\\n            ++num_digs;\\n            ++dig_count[pp%10];\\n            pp /= 10;\\n        }\\n        return make_pair(num_digs, dig_count);\\n    }\\npublic:    \\n    bool reorderedPowerOf2(int N) \\n    {\\n        // make histogram of target N\\n        auto tg_hist = make_hist(N);\\n        \\n        // start querying from lowest power of 2\\n        long int q = 1;\\n        while(q <= 10e9) // upper limit given in the question\\n        {\\n            // make histogram of power of 2\\n            auto q_hist = make_hist(q);\\n            q <<= 1; // increment q to next power\\n            \\n            // if number of digits in query > number of digits in target\\n            // break -- since answer cannot have different number of digits\\n            if(q_hist.first > tg_hist.first) break;\\n            \\n            // if number of digits in query < than number of digits in target\\n            // move on to next query\\n            if(q_hist.first < tg_hist.first) continue;\\n            \\n            // now it is ensured query and target have same number of digits\\n            \\n            // compare histograms of target and query\\n            int i = 0;\\n            for(; i < 10; ++i)\\n            {\\n                if(tg_hist.second[i] != q_hist.second[i]) break;\\n            }\\n            \\n            // if match found\\n            if(i == 10) return true;\\n        }\\n        // no match found\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165554,
                "title": "cpp-by-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> s;\\n    Solution(){\\n        int n = 1;\\n        for(int i = 0; i < 32; i++){\\n            string str = to_string(n);\\n            sort(str.begin(), str.end());\\n            s.insert(str);\\n            n <<= 1;\\n        }\\n    }  \\n    bool reorderedPowerOf2(int N) {\\n        string n = to_string(N);\\n        sort(n.begin(), n.end());\\n        if(s.find(n) == s.end()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> s;\\n    Solution(){\\n        int n = 1;\\n        for(int i = 0; i < 32; i++){\\n            string str = to_string(n);\\n            sort(str.begin(), str.end());\\n            s.insert(str);\\n            n <<= 1;\\n        }\\n    }  \\n    bool reorderedPowerOf2(int N) {\\n        string n = to_string(N);\\n        sort(n.begin(), n.end());\\n        if(s.find(n) == s.end()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150509,
                "title": "another-0ms-c-solution-no-special-data-structure",
                "content": "```\\n    int myPow(int a) {              //  returns 10^a;\\n        if(!a) return 1;\\n\\n        int res=1;\\n        while(a--)\\n\\t\\t\\t\\tres *= 10;\\n\\n        return res;\\n    }\\n\\n    int counter(int N, int& c1 ) {\\n        int res = 0;\\n\\n        for (; N; N /= 10) {res += myPow(N%10); c1++;}\\n\\n        return res;\\n    }\\n\\n\\n    bool reorderedPowerOf2(int N) {\\n        if(N<10) {\\n            if(N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n        \\n        int c, cc=0;\\n        c = counter(N, cc);\\n\\n        for (int i = 2*cc, k; i < 3*cc+3; i++)\\n            if (counter(1 << i, k) == c) return true;\\n\\n        return false;\\n    } \\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    int myPow(int a) {              //  returns 10^a;\\n        if(!a) return 1;\\n\\n        int res=1;\\n        while(a--)\\n\\t\\t\\t\\tres *= 10;\\n\\n        return res;\\n    }\\n\\n    int counter(int N, int& c1 ) {\\n        int res = 0;\\n\\n        for (; N; N /= 10) {res += myPow(N%10); c1++;}\\n\\n        return res;\\n    }\\n\\n\\n    bool reorderedPowerOf2(int N) {\\n        if(N<10) {\\n            if(N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n        \\n        int c, cc=0;\\n        c = counter(N, cc);\\n\\n        for (int i = 2*cc, k; i < 3*cc+3; i++)\\n            if (counter(1 << i, k) == c) return true;\\n\\n        return false;\\n    } \\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702162,
                "title": "explained-easy-cpp-solution",
                "content": "# Approach\\nPut Digits of n in a vector(Suppose G) and then find a power of 2 that has digits as vector G if we find that both have same digits return true else false.\\n\\n# Complexity\\n- Time complexity: 0ms,better than 100% online CPP Solutions\\n\\n- Space complexity: 6.36mb better than 40.61% online CPP Solutions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> g;\\n        while(n)\\n        {\\n            g.push_back(n%10);\\n            n/=10;\\n        }\\n        sort(g.begin(),g.end());\\n        for(int i=0;;i++)\\n        {\\n            vector<int> v;\\n            long long int t=pow(2,i);\\n            while(t)\\n            {\\n               v.push_back(t%10);\\n               t/=10;\\n            }\\n            sort(v.begin(),v.end());\\n            if(v==g)\\n            return true;\\n\\n            if(v.size()>g.size())\\n            break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting",
                    "Counting",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> g;\\n        while(n)\\n        {\\n            g.push_back(n%10);\\n            n/=10;\\n        }\\n        sort(g.begin(),g.end());\\n        for(int i=0;;i++)\\n        {\\n            vector<int> v;\\n            long long int t=pow(2,i);\\n            while(t)\\n            {\\n               v.push_back(t%10);\\n               t/=10;\\n            }\\n            sort(v.begin(),v.end());\\n            if(v==g)\\n            return true;\\n\\n            if(v.size()>g.size())\\n            break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499369,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  bool reorderedPowerOf2(int N) {\\n    int count = counter(N);\\n\\n    for (int i = 0; i < 30; ++i)\\n      if (counter(1 << i) == count)\\n        return true;\\n\\n    return false;\\n  }\\n private:\\n  int counter(int n) {\\n    int count = 0;\\n\\n    for (; n > 0; n /= 10)\\n      count += pow(10, n % 10);\\n\\n    return count;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n\\n        t = sorted(str(n))\\n        i = 0\\n        while len(str(2**i))<=len(str(n)):\\n            if t==sorted(str(2**i)):\\n                return True\\n            i+=1\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    static byte[][] ocurr;\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  bool reorderedPowerOf2(int N) {\\n    int count = counter(N);\\n\\n    for (int i = 0; i < 30; ++i)\\n      if (counter(1 << i) == count)\\n        return true;\\n\\n    return false;\\n  }\\n private:\\n  int counter(int n) {\\n    int count = 0;\\n\\n    for (; n > 0; n /= 10)\\n      count += pow(10, n % 10);\\n\\n    return count;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n\\n        t = sorted(str(n))\\n        i = 0\\n        while len(str(2**i))<=len(str(n)):\\n            if t==sorted(str(2**i)):\\n                return True\\n            i+=1\\n        return False\\n```\n```Java []\\nclass Solution {\\n    static byte[][] ocurr;\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343801,
                "title": "c-short-and-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string nn = to_string(n);\\n        \\n        sort(nn.begin(), nn.end());\\n        \\n        for (int i = 0; i < 32; i++)\\n        {\\n            string pp = to_string(1 << i);\\n            \\n            sort(pp.begin(), pp.end());\\n            \\n            if (pp == nn)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string nn = to_string(n);\\n        \\n        sort(nn.begin(), nn.end());\\n        \\n        for (int i = 0; i < 32; i++)\\n        {\\n            string pp = to_string(1 << i);\\n            \\n            sort(pp.begin(), pp.end());\\n            \\n            if (pp == nn)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224186,
                "title": "java-easy-solution-no-bit-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- There are 31 powers of 2 that are within the question constraints of `1 <= n <= 10^9`\\n- Sort the number `n` and each sorted power of 2 from 0 -> 30\\n- Leading 0 case is handled because the ordered power will never have a 0. For example, 0256 and 256 are not.\\n# Complexity\\n- Time complexity: $$O(nlogn*n)$$ Sort * string creation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] numArray = String.valueOf(n).toCharArray();\\n        Arrays.sort(numArray);\\n        String orderedNum = new String(numArray);\\n\\n        for (int i = 0; i < 31; i++) {\\n            int powerNum = (int) Math.pow(2, i);\\n            char[] powerNumArray = String.valueOf(powerNum).toCharArray();\\n            Arrays.sort(powerNumArray);\\n            String orderedPower = new String(powerNumArray);\\n\\n            if (orderedNum.equals(orderedPower)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] numArray = String.valueOf(n).toCharArray();\\n        Arrays.sort(numArray);\\n        String orderedNum = new String(numArray);\\n\\n        for (int i = 0; i < 31; i++) {\\n            int powerNum = (int) Math.pow(2, i);\\n            char[] powerNumArray = String.valueOf(powerNum).toCharArray();\\n            Arrays.sort(powerNumArray);\\n            String orderedPower = new String(powerNumArray);\\n\\n            if (orderedNum.equals(orderedPower)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976338,
                "title": "python-few-lines-of-easy-brute-force",
                "content": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        target = sorted(str(n))\\n\\n        for i in range(31):  # 10^9\\n            if sorted(str(2**i)) == target:\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        target = sorted(str(n))\\n\\n        for i in range(31):  # 10^9\\n            if sorted(str(2**i)) == target:\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755253,
                "title": "c-100-fast-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) \\n{\\n   string str = to_string(n);\\n   sort(str.begin(),str.end());\\n   long long int num;\\n   int counter=0;\\n   \\n   while(true)\\n   {\\n      num = pow(2,counter++);\\n      \\n      string temp = to_string(num);\\n      \\n       \\n      if(temp.length()>str.length())\\n      {\\n          //cout<<\"temp=\"<<temp<<endl;\\n          break;\\n      }\\n       \\n      sort(temp.begin(),temp.end());\\n         \\n      if(str == temp)\\n      return true;\\n     \\n   }     \\n   return false;   \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) \\n{\\n   string str = to_string(n);\\n   sort(str.begin(),str.end());\\n   long long int num;\\n   int counter=0;\\n   \\n   while(true)\\n   {\\n      num = pow(2,counter++);\\n      \\n      string temp = to_string(num);\\n      \\n       \\n      if(temp.length()>str.length())\\n      {\\n          //cout<<\"temp=\"<<temp<<endl;\\n          break;\\n      }\\n       \\n      sort(temp.begin(),temp.end());\\n         \\n      if(str == temp)\\n      return true;\\n     \\n   }     \\n   return false;   \\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2512264,
                "title": "clever-solution-convert-to-string-c",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n    unordered_set<string> powers = {\\n        \"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\",\"256\",\"512\",\"1024\",\"2048\",\"4096\",\"8192\",\"16384\",\"32768\",\"65536\", \"131072\", \"262144\",\"524288\", \"1048576\", \"2097152\", \"4194304\", \"8388608\", \"16777216\", \"33554432\", \"67108864\", \"134217728\", \"268435456\", \"536870912\", \"1073741824\", \"2147483648\"\\n    };\\n\\n    string num = to_string(n);\\n    sort(num.begin(), num.end());\\n\\n    for(string s : powers) {\\n        sort(s.begin(), s.end());\\n\\n        if(num == s)\\n            return true;\\n    } \\n    return false;\\n}\\n```\\n**upVote** \\uD83C\\uDF1D",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n    unordered_set<string> powers = {\\n        \"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\",\"256\",\"512\",\"1024\",\"2048\",\"4096\",\"8192\",\"16384\",\"32768\",\"65536\", \"131072\", \"262144\",\"524288\", \"1048576\", \"2097152\", \"4194304\", \"8388608\", \"16777216\", \"33554432\", \"67108864\", \"134217728\", \"268435456\", \"536870912\", \"1073741824\", \"2147483648\"\\n    };\\n\\n    string num = to_string(n);\\n    sort(num.begin(), num.end());\\n\\n    for(string s : powers) {\\n        sort(s.begin(), s.end());\\n\\n        if(num == s)\\n            return true;\\n    } \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496603,
                "title": "reordered-power-of-2-o-1-time-complexity-cpp-solution",
                "content": "*simply take all 2 powered no.s from 2^0 to 2^30 which falls under 10^9 and convert given number \\'n\\' into string and then simply compare with all other 2^x powers by converting it into string and sorting and checking if they both match then return true else after end of loop return false.*\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n==0) return false;\\n        string cnum = to_string(n);\\n        vector<string> res;\\n        sort(cnum.begin(),cnum.end());\\n        int len = cnum.size();\\n        for(int i=0;i<30;i++){\\n            int temp = pow(2,i);\\n            string num = to_string(temp);\\n            if(len==num.size()){\\n                sort(num.begin(),num.end());\\n                if(num==cnum) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n==0) return false;\\n        string cnum = to_string(n);\\n        vector<string> res;\\n        sort(cnum.begin(),cnum.end());\\n        int len = cnum.size();\\n        for(int i=0;i<30;i++){\\n            int temp = pow(2,i);\\n            string num = to_string(temp);\\n            if(len==num.size()){\\n                sort(num.begin(),num.end());\\n                if(num==cnum) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485629,
                "title": "c",
                "content": "```\\npublic class Solution \\n{\\n    public bool ReorderedPowerOf2(int n) \\n    {\\n\\t\\tstring s0 = string.Concat(n.ToString().OrderBy(ch => ch));\\n        \\n        int len = Convert.ToString( (int)Math.Pow(10, n.ToString().Length) , 2).Length;\\n        for (int i = 0; i <= len; i++)\\n        {\\n            int temp = (int)Math.Pow(2, i);\\n            string s1 = string.Concat(temp.ToString().OrderBy(ch => ch));\\n\\n            if (s1 == s0)\\n            {\\n                return true;\\n            }            \\n        }\\n\\n        return false;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool ReorderedPowerOf2(int n) \\n    {\\n\\t\\tstring s0 = string.Concat(n.ToString().OrderBy(ch => ch));\\n        \\n        int len = Convert.ToString( (int)Math.Pow(10, n.ToString().Length) , 2).Length;\\n        for (int i = 0; i <= len; i++)\\n        {\\n            int temp = (int)Math.Pow(2, i);\\n            string s1 = string.Concat(temp.ToString().OrderBy(ch => ch));\\n\\n            if (s1 == s0)\\n            {\\n                return true;\\n            }            \\n        }\\n\\n        return false;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485464,
                "title": "golang-c-python-100-solutions",
                "content": "same logic: \\n1) we prepare a int[10] list to store count of each digits in <kbd>n</kbd>,\\n2) check every <kbd>2 ** i</kbd> result for an identical list, until result reaches <kbd>1e9</kbd> (dictated in the subject)\\n\\n# Go\\n```go\\nfunc reorderedPowerOf2(n int) bool {\\n    check := count_n(n)\\n    // fmt.Println(check)\\n    num := 0\\n    i := 0\\n    for num < 1e9 + 1 {\\n        num = int(math.Pow(2, float64(i)))\\n        temp := count_n(num)\\n        if check == temp {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n}\\n\\nfunc count_n(n int) [10] int {\\n    r := [10] int {} // auto 0-filled\\n    for n > 0 {\\n        r[n % 10]++\\n        n /= 10\\n    }\\n    return r\\n}\\n```\\n# C++\\n```r\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        vector<int> check, temp;\\n        int         i, res;\\n\\n        check = count_n(n);\\n        i = 0;\\n        res = 0;\\n        while (res < (int) 1e9 + 1)\\n        {\\n            res = pow(2, i);\\n            temp = count_n(res);\\n            if (check == temp)\\n                return true;\\n            i++;\\n        }\\n        return false;\\n    }\\n\\n    vector<int> count_n(int n)\\n    {\\n        vector<int> r(10, 0);\\n\\n        while (n)\\n        {\\n            r[n % 10]++;\\n            n /= 10;\\n        }\\n        return r;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def count_n(num: int) -> List[int]:\\n            r = [0] * 10\\n            while num > 0:\\n                r[num % 10] += 1\\n                num //= 10\\n            return r\\n        check = count_n(n)\\n        res, i = 0, 0\\n        while res < 10 ** 9 + 1:\\n            res = 2 ** i\\n            temp = count_n(res)\\n            if check == temp:\\n                return True\\n            i += 1\\n        return False\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```go\\nfunc reorderedPowerOf2(n int) bool {\\n    check := count_n(n)\\n    // fmt.Println(check)\\n    num := 0\\n    i := 0\\n    for num < 1e9 + 1 {\\n        num = int(math.Pow(2, float64(i)))\\n        temp := count_n(num)\\n        if check == temp {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n}\\n\\nfunc count_n(n int) [10] int {\\n    r := [10] int {} // auto 0-filled\\n    for n > 0 {\\n        r[n % 10]++\\n        n /= 10\\n    }\\n    return r\\n}\\n```\n```r\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        vector<int> check, temp;\\n        int         i, res;\\n\\n        check = count_n(n);\\n        i = 0;\\n        res = 0;\\n        while (res < (int) 1e9 + 1)\\n        {\\n            res = pow(2, i);\\n            temp = count_n(res);\\n            if (check == temp)\\n                return true;\\n            i++;\\n        }\\n        return false;\\n    }\\n\\n    vector<int> count_n(int n)\\n    {\\n        vector<int> r(10, 0);\\n\\n        while (n)\\n        {\\n            r[n % 10]++;\\n            n /= 10;\\n        }\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def count_n(num: int) -> List[int]:\\n            r = [0] * 10\\n            while num > 0:\\n                r[num % 10] += 1\\n                num //= 10\\n            return r\\n        check = count_n(n)\\n        res, i = 0, 0\\n        while res < 10 ** 9 + 1:\\n            res = 2 ** i\\n            temp = count_n(res)\\n            if check == temp:\\n                return True\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485338,
                "title": "c-100-0ms-readable-optimised",
                "content": "```\\n\\tint nDig(int n) {\\n        int x=0;\\n        while(n || !x) {\\n            x++;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    string encodeDig(int n) {\\n        string x=\"0000000000\";\\n        while(n) {\\n            int i=n%10;\\n            x[i]+=1;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        string nstr=encodeDig(n);\\n        int ndig = nDig(n);\\n        int p2=1;\\n        while(nDig(p2)!=ndig) p2*=2;\\n        while(nDig(p2)==ndig) if(nstr==encodeDig(p2)) return true; else p2*=2;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tint nDig(int n) {\\n        int x=0;\\n        while(n || !x) {\\n            x++;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    string encodeDig(int n) {\\n        string x=\"0000000000\";\\n        while(n) {\\n            int i=n%10;\\n            x[i]+=1;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        string nstr=encodeDig(n);\\n        int ndig = nDig(n);\\n        int p2=1;\\n        while(nDig(p2)!=ndig) p2*=2;\\n        while(nDig(p2)==ndig) if(nstr==encodeDig(p2)) return true; else p2*=2;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485329,
                "title": "crazy-unusual-method-fta-python",
                "content": "![image](https://assets.leetcode.com/users/images/f581bc8b-cdae-458c-81ce-e507a5604a39_1661544945.0515218.png)\\nThe idea of this method is behind the desire of pre-calculating all the possible answers in a special way so that when we get a number we can quickly say is it an answer or not.\\n\\nLet\\'s not stray far from the idea of counting the number of all digits, because it\\'s pretty reasonable. We need to somehow hash all precalculations for powers of two less than 10**9.\\n\\nThat is, in other words, we must be able to quickly understand whether, say, the number of eights in the number given to us coincides with the number of eights in any of the powers of two. Or, to put it another way, is there a power of two with the same number of eights as in the given number.\\n\\nThat is, for each digit we need to understand the \"degree\" of its occurrence in the number and be able to quickly answer whether there is a power of two with the same number of the same digits.\\n\\nAt this point, I remembered the Fundamental Theorem of Arithmetic, and I came up with the idea of \\u200B\\u200Bthe following way to encode numbers. To each digit we associate a certain prime number (for simplicity, let\\'s say that we associate the \"i\" digit with the \"i+1\"-th prime number). Then the number will be encoded by multiplying all prime numbers encoded by its digits, raised to the power of occurrence of these digits.\\n\\nThus, we can create a set with all encoded powers of two less than 10**9, and then just encode each number given to us in the same way and check whether this number is in our set or not.\\n\\nThe main idea has been explained. Only the technical part of the implementation remains.\\n\\nFirst, let\\'s create a list of the first 10 primes (it\\'s faster to do it by hand). Here it is: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n\\nNow we need all powers of two less than 10**9. They can be generated like this:\\n```\\npowers_of_two = []\\ni = 0\\nwhile 2 ** i <= 10**9:\\n\\tpowers_of_two.append(2**i)\\n\\ti += 1\\n```\\nNow each power of two has to be encoded. For example, it can be done like this:\\n```\\nans = set()\\nfor num in powers_of_two:\\n\\tcnt = Counter(str(num))\\n\\ttmp = 1\\n\\tfor digit in cnt:\\n\\t\\ttmp *= primes[int(digit)] ** cnt[digit]\\n\\tans.add(tmp)\\n```\\nNow we have all the necessary pre-calculations in hand, and we can write the code itself:\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        ans = {3, 143849475, 5, 191712774, 11, 89201295, 1074450, 10005, 23, 35, 154275, 4757357605, 1621158, 66602158, 260015, 51, 187, 11970, 195, 6374082, 330, 588153930, 1105, 90321, 35070035, 345, 10846, 2530, 1891175, 341887}\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        cnt = Counter(str(n))\\n        t = 1\\n        for digit in cnt:\\n            t *= primes[int(digit)] ** cnt[digit]\\n        return t in ans\\n```\\n**Upvote if you find interesting this approach!**",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\npowers_of_two = []\\ni = 0\\nwhile 2 ** i <= 10**9:\\n\\tpowers_of_two.append(2**i)\\n\\ti += 1\\n```\n```\\nans = set()\\nfor num in powers_of_two:\\n\\tcnt = Counter(str(num))\\n\\ttmp = 1\\n\\tfor digit in cnt:\\n\\t\\ttmp *= primes[int(digit)] ** cnt[digit]\\n\\tans.add(tmp)\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        ans = {3, 143849475, 5, 191712774, 11, 89201295, 1074450, 10005, 23, 35, 154275, 4757357605, 1621158, 66602158, 260015, 51, 187, 11970, 195, 6374082, 330, 588153930, 1105, 90321, 35070035, 345, 10846, 2530, 1891175, 341887}\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        cnt = Counter(str(n))\\n        t = 1\\n        for digit in cnt:\\n            t *= primes[int(digit)] ** cnt[digit]\\n        return t in ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485204,
                "title": "java-with-bit-shift-100-faster-memory-usage-99-33",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        int digitCount[] = getDigitCount(n);\\n        int totalDigits = 0;\\n        \\n        for (int count : digitCount) {\\n            totalDigits += count;\\n        }\\n        \\n\\t\\t// set upper and lower limit\\n        int max = (int) Math.pow(10, totalDigits);\\n        int min = (int) Math.pow(10, totalDigits - 1);\\n        int powTwo = 1;\\n        \\n\\t\\t// shift until within upper and lower limit range\\n        while (powTwo < min) {\\n            powTwo <<= 1;\\n        }\\n        \\n        boolean same = true;\\n        while (powTwo < max) {\\n            int[] powTwoDigitCount = getDigitCount(powTwo);\\n            same = true;\\n\\t\\t\\t\\n\\t\\t\\t// check if digits occurrences are equal\\n            for (int i = 0; i < digitCount.length; i++) {\\n                if (digitCount[i] != powTwoDigitCount[i]) {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (same) break;\\n            powTwo <<= 1;\\n        }\\n        \\n        return same;\\n    }\\n    \\n    private int[] getDigitCount(int n) {\\n        int digitCount[] = new int[10];\\n        while (n != 0) {\\n            digitCount[n % 10]++;\\n            n /= 10;\\n        }\\n        \\n        return digitCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        int digitCount[] = getDigitCount(n);\\n        int totalDigits = 0;\\n        \\n        for (int count : digitCount) {\\n            totalDigits += count;\\n        }\\n        \\n\\t\\t// set upper and lower limit\\n        int max = (int) Math.pow(10, totalDigits);\\n        int min = (int) Math.pow(10, totalDigits - 1);\\n        int powTwo = 1;\\n        \\n\\t\\t// shift until within upper and lower limit range\\n        while (powTwo < min) {\\n            powTwo <<= 1;\\n        }\\n        \\n        boolean same = true;\\n        while (powTwo < max) {\\n            int[] powTwoDigitCount = getDigitCount(powTwo);\\n            same = true;\\n\\t\\t\\t\\n\\t\\t\\t// check if digits occurrences are equal\\n            for (int i = 0; i < digitCount.length; i++) {\\n                if (digitCount[i] != powTwoDigitCount[i]) {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (same) break;\\n            powTwo <<= 1;\\n        }\\n        \\n        return same;\\n    }\\n    \\n    private int[] getDigitCount(int n) {\\n        int digitCount[] = new int[10];\\n        while (n != 0) {\\n            digitCount[n % 10]++;\\n            n /= 10;\\n        }\\n        \\n        return digitCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485111,
                "title": "i-am-a-noob-got-1ms-solution",
                "content": "```\\nimport java.util.*;\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k*2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k*2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484999,
                "title": "i-am-a-noob-but-1ms-solution",
                "content": "import java.util.;\\nclass Solution \\n{\\n\\tpublic boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution \\n{\\n\\tpublic boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2484959,
                "title": "c-reordered-power-of-2",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<=30;i++){\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            if(temp==s)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<=30;i++){\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            if(temp==s)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2484863,
                "title": "0ms-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int i,s=1;\\n        string a=to_string(n);\\n        sort(a.begin(),a.end());\\n        vector<string> v;\\n        string b;\\n        for(i=0;i<=29;i++)\\n        {\\n            b=to_string(s);\\n            v.push_back(b);\\n            s=s*2;\\n            sort(b.begin(),b.end());\\n            if(b==a)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int i,s=1;\\n        string a=to_string(n);\\n        sort(a.begin(),a.end());\\n        vector<string> v;\\n        string b;\\n        for(i=0;i<=29;i++)\\n        {\\n            b=to_string(s);\\n            v.push_back(b);\\n            s=s*2;\\n            sort(b.begin(),b.end());\\n            if(b==a)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484734,
                "title": "c-easy-solution-clean-code-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string num=to_string(n);\\n        sort(num.begin(),num.end());\\n        //cout<<num<<endl;\\n        //vector<string> hash;\\n        for(int i=0;i<=30;i++){\\n            //cout<<pow(2,i)<<endl;\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            //cout<<temp<<endl;\\n            if(temp==num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string num=to_string(n);\\n        sort(num.begin(),num.end());\\n        //cout<<num<<endl;\\n        //vector<string> hash;\\n        for(int i=0;i<=30;i++){\\n            //cout<<pow(2,i)<<endl;\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            //cout<<temp<<endl;\\n            if(temp==num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2484719,
                "title": "80-faster-c-code-daily-leetcode-challenge-august-day-26",
                "content": "```\\nvector<map<int,int>> findarray(int nodigits){\\n    long long start=1;\\n    for(int i=1;i<nodigits;i++){\\n        start*=10;\\n    }\\n    long long end=start*10;\\n    long long start2=1;\\n    while(start2<start){\\n        start2*=2;\\n    }\\n   vector<map<int,int>> ans(100);\\n    int i=0;\\n    while(start2<=end){\\n        long long topush=start2;\\n        while(topush>0){\\n            int digito=topush%10;\\n            ans[i][digito]++;\\n            topush/=10;\\n        }\\n        i++;\\n        start2*=2;\\n    }\\n    return ans;\\n}    \\n```\\n```\\n    bool reorderedPowerOf2(int n) {\\n        int digits=0;\\n        long long num=n;\\n        map<int,int> original;\\n        while(num>0){\\n            int digito=num%10;\\n            original[digito]++;\\n            num/=10;\\n            digits++;\\n        }\\n        vector<map<int,int>> find=findarray(digits);\\n        for(int i=0;i<find.size();i++){\\n            if(find[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<map<int,int>> findarray(int nodigits){\\n    long long start=1;\\n    for(int i=1;i<nodigits;i++){\\n        start*=10;\\n    }\\n    long long end=start*10;\\n    long long start2=1;\\n    while(start2<start){\\n        start2*=2;\\n    }\\n   vector<map<int,int>> ans(100);\\n    int i=0;\\n    while(start2<=end){\\n        long long topush=start2;\\n        while(topush>0){\\n            int digito=topush%10;\\n            ans[i][digito]++;\\n            topush/=10;\\n        }\\n        i++;\\n        start2*=2;\\n    }\\n    return ans;\\n}    \\n```\n```\\n    bool reorderedPowerOf2(int n) {\\n        int digits=0;\\n        long long num=n;\\n        map<int,int> original;\\n        while(num>0){\\n            int digito=num%10;\\n            original[digito]++;\\n            num/=10;\\n            digits++;\\n        }\\n        vector<map<int,int>> find=findarray(digits);\\n        for(int i=0;i<find.size();i++){\\n            if(find[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484686,
                "title": "c-detailed-explanation-tc-o-nlogn",
                "content": "**Two Approaches**\\n* Approach-1 -> Generating all the permutations for the digits of number n, and checking individually for the power of 2.\\n*  TC =Total Permutations of the digits i.e. (n)!\\n ```\\nclass Solution {\\n    bool twoPower(string digits){\\n        int num=stoi(digits);\\n        return (num & (num-1))==0;\\n    }\\n    bool check(string digits,int pos){\\n        if(pos==digits.size()){\\n            if(digits[0]!=\\'0\\'&&twoPower(digits)) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        for(int i=pos;i<digits.size();i++){\\n            swap(digits[pos],digits[i]);\\n            if(digits[0]!=\\'0\\'&&check(digits,pos+1)) return true;\\n            swap(digits[i],digits[pos]);\\n        }\\n        return false;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        return check(to_string(n),0);\\n    }\\n};\\n```\\n* Approach-2 -> Getting all the power of twos arranging their digits in increasing order and put them in map, convert n to string, sort it, check whether it belongs to that map or not.\\n* Let count of digits of given number=k, TC = O(32 * k * log(k)).\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        unordered_map<string,bool> mp;\\n        for(int i=0;i<32;i++){\\n            int num= 1<<i;\\n            string s=to_string(num);\\n            sort(s.begin(),s.end());\\n            mp[s]=true;\\n        }\\n        string tc=to_string(n);\\n        sort(tc.begin(),tc.end());\\n        return mp.find(tc)!=mp.end();\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool twoPower(string digits){\\n        int num=stoi(digits);\\n        return (num & (num-1))==0;\\n    }\\n    bool check(string digits,int pos){\\n        if(pos==digits.size()){\\n            if(digits[0]!=\\'0\\'&&twoPower(digits)) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        for(int i=pos;i<digits.size();i++){\\n            swap(digits[pos],digits[i]);\\n            if(digits[0]!=\\'0\\'&&check(digits,pos+1)) return true;\\n            swap(digits[i],digits[pos]);\\n        }\\n        return false;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        return check(to_string(n),0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        unordered_map<string,bool> mp;\\n        for(int i=0;i<32;i++){\\n            int num= 1<<i;\\n            string s=to_string(num);\\n            sort(s.begin(),s.end());\\n            mp[s]=true;\\n        }\\n        string tc=to_string(n);\\n        sort(tc.begin(),tc.end());\\n        return mp.find(tc)!=mp.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484665,
                "title": "java-simple-100-sweet-and-simple",
                "content": "**IF you LIKE it UPVOTE**\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n    int Count[] = Count(n);\\n       \\n        for (int i = 0; i < 31; i++) {\\n            int power = (int)Math.pow(2,i);\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { \\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n    int Count[] = Count(n);\\n       \\n        for (int i = 0; i < 31; i++) {\\n            int power = (int)Math.pow(2,i);\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { \\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484537,
                "title": "easy-c-solution-using-vector-100-faster-than-others",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(int n){\\n        //Storing occurence of n :-\\n        vector<int>v(10);\\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        return v;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        if(n==1)return true;\\n        \\n        vector<int>v = solve(n);\\n        \\n        for(int i = 0;i<30;i++){\\n            // if(v == solve(pow(2,i)))return true;\\n            if(v == solve(1<<i))return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(int n){\\n        //Storing occurence of n :-\\n        vector<int>v(10);\\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        return v;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        if(n==1)return true;\\n        \\n        vector<int>v = solve(n);\\n        \\n        for(int i = 0;i<30;i++){\\n            // if(v == solve(pow(2,i)))return true;\\n            if(v == solve(1<<i))return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484532,
                "title": "c-code-with-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        //Convert the integer to string\\n        string s=to_string(n);\\n        \\n        //Sort the string\\n        sort(s.begin(),s.end());\\n        \\n        //Now check for all power till 32 and covert all power into string and sort them\\n        //If we get any power of 2 string equal to s then return true\\n        for(int i=0;i<32;i++){\\n            int power_2=(1<<i);\\n            string compare=to_string(power_2);\\n            sort(compare.begin(),compare.end());\\n            if(compare==s)return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        //Convert the integer to string\\n        string s=to_string(n);\\n        \\n        //Sort the string\\n        sort(s.begin(),s.end());\\n        \\n        //Now check for all power till 32 and covert all power into string and sort them\\n        //If we get any power of 2 string equal to s then return true\\n        for(int i=0;i<32;i++){\\n            int power_2=(1<<i);\\n            string compare=to_string(power_2);\\n            sort(compare.begin(),compare.end());\\n            if(compare==s)return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484340,
                "title": "c-easy-solution",
                "content": "**c++ easy understanding code using a string sort_string function**\\n\\n\\n\\n    \\n   string sort_string(int n)\\n    {\\n       string str=to_string(n);//convert to array\\n       sort(str.begin(),str.end());//sort it    \\n\\t   return str;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s=sort_string(n);// sort  the \\n        \\n        for(int i=0;i<30;i++)\\n        {\\n            string t=sort_string(1<<i);//sort the decimal form of the power of 2\\n            if(s==t)return true;//check if they are same or not\\n            \\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**c++ easy understanding code using a string sort_string function**\\n\\n\\n\\n    \\n   string sort_string(int n)\\n    {\\n       string str=to_string(n);//convert to array\\n       sort(str.begin(),str.end());//sort it    \\n\\t   return str;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s=sort_string(n);// sort  the \\n        \\n        for(int i=0;i<30;i++)\\n        {\\n            string t=sort_string(1<<i);//sort the decimal form of the power of 2\\n            if(s==t)return true;//check if they are same or not\\n            \\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2484279,
                "title": "100-faster-100-less-memory-than-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/75551367-0224-4491-a7be-5fd53e52c224_1661530948.5126617.png)\\n\\n\\n```\\n    public bool ReorderedPowerOf2(int n) {\\n        int[] numbers = GetFrequencyArray(n);\\n        for(int i=0; i<31; i++)\\n        {\\n            int pow = (int)Math.Pow(2, i);\\n            int[] powerFrequencies = GetFrequencyArray(pow);\\n            if(Compare(numbers, powerFrequencies)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private int[] GetFrequencyArray(int n)\\n    {\\n        int[] frequencies = new int[10];\\n        while(n>0)\\n        {\\n            frequencies[n%10]++;\\n            n /= 10;\\n        }\\n        return frequencies;\\n    }\\n    \\n    private bool Compare(int[] arrOne, int[] arrTwo)\\n    {\\n        for(int i=0; i<10; i++)\\n        {\\n            if(arrOne[i] != arrTwo[i]) return false;\\n        }\\n        return true;\\n    }  \\n```",
                "solutionTags": [],
                "code": "```\\n    public bool ReorderedPowerOf2(int n) {\\n        int[] numbers = GetFrequencyArray(n);\\n        for(int i=0; i<31; i++)\\n        {\\n            int pow = (int)Math.Pow(2, i);\\n            int[] powerFrequencies = GetFrequencyArray(pow);\\n            if(Compare(numbers, powerFrequencies)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private int[] GetFrequencyArray(int n)\\n    {\\n        int[] frequencies = new int[10];\\n        while(n>0)\\n        {\\n            frequencies[n%10]++;\\n            n /= 10;\\n        }\\n        return frequencies;\\n    }\\n    \\n    private bool Compare(int[] arrOne, int[] arrTwo)\\n    {\\n        for(int i=0; i<10; i++)\\n        {\\n            if(arrOne[i] != arrTwo[i]) return false;\\n        }\\n        return true;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484264,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n```\\n bool reorderedPowerOf2(int n) {\\n        vector<string>ans;\\n        string ndigit=to_string(n);\\n        \\n    \\n        sort(ndigit.begin(),ndigit.end());\\n        \\n        \\n        for(int i=0;i<31;i++){\\n            int p=pow(2,i);\\n            ans.push_back(to_string(p));\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            sort(ans[i].begin(),ans[i].end());\\n        }\\n        for(int i=0;i<=30;i++){\\n            if(ans[i]==ndigit) return true;\\n        }\\n        return false;\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool reorderedPowerOf2(int n) {\\n        vector<string>ans;\\n        string ndigit=to_string(n);\\n        \\n    \\n        sort(ndigit.begin(),ndigit.end());\\n        \\n        \\n        for(int i=0;i<31;i++){\\n            int p=pow(2,i);\\n            ans.push_back(to_string(p));\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            sort(ans[i].begin(),ans[i].end());\\n        }\\n        for(int i=0;i<=30;i++){\\n            if(ans[i]==ndigit) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484235,
                "title": "javascript-soln",
                "content": "```\\nvar reorderedPowerOf2 = function(n) {\\n    const max = 10**9\\n    let power = 0;\\n    let pvalue = 0 \\n    const input = `${n}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n    while(pvalue <= max ) {\\n        pvalue = 2**power\\n        power++\\n        const p = `${pvalue}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n        if(p === input) { return true }  \\n        if(p.length > input.length) { return false }\\n    }\\n    return false\\n};",
                "solutionTags": [],
                "code": "```\\nvar reorderedPowerOf2 = function(n) {\\n    const max = 10**9\\n    let power = 0;\\n    let pvalue = 0 \\n    const input = `${n}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n    while(pvalue <= max ) {\\n        pvalue = 2**power\\n        power++\\n        const p = `${pvalue}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n        if(p === input) { return true }  \\n        if(p.length > input.length) { return false }\\n    }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2484183,
                "title": "python-25ms-beat-90",
                "content": "1. create a list of all possible power of 2 under 10^9 by utilizing binary representation of integers.\\n2. an integer is power of 2 iff its representation in binary starts with \\'1\\' and trailed with all \\'0\\'s.\\n3. utilizing the counter function to compare the frequency of characters with that of each element in the list we built in step 1. \\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        n=str(n)\\n        counter=collections.Counter(n)\\n        ## create the lst of all possible power of 2 under 10**9\\n        lst=[]\\n        for i in range(0,99):\\n            s=\\'1\\'+\\'0\\'*i\\n            m=int(s,2)\\n            if m>10**9:\\n                break\\n            lst.append(str(m))\\n        ##\\n        for i in lst:\\n            if len(i)!=len(n):\\n                continue\\n            counter2=collections.Counter(i)\\n            if counter == counter2:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        n=str(n)\\n        counter=collections.Counter(n)\\n        ## create the lst of all possible power of 2 under 10**9\\n        lst=[]\\n        for i in range(0,99):\\n            s=\\'1\\'+\\'0\\'*i\\n            m=int(s,2)\\n            if m>10**9:\\n                break\\n            lst.append(str(m))\\n        ##\\n        for i in lst:\\n            if len(i)!=len(n):\\n                continue\\n            counter2=collections.Counter(i)\\n            if counter == counter2:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484172,
                "title": "python",
                "content": "```\\nimport itertools\\n\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        while n%2 == 0:\\n            n /= 2\\n        return 1 == n\\n    \\n    def getAllPermutations(self, n):\\n        permutations = []\\n        for num in itertools.permutations(list(n)):\\n            permutations.append(int(\"\".join(num)))\\n        return permutations\\n    \\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n = str(n)\\n        for num in self.getAllPermutations(n):\\n            if(self.isPowerOfTwo(num) and len(n) == len(str(num))): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        while n%2 == 0:\\n            n /= 2\\n        return 1 == n\\n    \\n    def getAllPermutations(self, n):\\n        permutations = []\\n        for num in itertools.permutations(list(n)):\\n            permutations.append(int(\"\".join(num)))\\n        return permutations\\n    \\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n = str(n)\\n        for num in self.getAllPermutations(n):\\n            if(self.isPowerOfTwo(num) and len(n) == len(str(num))): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484030,
                "title": "1-ms-faster-than-100-00-of-java",
                "content": "```\\npublic boolean reorderedPowerOf2(int n) {\\n\\t\\tif (n == 1) return true;\\n\\t\\tboolean isCorrect = false;\\n\\t\\t\\n\\t\\tint[] valCountArr = new int[10];\\n\\t\\tlong count = 0;\\n\\t\\tfor(char c : String.valueOf(n).toCharArray()) {\\n\\t\\t\\tvalCountArr[c-\\'0\\']++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint target = 2;\\n\\t\\t\\n\\t\\twhile (String.valueOf(target).length() <= count) {\\n\\t\\t\\t\\n\\t\\t\\tif(String.valueOf(target).length() < count) {\\n\\t\\t\\t\\ttarget *= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint[] targetArr = new int[10];\\n\\t\\t\\t\\n\\t\\t\\tfor(char c : String.valueOf(target).toCharArray())\\n\\t\\t\\t\\ttargetArr[c-\\'0\\']++;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 0; i < 10; i++) {\\n\\t\\t\\t\\tif (targetArr[i] == valCountArr[i]) {\\n\\t\\t\\t\\t\\tif (i == 9)\\n\\t\\t\\t\\t\\t\\tisCorrect = true;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n\\t\\t\\tif(isCorrect) break;\\n\\t\\t\\ttarget *= 2;\\n\\t\\t}\\n\\t\\treturn isCorrect;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n\\t\\tif (n == 1) return true;\\n\\t\\tboolean isCorrect = false;\\n\\t\\t\\n\\t\\tint[] valCountArr = new int[10];\\n\\t\\tlong count = 0;\\n\\t\\tfor(char c : String.valueOf(n).toCharArray()) {\\n\\t\\t\\tvalCountArr[c-\\'0\\']++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint target = 2;\\n\\t\\t\\n\\t\\twhile (String.valueOf(target).length() <= count) {\\n\\t\\t\\t\\n\\t\\t\\tif(String.valueOf(target).length() < count) {\\n\\t\\t\\t\\ttarget *= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint[] targetArr = new int[10];\\n\\t\\t\\t\\n\\t\\t\\tfor(char c : String.valueOf(target).toCharArray())\\n\\t\\t\\t\\ttargetArr[c-\\'0\\']++;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 0; i < 10; i++) {\\n\\t\\t\\t\\tif (targetArr[i] == valCountArr[i]) {\\n\\t\\t\\t\\t\\tif (i == 9)\\n\\t\\t\\t\\t\\t\\tisCorrect = true;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n\\t\\t\\tif(isCorrect) break;\\n\\t\\t\\ttarget *= 2;\\n\\t\\t}\\n\\t\\treturn isCorrect;\\n\\t}",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1754009,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "when I run the test case \"46\", the solution should be \"false\", but the expected is \"true\".\\nI don\\'t understand why it should be true, since the binary representation of \"46\" is 101110, and its clear that we can\\'t reorder this number to be a power of 2.... what I\\'m missing here?\\n\\n(I\\'m solving in C)"
                    },
                    {
                        "username": "user9132S",
                        "content": "[@lowchhector](/lowchhector) Thank you!"
                    },
                    {
                        "username": "lowchhector",
                        "content": "im thinking 46 can be reordered to 64 which is a power of 2"
                    },
                    {
                        "username": "shakti_2003",
                        "content": "we can not represent 46 as a power of 2 but it shows true for 46 .. how ????"
                    },
                    {
                        "username": "EgoriiSt",
                        "content": "if you reorder 46 you get 64 which is 2^6"
                    }
                ]
            },
            {
                "id": 1956852,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "when I run the test case \"46\", the solution should be \"false\", but the expected is \"true\".\\nI don\\'t understand why it should be true, since the binary representation of \"46\" is 101110, and its clear that we can\\'t reorder this number to be a power of 2.... what I\\'m missing here?\\n\\n(I\\'m solving in C)"
                    },
                    {
                        "username": "user9132S",
                        "content": "[@lowchhector](/lowchhector) Thank you!"
                    },
                    {
                        "username": "lowchhector",
                        "content": "im thinking 46 can be reordered to 64 which is a power of 2"
                    },
                    {
                        "username": "shakti_2003",
                        "content": "we can not represent 46 as a power of 2 but it shows true for 46 .. how ????"
                    },
                    {
                        "username": "EgoriiSt",
                        "content": "if you reorder 46 you get 64 which is 2^6"
                    }
                ]
            }
        ]
    },
    {
        "title": "Advantage Shuffle",
        "question_content": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> both of the same length. The <strong>advantage</strong> of <code>nums1</code> with respect to <code>nums2</code> is the number of indices <code>i</code> for which <code>nums1[i] &gt; nums2[i]</code>.</p>\n\n<p>Return <em>any permutation of </em><code>nums1</code><em> that maximizes its <strong>advantage</strong> with respect to </em><code>nums2</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n<strong>Output:</strong> [2,11,7,15]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n<strong>Output:</strong> [24,32,8,12]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 149822,
                "title": "java-greedy-6-lines-with-explanation",
                "content": "Contest version below:\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1531625378.png)\\nShorter version just for fun (promise me never use it during an interview):\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<B.length; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=A.length-1, res[] = new int[A.length];\\n        while(!pq.isEmpty()) res[pq.peek()[1]]=pq.poll()[0]<A[hi]?A[hi--]:A[lo++];\\n        return res;\\n    }\\n}\\n```\\nIf you are chasing speed, it\\'s time to forget lambda, beats 90%:\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                return b[0]-a[0];\\n            }\\n        });\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```\\nHappy coding.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<B.length; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=A.length-1, res[] = new int[A.length];\\n        while(!pq.isEmpty()) res[pq.peek()[1]]=pq.poll()[0]<A[hi]?A[hi--]:A[lo++];\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                return b[0]-a[0];\\n            }\\n        });\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149831,
                "title": "c-6-lines-greedy-o-n-log-n",
                "content": "For each B[i], we select the smallest number in A that is greater than B[i]. If there are no such number, we select the smalest number in A.\\n\\nI am usign multiset to sort and keep track of numbers in A. After a number is selected, we need to remove it from the multiset (erase by iterator takes a constant time).\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149842,
                "title": "python-greedy-solution-using-sort",
                "content": "# Explanation\\nSort `A`\\nFor every element `b` in B from big to small,\\nif `A[-1] > b`,\\nthen this `b` will take the biggest element in A by `A.pop()`.\\notherwise take the smallest in A by  `A.popleft()`\\n<br>\\n\\n\\n# Complexity\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Python3**\\n```py\\n    def advantageCount(self, A, B):\\n        A = deque(sorted(A))\\n        for b, i in sorted([-b, i] for i, b in enumerate(B)):\\n            B[i] = A.pop() if -b < A[-1] else A.popleft()\\n        return B\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def advantageCount(self, A, B):\\n        A = deque(sorted(A))\\n        for b, i in sorted([-b, i] for i, b in enumerate(B)):\\n            B[i] = A.pop() if -b < A[-1] else A.popleft()\\n        return B\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149840,
                "title": "c-java-greedy-solution-using-map",
                "content": "# Explanation\\nCount elements in `A` to a map `m`.\\nFor each element in `B`, find the least bigger element in map `m`.\\nOtherwise, we\\'ll take the smallest element.\\nThen we update the `m`.\\n<br>\\n\\n# Complexity\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(begin(A), end(A));\\n        for (int i = 0; i < B.size(); ++i) {\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    }\\n```\\n**Java:**\\n```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int i : A) m.put(i, m.getOrDefault(i, 0) + 1);\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            Integer x = m.higherKey(B[i]);\\n            if (x == null) x = m.firstKey();\\n            m.put(x, m.get(x) - 1);\\n            if (m.get(x) == 0) m.remove(x);\\n            res[i] = x;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(begin(A), end(A));\\n        for (int i = 0; i < B.size(); ++i) {\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    }\\n```\n```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int i : A) m.put(i, m.getOrDefault(i, 0) + 1);\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            Integer x = m.higherKey(B[i]);\\n            if (x == null) x = m.firstKey();\\n            m.put(x, m.get(x) - 1);\\n            if (m.get(x) == 0) m.remove(x);\\n            res[i] = x;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190310,
                "title": "explain-the-algorithm-and-concise-java-implementation",
                "content": "This is a generalization of the classic Chinese story of General Tian's Horse Race.\nhttps://en.wikipedia.org/wiki/Tian_Ji\n\nIn the original story there are only 3 numbers in each array and A[0] < B[0], A[1] < B[1], A[2] < B[2], how can A make a possible win?\n\nThe key mindset, is, instead of try to maximize the gain, try to minimize the loss.\n\nI will prove this strategy inline.\n\n```\npublic int[] advantageCount(int[] A, int[] B) {\n    // TJSM is the Chinese acronym for the original story\n    int[] TJSM = new int[A.length];\n\n    // Sort my hand to have an ordered horse quality\n    Arrays.sort(A);\n\t\t\n    // Use a max heap for my opponents to deal with his faster horse first\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n    for (int i = 0; i < B.length; i++) {\n        maxHeap.offer(new int[] {i, B[i]});\n    }\n\n    int slow = 0, fast = A.length - 1;\n    while (!maxHeap.isEmpty()) {\n        int[] b = maxHeap.poll();\n        // If my fastest horse remained is slower than my opponents' fastest horse,\n        // there is no way for me to win, use my slower horse.\n        // Otherwise use my fastest horse to win this round.\n        // Why using my second fastest horse won't improve my global scores?\n        // If my second fastest horse is faster than my opponents' fastest one,\n        // it sure is faster than the rest of his horse. Thus proved this strategy is\n        // optimal.\n        TJSM[b[0]] = b[1] >= A[fast] ? A[slow++] : A[fast--];\n    }\n\n    return TJSM;\n}\n```",
                "solutionTags": [],
                "code": "```\npublic int[] advantageCount(int[] A, int[] B) {\n    // TJSM is the Chinese acronym for the original story\n    int[] TJSM = new int[A.length];\n\n    // Sort my hand to have an ordered horse quality\n    Arrays.sort(A);\n\t\t\n    // Use a max heap for my opponents to deal with his faster horse first\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n    for (int i = 0; i < B.length; i++) {\n        maxHeap.offer(new int[] {i, B[i]});\n    }\n\n    int slow = 0, fast = A.length - 1;\n    while (!maxHeap.isEmpty()) {\n        int[] b = maxHeap.poll();\n        // If my fastest horse remained is slower than my opponents' fastest horse,\n        // there is no way for me to win, use my slower horse.\n        // Otherwise use my fastest horse to win this round.\n        // Why using my second fastest horse won't improve my global scores?\n        // If my second fastest horse is faster than my opponents' fastest one,\n        // it sure is faster than the rest of his horse. Thus proved this strategy is\n        // optimal.\n        TJSM[b[0]] = b[1] >= A[fast] ? A[slow++] : A[fast--];\n    }\n\n    return TJSM;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125119,
                "title": "python-greedy-solution-two-pointers-explained",
                "content": "The idea here is to sort `A` and `B` lists first and start with the biggest number from `B` and check if we can beat it with biggest number from `A`. If we can, do it and increase `beg` pointer. If no, than we need to choose the smallest number we have and we move `end` pointer. One difficulty here is that we need to keep order of data somehow, so we add indexes to `B` list. Then we create `ans` list and change corresponding element of it.\\n\\nTime complexity is `O(n log n)` to perform sorts and space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        B = sorted([(num, i) for i, num in enumerate(B)])[::-1]\\n        A = sorted(A)[::-1]\\n        ans = [-1]*n\\n        \\n        beg, end = 0, n - 1\\n        \\n        for num, ind in B:\\n            if A[beg] > num:\\n                ans[ind] = A[beg]\\n                beg += 1\\n            else:\\n                ans[ind] = A[end]\\n                end -= 1\\n                \\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        B = sorted([(num, i) for i, num in enumerate(B)])[::-1]\\n        A = sorted(A)[::-1]\\n        ans = [-1]*n\\n        \\n        beg, end = 0, n - 1\\n        \\n        for num, ind in B:\\n            if A[beg] > num:\\n                ans[ind] = A[beg]\\n                beg += 1\\n            else:\\n                ans[ind] = A[end]\\n                end -= 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125188,
                "title": "c-greedy-using-multiset-explained",
                "content": "Store all elements of array A in multiset.\\nFor each element *b* of array B, we find the first greater element than b in array A and push it in vector *v* and  if no such element is present then we push the smallest element of array A to vector *v* and remove it from A.\\n\\n\\n\\n**Time Complexity: O(nlogn)**\\n*code:*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b){\\n        multiset<int> s;\\n        vector<int> v;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n        }\\n        for(int i=0;i<b.size();i++){\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end()){\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else{\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b){\\n        multiset<int> s;\\n        vector<int> v;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n        }\\n        for(int i=0;i<b.size();i++){\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end()){\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else{\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125217,
                "title": "js-python-java-c-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe general principle here is easy to understand: for each value in **B**, we ideally want to pick a number from **A** that is *just* higher to match up against it. The naive way to do this would require sorting **A**, then iterating through it until we find the ideal number, then removing that number from **A** and moving it to the answer array (**ans**) at a **time complexity** of **O(n^2)**.\\n\\nWe could employ a **binary search** instead of a straight iteration, which would drop the overall time complexity to **O(n * log n)**, matching the sort time complexity. The issue that remains, however, is that getting rid of elements of **A** can be time-consuming. (*Note: This method actually works well in Python; see the code below.*)\\n\\nInstead, if we had a sorted **B** as well, we could just match up the values very easily in descending order. If the largest remaining value of **A** is larger than the largest remaining value of **B**, then use it, otherwise, use the smallest remaining value of **A**, which is the least useful.\\n\\nSince we need to return our answer matched up agains the original order of **B**, however, we can\\'t just sort **B**. We can, however, create an **index order lookup array** and sort it in reference to the values in **B**, then use it as a bridge between the sorted **A** and unsorted **B**.\\n\\nOnce we\\'ve finished iterating, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript as usual should take advantage of the faster typed arrays here.\\n\\nPython can convert **A** to a **deque** when it sorts to speed up the removal of elements from both ends. (Thanks [**@gizmo707**](https://leetcode.com/gizmo707)!)\\n\\nAs noted above, Python also has a very short, competitively performant version using **bisect** and without needing to sort **B**.\\n\\nJava will have to use a basic sort on **A**, as it\\'s a primitive array, but we can make **ord** an Integer array so that we can use a **lambda** sort. That means we\\'ll have to swap **i** and **j**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **160ms / 47.8MB** (beats 100% / 70%).\\n```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **308ms / 16.7MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Binary Search:***\\n\\nThe best result for the code below is **344ms / 16.6MB** (beats 88% / 100%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **25ms / 41.3MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **60ms / 33.4MB** (beats 99% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149932,
                "title": "python-greedy-sol-with-detailed-comment-chinese-story-tian-ji-s-horse-race",
                "content": "```\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [None]*len(A)\\n        A = collections.deque(sorted(A))\\n        B = collections.deque(sorted([(B[i], i) for i in range(len(B))]))\\n        \\n        last = len(res)-1\\n        head = 0\\n        while A and B:\\n            a = A.popleft()\\n            b, idx = B.popleft()\\n            \\n            # if we can win by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            if a > b:   \\n                res[idx] = a  # arrange them to fight, we win, and get one advantage score\\n\\n            # if we will lose by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            else:\\n            \\t# put enemy\\'s current fighter back to their queue, we will try our next stronger fighter for him in next round\\n                B.appendleft((b, idx))   \\n                # arrange our current fighter to fight with enemy\\'s current strongest fighter, \\n                # although we will lose this round, but enemy also lose their most powerful fighter so far\\n                last = B.pop()[1]   \\n                res[last] = a\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [None]*len(A)\\n        A = collections.deque(sorted(A))\\n        B = collections.deque(sorted([(B[i], i) for i in range(len(B))]))\\n        \\n        last = len(res)-1\\n        head = 0\\n        while A and B:\\n            a = A.popleft()\\n            b, idx = B.popleft()\\n            \\n            # if we can win by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            if a > b:   \\n                res[idx] = a  # arrange them to fight, we win, and get one advantage score\\n\\n            # if we will lose by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            else:\\n            \\t# put enemy\\'s current fighter back to their queue, we will try our next stronger fighter for him in next round\\n                B.appendleft((b, idx))   \\n                # arrange our current fighter to fight with enemy\\'s current strongest fighter, \\n                # although we will lose this round, but enemy also lose their most powerful fighter so far\\n                last = B.pop()[1]   \\n                res[last] = a\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1125220,
                "title": "advantage-shuffle-js-python-java-c-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe general principle here is easy to understand: for each value in **B**, we ideally want to pick a number from **A** that is *just* higher to match up against it. The naive way to do this would require sorting **A**, then iterating through it until we find the ideal number, then removing that number from **A** and moving it to the answer array (**ans**) at a **time complexity** of **O(n^2)**.\\n\\nWe could employ a **binary search** instead of a straight iteration, which would drop the overall time complexity to **O(n * log n)**, matching the sort time complexity. The issue that remains, however, is that getting rid of elements of **A** can be time-consuming. (*Note: This method actually works well in Python; see the code below.*)\\n\\nInstead, if we had a sorted **B** as well, we could just match up the values very easily in descending order. If the largest remaining value of **A** is larger than the largest remaining value of **B**, then use it, otherwise, use the smallest remaining value of **A**, which is the least useful.\\n\\nSince we need to return our answer matched up agains the original order of **B**, however, we can\\'t just sort **B**. We can, however, create an **index order lookup array** and sort it in reference to the values in **B**, then use it as a bridge between the sorted **A** and unsorted **B**.\\n\\nOnce we\\'ve finished iterating, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript as usual should take advantage of the faster typed arrays here.\\n\\nPython can convert **A** to a **deque** when it sorts to speed up the removal of elements from both ends. (Thanks [**@gizmo707**](https://leetcode.com/gizmo707)!)\\n\\nAs noted above, Python also has a very short, competitively performant version using **bisect** and without needing to sort **B**.\\n\\nJava will have to use a basic sort on **A**, as it\\'s a primitive array, but we can make **ord** an Integer array so that we can use a **lambda** sort. That means we\\'ll have to swap **i** and **j**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **160ms / 47.8MB** (beats 100% / 70%).\\n```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **308ms / 16.7MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Binary Search:***\\n\\nThe best result for the code below is **344ms / 16.6MB** (beats 88% / 100%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **25ms / 41.3MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **60ms / 33.4MB** (beats 99% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406893,
                "title": "c-solution-o-nlogn-simple",
                "content": "```\\n       int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];\\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n       int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];\\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125212,
                "title": "short-easy-w-explanation-simple-greedy-o-nlogn",
                "content": "***Solution - I***\\n\\nThe problem asks us to maximize `A[i] > B[i]`. We can do this by choosing an element from `A` for every element of `B` such that element chosen from A is the smallest element greater than corresponding element from B.\\n\\nTo do this efficiently, we must sort the arrays `A` and `B`. After that, we must choose the elements for each index of B as stated above. The index of B for which `A[i] > B[i]` isn\\'t possible in solution are assigned at last (order doesn\\'t matter).\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`\\n**Space Complexity :** **`O(N)`**\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nA better, more concise solution is to use multiset to solve the problem. We can keep track of the sorted elements of `A` and if any element of B is such that `A[i] > B[i]` is not possible, just assign it the smallest element available in the multiset. Every time an element is assigned and deleted.\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`.\\n**Space Complexity :** **`O(N)`**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150122,
                "title": "java-greedy-solution-using-map-easy-to-read-and-understand",
                "content": "Idea is that we need a sorted structure that makes it easy to find a smallest number higher than B[i]. If no such number exists, you use your smallest number from A at that position to maximize our chances to find better positions later.\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\t\\t\\t\\t\\n\\t    //Add each number to the map along with count\\n        for (int a : A) map.put(a, map.getOrDefault(a, 0)+1);\\n        \\n        int[] ret = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            //Find the best number to beat B[i]\\n            ret[i] = findBestMatch(B[i], map);\\n        }\\n        return ret;\\n    }\\n    \\n    private int findBestMatch(int target, TreeMap<Integer, Integer> map) {\\n\\t\\t// See if there exists a number higher than the target\\n        Integer res = map.higherKey(target);\\n\\t\\t\\t\\t\\n\\t\\t// If a number higher than target does not exist, use the smalles available number\\n        if (res == null) res = map.firstKey();\\n\\t\\t\\t\\t\\n\\t\\t//Update the TreeMap, remove the key if the number has 0 remaining occurences\\n        map.put(res, map.get(res) - 1);\\n        if (map.get(res) == 0) map.remove(res);\\n\\t\\t\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\t\\t\\t\\t\\n\\t    //Add each number to the map along with count\\n        for (int a : A) map.put(a, map.getOrDefault(a, 0)+1);\\n        \\n        int[] ret = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            //Find the best number to beat B[i]\\n            ret[i] = findBestMatch(B[i], map);\\n        }\\n        return ret;\\n    }\\n    \\n    private int findBestMatch(int target, TreeMap<Integer, Integer> map) {\\n\\t\\t// See if there exists a number higher than the target\\n        Integer res = map.higherKey(target);\\n\\t\\t\\t\\t\\n\\t\\t// If a number higher than target does not exist, use the smalles available number\\n        if (res == null) res = map.firstKey();\\n\\t\\t\\t\\t\\n\\t\\t//Update the TreeMap, remove the key if the number has 0 remaining occurences\\n        map.put(res, map.get(res) - 1);\\n        if (map.get(res) == 0) map.remove(res);\\n\\t\\t\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125451,
                "title": "2-solution-custom-sort-with-two-pointer-treemap",
                "content": "**Custom Sorting**\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        int[][] C = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            C[i][0] = B[i];\\n            C[i][1] = i;\\n        }\\n        \\n        Arrays.sort(C, (a, b) -> b[0] - a[0]);\\n        \\n        int[] result = new int[n];\\n        int lo = 0, hi = n - 1;\\n        for(int i = 0; i < n; i++) {\\n            if(A[hi] > C[i][0])\\n                result[C[i][1]] = A[hi--];\\n            else\\n                result[C[i][1]] = A[lo++];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n************\\n**TreeMap**\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int a : A)\\n            treeMap.put(a, treeMap.getOrDefault(a, 0) + 1);\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            Integer higher = treeMap.higherKey(B[i]);\\n            if (higher == null)\\n                higher = treeMap.firstKey();\\n            treeMap.put(higher, treeMap.get(higher) - 1);\\n            if (treeMap.get(higher) == 0)\\n                treeMap.remove(higher);\\n            result[i] = higher;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        int[][] C = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            C[i][0] = B[i];\\n            C[i][1] = i;\\n        }\\n        \\n        Arrays.sort(C, (a, b) -> b[0] - a[0]);\\n        \\n        int[] result = new int[n];\\n        int lo = 0, hi = n - 1;\\n        for(int i = 0; i < n; i++) {\\n            if(A[hi] > C[i][0])\\n                result[C[i][1]] = A[hi--];\\n            else\\n                result[C[i][1]] = A[lo++];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int a : A)\\n            treeMap.put(a, treeMap.getOrDefault(a, 0) + 1);\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            Integer higher = treeMap.higherKey(B[i]);\\n            if (higher == null)\\n                higher = treeMap.firstKey();\\n            treeMap.put(higher, treeMap.get(higher) - 1);\\n            if (treeMap.get(higher) == 0)\\n                treeMap.remove(higher);\\n            result[i] = higher;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125173,
                "title": "c-super-simple-and-easy-7-line-solution",
                "content": "First, we sort A.\\nThen, for each element in B, we insert in the result the least bigger element from A.\\nIf B[i] is bigger than the biggest value in A, there\\'s no way we can get a bigger element, so we\\'ll insert the smallest element from A.\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res;\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < B.size(); i++) {\\n            auto it = A.back() > B[i] ? upper_bound(A.begin(), A.end(), B[i]) : A.begin();\\n            res.push_back(*it);\\n            A.erase(it);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res;\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < B.size(); i++) {\\n            auto it = A.back() > B[i] ? upper_bound(A.begin(), A.end(), B[i]) : A.begin();\\n            res.push_back(*it);\\n            A.erase(it);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125210,
                "title": "advantage-shuffle-short-easy-w-explanation",
                "content": "***Solution - I***\\n\\nThe problem asks us to maximize `A[i] > B[i]`. We can do this by choosing an element from `A` for every element of `B` such that element chosen from A is the smallest element greater than corresponding element from B.\\n\\nTo do this efficiently, we must sort the arrays `A` and `B`. After that, we must choose the elements for each index of B as stated above. The index of B for which `A[i] > B[i]` isn\\'t possible in solution are assigned at last (order doesn\\'t matter).\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`\\n**Space Complexity :** **`O(N)`**\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nA better, more concise solution is to use multiset to solve the problem. We can keep track of the sorted elements of `A` and if any element of B is such that `A[i] > B[i]` is not possible, just assign it the smallest element available in the multiset. Every time an element is assigned and deleted.\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`.\\n**Space Complexity :** **`O(N)`**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126314,
                "title": "java-simple-and-easy-to-understand-solution-27-ms-faster-than-94-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        //store the element of B, and their corresponding index\\n        List<Item> itemBList = new ArrayList();\\n        for(int i = 0; i < A.length; i++){\\n            itemBList.add(new Item(i, B[i]));\\n        }\\n        \\n        //sort Array A increasing order\\n        Arrays.sort(A); \\n        \\n        //sort Array B increasing order, without loosing their index\\n        Collections.sort(itemBList, (a, b) -> (a.val - b.val));\\n        \\n        //make new array, and fill -1\\n        int[] result = new int[A.length];\\n        Arrays.fill(result, -1);\\n        \\n        List<Integer> remainingVal = new ArrayList();\\n        int i = 0;\\n        int j = 0;\\n        \\n        /*\\n            Gready Appraoch\\n            sort A, and B (wihout losing its index) increasing oreder of their value\\n            case \\n                if element at A[i], is greater than  itemBList.get(j), \\n                - just place A[i] in the right index itemBList.get(j).index\\n                otherwise \\n                -  just store in the remaining  array\\n        */\\n        \\n        \\n        while(i < A.length && j < A.length){\\n            if(A[i] > itemBList.get(j).val){\\n                //place the elemet of A, in the right place\\n                result[itemBList.get(j).index] = A[i];\\n                \\n                //move to next element for both A, and B\\n                i++;\\n                j++;\\n            }else{\\n                remainingVal.add(A[i]);\\n                \\n                //move to the next A item\\n                i++;\\n            }\\n        }\\n        \\n        //store the remaining elemet\\n        j = 0;\\n        for(i = 0; i < A.length && j < remainingVal.size(); i++){\\n            if(result[i] == -1){\\n                result[i] = remainingVal.get(j++);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n\\nclass Item {\\n    int index;\\n    int val;\\n    public Item(int index, int val){\\n        this.index = index;\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        //store the element of B, and their corresponding index\\n        List<Item> itemBList = new ArrayList();\\n        for(int i = 0; i < A.length; i++){\\n            itemBList.add(new Item(i, B[i]));\\n        }\\n        \\n        //sort Array A increasing order\\n        Arrays.sort(A); \\n        \\n        //sort Array B increasing order, without loosing their index\\n        Collections.sort(itemBList, (a, b) -> (a.val - b.val));\\n        \\n        //make new array, and fill -1\\n        int[] result = new int[A.length];\\n        Arrays.fill(result, -1);\\n        \\n        List<Integer> remainingVal = new ArrayList();\\n        int i = 0;\\n        int j = 0;\\n        \\n        /*\\n            Gready Appraoch\\n            sort A, and B (wihout losing its index) increasing oreder of their value\\n            case \\n                if element at A[i], is greater than  itemBList.get(j), \\n                - just place A[i] in the right index itemBList.get(j).index\\n                otherwise \\n                -  just store in the remaining  array\\n        */\\n        \\n        \\n        while(i < A.length && j < A.length){\\n            if(A[i] > itemBList.get(j).val){\\n                //place the elemet of A, in the right place\\n                result[itemBList.get(j).index] = A[i];\\n                \\n                //move to next element for both A, and B\\n                i++;\\n                j++;\\n            }else{\\n                remainingVal.add(A[i]);\\n                \\n                //move to the next A item\\n                i++;\\n            }\\n        }\\n        \\n        //store the remaining elemet\\n        j = 0;\\n        for(i = 0; i < A.length && j < remainingVal.size(); i++){\\n            if(result[i] == -1){\\n                result[i] = remainingVal.get(j++);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n\\nclass Item {\\n    int index;\\n    int val;\\n    public Item(int index, int val){\\n        this.index = index;\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164319,
                "title": "java-two-pointer-solution-without-using-treemap",
                "content": "What if both A and B are sorted? Then it could be solved by two-pointer like below:\\n\\n```\\nint[] res = new int[A.length];\\nint l = 0, r = res.length - 1;\\nfor (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n    if (A[idxA] > B[idxB]) {\\n        res[l] = A[idxA];\\n        idxB++;\\n        l++;\\n    } else {\\n        res[r] = A[idxA];\\n        r--;\\n    }\\n}\\nreturn res;\\n```\\n\\nBut for this problem, we cannot sort B. So let\\'s create an array for the indices of B, and sort it by the corresponding values in B. Then we could apply the two-pointer solution:\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        \\n        Integer[] bIdxArr = new Integer[B.length];\\n        for (int i = 0; i < bIdxArr.length; i++) {\\n            bIdxArr[i] = i;\\n        }\\n        Arrays.sort(bIdxArr, (a, b) -> (B[a] - B[b]));\\n        \\n        int[] res = new int[A.length];\\n        int l = 0, r = res.length - 1;\\n        for (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n            if (A[idxA] > B[bIdxArr[idxB]]) {\\n                res[bIdxArr[l]] = A[idxA];\\n                idxB++;\\n                l++;\\n            } else {\\n                res[bIdxArr[r]] = A[idxA];\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint[] res = new int[A.length];\\nint l = 0, r = res.length - 1;\\nfor (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n    if (A[idxA] > B[idxB]) {\\n        res[l] = A[idxA];\\n        idxB++;\\n        l++;\\n    } else {\\n        res[r] = A[idxA];\\n        r--;\\n    }\\n}\\nreturn res;\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        \\n        Integer[] bIdxArr = new Integer[B.length];\\n        for (int i = 0; i < bIdxArr.length; i++) {\\n            bIdxArr[i] = i;\\n        }\\n        Arrays.sort(bIdxArr, (a, b) -> (B[a] - B[b]));\\n        \\n        int[] res = new int[A.length];\\n        int l = 0, r = res.length - 1;\\n        for (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n            if (A[idxA] > B[bIdxArr[idxB]]) {\\n                res[bIdxArr[l]] = A[idxA];\\n                idxB++;\\n                l++;\\n            } else {\\n                res[bIdxArr[r]] = A[idxA];\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783387,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126749,
                "title": "c-greedy-multiset-approach-o-nlogn",
                "content": "Since we want to maximize number of indices i such that A[i] > B[i] we can greedily choose values while iterating vector B.\\n\\nApproach: \\n* Insert all the elements of vector A inside a multiset\\n* for each element in B try to find a suitable element in A using upper_bound which takes time complexity of O(logn) since multiset is stores elements in sorted order.\\n* If for an index we cannot find a proper value in mutliset we will skip the index and fill it up later with remainig values.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> a (A.begin(), A.end());\\n        \\n        vector<int> answer(A.size(),-1);\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            auto it = a.upper_bound(B[i]);\\n            if(it != a.end()) {\\n                answer[i] = *it;\\n                a.erase(it);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            if(answer[i] == -1) {\\n                answer[i] = *(a.begin());\\n                a.erase(a.begin());\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> a (A.begin(), A.end());\\n        \\n        vector<int> answer(A.size(),-1);\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            auto it = a.upper_bound(B[i]);\\n            if(it != a.end()) {\\n                answer[i] = *it;\\n                a.erase(it);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            if(answer[i] == -1) {\\n                answer[i] = *(a.begin());\\n                a.erase(a.begin());\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126365,
                "title": "c-upper-bound-solution-with-comments",
                "content": "**Explaination**\\n\\nA = [2,7,11,15]\\nB = [1,10,4,11]\\n\\nIt is mentioned in the question we requrie a permutation of A. So, we should start iterating in B. To get advantage we have to find greater element than current element of B from A. This defination is equivalent to Upper Bound. Upper Bound will return index of element which is greater than given element. If index is out of bound it means we are unable to find the element. So, we should remove first i.e. smallest element of A (as we required to sort A for upper bound),\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());  // Sorting A so that we can apply upper bound\\n        int n=B.size();  // Storing initial size of A and size of B\\n        vector<int> ans; // Defining ans vector which we are going to return\\n        for(int i=0;i<n;i++){\\n            int arr_size=A.size(); // Calculating size of A \\n            int ind=upper_bound(A.begin(),A.end(),B[i])-A.begin(); //Applying upper bound on vector A\\n            if(ind<arr_size){  // If index is within range of valid index of A it means we can get advantage\\n                ans.push_back(A[ind]); // Pushing element into ans vector\\n                A.erase(A.begin()+ind); // Removing element from vector A as we have used that element\\n            }\\n            else{\\n                ans.push_back(A[0]); // If we don\\'t have greater element in A we should take smallest element from A so that we can use other greter element for other elements\\' advantage as we require as many greater element as possible \\n                A.erase(A.begin()); // Removing smallest element from Vector A\\n            }\\n        }\\n        return ans; // Returning answer vector\\n    }\\n};\\n```\\n\\nIf like please upvote :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());  // Sorting A so that we can apply upper bound\\n        int n=B.size();  // Storing initial size of A and size of B\\n        vector<int> ans; // Defining ans vector which we are going to return\\n        for(int i=0;i<n;i++){\\n            int arr_size=A.size(); // Calculating size of A \\n            int ind=upper_bound(A.begin(),A.end(),B[i])-A.begin(); //Applying upper bound on vector A\\n            if(ind<arr_size){  // If index is within range of valid index of A it means we can get advantage\\n                ans.push_back(A[ind]); // Pushing element into ans vector\\n                A.erase(A.begin()+ind); // Removing element from vector A as we have used that element\\n            }\\n            else{\\n                ans.push_back(A[0]); // If we don\\'t have greater element in A we should take smallest element from A so that we can use other greter element for other elements\\' advantage as we require as many greater element as possible \\n                A.erase(A.begin()); // Removing smallest element from Vector A\\n            }\\n        }\\n        return ans; // Returning answer vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125203,
                "title": "c-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> C;\\n        C=B;\\n        sort(B.begin(),B.end());\\n        vector<int> ans;\\n        map<int,vector<int>> w;\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        int k=B.size()-1;\\n        while(j<B.size() && i<A.size()){\\n            if(A[i]>B[j]){\\n                count+=1;\\n                w[B[j]].push_back(A[i]);\\n                i+=1;\\n                j+=1;\\n            }\\n            else{\\n                w[B[k]].push_back(A[i]);\\n                i+=1;\\n                k-=1;\\n                \\n            }\\n            \\n        }\\n        for(auto i:C){\\n            ans.push_back(w[i][w[i].size()-1]);\\n            w[i].pop_back();\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> C;\\n        C=B;\\n        sort(B.begin(),B.end());\\n        vector<int> ans;\\n        map<int,vector<int>> w;\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        int k=B.size()-1;\\n        while(j<B.size() && i<A.size()){\\n            if(A[i]>B[j]){\\n                count+=1;\\n                w[B[j]].push_back(A[i]);\\n                i+=1;\\n                j+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1125073,
                "title": "advantage-shuffle-c-solution-easy-to-understand-with-explanation",
                "content": "The idea is to find the smallest greater number in `A` for every number in `B`. If there is no element greater in `A`, we take smallest number from `A`. \\n**using multiset**:\\nSo, here we use the multiset, we traverse `B` and find the `upperbound` for every number in `B`.removing element from multiset takes `O(1) time` since we are removing using iterator.\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s;\\n        for(int n:A) s.insert(n);\\n        for(int i = 0; i < B.size();i++) {\\n            auto p =  s.upper_bound(B[i]);\\n            if(p == s.end()) p =s.begin();\\n            A[i] = *p;\\n            s.erase(p);\\n        }\\n      return A;\\n    }\\n```\\n\\n**using vector**:\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<pair<int, int>> v;\\n\\t    for(int i=0; i<B.size(); i++)\\n            v.push_back({B[i], i});\\n\\t    sort(A.begin(), A.end());\\n\\t    sort(v.begin(), v.end());\\n        int k = A.size()-1;\\n\\t    for (int i=0,j=0;i<A.size();i++) {\\n\\t\\t    if(A[i] > v[j].first){\\n                B[v[j].second] = A[i];\\n                j++;\\n            }else{\\n                B[v[k].second] = A[i];\\n                k--;\\n            } \\n\\t    }\\n        return B;\\n    }\\n```\\n**Do Upvote** if you find it helpful!!!",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s;\\n        for(int n:A) s.insert(n);\\n        for(int i = 0; i < B.size();i++) {\\n            auto p =  s.upper_bound(B[i]);\\n            if(p == s.end()) p =s.begin();\\n            A[i] = *p;\\n            s.erase(p);\\n        }\\n      return A;\\n    }\\n```\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<pair<int, int>> v;\\n\\t    for(int i=0; i<B.size(); i++)\\n            v.push_back({B[i], i});\\n\\t    sort(A.begin(), A.end());\\n\\t    sort(v.begin(), v.end());\\n        int k = A.size()-1;\\n\\t    for (int i=0,j=0;i<A.size();i++) {\\n\\t\\t    if(A[i] > v[j].first){\\n                B[v[j].second] = A[i];\\n                j++;\\n            }else{\\n                B[v[k].second] = A[i];\\n                k--;\\n            } \\n\\t    }\\n        return B;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591514,
                "title": "simple-c-code-greedy",
                "content": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\n\\tvector<pair<int, int>> C;\\n\\tfor (int i = 0; i < B.size(); ++i) C.push_back({B[i], i});\\n\\tsort(A.begin(), A.end());\\n\\tsort(C.begin(), C.end());\\n\\n\\tfor (int i = 0, j = 0, k = A.size() - 1; i < A.size(); ++i) {\\n\\t\\tif (A[i] > C[j].first) B[C[j].second] = A[i], ++j;\\n\\t\\telse B[C[k].second] = A[i], --k;\\n\\t}\\n\\n\\treturn B;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\n\\tvector<pair<int, int>> C;\\n\\tfor (int i = 0; i < B.size(); ++i) C.push_back({B[i], i});\\n\\tsort(A.begin(), A.end());\\n\\tsort(C.begin(), C.end());\\n\\n\\tfor (int i = 0, j = 0, k = A.size() - 1; i < A.size(); ++i) {\\n\\t\\tif (A[i] > C[j].first) B[C[j].second] = A[i], ++j;\\n\\t\\telse B[C[k].second] = A[i], --k;\\n\\t}\\n\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236924,
                "title": "greedy-solution-without-using-map",
                "content": "The idea is to sort the indices of array B based on the elements.\\nThen compare the sorted array A with sorted array B. Because \\nwe keep the original indices of array B, we know where the value should be put\\nin output array.\\n\\n```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Integer[] C = new Integer[B.length];\\n        for(int i = 0; i < C.length; i++) {\\n            C[i] = i;\\n        }\\n        Arrays.sort(C, new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer o1, Integer o2) {\\n                return B[o1] - B[o2];\\n            }\\n        });\\n        Arrays.sort(A);\\n        int i = 0, j = A.length - 1, k = C.length - 1;\\n        while(i <= j) {\\n           if (A[j] > B[C[k]]) {\\n               result[C[k]] = A[j--];\\n           } else {\\n               result[C[k]] = A[i++];\\n           }\\n            k--;  \\n        }\\n        return result;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Integer[] C = new Integer[B.length];\\n        for(int i = 0; i < C.length; i++) {\\n            C[i] = i;\\n        }\\n        Arrays.sort(C, new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer o1, Integer o2) {\\n                return B[o1] - B[o2];\\n            }\\n        });\\n        Arrays.sort(A);\\n        int i = 0, j = A.length - 1, k = C.length - 1;\\n        while(i <= j) {\\n           if (A[j] > B[C[k]]) {\\n               result[C[k]] = A[j--];\\n           } else {\\n               result[C[k]] = A[i++];\\n           }\\n            k--;  \\n        }\\n        return result;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837204,
                "title": "advantage-shuffling-by-using-multiset-approach",
                "content": "Step 1 : change array into multiset -->it become sorted have rich function also\\nStep 2 : search the greater element in multiset  for given b[i] by multiset :: upper_bound(iterator)\\nStep 3 : if found --> store in new array and erase that element by multiset :: erase(iterator) ,otherwise store beginnning element of multiset in new array   and erase then ;\\nStep 4 :  return the new array\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282817,
                "title": "swap-greedily-detailed-explanation-c",
                "content": "I have not yet checked the discussion section but my approach is basically this :\\n\\n0. Map the elements of nums2 with its indices as it would be useful for step 3.\\n\\n1. Sort both the arrays.\\n\\n2. Now, start selecting elements from nums2. \\n**The goal is to select the smallest element in nums1 beating nums2[i] - if I find one, I will swap nums1[i] with that element, else I won\\'t swap and end the loop.**\\n\\n3. Now just map the elements of the resultant nums1 array according to the oiginal nums2 array.\\n\\n***Now, the question is, why does this algorithm work?***\\n\\nSuppose we are checking element at position i - that means that all the elements before index i have been optimally paired, and need not be modified.\\n\\nSo, we need to find an element between index i and len - 1 in nums1, which is larger than nums2[i], we must also ensure that the element we are choosing is the least among the greater elements, else we might lose advantage later. For instance, we have arrays :\\nnums1 = [2,7,11,15]\\nnums2 = [1,10,4,11]\\n\\nWhile considering index 0, I will select element 2 here. Why? Suppose, we choose 15 to pair with 1, then we would won\\'t have any element to pair and gain advantage over 11.\\nSimilar issue with choosing 7 or 11.\\n\\n***What if I don\\'t find any greater element in nums1? Why should I break out of the loop?***\\n\\nAs already stated, all elements in nums1 before index i are already at their optimal positions, modifying them is unnecessary. If we don\\'t find an element greater than nums2[i] in nums1[i] to nums1[-1], we won\\'t be finding any element greater than nums2[i], even in the later iterations as nums2 is already sorted in the ascending order.\\nSo, we won\\'t be having any \"advantage\" later in the loop, so break out of the loop.\\n\\nTime complexity - O(n log n) same as the sorting time.\\n\\nHere is the code :\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n    \\n        map<int , set<int>> mp;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            mp[nums2[i]].insert(i);\\n        }\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        \\n        vector<int> res(n , 0);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n\\t\\t\\tauto a = upper_bound(nums1.begin() + i, nums1.end(), nums2[i]);                                       int x = a - nums1.begin();\\n            \\n            if(x < n){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[x];\\n                nums1[x] = temp;               \\n            }\\n            \\n            else \\n                break;\\n\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            int pos = *(mp[nums2[i]].begin());\\n            \\n            mp[nums2[i]].erase(pos);\\n            \\n            res[pos] = nums1[i];\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n  \\n};\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n    \\n        map<int , set<int>> mp;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            mp[nums2[i]].insert(i);\\n        }\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        \\n        vector<int> res(n , 0);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n\\t\\t\\tauto a = upper_bound(nums1.begin() + i, nums1.end(), nums2[i]);                                       int x = a - nums1.begin();\\n            \\n            if(x < n){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[x];\\n                nums1[x] = temp;               \\n            }\\n            \\n            else \\n                break;\\n\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            int pos = *(mp[nums2[i]].begin());\\n            \\n            mp[nums2[i]].erase(pos);\\n            \\n            res[pos] = nums1[i];\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126094,
                "title": "c-greedy-sorting-two-pointers-beats-100-easy-to-understand",
                "content": "```\\npublic class Solution {\\n\\tpublic int[] AdvantageCount(int[] A, int[] B) {\\n        var N = A.Length;\\n        var idxs = new int[N]; // indices from 0..N-1\\n        for(int i=N-1; i>= 0; --i)\\n            idxs[i] = i;\\n        \\n        Array.Sort(B, idxs); // sort B in ascending order, keeping the original order into idxs\\n        Array.Sort(A); // sort A in ascending order\\n        \\n\\t\\tvar L = 0; // pointer to \"minimum\" value in A\\n        var R = N-1; // pointer to \"maximum\" value in A\\n        var result = new int[N];\\n        for(int i=N-1; i>= 0; --i)\\n        {\\n            if(B[i] >= A[R])\\n            {\\n\\t\\t\\t\\t// greedy approach: assign minimum value from A (and move \"minimum\" pointer to the right)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[L++];\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// greedy approach: assign maximum value from A (and move \"maximum\" pointer to the left)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[R--];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n\\tpublic int[] AdvantageCount(int[] A, int[] B) {\\n        var N = A.Length;\\n        var idxs = new int[N]; // indices from 0..N-1\\n        for(int i=N-1; i>= 0; --i)\\n            idxs[i] = i;\\n        \\n        Array.Sort(B, idxs); // sort B in ascending order, keeping the original order into idxs\\n        Array.Sort(A); // sort A in ascending order\\n        \\n\\t\\tvar L = 0; // pointer to \"minimum\" value in A\\n        var R = N-1; // pointer to \"maximum\" value in A\\n        var result = new int[N];\\n        for(int i=N-1; i>= 0; --i)\\n        {\\n            if(B[i] >= A[R])\\n            {\\n\\t\\t\\t\\t// greedy approach: assign minimum value from A (and move \"minimum\" pointer to the right)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[L++];\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// greedy approach: assign maximum value from A (and move \"maximum\" pointer to the left)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[R--];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125740,
                "title": "javascript-simple-two-pointer-greedy-approach",
                "content": "Time: `O(N log N)`\\nSpace: `O(N)`\\n```javascript\\nvar advantageCount = function(A, B) {\\n    const mapB = B.map((n, i) => [n, i]);\\n    const len = A.length;\\n    const output = [];\\n    const useless = []\\n    \\n    A.sort((a, b) => a - b);\\n    mapB.sort((a, b) => a[0] - b[0]);\\n    \\n    let currB = 0;\\n    \\n    for(let i = 0; i < len; i++) {\\n        const [numB, idxB] = mapB[currB];\\n        \\n        if(numB >= A[i]) useless.push(A[i]);\\n        else {\\n            output[idxB] = A[i];\\n            currB++;\\n        }\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        if(output[i] === undefined) {\\n            output[i] = useless.pop();\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```javascript\\nvar advantageCount = function(A, B) {\\n    const mapB = B.map((n, i) => [n, i]);\\n    const len = A.length;\\n    const output = [];\\n    const useless = []\\n    \\n    A.sort((a, b) => a - b);\\n    mapB.sort((a, b) => a[0] - b[0]);\\n    \\n    let currB = 0;\\n    \\n    for(let i = 0; i < len; i++) {\\n        const [numB, idxB] = mapB[currB];\\n        \\n        if(numB >= A[i]) useless.push(A[i]);\\n        else {\\n            output[idxB] = A[i];\\n            currB++;\\n        }\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        if(output[i] === undefined) {\\n            output[i] = useless.pop();\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125177,
                "title": "simple-and-intuitive-solution-using-multiset-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t// why multiset not set ? Duplicates ?\\n        multiset<int> set(begin(A),end(A));\\n\\t\\t// answer array !\\n        vector<int> ans(n,0);\\n\\t\\t// ans[i] => 0 means answer for this index is not yet discovered \\n\\t\\t// find upper bound of every element of B in multiset of A .... why ? coz A[i] > B[i]\\n        for(int i=0;i<n;i++){\\n            auto find = set.upper_bound(B[i]);\\n\\t\\t\\t// if got an upper bound then use it and erase it !\\n            if(find!=set.end()){\\n                ans[i]=*find;\\n\\t\\t\\t\\t// deletes only that particular element not all it\\'s occurrence.\\n                set.erase(find);\\n            }\\n        }\\n\\t\\t// if there are still some elements left ... put all of them in remaining space !\\n        if(set.size()){\\n            auto it = set.begin();\\n            for(int i=0;i<n;i++){\\n                if(!ans[i]){\\n                    ans[i] = *it;\\n                    it++;\\n                }\\n            }\\n        }\\n\\t\\t// hurray, we made it !\\n        return ans;\\n    }\\n};\\n```\\n```\\nLet\\'s talk About Time and Space complexity : \\nTC : O(NlogN) \\nSC : O(N) \\n```\\nDo Upvote if you liked it !",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t// why multiset not set ? Duplicates ?\\n        multiset<int> set(begin(A),end(A));\\n\\t\\t// answer array !\\n        vector<int> ans(n,0);\\n\\t\\t// ans[i] => 0 means answer for this index is not yet discovered \\n\\t\\t// find upper bound of every element of B in multiset of A .... why ? coz A[i] > B[i]\\n        for(int i=0;i<n;i++){\\n            auto find = set.upper_bound(B[i]);\\n\\t\\t\\t// if got an upper bound then use it and erase it !\\n            if(find!=set.end()){\\n                ans[i]=*find;\\n\\t\\t\\t\\t// deletes only that particular element not all it\\'s occurrence.\\n                set.erase(find);\\n            }\\n        }\\n\\t\\t// if there are still some elements left ... put all of them in remaining space !\\n        if(set.size()){\\n            auto it = set.begin();\\n            for(int i=0;i<n;i++){\\n                if(!ans[i]){\\n                    ans[i] = *it;\\n                    it++;\\n                }\\n            }\\n        }\\n\\t\\t// hurray, we made it !\\n        return ans;\\n    }\\n};\\n```\n```\\nLet\\'s talk About Time and Space complexity : \\nTC : O(NlogN) \\nSC : O(N) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 920672,
                "title": "java-treemap",
                "content": "```\\nclass Solution {\\n\\n    public int[] advantageCount(int[] A, int[] B) {\\n\\t\\n\\t    //Use TreeMap to sort\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for (int a : A) {\\n            tm.put(a, tm.getOrDefault(a, 0) + 1);\\n        }\\n        \\n        for(int i=0; i<B.length; i++) {\\n            int val = B[i];\\n\\t\\t\\t\\n\\t\\t\\t//find the higher value\\n            Integer tmp = tm.ceilingKey(val+1);\\n\\t\\t\\t//if no higher value, use the least key\\n            if(tmp == null) {\\n                tmp = tm.firstKey();\\n            }\\n\\t\\t\\t//store to results\\n            A[i] = tmp;\\n\\t\\t\\t\\n\\t\\t\\t//reduce key count or remove when 0\\n            int cnt = tm.get(tmp);\\n            if(cnt > 1) {\\n                tm.put(tmp, cnt-1);\\n            } else {\\n                tm.remove(tmp);\\n            }\\n            \\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int[] advantageCount(int[] A, int[] B) {\\n\\t\\n\\t    //Use TreeMap to sort\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for (int a : A) {\\n            tm.put(a, tm.getOrDefault(a, 0) + 1);\\n        }\\n        \\n        for(int i=0; i<B.length; i++) {\\n            int val = B[i];\\n\\t\\t\\t\\n\\t\\t\\t//find the higher value\\n            Integer tmp = tm.ceilingKey(val+1);\\n\\t\\t\\t//if no higher value, use the least key\\n            if(tmp == null) {\\n                tmp = tm.firstKey();\\n            }\\n\\t\\t\\t//store to results\\n            A[i] = tmp;\\n\\t\\t\\t\\n\\t\\t\\t//reduce key count or remove when 0\\n            int cnt = tm.get(tmp);\\n            if(cnt > 1) {\\n                tm.put(tmp, cnt-1);\\n            } else {\\n                tm.remove(tmp);\\n            }\\n            \\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843628,
                "title": "python-3-greedy-two-pointers-explanations",
                "content": "### Explanation\\n- Intuitively, we can see that, for A, to make the most advantage over B is to use large number cover large number, small number to cover small number, if possible. e.g.\\n\\t- `A = [5, 9]`, `B = [4, 8]`, we can easily tell, 5 covers 4, 9 covers 8\\n\\t- but if we switch the order, we noticed that 9 covers 4, but 5 can\\'t cover 8\\n- Given the thought above, we simply sort `A` & `B` (reversely, from large to small)\\n- Iterate over `B`, \\n\\t- if current `A[j]` covers current `B[i]`\\n\\t\\t- we take it, meaning assign `A[j]` at the original index (`ori_idx`) of `B[i]` \\n\\t\\t- then increment `j`, meaning use next largest number in `A`\\n\\t- otherwise, meaning `B[i]` is too large for the current maximum available `A[j]`, so check whether next number (`B[i+1]`) can be covered by `A[j]`\\n- After we iterate over `B`, there might have some original index wasn\\'t assigned (because it\\'s possible that not all values is B was covered)\\n\\t- Simply iterate over `ans`, if we meet a `-1` (meaning wasn\\'t assigned), then assign the rest value in A to them\\n### Implementation\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        sorted_a = sorted(A, reverse=True)                                         # descending order\\n        sorted_b = sorted(enumerate(B), key=lambda x: (x[1], x[0]), reverse=True)  # descending order with original index\\n        n, j = len(B), 0\\n        ans = [-1] * n\\n        for i, (ori_idx, val) in enumerate(sorted_b):                 # A greedily tries to cover value in B as large as possible\\n            if sorted_a[j] > val: ans[ori_idx], j = sorted_a[j], j+1\\n        for i in range(n):                                            # assign rest value in A to ans\\n            if ans[i] == -1: ans[i], j = sorted_a[j], j+1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        sorted_a = sorted(A, reverse=True)                                         # descending order\\n        sorted_b = sorted(enumerate(B), key=lambda x: (x[1], x[0]), reverse=True)  # descending order with original index\\n        n, j = len(B), 0\\n        ans = [-1] * n\\n        for i, (ori_idx, val) in enumerate(sorted_b):                 # A greedily tries to cover value in B as large as possible\\n            if sorted_a[j] > val: ans[ori_idx], j = sorted_a[j], j+1\\n        for i in range(n):                                            # assign rest value in A to ans\\n            if ans[i] == -1: ans[i], j = sorted_a[j], j+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694392,
                "title": "javascript-o-nlog-n-time-o-n-space-beats-90",
                "content": "```\\nvar advantageCount = function(A, B) {\\n    //first, map indices within B to their values\\n    const bMap = {};\\n    for (let i = 0; i < B.length; i++) {\\n        const num = B[i];\\n        if (!bMap[num]) bMap[num] = [];\\n        bMap[num].push(i);\\n    }\\n    \\n    //initialize output array\\n    let output = new Array(A.length).fill(null);\\n    \\n    //sort both arrays largest to smallest\\n    A.sort((a, b) => b - a);\\n    B.sort((a, b) => b - a);\\n    \\n    //tracking indices avoids time penalties of shifting array.\\n    let aStart = 0;\\n    let aEnd = A.length - 1;\\n    let bStart = 0;\\n    \\n    //If largest remaining A can beat largest remaining B, let it.\\n    //Otherwise, pair largest remaining B with smallest remaining A.\\n    while (aStart <= aEnd) {\\n        const aMax = A[aStart];\\n        const aMin = A[aEnd];\\n        const bMax = B[bStart];\\n        const bCoord = bMap[bMax].pop();\\n        if (aMax > bMax) {\\n            output[bCoord] = aMax;\\n            aStart ++;\\n        } else {\\n            output[bCoord] = aMin;\\n            aEnd --;\\n        }\\n        bStart ++;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar advantageCount = function(A, B) {\\n    //first, map indices within B to their values\\n    const bMap = {};\\n    for (let i = 0; i < B.length; i++) {\\n        const num = B[i];\\n        if (!bMap[num]) bMap[num] = [];\\n        bMap[num].push(i);\\n    }\\n    \\n    //initialize output array\\n    let output = new Array(A.length).fill(null);\\n    \\n    //sort both arrays largest to smallest\\n    A.sort((a, b) => b - a);\\n    B.sort((a, b) => b - a);\\n    \\n    //tracking indices avoids time penalties of shifting array.\\n    let aStart = 0;\\n    let aEnd = A.length - 1;\\n    let bStart = 0;\\n    \\n    //If largest remaining A can beat largest remaining B, let it.\\n    //Otherwise, pair largest remaining B with smallest remaining A.\\n    while (aStart <= aEnd) {\\n        const aMax = A[aStart];\\n        const aMin = A[aEnd];\\n        const bMax = B[bStart];\\n        const bCoord = bMap[bMax].pop();\\n        if (aMax > bMax) {\\n            output[bCoord] = aMax;\\n            aStart ++;\\n        } else {\\n            output[bCoord] = aMin;\\n            aEnd --;\\n        }\\n        bStart ++;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151736,
                "title": "python-solution-nlog-n-time-complexity-with-a-b-space",
                "content": "```\\nfrom collections import defaultdict\\n    \\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = sorted(A)\\n        b = sorted(B)\\n        j = 0 \\n        hm = defaultdict(list)\\n        no_matches = []\\n        for i in range(len(a)):\\n            if a[i] > b[j]:\\n                hm[b[j]].append(a[i])\\n                j += 1\\n            else:\\n                no_matches.append(a[i])\\n        return [ hm[n].pop() if n in hm and len(hm[n]) > 0 else no_matches.pop() for n in B ]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n    \\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = sorted(A)\\n        b = sorted(B)\\n        j = 0 \\n        hm = defaultdict(list)\\n        no_matches = []\\n        for i in range(len(a)):\\n            if a[i] > b[j]:\\n                hm[b[j]].append(a[i])\\n                j += 1\\n            else:\\n                no_matches.append(a[i])\\n        return [ hm[n].pop() if n in hm and len(hm[n]) > 0 else no_matches.pop() for n in B ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149865,
                "title": "python-using-sort",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        B0=[[i,B[i],0] for i in range(len(B))]\\n        A.sort()\\n        B0.sort(key=lambda x:x[1])\\n        p2=0\\n        wasted=1\\n        for p1 in A:\\n            if p1>B0[p2][1]:\\n                B0[p2][2]=p1\\n                p2+=1\\n            else:\\n                B0[-wasted][2]=p1\\n                wasted+=1\\n        B0.sort(key=lambda x:x[0])\\n\\t\\t\\t\\t\\n        return [i[2] for i in B0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        B0=[[i,B[i],0] for i in range(len(B))]\\n        A.sort()\\n        B0.sort(key=lambda x:x[1])\\n        p2=0\\n        wasted=1\\n        for p1 in A:\\n            if p1>B0[p2][1]:\\n                B0[p2][2]=p1\\n                p2+=1\\n            else:\\n                B0[-wasted][2]=p1\\n                wasted+=1\\n        B0.sort(key=lambda x:x[0])\\n\\t\\t\\t\\t\\n        return [i[2] for i in B0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499371,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        vector<int>res(n,-1);\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[j].first<nums1[i])\\n            {\\n                res[v[j].second]=nums1[i];\\n                nums1[i]=-1;\\n                j++;\\n            }\\n        }\\n        j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]!=-1)\\n            {\\n                while(res[j]!=-1)\\n                {\\n                    j++;\\n                }\\n                res[j]=nums1[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        from collections import deque\\n        q = deque(sorted(nums1))\\n        n = len(nums1)\\n        order = sorted(range(n), key=lambda x: nums2[x], reverse=True)\\n        res = [0] * n\\n        for idx in order:\\n            if q[-1] > nums2[idx]:\\n                res[idx] = q.pop()\\n            else:\\n                res[idx] = q.popleft()\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        int[] ans = new int[n];\\n        boolean[] vis = new boolean[n];\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int ub = upperBound(nums1, nums2[i]);\\n            if(ub!=n && vis[ub]==false){\\n                 ans[i] = nums1[ub];\\n                 vis[ub] = true;\\n            }\\n            else if(ub<n-1 && vis[ub]==true){\\n                while(ub<n && vis[ub]==true){\\n                    ub++;\\n                }\\n                if(ub==n){\\n                    arr.add(i);\\n                }\\n                else{\\n                     ans[i] = nums1[ub];\\n                     vis[ub]=true;\\n                }\\n            }\\n            else{\\n              arr.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int x: arr){\\n            while(j<n && vis[j]==true){\\n                j++;\\n            }\\n            ans[x]=nums1[j];\\n            vis[j]=true;\\n        }\\n        return ans;\\n    }\\n    public int upperBound(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]<=target){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        vector<int>res(n,-1);\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[j].first<nums1[i])\\n            {\\n                res[v[j].second]=nums1[i];\\n                nums1[i]=-1;\\n                j++;\\n            }\\n        }\\n        j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]!=-1)\\n            {\\n                while(res[j]!=-1)\\n                {\\n                    j++;\\n                }\\n                res[j]=nums1[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        from collections import deque\\n        q = deque(sorted(nums1))\\n        n = len(nums1)\\n        order = sorted(range(n), key=lambda x: nums2[x], reverse=True)\\n        res = [0] * n\\n        for idx in order:\\n            if q[-1] > nums2[idx]:\\n                res[idx] = q.pop()\\n            else:\\n                res[idx] = q.popleft()\\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        int[] ans = new int[n];\\n        boolean[] vis = new boolean[n];\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int ub = upperBound(nums1, nums2[i]);\\n            if(ub!=n && vis[ub]==false){\\n                 ans[i] = nums1[ub];\\n                 vis[ub] = true;\\n            }\\n            else if(ub<n-1 && vis[ub]==true){\\n                while(ub<n && vis[ub]==true){\\n                    ub++;\\n                }\\n                if(ub==n){\\n                    arr.add(i);\\n                }\\n                else{\\n                     ans[i] = nums1[ub];\\n                     vis[ub]=true;\\n                }\\n            }\\n            else{\\n              arr.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int x: arr){\\n            while(j<n && vis[j]==true){\\n                j++;\\n            }\\n            ans[x]=nums1[j];\\n            vis[j]=true;\\n        }\\n        return ans;\\n    }\\n    public int upperBound(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]<=target){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574032,
                "title": "only-simple-sorting-without-heap-or-multiset-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>&a, pair<int,int>&b){\\n        return a.second < b.second;\\n    }\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<pair<int,int>>v;\\n        for(int i = 0; i < n ; i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>vis(n,0);\\n        int i = 0;\\n        int j = 0;\\n        while( j < n && i < n){\\n            if(nums1[i] > v[j].first){\\n                v[j].first = nums1[i];\\n                vis[i] = 1;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        i = 0;\\n        while( j < n){\\n            if(vis[i] == 0){\\n                v[j].first = nums1[i];\\n                j++;\\n            }\\n            i++;\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int> ans;\\n        for(auto &x:v)\\n            ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>&a, pair<int,int>&b){\\n        return a.second < b.second;\\n    }\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<pair<int,int>>v;\\n        for(int i = 0; i < n ; i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>vis(n,0);\\n        int i = 0;\\n        int j = 0;\\n        while( j < n && i < n){\\n            if(nums1[i] > v[j].first){\\n                v[j].first = nums1[i];\\n                vis[i] = 1;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        i = 0;\\n        while( j < n){\\n            if(vis[i] == 0){\\n                v[j].first = nums1[i];\\n                j++;\\n            }\\n            i++;\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int> ans;\\n        for(auto &x:v)\\n            ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491265,
                "title": "sort",
                "content": "**greedy**\\n**time: `O(NlogN)`; space: `O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/baeb977b-a7f1-4f70-ba82-0e7dcba741f9_1661636280.332966.png)\\n\\n![image](https://assets.leetcode.com/users/images/8628aaf7-2640-4351-8763-5d9377ce1afe_1661637931.9426262.png)\\n\\n![image](https://assets.leetcode.com/users/images/3f0cacf8-5e77-4b77-85ec-b879173e0b28_1661637080.2531178.png)\\n\\n```\\nvector<int> advantageCount(vector<int>& n, vector<int>& m) \\n{\\n\\tvector<int> i(size(n)), out(size(n));\\n\\tiota(begin(i), end(i), 0); \\n\\tsort(begin(n), end(n));\\n\\tsort(begin(i), end(i), [&](auto & x, auto & y){ return m[x]<m[y]; });\\n\\n\\tfor(int b{}, e(size(n)); const auto & x : n)\\n\\t\\tout[i[m[i[b]]<x ? b++ : --e]] = x; \\n\\treturn out;\\n}\\n```\\n**Notation:**\\n\\n`i` - **i**ndices;\\n`b` - **b**egin;\\n`e` - **e**nd.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& n, vector<int>& m) \\n{\\n\\tvector<int> i(size(n)), out(size(n));\\n\\tiota(begin(i), end(i), 0); \\n\\tsort(begin(n), end(n));\\n\\tsort(begin(i), end(i), [&](auto & x, auto & y){ return m[x]<m[y]; });\\n\\n\\tfor(int b{}, e(size(n)); const auto & x : n)\\n\\t\\tout[i[m[i[b]]<x ? b++ : --e]] = x; \\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362809,
                "title": "simple-and-short-c-solution",
                "content": "1)The idea here is to push the elements of nums1 to map \\n2)Use upper bound to find the immediate greater element\\n3)If no greater element found  for that given index,the answer for the given index would be the smallest existing element of nums1\\n4)Remove that element from map,once pushed to ans vector to avoid it being taken more than once\\n\\n\\n\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++)m[nums1[i]]++;\\n         \\n        for(int i=0;i<nums2.size();i++){\\n            \\n            auto it=m.upper_bound(nums2[i]);\\n          \\n            if(it==m.end()){// in case no larger element is found,we put the smallest element as our ans for that given index\\n                int t=m.begin()->first;\\n                ans.push_back(t);\\n               m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n            else{\\n                int t=it->first;\\n               ans.push_back(t);\\n                m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\'\\'\\'\\n\\nDo upvote if you like the solution:)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "1)The idea here is to push the elements of nums1 to map \\n2)Use upper bound to find the immediate greater element\\n3)If no greater element found  for that given index,the answer for the given index would be the smallest existing element of nums1\\n4)Remove that element from map,once pushed to ans vector to avoid it being taken more than once\\n\\n\\n\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++)m[nums1[i]]++;\\n         \\n        for(int i=0;i<nums2.size();i++){\\n            \\n            auto it=m.upper_bound(nums2[i]);\\n          \\n            if(it==m.end()){// in case no larger element is found,we put the smallest element as our ans for that given index\\n                int t=m.begin()->first;\\n                ans.push_back(t);\\n               m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n            else{\\n                int t=it->first;\\n               ans.push_back(t);\\n                m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\'\\'\\'\\n\\nDo upvote if you like the solution:)",
                "codeTag": "Unknown"
            },
            {
                "id": 2246818,
                "title": "c",
                "content": "vector<int> advantageCount(vector<int>& arr, vector<int>& arr2) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size(),i;\\n        vector<int>ans(n,-1);\\n        unordered_map<int,vector<int>>mp;\\n        for ( i = 0; i < n; i++)\\n        {\\n            mp[arr2[i]].push_back(i);\\n        }\\n        sort(arr2.begin(),arr2.end());\\n\\n         i=0;\\n         int j=0;\\n         vector<int>temp;\\n         while (i<n)\\n         {\\n            if (arr[i]>arr2[j])\\n            {\\n                int x=mp[arr2[j]].back();\\n                mp[arr2[j]].pop_back();\\n                ans[x]=arr[i];\\n                i++,j++;\\n               \\n            }\\n            else\\n            {\\n                temp.push_back(arr[i]);\\n                i++;\\n            }\\n            \\n            \\n         }\\n         j=0;\\n         for ( i = 0; i < n; i++)\\n         {\\n            if (ans[i]==-1)\\n            {\\n                ans[i]=temp[j];\\n                j++;\\n            }\\n            \\n         }\\n         \\n         \\n        return ans;\\n\\n        \\n    }",
                "solutionTags": [],
                "code": "vector<int> advantageCount(vector<int>& arr, vector<int>& arr2) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size(),i;\\n        vector<int>ans(n,-1);\\n        unordered_map<int,vector<int>>mp;\\n        for ( i = 0; i < n; i++)\\n        {\\n            mp[arr2[i]].push_back(i);\\n        }\\n        sort(arr2.begin(),arr2.end());\\n\\n         i=0;\\n         int j=0;\\n         vector<int>temp;\\n         while (i<n)\\n         {\\n            if (arr[i]>arr2[j])\\n            {\\n                int x=mp[arr2[j]].back();\\n                mp[arr2[j]].pop_back();\\n                ans[x]=arr[i];\\n                i++,j++;\\n               \\n            }\\n            else\\n            {\\n                temp.push_back(arr[i]);\\n                i++;\\n            }\\n            \\n            \\n         }\\n         j=0;\\n         for ( i = 0; i < n; i++)\\n         {\\n            if (ans[i]==-1)\\n            {\\n                ans[i]=temp[j];\\n                j++;\\n            }\\n            \\n         }\\n         \\n         \\n        return ans;\\n\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1860873,
                "title": "c-easy-to-understand-simple-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n\\n**Using vector (Gives TLE)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.push_back(num);\\n        }\\n        sort(t.begin(),t.end());\\n        vector<int> ans;\\n        int k=0;\\n        for(auto num:nums2)\\n        {\\n            auto upper=upper_bound(t.begin()+k,t.end(),num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*(t.begin()+k));\\n                t.erase(t.begin()+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Using Multi-set**\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        multiset<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.insert(num);\\n        }\\n        vector<int> ans;\\n        for(auto num:nums2)\\n        {\\n            auto upper=t.upper_bound(num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*t.begin());\\n                t.erase(t.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.push_back(num);\\n        }\\n        sort(t.begin(),t.end());\\n        vector<int> ans;\\n        int k=0;\\n        for(auto num:nums2)\\n        {\\n            auto upper=upper_bound(t.begin()+k,t.end(),num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*(t.begin()+k));\\n                t.erase(t.begin()+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        multiset<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.insert(num);\\n        }\\n        vector<int> ans;\\n        for(auto num:nums2)\\n        {\\n            auto upper=t.upper_bound(num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*t.begin());\\n                t.erase(t.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496555,
                "title": "c-super-simple-using-two-pointer-just-compare-and-update",
                "content": "```\\n/* \\nwe will think of greater element first i.e. :-\\nif(max(A)>max(B)) then we\\'ll update maximum[B]=maximum[A], else  maximum[B]=minimum[A] \\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n         int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];  \\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\nwe will think of greater element first i.e. :-\\nif(max(A)>max(B)) then we\\'ll update maximum[B]=maximum[A], else  maximum[B]=minimum[A] \\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n         int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];  \\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280974,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        //we need to maintain the nums1 in sorted order\\n        //for every ele in nums2 get the next greater ele in nums1;\\n        \\n        multiset<int> s(nums1.begin(),nums1.end());\\n        \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            //if the last element in set is greater than current element\\n            //then we can be sure to get a upper bound\\n            //if not we place the first element (smallest element) \\n             auto it= *s.rbegin()>nums2[i] ? s.upper_bound(nums2[i]) : s.begin();\\n            nums1[i]= *it;\\n            s.erase(it);\\n        }\\n        return nums1;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        //we need to maintain the nums1 in sorted order\\n        //for every ele in nums2 get the next greater ele in nums1;\\n        \\n        multiset<int> s(nums1.begin(),nums1.end());\\n        \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            //if the last element in set is greater than current element\\n            //then we can be sure to get a upper bound\\n            //if not we place the first element (smallest element) \\n             auto it= *s.rbegin()>nums2[i] ? s.upper_bound(nums2[i]) : s.begin();\\n            nums1[i]= *it;\\n            s.erase(it);\\n        }\\n        return nums1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147578,
                "title": "c-using-multiset-and-upper-bound-probably-the-most-intuitive",
                "content": "O(nlogn): The idea is simple, take a multiset and store all the values of A. Then perform binary search to find element just greater than B[i]. If one such element is found, remove this from the multiset, and continue. \\nAfter that, there will be some positions in B for which we were unable to find any greater element, so add the remaining values of the multiset into the result. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset <int> aset; \\n        for(auto x:A) aset.insert(x); \\n        int n = B.size(); \\n        vector<int> out(n, -1);\\n        for(int i=0; i <n ; i++){\\n            auto it = aset.upper_bound(B[i]); \\n            if(it!= aset.end()) out[i] = (*it), aset.erase(it); \\n        }\\n        for(int i=0; i <n ; i++){\\n            if(out[i] == -1) out[i] = *(aset.cbegin()), aset.erase(aset.cbegin()); \\n        }\\n        return out ; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset <int> aset; \\n        for(auto x:A) aset.insert(x); \\n        int n = B.size(); \\n        vector<int> out(n, -1);\\n        for(int i=0; i <n ; i++){\\n            auto it = aset.upper_bound(B[i]); \\n            if(it!= aset.end()) out[i] = (*it), aset.erase(it); \\n        }\\n        for(int i=0; i <n ; i++){\\n            if(out[i] == -1) out[i] = *(aset.cbegin()), aset.erase(aset.cbegin()); \\n        }\\n        return out ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130646,
                "title": "java-treemap-bst-o-n-log-n",
                "content": "**idea**\\n\\n* For each B[i], it is advantageous to pick the smallest number from A that is higher than B[i].\\n* If such number does not exist, we just pick the lowest number from A.\\n\\nWe can use `TreeSet` to make those queries efficient.\\n\\n**code**\\n\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length;\\n        int m = B.length;\\n        if (n != m) {\\n            throw new IllegalArgumentException(\"the inputs have different lengths.\");\\n        }\\n        \\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int num : A) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Integer cur = counts.higherKey(B[i]);\\n            if (cur == null) {\\n                cur = counts.firstKey();\\n            }\\n            \\n            ans[i] = cur;\\n            \\n            if (counts.get(cur) == 1) {\\n                counts.remove(cur);\\n            } else {\\n                counts.put(cur, counts.get(cur) - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**analysis**\\n\\nLet N = |A|\\n\\n* Time complexity: ~O(NlogN)\\n* Space complexity: ~O(N)",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Ordered Set"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length;\\n        int m = B.length;\\n        if (n != m) {\\n            throw new IllegalArgumentException(\"the inputs have different lengths.\");\\n        }\\n        \\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int num : A) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Integer cur = counts.higherKey(B[i]);\\n            if (cur == null) {\\n                cur = counts.firstKey();\\n            }\\n            \\n            ans[i] = cur;\\n            \\n            if (counts.get(cur) == 1) {\\n                counts.remove(cur);\\n            } else {\\n                counts.put(cur, counts.get(cur) - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126215,
                "title": "c-heap-based-in-place-solution-explained-99-time-65-space",
                "content": "This was a fun one to solve; I went to use 2 `priotity_queues`; maybe thee is an even better way, but it performed rather well for me.\\n\\nFirst of all I declared an external constant variable `lmt` to store the upperbound of our input, which will also double as our increment later on.\\n\\nInside the main function, we are going to declare a few support variables:\\n* `len` will store the length of our input vectors (guaranteed to be always the same);\\n* `curr` is where we will store the current top of the heap;\\n* `qa` is going to be a `priority_queue` of values from `a`, in increasing order;\\n* `qa` is going to be a `priority_queue` of pairs of values from `b` and their matching index, in increasing order.\\n\\nWe will first of all go to populate `qa` and `qb` and mentioned above.\\n\\nWe will then have a man loop where we will:\\n* assign the smallest element in `qa` to `curr`;\\n* if `curr` is bigger than the `qb.top().first` (ie: we have an advantage) or `curr >= lmt` (ie: it is an element we already saw and sent to the bottom), we will:\\n\\t* if we come from an already seen value, then we will subtract `lmt` from it again;\\n\\t* we will update `a` to be `curr` at the index stored in `qb.top().second`;\\n\\t* finally, we will pop from both `qa` and `qb`;\\n* otherwise we will:\\n\\t* increase `curr` by `lmt` (to mark it as already seen);\\n\\t* pop its previous value from `qa`,\\n\\t* add it back into `qa` (where it will go at the bottom).\\n\\nOnce done, we can return `a`.\\n\\nThe code:\\n\\n```cpp\\nusing qpair = pair<int, int>;\\n\\nstatic constexpr int lmt = 1e9;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // qa is a good fit\\n            if (curr > qb.top().first || curr >= lmt) {\\n                // restoring curr if it was sent to the end of the heap\\n                if (curr >= lmt) curr -= lmt;\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to the back;\\n            else {\\n                curr += lmt;\\n                qa.pop();\\n                qa.push(curr);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\\n\\nAlternative version without the incrementing/decrementing trick, just storing the non fitting values in another `priority_queue`, apparently with little to no gain in performance:\\n\\n```cpp\\nusing qpair = pair<int, int>;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa, leftovers;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // curr is a good fit\\n            if (curr > qb.top().first) {\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to leftovers;\\n            else {\\n                leftovers.push(curr);\\n                qa.pop();\\n            }\\n        }\\n        // assigning the leftovers\\n        while (leftovers.size()) {\\n            curr = leftovers.top();\\n            // updating a\\n            a[qb.top().second] = curr;\\n            // moving on with leftovers and qb\\n            leftovers.pop(), qb.pop();\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nusing qpair = pair<int, int>;\\n\\nstatic constexpr int lmt = 1e9;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // qa is a good fit\\n            if (curr > qb.top().first || curr >= lmt) {\\n                // restoring curr if it was sent to the end of the heap\\n                if (curr >= lmt) curr -= lmt;\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to the back;\\n            else {\\n                curr += lmt;\\n                qa.pop();\\n                qa.push(curr);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\n```cpp\\nusing qpair = pair<int, int>;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa, leftovers;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // curr is a good fit\\n            if (curr > qb.top().first) {\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to leftovers;\\n            else {\\n                leftovers.push(curr);\\n                qa.pop();\\n            }\\n        }\\n        // assigning the leftovers\\n        while (leftovers.size()) {\\n            curr = leftovers.top();\\n            // updating a\\n            a[qb.top().second] = curr;\\n            // moving on with leftovers and qb\\n            leftovers.pop(), qb.pop();\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125788,
                "title": "java-simple-concise-solution-using-sorting-faster-than-99",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n=A.length;\\n        \\n        Integer t[]=new Integer[n];\\n        \\n        for(int i=0;i<n;i++)\\n            t[i]=i;\\n        int ans[]= new int[n];\\n        \\n        Arrays.sort(t,(i,j) -> B[i]-B[j]);\\n        Arrays.sort(A);\\n        int min=0;\\n        int max=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int ind=t[i];\\n            if(B[ind]<A[max])\\n                ans[ind]=A[max--];\\n            else\\n                 ans[ind]=A[min++];\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n=A.length;\\n        \\n        Integer t[]=new Integer[n];\\n        \\n        for(int i=0;i<n;i++)\\n            t[i]=i;\\n        int ans[]= new int[n];\\n        \\n        Arrays.sort(t,(i,j) -> B[i]-B[j]);\\n        Arrays.sort(A);\\n        int min=0;\\n        int max=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int ind=t[i];\\n            if(B[ind]<A[max])\\n                ans[ind]=A[max--];\\n            else\\n                 ans[ind]=A[min++];\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125545,
                "title": "c-pure-stl-readable-and-easy-comments",
                "content": "Simple use of STL\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(A.begin(),A.end());  // Upper bound works on sorted arrays\\n\\tvector<int> ans;\\n\\tfor(auto i: B)\\n\\t{\\n\\t\\tauto ele = upper_bound(A.begin(),A.end(),i);  // Get the first element strictly greater than i\\n\\t\\tif(ele==A.end())   // If no element is greater than i, then use the least useful element in A, i.e, the smallest one \\n\\t\\t\\tele = min_element(A.begin(),A.end());\\n\\t\\tans.push_back(*ele);\\n\\t\\tA.erase(ele); // Remove it from A\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(A.begin(),A.end());  // Upper bound works on sorted arrays\\n\\tvector<int> ans;\\n\\tfor(auto i: B)\\n\\t{\\n\\t\\tauto ele = upper_bound(A.begin(),A.end(),i);  // Get the first element strictly greater than i\\n\\t\\tif(ele==A.end())   // If no element is greater than i, then use the least useful element in A, i.e, the smallest one \\n\\t\\t\\tele = min_element(A.begin(),A.end());\\n\\t\\tans.push_back(*ele);\\n\\t\\tA.erase(ele); // Remove it from A\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125511,
                "title": "greedy-two-pointers-sorting-java",
                "content": "**GOAL + Approch:**\\n* we have to maximize Advantage . i.e rearrange array A such that number of idx following this property A[i]>B[i] is maximum.\\n* we will approch greedly try the maximum value of A on maximum value of B. if maximum of A is greater than maximum of B. will put that maximum at that index. \\n* if maximum value of A is less than maximum value of B .If we put the maximum of A here it is a loos. because its not contributing to advantage so better to put minimum value of A here and use the maximum next time maybe its greater than that and contribute to advantage.\\n\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result=new int[A.length];\\n      \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int i=0;i<B.length;i++){\\n            int val=B[i];\\n            Pair np=new Pair(val,i);\\n            pq.add(np);\\n        }\\n        \\n        Arrays.sort(A);\\n        \\n        int end=A.length-1;\\n        int start=0;\\n        while(start<=end){\\n           Pair top=pq.remove();\\n            \\n           int idx=top.idx;\\n           int val=top.val;\\n            \\n           int max=A[end];\\n           int min=A[start];\\n            \\n           if(max>val){\\n               result[idx]=max;\\n               end--;\\n           }else{\\n               result[idx]=min;\\n               start++;\\n           }\\n        }\\n        return result;\\n    }\\n    \\n    public class Pair implements Comparable<Pair>{\\n        int idx;\\n        int val;\\n        \\n        Pair(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            return other.val-this.val;\\n        }\\n    }\\n}\\n```\\n\\n**Complexity : O(nlogn) and Space:O(n)**\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result=new int[A.length];\\n      \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int i=0;i<B.length;i++){\\n            int val=B[i];\\n            Pair np=new Pair(val,i);\\n            pq.add(np);\\n        }\\n        \\n        Arrays.sort(A);\\n        \\n        int end=A.length-1;\\n        int start=0;\\n        while(start<=end){\\n           Pair top=pq.remove();\\n            \\n           int idx=top.idx;\\n           int val=top.val;\\n            \\n           int max=A[end];\\n           int min=A[start];\\n            \\n           if(max>val){\\n               result[idx]=max;\\n               end--;\\n           }else{\\n               result[idx]=min;\\n               start++;\\n           }\\n        }\\n        return result;\\n    }\\n    \\n    public class Pair implements Comparable<Pair>{\\n        int idx;\\n        int val;\\n        \\n        Pair(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            return other.val-this.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125301,
                "title": "python-o-n-lg-n-by-horse-racing-strategy-w-hint",
                "content": "**Hint**:\\n\\nLike the mutli-round horse racing strategy between A and B\\n\\nWhat we want is the **best match sequence** for A to win B as much as possible\\n\\nKeep A in sorted order, and make a heap for B.\\n\\nFor each round:\\n\\nIf current largest element of A is larger than current largest element of B, \\nthen pick current largest element of A as best shuffle against B\\n[ use **best of A** to **win best of B** ]\\n\\nOtherwise, pick current smallest of A as best shuffle against B.\\n[ use **worst of A** to **comsume best of B** ]\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/7fbd9bef-84e3-41ff-963d-e467c87066c4_1616584312.1154692.png)\\n[Source: Alge Timing](https://alge-timing.com/AlgeTiming_V2/en/horse-racing.html)\\n---\\n\\n**Implementation**\\n\\n```\\n\\n\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        \\n        # array size\\n        size = len(A)\\n        \\n        # best advantage shuffle of A\\n        best_shuffle = [ 0 for _ in range(size) ]\\n        \\n        \\n        # two pointers for A and best shuffle\\n        left, right = 0, size-1\\n        \\n        \\n        # B_tuple\\n        # first item: negative value of b\\n        # second item: index of b\\n        B_tuple = [ (-b, idx) for idx, b in enumerate(B) ]\\n        \\n        \\n        # build a min heap from B_tuple\\n        # larger elements will be on the top naturally (because what we record in tuple is -b, negative value )\\n        heapq.heapify(B_tuple)\\n        \\n        \\n        # find best shuffle of A against B from largest value\\n        \\n        while B_tuple:\\n            \\n            \\n            largest_b_value, largest_b_idx = heapq.heappop(B_tuple)\\n        \\n            if A[right] > abs(largest_b_value):\\n                \\n                # largest of A is bigger than largest of B\\n                # pick A\\'s largest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[right]\\n                right -= 1\\n                \\n            else:\\n                \\n                # largest of A is smaller than or equal to B\\n                # no chance to win, pick A\\'s smallest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[left]\\n                left += 1\\n                \\n                \\n        return best_shuffle\\n```\\n\\n---\\n\\nReferecne:\\n\\n[1] [Python offficial docs about heap](https://docs.python.org/3/library/heapq.html)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Two Pointers",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        \\n        # array size\\n        size = len(A)\\n        \\n        # best advantage shuffle of A\\n        best_shuffle = [ 0 for _ in range(size) ]\\n        \\n        \\n        # two pointers for A and best shuffle\\n        left, right = 0, size-1\\n        \\n        \\n        # B_tuple\\n        # first item: negative value of b\\n        # second item: index of b\\n        B_tuple = [ (-b, idx) for idx, b in enumerate(B) ]\\n        \\n        \\n        # build a min heap from B_tuple\\n        # larger elements will be on the top naturally (because what we record in tuple is -b, negative value )\\n        heapq.heapify(B_tuple)\\n        \\n        \\n        # find best shuffle of A against B from largest value\\n        \\n        while B_tuple:\\n            \\n            \\n            largest_b_value, largest_b_idx = heapq.heappop(B_tuple)\\n        \\n            if A[right] > abs(largest_b_value):\\n                \\n                # largest of A is bigger than largest of B\\n                # pick A\\'s largest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[right]\\n                right -= 1\\n                \\n            else:\\n                \\n                # largest of A is smaller than or equal to B\\n                # no chance to win, pick A\\'s smallest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[left]\\n                left += 1\\n                \\n                \\n        return best_shuffle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125290,
                "title": "java-maxheap",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> maxHeap = new  PriorityQueue<int[]>((a,b)-> (b[1]  -a[1]));\\n        int shuffledArray[] = new int[A.length];\\n        for(int i=0; i<B.length; i++){\\n            maxHeap.offer(new int[]{i, B[i]});\\n        }\\n        \\n        int low= 0 ;\\n        int high = A.length-1;\\n        while(!maxHeap.isEmpty()){\\n            int top[] = maxHeap.poll();\\n            int maximum =  top[1];\\n            int index =  top[0];\\n            if(A[high] > maximum){\\n                shuffledArray[index] = A[high];\\n                high-=1;\\n            }else {\\n                shuffledArray[index] = A[low];\\n                low++;\\n            }\\n        }\\n        \\n        return shuffledArray;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> maxHeap = new  PriorityQueue<int[]>((a,b)-> (b[1]  -a[1]));\\n        int shuffledArray[] = new int[A.length];\\n        for(int i=0; i<B.length; i++){\\n            maxHeap.offer(new int[]{i, B[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1125260,
                "title": "runtime-beats-94-37-of-cpp-submissions-2-pointer-approach-greedy-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        //this will store value and index of the arry B\\n        int sz=A.size();\\n        vector<pair<int,int>> vi(sz);\\n        for(int i=0;i<B.size();i++)\\n        {\\n            vi[i]=make_pair(B[i],i);\\n        }\\n        sort(vi.begin(),vi.end(),greater<pair<int,int>>());\\n        sort(A.begin(),A.end(),greater<int>());\\n        int li=0,ri=sz-1;\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(vi[i].first<A[li])\\n            {\\n                B[vi[i].second]=A[li];\\n                li++;\\n            }\\n            else\\n            {\\n                B[vi[i].second]=A[ri];\\n                ri--;\\n            }\\n        }\\n        return B;\\n    }\\n};\\n```\\n**If You Like It! Please Upvote**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        //this will store value and index of the arry B\\n        int sz=A.size();\\n        vector<pair<int,int>> vi(sz);\\n        for(int i=0;i<B.size();i++)\\n        {\\n            vi[i]=make_pair(B[i],i);\\n        }\\n        sort(vi.begin(),vi.end(),greater<pair<int,int>>());\\n        sort(A.begin(),A.end(),greater<int>());\\n        int li=0,ri=sz-1;\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(vi[i].first<A[li])\\n            {\\n                B[vi[i].second]=A[li];\\n                li++;\\n            }\\n            else\\n            {\\n                B[vi[i].second]=A[ri];\\n                ri--;\\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125171,
                "title": "c-greedy",
                "content": "```\\npublic class Solution {\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        Array.Sort(A);\\n        // deep copy of B\\n        var bCopy = (int[])B.Clone();\\n        Array.Sort(B);\\n        int idx = 0;    \\n        int ALength = A.Length; \\n        int[] sortedResult = new int[ALength];        \\n        \\n        // Greedy approach to get the hand that beats a sorted B. First find the numbers in sorted A that beat numbers in sorted B.\\n        // In the second for we fill the remaining positions with the number in A that won\\'t beat numbers in B\\n        for (int i = 0; i < ALength; i++)\\n        {\\n            if (A[i] > B[idx])\\n            {\\n                sortedResult[idx] = A[i];\\n                A[i] = -1;\\n                idx++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < ALength; i++)\\n        {\\n            if (A[i] != -1)\\n            {\\n                sortedResult[idx] = A[i];\\n                idx++;\\n            }\\n        }\\n        \\n        // Go through B and find the original positions of numbers (using the deep copy) so that we can re-arrage A\\n        for (int i = 0; i < ALength; i++)\\n        {\\n            // find the original index of B[i] in bCopy\\n            int index = Array.IndexOf(bCopy, B[i]);\\n            // make sure next time we look in B we don\\'t pick the same position\\n            bCopy[index] = -1;\\n            // put the number in A\\n            A[index] = sortedResult[i];\\n        }\\n        \\n        return A;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        Array.Sort(A);\\n        // deep copy of B\\n        var bCopy = (int[])B.Clone();\\n        Array.Sort(B);\\n        int idx = 0;    \\n        int ALength = A.Length; \\n        int[] sortedResult = new int[ALength];        \\n        \\n        // Greedy approach to get the hand that beats a sorted B. First find the numbers in sorted A that beat numbers in sorted B.\\n        // In the second for we fill the remaining positions with the number in A that won\\'t beat numbers in B\\n        for (int i = 0; i < ALength; i++)\\n        {\\n            if (A[i] > B[idx])\\n            {\\n                sortedResult[idx] = A[i];\\n                A[i] = -1;\\n                idx++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 683730,
                "title": "python-dictionary-sort-time-93-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        result = []\\n        counter = defaultdict(list)\\n        for idx in sorted(B, reverse=True):\\n            if A[-1] > idx: \\n                counter[idx].append(A.pop())\\n        for idx in B:\\n            if counter[idx]:\\n                result.append(counter[idx].pop())\\n            else:\\n                result.append(A.pop())\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        result = []\\n        counter = defaultdict(list)\\n        for idx in sorted(B, reverse=True):\\n            if A[-1] > idx: \\n                counter[idx].append(A.pop())\\n        for idx in B:\\n            if counter[idx]:\\n                result.append(counter[idx].pop())\\n            else:\\n                result.append(A.pop())\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642921,
                "title": "easy-understanding-python-solution",
                "content": "Concept: what is the point to pair a (a from A) to b (b from B) if a<b? So lets sort both from top to bottom and if a<b , pair the smallest avilable a to b.\\n\\n```\\nout=[0]*len(A)\\n\\nB=[[B[i],i] for i in range(len(B))]\\nB=sorted(B,reverse=True)\\nA=sorted(A,reverse=True)\\nfor i in range(len(B)):\\n\\tif A[0]>B[i][0]:\\n\\t\\tout[B[i][1]]=A.pop(0)\\n\\n\\telse:\\n\\t\\tout[B[i][1]]=A.pop()\\nreturn out\\n\\n```",
                "solutionTags": [],
                "code": "```\\nout=[0]*len(A)\\n\\nB=[[B[i],i] for i in range(len(B))]\\nB=sorted(B,reverse=True)\\nA=sorted(A,reverse=True)\\nfor i in range(len(B)):\\n\\tif A[0]>B[i][0]:\\n\\t\\tout[B[i][1]]=A.pop(0)\\n\\n\\telse:\\n\\t\\tout[B[i][1]]=A.pop()\\nreturn out\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548111,
                "title": "python-binary-search",
                "content": "```Python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A.sort()\\n        res = []\\n        for i in B:\\n            index = bisect.bisect(A, i)\\n            if index == len(A):\\n                res.append(A.pop(0))\\n            else:\\n                res.append(A.pop(index))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A.sort()\\n        res = []\\n        for i in B:\\n            index = bisect.bisect(A, i)\\n            if index == len(A):\\n                res.append(A.pop(0))\\n            else:\\n                res.append(A.pop(index))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452567,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int[] AdvantageCount(int[] A, int[] B) \\n    {\\n        List<int> result = new List<int>(), list = new List<int>(A);\\n        list.Sort();\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            var index = list.BinarySearch(B[i] + 1);\\n            if(index < 0) index = ~index;\\n            if(index == list.Count) index = 0;\\n            result.Add(list[index]);\\n            list.RemoveAt(index);\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[] AdvantageCount(int[] A, int[] B) \\n    {\\n        List<int> result = new List<int>(), list = new List<int>(A);\\n        list.Sort();\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            var index = list.BinarySearch(B[i] + 1);\\n            if(index < 0) index = ~index;\\n            if(index == list.Count) index = 0;\\n            result.Add(list[index]);\\n            list.RemoveAt(index);\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287666,
                "title": "java-greedy-with-treemap-o-nlogn-slower-but-easier",
                "content": "First of all , build up a treemap from numbers in A  , and record the qty\\n\\nSecondly , loop the number in B one by one to build up the result array from getting the ceilingKey in the treemap\\n\\ntwo cases here:\\n1.if we can find such ceiling key , then use it and deduct  qty or remove it from the treemap when qty becomes 0\\n\\n2.if we can\\'t find such a key, then use the smallest key of the treemap , also deduct the qty or remove it when it\\'s qty becomes 0\\n\\nThe time complexity of building a treemap is o(logn)\\nThe time complexity of looking up ceiling key is also o(logn) while we lookup the ceiling key in a loop which complexity is o(n) , so the final time complexity is o(nlogn)\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        for(int num: A){\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        \\n        int[] result = new int[B.length];\\n        \\n        for(int i = 0;i<result.length;i++){\\n            \\n            Integer nextKey =map.ceilingKey(B[i]+1);\\n            \\n            if(null!=nextKey){\\n              result[i]=nextKey;   \\n            }else{\\n              result[i]=map.firstKey();\\n            }\\n            \\n            if(map.get(result[i])==1){\\n                map.remove(result[i]);\\n               }else{\\n                map.put(result[i],map.get(result[i])-1);    \\n              }  \\n                        \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        for(int num: A){\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        \\n        int[] result = new int[B.length];\\n        \\n        for(int i = 0;i<result.length;i++){\\n            \\n            Integer nextKey =map.ceilingKey(B[i]+1);\\n            \\n            if(null!=nextKey){\\n              result[i]=nextKey;   \\n            }else{\\n              result[i]=map.firstKey();\\n            }\\n            \\n            if(map.get(result[i])==1){\\n                map.remove(result[i]);\\n               }else{\\n                map.put(result[i],map.get(result[i])-1);    \\n              }  \\n                        \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153787,
                "title": "c-greedy-beats-96-easy-to-remember-and-impl-in-7mins",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n#include <utility>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\n        vector<pair<int, int>> pairs(n);\\n        for (int i = 0; i < n; ++i) {\\n            pairs[i] = make_pair(B[i], i);\\n        }\\n\\n        sort(A.begin(), A.end());\\n        sort(pairs.begin(), pairs.end());\\n\\n        vector<int> remain;\\n        vector<bool> used(n, false);\\n        vector<int> res(n);\\n\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] <= pairs[j].first) {\\n                remain.push_back(A[i]);\\n            } else {\\n                res[pairs[j].second] = A[i];\\n                used[pairs[j].second] = true;\\n                ++j;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!used[i]) {\\n                res[i] = remain.back();\\n                remain.pop_back();\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n#include <utility>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\n        vector<pair<int, int>> pairs(n);\\n        for (int i = 0; i < n; ++i) {\\n            pairs[i] = make_pair(B[i], i);\\n        }\\n\\n        sort(A.begin(), A.end());\\n        sort(pairs.begin(), pairs.end());\\n\\n        vector<int> remain;\\n        vector<bool> used(n, false);\\n        vector<int> res(n);\\n\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] <= pairs[j].first) {\\n                remain.push_back(A[i]);\\n            } else {\\n                res[pairs[j].second] = A[i];\\n                used[pairs[j].second] = true;\\n                ++j;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!used[i]) {\\n                res[i] = remain.back();\\n                remain.pop_back();\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 152705,
                "title": "c-greedy-multiset-7-line",
                "content": "```\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(A.begin(), A.end());\\n        for(int i=0;i<A.size();i++){\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    } ```",
                "solutionTags": [],
                "code": "```\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(A.begin(), A.end());\\n        for(int i=0;i<A.size();i++){\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    } ```",
                "codeTag": "Unknown"
            },
            {
                "id": 151908,
                "title": "nlogn-time-on-space-c",
                "content": " public int[] AdvantageCount(int[] A, int[] B) {\\n        if(A.Length <=1)\\n            return A;\\n        \\n        int[] sortedB = new int[B.Length];\\n        Array.Copy(B,sortedB,B.Length);\\n        Array.Sort(sortedB);\\n        Array.Sort(A);\\n        \\n        Dictionary<int,List<int>> dics = new Dictionary<int,List<int>>();\\n        int i = 0, j= 0, endA = A.Length -1, endB = B.Length -1;\\n     \\n        while(i<= endA && j <= endB)\\n        {\\n            if(A[i] > sortedB[j])\\n            {\\n                if (dics.ContainsKey(sortedB[j]))\\n                    dics[sortedB[j]].Add(A[i]);\\n                else\\n                    dics[sortedB[j]] = new List<int>{A[i]};\\n                \\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                 if (dics.ContainsKey(sortedB[endB]))\\n                    dics[sortedB[endB]].Add(A[i]);\\n                else\\n                    dics[sortedB[endB]] =  new List<int>{A[i]};\\n                \\n                endB--;\\n                i++;\\n                \\n            }\\n        }\\n        \\n       for(int k = 0; k < B.Length; k++)\\n       {\\n           A[k] = dics[B[k]].First();\\n           dics[B[k]].Remove(A[k]);\\n       }\\n        \\n        \\n        return A;\\n        \\n    }",
                "solutionTags": [],
                "code": " public int[] AdvantageCount(int[] A, int[] B) {\\n        if(A.Length <=1)\\n            return A;\\n        \\n        int[] sortedB = new int[B.Length];\\n        Array.Copy(B,sortedB,B.Length);\\n        Array.Sort(sortedB);\\n        Array.Sort(A);\\n        \\n        Dictionary<int,List<int>> dics = new Dictionary<int,List<int>>();\\n        int i = 0, j= 0, endA = A.Length -1, endB = B.Length -1;\\n     \\n        while(i<= endA && j <= endB)\\n        {\\n            if(A[i] > sortedB[j])\\n            {\\n                if (dics.ContainsKey(sortedB[j]))\\n                    dics[sortedB[j]].Add(A[i]);\\n                else\\n                    dics[sortedB[j]] = new List<int>{A[i]};\\n                \\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                 if (dics.ContainsKey(sortedB[endB]))\\n                    dics[sortedB[endB]].Add(A[i]);\\n                else\\n                    dics[sortedB[endB]] =  new List<int>{A[i]};\\n                \\n                endB--;\\n                i++;\\n                \\n            }\\n        }\\n        \\n       for(int k = 0; k < B.Length; k++)\\n       {\\n           A[k] = dics[B[k]].First();\\n           dics[B[k]].Remove(A[k]);\\n       }\\n        \\n        \\n        return A;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 151081,
                "title": "java-greedy-treeset-hashmap",
                "content": "TreeSet to be used to get higer or lowest.\\nHashMap is used as counter. Once run out, remove value from TreeSet.\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeSet<Integer> values=new TreeSet<>();\\n        Map<Integer,Integer> counts=new HashMap<>();\\n        for (int value:A) {\\n            int count=counts.getOrDefault(value,0);\\n            if (count==0) {\\n                values.add(value);                \\n            }\\n            counts.put(value,count+1);\\n        }\\n        int len=A.length;\\n        int[] dest=new int[len];\\n        for (int i=0;i<len;i++) {\\n            int value=B[i];\\n            Integer k=values.higher(value);\\n            if (k==null) {\\n                k=values.first();\\n            }\\n            dest[i]=k;\\n            int count=counts.get(k)-1;\\n            counts.put(k,count);\\n            if (count==0) {\\n                values.remove(k);                \\n            }\\n        }\\n        return dest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeSet<Integer> values=new TreeSet<>();\\n        Map<Integer,Integer> counts=new HashMap<>();\\n        for (int value:A) {\\n            int count=counts.getOrDefault(value,0);\\n            if (count==0) {\\n                values.add(value);                \\n            }\\n            counts.put(value,count+1);\\n        }\\n        int len=A.length;\\n        int[] dest=new int[len];\\n        for (int i=0;i<len;i++) {\\n            int value=B[i];\\n            Integer k=values.higher(value);\\n            if (k==null) {\\n                k=values.first();\\n            }\\n            dest[i]=k;\\n            int count=counts.get(k)-1;\\n            counts.put(k,count);\\n            if (count==0) {\\n                values.remove(k);                \\n            }\\n        }\\n        return dest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150380,
                "title": "python-greedy-solution-using-sort-and-min-heap-with-o-n-log-n-time",
                "content": "We don\\'t need to sort `A`. A min-heap from `A` will suffice.\\n\\n```\\n# Time complexity: O(N * log N)\\n# Space complexity: O(N)\\n# N = len(A) = len(B)\\n\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # Sort the tuples of (number, index) of \"B\" in an\\n        # non-decreasing order.\\n        B_with_index = [(b, i) for i, b in enumerate(B)]\\n        B_with_index.sort()\\n        \\n        # Create a min-heap from \"A\".\\n        lenA = len(A)\\n        res = [0] * lenA\\n        heapify(A)\\n        \\n        # For each number in the sorted \"B\", the optimal\\n        # advantage number of \"A\" is the minimum number in\\n        # \"A\" which is greater than the number of \"B\".\\n        unusedA = []\\n        for b, i in B_with_index:\\n            # If the min-heap is non-empty, keep popping\\n            # numbers of it until we see a number which is\\n            # bigger than the number in the sorted \"B\".\\n            while A:\\n                a = heappop(A)\\n                if a > b:\\n                    res[i] = a\\n                    break\\n                else:\\n                    # For those \"small\" numbers in \"A\", simply\\n                    # put them in the remaining positions after\\n                    # we put all the advantage numbers.\\n                    unusedA.append(a)\\n            if not A:\\n                break\\n        \\n        # Put the \"small\" numbers in the remaining positions.\\n        len_unusedA = len(unusedA)\\n        for j in range(lenA - len_unusedA, lenA):\\n            res[B_with_index[j][1]] = unusedA[j - (lenA - len_unusedA)]\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Time complexity: O(N * log N)\\n# Space complexity: O(N)\\n# N = len(A) = len(B)\\n\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # Sort the tuples of (number, index) of \"B\" in an\\n        # non-decreasing order.\\n        B_with_index = [(b, i) for i, b in enumerate(B)]\\n        B_with_index.sort()\\n        \\n        # Create a min-heap from \"A\".\\n        lenA = len(A)\\n        res = [0] * lenA\\n        heapify(A)\\n        \\n        # For each number in the sorted \"B\", the optimal\\n        # advantage number of \"A\" is the minimum number in\\n        # \"A\" which is greater than the number of \"B\".\\n        unusedA = []\\n        for b, i in B_with_index:\\n            # If the min-heap is non-empty, keep popping\\n            # numbers of it until we see a number which is\\n            # bigger than the number in the sorted \"B\".\\n            while A:\\n                a = heappop(A)\\n                if a > b:\\n                    res[i] = a\\n                    break\\n                else:\\n                    # For those \"small\" numbers in \"A\", simply\\n                    # put them in the remaining positions after\\n                    # we put all the advantage numbers.\\n                    unusedA.append(a)\\n            if not A:\\n                break\\n        \\n        # Put the \"small\" numbers in the remaining positions.\\n        len_unusedA = len(unusedA)\\n        for j in range(lenA - len_unusedA, lenA):\\n            res[B_with_index[j][1]] = unusedA[j - (lenA - len_unusedA)]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150176,
                "title": "easy-peasy-java-squeezy",
                "content": "```class Solution {\\n\\t\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\t\\tTreeMap<Integer,Integer> nums = new TreeMap<>();\\n\\n\\t\\t\\t\\tfor(int i : A) nums.put(i, nums.getOrDefault(i,0)+1);\\n\\n\\n\\t\\t\\t\\tfor (int i = 0; i < B.length; i++){\\n\\t\\t\\t\\t\\t\\tInteger advantage = nums.higherKey(B[i]);\\n\\t\\t\\t\\t\\t\\tif(advantage == null)\\n\\t\\t\\t\\t\\t\\t\\t\\tadvantage = nums.firstKey();\\n\\n\\t\\t\\t\\t\\t\\tA[i] = advantage;\\n\\n\\t\\t\\t\\t\\t\\tnums.put(advantage, nums.get(advantage)-1);\\n\\t\\t\\t\\t\\t\\tif(nums.get(advantage) == 0)\\n\\t\\t\\t\\t\\t\\t\\t\\tnums.remove(advantage);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn A;\\n\\t\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n\\t\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\t\\tTreeMap<Integer,Integer> nums = new TreeMap<>();\\n\\n\\t\\t\\t\\tfor(int i : A) nums.put(i, nums.getOrDefault(i,0)+1);\\n\\n\\n\\t\\t\\t\\tfor (int i = 0; i < B.length; i++){\\n\\t\\t\\t\\t\\t\\tInteger advantage = nums.higherKey(B[i]);\\n\\t\\t\\t\\t\\t\\tif(advantage == null)\\n\\t\\t\\t\\t\\t\\t\\t\\tadvantage = nums.firstKey();\\n\\n\\t\\t\\t\\t\\t\\tA[i] = advantage;\\n\\n\\t\\t\\t\\t\\t\\tnums.put(advantage, nums.get(advantage)-1);\\n\\t\\t\\t\\t\\t\\tif(nums.get(advantage) == 0)\\n\\t\\t\\t\\t\\t\\t\\t\\tnums.remove(advantage);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn A;\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149830,
                "title": "c-greedy-and-binary-search-o-nlogn-s-1",
                "content": "```\\n// greedy, O(nlogn), S(1)\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        std::sort(begin(A), end(A));\\n        \\n        for(auto i = 0 ; i < B.size() ; i++){\\n            \\n            const auto it = std::upper_bound(begin(A), end(A), B[i]);\\n            \\n            if(it != end(A)){\\n                \\n                B[i] = *it;\\n                A.erase(it);\\n                \\n            }else{\\n                \\n                B[i] = *A.begin();\\n                A.erase(A.begin());\\n            }\\n        }\\n        \\n        return B;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// greedy, O(nlogn), S(1)\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        std::sort(begin(A), end(A));\\n        \\n        for(auto i = 0 ; i < B.size() ; i++){\\n            \\n            const auto it = std::upper_bound(begin(A), end(A), B[i]);\\n            \\n            if(it != end(A)){\\n                \\n                B[i] = *it;\\n                A.erase(it);\\n                \\n            }else{\\n                \\n                B[i] = *A.begin();\\n                A.erase(A.begin());\\n            }\\n        }\\n        \\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611297,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo Pointers and sorting\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)->sorting\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums2.size();\\n        vector<int> res(n);\\n        sort(nums1.begin(),nums1.end());\\n        vector<pair<int,int>> p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({nums2[i],i});\\n        }\\n        sort(p.begin(),p.end());\\n\\n        int fp=0,lp=n-1;\\n        \\n        for(auto i:nums1){\\n            if(p[fp].first < i){\\n                res[p[fp++].second]=i;\\n            }\\n            else{\\n                res[p[lp--].second]=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums2.size();\\n        vector<int> res(n);\\n        sort(nums1.begin(),nums1.end());\\n        vector<pair<int,int>> p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({nums2[i],i});\\n        }\\n        sort(p.begin(),p.end());\\n\\n        int fp=0,lp=n-1;\\n        \\n        for(auto i:nums1){\\n            if(p[fp].first < i){\\n                res[p[fp++].second]=i;\\n            }\\n            else{\\n                res[p[lp--].second]=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405273,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) \\n    {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) \\n  {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) \\n    {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) \\n  {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350655,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037169,
                "title": "100-kotlin",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun advantageCount(nums1: IntArray, nums2: IntArray): IntArray {\\n        nums1.sort()\\n        \\n        val pairs2 = nums2.mapIndexed {i, n -> Pair(n, i)}.sortedByDescending {it.first}\\n        var left = 0\\n        var right = nums1.lastIndex \\n\\n        val res = IntArray(nums1.size)\\n\\n        for (p in pairs2) {\\n            if (nums1[right] > p.first) {\\n                res[p.second] = nums1[right--]\\n            } else {\\n                res[p.second] = nums1[left++]\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun advantageCount(nums1: IntArray, nums2: IntArray): IntArray {\\n        nums1.sort()\\n        \\n        val pairs2 = nums2.mapIndexed {i, n -> Pair(n, i)}.sortedByDescending {it.first}\\n        var left = 0\\n        var right = nums1.lastIndex \\n\\n        val res = IntArray(nums1.size)\\n\\n        for (p in pairs2) {\\n            if (nums1[right] > p.first) {\\n                res[p.second] = nums1[right--]\\n            } else {\\n                res[p.second] = nums1[left++]\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036588,
                "title": "sorting-two-pointers-approach-java-simple-solution-clean-code",
                "content": "# Intuition\\nLargest number of `nums1` should be assigned to largest number of `nums2` as long as it satisfies the condition.\\n\\n# Approach\\n- Sort both the arrays maintaining the indices of `nums2`\\n- Greedily assign the largest number of `nums1[i]` to largest number of `nums2[j]` such that `nums1[i] > nums2[j]` using two pointers approach.\\n- Assign the rest element randomly.\\n\\n# Complexity\\nLet $$n = nums1.length = nums2.length$$\\n- Time complexity: $$O(n * logn)$$\\n\\n- Space complexity: $$O(1)$$ (ignoring space used for answer)\\n\\n# Code\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        Arrays.sort(nums1);\\n        int mat[][] = new int[n][2];\\n        for(int i = 0;i < n;i++){\\n            mat[i][0] = i;\\n            mat[i][1] = nums2[i];\\n        }\\n        Arrays.sort(mat,(a,b) -> a[1] - b[1]);\\n        int i1 = n - 1;\\n        for(int i2 = n - 1;i1 >= 0 && i2 >= 0;){\\n            for(;i2 >= 0 && mat[i2][1] >= nums1[i1];) --i2;\\n            if(i2 >= 0){\\n                ans[mat[i2][0]] = nums1[i1];\\n                --i2;\\n                --i1;\\n            }\\n        }\\n        for(int i = 0;i < n && i1 >= 0;i++,i1--){\\n            for(;i < n && ans[i] != -1;) i++;\\n            ans[i] = nums1[i1];\\n        }\\n        if(i1 >= 0) ans[n - 1] = nums1[i1];\\n        return ans;\\n\\n    }\\n}\\n```\\n\\n# Upvote if you like \\uD83D\\uDC4D\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        Arrays.sort(nums1);\\n        int mat[][] = new int[n][2];\\n        for(int i = 0;i < n;i++){\\n            mat[i][0] = i;\\n            mat[i][1] = nums2[i];\\n        }\\n        Arrays.sort(mat,(a,b) -> a[1] - b[1]);\\n        int i1 = n - 1;\\n        for(int i2 = n - 1;i1 >= 0 && i2 >= 0;){\\n            for(;i2 >= 0 && mat[i2][1] >= nums1[i1];) --i2;\\n            if(i2 >= 0){\\n                ans[mat[i2][0]] = nums1[i1];\\n                --i2;\\n                --i1;\\n            }\\n        }\\n        for(int i = 0;i < n && i1 >= 0;i++,i1--){\\n            for(;i < n && ans[i] != -1;) i++;\\n            ans[i] = nums1[i1];\\n        }\\n        if(i1 >= 0) ans[n - 1] = nums1[i1];\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891124,
                "title": "brute-force-solution-in-python-tle",
                "content": "```py\\nclass Solution:\\n    from itertools import permutations\\n    def advantageCount(self, nums1, nums2):\\n        def calc_advantage(nums1, nums2):\\n            adv = 0\\n            for i in range(len(nums1)):\\n                if nums1[i] > nums2[i]:\\n                    adv += 1\\n            return adv\\n\\n        max_advantage = -1 \\n        \\n        for perm in permutations(nums1):\\n            adv = calc_advantage(perm, nums2)\\n            if adv > max_advantage:\\n                max_advantage = adv\\n                res = perm\\n        return res\\n```\\n\\nThe idea behind the brute force algorithm is as follows: Given the two integer arrays nums1 and nums2, we can enumerate all the permutations of nums1 and calculate the advantage of each permutation. Finally, we can choose the permutation with the maximum advantage as the answer.\\n\\nTime complexity: Since we need to enumerate all the permutations of nums1, the time complexity is O(n! * n), where n is the length of nums1 and nums2.\\n\\nSpace complexity: Since we need to store all the permutations of nums1, the space complexity is O(n!).\\n\\nThe drawback of this brute force algorithm is that when n becomes large, its running time becomes very long, so it is not an efficient solution. We need a more efficient algorithm to solve this problem.\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    from itertools import permutations\\n    def advantageCount(self, nums1, nums2):\\n        def calc_advantage(nums1, nums2):\\n            adv = 0\\n            for i in range(len(nums1)):\\n                if nums1[i] > nums2[i]:\\n                    adv += 1\\n            return adv\\n\\n        max_advantage = -1 \\n        \\n        for perm in permutations(nums1):\\n            adv = calc_advantage(perm, nums2)\\n            if adv > max_advantage:\\n                max_advantage = adv\\n                res = perm\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674815,
                "title": "advantage-shuffle",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Integer[] idx1 = new Integer[n];\\n        Integer[] idx2 = new Integer[n];\\n        for (int i = 0; i < n; ++i) {\\n            idx1[i] = i;\\n            idx2[i] = i;\\n        }\\n        Arrays.sort(idx1, (i, j) -> nums1[i] - nums1[j]);\\n        Arrays.sort(idx2, (i, j) -> nums2[i] - nums2[j]);\\n\\n        int[] res = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[idx1[i]] > nums2[idx2[left]]) {\\n                res[idx2[left]] = nums1[idx1[i]];\\n                ++left;\\n            } else {\\n                res[idx2[right]] = nums1[idx1[i]];\\n                --right;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Integer[] idx1 = new Integer[n];\\n        Integer[] idx2 = new Integer[n];\\n        for (int i = 0; i < n; ++i) {\\n            idx1[i] = i;\\n            idx2[i] = i;\\n        }\\n        Arrays.sort(idx1, (i, j) -> nums1[i] - nums1[j]);\\n        Arrays.sort(idx2, (i, j) -> nums2[i] - nums2[j]);\\n\\n        int[] res = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[idx1[i]] > nums2[idx2[left]]) {\\n                res[idx2[left]] = nums1[idx1[i]];\\n                ++left;\\n            } else {\\n                res[idx2[right]] = nums1[idx1[i]];\\n                --right;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618151,
                "title": "98-faster-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<nums2.size(); i++) v.push_back({nums2[i], i});\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        \\n        int s = 0, e = nums1.size() - 1;\\n        vector<int> ans(nums1.size());\\n        \\n        for(auto i : v) {\\n            ans[i.second] = nums1[e] <= i.first ? nums1[s++] : nums1[e--];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<nums2.size(); i++) v.push_back({nums2[i], i});\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        \\n        int s = 0, e = nums1.size() - 1;\\n        vector<int> ans(nums1.size());\\n        \\n        for(auto i : v) {\\n            ans[i.second] = nums1[e] <= i.first ? nums1[s++] : nums1[e--];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489018,
                "title": "c-easy-binary-search-solved-it-in-salesforce-interview",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        multiset<int> ms(nums1.begin(),nums1.end());\\n        for(int x : nums2) {\\n            auto it = ms.upper_bound(x);\\n            if(it==ms.end()) {\\n                ans.push_back(*ms.begin());\\n                ms.erase(ms.begin());\\n            }\\n            else {\\n                ans.push_back(*it);\\n                ms.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        multiset<int> ms(nums1.begin(),nums1.end());\\n        for(int x : nums2) {\\n            auto it = ms.upper_bound(x);\\n            if(it==ms.end()) {\\n                ans.push_back(*ms.begin());\\n                ms.erase(ms.begin());\\n            }\\n            else {\\n                ans.push_back(*it);\\n                ms.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342025,
                "title": "python-o-nlogn-tc-o-n-sc-greedy-sorting",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        \\n\\t\\tnums1.sort()\\n\\t\\t\\n        nums3 = []\\n        for i in range(len(nums2)):\\n            nums3.append((nums2[i], i))\\n\\t\\t\\t\\n        nums3.sort(key=lambda x : x[0])\\n        \\n        # greedily pick just larger nums2[i] and if that is not the case then pick smallest and assign to it\\n        for i in range(len(nums1)-1, -1, -1):\\n            if nums1[-1] > nums3[i][0]:\\n                nums2[nums3[i][1]] = nums1.pop()\\n            else:\\n                nums2[nums3[i][1]] = nums1.pop(0)\\n        \\n        return nums2\\n\\'\\'\\'\\nIf you get this then try Space Optimizing it ; )",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        \\n\\t\\tnums1.sort()\\n\\t\\t\\n        nums3 = []\\n        for i in range(len(nums2)):\\n            nums3.append((nums2[i], i))\\n\\t\\t\\t\\n        nums3.sort(key=lambda x : x[0])\\n        \\n        # greedily pick just larger nums2[i] and if that is not the case then pick smallest and assign to it\\n        for i in range(len(nums1)-1, -1, -1):\\n            if nums1[-1] > nums3[i][0]:\\n                nums2[nums3[i][1]] = nums1.pop()\\n            else:\\n                nums2[nums3[i][1]] = nums1.pop(0)\\n        \\n        return nums2\\n\\'\\'\\'\\nIf you get this then try Space Optimizing it ; )",
                "codeTag": "Java"
            },
            {
                "id": 2310057,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n1 = collections.deque(sorted(nums1, reverse = True))\\n        n2 = sorted([(num, idx) for idx, num in enumerate(nums2)], reverse = True)\\n        res = [0] * len(n1)\\n        for num, idx in n2:\\n            if num < n1[0]:\\n                res[idx] = n1.popleft()\\n            else:\\n                res[idx] = n1.pop()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n1 = collections.deque(sorted(nums1, reverse = True))\\n        n2 = sorted([(num, idx) for idx, num in enumerate(nums2)], reverse = True)\\n        res = [0] * len(n1)\\n        for num, idx in n2:\\n            if num < n1[0]:\\n                res[idx] = n1.popleft()\\n            else:\\n                res[idx] = n1.pop()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118480,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Multiset***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        multiset<int> s(nums1.begin(), nums1.end());\\n        \\n        for(int i = 0; i < n2; i++)\\n        {\\n            int val = nums2[i];\\n            \\n            auto it = s.upper_bound(val);\\n            \\n            if(it != s.end())\\n            {\\n                nums1[i] = *it;\\n                \\n                s.erase(it);\\n            }\\n            else\\n            {\\n                nums1[i] = -1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            if(nums1[i] == -1)\\n            {\\n                nums1[i] = *s.begin();\\n                \\n                s.erase(s.begin());\\n            }\\n        }\\n        \\n        return nums1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        multiset<int> s(nums1.begin(), nums1.end());\\n        \\n        for(int i = 0; i < n2; i++)\\n        {\\n            int val = nums2[i];\\n            \\n            auto it = s.upper_bound(val);\\n            \\n            if(it != s.end())\\n            {\\n                nums1[i] = *it;\\n                \\n                s.erase(it);\\n            }\\n            else\\n            {\\n                nums1[i] = -1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            if(nums1[i] == -1)\\n            {\\n                nums1[i] = *s.begin();\\n                \\n                s.erase(s.begin());\\n            }\\n        }\\n        \\n        return nums1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830993,
                "title": "python-very-easy-greedy-sorting-explained",
                "content": "**\\nFor every position we try to get a point or advantage\\nTo get a point lets say for 2 we have choices [3,10] the we should use 3 not 10 as we can get advantage from both of them but using less valuable item can be good in the long run .\\nTo do so we sort num1 and find the index with value just greater than item in nums2 : if no such index exists add the smallest we have\\n**\\n```\\nclass Solution:\\n    def binarySearch(self , arr , x):\\n        low = 0 \\n        high = len(arr)-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if arr[mid] <= x:low = mid + 1\\n            else: high = mid - 1\\n        return low\\n    \\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n        n = len(nums1)\\n        ans = []\\n        for i in nums2:\\n            idx = self.binarySearch(nums1 , i)\\n            if idx == n: idx = 0\\n            ans.append(nums1[idx])\\n            nums1.pop(idx)\\n            n-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def binarySearch(self , arr , x):\\n        low = 0 \\n        high = len(arr)-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if arr[mid] <= x:low = mid + 1\\n            else: high = mid - 1\\n        return low\\n    \\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n        n = len(nums1)\\n        ans = []\\n        for i in nums2:\\n            idx = self.binarySearch(nums1 , i)\\n            if idx == n: idx = 0\\n            ans.append(nums1[idx])\\n            nums1.pop(idx)\\n            n-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716092,
                "title": "tim-n-o-log-n-space-4-o-n-noob-solution",
                "content": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n\\tint n = nums1.size();\\n\\t\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq2;\\t\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tpq.push(nums1[i]);\\n\\t\\tpq2.push({nums2[i], i});\\n\\t}\\n\\n\\tvector<int> result(n, -1);\\n\\tstack<int> res;\\n\\twhile(!pq2.empty() && !pq.empty()){\\n\\t\\tint ele = pq2.top().first;\\n\\t\\tint idx = pq2.top().second;\\n\\t\\tpq2.pop();\\n\\n\\t\\twhile(!pq.empty() && pq.top() <= ele){\\n\\t\\t\\tres.push(pq.top());\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\n\\t\\tif(!pq.empty() && pq.top() > ele){\\n\\t\\t\\tresult[idx] = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\telse\\tbreak;\\n\\t}\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif(result[i] == -1){\\n\\t\\t\\tresult[i] = res.top();\\n\\t\\t\\tres.pop();\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n\\tint n = nums1.size();\\n\\t\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq2;\\t\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tpq.push(nums1[i]);\\n\\t\\tpq2.push({nums2[i], i});\\n\\t}\\n\\n\\tvector<int> result(n, -1);\\n\\tstack<int> res;\\n\\twhile(!pq2.empty() && !pq.empty()){\\n\\t\\tint ele = pq2.top().first;\\n\\t\\tint idx = pq2.top().second;\\n\\t\\tpq2.pop();\\n\\n\\t\\twhile(!pq.empty() && pq.top() <= ele){\\n\\t\\t\\tres.push(pq.top());\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\n\\t\\tif(!pq.empty() && pq.top() > ele){\\n\\t\\t\\tresult[idx] = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\telse\\tbreak;\\n\\t}\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif(result[i] == -1){\\n\\t\\t\\tresult[i] = res.top();\\n\\t\\t\\tres.pop();\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672786,
                "title": "java-easy-solution-greedy-sorting-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n       int temp1[]=nums1.clone();\\n       int temp2[]=nums2.clone();\\n       Arrays.sort(temp1);\\n       Arrays.sort(temp2);\\n       HashMap<Integer,Queue<Integer>> map=new HashMap<>();\\n       int j=0,k=nums2.length-1;\\n       for(int i=0;i<nums1.length;i++){\\n           \\n            \\n           \\n           if(temp1[i]>temp2[j])\\n           {\\n               \\n              if(!map.containsKey(temp2[j]))\\n                   map.put(temp2[j],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[j++]).add(temp1[i]);\\n           }\\n           else\\n           {\\n               if(!map.containsKey(temp2[k]))\\n                   map.put(temp2[k],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[k--]).add(temp1[i]);\\n           }\\n              \\n       }\\n      for(int i=0;i<nums2.length;i++)\\n          nums1[i]=map.get(nums2[i]).poll();\\n        \\n       return nums1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n       int temp1[]=nums1.clone();\\n       int temp2[]=nums2.clone();\\n       Arrays.sort(temp1);\\n       Arrays.sort(temp2);\\n       HashMap<Integer,Queue<Integer>> map=new HashMap<>();\\n       int j=0,k=nums2.length-1;\\n       for(int i=0;i<nums1.length;i++){\\n           \\n            \\n           \\n           if(temp1[i]>temp2[j])\\n           {\\n               \\n              if(!map.containsKey(temp2[j]))\\n                   map.put(temp2[j],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[j++]).add(temp1[i]);\\n           }\\n           else\\n           {\\n               if(!map.containsKey(temp2[k]))\\n                   map.put(temp2[k],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[k--]).add(temp1[i]);\\n           }\\n              \\n       }\\n      for(int i=0;i<nums2.length;i++)\\n          nums1[i]=map.get(nums2[i]).poll();\\n        \\n       return nums1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574167,
                "title": "c-short-code-using-multiset",
                "content": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        multiset<int> buffer;\\n        for(auto x : nums1){\\n            buffer.insert(x);\\n        }\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it = buffer.upper_bound(nums2[i]);\\n            if(it==buffer.end()){\\n                it = buffer.begin();\\n            }\\n            ans[i] = *it;\\n            buffer.erase(it);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        multiset<int> buffer;\\n        for(auto x : nums1){\\n            buffer.insert(x);\\n        }\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it = buffer.upper_bound(nums2[i]);\\n            if(it==buffer.end()){\\n                it = buffer.begin();\\n            }\\n            ans[i] = *it;\\n            buffer.erase(it);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1530696,
                "title": "o-n-log-n-sorting-monotonic-queue",
                "content": "Our goal, for each index `i` in `nums2`, is to (greedily) find the smallest value in `nums1` which exceeds `nums2[i]` (and thus yields us an advantage at position `i`). That is, we want to find the \\'next greater element\\' in `nums1` for each value in `nums2`.\\n\\nIf we cannot find such a value for index `i`, then we are free to assign to `nums1[i]` anything that remains unused after we finish iterating through the elements of `nums2`.\\n\\n**SORTED CASE: MONOTONIC QUEUE**\\nLet\\'s simplify our lives a bit by assuming that `nums1` and `nums2` are each sorted in ascending order. \\n\\nFor current value `nums2[i]`, we can iterate through the elements of `nums1` from the front (since they are in ascending order as well) until we arrive at the first element in `nums1` that exceeds `nums2[i]`; we assign this value to index `i` of the new shuffled array (as this greedily confers an advantage to us at index `i`). \\n\\nHowever, since the numbers of `nums2` are in ascending order, everything in `nums1` that didn\\'t exceed `nums2[i]` will not exceed anything later on in `nums2`, so we can safely \\'discard\\'/dequeue these values (more on this in a moment), i.e. we treat `nums1` as a monotonic queue.\\n\\nWhat happens if we cannot find anything in `nums1` that exceeds value `nums2[i]`? This occurs if and only if our queue `nums1` becomes empty during the above process of finding a next greater element in `nums1`. What do we assign to index `i` of our shuffled array in this case? Well, anything that has not been used already from `nums1` will work (since none of these values will confer any advantage ever). For this reason, anything we dequeue from our monotonic queue `nums1`, we shouldn\\'t _truly_ discard, but rather save off as a set of unsed elements, for filling any slots `i` where we cannot find an element in (sorted) `nums1` that exceeds `nums2[i]`.\\n\\n**UNSORTED CASE**\\nNow to handle the general case of when the arrays are unsorted, we note that the only thing we really care about above from the original ordering of `nums1` and `nums2` are the original indexes of elements from `nums2` (since we use these to determine where to assign a front element from our monotonic queue `nums1` in the new shuffled array).\\n\\nOf course, sorting elements, we lose this information about `nums2`; so before we do any sorting, we should save this information in a multi-valued hash map (for the situation that we have repeated numbers in `nums2`), and reference back to this when determining which index in our new shuffled array should be assigned the front value in the monotonic queue `nums1` (or an unused element).\\n\\n**CODE**\\n```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n = len(nums1)\\n        \\n        # STEP 1: For each value in nums2, store the list of indexes in the array the value appears at\\n        nums2_val_to_index = {v: [] for v in nums2}\\n        for i,v in enumerate(nums2):\\n            nums2_val_to_index[v].append(i)\\n\\n        # STEP 2: Sort nums1 and nums2\\n        nums1.sort()\\n        nums2.sort()\\n        \\n        # STEP 3: Treat nums1 as monotonic queue, in order to greedily find next greatest element in (sorted)\\n        # nums1 for each element in (sorted) nums2 \\n        unused = []\\n        new_arr = [0] * n\\n        for i, v in enumerate(nums2):\\n            while len(nums1) > 0 and nums1[0] <= v:\\n                unused.append(nums1.pop(0))\\n            # everything in nums1 is too small compared to nums2[i]; we are free to fill original index of nums2[i] in the \\n            # new shuffled array with whatever has been \\'discarded\\' from the queue\\n            if len(nums1) == 0:\\n                new_arr[nums2_val_to_index[v].pop(0)] = unused.pop(0)\\n            else:\\n                new_arr[nums2_val_to_index[v].pop(0)] = nums1.pop(0)\\n\\n        return new_arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n = len(nums1)\\n        \\n        # STEP 1: For each value in nums2, store the list of indexes in the array the value appears at\\n        nums2_val_to_index = {v: [] for v in nums2}\\n        for i,v in enumerate(nums2):\\n            nums2_val_to_index[v].append(i)\\n\\n        # STEP 2: Sort nums1 and nums2\\n        nums1.sort()\\n        nums2.sort()\\n        \\n        # STEP 3: Treat nums1 as monotonic queue, in order to greedily find next greatest element in (sorted)\\n        # nums1 for each element in (sorted) nums2 \\n        unused = []\\n        new_arr = [0] * n\\n        for i, v in enumerate(nums2):\\n            while len(nums1) > 0 and nums1[0] <= v:\\n                unused.append(nums1.pop(0))\\n            # everything in nums1 is too small compared to nums2[i]; we are free to fill original index of nums2[i] in the \\n            # new shuffled array with whatever has been \\'discarded\\' from the queue\\n            if len(nums1) == 0:\\n                new_arr[nums2_val_to_index[v].pop(0)] = unused.pop(0)\\n            else:\\n                new_arr[nums2_val_to_index[v].pop(0)] = nums1.pop(0)\\n\\n        return new_arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522671,
                "title": "easy-c-solution-map-binary-search-sorting-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(pair<int,int>&a,pair<int,int>&b) {\\n         return  a.first<b.first;\\n    }\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        map<int,int> mp;\\n        vector<pair<int,int>> px;\\n        for(int i=0; i<a.size(); i++) {\\n             px.push_back({b[i],i});\\n             mp[a[i]]++;\\n        }\\n        sort(px.begin(),px.end(),cmp);\\n        for(int i=0; i<px.size(); i++) {\\n             auto it=mp.upper_bound(px[i].first);\\n             if(it==mp.end()) {\\n                  for(pair<int,int> p : mp) {\\n                     for(int j=0; j<p.second; j++) a[px[i++].second]=p.first;\\n                  }\\n                  break;\\n             }\\n             a[px[i].second]=it->first;\\n             it->second--;\\n             if(it->second==0) mp.erase(it);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n1 4 10 11\\n2 7 11 15\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(pair<int,int>&a,pair<int,int>&b) {\\n         return  a.first<b.first;\\n    }\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        map<int,int> mp;\\n        vector<pair<int,int>> px;\\n        for(int i=0; i<a.size(); i++) {\\n             px.push_back({b[i],i});\\n             mp[a[i]]++;\\n        }\\n        sort(px.begin(),px.end(),cmp);\\n        for(int i=0; i<px.size(); i++) {\\n             auto it=mp.upper_bound(px[i].first);\\n             if(it==mp.end()) {\\n                  for(pair<int,int> p : mp) {\\n                     for(int j=0; j<p.second; j++) a[px[i++].second]=p.first;\\n                  }\\n                  break;\\n             }\\n             a[px[i].second]=it->first;\\n             it->second--;\\n             if(it->second==0) mp.erase(it);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n1 4 10 11\\n2 7 11 15\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448054,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        B = sorted([(ix, val) for ix, val in enumerate(B)], key=lambda x:x[1], reverse=True)\\n        answer = [0]*len(A)\\n        for (i, b) in B:\\n            if b < A[-1]:\\n                answer[i] = A.pop()\\n            else:\\n                answer[i] = A[0]\\n                A = A[1:]\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        B = sorted([(ix, val) for ix, val in enumerate(B)], key=lambda x:x[1], reverse=True)\\n        answer = [0]*len(A)\\n        for (i, b) in B:\\n            if b < A[-1]:\\n                answer[i] = A.pop()\\n            else:\\n                answer[i] = A[0]\\n                A = A[1:]\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417014,
                "title": "c-multiset-greedy-algorithm",
                "content": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n  multiset<int> store{begin(nums1), end(nums1)};\\n  for (int i = 0; i < nums2.size(); ++ i) {\\n\\tauto iter = store.upper_bound(nums2[i]);\\n\\tif (iter == store.end()) {\\n\\t  iter = store.begin();\\n\\t}\\n\\tnums1[i] = *iter;\\n\\tstore.erase(iter);\\n  }\\n  return nums1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n  multiset<int> store{begin(nums1), end(nums1)};\\n  for (int i = 0; i < nums2.size(); ++ i) {\\n\\tauto iter = store.upper_bound(nums2[i]);\\n\\tif (iter == store.end()) {\\n\\t  iter = store.begin();\\n\\t}\\n\\tnums1[i] = *iter;\\n\\tstore.erase(iter);\\n  }\\n  return nums1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367347,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        int n=nums1.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            pq.push({nums2[i],i});\\n        }\\n        vector<int>ans(n,-1);\\n        int i=0;\\n        vector<int>missing;\\n        while(i<nums1.size() && !pq.empty())\\n        {\\n            if(nums1[i]>pq.top().first)\\n            {\\n                ans[pq.top().second]=nums1[i];\\n                pq.pop();\\n                i++;\\n            }\\n            else\\n            {\\n                missing.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        int k=0;\\n        for(int a=0;a<ans.size();a++)\\n        {\\n            if(ans[a]==-1)\\n            {\\n                ans[a]=missing[k];\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        int n=nums1.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            pq.push({nums2[i],i});\\n        }\\n        vector<int>ans(n,-1);\\n        int i=0;\\n        vector<int>missing;\\n        while(i<nums1.size() && !pq.empty())\\n        {\\n            if(nums1[i]>pq.top().first)\\n            {\\n                ans[pq.top().second]=nums1[i];\\n                pq.pop();\\n                i++;\\n            }\\n            else\\n            {\\n                missing.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        int k=0;\\n        for(int a=0;a<ans.size();a++)\\n        {\\n            if(ans[a]==-1)\\n            {\\n                ans[a]=missing[k];\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350234,
                "title": "java-solution-using-priorityqueue-hashmap-and-stacks",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int temp2[]=new int[nums1.length]; // clone of nums2\\n        for(int i=0;i<nums2.length;i++)\\n            temp2[i]=nums2[i];\\n        Arrays.sort(temp2); // sorting the clone of nums2\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(); // priority queue to store the elements of nums1\\n        for(int i : nums1)\\n            pq.add(i);\\n        HashMap<Integer,Stack<Integer>> hm=new HashMap<>(); // hashmap to store the corresponding answer values\\n        Stack<Integer> helper=new Stack<>(); // stack to store the unmatched elements of nums1\\n        for(int i=0;i<temp2.length;i++)\\n        {\\n            if(pq.isEmpty())\\n                break;\\n            int p=pq.remove();\\n            if(p<=temp2[i])\\n            {\\n                i--;\\n               helper.push(p);\\n            }\\n            else\\n            {\\n                if(!hm.containsKey(temp2[i]))\\n                    hm.put(temp2[i],new Stack<Integer>());\\n                hm.get(temp2[i]).push(p);\\n            }\\n        }\\n        int ans[]=new int[nums2.length];\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(hm.containsKey(nums2[i]) && hm.get(nums2[i]).size()>0) // checking if there is mapping for current element\\n                ans[i]=hm.get(nums2[i]).pop();\\n            else\\n                ans[i]=helper.pop(); // the unmapped element is mapped with the unmapped nums1 elements\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int temp2[]=new int[nums1.length]; // clone of nums2\\n        for(int i=0;i<nums2.length;i++)\\n            temp2[i]=nums2[i];\\n        Arrays.sort(temp2); // sorting the clone of nums2\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(); // priority queue to store the elements of nums1\\n        for(int i : nums1)\\n            pq.add(i);\\n        HashMap<Integer,Stack<Integer>> hm=new HashMap<>(); // hashmap to store the corresponding answer values\\n        Stack<Integer> helper=new Stack<>(); // stack to store the unmatched elements of nums1\\n        for(int i=0;i<temp2.length;i++)\\n        {\\n            if(pq.isEmpty())\\n                break;\\n            int p=pq.remove();\\n            if(p<=temp2[i])\\n            {\\n                i--;\\n               helper.push(p);\\n            }\\n            else\\n            {\\n                if(!hm.containsKey(temp2[i]))\\n                    hm.put(temp2[i],new Stack<Integer>());\\n                hm.get(temp2[i]).push(p);\\n            }\\n        }\\n        int ans[]=new int[nums2.length];\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(hm.containsKey(nums2[i]) && hm.get(nums2[i]).size()>0) // checking if there is mapping for current element\\n                ans[i]=hm.get(nums2[i]).pop();\\n            else\\n                ans[i]=helper.pop(); // the unmapped element is mapped with the unmapped nums1 elements\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173832,
                "title": "c-greedy-two-pointers-easy-code",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i<n; i++){\\n            vec.push_back(make_pair(b[i], i));\\n        }\\n        sort(vec.begin(), vec.end(), greater<pair<int, int>>());\\n        \\n        sort(a.begin(), a.end(), greater<int>());\\n        \\n        int low = 0, high = n-1;\\n        for(int i = 0; i<n; i++){\\n            if(a[low] > vec[i].first){\\n                b[vec[i].second] = a[low];\\n                low++;\\n            }else{\\n                b[vec[i].second] = a[high];\\n                high--;\\n            }\\n        }\\n        return b;\\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i<n; i++){\\n            vec.push_back(make_pair(b[i], i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1129822,
                "title": "c-sorting-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<pair<int,int>> arrB;\\n        vector<int> unused, res(n, -1);\\n        for(int i = 0; i < n; i++) arrB.push_back(make_pair(B[i], i));\\n        sort(A.begin(), A.end());\\n        sort(arrB.begin(), arrB.end());\\n        int i = 0, j = 0;\\n        while(i < n && j < n) {\\n            if(A[i] > arrB[j].first) {res[arrB[j].second] = A[i];j++;}\\n            else unused.push_back(A[i]);\\n            i++;\\n        }\\n        j = 0;\\n        for(int i = 0; i < n; i++) if(res[i] == -1) res[i] = unused[j++];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<pair<int,int>> arrB;\\n        vector<int> unused, res(n, -1);\\n        for(int i = 0; i < n; i++) arrB.push_back(make_pair(B[i], i));\\n        sort(A.begin(), A.end());\\n        sort(arrB.begin(), arrB.end());\\n        int i = 0, j = 0;\\n        while(i < n && j < n) {\\n            if(A[i] > arrB[j].first) {res[arrB[j].second] = A[i];j++;}\\n            else unused.push_back(A[i]);\\n            i++;\\n        }\\n        j = 0;\\n        for(int i = 0; i < n; i++) if(res[i] == -1) res[i] = unused[j++];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126454,
                "title": "javascript-easy-to-understand-greedy",
                "content": "The key point for this problem is that we could return any permutation meets the requirement.\\nSo it\\'s easy to find out that we could traversal the sorted `B` and find the answer via greedy algorithm.\\n\\n## SOLUTION 1\\n\\n1. We sort the `A` and `B` first.\\n2. Traversal `B` to find out the closest and bigger number in `A` for each number in `B`. If there\\'s no such number, then we use the smallest number in `A` which is mostly useless in our rule.\\n3. Try to match the index and value to original `B` to get the final answer.\\n\\n```js\\nconst SWAP = (a, b) => b - a;\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const ret = new Uint32Array(LEN);\\n  const b = [...B];\\n  const map = {};\\n  b.sort(SWAP);\\n  a.sort(SWAP);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i] ? a[left++] : a[right--];\\n    map[b[i]] ? map[b[i]].push(value) : (map[b[i]] = [value]);\\n  }\\n  for (let i = 0; i < B.length; ++i) {\\n    ret[i] = map[B[i]].pop();\\n  }\\n  return ret;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nWe use a hashmap and linear list to save the value mappings in solution 1. But we could do it better actually.\\nThe most important is to find a way to save the index mappings between the original `B` and sorted `B`.\\n\\nSo, I give 2 solutions here, the main greedy algorithm is the same as solution 1. I think it\\'s easy to read, so if there\\'s any question, please give me a comment.\\n\\n```js\\n// save the index as extra data\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => [val, idx]);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((a, b) => b[0] - a[0]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i][0] ? a[left++] : a[right--];\\n    ret[b[i][1]] = value;\\n  }\\n  return ret;\\n};\\n```\\n\\n```js\\n// save the index for B which is sorted by value\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => idx);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((i, j) => B[j] - B[i]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > B[b[i]] ? a[left++] : a[right--];\\n    ret[b[i]] = value;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst SWAP = (a, b) => b - a;\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const ret = new Uint32Array(LEN);\\n  const b = [...B];\\n  const map = {};\\n  b.sort(SWAP);\\n  a.sort(SWAP);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i] ? a[left++] : a[right--];\\n    map[b[i]] ? map[b[i]].push(value) : (map[b[i]] = [value]);\\n  }\\n  for (let i = 0; i < B.length; ++i) {\\n    ret[i] = map[B[i]].pop();\\n  }\\n  return ret;\\n};\\n```\n```js\\n// save the index as extra data\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => [val, idx]);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((a, b) => b[0] - a[0]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i][0] ? a[left++] : a[right--];\\n    ret[b[i][1]] = value;\\n  }\\n  return ret;\\n};\\n```\n```js\\n// save the index for B which is sorted by value\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => idx);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((i, j) => B[j] - B[i]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > B[b[i]] ? a[left++] : a[right--];\\n    ret[b[i]] = value;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126272,
                "title": "c-without-map-sets-using-single-sort-and-upper-bound-to-a",
                "content": "Intuition - Advantage will be when we select an element in A such that it is greater than B at some index. And we will have more greater elements left in A if we select the smallest greater element than B instead of randomly selecting element in A that is greater than B.\\n\\nUpper_bound on sorted array gives the iterator to next greater element than the element searched for. E.g. - upper_bound(sortedA.begin(), sortedA.end(), 8) will give you iterator to 9 for sortedA = [5,6,7,8,9,10]\\n\\nSo, knowing this I sorted array A and created a boolean indices array of same size as A that will store which indices from A have been occupied.\\n\\nNow traversing B we will look for element in A that is just greater than B. If found we will update indices A to true and res as well to store the resultant permutation.\\n\\nIn the end we will also fill the rest of res for elements which did not had any greater element in A.\\n\\n```\\n// to get the next index that is not occupied\\nint nextAvailable(vector<bool>& indices, int j, const int& n){\\n\\twhile(j < n && indices[j]) j++;\\n\\treturn j;\\n}\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tint n = A.size(), idx;\\n\\tvector<bool> indices(n);\\n\\tvector<int> res(n, -1);\\n\\tsort(A.begin(), A.end());\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t// get the index of the next greater element\\n\\t\\tidx = upper_bound(A.begin(), A.end(), B[i]) - A.begin();\\n\\t\\twhile(idx < n && indices[idx]) idx++;\\n\\t\\tif(idx != n){\\n\\t\\t\\tindices[idx] = true;\\n\\t\\t\\tres[i] = A[idx];\\n\\t\\t}\\n\\t}\\n\\t// updating res with rest of the elements\\n\\tint j = 0;\\n\\tj = nextAvailable(indices, j, n);\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(res[i] == -1){\\n\\t\\t\\tres[i] = A[j];\\n\\t\\t\\tj = nextAvailable(indices, j+1, n);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// to get the next index that is not occupied\\nint nextAvailable(vector<bool>& indices, int j, const int& n){\\n\\twhile(j < n && indices[j]) j++;\\n\\treturn j;\\n}\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tint n = A.size(), idx;\\n\\tvector<bool> indices(n);\\n\\tvector<int> res(n, -1);\\n\\tsort(A.begin(), A.end());\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t// get the index of the next greater element\\n\\t\\tidx = upper_bound(A.begin(), A.end(), B[i]) - A.begin();\\n\\t\\twhile(idx < n && indices[idx]) idx++;\\n\\t\\tif(idx != n){\\n\\t\\t\\tindices[idx] = true;\\n\\t\\t\\tres[i] = A[idx];\\n\\t\\t}\\n\\t}\\n\\t// updating res with rest of the elements\\n\\tint j = 0;\\n\\tj = nextAvailable(indices, j, n);\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(res[i] == -1){\\n\\t\\t\\tres[i] = A[j];\\n\\t\\t\\tj = nextAvailable(indices, j+1, n);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126041,
                "title": "python-3-binary-search-two-pointers-deque-2-lines",
                "content": "# Naive, Binary search\\n- Naive iterative approach is to find minimum `A` value greater than current `B` value. If  there is no such minimum value then use just lowest value (no advantage).\\n- To avoid double usage the found values should be removed from the `A` list.\\n- To quickly search `A` list it should be sorted.\\n- Time complexity is `O(n**2)`. Space complexity is `O(n)`.\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = sorted(A)\\n        \\n        return [A.pop(bisect_right(A, b) % len(A)) for b in B]\\n```\\n# Two pointers, A loop\\n- `pop(i)` method from the previous approach takes `O(n)`. To improve it we can sort both `A` and `B` lists and use it in pair. Sorted `B` list should contain original index to be able restore original order.\\n- Every sorted `A` value we compare with sorted `B` value. If `A` value is greater `B` value then `A` value has the advantage (move `A` value to the begin of result list). Else `A` value and all next values have no advantage (move `A` value to the end of result list).\\n- Use `B` index to sort result in original order.\\n- Time complexity is `O(n * log n)`. Space complexity is `O(n)`.\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        B = sorted(zip(B, count()))\\n        i, j = 0, -1; ret = [None]*len(B)\\n        for a in sorted(A):\\n            if a > B[i][0]:\\n                ret[B[i][1]] = a; i += 1\\n            else:\\n                ret[B[j][1]] = a; j -= 1\\n        \\n        return ret\\n```\\n# Deque, B loop\\n- We can use double ended queue instead of two pointers.\\n- We can traverse sorted `B` list instead of sorted `A`. Note the lists are reversed.\\n- Time complexity is `O(n * log n)`. Space complexity is `O(n)`.\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = deque(sorted(A, reverse=True))\\n\\t\\tret = [...]*len(B)\\n        for b, i in sorted(zip(B, count()), reverse=True):\\n            ret[i] = A.popleft() if A[0] > b else A.pop()\\n        \\n        return ret\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = sorted(A)\\n        \\n        return [A.pop(bisect_right(A, b) % len(A)) for b in B]\\n```\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        B = sorted(zip(B, count()))\\n        i, j = 0, -1; ret = [None]*len(B)\\n        for a in sorted(A):\\n            if a > B[i][0]:\\n                ret[B[i][1]] = a; i += 1\\n            else:\\n                ret[B[j][1]] = a; j -= 1\\n        \\n        return ret\\n```\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = deque(sorted(A, reverse=True))\\n\\t\\tret = [...]*len(B)\\n        for b, i in sorted(zip(B, count()), reverse=True):\\n            ret[i] = A.popleft() if A[0] > b else A.pop()\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126022,
                "title": "100-idiomatic-go-solution",
                "content": "```\\nfunc advantageCount(A []int, B []int) []int {\\n\\tsort.Ints(A)\\n\\tb := make([][2]int, len(B))\\n\\tfor i, n := range B {\\n\\t\\tb[i] = [2]int{n, i}\\n\\t}\\n\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\treturn b[i][0] < b[j][0]\\n\\t})\\n\\n\\tresult := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(b) - 1; i >= 0; i-- {\\n\\t\\tval, idx := b[i][0], b[i][1]\\n\\t\\tif A[right] > val {\\n\\t\\t\\tresult[idx] = A[right]\\n\\t\\t\\tright--\\n\\t\\t} else {\\n\\t\\t\\tresult[idx] = A[left]\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc advantageCount(A []int, B []int) []int {\\n\\tsort.Ints(A)\\n\\tb := make([][2]int, len(B))\\n\\tfor i, n := range B {\\n\\t\\tb[i] = [2]int{n, i}\\n\\t}\\n\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\treturn b[i][0] < b[j][0]\\n\\t})\\n\\n\\tresult := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(b) - 1; i >= 0; i-- {\\n\\t\\tval, idx := b[i][0], b[i][1]\\n\\t\\tif A[right] > val {\\n\\t\\t\\tresult[idx] = A[right]\\n\\t\\t\\tright--\\n\\t\\t} else {\\n\\t\\t\\tresult[idx] = A[left]\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125897,
                "title": "python-clean-simple",
                "content": "```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        q = deque(sorted(A))\\n        b = sorted([(num, i) for i, num in enumerate(B)], reverse=True)\\n        result = [0] * len(q) \\n        for num, i in b:\\n            if num < q[-1]:\\n                result[i] = q.pop()\\n            else:\\n                result[i] = q.popleft()\\n        return result\\n```\\n\\nBut of course, lee215\\'s answer looks even neater. \\uD83E\\uDD2F",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        q = deque(sorted(A))\\n        b = sorted([(num, i) for i, num in enumerate(B)], reverse=True)\\n        result = [0] * len(q) \\n        for num, i in b:\\n            if num < q[-1]:\\n                result[i] = q.pop()\\n            else:\\n                result[i] = q.popleft()\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125882,
                "title": "c-greedy-solution-using-sort-explained",
                "content": "The idea is to keep elements of A greater than elements of B, but they have to be closest.\\nsort vector A in order to use upper_bound function.\\nupper_bound returns the next larger value than the value we passed in the function.\\nif we find next largest value, we put that in result vector and erase it from vector A, so we don\\'t use it again.\\nIf we don\\'t find the largest value, then we put the smallest value. The smallest value is located at beginning of vector A (A is sorted). Erase that too.\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res(A.size());\\n        int i, j, index;\\n        sort(A.begin(), A.end());\\n        for(i=0; i<B.size(); i++)\\n        {\\n            auto ub = upper_bound(A.begin(), A.end(), B[i]);\\n           \\n            if(ub!=A.end())\\n            {\\n                res[i] = A[ub-A.begin()];\\n               index = ub-A.begin();\\n                A.erase(A.begin()+index);\\n            }\\n            else\\n            {\\n                res[i] = A[0];\\n                A.erase(A.begin()+0);\\n            }      \\n        }\\n        return res;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res(A.size());\\n        int i, j, index;\\n        sort(A.begin(), A.end());\\n        for(i=0; i<B.size(); i++)\\n        {\\n            auto ub = upper_bound(A.begin(), A.end(), B[i]);\\n           \\n            if(ub!=A.end())\\n            {\\n                res[i] = A[ub-A.begin()];\\n               index = ub-A.begin();\\n                A.erase(A.begin()+index);\\n            }\\n            else\\n            {\\n                res[i] = A[0];\\n                A.erase(A.begin()+0);\\n            }      \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125704,
                "title": "python-greedy-two-pointers",
                "content": "just keep original indices for B, sort and then one more traversal to fill remains\\n\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [None for _ in range(len(A))]\\n        \\n        A.sort(reverse=True)\\n        bb = [[i, B[i]] for i in range(len(B))]\\n        \\n        bb.sort(key=lambda k: k[1], reverse=True)\\n        \\n        i = 0\\n        j = 0\\n        while i < len(B):\\n            if bb[i][1] < A[j]:\\n                res[bb[i][0]] = A[j]\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        for i in range(len(res)):\\n            if res[i] is None:\\n                res[i] = A[j]\\n                j+=1\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [None for _ in range(len(A))]\\n        \\n        A.sort(reverse=True)\\n        bb = [[i, B[i]] for i in range(len(B))]\\n        \\n        bb.sort(key=lambda k: k[1], reverse=True)\\n        \\n        i = 0\\n        j = 0\\n        while i < len(B):\\n            if bb[i][1] < A[j]:\\n                res[bb[i][0]] = A[j]\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        for i in range(len(res)):\\n            if res[i] is None:\\n                res[i] = A[j]\\n                j+=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125646,
                "title": "c-solution-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t//storing in set to remove the duplicates\\n        multiset<int> s(A.begin(),A.end());\\n        vector<int>ans(n, -1);\\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t    // see if is there is any value present which is just greater one \\n            auto itr = s.upper_bound(B[i]);\\n            if(itr != s.end())\\n            {\\n                ans[i] = *itr;\\n                s.erase(itr);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ans[i] == -1)\\n            {\\n                ans[i] = *s.begin();\\n                s.erase(s.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t//storing in set to remove the duplicates\\n        multiset<int> s(A.begin(),A.end());\\n        vector<int>ans(n, -1);\\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t    // see if is there is any value present which is just greater one \\n            auto itr = s.upper_bound(B[i]);\\n            if(itr != s.end())\\n            {\\n                ans[i] = *itr;\\n                s.erase(itr);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ans[i] == -1)\\n            {\\n                ans[i] = *s.begin();\\n                s.erase(s.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125532,
                "title": "javascript-easy-to-understand-with-explanation-and-commented-code",
                "content": "Ok, so the problem is, given two arrays, A and B, reshuffel A, so that at each position, it is a higher value than B, or at least in the way that gives A, as many indicies with higher value as possible.\\n\\nSo, while maybe not the most optimal solution, one way is to sort A, then iterate though B, beating each value in B with as small a value in A as possible.  When it\\'s not possible to beat the value, simply use the smallest value possible.  \\n\\nIf you sort A, u know that the last value is the largest, the first value the smallest.\\nSo, one by one, is the value of B, smaller than the largest value of A?  If so, it\\'s possible to beat, so lets do it in the smallest way possible (saving larger numbers for use later).\\n\\nSince I didn\\'t sort B in any way, i keep starting at the bottom of A and go until i find the larger A value and swap that value into B.  I could have used another array, but since I don\\'t need previous values of B anymore, why not just reuse that data structure.  When finished, return it.\\n\\n```\\nvar advantageCount = function(A, B) {\\n   let sortedA = A.sort((a,b) => a-b); // sort A\\n   for (let i=0, j=B.length; i<j; i++) { // iterate through B\\n     if (B[i]<A[A.length-1]) { // is it possible to beat the current B?\\n       let ii=0; // we can, so starting at zero, find the first value that beats the current B val\\n       while (B[i]>=A[ii]) ii++ //keep going\\n       B[i] = A.splice(ii,1); // ok, we have a larger A value, so put it into B which we will return\\n     } else {\\n       B[i] = A.shift(); // In this case, the current B is even larger than the largest A, so use the smallest A value\\n     }\\n   }\\n  return B; \\n};\\n```\\n\\nIf this solution helps you, please upvote it so others can notice it, not to mention appreciating a little of my effort.  Thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar advantageCount = function(A, B) {\\n   let sortedA = A.sort((a,b) => a-b); // sort A\\n   for (let i=0, j=B.length; i<j; i++) { // iterate through B\\n     if (B[i]<A[A.length-1]) { // is it possible to beat the current B?\\n       let ii=0; // we can, so starting at zero, find the first value that beats the current B val\\n       while (B[i]>=A[ii]) ii++ //keep going\\n       B[i] = A.splice(ii,1); // ok, we have a larger A value, so put it into B which we will return\\n     } else {\\n       B[i] = A.shift(); // In this case, the current B is even larger than the largest A, so use the smallest A value\\n     }\\n   }\\n  return B; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125446,
                "title": "rust-solution",
                "content": "Applied the strategy of `\\u7530\\u5FCC\\u8D5B\\u9A6C`  here.\\n\\n```rust\\nimpl Solution {\\n    // time: O(nlogn)\\n    pub fn advantage_count(mut a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n        let n = a.len();\\n        a.sort();\\n        let mut b: Vec<(usize, i32)> = b.into_iter().enumerate().collect();\\n        b.sort_by(|a, b| a.1.cmp(&b.1));\\n\\n        let mut res = vec![0; n];\\n        let mut slow = 0;\\n        let mut fast = n - 1;\\n        while let Some((opponent_idx, opponent)) = b.pop() {\\n            res[opponent_idx] = {\\n                if opponent >= a[fast] {\\n                    let v = a[slow];\\n                    slow += 1;\\n                    v\\n                } else {\\n                    let v = a[fast];\\n                    fast -= 1;\\n                    v\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    // time: O(nlogn)\\n    pub fn advantage_count(mut a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n        let n = a.len();\\n        a.sort();\\n        let mut b: Vec<(usize, i32)> = b.into_iter().enumerate().collect();\\n        b.sort_by(|a, b| a.1.cmp(&b.1));\\n\\n        let mut res = vec![0; n];\\n        let mut slow = 0;\\n        let mut fast = n - 1;\\n        while let Some((opponent_idx, opponent)) = b.pop() {\\n            res[opponent_idx] = {\\n                if opponent >= a[fast] {\\n                    let v = a[slow];\\n                    slow += 1;\\n                    v\\n                } else {\\n                    let v = a[fast];\\n                    fast -= 1;\\n                    v\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125343,
                "title": "c-code-using-multiset",
                "content": "Store all the elements in a multiset and for each element in vector B , select the just greater element from multiset. Incase there is no such element choose the smallest element from set , i.e. the first element and push it into the res vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        // sort(A.begin(), A.end());\\n        vector<int> res ; \\n        int size = B.size();\\n        multiset<int> st;\\n        for(int i = 0; i< size; i++){\\n            st.insert(A[i]);\\n        }\\n        for(int i = 0; i<size; i++){\\n            auto upper1 = st.upper_bound(B[i]);\\n            if(upper1 != st.end()){\\n                res.push_back(*upper1);\\n                st.erase(upper1);\\n            }\\n            else{\\n                res.push_back(*st.begin());\\n                st.erase(st.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        // sort(A.begin(), A.end());\\n        vector<int> res ; \\n        int size = B.size();\\n        multiset<int> st;\\n        for(int i = 0; i< size; i++){\\n            st.insert(A[i]);\\n        }\\n        for(int i = 0; i<size; i++){\\n            auto upper1 = st.upper_bound(B[i]);\\n            if(upper1 != st.end()){\\n                res.push_back(*upper1);\\n                st.erase(upper1);\\n            }\\n            else{\\n                res.push_back(*st.begin());\\n                st.erase(st.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125197,
                "title": "advantage-shuffle-fast-python-multiple-solutions-with-explanation",
                "content": "### Ideas\\nThere are multiple ways to approach this problem. I list them as my thought progresses.\\n\\n#### 1. Sorted container\\nSort `B` from big to small. The optimal pick for `b` is the smallest not-chosen value in `A` that `> b`. \\n\\nThis approach requires a data structure that supports efficient `bisect` query and deletion. `sortedcontainers.SortedList` can come in handy.\\n\\n#### 2. Running stack\\nCan we do it without non-standard libraries? The answer is yes. We can sort `A` as well and maintain a stack of eligible values.  For each `b`, we will add values `> b` from sorted `A` to the stack in descending order and pick the top element for `b`. \\n\\nSee \"Code 2\" below. After the main loop, we fill the unassigned slots in `ans` with unused values from `A`.\\n\\n#### 3. Just pick\\nOnce we have the stack view, one may start to wonder do we really need to pick the smallest value in the stack for each `b`. After all, no matter we pick the smallest or largest, it won\\'t affect the candidate pool\\'s size and consequently the number of winning locations.\\n\\nSo let\\'s try to pick the largest eligible value instead.  One realization is that we don\\'t need a stack at all! The largest eligible value, if there is any, will just be the next biggest value in sorted `A`!\\n\\nWhat if the next biggest value in `A` is `<= b`? Then there is no way to win at `b` and we fill the location with the smallest value that is not yet picked from `A`. \\n\\nSee \"Code 3\" below. Note this also eliminated the extra finishing-up logic at the end of \"Code 2\".\\n\\n### Code 2\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i = j = n - 1\\n        ans = [-1] * n\\n        st = []\\n        for b, j in reversed(sorted_B):\\n            if st:\\n                ans[j] = st.pop()\\n                continue\\n            if sorted_A[i] <= b:\\n                continue\\n            while i >= 0 and sorted_A[i] > b:\\n                st.append(sorted_A[i])\\n                i -= 1\\n            ans[j] = st.pop()\\n        while i >= 0:\\n            st.append(sorted_A[i])\\n            i -= 1\\n        for i in range(n):\\n            if ans[i] == -1:\\n                ans[i] = st.pop()\\n        return ans\\n```\\n\\n### Code 3\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for b, j in reversed(sorted_B):\\n            if sorted_A[i] > b:\\n                ans[j] = sorted_A[i]\\n                i -= 1\\n            else:\\n                ans[j] = sorted_A[k]\\n                k += 1\\n        return ans\\n```\\n\\n\\n### Code 3.1\\nWe could further optimize the foot print of Code 3 by sorting `A` in place and only sorting the index of `B`:\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        A.sort()\\n        sorted_B_idxs = sorted(range(n), key=lambda j: B[j], reverse=True)\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for j in sorted_B_idxs:\\n            if A[i] > B[j]:\\n                ans[j] = A[i]\\n                i -= 1\\n            else:\\n                ans[j] = A[k]\\n                k += 1\\n        return ans\\n```\\n\\n### Complexity\\nFor Code 2:\\n- O(n log n) time. \\nSorting takes O(n log n). The main loop takes O(n), as it walks through both `sorted_A` and `sorted_B` once.\\n- O(n) extra space. \\nThe storage of  `sorted_A`, `sorted_B` and the stack `st`.\\n\\nFor Code 3:\\n- O(n log n) time. \\nThe same argument applies. However, the actual running time is faster as the logic is simpler with no stack operations. \\n- O(n) extra space.\\nWe still need to store `sorted_A`, `sorted_B`, but the space for `st` is saved.\\n\\n### Submission Stats\\nFor Code 2:\\nRuntime: 356 ms (beats 66.12 %)\\nMemory Usage: 18 MB\\n\\nFor Code 3:\\nRuntime: 336 ms (beats 94.14 %)\\nMemory Usage: 17.6 MB\\n\\nFor Code 3.1:\\nRuntime: 332 ms (beats 96.52 %)\\nMemory Usage: 16.9 MB (beats 93.04 %)\\n\\n---\\nIf you find this helpful, please kindly **upvote**! It will greatly encourage me to write more in the future.\\nThanks for reading and happy LeetCoding~!",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i = j = n - 1\\n        ans = [-1] * n\\n        st = []\\n        for b, j in reversed(sorted_B):\\n            if st:\\n                ans[j] = st.pop()\\n                continue\\n            if sorted_A[i] <= b:\\n                continue\\n            while i >= 0 and sorted_A[i] > b:\\n                st.append(sorted_A[i])\\n                i -= 1\\n            ans[j] = st.pop()\\n        while i >= 0:\\n            st.append(sorted_A[i])\\n            i -= 1\\n        for i in range(n):\\n            if ans[i] == -1:\\n                ans[i] = st.pop()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for b, j in reversed(sorted_B):\\n            if sorted_A[i] > b:\\n                ans[j] = sorted_A[i]\\n                i -= 1\\n            else:\\n                ans[j] = sorted_A[k]\\n                k += 1\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        A.sort()\\n        sorted_B_idxs = sorted(range(n), key=lambda j: B[j], reverse=True)\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for j in sorted_B_idxs:\\n            if A[i] > B[j]:\\n                ans[j] = A[i]\\n                i -= 1\\n            else:\\n                ans[j] = A[k]\\n                k += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125178,
                "title": "python-sort-and-walk",
                "content": "# Idea\\nThe strategy for elements from A is to use them to cover the largest possible element in B. Let\\'s sort both A and B, remembering the indices for the elements in B. Then let\\'s walk back from the end of both arrays and do the following:\\nIf the current element in A is bigger than the one in B, use it to cover that element in B.\\nOtherwise, use the smallest unused element in A (walk from the opposite direction).\\n\\n# Complexity\\nTime: O(NlogN), because of sorting\\nSpace: O(N), for the result and temporary array `c`\\n```\\ndef advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\tN = len(A)\\n\\tA.sort()\\n\\tc = sorted([(v, i) for i, v in enumerate(B)])  # sorting B, while keeping the positions\\n\\tresult = [-1] * N\\n\\n\\tli, ri = 0, N-1  # pointers for A\\n\\trj = N-1  # pointer for c\\n\\twhile rj >= 0:\\n\\t\\tcv, ci = c[rj]\\n\\t\\tif cv < A[ri]:\\n\\t\\t\\tresult[ci] = A[ri]\\n\\t\\t\\tri -= 1\\n\\t\\telse:\\n\\t\\t\\tresult[ci] = A[li]\\n\\t\\t\\tli += 1\\n\\t\\trj -= 1\\n\\n\\treturn result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\tN = len(A)\\n\\tA.sort()\\n\\tc = sorted([(v, i) for i, v in enumerate(B)])  # sorting B, while keeping the positions\\n\\tresult = [-1] * N\\n\\n\\tli, ri = 0, N-1  # pointers for A\\n\\trj = N-1  # pointer for c\\n\\twhile rj >= 0:\\n\\t\\tcv, ci = c[rj]\\n\\t\\tif cv < A[ri]:\\n\\t\\t\\tresult[ci] = A[ri]\\n\\t\\t\\tri -= 1\\n\\t\\telse:\\n\\t\\t\\tresult[ci] = A[li]\\n\\t\\t\\tli += 1\\n\\t\\trj -= 1\\n\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1125068,
                "title": "python-greedy",
                "content": "Here is one way to construct a valid permutation: Sort `A`. Do not sort `B` itself but get the indices that would do so in `places`. Now we consider elements from sorted `A` and `B` in decreasing order. `i` and `j` point to the beginning and end of `A`, and `k` points to end of sorted `B` (which is equivalent to the end of `places`). Two cases can occur:\\n* If `A[j] > B[places[k]]`, place that `A[j]` to the corresponding location, `ans[places[k]] = A[j]`. Decrement `j`.\\n* Otherwise there is no way we can beat `B[places[k]]`, we can safely place the smallest available element to the corresponding location, `ans[places[k]] = A[i]`. Increment `i`.\\n\\nTime: `O(N logN)` (due to sort)\\nSpace: `O(1)` (apart from array created to return)\\n\\n```python\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        ans = [0]*n\\n        \\n        #A in increasing order\\n        A.sort()\\n        #B in increasing order\\n        places = list(sorted(range(n), key=B.__getitem__)) \\n        #Two pointers for A, one for B\\n        i, j, k = 0, n-1, n-1\\n        while i <= j:\\n            if A[j] > B[places[k]]: #add from right of sorted A\\n                ans[places[k]] = A[j]\\n                j -= 1\\n            else: #add from left of sorted A\\n                ans[places[k]] = A[i]\\n                i += 1\\n            k -= 1 #go to next element of B\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        ans = [0]*n\\n        \\n        #A in increasing order\\n        A.sort()\\n        #B in increasing order\\n        places = list(sorted(range(n), key=B.__getitem__)) \\n        #Two pointers for A, one for B\\n        i, j, k = 0, n-1, n-1\\n        while i <= j:\\n            if A[j] > B[places[k]]: #add from right of sorted A\\n                ans[places[k]] = A[j]\\n                j -= 1\\n            else: #add from left of sorted A\\n                ans[places[k]] = A[i]\\n                i += 1\\n            k -= 1 #go to next element of B\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977714,
                "title": "java-treemap-ceilingkey-function",
                "content": "**Upvote if u find this solution useful.**\\n```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[] ans = new int[A.length];\\n        for (int i : A) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int index = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            Integer ceiling = map.ceilingKey(B[i] + 1);\\n            if (ceiling == null) {\\n                final Integer firstKey = map.firstKey();\\n                ans[index++] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n            else {\\n                ans[index++] = ceiling;\\n                map.put(ceiling, map.get(ceiling) - 1);\\n                if (map.get(ceiling) == 0) map.remove(ceiling);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "**Upvote if u find this solution useful.**\\n```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[] ans = new int[A.length];\\n        for (int i : A) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int index = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            Integer ceiling = map.ceilingKey(B[i] + 1);\\n            if (ceiling == null) {\\n                final Integer firstKey = map.firstKey();\\n                ans[index++] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n            else {\\n                ans[index++] = ceiling;\\n                map.put(ceiling, map.get(ceiling) - 1);\\n                if (map.get(ceiling) == 0) map.remove(ceiling);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 902900,
                "title": "c-o-nlog-n-using-upper-bound-beats-94-solution",
                "content": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms;\\n        for(auto a: A){\\n            ms.insert(a);\\n        }\\n        vector<int> ans(B.size(), -1);\\n        for(int i = 0; i < B.size(); i++){\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()){\\n                ans[i] = *it;\\n            }\\n            else{\\n                it = ms.begin();\\n                ans[i] = *it;\\n            }\\n            ms.erase(it);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms;\\n        for(auto a: A){\\n            ms.insert(a);\\n        }\\n        vector<int> ans(B.size(), -1);\\n        for(int i = 0; i < B.size(); i++){\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()){\\n                ans[i] = *it;\\n            }\\n            else{\\n                it = ms.begin();\\n                ans[i] = *it;\\n            }\\n            ms.erase(it);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886254,
                "title": "c-solution-using-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> ans;\\n        for(int i=0;i<B.size();i++){\\n            auto it=upper_bound(A.begin(),A.end(),B[i]);\\n            if(it!=A.end()){\\n                ans.push_back(A[it-A.begin()]);\\n                A.erase(it);\\n            }else{\\n                ans.push_back(A[0]);\\n                A.erase(A.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> ans;\\n        for(int i=0;i<B.size();i++){\\n            auto it=upper_bound(A.begin(),A.end(),B[i]);\\n            if(it!=A.end()){\\n                ans.push_back(A[it-A.begin()]);\\n                A.erase(it);\\n            }else{\\n                ans.push_back(A[0]);\\n                A.erase(A.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882013,
                "title": "java-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    /*\\n    *Logic:\\n    *   For every element B[i],find the smallest element A[j]\\n    *   such that A[j] > B[i]\\n    *    if no such element exist,append the smallest element of A\\n    *\\n    *   sort the array A ,so that binary search can be used\\n    *   time complexity = O(nlogn)\\n    */\\n    \\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        ArrayList<Integer> arrA = new ArrayList<>();\\n        for(int i : A)\\n            arrA.add(i);\\n        \\n        Collections.sort(arrA);\\n        \\n        int j = 0;\\n        for(int i : B)\\n        {\\n            int index = binarySearch(arrA,i);   \\n            if(index!=-1)\\n            {\\n                A[j++] = arrA.get(index);\\n                arrA.remove(index);\\n            }        \\n            else\\n            {\\n                A[j++] = arrA.get(0);\\n                arrA.remove(0);\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    \\n    public int binarySearch(ArrayList<Integer> arr , int key)\\n    {\\n        int start = 0;\\n        int end = arr.size()-1;\\n        int index = -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            int ele = arr.get(mid);\\n            \\n            if(ele <= key)\\n                start = mid+1;\\n            else\\n            {\\n                index = mid;\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return index;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    *Logic:\\n    *   For every element B[i],find the smallest element A[j]\\n    *   such that A[j] > B[i]\\n    *    if no such element exist,append the smallest element of A\\n    *\\n    *   sort the array A ,so that binary search can be used\\n    *   time complexity = O(nlogn)\\n    */\\n    \\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        ArrayList<Integer> arrA = new ArrayList<>();\\n        for(int i : A)\\n            arrA.add(i);\\n        \\n        Collections.sort(arrA);\\n        \\n        int j = 0;\\n        for(int i : B)\\n        {\\n            int index = binarySearch(arrA,i);   \\n            if(index!=-1)\\n            {\\n                A[j++] = arrA.get(index);\\n                arrA.remove(index);\\n            }        \\n            else\\n            {\\n                A[j++] = arrA.get(0);\\n                arrA.remove(0);\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    \\n    public int binarySearch(ArrayList<Integer> arr , int key)\\n    {\\n        int start = 0;\\n        int end = arr.size()-1;\\n        int index = -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            int ele = arr.get(mid);\\n            \\n            if(ele <= key)\\n                start = mid+1;\\n            else\\n            {\\n                index = mid;\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874496,
                "title": "javascript-greedy-brute-force-solution",
                "content": "```\\nconst advantageCount = (A, B) => {\\n    let data = [];\\n    for (const b of B) {\\n        let n = A.length;\\n        A.sort((a, b) => a - b);\\n        let min = A[0];\\n        let max = A[n - 1];\\n        if (b >= max) { // if cannot find a item of A smaller than b, assign the trash (min item) to it (then remove), which means give up this index\\n            data.push(min);\\n            A.shift();\\n        } else { // greedy: find the min value from A which larger than b (then remove), to guarantee better usage of each item in A\\n            let removeIdx;\\n            for (let i = 0; i < n; i++) {\\n                if (A[i] > b) {\\n                    data.push(A[i]);\\n                    removeIdx = i;\\n                    break;\\n                }\\n            }\\n            A.splice(removeIdx, 1);\\n        }\\n    }\\n    return data;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst advantageCount = (A, B) => {\\n    let data = [];\\n    for (const b of B) {\\n        let n = A.length;\\n        A.sort((a, b) => a - b);\\n        let min = A[0];\\n        let max = A[n - 1];\\n        if (b >= max) { // if cannot find a item of A smaller than b, assign the trash (min item) to it (then remove), which means give up this index\\n            data.push(min);\\n            A.shift();\\n        } else { // greedy: find the min value from A which larger than b (then remove), to guarantee better usage of each item in A\\n            let removeIdx;\\n            for (let i = 0; i < n; i++) {\\n                if (A[i] > b) {\\n                    data.push(A[i]);\\n                    removeIdx = i;\\n                    break;\\n                }\\n            }\\n            A.splice(removeIdx, 1);\\n        }\\n    }\\n    return data;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799921,
                "title": "python3-sort-the-indices-of-b-by-element-value-advantage-shuffle",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n        index = sorted(range(len(B)), key=lambda x:B[x], reverse=True)\\n        remaining = []\\n        for a in sorted(A):\\n            if a > B[index[-1]]:\\n                ans[index.pop()] = a\\n            else:\\n                remaining.append(a)\\n        for b, a in zip(index, remaining):\\n            ans[b] = a\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n        index = sorted(range(len(B)), key=lambda x:B[x], reverse=True)\\n        remaining = []\\n        for a in sorted(A):\\n            if a > B[index[-1]]:\\n                ans[index.pop()] = a\\n            else:\\n                remaining.append(a)\\n        for b, a in zip(index, remaining):\\n            ans[b] = a\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759665,
                "title": "python-greedy-using-heap",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [-1] * len(A)\\n        sA = [(a,i) for i,a in enumerate(A)]\\n        sB = [(b,i) for i,b in enumerate(B)]\\n        heapq.heapify(sA)\\n        heapq.heapify(sB)\\n        remaining  = []\\n        while sA:\\n            a,i = heapq.heappop(sA)\\n            b,j = heapq.heappop(sB)\\n            if a>b:\\n                res[j] = a\\n            else:\\n                remaining.append(a)\\n                heapq.heappush(sB,(b,j))\\n        for i in range(len(res)):\\n            if res[i]==-1:\\n                res[i]=remaining.pop()\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [-1] * len(A)\\n        sA = [(a,i) for i,a in enumerate(A)]\\n        sB = [(b,i) for i,b in enumerate(B)]\\n        heapq.heapify(sA)\\n        heapq.heapify(sB)\\n        remaining  = []\\n        while sA:\\n            a,i = heapq.heappop(sA)\\n            b,j = heapq.heappop(sB)\\n            if a>b:\\n                res[j] = a\\n            else:\\n                remaining.append(a)\\n                heapq.heappush(sB,(b,j))\\n        for i in range(len(res)):\\n            if res[i]==-1:\\n                res[i]=remaining.pop()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747321,
                "title": "c-binary-search-on-a-to-get-next-larger-element-for-b-greedy-simple",
                "content": "Sort vector A\\nTraverse through B\\nFor each element in B, use Binary search to get the smallest element in A which is just larger than B\\'s corresponding element.\\nIf no auch element found, return smallest element of A.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:    \\n\\n\\tint BinarySearchNextLargest(int x, vector<int>& A)\\n    {\\n        int i = 0, j = A.size()-1, mid;\\n        \\n        if(x>=A[A.size()-1])    i = j+1;\\n        \\n        while(i<=j){\\n            mid = (i+j)/2;\\n            \\n            if(A[mid]>x && (mid==0 || A[mid-1]<=x))\\n            {\\n                int tmp = A[mid];\\n                A.erase(A.begin() + mid);\\n                return tmp;\\n            }\\n            else if(A[mid]<=x)\\n                i = mid+1;\\n            \\n            else if(A[mid]>x)\\n                j = mid-1;\\n        }\\n        \\n        int tmp = A[0];\\n        A.erase(A.begin());\\n        return tmp;\\n    }\\n    \\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> res;\\n        sort(A.begin(), A.end());\\n        \\n        for(int i = 0; i<B.size(); i++)\\n        {\\n            int n = BinarySearchNextLargest(B[i], A);\\n            res.push_back(n);\\n        }\\n        return res;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:    \\n\\n\\tint BinarySearchNextLargest(int x, vector<int>& A)\\n    {\\n        int i = 0, j = A.size()-1, mid;\\n        \\n        if(x>=A[A.size()-1])    i = j+1;\\n        \\n        while(i<=j){\\n            mid = (i+j)/2;\\n            \\n            if(A[mid]>x && (mid==0 || A[mid-1]<=x))\\n            {\\n                int tmp = A[mid];\\n                A.erase(A.begin() + mid);\\n                return tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 719000,
                "title": "c-using-multiset",
                "content": "Multiset has been used which easily allows using `upper_bound`.\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n=a.size();\\n        multiset<int> m;\\n        for(auto &it:a)m.insert(it);\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            auto it=m.upper_bound(b[i]);\\n            if(it!=m.end())\\n            {\\n                ans[i]=*it;\\n                m.erase(it);\\n            }\\n        }\\n        vector<int> temp;\\n        for(auto it:m)temp.push_back(it);\\n        for(int i=0;i<n;i++)\\n            if(ans[i]==-1)\\n            {\\n                ans[i]=temp.back();\\n                temp.pop_back();\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n=a.size();\\n        multiset<int> m;\\n        for(auto &it:a)m.insert(it);\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            auto it=m.upper_bound(b[i]);\\n            if(it!=m.end())\\n            {\\n                ans[i]=*it;\\n                m.erase(it);\\n            }\\n        }\\n        vector<int> temp;\\n        for(auto it:m)temp.push_back(it);\\n        for(int i=0;i<n;i++)\\n            if(ans[i]==-1)\\n            {\\n                ans[i]=temp.back();\\n                temp.pop_back();\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716520,
                "title": "my-greedy-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> temp,temp1 ;\\n        for (int i=0;i<A.size();i++) temp.push_back(make_pair(A[i],i)) ;\\n        for (int i=0;i<B.size();i++) temp1.push_back(make_pair(B[i],i)) ;\\n        \\n        sort(temp.begin(),temp.end()) ;\\n        sort(temp1.begin(),temp1.end()) ;\\n        \\n        while (temp.size()>0){\\n            if (temp.back().first>temp1.back().first){\\n                A[temp1.back().second] = temp.back().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.end()) ;\\n            }else {\\n                A[temp1.back().second] = temp.front().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.begin()) ;\\n            }\\n        }\\n        return A ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> temp,temp1 ;\\n        for (int i=0;i<A.size();i++) temp.push_back(make_pair(A[i],i)) ;\\n        for (int i=0;i<B.size();i++) temp1.push_back(make_pair(B[i],i)) ;\\n        \\n        sort(temp.begin(),temp.end()) ;\\n        sort(temp1.begin(),temp1.end()) ;\\n        \\n        while (temp.size()>0){\\n            if (temp.back().first>temp1.back().first){\\n                A[temp1.back().second] = temp.back().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.end()) ;\\n            }else {\\n                A[temp1.back().second] = temp.front().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.begin()) ;\\n            }\\n        }\\n        return A ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687038,
                "title": "c-multiset-solution-easy-and-simple",
                "content": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B)\\n    {\\n        multiset<int> st;\\n        for(auto elem : A)st.insert(elem);\\n        \\n        vector<int> ans;\\n        for(auto elem : B)\\n        {\\n            auto it = st.upper_bound(elem);\\n            if(it == st.end())\\n            {ans.pb(*st.begin()); st.erase(st.begin());}\\n            else {ans.pb(*it); st.erase(it);}\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B)\\n    {\\n        multiset<int> st;\\n        for(auto elem : A)st.insert(elem);\\n        \\n        vector<int> ans;\\n        for(auto elem : B)\\n        {\\n            auto it = st.upper_bound(elem);\\n            if(it == st.end())\\n            {ans.pb(*st.begin()); st.erase(st.begin());}\\n            else {ans.pb(*it); st.erase(it);}\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675938,
                "title": "c-only-arrays-used",
                "content": "```\\n vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        \\n       vector<pair<int,int>>c;\\n       int i,j,k,l,m,n;\\n       \\n       for(i=0;i<b.size();i++)\\n       {\\n           pair<int,int>p;\\n           p=make_pair(b[i],i);\\n           c.push_back(p);\\n       }\\n       \\n       n=b.size();\\n       \\n        \\n       vector<int>ans(n,-1);\\n    \\n       sort(a.begin(),a.end());\\n       sort(c.begin(),c.end());\\n       \\n      \\n       vector<int>left;\\n       j=0;\\n        \\n       i=0;\\n          \\n        \\n        while(i<a.size()){\\n            \\n           if(a[i]>c[j].first)\\n           {  \\n             \\n               \\n             ans[c[j].second]=a[i];   \\n             j++;  \\n           }\\n           else \\n           {\\n        \\n               while(i<a.size() &&  a[i]<=c[j].first)\\n               {  \\n                \\n                  left.push_back(a[i]); \\n              \\n                      i++; \\n               }\\n              \\n              if(i<a.size() && a[i]>c[j].first)\\n              {\\n                  ans[c[j].second]=a[i];\\n                  j++;\\n              }\\n           }\\n           \\n            i++;\\n         \\n       }\\n         \\n\\n        \\n       j=0; \\n       i=0;\\n       \\n      while(i<ans.size()) \\n      {  \\n          \\n          if(ans[i]==-1)\\n          {    \\n             ans[i]=left[j];\\n              j++;\\n          }\\n          i++;\\n     \\n      }\\n        \\n       return ans; \\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        \\n       vector<pair<int,int>>c;\\n       int i,j,k,l,m,n;\\n       \\n       for(i=0;i<b.size();i++)\\n       {\\n           pair<int,int>p;\\n           p=make_pair(b[i],i);\\n           c.push_back(p);\\n       }\\n       \\n       n=b.size();\\n       \\n        \\n       vector<int>ans(n,-1);\\n    \\n       sort(a.begin(),a.end());\\n       sort(c.begin(),c.end());\\n       \\n      \\n       vector<int>left;\\n       j=0;\\n        \\n       i=0;\\n          \\n        \\n        while(i<a.size()){\\n            \\n           if(a[i]>c[j].first)\\n           {  \\n             \\n               \\n             ans[c[j].second]=a[i];   \\n             j++;  \\n           }\\n           else \\n           {\\n        \\n               while(i<a.size() &&  a[i]<=c[j].first)\\n               {  \\n                \\n                  left.push_back(a[i]); \\n              \\n                      i++; \\n               }\\n              \\n              if(i<a.size() && a[i]>c[j].first)\\n              {\\n                  ans[c[j].second]=a[i];\\n                  j++;\\n              }\\n           }\\n           \\n            i++;\\n         \\n       }\\n         \\n\\n        \\n       j=0; \\n       i=0;\\n       \\n      while(i<ans.size()) \\n      {  \\n          \\n          if(ans[i]==-1)\\n          {    \\n             ans[i]=left[j];\\n              j++;\\n          }\\n          i++;\\n     \\n      }\\n        \\n       return ans; \\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 651733,
                "title": "simple-cpp-sol",
                "content": "Runtime: 256 ms, faster than 43.29% of C++ online submissions for Advantage Shuffle.\\nMemory Usage: 38.5 MB, less than 8.33% of C++ online submissions for Advantage Shuffle.\\n```\\n    bool arrange(pair<int,int> p1, pair<int,int> p2){\\n    return p1.second < p2.second;\\n}\\n    class Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> newB;\\n        vector<pair<int,int>> newA;\\n        int i,j;\\n        int n = B.size();\\n        if(n == 0){\\n            return {};\\n        }\\n        vector<int> output(n,0);\\n        for(i = 0; i < n; i++){\\n            newB.push_back({B[i], i});\\n            newA.push_back({A[i], i});\\n        }\\n        sort(newB.begin(), newB.end());\\n        sort(newA.begin(),newA.end());\\n        i = 0;\\n        j = 0;\\n        \\n        while(j < n && i < n){\\n            if(newA[i].first > newB[j].first){\\n                output[newB[j].second] = newA[i].first; \\n                newA[i].second = -1;\\n                newB[j].second = -1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        i = 0;\\n        sort(newB.begin(), newB.end(),arrange);\\n        sort(newA.begin(),newA.end(),arrange);\\n        while(i < n && newB[i].second == -1) i++;\\n        for(;i < n; i++){\\n            output[newB[i].second] = newA[i].first;\\n        }\\n        return output;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> newB;\\n        vector<pair<int,int>> newA;\\n        int i,j;\\n        int n = B.size();\\n        if(n == 0){\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 643109,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            } else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            } else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571996,
                "title": "advantage-shuffle-maximize-elements-a-i-b-i",
                "content": "I tried to maximize the advantage using greedy approach  but this problem is more look like maximzing the number of elements greater than B , Shuffle array such that we get maximu A[i]>B[i]\\nHere is the solution for same.\\n   \\n    \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\n        List<Integer> result = new LinkedList<Integer>();\\n\\t\\tint[] sortedA = A.clone();\\n        List<Integer> list = Arrays.stream(sortedA).boxed().collect(Collectors.toList());\\n        Collections.sort(list,Collections.reverseOrder());\\n        \\n\\t\\tfor (int i = 0; i < B.length; i++) {\\n            int j = 0;\\n            while (j < list.size() &&  B[i] < list.get(j)) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n            \\n            if(j == 0) {\\n                j = list.size();\\n            }\\n            result.add(list.get(j - 1));\\n            list.remove(j-1);\\n            \\n            \\n       }\\n       return result.stream().mapToInt(k -> k).toArray();\\n\\n\\t}\\n",
                "solutionTags": [],
                "code": "I tried to maximize the advantage using greedy approach  but this problem is more look like maximzing the number of elements greater than B , Shuffle array such that we get maximu A[i]>B[i]\\nHere is the solution for same.\\n   \\n    \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\n        List<Integer> result = new LinkedList<Integer>();\\n\\t\\tint[] sortedA = A.clone();\\n        List<Integer> list = Arrays.stream(sortedA).boxed().collect(Collectors.toList());\\n        Collections.sort(list,Collections.reverseOrder());\\n        \\n\\t\\tfor (int i = 0; i < B.length; i++) {\\n            int j = 0;\\n            while (j < list.size() &&  B[i] < list.get(j)) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n            \\n            if(j == 0) {\\n                j = list.size();\\n            }\\n            result.add(list.get(j - 1));\\n            list.remove(j-1);\\n            \\n            \\n       }\\n       return result.stream().mapToInt(k -> k).toArray();\\n\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 434799,
                "title": "clean-simple-java-solution-with-java-8",
                "content": "```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Queue<Integer> heapA = new PriorityQueue<Integer>((i,j) -> A[j]-A[i]);\\n        Queue<Integer> heapB = new PriorityQueue<Integer>((i,j) -> B[j]-B[i]);\\n        for(int i = 0; i<A.length; i++){\\n            heapA.add(i);\\n            heapB.add(i);\\n        }\\n        \\n        HashSet<Integer> nonAdvantageIndices = new HashSet();\\n        while(!heapB.isEmpty()){\\n            if(A[heapA.peek()] > B[heapB.peek()]){\\n                result[heapB.poll()] = A[heapA.poll()];\\n            }else{\\n                nonAdvantageIndices.add(heapB.poll());\\n            }\\n        }\\n\\t\\t\\n        nonAdvantageIndices.forEach(i -> result[i] = A[heapA.poll()]);\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Queue<Integer> heapA = new PriorityQueue<Integer>((i,j) -> A[j]-A[i]);\\n        Queue<Integer> heapB = new PriorityQueue<Integer>((i,j) -> B[j]-B[i]);\\n        for(int i = 0; i<A.length; i++){\\n            heapA.add(i);\\n            heapB.add(i);\\n        }\\n        \\n        HashSet<Integer> nonAdvantageIndices = new HashSet();\\n        while(!heapB.isEmpty()){\\n            if(A[heapA.peek()] > B[heapB.peek()]){\\n                result[heapB.poll()] = A[heapA.poll()];\\n            }else{\\n                nonAdvantageIndices.add(heapB.poll());\\n            }\\n        }\\n\\t\\t\\n        nonAdvantageIndices.forEach(i -> result[i] = A[heapA.poll()]);\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413476,
                "title": "python-use-sort-o-n-log-n-and-then-o-n-with-example",
                "content": "Sort A and B decrease, (save index only to make result)\\nB:[8,6,4,2,],---->B:[8,6,4,2,],---->B:[8,6,4,2,],\\nA:[9,5,3,1,],---->A:[9,  ,5,3,],---->A: [9,1,5,3,]\\nand you can see for num in B, if find max num available in A ,  if fail use it for next num in B\\nfinally put availables in empty position, so put tail ones in fail position has no risk\\n```\\n\\t\\tBdown = sorted(range(len(B)), key=lambda k: B[k] ,reverse = True)\\n        Adown = sorted(range(len(B)), key=lambda k: A[k] ,reverse = True)\\n        Res = [0]*len(B)\\n        \\n        for idx,num in enumerate(Bdown):\\n            if A[Adown[0]] > B[num]:\\n                Res[num] = A[Adown[0]]\\n                del Adown[0]\\n            else :\\n                Res[num] = A[Adown.pop()]\\n        return Res",
                "solutionTags": [],
                "code": "Sort A and B decrease, (save index only to make result)\\nB:[8,6,4,2,],---->B:[8,6,4,2,],---->B:[8,6,4,2,],\\nA:[9,5,3,1,],---->A:[9,  ,5,3,],---->A: [9,1,5,3,]\\nand you can see for num in B, if find max num available in A ,  if fail use it for next num in B\\nfinally put availables in empty position, so put tail ones in fail position has no risk\\n```\\n\\t\\tBdown = sorted(range(len(B)), key=lambda k: B[k] ,reverse = True)\\n        Adown = sorted(range(len(B)), key=lambda k: A[k] ,reverse = True)\\n        Res = [0]*len(B)\\n        \\n        for idx,num in enumerate(Bdown):\\n            if A[Adown[0]] > B[num]:\\n                Res[num] = A[Adown[0]]\\n                del Adown[0]\\n            else :\\n                Res[num] = A[Adown.pop()]\\n        return Res",
                "codeTag": "Unknown"
            },
            {
                "id": 399700,
                "title": "swift",
                "content": "first sort A and B\\nfor each element in A, if we can not have advantage in the current smallest element in B, we pair the current largest element in B. After each pair, shrink B\\n```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var result = A\\n        var start = 0\\n        var end = A.count - 1\\n        let sortedA = A.sorted()\\n        let sortedBTuple = B.enumerated().sorted { $0.1 < $1.1 }\\n        \\n        for i in 0..<A.count {\\n            if sortedA[i] > sortedBTuple[start].1 {\\n                result[sortedBTuple[start].0] = sortedA[i]\\n                start += 1\\n            } else {\\n                result[sortedBTuple[end].0] = sortedA[i]\\n                end -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var result = A\\n        var start = 0\\n        var end = A.count - 1\\n        let sortedA = A.sorted()\\n        let sortedBTuple = B.enumerated().sorted { $0.1 < $1.1 }\\n        \\n        for i in 0..<A.count {\\n            if sortedA[i] > sortedBTuple[start].1 {\\n                result[sortedBTuple[start].0] = sortedA[i]\\n                start += 1\\n            } else {\\n                result[sortedBTuple[end].0] = sortedA[i]\\n                end -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374534,
                "title": "easy-to-undersand",
                "content": "1) sort A\\n2) find the index of each element of B in sorted A.\\n3) If the index is equal to length of A which means the current element of B is greater than the current max of A, pop the minimum of A.\\n3) Otherwise, pop the element at the index found in step 2.\\n4) Append the popped element to the result.\\n\\n\\n```\\n\\t\\timport bisect\\n        ans = []\\n        A.sort()\\n        for num in B:\\n            indx = bisect.bisect_right(A, num)\\n            if indx == len(A):\\n                ans.append(A.pop(0))\\n            else:\\n                ans.append(A.pop(indx))\\n        return ans\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n\\t\\timport bisect\\n        ans = []\\n        A.sort()\\n        for num in B:\\n            indx = bisect.bisect_right(A, num)\\n            if indx == len(A):\\n                ans.append(A.pop(0))\\n            else:\\n                ans.append(A.pop(indx))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363681,
                "title": "treemap-and-two-pointers-solutions",
                "content": "treeMap solution\\n```\\npublic int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int num : A){\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i=0;i<B.length;i++){\\n            Integer k = treeMap.higherKey(B[i]);\\n            if (k==null){\\n                int n = treeMap.firstKey();\\n                ans[i] = n;\\n            }else {\\n                ans[i] = k;\\n            }\\n            treeMap.put(ans[i], treeMap.get(ans[i])-1);\\n            if (treeMap.get(ans[i])==0){\\n                treeMap.remove(ans[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\ntwo pointers sort solution\\n```\\npublic int[] advantageCount3(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int[][] temp = new int[B.length][2];\\n        for (int i=0;i<B.length;i++){\\n            temp[i] = new int[]{B[i],i};\\n        }\\n        Arrays.sort(temp, (a1, a2)->a1[0]-a2[0]);\\n        int[] ans = new int[A.length];\\n        int l = 0, r = A.length-1;\\n        for (int i=temp.length-1;i>=0;i--){\\n            if (temp[i][0] < A[r]){\\n                ans[temp[i][1]] = A[r--];\\n            }else {\\n                ans[temp[i][1]] = A[l++];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int num : A){\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i=0;i<B.length;i++){\\n            Integer k = treeMap.higherKey(B[i]);\\n            if (k==null){\\n                int n = treeMap.firstKey();\\n                ans[i] = n;\\n            }else {\\n                ans[i] = k;\\n            }\\n            treeMap.put(ans[i], treeMap.get(ans[i])-1);\\n            if (treeMap.get(ans[i])==0){\\n                treeMap.remove(ans[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int[] advantageCount3(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int[][] temp = new int[B.length][2];\\n        for (int i=0;i<B.length;i++){\\n            temp[i] = new int[]{B[i],i};\\n        }\\n        Arrays.sort(temp, (a1, a2)->a1[0]-a2[0]);\\n        int[] ans = new int[A.length];\\n        int l = 0, r = A.length-1;\\n        for (int i=temp.length-1;i>=0;i--){\\n            if (temp[i][0] < A[r]){\\n                ans[temp[i][1]] = A[r--];\\n            }else {\\n                ans[temp[i][1]] = A[l++];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349558,
                "title": "java-greedy-with-list-and-memory-usage-less-than-86-11-of-java-online-submissions",
                "content": "\\'\\'\\'\\npublic static <T> int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\n\\t     int anss[]=new int[A.length];     \\n\\t     List<Integer> bb =Arrays.stream(B).boxed().collect(Collectors.toList());\\n\\t     Arrays.sort(A);\\n\\t     int k=0;\\n\\t     int kl=anss.length-1;\\n\\t     for(int i=0;i<anss.length;i++)\\n\\t     {\\n\\t    \\t int maxb =Collections.max(bb); \\n\\t    \\t int maxindexb=bb.indexOf(maxb);\\t\\n\\t    \\t int maxa =A[kl]; \\n\\t    \\t if(maxa>maxb)\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=maxa;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t\\t kl--;\\n\\t    \\t }\\n\\t    \\t else\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=A[k];\\n\\t    \\t\\t k++;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t }\\t \\n\\t      }\\t     \\n\\t     return anss;\\n\\t    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\npublic static <T> int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\n\\t     int anss[]=new int[A.length];     \\n\\t     List<Integer> bb =Arrays.stream(B).boxed().collect(Collectors.toList());\\n\\t     Arrays.sort(A);\\n\\t     int k=0;\\n\\t     int kl=anss.length-1;\\n\\t     for(int i=0;i<anss.length;i++)\\n\\t     {\\n\\t    \\t int maxb =Collections.max(bb); \\n\\t    \\t int maxindexb=bb.indexOf(maxb);\\t\\n\\t    \\t int maxa =A[kl]; \\n\\t    \\t if(maxa>maxb)\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=maxa;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t\\t kl--;\\n\\t    \\t }\\n\\t    \\t else\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=A[k];\\n\\t    \\t\\t k++;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t }\\t \\n\\t      }\\t     \\n\\t     return anss;\\n\\t    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 342789,
                "title": "c-concise-and-easy-to-understand-using-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]); // find the smallest number greater than this current number in B in A\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            }\\n            else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]); // find the smallest number greater than this current number in B in A\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            }\\n            else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321568,
                "title": "c-two-pointer-solution-beats-97",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // A comparator adapter that uses the values from a secondary vector to determine ordering.\\n    template<class T, class C>\\n    class alt_order {\\n    private:\\n        const vector<T>& order_;\\n        C c_;\\n\\n    public:\\n        alt_order(const vector<T>& order) : order_(order), c_() {}\\n\\n        bool operator()(size_t a, size_t b) const {\\n            return c_(order_[a], order_[b]);\\n        }\\n    };\\n\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        size_t N = A.size();\\n\\n        // Generate order, a vector of indicies from 0..N-1, and sort it such that when iterated, the values,\\n        // when used to index B, would iterate B in ascending order.\\n        vector<size_t> order(N);\\n        iota(order.begin(), order.end(), 0);\\n        sort(order.begin(), order.end(), alt_order<int, less<int>>(B));\\n\\n        // Sort A in ascending order.\\n        sort(A.begin(), A.end());\\n\\n        vector<int> ans(N);\\n\\n        size_t i = 0, j = 0, k = N;\\n\\n        while(j < N) {\\n            // If the next value in A is > the next value in B (using the order vector to iterate B in ascending order),\\n            // then the A value should be paired with the B value in the answer vector.\\n            if(A[j] > B[order[i]]) {\\n                ans[order[i]] = A[j];\\n                ++i;\\n            }\\n            // Otherwise, the A value will never be greater than any upcoming B value, so pair it with the next largest\\n            // value in B (iterating the order vector backwards iterates B in descending order).\\n            else {\\n                ans[order[--k]] = A[j];\\n            }\\n            ++j;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // A comparator adapter that uses the values from a secondary vector to determine ordering.\\n    template<class T, class C>\\n    class alt_order {\\n    private:\\n        const vector<T>& order_;\\n        C c_;\\n\\n    public:\\n        alt_order(const vector<T>& order) : order_(order), c_() {}\\n\\n        bool operator()(size_t a, size_t b) const {\\n            return c_(order_[a], order_[b]);\\n        }\\n    };\\n\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        size_t N = A.size();\\n\\n        // Generate order, a vector of indicies from 0..N-1, and sort it such that when iterated, the values,\\n        // when used to index B, would iterate B in ascending order.\\n        vector<size_t> order(N);\\n        iota(order.begin(), order.end(), 0);\\n        sort(order.begin(), order.end(), alt_order<int, less<int>>(B));\\n\\n        // Sort A in ascending order.\\n        sort(A.begin(), A.end());\\n\\n        vector<int> ans(N);\\n\\n        size_t i = 0, j = 0, k = N;\\n\\n        while(j < N) {\\n            // If the next value in A is > the next value in B (using the order vector to iterate B in ascending order),\\n            // then the A value should be paired with the B value in the answer vector.\\n            if(A[j] > B[order[i]]) {\\n                ans[order[i]] = A[j];\\n                ++i;\\n            }\\n            // Otherwise, the A value will never be greater than any upcoming B value, so pair it with the next largest\\n            // value in B (iterating the order vector backwards iterates B in descending order).\\n            else {\\n                ans[order[--k]] = A[j];\\n            }\\n            ++j;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306652,
                "title": "c-ordering",
                "content": "```\\n        public int[] AdvantageCount(int[] A, int[] B) {\\n            int len = A.Length;\\n            int[] C = Enumerable.Range(0, len).ToArray();\\n            Array.Sort(A);\\n            Array.Sort(B, C);\\n            int[] res = new int[len];\\n            int end = len - 1, cur = 0;\\n            for(int i = 0; i < len; i++) {\\n                if(A[i] > B[cur]) {\\n                    res[cur] = A[i];\\n                    cur++;\\n                } else {\\n                    res[end] = A[i];\\n                    end--;\\n                }\\n            }\\n            Array.Sort(C, res);\\n            return res;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[] AdvantageCount(int[] A, int[] B) {\\n            int len = A.Length;\\n            int[] C = Enumerable.Range(0, len).ToArray();\\n            Array.Sort(A);\\n            Array.Sort(B, C);\\n            int[] res = new int[len];\\n            int end = len - 1, cur = 0;\\n            for(int i = 0; i < len; i++) {\\n                if(A[i] > B[cur]) {\\n                    res[cur] = A[i];\\n                    cur++;\\n                } else {\\n                    res[end] = A[i];\\n                    end--;\\n                }\\n            }\\n            Array.Sort(C, res);\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287152,
                "title": "binary-search-solution",
                "content": "The idea is that \\n* First sort A in ascending order.\\n* Then use priority queue to store index of B by its correspoding B[index] in desending order.\\n* For each number b in B, use a binary search in A to find smallest number that is larger than b and not visited yet, write as a. If that a does not exist, use a pointer from the begining of A to find the smallest number that is not visited, use that as a.\\n```\\n public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((x, y) -> (B[y] - B[x]));\\n        // From the largest to smallest.\\n        for (int i = 0; i < B.length; i++) {\\n            queue.add(i);\\n        }\\n        boolean[] visited = new boolean[A.length];\\n        // Use the binary search to pair each number.\\n        int[] res = new int[B.length];\\n        while (!queue.isEmpty()) {\\n            int bIndex = queue.poll();\\n            int b = B[bIndex];\\n            int a = binarySearch(A, visited, b);\\n            res[bIndex] = a;\\n        }\\n        return res;\\n    }\\n    public int binarySearch(int[] A, boolean[] visited, int b) {\\n        int left = 0;\\n        int right = A.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (A[mid] <= b) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        while (left < A.length && visited[left]) {\\n            left ++;\\n        }\\n        if (left < A.length && A[left] > b) {\\n            visited[left] = true;\\n            return A[left];\\n        }\\n        right = 0;\\n        while (right < A.length && visited[right]) {\\n            right ++;\\n        }\\n        visited[right] = true;\\n        return A[right];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((x, y) -> (B[y] - B[x]));\\n        // From the largest to smallest.\\n        for (int i = 0; i < B.length; i++) {\\n            queue.add(i);\\n        }\\n        boolean[] visited = new boolean[A.length];\\n        // Use the binary search to pair each number.\\n        int[] res = new int[B.length];\\n        while (!queue.isEmpty()) {\\n            int bIndex = queue.poll();\\n            int b = B[bIndex];\\n            int a = binarySearch(A, visited, b);\\n            res[bIndex] = a;\\n        }\\n        return res;\\n    }\\n    public int binarySearch(int[] A, boolean[] visited, int b) {\\n        int left = 0;\\n        int right = A.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (A[mid] <= b) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        while (left < A.length && visited[left]) {\\n            left ++;\\n        }\\n        if (left < A.length && A[left] > b) {\\n            visited[left] = true;\\n            return A[left];\\n        }\\n        right = 0;\\n        while (right < A.length && visited[right]) {\\n            right ++;\\n        }\\n        visited[right] = true;\\n        return A[right];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282771,
                "title": "go-one-pass-solution-without-map",
                "content": "If we record origin position of elements in `B` We can do it one pass:\\n1. if `a` (from sorted `A`) is larger than `b` (from sorted `B`), then place `a` at the index of `b`, remove `b` from `B`\\n2. else, place `a` at the index of `bb`, which is the largest element of sorted `B`. remove `bb` from `B`\\n\\n## Code\\n\\n```go\\nimport (\\n\\t\"sort\"\\n)\\n\\ntype indexedInt struct {\\n\\tidx, val int\\n}\\n\\ntype IdxList []indexedInt\\n\\nfunc (l IdxList) Len() int           { return len(l) }\\nfunc (l IdxList) Less(i, j int) bool { return l[i].val < l[j].val }\\nfunc (l IdxList) Swap(i, j int)      { l[i], l[j] = l[j], l[i] }\\n\\nfunc advantageCount(A []int, B []int) []int {\\n\\tvar ans = make([]int, len(A))\\n\\tBList := IdxList{}\\n\\tfor i, b := range B {\\n\\t\\tBList = append(BList, indexedInt{i, b})\\n\\t}\\n\\tsort.Ints(A)\\n\\tsort.Sort(BList)\\n\\tfor _, a := range A {\\n\\t\\tif a > BList[0].val {\\n\\t\\t\\tidx := BList[0].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[1:]\\n\\t\\t} else {\\n\\t\\t\\tn := BList.Len()\\n\\t\\t\\tidx := BList[n-1].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[:n-1]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nimport (\\n\\t\"sort\"\\n)\\n\\ntype indexedInt struct {\\n\\tidx, val int\\n}\\n\\ntype IdxList []indexedInt\\n\\nfunc (l IdxList) Len() int           { return len(l) }\\nfunc (l IdxList) Less(i, j int) bool { return l[i].val < l[j].val }\\nfunc (l IdxList) Swap(i, j int)      { l[i], l[j] = l[j], l[i] }\\n\\nfunc advantageCount(A []int, B []int) []int {\\n\\tvar ans = make([]int, len(A))\\n\\tBList := IdxList{}\\n\\tfor i, b := range B {\\n\\t\\tBList = append(BList, indexedInt{i, b})\\n\\t}\\n\\tsort.Ints(A)\\n\\tsort.Sort(BList)\\n\\tfor _, a := range A {\\n\\t\\tif a > BList[0].val {\\n\\t\\t\\tidx := BList[0].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[1:]\\n\\t\\t} else {\\n\\t\\t\\tn := BList.Len()\\n\\t\\t\\tidx := BList[n-1].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[:n-1]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 275497,
                "title": "python-with-explanation",
                "content": "```\\nfrom bisect import bisect_right as bs\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        r = []\\n        for n in B[:-1]:\\n            i = bs(A, n)\\n            if i == len(A):\\n                r.append(A.pop(0))\\n            else:\\n                r.append(A.pop(i)) # don\\'t use A = A[:i] + A[i + 1:], that\\'s much much slower and will cause TLE\\n        r.append(A[0])\\n        return r\\n```\\n\\nexplanation of the story of Ji Tian\\'s Horse Race (\\u7530\\u5FCC\\u8D5B\\u9A6C):\\n    About 2400 years ago, in ancient China, there was a noble called Ji Tian (\\u7530\\u5FCC) in the principality Qi (\\u9F50). One day he was having a horse race with the lord of Qi. They both had 3 horses, classified by their speeds as the best, the media and the worst. First, Tian sended his best, media and worst horse against the lord\\'s best, media and worst respectively, and they all lost. While Tian was sad, one of his hanger-ons called Bin Sun (\\u5B59\\u8191), who became a very famous strategist later, told him that even though all Tian\\'s horses lost, the gaps werer all close, so with some arrangements Tian could win the lord. Then Sun sended Tian\\'s worst horse against the lord\\'s best horse and was laughed because the gap was too big and others thought he was too crazy. You know the rest and Tian finally won with a 2:1 vs the lord.",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_right as bs\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        r = []\\n        for n in B[:-1]:\\n            i = bs(A, n)\\n            if i == len(A):\\n                r.append(A.pop(0))\\n            else:\\n                r.append(A.pop(i)) # don\\'t use A = A[:i] + A[i + 1:], that\\'s much much slower and will cause TLE\\n        r.append(A[0])\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266669,
                "title": "a-java-solution-with-treemap",
                "content": "Simple application of Java TreeMap is good enough to ace this problem.\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i = 0;i < B.length;i++) {\\n            Integer key = map.higherKey(B[i]);\\n            if (key == null) ans[i] = -1;\\n            else {\\n                ans[i] = key;\\n                map.put(key, map.get(key) - 1);\\n                if (map.get(key) == 0) map.remove(key);\\n            }\\n        }\\n        for (int i = 0;i < ans.length;i++) {\\n            if (ans[i] == -1) {\\n                int firstKey = map.firstKey();\\n                ans[i] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i = 0;i < B.length;i++) {\\n            Integer key = map.higherKey(B[i]);\\n            if (key == null) ans[i] = -1;\\n            else {\\n                ans[i] = key;\\n                map.put(key, map.get(key) - 1);\\n                if (map.get(key) == 0) map.remove(key);\\n            }\\n        }\\n        for (int i = 0;i < ans.length;i++) {\\n            if (ans[i] == -1) {\\n                int firstKey = map.firstKey();\\n                ans[i] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231399,
                "title": "swift-one-time-pass",
                "content": "```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var leftArr = [Int]()\\n        var ans = [Int](repeating: Int.min, count: A.count)\\n        var tupleArrB = [(Int, Int)]()\\n        for i in 0..<B.count {\\n            tupleArrB.append((i, B[i]))\\n        }\\n        tupleArrB.sort { $0.1 < $1.1}\\n        var sorteA = A.sorted()\\n        var aIndex = 0\\n        for (bi, v) in tupleArrB {\\n            if aIndex >= sorteA.count { break }\\n            while aIndex < sorteA.count {\\n                let a = sorteA[aIndex]\\n                aIndex += 1\\n                if a > v { ans[bi] = a; break}\\n                leftArr.append(a)\\n            }\\n        }\\n\\n        for i in 0..<ans.count {\\n            if ans[i] == Int.min {\\n                ans[i] = leftArr.removeFirst()\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var leftArr = [Int]()\\n        var ans = [Int](repeating: Int.min, count: A.count)\\n        var tupleArrB = [(Int, Int)]()\\n        for i in 0..<B.count {\\n            tupleArrB.append((i, B[i]))\\n        }\\n        tupleArrB.sort { $0.1 < $1.1}\\n        var sorteA = A.sorted()\\n        var aIndex = 0\\n        for (bi, v) in tupleArrB {\\n            if aIndex >= sorteA.count { break }\\n            while aIndex < sorteA.count {\\n                let a = sorteA[aIndex]\\n                aIndex += 1\\n                if a > v { ans[bi] = a; break}\\n                leftArr.append(a)\\n            }\\n        }\\n\\n        for i in 0..<ans.count {\\n            if ans[i] == Int.min {\\n                ans[i] = leftArr.removeFirst()\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229286,
                "title": "scala-o-n-lg-n-concise-purely-functional",
                "content": "```\\nobject Solution {\\n  def advantageCount(a: Array[Int], b: Array[Int]): Array[Int] = {\\n    val bIndicesSorted = b.indices.sortBy(b)\\n    val (bIndexToAElem, _, _) = a.sorted.foldLeft(Map[Int, Int](), 0, bIndicesSorted.length) {\\n      case ((map, start, end), elem) if elem > b(bIndicesSorted(start)) =>\\n        (map + (bIndicesSorted(start) -> elem), start + 1, end)\\n      case ((map, start, end), elem) =>\\n        (map + (bIndicesSorted(end - 1) -> elem), start, end - 1)\\n    }\\n    b.indices.map(bIndexToAElem).toArray\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def advantageCount(a: Array[Int], b: Array[Int]): Array[Int] = {\\n    val bIndicesSorted = b.indices.sortBy(b)\\n    val (bIndexToAElem, _, _) = a.sorted.foldLeft(Map[Int, Int](), 0, bIndicesSorted.length) {\\n      case ((map, start, end), elem) if elem > b(bIndicesSorted(start)) =>\\n        (map + (bIndicesSorted(start) -> elem), start + 1, end)\\n      case ((map, start, end), elem) =>\\n        (map + (bIndicesSorted(end - 1) -> elem), start, end - 1)\\n    }\\n    b.indices.map(bIndexToAElem).toArray\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 202802,
                "title": "python-greedy-to-beat-the-current-smallest-in-b",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sorted_B = sorted(B, reverse = True)\\n        assigned = {b:[] for b in B+[-1]}\\n                \\n        b = sorted_B.pop()\\n        for a in sorted(A):\\n            if a > b:\\n                assigned[b].append(a)\\n                b = sorted_B.pop() if sorted_B else -1\\n            else:\\n                assigned[-1].append(a)\\n        \\n        return [assigned[b].pop() if assigned[b] else assigned[-1].pop() for b in B]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sorted_B = sorted(B, reverse = True)\\n        assigned = {b:[] for b in B+[-1]}\\n                \\n        b = sorted_B.pop()\\n        for a in sorted(A):\\n            if a > b:\\n                assigned[b].append(a)\\n                b = sorted_B.pop() if sorted_B else -1\\n            else:\\n                assigned[-1].append(a)\\n        \\n        return [assigned[b].pop() if assigned[b] else assigned[-1].pop() for b in B]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172852,
                "title": "c-solution-using-max-heap-beats-98-88",
                "content": "// algo is to use greedy. add elements of A in max heap pq. then sort elements of B along with its original index location (you can use this by // creating a new vector containing pair(B[i],[i]) elements.\\n// navigate through sorted BB and insert pq.top() in original B\\'s index if it is greater than the BB[i].\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\tvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> result(B.size(),-1);\\n        \\n        vector<pair<int,int>> BB;\\n        for(int i=0; i<B.size(); i++)\\n            BB.push_back(make_pair(B[i],i));\\n        \\n        sort(BB.begin(), BB.end(), std::greater<pair<int,int>>());\\n        \\n        priority_queue<int> pq;\\n        for(auto a:A)\\n            pq.push(a);\\n        \\n        for(int i=0; i<BB.size(); i++)\\n            if(BB[i].first < pq.top())\\n                {result[BB[i].second] = pq.top(); pq.pop();}\\n        \\n        if(!pq.empty())\\n            for(int i=0; i<result.size(); i++)\\n                if(result[i]<0)\\n                    {result[i]=pq.top(); pq.pop();}\\n        \\n        return result;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> result(B.size(),-1);\\n        \\n        vector<pair<int,int>> BB;\\n        for(int i=0; i<B.size(); i++)\\n            BB.push_back(make_pair(B[i],i));\\n        \\n        sort(BB.begin(), BB.end(), std::greater<pair<int,int>>());\\n        \\n        priority_queue<int> pq;\\n        for(auto a:A)\\n            pq.push(a);\\n        \\n        for(int i=0; i<BB.size(); i++)\\n            if(BB[i].first < pq.top())\\n                {result[BB[i].second] = pq.top(); pq.pop();}",
                "codeTag": "Java"
            },
            {
                "id": 172218,
                "title": "short-python-beats-95-by-mapping-index-between-sorted-b-and-b",
                "content": "The main idea is building a mapping between the index of sorted(B) and B, i.e. Bmapping = sorted(range(n), key=lambda k: B[k])\\nThe meaning of every element in list Bmapping is: for the i-th smallest element in B, what is its index in B.\\nFor example, if B = [2,3,1,4,0], then sorted(B) = [0,1,2,3,4], then Bmapping = [4,2,0,1,3].\\nBy going through the index in the reverse Bmapping order, we check every item in B from the largest to the smallest.\\n\\nAt the same time, we sort A, and use 2 pointers: start mark the index of the current unused smallest element in A, and end mark the index of the current unused largest element in A. If the current B element if larger than the remaining largest element in A, then we put the smallest A element in the corresponding final result location; or else put the largest A element in the correpsonding final result location.\\n```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(B)\\n        if n < 2: return A\\n        \\n        newA = sorted(A)\\n        Bmapping = sorted(range(n), key=lambda k: B[k])\\n        \\n        finals = [0 for i in xrange(n)]\\n        start = 0\\n        end = n-1\\n        for i in Bmapping[::-1]:\\n            if B[i] >= newA[end]:\\n                finals[i] = newA[start]\\n                start += 1\\n            else:\\n                finals[i] = newA[end]\\n                end -= 1\\n                \\n        return finals\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(B)\\n        if n < 2: return A\\n        \\n        newA = sorted(A)\\n        Bmapping = sorted(range(n), key=lambda k: B[k])\\n        \\n        finals = [0 for i in xrange(n)]\\n        start = 0\\n        end = n-1\\n        for i in Bmapping[::-1]:\\n            if B[i] >= newA[end]:\\n                finals[i] = newA[start]\\n                start += 1\\n            else:\\n                finals[i] = newA[end]\\n                end -= 1\\n                \\n        return finals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155798,
                "title": "10-lines-javascript-solution-with-deque",
                "content": "```js\\nfunction advantageCount(A, B) {\\n  const idxs = B.map((v, i) => i).sort((a, b) => B[b]-B[a]);\\n  A.sort((a, b) => b-a);\\n  \\n  const res = [];\\n  for (let i = 0; i < B.length; i++) {\\n    res[idxs[i]] = A[0] > B[idxs[i]] ? A.shift() : A.pop();\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction advantageCount(A, B) {\\n  const idxs = B.map((v, i) => i).sort((a, b) => B[b]-B[a]);\\n  A.sort((a, b) => b-a);\\n  \\n  const res = [];\\n  for (let i = 0; i < B.length; i++) {\\n    res[idxs[i]] = A[0] > B[idxs[i]] ? A.shift() : A.pop();\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150105,
                "title": "c-straight-forward-solution-using-multiset-details-explained",
                "content": "//  Greedy method solution.\\n//  Insert all elements of `A` into a multiset, now all are sorted,\\n//  For each element of `B[i]`, find the smallest element of `A` which is `>` than `B`, when found store it at `i-th` position of `A`.\\n// if not found, store the smallest element of A at `i-th` position.\\n```\\n    \\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> ss(begin(A), end(A));      //  create a multiset with A\\'s elements.\\n        \\n        for (auto i = 0; i < B.size(); ++i) {\\n\\n            auto p = ss.upper_bound(B[i]);       //  Find the smallest value in A which is > B[i].\\n\\n            if(p != ss.end()) A[i] = *p;         //  when found, store that element at i-th position of A.\\n\\n            else {p = ss.begin(); A[i] = *p;}    //  if not-found, store the smallest element at i-th position of A.\\n\\n    ss.erase(p);\\n  }\\n  return A;\\n} \\n```",
                "solutionTags": [],
                "code": "```\\n    \\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> ss(begin(A), end(A));      //  create a multiset with A\\'s elements.\\n        \\n        for (auto i = 0; i < B.size(); ++i) {\\n\\n            auto p = ss.upper_bound(B[i]);       //  Find the smallest value in A which is > B[i].\\n\\n            if(p != ss.end()) A[i] = *p;         //  when found, store that element at i-th position of A.\\n\\n            else {p = ss.begin(); A[i] = *p;}    //  if not-found, store the smallest element at i-th position of A.\\n\\n    ss.erase(p);\\n  }\\n  return A;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150094,
                "title": "java-treemap-greedy-method-w-explanations-o-nlogn-time-o-n-space",
                "content": "The idea of greedy method is to:\\nFor each element in B, select the smallest element in A that satisfies A > B. If there is no such element, find the smallest element in A.\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        //Put nums in A into TreeMap\\n        TreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();\\n        for (int n : A){\\n            if (!tm.containsKey(n - 1)) tm.put(n - 1, 1);\\n            else tm.put(n - 1, tm.get(n - 1) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        int cur = -1;\\n        for (int i = 0; i < B.length; i++){\\n            if (tm.ceilingKey(B[i]) == null){\\n                cur = tm.firstKey();\\n            } else {\\n                cur = tm.ceilingKey(B[i]);\\n            }\\n            ans[i] = cur + 1;\\n            if (tm.get(cur) == 1) tm.remove(cur);\\n            else tm.put(cur, tm.get(cur) - 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        //Put nums in A into TreeMap\\n        TreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();\\n        for (int n : A){\\n            if (!tm.containsKey(n - 1)) tm.put(n - 1, 1);\\n            else tm.put(n - 1, tm.get(n - 1) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        int cur = -1;\\n        for (int i = 0; i < B.length; i++){\\n            if (tm.ceilingKey(B[i]) == null){\\n                cur = tm.firstKey();\\n            } else {\\n                cur = tm.ceilingKey(B[i]);\\n            }\\n            ans[i] = cur + 1;\\n            if (tm.get(cur) == 1) tm.remove(cur);\\n            else tm.put(cur, tm.get(cur) - 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149908,
                "title": "c-solution-sort-both-in-descending-order-and-find-closest-match",
                "content": " * sort both in descending order and find closest match\\n * stored not matched positions in B, then fill by not matched numbers in A\\n```\\npublic class Solution {\\n    public class Sorted {\\n        public int b;\\n        public int position;\\n    }\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        List<int> o = new List<int>();\\n        for(int c = 0; c < A.Length; c++)\\n            o.Add(-1);\\n        int[] output = o.ToArray<int>();\\n        var listB = new List<Sorted>();\\n        for(int bc = 0; bc < B.Length; bc++)\\n            listB.Add(new Sorted() { b = B[bc], position = bc });\\n        var sortedB = listB.ToArray<Sorted>();\\n        Array.Sort(sortedB, (s1, s2) => s2.b - s1.b);\\n        var positions = new HashSet<int>();\\n        for(int p = 0; p < A.Length; p++)\\n            positions.Add(p);\\n        var notPaired = new List<int>();\\n        Array.Sort(A, (a1, a2) => a2 - a1);\\n        foreach(int a in A) {\\n            int selection = -1;\\n            for(int bc = 0; bc < sortedB.Length; bc++)\\n                if (output[sortedB[bc].position] == -1 && a > sortedB[bc].b) {\\n                    selection = sortedB[bc].position;\\n                    break;\\n                }\\n            if (selection != -1) {\\n                positions.Remove(selection);\\n                output[selection] = a;\\n            } else {\\n                notPaired.Add(a);\\n            }\\n        }\\n        int np = 0;\\n        foreach(int oc in positions) {\\n            output[oc] = notPaired[np];\\n            np++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public class Sorted {\\n        public int b;\\n        public int position;\\n    }\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        List<int> o = new List<int>();\\n        for(int c = 0; c < A.Length; c++)\\n            o.Add(-1);\\n        int[] output = o.ToArray<int>();\\n        var listB = new List<Sorted>();\\n        for(int bc = 0; bc < B.Length; bc++)\\n            listB.Add(new Sorted() { b = B[bc], position = bc });\\n        var sortedB = listB.ToArray<Sorted>();\\n        Array.Sort(sortedB, (s1, s2) => s2.b - s1.b);\\n        var positions = new HashSet<int>();\\n        for(int p = 0; p < A.Length; p++)\\n            positions.Add(p);\\n        var notPaired = new List<int>();\\n        Array.Sort(A, (a1, a2) => a2 - a1);\\n        foreach(int a in A) {\\n            int selection = -1;\\n            for(int bc = 0; bc < sortedB.Length; bc++)\\n                if (output[sortedB[bc].position] == -1 && a > sortedB[bc].b) {\\n                    selection = sortedB[bc].position;\\n                    break;\\n                }\\n            if (selection != -1) {\\n                positions.Remove(selection);\\n                output[selection] = a;\\n            } else {\\n                notPaired.Add(a);\\n            }\\n        }\\n        int np = 0;\\n        foreach(int oc in positions) {\\n            output[oc] = notPaired[np];\\n            np++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149895,
                "title": "java-solution-using-treemap",
                "content": "Usint treemap to get the optimized solution for each B[i], if we cant get anything bigger than B[i], just use the least value.\\n\\n```\\n\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> a = new TreeMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.containsKey(A[i])) {\\n                a.put(A[i], a.get(A[i]) + 1);\\n            } else {\\n                a.put(A[i], 1);\\n            }\\n        }\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.higherKey(B[i]) != null && a.get(a.higherKey(B[i])) > 0) {\\n                res[i] = a.higherKey(B[i]);\\n                a.put(a.higherKey(B[i]), a.get(a.higherKey(B[i])) - 1);\\n                if (a.get(a.higherKey(B[i])) == 0) {\\n                    a.remove(a.higherKey(B[i]));\\n                }\\n            } else {\\n                int key = a.firstKey();\\n                res[i] = key;\\n                a.put(key, a.get(key) - 1);\\n                if (a.get(key) == 0) {\\n                    a.remove(key);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> a = new TreeMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.containsKey(A[i])) {\\n                a.put(A[i], a.get(A[i]) + 1);\\n            } else {\\n                a.put(A[i], 1);\\n            }\\n        }\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.higherKey(B[i]) != null && a.get(a.higherKey(B[i])) > 0) {\\n                res[i] = a.higherKey(B[i]);\\n                a.put(a.higherKey(B[i]), a.get(a.higherKey(B[i])) - 1);\\n                if (a.get(a.higherKey(B[i])) == 0) {\\n                    a.remove(a.higherKey(B[i]));\\n                }\\n            } else {\\n                int key = a.firstKey();\\n                res[i] = key;\\n                a.put(key, a.get(key) - 1);\\n                if (a.get(key) == 0) {\\n                    a.remove(key);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149880,
                "title": "greedy-approach-using-treemap",
                "content": "Put the array A in a TreeMap with a following structure : \\n`key : number , value : count `\\n\\nParse the Array B, while filling the result as follows : \\nfor any element `num` in B\\n1. find the next value greater that `num` in treemap and put in result. \\n2. If no greater value exists put the smallest value in the result. \\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length; \\n        TreeMap<Integer, Integer> map  = new TreeMap<>(); \\n        for(int num : A)\\n            map.put(num, map.getOrDefault(num, 0)+1); \\n        int[] nA = new int[n]; \\n        for(int i = 0 ; i < n ; ++i){\\n            int val = B[i]; \\n            int key = map.higherKey(val) == null ? map.firstKey() : map.higherKey(val); \\n            map.put(key, map.get(key)-1); \\n            if(map.get(key) == 0)\\n                map.remove(key); \\n            nA[i] = key;\\n        }\\n        return nA; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length; \\n        TreeMap<Integer, Integer> map  = new TreeMap<>(); \\n        for(int num : A)\\n            map.put(num, map.getOrDefault(num, 0)+1); \\n        int[] nA = new int[n]; \\n        for(int i = 0 ; i < n ; ++i){\\n            int val = B[i]; \\n            int key = map.higherKey(val) == null ? map.firstKey() : map.higherKey(val); \\n            map.put(key, map.get(key)-1); \\n            if(map.get(key) == 0)\\n                map.remove(key); \\n            nA[i] = key;\\n        }\\n        return nA; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149832,
                "title": "easy-understand-java-greedy-solution",
                "content": "  Sort A upfront. If A[i] <= B[i], find the first number in A[i+1, n) that is bigger than B[i] and shift A. At this moment, A[0, i] are fixed. \\n\\t \\n\\t \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        for (int i=0; i<A.length; i++) {\\n            if (A[i] <= B[i]) {\\n                for (int j=i+1; j<A.length; j++) {\\n                    if (A[j] > B[i]) {\\n                        shift(A, i, j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    public void shift(int[] A, int i, int j) {\\n        int tmp = A[j];\\n        for (int k=j; k>i; k--) {\\n            A[k] = A[k-1];\\n        }\\n        A[i] = tmp;\\n    }",
                "solutionTags": [],
                "code": "  Sort A upfront. If A[i] <= B[i], find the first number in A[i+1, n) that is bigger than B[i] and shift A. At this moment, A[0, i] are fixed. \\n\\t \\n\\t \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        for (int i=0; i<A.length; i++) {\\n            if (A[i] <= B[i]) {\\n                for (int j=i+1; j<A.length; j++) {\\n                    if (A[j] > B[i]) {\\n                        shift(A, i, j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    public void shift(int[] A, int i, int j) {\\n        int tmp = A[j];\\n        for (int k=j; k>i; k--) {\\n            A[k] = A[k-1];\\n        }\\n        A[i] = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 149824,
                "title": "simple-python-solution-based-on-binary-search",
                "content": "```\\n    def advantageCount(self, a, b):\\n        b = sorted(enumerate(b), key=lambda x: x[1])\\n        sorted_a = sorted(a)\\n\\n        unused, prev, res = set(range(len(a))), 0, [0] * len(a)\\n        for i in range(len(b)):\\n            idx = bisect_right(sorted_a, b[i][1], prev)\\n            if idx != len(a):\\n                res[b[i][0]] = sorted_a[idx]\\n                unused.remove(idx)\\n                prev = idx + 1\\n            else:\\n                res[b[i][0]] = sorted_a[unused.pop()]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def advantageCount(self, a, b):\\n        b = sorted(enumerate(b), key=lambda x: x[1])\\n        sorted_a = sorted(a)\\n\\n        unused, prev, res = set(range(len(a))), 0, [0] * len(a)\\n        for i in range(len(b)):\\n            idx = bisect_right(sorted_a, b[i][1], prev)\\n            if idx != len(a):\\n                res[b[i][0]] = sorted_a[idx]\\n                unused.remove(idx)\\n                prev = idx + 1\\n            else:\\n                res[b[i][0]] = sorted_a[unused.pop()]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4054593,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int val = pair[1];\\n            if (nums1[right] > val) {\\n                res[i] = nums1[right];\\n                right--;\\n            }\\n            else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<int>res(n);\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++)\\n        p.push_back({nums2[i],i});\\n        sort(p.begin(), p.end());\\n        int l=0, r=n-1;\\n        for(int x : nums1){\\n            if(p[l].first < x)\\n            res[p[l++].second]=x;\\n\\n            else\\n            res[p[r--].second] =x;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int val = pair[1];\\n            if (nums1[right] > val) {\\n                res[i] = nums1[right];\\n                right--;\\n            }\\n            else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<int>res(n);\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++)\\n        p.push_back({nums2[i],i});\\n        sort(p.begin(), p.end());\\n        int l=0, r=n-1;\\n        for(int x : nums1){\\n            if(p[l].first < x)\\n            res[p[l++].second]=x;\\n\\n            else\\n            res[p[r--].second] =x;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045950,
                "title": "python-video-walkthrough-time-o-nlogn-space-o-n",
                "content": "[Click Here For Video](https://youtu.be/nz0_sRskx5U)\\n```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        I, res, _ = deque(sorted(range(len(nums2)),key = lambda idx: nums2[idx])), [-1] * len(nums1), nums1.sort()\\n        for boy in nums1:\\n            if boy > nums2[I[0]]: res[I.popleft()] = boy\\n            else: res[I.pop()] = boy\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        I, res, _ = deque(sorted(range(len(nums2)),key = lambda idx: nums2[idx])), [-1] * len(nums1), nums1.sort()\\n        for boy in nums1:\\n            if boy > nums2[I[0]]: res[I.popleft()] = boy\\n            else: res[I.pop()] = boy\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006265,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        Integer[] index = new Integer[nums2.length];\\n        for(int i = 0; i < nums2.length; i++){\\n            index[i] = i;\\n        }\\n        Arrays.sort(index, (a, b) -> (nums2[a] - nums2[b]));\\n        Arrays.sort(nums1);\\n        int[] res = new int[nums1.length];\\n        int i = 0, j = nums1.length - 1;\\n        for(int k = nums2.length - 1; k >= 0; k--){\\n            int num = nums2[index[k]];\\n            if(nums1[j] > num){\\n                res[index[k]] = nums1[j];\\n                j--;\\n            }else{\\n                res[index[k]] = nums1[i];\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        Integer[] index = new Integer[nums2.length];\\n        for(int i = 0; i < nums2.length; i++){\\n            index[i] = i;\\n        }\\n        Arrays.sort(index, (a, b) -> (nums2[a] - nums2[b]));\\n        Arrays.sort(nums1);\\n        int[] res = new int[nums1.length];\\n        int i = 0, j = nums1.length - 1;\\n        for(int k = nums2.length - 1; k >= 0; k--){\\n            int num = nums2[index[k]];\\n            if(nums1[j] > num){\\n                res[index[k]] = nums1[j];\\n                j--;\\n            }else{\\n                res[index[k]] = nums1[i];\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916789,
                "title": "python3",
                "content": "# Intuition\\n\\nsort nums2 desc\\nsort nums1 asc\\nif the max val in nums1 is less than the max val in nums2,\\nchoose the min val in nums1\\n\\n# Code\\n```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n\\n        heap = []\\n        for i, num in enumerate(nums2):\\n            heapq.heappush(heap, (-num, i))\\n        print(\\'heap\\', heap)\\n\\n        left, right = 0, len(nums1)-1\\n        res = [0]*(len(nums1))\\n\\n        while heap:\\n            maxnum2, idx = heapq.heappop(heap)\\n            print(\\'22\\', maxnum2, idx)\\n            maxnum2 = -maxnum2\\n            \\n          \\n            if maxnum2 < nums1[right]:\\n                res[idx] = nums1[right]\\n                right -= 1\\n            else:\\n                res[idx] = nums1[left]\\n                left += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n\\n        heap = []\\n        for i, num in enumerate(nums2):\\n            heapq.heappush(heap, (-num, i))\\n        print(\\'heap\\', heap)\\n\\n        left, right = 0, len(nums1)-1\\n        res = [0]*(len(nums1))\\n\\n        while heap:\\n            maxnum2, idx = heapq.heappop(heap)\\n            print(\\'22\\', maxnum2, idx)\\n            maxnum2 = -maxnum2\\n            \\n          \\n            if maxnum2 < nums1[right]:\\n                res[idx] = nums1[right]\\n                right -= 1\\n            else:\\n                res[idx] = nums1[left]\\n                left += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915209,
                "title": "java-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to sort the two arrays, but we can\\'t change the order of the elements in nums2, because the order of the results depends on the order of nums2, so we can\\'t sort nums2 directly, need to use other data structures to help.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        // sort nums2 in descending order\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n        // sort nums1 in ascending order\\n        Arrays.sort(nums1);\\n\\n        // nums1[left] is the minimum, nums1[right] is the maximum\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int maxval = pair[1];\\n            if (nums1[right] > maxval) {\\n                res[i] = nums1[right];\\n                right--;\\n            } else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        // sort nums2 in descending order\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n        // sort nums1 in ascending order\\n        Arrays.sort(nums1);\\n\\n        // nums1[left] is the minimum, nums1[right] is the maximum\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int maxval = pair[1];\\n            if (nums1[right] > maxval) {\\n                res[i] = nums1[right];\\n                right--;\\n            } else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911784,
                "title": "java-simple-sol-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < nums1.length; i++){\\n            map.put(nums1[i],map.getOrDefault(nums1[i],0)+1);\\n        }\\n        int []arr= new int[nums1.length];\\n        for(int i=0;i<nums1.length;i++){\\n            Map.Entry<Integer,Integer> lrgr=map.higherEntry(nums2[i]);\\n            if(lrgr==null){\\n                Map.Entry<Integer,Integer> smlr = map.firstEntry();\\n                arr[i]= smlr.getKey();\\n                if(smlr.getValue()==1){map.remove(smlr.getKey());}\\n                else{map.put(smlr.getKey(),smlr.getValue()-1);}\\n\\n            }\\n            else{\\n                arr[i]= lrgr.getKey();\\n                if(lrgr.getValue()==1){map.remove(lrgr.getKey());}\\n                else{map.put(lrgr.getKey(),lrgr.getValue()-1);}\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < nums1.length; i++){\\n            map.put(nums1[i],map.getOrDefault(nums1[i],0)+1);\\n        }\\n        int []arr= new int[nums1.length];\\n        for(int i=0;i<nums1.length;i++){\\n            Map.Entry<Integer,Integer> lrgr=map.higherEntry(nums2[i]);\\n            if(lrgr==null){\\n                Map.Entry<Integer,Integer> smlr = map.firstEntry();\\n                arr[i]= smlr.getKey();\\n                if(smlr.getValue()==1){map.remove(smlr.getKey());}\\n                else{map.put(smlr.getKey(),smlr.getValue()-1);}\\n\\n            }\\n            else{\\n                arr[i]= lrgr.getKey();\\n                if(lrgr.getValue()==1){map.remove(lrgr.getKey());}\\n                else{map.put(lrgr.getKey(),lrgr.getValue()-1);}\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565493,
                "content": [
                    {
                        "username": "Yuandong-Chen",
                        "content": "Why greedy algorithm? The official solution don\\'t justify the correctness of greedy algorithm, so as many posts did. I think it is necessary to prove the correctness. (I think this is the first post in the discuss to prove the algorithm itself for this problem)\\n\\nWithout loss of generality, suppose A and B is sorted, for example, A = [2, 4, 6, 10]\\nB = [1, 3, 3, 17]. For any permutation of P(A), we can always find the equivalent permutation P*(A) = [a_0, a_1, ..., a_n] that has the same adavantage as P(A) and also has following property (named as GP):\\n\\n\\tThere exists integer k in [0, n], such that:\\n    (a) a_i > b_i for any [0, k] and a_i <= b_i for any [k+1, n]\\n\\t(b) Also for any 0<= i < j <=k, a_i <= a_j\\nWhat does this GP tell us? Since the advantage of any permutation of GP is k by definition, our goal is to enlarge k. Also find that, permutation of GP is a non-decreasing array until k. It is clear that the greedy strategy as follows could always find the maximum advantage permutation of GP:\\nB[0] = 1, we find the left most element in A that is larger than B[0] is 2, so P*(A)[0] = 2\\nB[1] = 3, so P*(A)[1] = 4\\nB[2] = 3, so P*(A)[2] = 6 since 4 is already taken for B[1]\\nB[3] = 17, so P*(A)[3] = 10, since we have no element in A that is larger than 17, it doesn\\'t matter to choose any element left over.\\n\\nThe only left question is how to transfer any permutation to its equivalent permutation of GP. Actually, it is quite easy. Suppose we have permutation P:\\n\\nIf P(A)[i] < B[i], and also j > i, P(A)[j] > B[j], we rearrange it and let B[i] <--> P(A)[j] and B[j] <--> P(A)[i], since P(A)[j] > B[j] > B[i] (note: B is sorted), P(A)[i] < B[i] < B[j], it doesn\\'t change the advantge of Permutation, but after limited number of this operations, we achieve the (a) part of GP.\\n\\nwhat about (b) part of GP? 0<= i < j < =k, P(A)[i] < B[i], P(A)[j] < B[j] and P(A)[i] >= P(A)[j], we just rearrange it as before let B[i] <--> P(A)[j], B[j] <--> P(A)[i]. Obviously, it also doesn\\'t change the advantage of Permutation.\\n\\nQED\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] sortedA = A.clone();\\n        Arrays.sort(sortedA);\\n        int[] sortedB = B.clone();\\n        Arrays.sort(sortedB);\\n\\n        // assigned[b] = list of a that are assigned to beat b\\n        Map<Integer, Deque<Integer>> assigned = new HashMap();\\n        for (int b: B) assigned.put(b, new LinkedList());\\n\\n        // remaining = list of a that are not assigned to any b\\n        Deque<Integer> remaining = new LinkedList();\\n\\n        // populate (assigned, remaining) appropriately\\n        // sortedB[j] is always the smallest unassigned element in B\\n        int j = 0;\\n        for (int a: sortedA) {\\n            if (a > sortedB[j]) {\\n                assigned.get(sortedB[j++]).add(a);\\n            } else {\\n                remaining.add(a);\\n            }\\n        }\\n\\n        // Reconstruct the answer from annotations (assigned, remaining)\\n        int[] ans = new int[B.length];\\n        for (int i = 0; i < B.length; ++i) {\\n            // if there is some a assigned to b...\\n            if (assigned.get(B[i]).size() > 0)\\n                ans[i] = assigned.get(B[i]).pop();\\n            else\\n                ans[i] = remaining.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1764221,
                "content": [
                    {
                        "username": "Yuandong-Chen",
                        "content": "Why greedy algorithm? The official solution don\\'t justify the correctness of greedy algorithm, so as many posts did. I think it is necessary to prove the correctness. (I think this is the first post in the discuss to prove the algorithm itself for this problem)\\n\\nWithout loss of generality, suppose A and B is sorted, for example, A = [2, 4, 6, 10]\\nB = [1, 3, 3, 17]. For any permutation of P(A), we can always find the equivalent permutation P*(A) = [a_0, a_1, ..., a_n] that has the same adavantage as P(A) and also has following property (named as GP):\\n\\n\\tThere exists integer k in [0, n], such that:\\n    (a) a_i > b_i for any [0, k] and a_i <= b_i for any [k+1, n]\\n\\t(b) Also for any 0<= i < j <=k, a_i <= a_j\\nWhat does this GP tell us? Since the advantage of any permutation of GP is k by definition, our goal is to enlarge k. Also find that, permutation of GP is a non-decreasing array until k. It is clear that the greedy strategy as follows could always find the maximum advantage permutation of GP:\\nB[0] = 1, we find the left most element in A that is larger than B[0] is 2, so P*(A)[0] = 2\\nB[1] = 3, so P*(A)[1] = 4\\nB[2] = 3, so P*(A)[2] = 6 since 4 is already taken for B[1]\\nB[3] = 17, so P*(A)[3] = 10, since we have no element in A that is larger than 17, it doesn\\'t matter to choose any element left over.\\n\\nThe only left question is how to transfer any permutation to its equivalent permutation of GP. Actually, it is quite easy. Suppose we have permutation P:\\n\\nIf P(A)[i] < B[i], and also j > i, P(A)[j] > B[j], we rearrange it and let B[i] <--> P(A)[j] and B[j] <--> P(A)[i], since P(A)[j] > B[j] > B[i] (note: B is sorted), P(A)[i] < B[i] < B[j], it doesn\\'t change the advantge of Permutation, but after limited number of this operations, we achieve the (a) part of GP.\\n\\nwhat about (b) part of GP? 0<= i < j < =k, P(A)[i] < B[i], P(A)[j] < B[j] and P(A)[i] >= P(A)[j], we just rearrange it as before let B[i] <--> P(A)[j], B[j] <--> P(A)[i]. Obviously, it also doesn\\'t change the advantage of Permutation.\\n\\nQED\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] sortedA = A.clone();\\n        Arrays.sort(sortedA);\\n        int[] sortedB = B.clone();\\n        Arrays.sort(sortedB);\\n\\n        // assigned[b] = list of a that are assigned to beat b\\n        Map<Integer, Deque<Integer>> assigned = new HashMap();\\n        for (int b: B) assigned.put(b, new LinkedList());\\n\\n        // remaining = list of a that are not assigned to any b\\n        Deque<Integer> remaining = new LinkedList();\\n\\n        // populate (assigned, remaining) appropriately\\n        // sortedB[j] is always the smallest unassigned element in B\\n        int j = 0;\\n        for (int a: sortedA) {\\n            if (a > sortedB[j]) {\\n                assigned.get(sortedB[j++]).add(a);\\n            } else {\\n                remaining.add(a);\\n            }\\n        }\\n\\n        // Reconstruct the answer from annotations (assigned, remaining)\\n        int[] ans = new int[B.length];\\n        for (int i = 0; i < B.length; ++i) {\\n            // if there is some a assigned to b...\\n            if (assigned.get(B[i]).size() > 0)\\n                ans[i] = assigned.get(B[i]).pop();\\n            else\\n                ans[i] = remaining.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    }
                ]
            }
        ]
    }
]