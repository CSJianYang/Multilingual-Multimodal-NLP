[
    {
        "title": "Encrypt and Decrypt Strings",
        "question_content": "You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.\nA string is encrypted with the following process:\n\n\tFor each character c in the string, we find the index i satisfying keys[i] == c in keys.\n\tReplace c with values[i] in the string.\n\nNote that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string \"\" is returned.\nA string is decrypted with the following process:\n\n\tFor each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.\n\tReplace s with keys[i] in the string.\n\nImplement the Encrypter class:\n\n\tEncrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.\n\tString encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.\n\tint decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\nOutput\n[null, \"eizfeiam\", 2]\nExplanation\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // return \"eizfeiam\". \n&nbsp;                          // 'a' maps to \"ei\", 'b' maps to \"zf\", 'c' maps to \"ei\", and 'd' maps to \"am\".\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" can map to 'a' or 'c', \"zf\" maps to 'b', and \"am\" maps to 'd'. \n                              // Thus, the possible strings after decryption are \"abad\", \"cbad\", \"abcd\", and \"cbcd\". \n                              // 2 of those strings, \"abad\" and \"abcd\", appear in dictionary, so the answer is 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= keys.length == values.length <= 26\n\tvalues[i].length == 2\n\t1 <= dictionary.length <= 100\n\t1 <= dictionary[i].length <= 100\n\tAll keys[i] and dictionary[i] are unique.\n\t1 <= word1.length <= 2000\n\t1 <= word2.length <= 200\n\tAll word1[i] appear in keys.\n\tword2.length is even.\n\tkeys, values[i], dictionary[i], word1, and word2 only contain lowercase English letters.\n\tAt most 200 calls will be made to encrypt and decrypt in total.",
        "solutions": [
            {
                "id": 1909025,
                "title": "java-c-python-two-hashmaps-with-explanation",
                "content": "# **Explanation**\\nThe hashmap `enc` help binding each paire of `keys[i]` and `values[i]`,\\nso that we can encrypt a char to the string in `O(1)`\\n\\n`count` counts the frequency of words in `dictionary` after `encrypt`,\\nthen we can used in `decrypt` in `O(1)`.\\n<br>\\n\\n# **Complexity**\\n`Encrypter`  Time `O(n)`      Space `O(n)`\\n`encrypt`    Time `O(word1)`  Space `O(word1)`\\n`decrypt`    Time `O(1)`      Space `O(1)`\\n<br>\\n\\n# **Note**\\nNot all word can be \"encrypt\", \\nFor character `c`, if we can\\'t find the index `i` satisfying `keys[i] == c` in keys.\\nThe behavior are **NOT** clearly defined.\\n\\nIn my opinion we should do nothing but keep the original character, \\n(the standard solution of OJ doesn\\'t work as I suggest)\\n\\nThese kind of test cases are not present in the original test cases set,\\nbut recedntly blindly added to the test cases.\\n\\nThe descrption of probelm should be fixed, not blindly add an appropriat test cases.\\n\\nIt\\'s like, a bug is reported and not guarded by tests, \\nthen LC adds a test but not fix anything at all.\\n\\n\\n**Java**\\n```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\\n\\n**Python**\\n3-lines Python.\\n`decrypt` method is not missing, `defined` in `init`\\nI remoded unnecessay code from default template.\\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908722,
                "title": "easy-understanding-c-code-with-comments-without-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n**Upvote if it helps!\\uD83D\\uDE4C**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908714,
                "title": "c-simple-solution-w-explanation-hashmap-trie-dfs-hashmap-preprocess",
                "content": "\\n\\u2714\\uFE0F ***Solution - I  (Hashmap + Trie)***\\n\\nWe are given an array of characters `K`, an array of strings `V` and another array of strings `D`.\\nA string `W` is encrypted by replacing each character `c`, found at `K[i]` with `V[i]` (only single possible index `i`).\\nA string `W` is decrypted by replacing every 2-character substring `s`, found at `V[i]` with `K[i]` for all possible `i`. This decrypted value must be present in `D`.\\n\\n**Encryption:**\\n* The encryption process is straight-forward wherein for every character `c` in given word `W`, we need to find  `c`\\'s index `i` in `K` & replace it with corresponding string in `V`, i.e `V[i]`. \\n* For this, we can use a hashmap `K_V` to keep mapping between each key and value.\\n\\n**Decryption:**\\n* For decryption, there can be multiple choices for replacement of a substring of length 2 and we need to consider each of them to find count of possible decryptions. \\n* But for efficient decryption process, we need to eliminate a choice as soon as we know that it wont be found in `D`. \\n* For this, we can maintain Trie consisting of all strings from `D` & we stop further exploration as soon as we find that current choice wont lead to a string present in the trie.\\n* We also keep a hashmap `V_Ks` to map a value in `V` to all possible keys in `K`.\\n\\n**C++**\\n```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II  (Hashmap + Pre-process)***\\n\\nWe can also preprocess and keep all possible encrypted strings that can be obtained by encrypting strings in `D`. Then we can directly return the count of strings which could lead to a given encrypted string `W`.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908702,
                "title": "encrypted-dictionary-vs-trie",
                "content": "#### Approach 1: Encrypted Dictionary\\nI did not see this, but it makes sense. If we encrypt all words in the dictionary, some of those words may have the same encrypted representation.\\n\\nWe could store the number of dictionary words for each encrypted representation in hash map `m`, and return this count in the `decrypt` function.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\\n\\n#### Approach 2: Trie\\nWe need to pay attention to the `decrypt` function. If we check for a valid word in the end, we will get TLE.\\n    \\nTherefore, we need to use Trie so we can prune invalid words as we go.\\n    \\n**C++**\\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908833,
                "title": "python-hashmap-counter-solution-with-detailed-explanations-very-clean-concise",
                "content": "This is the first time I get AK over the past few months. I would like to share my solution with the LC community.\\n\\n**Intuition**\\nThe given constraints are not large, we can pre-compute all necessary quantities only once.\\n\\n\\n**Explanation**\\nWe can pre-compute two hashmaps as follows:\\n\\n(1) The first hashmap `self.hashmap` is a encryption map - we map each key with their encrypted values, which is straightforward.\\n(2) The second hashmap `self.dictmap` is a `Counter` - we encrypt each word in the given `dictionary` and use the encrypted string as the key and increase the counter by 1. As such, we have solved the duplication problem of the `decrypt()` method.\\n\\n**Complexity**\\nTime in `__init__()`: `O(sum(dictionary[i].length))`, which gets amortized over later function calls\\nSpace in `__init__()`: `O(dictionary.length)`\\nTime in `encrypt()`: `O(word1.length)`\\nSpace in `encrypt()`: `O(1)` (if not counting the `output` string)\\nTime in `decrypt()`: `O(1)`\\nSpace in `decrypt()`: `O(1)`\\n\\n\\nBelow is my in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n**Follow up** (for self-learning purpose): The `encrypt()` method can be written as follows to handle more general test cases (given in the Comments section).\\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908706,
                "title": "c-maps-fastest",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908902,
                "title": "python-very-simple-code",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908891,
                "title": "java-solution-with-description-pre-process-dictionary-o-1-decrypt",
                "content": "**Approach**: \\nWhenever decrypt(word) is called decrypt the word. However `values` contains duplicates and it will match to different keys and our descrypt can have many answers. \\nSo, total number of combinations you can achieve is really high and checking every value to dictionary is not a feasible solution.\\n\\nTo overcome that instead of processing word in decrypt(word), pre-process all values in dictionary before. As given there are at most 100 words in dictionary so, encrypt that. As any encryption can lead to same string, store the count of each encryption. This way whenever decrypt is called, just seach that string in our Map and return the count.\\n\\n**Time complexity**:\\n\\nEncrypt: O(n), n: length of word\\nDecrypt: O(1)\\nClass define Encrypter : O(n*m), where n: length of longest word in dictionary, m = dictionary.length\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2778107,
                "title": "java-solutions",
                "content": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908980,
                "title": "java-trie-map-with-trie-node-class-implementation",
                "content": "The approach is to first encrypt the words of the dictionary and store them in a trie with a count of each words.\\nNext, what\\'s left is just traversing over the trie with decrypted word to get the count.\\n**Please upvote if you got the solution.**\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\nQueries and discussions regarding the implementation are most welcome.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908851,
                "title": "c-short-hash-map",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Hash Map\\n\\n`encrypt` is straightforward. For `decrypt`, we can precompute ans store the frequencies of encrypted permitted value strings in a map `freq`, and return `freq[word]` in `decrypt`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\\n\\nThe problem didn\\'t say clearly whether a permitted original string might include unsupported keys. If it might include, then we need to consider the following testcase:\\n\\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979556,
                "title": "java-c-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n\\n***Java***\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961804,
                "title": "python3-hash-table-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f2b4a5c0268eb27201b136764bb0b6ad3880c6f6) for solutions of weekly 287.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909284,
                "title": "c-hashmap-based-solution-why-is-this-problem-marked-as-hard",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1909054,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908746,
                "title": "java-solution-using-hashmaps",
                "content": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908740,
                "title": "python-trie-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Trie Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\n* key2Value:  It is a **one to one map** from key to value, so we could just creat a key2Value hashMap easily\\n* value2Key: It is a **one to many map** from value back to keys, so we use defaultdict(list) to store all keys\\n* trieDict: We build our dictionary in a trie, beacuse when we decrypt from value2Key. There are too many possible that could generate Memory Limit Exceed\\n\\tSo we could use a trie, once we found currChar is not in our currNode. We don\\'t have to traverse all remaining possible.\\n\\t\\n* **func buildTrie** : Init a trie = {}, iterate through all words in dictionary. And iterate through char in word to build a trie\\n* **encrypt**: Iterate through word1 to map all char to its value. And append it in res. Finnally stringfy res and return.\\n* **decrypt** : This is the hard part in this question\\n1. Find all posiible from value2Key: For example ```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.``` ```So possible = [[a,c] , [b], [a,c], [d]]```\\n2. findInTrie: Given possibles, DFS search from possible in our self.trieDict. If current word is valid res += 1.\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.```\n```So possible = [[a,c] , [b], [a,c], [d]]```\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775969,
                "title": "c-easy-faster",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909590,
                "title": "easiest-hard-probelm-logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n\\n#### **LOGIC**\\n* Map vector ```keys``` to ```values``` so that we do not need to loop through ```keys``` to find correct value.\\n* ```dictionary``` is having all decrypted string, so we will encrypt them and see if the result match to the ```word2``` if so, then increase ```sol``` by 1.\\n* If you crete all decrypted string from ```word2``` and then try to look ```dictionary``` for that valuse. then it will make it very complex in term of code and time.\\n\\n\\n#### **Code**  \\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  \\n* __Encrypter__:  __O(size_of_keys)__\\n* __encrypt__:  __O(size_of_word1)__\\n* __decrypt__:  __O(size_of_dictionary)__\\n\\n##### Space Complexity:\\n* __O(size_of_dictionary)__\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```keys```\n```values```\n```keys```\n```dictionary```\n```word2```\n```sol```\n```word2```\n```dictionary```\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909251,
                "title": "elegant-pythonic-solution",
                "content": "The `encrypt` is the easiest part of the problem. Create a mapping and you are done.  The `decrypt` and `dictionary` values is a little tricky to figure out and we have basically have to create an inverse frequency map for this.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909075,
                "title": "python-easy-understanding-python-solution",
                "content": "After 1 hour struggled with dp and trie. The question tend to be solved as simple as this \\nLOL\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\\n\\nHere I also  post my Trie + Dp solution, but it is exceed the time limit. I would appricate if anyone could helpe me optimize the solution.\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908808,
                "title": "c-hashmap-trie-dp-dfs",
                "content": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908758,
                "title": "c-hashmap-set",
                "content": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 4080996,
                "title": "very-simple-solution-try-catch-without-trie",
                "content": "# Code\\n```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\nThe Try catch block... its because I didnt want to mannually check for the error. Anyways, if a word causes problem, it wont be there in encrypted dictionary anyways... \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544782,
                "title": "two-maps-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475098,
                "title": "java-trie-hashmap",
                "content": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1956564,
                "title": "python-trie-and-hashmap",
                "content": "`@cache` helps a lot with same queries in test cases.\\n\\n# Trie\\n```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\\n\\n# hashmap\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942851,
                "title": "java-solution-faster-than-25-81-less-than-81-35",
                "content": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930455,
                "title": "this-very-simple-solution-beats-80-while-trie-gets-tle",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926788,
                "title": "simple-java-solution-with-2-maps",
                "content": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920897,
                "title": "c-easy-to-understand-simple-solution-using-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920780,
                "title": "a-few-solutions",
                "content": "Encrypt each string `s` of the input array `A` as `t` and track the count `cnt` of each successfully encrypted `t`.  We use a map `m` to associate each `i`<sup>th</sup> input character of `C` with the corresponding `i`<sup>th</sup> input string of `S` for encryption.\\n\\nNote: we know the encryption successfully transforms input string `s` into output string `t` when the cardinality of `s` is equal to the cardinality of `t` divided evenly by `2` since each single character is encoded as two characters.\\n* `2 * |s| == |t|`\\n\\n---\\n\\n*Kotlin*\\n```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915722,
                "title": "c-using-two-hashmaps-easy-understanding-fastest",
                "content": "Here\\'s the trick:\\nDo not generate all the possible strings after decryption and then count the occurrences in dictionary, TAKE THE REVERSE WAY, encrypt the dictionary and store it in a map, now just return the number of occurrences in that map of the desired string to be decrypted.\\n\\nWe can create 2 hashmaps, \\n- one to map the keys to value, so that we can instantly get the corresponding encryption of a character in O(1) for the encryption method.\\n- other for decryption method, to encrypt all the strings in the dictionary and count the occurences. Now whenever we get a call to decrypt a string, we can direct look it up in the hashmap, and return the count instead of actually decrypting it and checking if it exists in the dictionary.\\n\\nThe Code below would make it much clearer. \\n\\n```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915491,
                "title": "test-cases-can-be-passed-using-a-simple-cache",
                "content": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "solutionTags": [],
                "code": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "codeTag": "Unknown"
            },
            {
                "id": 1915086,
                "title": "javascript-two-hashmaps",
                "content": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911392,
                "title": "easy-to-understand-cpp",
                "content": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1911274,
                "title": "python-trie",
                "content": "Build the trie with encrypted strings in the dictionary. Use c[\\'#\\'] to store the number of occurence. \\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909405,
                "title": "javascript-brain-teaser-390ms",
                "content": "for decrypt() first thinking is do backtracking, and check if match to any of them in dictionary, this way I tried get TLE with 201/203 passed (don\\'t know how to improve)\\n\\nThen I figure out what we need to do is just encrypt each string in dictionary, and see if it match to decrypt (^_^)\\n```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\\nbacktracking tried version, not working TLE 201/203 passed\\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909305,
                "title": "python-simple-short-and-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909172,
                "title": "c-using-hashmap-preprocessing",
                "content": "Simply, encrypt all the strings of *dictionary* in the constructor only and then store the frequency of the encoded string in the *dict* map. Then, return the frequency of the encoded string from the *dict* map int the **decrpyt** method.\\n\\n```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909139,
                "title": "easy-map-solution-in-c-with-comments-without-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1909130,
                "title": "by-using-three-maps",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909101,
                "title": "java-trie",
                "content": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1909063,
                "title": "cheated-solution-make-this-a-easy-problem",
                "content": "Instead of really solving this problem, as the dictionary is super short, we can just do a encryption of all of them when initialize, and store the encrpted->count map.\\n\\n\\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909016,
                "title": "hash-map-bruteforce",
                "content": "\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908959,
                "title": "easy-trie-bfs-python-optimized-code",
                "content": "**Solution 1: Trie**\\n\\n1. Use a trie to store the target words of dict\\n2. Find all combinations using a lookup dict.\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\\n\\n**Solution 2:**\\n\\nInstead of decrypting result for each decrypt() call and then matching it with target list.\\nEncrypt the words in target list and count them. \\nSo each decrypt call can look it up in dict.\\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908949,
                "title": "python-10-liner-o-1-for-decrypt",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908938,
                "title": "simple-java-solution-precompute-o-1-decrypt",
                "content": "Idea is pre-encryting the word in dictionary and store the count in a map. When doing decryption, simply check the map and return the count.\\n```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908927,
                "title": "python-not-trie-just-search-on-the-dictionary",
                "content": "Instead of trie, try to search for each word in the dictionary (because the dictionary size is only 100 and each word in the dictionary is also 100):\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908901,
                "title": "java-dfs-trie",
                "content": "This is the first time I completed all four problems~~~!!!\\n```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908887,
                "title": "c-rainbow-table-solution-and-trie-solution",
                "content": "#### rainbow table \\nA [rainbow table](https://en.wikipedia.org/wiki/Rainbow_table) is a precomputed table for caching the output of cryptographic hash functions, usually for cracking password hashes. \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\\n#### Trie solution \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1908884,
                "title": "c-trie",
                "content": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908873,
                "title": "c-clean-commented-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\nUPvote if you liked my solution.\\nThanks.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908865,
                "title": "java-hashing-easy-to-understand-smart-approach",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. Create an `enc` map which **stores the key value pair** of what each character will **encrypt** to.\\n2. Create a `dictionary` map which will **store the count of each encrypted word** from the `dictionary` string.\\n3. In `encrypt` function, we just take each character from `word1`, and use `enc` map to **encrypt** it.\\n4. In `decrypt` function, we just return the **count of each** `word2` from `dictionary` map.\\n\\n**Source Code:**\\n```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908853,
                "title": "hashmap-solution-o-n-encrypt-o-1-decrypt",
                "content": "pre-built dictionary to encrypt string\\n\\n```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908836,
                "title": "easy-understand-code-no-dfs-no-trie-simple-logic",
                "content": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1908770,
                "title": "python-not-hard-but-confusing",
                "content": "That is, the way this question is worded. We are supposed to use the encryption function we have written to descript efficiently. That\\'s sort of the hint (otherwise it\\'s trivial to code the encryption).\\n\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908735,
                "title": "easy-to-understand-solution-c-unordered-maps",
                "content": "Firstly, we will store all the information present with us in a hashmap so that we can retrieve them faster. The two arrays Keys[] and Values[] can be stored in a single hashmap\\n\\nThe encrypt function is easy to implement. Just traverse through the string \\u2018word1\\u2019 and replace each character with its corresponding value string.\\n\\nThe decrypt function needs only one trick to implement. One may think we can recursively form all the possible strings by taking characters in pairs and encrypt these pairs but this will have a polynomial time complexity since a given pair may have one or more encryption characters.\\n\\n**But we can be a little smart in doing this. Instead of finding all the decryption strings of the given string and check how many of those are present in the dictionary array, we can encrypt all the strings present in the dictionary array, maintain their count using a frequency hashmap and finally check how any time the string \\u2018word2\\u2019 exist in this frequency map. **\\n\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908733,
                "title": "cpp-straight-forward-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018573,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996812,
                "title": "2-typescript-javascript-solutions-reverse-lookup-and-trie",
                "content": "# Code\\n\\n## Using Reverse Lookup (~200ms)\\n(Encrypt all dictionary words and lookup count during decryption.)\\n```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\\n\\n## Using Trie (~1500ms)\\n(Probably the intended solution.)\\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958315,
                "title": "encrypt-decrypt-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design",
                    "Trie"
                ],
                "code": "```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899951,
                "title": "typescript-hash-table-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874459,
                "title": "python-simple-solution-beats-96-92",
                "content": "# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750883,
                "title": "c-solution-without-trie-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676976,
                "title": "python3-hashmap-solution",
                "content": "\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661824,
                "title": "c-python-trie-hash-map-solution-with-explanation",
                "content": "use a hash map to record mapping of letter to values.\\nuse Trie to store word of dictionary after encrypting, if the word  after encrypting is empty string, pass it.\\n\\ntc: \\n__init__ O(len(keys) + O(len(dictionary)))\\nencrypt O(n)\\ndecrypt O(n)\\n\\nsc is O(len(dictionary) * 100)\\n\\n### c++\\n```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613010,
                "title": "straight-forward-solution-187ms-runtime-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor encryption - since for every character in string \\'c\\' present in key[i] we need to fetch values[i], we\\'ll build a dictionary mapping each key[i] to valeus[i] so we can get value associated with each key-character in O(1).\\n\\nFor decryption - since we need to find possible strings in valid \\'dictionary\\' array that we can encrypt to get this string that we are currently trying to decrypt, we can simply encrypt all the possible/valid string provided already in \\'dictionary\\' array, and see how many of those strings can map to same encrypted result (that we are currently tryint to decrypt)\\n\\nFor both of these steps since we need to build dictionaries, we perform the pre-computation steps needed in constructor.\\n\\n![Screenshot 2023-06-08 145030.png](https://assets.leetcode.com/users/images/b0531d62-cd4f-4283-8292-6e2d8fc57fd4_1686216056.4274116.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D*N) -> D is number of words in dictionary and N is the max number of characters in a word (as we are calling Encrypt for each word)\\n**Encrypt** - O(N) -> N is the number of characters in the word to encrypt\\n**Decrypt** - O(1)\\n\\nOverall - O(D*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D) -> D is number of words in dictionary that we are storing in Dictionary\\n**Encrypt** - O(N) -> as we are using a StringBuilder\\n**Decrypt** - O(1)\\n\\nOverall - O(D)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594273,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590876,
                "title": "c-simple-solution-using-two-dictionaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want a keys[i] -> values[i] dictionary to easily encrypt a character in O(1) and a word in O(n) where n is the length of the word.\\n\\nSimilarly, for an O(1) decryption we want to pre-process all of the strings in the given dictionary upon Encrypter construction.\\n\\nThe Encrytper would run in O(n) where n is the number of strings in the dictionary. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a dicitonary mapping chars to strings (keys to values).\\nUse a dicitonary mapping words to count the number of possible strings word2 could decrypt to that also appear in dictionary.\\nProcess the above in Encrypter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(n)\\nDecrypt O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(1)\\nDecrypt O(1)\\n\\n# Code\\n```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405875,
                "title": "simple-java-solution",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352515,
                "title": "c-golang-2-maps",
                "content": "# Code\\n```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284893,
                "title": "c-trie-dfs",
                "content": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283180,
                "title": "c-solution-with-comments",
                "content": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3254331,
                "title": "using-hashmap",
                "content": "\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243268,
                "title": "java-simple-solution-using-hashmap-and-its-methods",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105951,
                "title": "simple-solution-100-faster-using-hashtable-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will save values for encryption and as we have to decrypt word2 and see how many words can be made that lie in dict , so we will make encryption for words in dict and count in how many ways that encryption can be decrypted , so we can simply return in decrypt call .\\n![image.png](https://assets.leetcode.com/users/images/b48e583f-c741-4e4f-b8d9-9b7d0c74e89e_1674834382.4091935.png)\\n\\n# Complexity\\n- Time complexity: O(dict[i]*dict.length + word1.length**calls to encrypt)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899070,
                "title": "golang-hash-map-and-trie",
                "content": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2826497,
                "title": "c-solution-using-little-string-trick",
                "content": "Well, unexpected problem : having problems in adding strings together (-_-) during encryption = time limit exceeded.\\n\\nSolution : Well, just realized that one can just set the resultant string into final size and assign characters to it = what do you know, 100 times faster than adding substrings (which will extend the string but I\\'ve never expected to have such a difference in runtime (-_-)) \\n\\nHa ha (-_-)\\n\\n```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813645,
                "title": "go-solution-with-trie",
                "content": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2806049,
                "title": "2-solutions-using-trie-and-2-maps-easy-to-understand-c",
                "content": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780295,
                "title": "python-solution-using-trie-and-hash-table-o-len-word1-encrypt-and-o-len-word2-decrypt",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779845,
                "title": "rust-solution-with-hashmap-28-ms-6-3-mb",
                "content": "\\nKey Idea :  encrypt and decrypt will be called around 200 times for one new call, so, even if new is slow, if encrypt and decrypt are relatively fast, the whole process would be fast. \\n\\nEncrypt will have to remain O(N) because, we don\\'t know which all words can be encrypted so we can not cache them prior to it\\'s call.\\n\\nDecrypt on the other hand returns how many Strings upon encryption in Dictionary will return that string. Since the dictionary is only initialized once, and has finite number of words with finite length, we can cache it\\'s results in a hashmap. So, if we have the encrypted string as key, we can use that to get the count or return 0.\\n\\nWith some other minor optimizations, we can get the final Space and Time Complexities of the functions like so\\n\\nnew() -> TC : O(N<sup>2</sup>), SC : O(N)\\nEncrypt -> TC : O(N), SC : O(N)\\nDecrypt -> TC : O*(1), SC : O(1)\\n\\n**Note that since we are using a HashMap, the time complexity can get to O(N), however, here since the number of words in dictionary isn\\'t that much, it\\'s O(1).**\\n\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779656,
                "title": "javascript-the-hard-way",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703218,
                "title": "easy-understanding-map",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2665637,
                "title": "one-hashmap-use",
                "content": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599073,
                "title": "kotlin-100-time-and-space-saving-dictionary-in-trie-checking-recursively",
                "content": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521009,
                "title": "c",
                "content": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514185,
                "title": "c-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496934,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488939,
                "title": "encrypt",
                "content": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2488362,
                "title": "python-trie",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483394,
                "title": "just-use-encrypt-for-decrypt-simple-python-solution",
                "content": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2471560,
                "title": "python",
                "content": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2402687,
                "title": "java-hashmap-84",
                "content": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "codeTag": "Java"
            },
            {
                "id": 2309711,
                "title": "javascript-easy-to-undertand-beats-67",
                "content": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286710,
                "title": "javascript-with-pre-encryption",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126251,
                "title": "java-easy-solution-without-using-trie",
                "content": "\\n\\n\\n```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101700,
                "title": "kotlin-simple-ds-to-reverse-check-the-elements-without-a-trie",
                "content": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054508,
                "title": "java-trie",
                "content": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2023323,
                "title": "c-without-trie",
                "content": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973915,
                "title": "c-trie-based-solution",
                "content": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969128,
                "title": "java-trie-based-faster-than-95-mem-less-than-87",
                "content": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962125,
                "title": "c-2227-encrypt-and-decrypt-strings",
                "content": "\\n```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947464,
                "title": "simple-python-solution",
                "content": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1942236,
                "title": "trie-bfs",
                "content": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie",
                    "Queue"
                ],
                "code": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936856,
                "title": "c-simple-solution",
                "content": "*The solution is very intuitive.*\\n**1**. **Encrypt**:\\n\\tFor encryption, we need to replace every char of `word1` by its corresponding value. It is best to use a hashmap to store key, value pairs. So, while encrypting, replace every character by its corresponding value stored in the map `k2v`.\\n\\n**2**. **Decrypt**:\\n\\tSince we need to match every possible decryption with the given dictionary to see how many matches are there, it is better to reverse this approach. So, for every word in the dictionary, calculate the encrypted version and store the count of it in another hashmap `dict` . So, when decrypt function is called, we can just return the count of `dict[word2]`. Thing to note is, while calculating encryptions of words in a dictionary, not every char of a word will be in `k2v keys`. So, for those strings, no encryption is possible and hence we do need to store them (as they will never be able form a word with a possible decryption).\\n\\n```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930872,
                "title": "scala-trie-with-dfs",
                "content": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929920,
                "title": "java-trie-in-40-lines",
                "content": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929334,
                "title": "java-sol-2-maps-and-precompute",
                "content": "Approach,\\n1. Make 2 maps\\n2. One for storing <keys[i],values[i]> pairs.\\n3. Second for storing decrypted string frequencies from dictionary array\\n4. While precomputing dictionary array, make sure not to store invalid decrypted strings\\n5. Below is the implementation for the same.\\n```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928783,
                "title": "c-code-two-hashmap-s-only",
                "content": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926771,
                "title": "java-hashmap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926295,
                "title": "golang-trie",
                "content": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925491,
                "title": "java-trie-dfs-hashmaps",
                "content": "Runtime: 970 ms, faster than 27.23% of Java online submissions for Encrypt and Decrypt Strings.\\nMemory Usage: 509.4 MB, less than 5.06% of Java online submissions for Encrypt and Decrypt Strings.\\n```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924906,
                "title": "python-solution-with-explanation",
                "content": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1920939,
                "title": "swift-hash-map-solution",
                "content": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1920424,
                "title": "cpp-simple-and-clean-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920343,
                "title": "golang-hash-solution",
                "content": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\\n\\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1915872,
                "title": "using-zip-and-dict-in-python",
                "content": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Java"
            },
            {
                "id": 1915670,
                "title": "rust-hashmap-hashset-search-from-dic-word-o-n",
                "content": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914609,
                "title": "c-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913855,
                "title": "using-hashmap-java",
                "content": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1913315,
                "title": "c-solution-using-trie",
                "content": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1913137,
                "title": "c-hashset-and-trie",
                "content": "Basic ideas:\\n1.TLE issue: using dict1 as cache of Encrypt to avoid TLE.\\n2.Build a trie tree by all valid strings from dictionary. Using valid to mark an acceptable decrypt string.\\n\\n```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913134,
                "title": "pre-count-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912932,
                "title": "scala-simple-problem-so-0-need-for-more-than-5-lines-including-all",
                "content": "`encrypt` is easy. Now you might want to use complex algorithm for `decrypt`, but it turns out *(gotcha)*, the dictionary input is always quite small.\\nSo you could pre-encrypt them and make the histogram of encrypted values. When you hit `decrypt`, you simply return the pre-computed counts.\\n\\n```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912816,
                "title": "easy-understanding-c-code-trie",
                "content": "https://github.com/kumarmanish03/DSA-Solved-Questions/blob/main/Tree/Encrypt%20and%20Decrypt%20Strings.cpp\\n\\n```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1912408,
                "title": "rust-translated-from-lee215-s-solution",
                "content": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912223,
                "title": "3-min-hindi-video-simple-hash-solution",
                "content": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "solutionTags": [],
                "code": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "codeTag": "Unknown"
            },
            {
                "id": 1911731,
                "title": "python-simple-use-two-dicts",
                "content": "We just need to use 2 dicts:\\n**dict1**: to map character from *key* to its value in *values* (which will be used in *encrypt*)\\n**dict2**: to map each word in dictionary to its encrypted word using **dict1** and store its count of occurances (which will be used in *decrypt*)\\n\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911486,
                "title": "c-easy-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911396,
                "title": "python-very-simple-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911391,
                "title": "python-three-lines-of-code",
                "content": "This is the easiest hard problem ever. It\\'s just three lines of python code with one line in each class method.\\n\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911346,
                "title": "java-solution-using-trie",
                "content": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911321,
                "title": "most-optimized-code-using-dict",
                "content": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Python3"
            },
            {
                "id": 1911295,
                "title": "easy-c-solution-hashmap-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911250,
                "title": "python3-stupid-easy-solution-with-counter",
                "content": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911205,
                "title": "java-hashmaps-with-trick",
                "content": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1910749,
                "title": "python-3-hashmap-and-counter",
                "content": "Maintain a hashmap and a counter. Hashmap `c2v` converts keys to values, and garanteed by the question all letters in word1 appear in keys. Counter `en_ct` keeps count of encrypted from all words in the dictionary, if word2 is in `en_ct`, return its count, otherwise 0 - word2 not in the dictionary.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910648,
                "title": "java-trie-hashmap-o-n",
                "content": "The idea is to encrypt all dictionary words and create a trie tree of all of them.\\nRoot nodes of the trie tree should hold the dictionary frequency of each encrypted word \\n\\n```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910582,
                "title": "java-hashmap-only-easy-understanding",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910551,
                "title": "c-hashmap-trie",
                "content": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910411,
                "title": "trie-but-failed-very-hard-time-limit",
                "content": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "Trie"
                ],
                "code": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1910319,
                "title": "c-solution-with-trick-making-it-easiest-hard-problem",
                "content": "\\n\\n```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "solutionTags": [],
                "code": "```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910089,
                "title": "map-c",
                "content": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1910027,
                "title": "c-solution",
                "content": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1909945,
                "title": "c-encryption-hashmap-decryption-dfs-trie",
                "content": "**Prerequisite: TRIE**\\nEncrypting the string is straight forward, just store the string for each character in map and You are good to go. Also decryption of string is easy, the only difficult part is verifying the final string from the dictionary. \\n##### TLE for Set: \\nIf we use **set** to store and verify from dictionary, no doubt it will give the correct ans but using so will also increase our runtime. Because, before verifying we will 1st decrypt the whole string and after that we will verify from **Set**. By doing so we are doing redundent searches because its possible that the string doesn\\'t even exists in **set**. \\nSo, we need to find a way to decrypt the string word by word along with verification. Solution to this is Trie, as trie stores the string word by word and level by level.\\n#### Trie Solution:\\n1. Store each word of `dictionary` in trie\\n1. For decryption, use Trie along with DFS. \\n1. Take two character(given) at a time, find it\\'s decryption match from hashmap. Verify the if this character in the word exits in trie or not.\\n*  **Example**: We have a word in Trie, `word` = **\"abbccc\"**,(stored in trie like a->b->b->c->c->c) and we have formed the decrypted string till 3rd character like,`re` = **\"abb\"**. \\n*  Now suppose our next character after decryption is **\\'f\\'**, but **\\'f\\'** does exits in next sequence of characters in **trie**. So, we will stop our search here and **return** **0**. But if it matches, we will continue our search untill there are no more chararcter to decrypt. If we reach at the end of the string, check if the word exits, if it do, **return 1**.\\n\\nBelow is the Implementation.\\n```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```\\n**Upvote if it Helps**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909917,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N), for decryption and O(N) for encryption***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909883,
                "title": "java-simple-code-using-hashmap-100-faster-with-explaination",
                "content": "**Time Complexity :-\\nEncrypter:- O(nlog(n))\\nencrypt:- O(mlog(n)) ; m-> length of provided String\\ndecrypt:- O(mlog(n))\\n\\n**\\n\\n**Explanation :-**\\nComming Soon\\n\\n**JAVA Code :-**\\n```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1909756,
                "title": "c-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```\\n\\n**TIme Complexity of Encrypt : o(no of chars in given word)\\nTime Complexity of Decrypt : O((no_of chars in given word/2) * size_of_dictionary)**\\n\\nSince we are using Trie, there lies atmost size of dictionary paths at the end of last recursion call and other would have been pruned.\\n\\nThe max depth of recursion tree is no_of_chars/2 and max paths is size_of_dictionary.\\nHence Complexity is O((no_of chars in given word/2) * size_of_dictionary).\\n\\n**Note: If you dont pass word by reference in Decrypt dfs function call you would get TLE**",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1834851,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            },
            {
                "id": 2043619,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            }
        ]
    }
]